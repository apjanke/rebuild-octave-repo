# HG changeset patch
# User Max Brister <max@2bass.com>
# Date 1357241710 25200
#      Thu Jan 03 12:35:10 2013 -0700
# Node ID 1f076c40c133fcf2e2d39274663c425750211b6f
# Parent  44f30dcd87e0de84f357a12896cc618c8db600f2
Do not use vectorized llvm commands for complex numbers

* jit-typeinfo.cc (octave_jit_complex_mul): New function.
(jit_typeinfo::jit_typeinfo): Implement complex numbers using an llvm array and
use create_internal/create_external.
(jit_typeinfo::complex_real, jit_typeinfo::complex_imag,
jit_typeinfo::pack_complex, jit_typeinfo::unpack_complex): Implement complex
numbers using an llvm array.
(jit_typeinfo::add_binary_op, jit_typeinfo::add_binary_icmp,
jit_typeinfo::add_binary_fcmp, jit_typeinfo::create_identity,
jit_typeinfo::register_intrinsic, jit_typeinfo::register_generic,
jit_typeinfo::mirror_binary): Use create_internal/create_external.
(jit_typeinfo::type_of): Correctly determine complex type.
* jit-typeinfo.h (jit_typeinfo::create_complex,
jit_typeinfo::create_internal, jit_typeinfo::create_external): New function.

* pt-jit.cc (jit_convert_llvm::visit): Create an array for complex constants.

diff --git a/libinterp/interp-core/jit-typeinfo.cc b/libinterp/interp-core/jit-typeinfo.cc
--- a/libinterp/interp-core/jit-typeinfo.cc
+++ b/libinterp/interp-core/jit-typeinfo.cc
@@ -376,16 +376,25 @@ octave_jit_create_undef (void)
   octave_value undef;
   octave_base_value *ret = undef.internal_rep ();
   ret->grab ();
 
   return ret;
 }
 
 extern "C" Complex
+octave_jit_complex_mul (Complex lhs, Complex rhs)
+{
+  if (lhs.imag () == 0 && rhs.imag() == 0)
+    return Complex (lhs.real () * rhs.real (), 0);
+
+  return lhs * rhs;
+}
+
+extern "C" Complex
 octave_jit_complex_div (Complex lhs, Complex rhs)
 {
   // see src/OPERATORS/op-cs-cs.cc
   if (rhs == 0.0)
     gripe_divide_by_zero ();
 
   return lhs / rhs;
 }
@@ -1013,16 +1022,19 @@ jit_paren_subsasgn::do_initialize (void)
 
 // -------------------- jit_typeinfo --------------------
 void
 jit_typeinfo::initialize (llvm::Module *m, llvm::ExecutionEngine *e)
 {
   new jit_typeinfo (m, e);
 }
 
+// wrap function names to simplify jit_typeinfo::create_external
+#define JIT_FN(fn) engine, &fn, #fn
+
 jit_typeinfo::jit_typeinfo (llvm::Module *m, llvm::ExecutionEngine *e)
   : module (m), engine (e), next_id (0),
     builder (*new llvm::IRBuilderD (context))
 {
   instance = this;
 
   // FIXME: We should be registering types like in octave_value_typeinfo
   llvm::Type *any_t = llvm::StructType::create (context, "octave_base_value");
@@ -1046,17 +1058,17 @@ jit_typeinfo::jit_typeinfo (llvm::Module
   llvm::Type *matrix_contents[5];
   matrix_contents[0] = refcount_t->getPointerTo ();
   matrix_contents[1] = scalar_t->getPointerTo ();
   matrix_contents[2] = index_t;
   matrix_contents[3] = index_t->getPointerTo ();
   matrix_contents[4] = string_t;
   matrix_t->setBody (llvm::makeArrayRef (matrix_contents, 5));
 
-  llvm::Type *complex_t = llvm::VectorType::get (scalar_t, 2);
+  llvm::Type *complex_t = llvm::ArrayType::get (scalar_t, 2);
 
   // complex_ret is what is passed to C functions in order to get calling
   // convention right
   llvm::Type *cmplx_inner_cont[] = {scalar_t, scalar_t};
   llvm::StructType *cmplx_inner = llvm::StructType::create (cmplx_inner_cont);
 
   complex_ret = llvm::StructType::create (context, "complex_ret");
   {
@@ -1117,29 +1129,26 @@ jit_typeinfo::jit_typeinfo (llvm::Module
                                 llvm::GlobalValue::ExternalLinkage, 0,
                                 "octave_interrupt_state");
   engine->addGlobalMapping (loctave_interrupt_state,
                             reinterpret_cast<void *> (&octave_interrupt_state));
 
   // generic call function
   {
     jit_type *int_t = intN (sizeof (octave_builtin::fcn) * 8);
-    any_call = create_function (jit_convention::external, "octave_jit_call",
-                                any, int_t, int_t, any_ptr, int_t);
-    any_call.add_mapping (engine, &octave_jit_call);
+    any_call = create_external (JIT_FN (octave_jit_call), any, int_t, int_t,
+                                any_ptr, int_t);
   }
 
   // any with anything is an any op
   jit_function fn;
   jit_type *binary_op_type = intN (sizeof (octave_value::binary_op) * 8);
   llvm::Type *llvm_bo_type = binary_op_type->to_llvm ();
-  jit_function any_binary = create_function (jit_convention::external,
-                                             "octave_jit_binary_any_any",
+  jit_function any_binary = create_external (JIT_FN (octave_jit_binary_any_any),
                                              any, binary_op_type, any, any);
-  any_binary.add_mapping (engine, &octave_jit_binary_any_any);
   any_binary.mark_can_error ();
   binary_ops.resize (octave_value::num_binary_ops);
   for (size_t i = 0; i < octave_value::num_binary_ops; ++i)
     {
       octave_value::binary_op op = static_cast<octave_value::binary_op> (i);
       std::string op_name = octave_value::binary_op_as_string (op);
       binary_ops[i].stash_name ("binary" + op_name);
     }
@@ -1152,54 +1161,48 @@ jit_typeinfo::jit_typeinfo (llvm::Module
       unary_ops[i].stash_name ("unary" + op_name);
     }
 
   for (int op = 0; op < octave_value::num_binary_ops; ++op)
     {
       llvm::Twine fn_name ("octave_jit_binary_any_any_");
       fn_name = fn_name + llvm::Twine (op);
 
-      fn = create_function (jit_convention::internal, fn_name, any, any, any);
+      fn = create_internal (fn_name, any, any, any);
       fn.mark_can_error ();
       llvm::BasicBlock *block = fn.new_block ();
       builder.SetInsertPoint (block);
       llvm::APInt op_int(sizeof (octave_value::binary_op) * 8, op,
                          std::numeric_limits<octave_value::binary_op>::is_signed);
       llvm::Value *op_as_llvm = llvm::ConstantInt::get (llvm_bo_type, op_int);
       llvm::Value *ret = any_binary.call (builder, op_as_llvm,
                                           fn.argument (builder, 0),
                                           fn.argument (builder, 1));
       fn.do_return (builder, ret);
       binary_ops[op].add_overload (fn);
     }
 
   // grab matrix
-  fn = create_function (jit_convention::external, "octave_jit_grab_matrix",
-                        matrix, matrix);
-  fn.add_mapping (engine, &octave_jit_grab_matrix);
+  fn = create_external (JIT_FN (octave_jit_grab_matrix), matrix, matrix);
   grab_fn.add_overload (fn);
 
   grab_fn.add_overload (create_identity (scalar));
   grab_fn.add_overload (create_identity (scalar_ptr));
   grab_fn.add_overload (create_identity (any_ptr));
   grab_fn.add_overload (create_identity (boolean));
   grab_fn.add_overload (create_identity (complex));
   grab_fn.add_overload (create_identity (index));
 
   // release any
-  fn = create_function (jit_convention::external, "octave_jit_release_any", 0,
-                        any);
-  fn.add_mapping (engine, &octave_jit_release_any);
+  fn = create_external (JIT_FN (octave_jit_release_any), 0, any);
   release_fn.add_overload (fn);
   release_fn.stash_name ("release");
 
   // release matrix
-  fn = create_function (jit_convention::external, "octave_jit_release_matrix",
-                        0, matrix);
-  fn.add_mapping (engine, &octave_jit_release_matrix);
+  fn = create_external (JIT_FN (octave_jit_release_matrix), 0, matrix);
   release_fn.add_overload (fn);
 
   // destroy
   destroy_fn = release_fn;
   destroy_fn.stash_name ("destroy");
   destroy_fn.add_overload (create_identity(scalar));
   destroy_fn.add_overload (create_identity(boolean));
   destroy_fn.add_overload (create_identity(index));
@@ -1213,24 +1216,21 @@ jit_typeinfo::jit_typeinfo (llvm::Module
 
   add_binary_fcmp (scalar, octave_value::op_lt, llvm::CmpInst::FCMP_ULT);
   add_binary_fcmp (scalar, octave_value::op_le, llvm::CmpInst::FCMP_ULE);
   add_binary_fcmp (scalar, octave_value::op_eq, llvm::CmpInst::FCMP_UEQ);
   add_binary_fcmp (scalar, octave_value::op_ge, llvm::CmpInst::FCMP_UGE);
   add_binary_fcmp (scalar, octave_value::op_gt, llvm::CmpInst::FCMP_UGT);
   add_binary_fcmp (scalar, octave_value::op_ne, llvm::CmpInst::FCMP_UNE);
 
-  jit_function gripe_div0 = create_function (jit_convention::external,
-                                             "gripe_divide_by_zero", 0);
-  gripe_div0.add_mapping (engine, &gripe_divide_by_zero);
+  jit_function gripe_div0 = create_external (JIT_FN (gripe_divide_by_zero), 0);
   gripe_div0.mark_can_error ();
 
   // divide is annoying because it might error
-  fn = create_function (jit_convention::internal,
-                        "octave_jit_div_scalar_scalar", scalar, scalar, scalar);
+  fn = create_internal ("octave_jit_div_scalar_scalar", scalar, scalar, scalar);
   fn.mark_can_error ();
 
   llvm::BasicBlock *body = fn.new_block ();
   builder.SetInsertPoint (body);
   {
     llvm::BasicBlock *warn_block = fn.new_block ("warn");
     llvm::BasicBlock *normal_block = fn.new_block ("normal");
 
@@ -1253,166 +1253,108 @@ jit_typeinfo::jit_typeinfo (llvm::Module
   // ldiv is the same as div with the operators reversed
   fn = mirror_binary (fn);
   binary_ops[octave_value::op_ldiv].add_overload (fn);
   binary_ops[octave_value::op_el_ldiv].add_overload (fn);
 
   // In general, the result of scalar ^ scalar is a complex number. We might be
   // able to improve on this if we keep track of the range of values varaibles
   // can take on.
-  fn = create_function (jit_convention::external,
-                        "octave_jit_pow_scalar_scalar", complex, scalar,
+  fn = create_external (JIT_FN (octave_jit_pow_scalar_scalar), complex, scalar,
                         scalar);
-  fn.add_mapping (engine, &octave_jit_pow_scalar_scalar);
   binary_ops[octave_value::op_pow].add_overload (fn);
   binary_ops[octave_value::op_el_pow].add_overload (fn);
 
   // now for unary scalar operations
   // FIXME: Impelment not
-  fn = create_function (jit_convention::internal, "octave_jit_++", scalar,
-                        scalar);
+  fn = create_internal ("octave_jit_++", scalar, scalar);
   body = fn.new_block ();
   builder.SetInsertPoint (body);
   {
     llvm::Value *one = llvm::ConstantFP::get (scalar_t, 1);
     llvm::Value *val = fn.argument (builder, 0);
     val = builder.CreateFAdd (val, one);
     fn.do_return (builder, val);
   }
   unary_ops[octave_value::op_incr].add_overload (fn);
 
-  fn = create_function (jit_convention::internal, "octave_jit_--", scalar,
-                        scalar);
+  fn = create_internal ("octave_jit_--", scalar, scalar);
   body = fn.new_block ();
   builder.SetInsertPoint (body);
   {
     llvm::Value *one = llvm::ConstantFP::get (scalar_t, 1);
     llvm::Value *val = fn.argument (builder, 0);
     val = builder.CreateFSub (val, one);
     fn.do_return (builder, val);
   }
   unary_ops[octave_value::op_decr].add_overload (fn);
 
-  fn = create_function (jit_convention::internal, "octave_jit_uminus", scalar,
-                        scalar);
+  fn = create_internal ("octave_jit_uminus", scalar, scalar);
   body = fn.new_block ();
   builder.SetInsertPoint (body);
   {
     llvm::Value *mone = llvm::ConstantFP::get (scalar_t, -1);
     llvm::Value *val = fn.argument (builder, 0);
     val = builder.CreateFMul (val, mone);
     fn.do_return (builder, val);
   }
 
   fn = create_identity (scalar);
   unary_ops[octave_value::op_uplus].add_overload (fn);
   unary_ops[octave_value::op_transpose].add_overload (fn);
   unary_ops[octave_value::op_hermitian].add_overload (fn);
 
   // now for binary complex operations
-  add_binary_op (complex, octave_value::op_add, llvm::Instruction::FAdd);
-  add_binary_op (complex, octave_value::op_sub, llvm::Instruction::FSub);
+  fn = create_internal ("octave_jit_+_complex_complex", complex, complex,
+                        complex);
+  body = fn.new_block ();
+  builder.SetInsertPoint (body);
+  {
+    llvm::Value *lhs = fn.argument (builder, 0);
+    llvm::Value *rhs = fn.argument (builder, 1);
+    llvm::Value *real = builder.CreateFAdd (complex_real (lhs),
+                                            complex_real (rhs));
+    llvm::Value *imag = builder.CreateFAdd (complex_imag (lhs),
+                                            complex_imag (rhs));
+    fn.do_return (builder, complex_new (real, imag));
+  }
+  binary_ops[octave_value::op_add].add_overload (fn);
 
-  fn = create_function (jit_convention::internal,
-                        "octave_jit_*_complex_complex", complex, complex,
+  fn = create_internal ("octave_jit_-_complex_complex", complex, complex,
                         complex);
   body = fn.new_block ();
   builder.SetInsertPoint (body);
   {
-    // (x0*x1 - y0*y1, x0*y1 + y0*x1) = (x0,y0) * (x1,y1)
-    // We compute this in one vectorized multiplication, a subtraction, and an
-    // addition.
     llvm::Value *lhs = fn.argument (builder, 0);
     llvm::Value *rhs = fn.argument (builder, 1);
-
-    // FIXME: We need a better way of doing this, working with llvm's IR
-    // directly is sort of a pain.
-    llvm::Value *zero = builder.getInt32 (0);
-    llvm::Value *one = builder.getInt32 (1);
-    llvm::Value *two = builder.getInt32 (2);
-    llvm::Value *three = builder.getInt32 (3);
-    llvm::Value *fzero = llvm::ConstantFP::get (scalar_t, 0);
-
-    // we are really dealing with a complex number OR a scalar. That is, if the
-    // complex component is 0, we really have a scalar. This matters in
-    // 0+0i * NaN
-    llvm::BasicBlock *complex_mul = fn.new_block ("complex_mul");
-    llvm::BasicBlock *real_mul = fn.new_block ("real_mul");
-    llvm::BasicBlock *ret_block = fn.new_block ("ret");
-    llvm::Value *temp = builder.CreateFCmpUEQ (complex_imag (lhs), fzero);
-    llvm::Value *temp2 = builder.CreateFCmpUEQ (complex_imag (rhs), fzero);
-    temp = builder.CreateAnd (temp, temp2);
-    builder.CreateCondBr (temp, real_mul, complex_mul);
-
-    builder.SetInsertPoint(real_mul);
-    temp = builder.CreateFMul (complex_real (lhs), complex_real (rhs));
-    llvm::Value *real_branch_ret = complex_new (temp, fzero);
-    builder.CreateBr (ret_block);
+    llvm::Value *real = builder.CreateFSub (complex_real (lhs),
+                                            complex_real (rhs));
+    llvm::Value *imag = builder.CreateFSub (complex_imag (lhs),
+                                            complex_imag (rhs));
+    fn.do_return (builder, complex_new (real, imag));
+  }
+  binary_ops[octave_value::op_sub].add_overload (fn);
 
-    llvm::Type *vec4 = llvm::VectorType::get (scalar_t, 4);
-    llvm::Value *mlhs = llvm::UndefValue::get (vec4);
-    llvm::Value *mrhs = mlhs;
-    builder.SetInsertPoint (complex_mul);
-    temp = complex_real (lhs);
-    mlhs = builder.CreateInsertElement (mlhs, temp, zero);
-    mlhs = builder.CreateInsertElement (mlhs, temp, two);
-    temp = complex_imag (lhs);
-    mlhs = builder.CreateInsertElement (mlhs, temp, one);
-    mlhs = builder.CreateInsertElement (mlhs, temp, three);
-
-    temp = complex_real (rhs);
-    mrhs = builder.CreateInsertElement (mrhs, temp, zero);
-    mrhs = builder.CreateInsertElement (mrhs, temp, three);
-    temp = complex_imag (rhs);
-    mrhs = builder.CreateInsertElement (mrhs, temp, one);
-    mrhs = builder.CreateInsertElement (mrhs, temp, two);
-
-    llvm::Value *mres = builder.CreateFMul (mlhs, mrhs);
-    llvm::Value *tlhs = builder.CreateExtractElement (mres, zero);
-    llvm::Value *trhs = builder.CreateExtractElement (mres, one);
-    llvm::Value *ret_real = builder.CreateFSub (tlhs, trhs);
-
-    tlhs = builder.CreateExtractElement (mres, two);
-    trhs = builder.CreateExtractElement (mres, three);
-    llvm::Value *ret_imag = builder.CreateFAdd (tlhs, trhs);
-    llvm::Value *complex_branch_ret = complex_new (ret_real, ret_imag);
-    builder.CreateBr (ret_block);
-
-    builder.SetInsertPoint (ret_block);
-    llvm::PHINode *merge = llvm::PHINode::Create(complex_t, 2);
-    builder.Insert (merge);
-    merge->addIncoming (real_branch_ret, real_mul);
-    merge->addIncoming (complex_branch_ret, complex_mul);
-    fn.do_return (builder, merge);
-  }
-
+  fn = create_external (JIT_FN (octave_jit_complex_mul),
+                        complex, complex, complex);
   binary_ops[octave_value::op_mul].add_overload (fn);
   binary_ops[octave_value::op_el_mul].add_overload (fn);
 
-  jit_function complex_div = create_function (jit_convention::external,
-                                              "octave_jit_complex_div",
+  jit_function complex_div = create_external (JIT_FN (octave_jit_complex_div),
                                               complex, complex, complex);
-  complex_div.add_mapping (engine, &octave_jit_complex_div);
   complex_div.mark_can_error ();
   binary_ops[octave_value::op_div].add_overload (fn);
   binary_ops[octave_value::op_ldiv].add_overload (fn);
 
-  // fn = mirror_binary (complex_div);
-  // binary_ops[octave_value::op_ldiv].add_overload (fn);
-  // binary_ops[octave_value::op_el_ldiv].add_overload (fn);
-
-  fn = create_function (jit_convention::external,
-                        "octave_jit_pow_complex_complex", complex, complex,
-                        complex);
-  fn.add_mapping (engine, &octave_jit_pow_complex_complex);
+  fn = create_external (JIT_FN (octave_jit_pow_complex_complex), complex,
+                        complex, complex);
   binary_ops[octave_value::op_pow].add_overload (fn);
   binary_ops[octave_value::op_el_pow].add_overload (fn);
 
-  fn = create_function (jit_convention::internal,
-                        "octave_jit_*_scalar_complex", complex, scalar,
+  fn = create_internal ("octave_jit_*_scalar_complex", complex, scalar,
                         complex);
   jit_function mul_scalar_complex = fn;
   body = fn.new_block ();
   builder.SetInsertPoint (body);
   {
     llvm::BasicBlock *complex_mul = fn.new_block ("complex_mul");
     llvm::BasicBlock *scalar_mul = fn.new_block ("scalar_mul");
 
@@ -1425,77 +1367,74 @@ jit_typeinfo::jit_typeinfo (llvm::Module
 
     builder.SetInsertPoint (scalar_mul);
     llvm::Value *temp = complex_real (rhs);
     temp = builder.CreateFMul (lhs, temp);
     fn.do_return (builder, complex_new (temp, fzero), false);
 
 
     builder.SetInsertPoint (complex_mul);
-    temp = complex_new (lhs, lhs);
-    fn.do_return (builder, builder.CreateFMul (temp, rhs));
+    temp = complex_new (builder.CreateFMul (lhs, complex_real (rhs)),
+                        builder.CreateFMul (lhs, complex_imag (rhs)));
+    fn.do_return (builder, temp);
   }
   binary_ops[octave_value::op_mul].add_overload (fn);
   binary_ops[octave_value::op_el_mul].add_overload (fn);
 
 
   fn = mirror_binary (mul_scalar_complex);
   binary_ops[octave_value::op_mul].add_overload (fn);
   binary_ops[octave_value::op_el_mul].add_overload (fn);
 
-  fn = create_function (jit_convention::internal, "octave_jit_+_scalar_complex",
-                        complex, scalar, complex);
+  fn = create_internal ("octave_jit_+_scalar_complex", complex, scalar,
+                        complex);
   body = fn.new_block ();
   builder.SetInsertPoint (body);
   {
     llvm::Value *lhs = fn.argument (builder, 0);
     llvm::Value *rhs = fn.argument (builder, 1);
     llvm::Value *real = builder.CreateFAdd (lhs, complex_real (rhs));
     fn.do_return (builder, complex_real (rhs, real));
   }
   binary_ops[octave_value::op_add].add_overload (fn);
 
   fn = mirror_binary (fn);
   binary_ops[octave_value::op_add].add_overload (fn);
 
-  fn = create_function (jit_convention::internal, "octave_jit_-_complex_scalar",
-                        complex, complex, scalar);
+  fn = create_internal ("octave_jit_-_complex_scalar", complex, complex,
+                        scalar);
   body = fn.new_block ();
   builder.SetInsertPoint (body);
   {
     llvm::Value *lhs = fn.argument (builder, 0);
     llvm::Value *rhs = fn.argument (builder, 1);
     llvm::Value *real = builder.CreateFSub (complex_real (lhs), rhs);
     fn.do_return (builder, complex_real (lhs, real));
   }
   binary_ops[octave_value::op_sub].add_overload (fn);
 
-  fn = create_function (jit_convention::internal, "octave_jit_-_scalar_complex",
-                        complex, scalar, complex);
+  fn = create_internal ("octave_jit_-_scalar_complex", complex, scalar,
+                        complex);
   body = fn.new_block ();
   builder.SetInsertPoint (body);
   {
     llvm::Value *lhs = fn.argument (builder, 0);
     llvm::Value *rhs = fn.argument (builder, 1);
     llvm::Value *real = builder.CreateFSub (lhs, complex_real (rhs));
     fn.do_return (builder, complex_real (rhs, real));
   }
   binary_ops[octave_value::op_sub].add_overload (fn);
 
-  fn = create_function (jit_convention::external,
-                        "octave_jit_pow_scalar_complex", complex, scalar,
+  fn = create_external (JIT_FN (octave_jit_pow_scalar_complex), complex, scalar,
                         complex);
-  fn.add_mapping (engine, &octave_jit_pow_scalar_complex);
   binary_ops[octave_value::op_pow].add_overload (fn);
   binary_ops[octave_value::op_el_pow].add_overload (fn);
 
-  fn = create_function (jit_convention::external,
-                        "octave_jit_pow_complex_scalar", complex, complex,
-                        scalar);
-  fn.add_mapping (engine, &octave_jit_pow_complex_scalar);
+  fn = create_external (JIT_FN (octave_jit_pow_complex_scalar), complex,
+                        complex, scalar);
   binary_ops[octave_value::op_pow].add_overload (fn);
   binary_ops[octave_value::op_el_pow].add_overload (fn);
 
   // now for binary index operators
   add_binary_op (index, octave_value::op_add, llvm::Instruction::Add);
 
   // and binary bool operators
   add_binary_op (boolean, octave_value::op_el_or, llvm::Instruction::Or);
@@ -1504,47 +1443,44 @@ jit_typeinfo::jit_typeinfo (llvm::Module
   // now for printing functions
   print_fn.stash_name ("print");
   add_print (any, reinterpret_cast<void *> (&octave_jit_print_any));
   add_print (scalar, reinterpret_cast<void *> (&octave_jit_print_scalar));
 
   // initialize for loop
   for_init_fn.stash_name ("for_init");
 
-  fn = create_function (jit_convention::internal, "octave_jit_for_range_init",
-                        index, range);
+  fn = create_internal ("octave_jit_for_range_init", index, range);
   body = fn.new_block ();
   builder.SetInsertPoint (body);
   {
     llvm::Value *zero = llvm::ConstantInt::get (index_t, 0);
     fn.do_return (builder, zero);
   }
   for_init_fn.add_overload (fn);
 
   // bounds check for for loop
   for_check_fn.stash_name ("for_check");
 
-  fn = create_function (jit_convention::internal, "octave_jit_for_range_check",
-                        boolean, range, index);
+  fn = create_internal ("octave_jit_for_range_check", boolean, range, index);
   body = fn.new_block ();
   builder.SetInsertPoint (body);
   {
     llvm::Value *nelem
       = builder.CreateExtractValue (fn.argument (builder, 0), 3);
     llvm::Value *idx = fn.argument (builder, 1);
     llvm::Value *ret = builder.CreateICmpULT (idx, nelem);
     fn.do_return (builder, ret);
   }
   for_check_fn.add_overload (fn);
 
   // index variabe for for loop
   for_index_fn.stash_name ("for_index");
 
-  fn = create_function (jit_convention::internal, "octave_jit_for_range_idx",
-                        scalar, range, index);
+  fn = create_internal ("octave_jit_for_range_idx", scalar, range, index);
   body = fn.new_block ();
   builder.SetInsertPoint (body);
   {
     llvm::Value *idx = fn.argument (builder, 1);
     llvm::Value *didx = builder.CreateSIToFP (idx, scalar_t);
     llvm::Value *rng = fn.argument (builder, 0);
     llvm::Value *base = builder.CreateExtractValue (rng, 0);
     llvm::Value *inc = builder.CreateExtractValue (rng, 2);
@@ -1554,23 +1490,20 @@ jit_typeinfo::jit_typeinfo (llvm::Module
     fn.do_return (builder, ret);
   }
   for_index_fn.add_overload (fn);
 
   // logically true
   logically_true_fn.stash_name ("logically_true");
 
   jit_function gripe_nantl
-    = create_function (jit_convention::external,
-                       "octave_jit_gripe_nan_to_logical_conversion", 0);
-  gripe_nantl.add_mapping (engine, &octave_jit_gripe_nan_to_logical_conversion);
+    = create_external (JIT_FN (octave_jit_gripe_nan_to_logical_conversion), 0);
   gripe_nantl.mark_can_error ();
 
-  fn = create_function (jit_convention::internal,
-                        "octave_jit_logically_true_scalar", boolean, scalar);
+  fn = create_internal ("octave_jit_logically_true_scalar", boolean, scalar);
   fn.mark_can_error ();
 
   body = fn.new_block ();
   builder.SetInsertPoint (body);
   {
     llvm::BasicBlock *error_block = fn.new_block ("error");
     llvm::BasicBlock *normal_block = fn.new_block ("normal");
 
@@ -1592,22 +1525,21 @@ jit_typeinfo::jit_typeinfo (llvm::Module
   // logically_true boolean
   fn = create_identity (boolean);
   logically_true_fn.add_overload (fn);
 
   // make_range
   // FIXME: May be benificial to implement all in LLVM
   make_range_fn.stash_name ("make_range");
   jit_function compute_nelem
-    = create_function (jit_convention::external, "octave_jit_compute_nelem",
+    = create_external (JIT_FN (octave_jit_compute_nelem),
                        index, scalar, scalar, scalar);
-  compute_nelem.add_mapping (engine, &octave_jit_compute_nelem);
+
 
-  fn = create_function (jit_convention::internal, "octave_jit_make_range",
-                        range, scalar, scalar, scalar);
+  fn = create_internal ("octave_jit_make_range", range, scalar, scalar, scalar);
   body = fn.new_block ();
   builder.SetInsertPoint (body);
   {
     llvm::Value *base = fn.argument (builder, 0);
     llvm::Value *limit = fn.argument (builder, 1);
     llvm::Value *inc = fn.argument (builder, 2);
     llvm::Value *nelem = compute_nelem.call (builder, base, limit, inc);
 
@@ -1622,27 +1554,22 @@ jit_typeinfo::jit_typeinfo (llvm::Module
     fn.do_return (builder, rng);
   }
   make_range_fn.add_overload (fn);
 
   // paren_subsref
   jit_type *jit_int = intN (sizeof (int) * 8);
   llvm::Type *int_t = jit_int->to_llvm ();
   jit_function ginvalid_index
-    = create_function (jit_convention::external, "octave_jit_ginvalid_index",
-                       0);
-  ginvalid_index.add_mapping (engine, &octave_jit_ginvalid_index);
-  jit_function gindex_range = create_function (jit_convention::external,
-                                               "octave_jit_gindex_range",
+    = create_external (JIT_FN (octave_jit_ginvalid_index), 0);
+  jit_function gindex_range = create_external (JIT_FN (octave_jit_gindex_range),
                                                0, jit_int, jit_int, index,
                                                index);
-  gindex_range.add_mapping (engine, &octave_jit_gindex_range);
 
-  fn = create_function (jit_convention::internal, "()subsref", scalar, matrix,
-                        scalar);
+  fn = create_internal ("()subsref", scalar, matrix, scalar);
   fn.mark_can_error ();
 
   body = fn.new_block ();
   builder.SetInsertPoint (body);
   {
     llvm::Value *one = llvm::ConstantInt::get (index_t, 1);
     llvm::Value *ione;
     if (index_t == int_t)
@@ -1701,22 +1628,21 @@ jit_typeinfo::jit_typeinfo (llvm::Module
     fn.do_return (builder, merge);
   }
   paren_subsref_fn.add_overload (fn);
 
   // paren subsasgn
   paren_subsasgn_fn.stash_name ("()subsasgn");
 
   jit_function resize_paren_subsasgn
-    = create_function (jit_convention::external,
-                       "octave_jit_paren_subsasgn_impl", matrix, matrix, index,
-                       scalar);
-  resize_paren_subsasgn.add_mapping (engine, &octave_jit_paren_subsasgn_impl);
-  fn = create_function (jit_convention::internal, "octave_jit_paren_subsasgn",
-                        matrix, matrix, scalar, scalar);
+    = create_external (JIT_FN (octave_jit_paren_subsasgn_impl), matrix, matrix,
+                       index, scalar);
+
+  fn = create_internal ("octave_jit_paren_subsasgn", matrix, matrix, scalar,
+                        scalar);
   fn.mark_can_error ();
   body = fn.new_block ();
   builder.SetInsertPoint (body);
   {
     llvm::Value *one = llvm::ConstantInt::get (index_t, 1);
 
     llvm::Value *mat = fn.argument (builder, 0);
     llvm::Value *idx = fn.argument (builder, 1);
@@ -1769,114 +1695,92 @@ jit_typeinfo::jit_typeinfo (llvm::Module
     builder.Insert (merge);
     merge->addIncoming (mat, conv_error);
     merge->addIncoming (resize_result, bounds_error);
     merge->addIncoming (mat, success);
     fn.do_return (builder, merge);
   }
   paren_subsasgn_fn.add_overload (fn);
 
-  fn = create_function (jit_convention::external,
-                        "octave_jit_paren_subsasgn_matrix_range", matrix,
+  fn = create_external (JIT_FN (octave_jit_paren_subsasgn_matrix_range), matrix,
                         matrix, range, scalar);
-  fn.add_mapping (engine, &octave_jit_paren_subsasgn_matrix_range);
   fn.mark_can_error ();
   paren_subsasgn_fn.add_overload (fn);
 
   end1_fn.stash_name ("end1");
-  fn = create_function (jit_convention::internal, "octave_jit_end1_matrix",
-                        scalar, matrix, index, index);
+  fn = create_internal ("octave_jit_end1_matrix", scalar, matrix, index, index);
   body = fn.new_block ();
   builder.SetInsertPoint (body);
   {
     llvm::Value *mat = fn.argument (builder, 0);
     llvm::Value *ret = builder.CreateExtractValue (mat, 2);
     fn.do_return (builder, builder.CreateSIToFP (ret, scalar_t));
   }
   end1_fn.add_overload (fn);
 
   end_fn.stash_name ("end");
-  fn = create_function (jit_convention::external, "octave_jit_end_matrix",
-                        scalar, matrix, index, index);
+  fn = create_external (JIT_FN (octave_jit_end_matrix),scalar, matrix, index,
+                        index);
   end_fn.add_overload (fn);
 
   // -------------------- create_undef --------------------
   create_undef_fn.stash_name ("create_undef");
-  fn = create_function (jit_convention::external, "octave_jit_create_undef",
-                        any);
+  fn = create_external (JIT_FN (octave_jit_create_undef), any);
   create_undef_fn.add_overload (fn);
 
   casts[any->type_id ()].stash_name ("(any)");
   casts[scalar->type_id ()].stash_name ("(scalar)");
   casts[complex->type_id ()].stash_name ("(complex)");
   casts[matrix->type_id ()].stash_name ("(matrix)");
   casts[range->type_id ()].stash_name ("(range)");
 
   // cast any <- matrix
-  fn = create_function (jit_convention::external, "octave_jit_cast_any_matrix",
-                        any, matrix);
-  fn.add_mapping (engine, &octave_jit_cast_any_matrix);
+  fn = create_external (JIT_FN (octave_jit_cast_any_matrix), any, matrix);
   casts[any->type_id ()].add_overload (fn);
 
   // cast matrix <- any
-  fn = create_function (jit_convention::external, "octave_jit_cast_matrix_any",
-                        matrix, any);
-  fn.add_mapping (engine, &octave_jit_cast_matrix_any);
+  fn = create_external (JIT_FN (octave_jit_cast_matrix_any), matrix, any);
   casts[matrix->type_id ()].add_overload (fn);
 
   // cast any <- range
-  fn = create_function (jit_convention::external, "octave_jit_cast_any_range",
-                        any, range);
-  fn.add_mapping (engine, &octave_jit_cast_any_range);
+  fn = create_external (JIT_FN (octave_jit_cast_any_range), any, range);
   casts[any->type_id ()].add_overload (fn);
 
   // cast range <- any
-  fn = create_function (jit_convention::external, "octave_jit_cast_range_any",
-                        range, any);
-  fn.add_mapping (engine, &octave_jit_cast_range_any);
+  fn = create_external (JIT_FN (octave_jit_cast_range_any), range, any);
   casts[range->type_id ()].add_overload (fn);
 
   // cast any <- scalar
-  fn = create_function (jit_convention::external, "octave_jit_cast_any_scalar",
-                        any, scalar);
-  fn.add_mapping (engine, &octave_jit_cast_any_scalar);
+  fn = create_external (JIT_FN (octave_jit_cast_any_scalar), any, scalar);
   casts[any->type_id ()].add_overload (fn);
 
   // cast scalar <- any
-  fn = create_function (jit_convention::external, "octave_jit_cast_scalar_any",
-                        scalar, any);
-  fn.add_mapping (engine, &octave_jit_cast_scalar_any);
+  fn = create_external (JIT_FN (octave_jit_cast_scalar_any), scalar, any);
   casts[scalar->type_id ()].add_overload (fn);
 
   // cast any <- complex
-  fn = create_function (jit_convention::external, "octave_jit_cast_any_complex",
-                        any, complex);
-  fn.add_mapping (engine, &octave_jit_cast_any_complex);
+  fn = create_external (JIT_FN (octave_jit_cast_any_complex), any, complex);
   casts[any->type_id ()].add_overload (fn);
 
   // cast complex <- any
-  fn = create_function (jit_convention::external, "octave_jit_cast_complex_any",
-                        complex, any);
-  fn.add_mapping (engine, &octave_jit_cast_complex_any);
+  fn = create_external (JIT_FN (octave_jit_cast_complex_any), complex, any);
   casts[complex->type_id ()].add_overload (fn);
 
   // cast complex <- scalar
-  fn = create_function (jit_convention::internal,
-                        "octave_jit_cast_complex_scalar", complex, scalar);
+  fn = create_internal ("octave_jit_cast_complex_scalar", complex, scalar);
   body = fn.new_block ();
   builder.SetInsertPoint (body);
   {
     llvm::Value *zero = llvm::ConstantFP::get (scalar_t, 0);
     fn.do_return (builder, complex_new (fn.argument (builder, 0), zero));
   }
   casts[complex->type_id ()].add_overload (fn);
 
   // cast scalar <- complex
-  fn = create_function (jit_convention::internal,
-                        "octave_jit_cast_scalar_complex", scalar, complex);
+  fn = create_internal ("octave_jit_cast_scalar_complex", scalar, complex);
   body = fn.new_block ();
   builder.SetInsertPoint (body);
   fn.do_return (builder, complex_real (fn.argument (builder, 0)));
   casts[scalar->type_id ()].add_overload (fn);
 
   // cast any <- any
   fn = create_identity (any);
   casts[any->type_id ()].add_overload (fn);
@@ -1929,19 +1833,18 @@ jit_typeinfo::jit_typeinfo (llvm::Module
   register_generic ("eye", matrix, scalar);
   register_generic ("eye", matrix, std::vector<jit_type *> (2, scalar));
 
   add_builtin ("mod");
   register_generic ("mod", scalar, std::vector<jit_type *> (2, scalar));
 
   casts.resize (next_id + 1);
   jit_function any_id = create_identity (any);
-  jit_function grab_any = create_function (jit_convention::external,
-                                           "octave_jit_grab_any", any, any);
-  grab_any.add_mapping (engine, &octave_jit_grab_any);
+  jit_function grab_any = create_external (JIT_FN (octave_jit_grab_any),
+                                           any, any);
   jit_function release_any = get_release (any);
   std::vector<jit_type *> args;
   args.resize (1);
 
   for (std::map<std::string, jit_type *>::iterator iter = builtins.begin ();
        iter != builtins.end (); ++iter)
     {
       jit_type *btype = iter->second;
@@ -1976,33 +1879,30 @@ jit_typeinfo::new_type (const std::strin
   return ret;
 }
 
 void
 jit_typeinfo::add_print (jit_type *ty, void *fptr)
 {
   std::stringstream name;
   name << "octave_jit_print_" << ty->name ();
-  jit_function fn = create_function (jit_convention::external, name.str (), 0,
-                                     intN (8), ty);
-  fn.add_mapping (engine, fptr);
+  jit_function fn = create_external (engine, fptr, name.str (), 0, intN (8), ty);
   print_fn.add_overload (fn);
 }
 
 // FIXME: cp between add_binary_op, add_binary_icmp, and add_binary_fcmp
 void
 jit_typeinfo::add_binary_op (jit_type *ty, int op, int llvm_op)
 {
   std::stringstream fname;
   octave_value::binary_op ov_op = static_cast<octave_value::binary_op>(op);
   fname << "octave_jit_" << octave_value::binary_op_as_string (ov_op)
         << "_" << ty->name ();
 
-  jit_function fn = create_function (jit_convention::internal, fname.str (),
-                                        ty, ty, ty);
+  jit_function fn = create_internal (fname.str (), ty, ty, ty);
   llvm::BasicBlock *block = fn.new_block ();
   builder.SetInsertPoint (block);
   llvm::Instruction::BinaryOps temp
     = static_cast<llvm::Instruction::BinaryOps>(llvm_op);
 
   llvm::Value *ret = builder.CreateBinOp (temp, fn.argument (builder, 0),
                                           fn.argument (builder, 1));
   fn.do_return (builder, ret);
@@ -2012,18 +1912,17 @@ jit_typeinfo::add_binary_op (jit_type *t
 void
 jit_typeinfo::add_binary_icmp (jit_type *ty, int op, int llvm_op)
 {
   std::stringstream fname;
   octave_value::binary_op ov_op = static_cast<octave_value::binary_op>(op);
   fname << "octave_jit" << octave_value::binary_op_as_string (ov_op)
         << "_" << ty->name ();
 
-  jit_function fn = create_function (jit_convention::internal, fname.str (),
-                                     boolean, ty, ty);
+  jit_function fn = create_internal (fname.str (), boolean, ty, ty);
   llvm::BasicBlock *block = fn.new_block ();
   builder.SetInsertPoint (block);
   llvm::CmpInst::Predicate temp
     = static_cast<llvm::CmpInst::Predicate>(llvm_op);
   llvm::Value *ret = builder.CreateICmp (temp, fn.argument (builder, 0),
                                          fn.argument (builder, 1));
   fn.do_return (builder, ret);
   binary_ops[op].add_overload (fn);
@@ -2032,18 +1931,17 @@ jit_typeinfo::add_binary_icmp (jit_type 
 void
 jit_typeinfo::add_binary_fcmp (jit_type *ty, int op, int llvm_op)
 {
   std::stringstream fname;
   octave_value::binary_op ov_op = static_cast<octave_value::binary_op>(op);
   fname << "octave_jit" << octave_value::binary_op_as_string (ov_op)
         << "_" << ty->name ();
 
-  jit_function fn = create_function (jit_convention::internal, fname.str (),
-                                     boolean, ty, ty);
+  jit_function fn = create_internal (fname.str (), boolean, ty, ty);
   llvm::BasicBlock *block = fn.new_block ();
   builder.SetInsertPoint (block);
   llvm::CmpInst::Predicate temp
     = static_cast<llvm::CmpInst::Predicate>(llvm_op);
   llvm::Value *ret = builder.CreateFCmp (temp, fn.argument (builder, 0),
                                          fn.argument (builder, 1));
   fn.do_return (builder, ret);
   binary_ops[op].add_overload (fn);
@@ -2064,19 +1962,18 @@ jit_typeinfo::create_identity (jit_type 
   size_t id = type->type_id ();
   if (id >= identities.size ())
     identities.resize (id + 1);
 
   if (! identities[id].valid ())
     {
       std::stringstream name;
       name << "id_" << type->name ();
-      jit_function fn = create_function (jit_convention::internal, name.str (),
-                                         type, type);
 
+      jit_function fn = create_internal (name.str (), type, type);
       llvm::BasicBlock *body = fn.new_block ();
       builder.SetInsertPoint (body);
       fn.do_return (builder, fn.argument (builder, 0));
       return identities[id] = fn;
     }
 
   return identities[id];
 }
@@ -2125,18 +2022,17 @@ jit_typeinfo::register_intrinsic (const 
 
   std::vector<jit_type *> args1 (nargs + 1);
   args1[0] = builtin_type;
   std::copy (args.begin (), args.end (), args1.begin () + 1);
 
   // The first argument will be the Octave function, but we already know that
   // the function call is the equivalent of the intrinsic, so we ignore it and
   // call the intrinsic with the remaining arguments.
-  jit_function fn = create_function (jit_convention::internal, fn_name.str (),
-                                     result, args1);
+  jit_function fn = create_internal (fn_name.str (), result, args1);
   llvm::BasicBlock *body = fn.new_block ();
   builder.SetInsertPoint (body);
 
   llvm::SmallVector<llvm::Value *, 5> fargs (nargs);
   for (size_t i = 0; i < nargs; ++i)
     fargs[i] = fn.argument (builder, i + 1);
 
   llvm::Value *ret = builder.CreateCall (ifun, fargs);
@@ -2159,18 +2055,17 @@ jit_typeinfo::register_generic (const st
 {
   octave_builtin *builtin = find_builtin (name);
   if (! builtin)
     return;
 
   std::vector<jit_type *> fn_args (args.size () + 1);
   fn_args[0] = builtins[name];
   std::copy (args.begin (), args.end (), fn_args.begin () + 1);
-  jit_function fn = create_function (jit_convention::internal, name, result,
-                                     fn_args);
+  jit_function fn = create_internal (name, result, fn_args);
   fn.mark_can_error ();
   llvm::BasicBlock *block = fn.new_block ();
   builder.SetInsertPoint (block);
   llvm::Type *any_t = any->to_llvm ();
   llvm::ArrayType *array_t = llvm::ArrayType::get (any_t, args.size ());
   llvm::Value *array = llvm::UndefValue::get (array_t);
   for (size_t i = 0; i < args.size (); ++i)
     {
@@ -2198,18 +2093,17 @@ jit_typeinfo::register_generic (const st
   jit_function cast_result = cast (result, any);
   fn.do_return (builder, cast_result.call (builder, ret));
   paren_subsref_fn.add_overload (fn);
 }
 
 jit_function
 jit_typeinfo::mirror_binary (const jit_function& fn)
 {
-  jit_function ret = create_function (jit_convention::internal,
-                                      fn.name () + "_reverse",
+  jit_function ret = create_internal (fn.name () + "_reverse",
                                       fn.result (), fn.argument_type (1),
                                       fn.argument_type (0));
   if (fn.can_error ())
     ret.mark_can_error ();
 
   llvm::BasicBlock *body = ret.new_block ();
   builder.SetInsertPoint (body);
   llvm::Value *result = fn.call (builder, ret.argument (builder, 1),
@@ -2221,18 +2115,18 @@ jit_typeinfo::mirror_binary (const jit_f
 
   return ret;
 }
 
 llvm::Value *
 jit_typeinfo::pack_complex (llvm::IRBuilderD& bld, llvm::Value *cplx)
 {
   llvm::Type *complex_ret = instance->complex_ret;
-  llvm::Value *real = bld.CreateExtractElement (cplx, bld.getInt32 (0));
-  llvm::Value *imag = bld.CreateExtractElement (cplx, bld.getInt32 (1));
+  llvm::Value *real = bld.CreateExtractValue (cplx, 0);
+  llvm::Value *imag = bld.CreateExtractValue (cplx, 1);
   llvm::Value *ret = llvm::UndefValue::get (complex_ret);
 
   unsigned int re_idx[] = {0, 0};
   unsigned int im_idx[] = {0, 1};
   ret = bld.CreateInsertValue (ret, real, re_idx);
   return bld.CreateInsertValue (ret, imag, im_idx);
 }
 
@@ -2242,42 +2136,42 @@ jit_typeinfo::unpack_complex (llvm::IRBu
   unsigned int re_idx[] = {0, 0};
   unsigned int im_idx[] = {0, 1};
 
   llvm::Type *complex_t = get_complex ()->to_llvm ();
   llvm::Value *real = bld.CreateExtractValue (result, re_idx);
   llvm::Value *imag = bld.CreateExtractValue (result, im_idx);
   llvm::Value *ret = llvm::UndefValue::get (complex_t);
 
-  ret = bld.CreateInsertElement (ret, real, bld.getInt32 (0));
-  return bld.CreateInsertElement (ret, imag, bld.getInt32 (1));
+  ret = bld.CreateInsertValue (ret, real, 0);
+  return bld.CreateInsertValue (ret, imag, 1);
 }
 
 llvm::Value *
 jit_typeinfo::complex_real (llvm::Value *cx)
 {
-  return builder.CreateExtractElement (cx, builder.getInt32 (0));
+  return builder.CreateExtractValue (cx, 0);
 }
 
 llvm::Value *
 jit_typeinfo::complex_real (llvm::Value *cx, llvm::Value *real)
 {
-  return builder.CreateInsertElement (cx, real, builder.getInt32 (0));
+  return builder.CreateInsertValue (cx, real, 0);
 }
 
 llvm::Value *
 jit_typeinfo::complex_imag (llvm::Value *cx)
 {
-  return builder.CreateExtractElement (cx, builder.getInt32 (1));
+  return builder.CreateExtractValue (cx, 1);
 }
 
 llvm::Value *
 jit_typeinfo::complex_imag (llvm::Value *cx, llvm::Value *imag)
 {
-  return builder.CreateInsertElement (cx, imag, builder.getInt32 (1));
+  return builder.CreateInsertValue (cx, imag, 1);
 }
 
 llvm::Value *
 jit_typeinfo::complex_new (llvm::Value *real, llvm::Value *imag)
 {
   llvm::Value *ret = llvm::UndefValue::get (complex->to_llvm ());
   ret = complex_real (ret, real);
   return complex_imag (ret, imag);
@@ -2328,16 +2222,16 @@ jit_typeinfo::do_type_of (const octave_v
     }
 
   if (ov.is_complex_scalar ())
     {
       Complex cv = ov.complex_value ();
 
       // We don't really represent complex values, instead we represent
       // complex_or_scalar. If the imag value is zero, we assume a scalar.
-      if (cv.imag () == 0)
+      if (cv.imag () != 0)
         return get_complex ();
     }
 
   return get_any ();
 }
 
 #endif
diff --git a/libinterp/interp-core/jit-typeinfo.h b/libinterp/interp-core/jit-typeinfo.h
--- a/libinterp/interp-core/jit-typeinfo.h
+++ b/libinterp/interp-core/jit-typeinfo.h
@@ -581,16 +581,21 @@ public:
   {
     return instance->do_end (value, index, count);
   }
 
   static const jit_operation& create_undef (void)
   {
     return instance->create_undef_fn;
   }
+
+  static llvm::Value *create_complex (llvm::Value *real, llvm::Value *imag)
+  {
+    return instance->complex_new (real, imag);
+  }
 private:
   jit_typeinfo (llvm::Module *m, llvm::ExecutionEngine *e);
 
   // FIXME: Do these methods really need to be in jit_typeinfo?
   jit_type *do_join (jit_type *lhs, jit_type *rhs)
   {
     // empty case
     if (! lhs)
@@ -668,25 +673,63 @@ private:
   void add_print (jit_type *ty, void *fptr);
 
   void add_binary_op (jit_type *ty, int op, int llvm_op);
 
   void add_binary_icmp (jit_type *ty, int op, int llvm_op);
 
   void add_binary_fcmp (jit_type *ty, int op, int llvm_op);
 
+  // create a function with an external calling convention
+  // forces the function pointer to be specified
+  template <typename T>
+  jit_function create_external (llvm::ExecutionEngine *ee, T fn,
+                                const llvm::Twine& name, jit_type *ret,
+                                const std::vector<jit_type *>& args
+                                = std::vector<jit_type *> ())
+  {
+    jit_function retval = create_function (jit_convention::external, name, ret,
+                                           args);
+    retval.add_mapping (ee, fn);
+    return retval;
+  }
+
+#define JIT_PARAM_ARGS llvm::ExecutionEngine *ee, T fn,     \
+    const llvm::Twine& name, jit_type *ret,
+#define JIT_PARAMS ee, fn, name, ret,
+#define CREATE_FUNCTION(N) JIT_EXPAND(template <typename T> jit_function, \
+                                      create_external,                  \
+                                      jit_type *, /* empty */, N)
+
+  CREATE_FUNCTION(1);
+  CREATE_FUNCTION(2);
+  CREATE_FUNCTION(3);
+  CREATE_FUNCTION(4);
+
+#undef JIT_PARAM_ARGS
+#undef JIT_PARAMS
+#undef CREATE_FUNCTION
+
+  // use create_external or create_internal directly
   jit_function create_function (jit_convention::type cc,
                                 const llvm::Twine& name, jit_type *ret,
                                 const std::vector<jit_type *>& args
                                 = std::vector<jit_type *> ());
 
-#define JIT_PARAM_ARGS jit_convention::type cc, const llvm::Twine& name, \
-    jit_type *ret,
-#define JIT_PARAMS cc, name, ret,
-#define CREATE_FUNCTION(N) JIT_EXPAND(jit_function, create_function,    \
+  // create an internal calling convention (a function defined in llvm)
+  jit_function create_internal (const llvm::Twine& name, jit_type *ret,
+                                const std::vector<jit_type *>& args
+                                = std::vector<jit_type *> ())
+  {
+    return create_function (jit_convention::internal, name, ret, args);
+  }
+
+#define JIT_PARAM_ARGS const llvm::Twine& name, jit_type *ret,
+#define JIT_PARAMS name, ret,
+#define CREATE_FUNCTION(N) JIT_EXPAND(jit_function, create_internal,    \
                                       jit_type *, /* empty */, N)
 
   CREATE_FUNCTION(1);
   CREATE_FUNCTION(2);
   CREATE_FUNCTION(3);
   CREATE_FUNCTION(4);
 
 #undef JIT_PARAM_ARGS
diff --git a/libinterp/interp-core/pt-jit.cc b/libinterp/interp-core/pt-jit.cc
--- a/libinterp/interp-core/pt-jit.cc
+++ b/libinterp/interp-core/pt-jit.cc
@@ -1251,21 +1251,20 @@ jit_convert_llvm::visit (jit_const_scala
 {
   cs.stash_llvm (llvm::ConstantFP::get (cs.type_llvm (), cs.value ()));
 }
 
 void
 jit_convert_llvm::visit (jit_const_complex& cc)
 {
   llvm::Type *scalar_t = jit_typeinfo::get_scalar_llvm ();
-  llvm::Constant *values[2];
   Complex value = cc.value ();
-  values[0] = llvm::ConstantFP::get (scalar_t, value.real ());
-  values[1] = llvm::ConstantFP::get (scalar_t, value.imag ());
-  cc.stash_llvm (llvm::ConstantVector::get (values));
+  llvm::Value *real = llvm::ConstantFP::get (scalar_t, value.real ());
+  llvm::Value *imag = llvm::ConstantFP::get (scalar_t, value.imag ());
+  cc.stash_llvm (jit_typeinfo::create_complex (real, imag));
 }
 
 void jit_convert_llvm::visit (jit_const_index& ci)
 {
   ci.stash_llvm (llvm::ConstantInt::get (ci.type_llvm (), ci.value ()));
 }
 
 void
