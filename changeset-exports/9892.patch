# HG changeset patch
# User Kacper Kowalik <xarthisius.kk@gmail.com>
# Date 1259624947 -3600
#      Tue Dec 01 00:49:07 2009 +0100
# Node ID ac69e6f4b33d43e3779259969db5aed2af15eb4a
# Parent  1506a17832c95a7418a69305e49c9a114317eaf9
Add HDF5-1.8 compatibility while maintaining compatibility with HDF5-1.6 versions

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,16 @@
+2009-11-30  Kacper Kowalik <xarthisius.kk@gmail.com>
+
+	* acinclude.m4 (OCTAVE_HDF5_HAS_ENFORCED_16_API): New macro that
+	tests whether the HDF5 library has an enforced v1.6 API and detects
+	v1.8 APIs.
+	* configure.m4: Adapt test for HDF5 libraries to support v1.8 
+	HDF5 libraries.
+
 2009-11-29  Jaroslav Hajek  <highegg@gmail.com>
 
 	* NEWS: Update.
 
 2009-11-27  David Bateman  <dbateman@free.fr>
 
 	* configure.ac (HAVE_H5GGET_NUM_OBJS) Remove define.
 
diff --git a/acinclude.m4 b/acinclude.m4
--- a/acinclude.m4
+++ b/acinclude.m4
@@ -1054,30 +1054,27 @@ AC_DEFUN([OCTAVE_HDF5_DLL], [
       CFLAGS="$save_CFLAGS"
       LIBS="$save_LIBS"])])
   if test "$octave_cv_hdf5_dll" = yes; then
     AC_DEFINE(_HDF5USEDLL_, 1, [Define if using HDF5 dll (Win32)])
   fi])
 dnl
 dnl Check whether HDF5 library has version 1.6 API functions.
 dnl
-AC_DEFUN([OCTAVE_HDF5_HAS_REQUIRED_API], [
-  AC_CACHE_CHECK([whether HDF5 library has required API],
-    octave_cv_hdf5_has_required_api, [
+AC_DEFUN([OCTAVE_HDF5_HAS_ENFORCED_16_API], [
+  AC_CACHE_CHECK([whether HDF5 library has enforced version 1.6 API],
+    octave_cv_hdf5_has_enforced_16_api, [
     AC_TRY_LINK([
-#define H5_USE_16_API 1
 #include <hdf5.h>
 ], [
   H5Eset_auto (0, 0);], [
-      octave_cv_hdf5_has_required_api=yes], [
-      octave_cv_hdf5_has_required_api=no])])
-  if test "$octave_cv_hdf5_has_required_api" = "no"; then
-    octave_hdf5_ok=no
-    warn_hdf5="HDF5 library does not provide the version 1.6 API.  Octave will not be able to save or load HDF5 data files."
-    AC_MSG_WARN($warn_hdf5)
+      octave_cv_hdf5_has_enforced_16_api=yes], [
+      octave_cv_hdf5_has_enforced_16_api=no])])
+  if test "$octave_cv_hdf5_has_enforced_16_api" != "yes"; then
+    AC_DEFINE(HAVE_HDF5_18, 1, [Define if >=HDF5-1.8 is available.])
   fi
 ])
 dnl
 dnl Check for the QHull version.
 dnl
 AC_DEFUN([OCTAVE_CHECK_QHULL_VERSION],
   [AC_CACHE_CHECK([for qh_version in $QHULL_LIBS],
     octave_cv_lib_qhull_version,  [
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -626,26 +626,25 @@ OCTAVE_CHECK_LIBRARY(z, ZLIB,
 save_CPPFLAGS="$CPPFLAGS"
 CPPFLAGS="$Z_CPPFLAGS $CPPFLAGS"
 save_LIBS="$LIBS"
 LIBS="$Z_LDFLAGS $Z_LIBS $LIBS"
 OCTAVE_CHECK_LIBRARY(hdf5, HDF5,
   [HDF5 library not found.  Octave will not be able to save or load HDF5 data files.],
   [hdf5.h], [H5Gget_num_objs], [], [],
   [warn_hdf5=
-   OCTAVE_HDF5_HAS_REQUIRED_API
-   if test $octave_hdf5_ok = yes; then
-     TEXINFO_HDF5="@set HAVE_HDF5"
-     AC_DEFINE(HAVE_HDF5, 1, [Define if HDF5 is available.])
-     case "$canonical_host_type" in
-       *-*-msdosmsvc)
-	 OCTAVE_HDF5_DLL
-	 ;;
-     esac
-   fi])
+   OCTAVE_HDF5_HAS_ENFORCED_16_API
+   TEXINFO_HDF5="@set HAVE_HDF5"
+   AC_DEFINE(HAVE_HDF5, 1, [Define if HDF5 is available and newer than version 1.6.])
+   case "$canonical_host_type" in
+     *-*-msdosmsvc)
+       OCTAVE_HDF5_DLL
+       ;;
+   esac
+   ])
 CPPFLAGS="$save_CPPFLAGS"
 LIBS="$save_LIBS"
 
 
 # Subdirectory of libcruft to build if fftw is not found:
 
 FFT_DIR="fftpack"
 AC_SUBST(FFT_DIR)
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,19 @@
+2009-11-30  Kacper Kowalik <xarthisius.kk@gmail.com>
+
+	* oct-hdf5.h: Drop force the use of the v1.6 API
+	* ls-hdf5.cc, ov-base-int.cc, ov-bool-mat.cc, ov-bool-sparse.cc,
+	ov-bool.cc, ov-cell.cc, ov-class.cc, ov-complex.cc, ov-cx-mat.cc,
+	ov-cx-sparse.cc, ov-fcn-handle.cc, ov-fcn-inline.cc, ov-float.cc,
+	ov-flt-complex.cc, ov-flt-cx-mat.cc, ov-flt-re-mat.cc, ov-list.cc,
+	ov-range.cc, ov-re-mat.cc, ov-re-sparse.cc, ov-scalar.cc,
+	ov-str-mat.cc, ov-struct.cc: Allow v1.8 API versions of hdf5
+	functions.
+
 2009-11-30  John W. Eaton  <jwe@octave.org>
 
 	* DLD-FUNCTIONS/fft2.cc (Fifft2): Docstring fix.
 
 2009-11-29  Jaroslav Hajek  <highegg@gmail.com>
 
 	* pt-unop.cc (tree_prefix_expression::rvalue1): Try to use
 	octave_value::do_non_const_unary_op.
diff --git a/src/ls-hdf5.cc b/src/ls-hdf5.cc
--- a/src/ls-hdf5.cc
+++ b/src/ls-hdf5.cc
@@ -137,31 +137,39 @@ hdf5_check_attr (hid_t loc_id, const cha
   // call H5Aopen for a non-existing attribute
 
   H5E_auto_t err_func;
   void *err_func_data;
 
   // turn off error reporting temporarily, but save the error
   // reporting function:
 
+#if HAVE_HDF5_18
+  H5Eget_auto (H5E_DEFAULT, &err_func, &err_func_data);
+  H5Eset_auto (H5E_DEFAULT, 0, 0);
+#else
   H5Eget_auto (&err_func, &err_func_data);
   H5Eset_auto (0, 0);
+#endif
 
   hid_t attr_id = H5Aopen_name (loc_id, attr_name);
 
   if (attr_id >= 0)
     {
       // successful
       retval = 1;
       H5Aclose (attr_id);
     }
 
   // restore error reporting:
+#if HAVE_HDF5_18
+  H5Eset_auto (H5E_DEFAULT, err_func, err_func_data);
+#else
   H5Eset_auto (err_func, err_func_data);
-
+#endif
   return retval;
 }
 
 // The following subroutines creates an HDF5 representations of the way
 // we will store Octave complex types (pairs of floating-point numbers).
 // NUM_TYPE is the HDF5 numeric type to use for storage (e.g. 
 // H5T_NATIVE_DOUBLE to save as 'double'). Note that any necessary 
 // conversions are handled automatically by HDF5.
@@ -211,27 +219,35 @@ hdf5_read_next_data (hid_t group_id, con
       // check again (in case vname was null, empty, or some such thing):
       ident_valid = valid_identifier (vname); 
     }
 
   H5Gget_objinfo (group_id, name, 1, &info);
 
   if (info.type == H5G_GROUP && ident_valid)
     {
+#if HAVE_HDF5_18
+      subgroup_id = H5Gopen (group_id, name, H5P_DEFAULT);
+#else
       subgroup_id = H5Gopen (group_id, name);
+#endif
 
       if (subgroup_id < 0)
 	{
 	  retval = subgroup_id;
 	  goto done;
 	}
 
       if (hdf5_check_attr (subgroup_id, "OCTAVE_NEW_FORMAT"))
 	{
+#if HAVE_HDF5_18
+	  data_id = H5Dopen (subgroup_id, "type", H5P_DEFAULT);
+#else
 	  data_id = H5Dopen (subgroup_id, "type");
+#endif
 
 	  if (data_id < 0)
 	    {
 	      retval = data_id;
 	      goto done;
 	    }
 
 	  type_id = H5Dget_type (data_id);
@@ -291,17 +307,21 @@ hdf5_read_next_data (hid_t group_id, con
 
 	  retval = (d->tc.load_hdf5 (group_id, name) ? 1 : -1);
 	}
 
     }
   else if (info.type == H5G_DATASET && ident_valid)
     {
       // For backwards compatiability.
+#if HAVE_HDF5_18
+      data_id = H5Dopen (group_id, name, H5P_DEFAULT);
+#else
       data_id = H5Dopen (group_id, name);
+#endif
 
       if (data_id < 0)
 	{
 	  retval = data_id;
 	  goto done;
 	}
 
       type_id = H5Dget_type (data_id);
@@ -518,24 +538,27 @@ read_hdf5_data (std::istream& is, const 
   doc.resize (0);
 
   hdf5_ifstream& hs = dynamic_cast<hdf5_ifstream&> (is);
   hdf5_callback_data d;
 
   herr_t H5Giterate_retval = -1;
 
   hsize_t num_obj = 0;
+#if HAVE_HDF5_18
+  hid_t group_id = H5Gopen (hs.file_id, "/", H5P_DEFAULT); 
+#else
   hid_t group_id = H5Gopen (hs.file_id, "/"); 
+#endif
   H5Gget_num_objs (group_id, &num_obj);
   H5Gclose (group_id);
   if (hs.current_item < static_cast<int> (num_obj))
     H5Giterate_retval = H5Giterate (hs.file_id, "/", &hs.current_item,
 				    hdf5_read_next_data, &d);
 
-
   if (H5Giterate_retval > 0)
     {
       global = d.global;
       tc = d.tc;
       doc = d.doc;
     }
   else
     {
@@ -556,19 +579,23 @@ static herr_t
 hdf5_add_attr (hid_t loc_id, const char *attr_name)
 {
   herr_t retval = 0;
 
   hid_t as_id = H5Screate (H5S_SCALAR);
 
   if (as_id >= 0)
     {
+#if HAVE_HDF5_18
+      hid_t a_id = H5Acreate (loc_id, attr_name, H5T_NATIVE_UCHAR, 
+      			      as_id, H5P_DEFAULT, H5P_DEFAULT);
+#else
       hid_t a_id = H5Acreate (loc_id, attr_name,
 			      H5T_NATIVE_UCHAR, as_id, H5P_DEFAULT);
-
+#endif
       if (a_id >= 0)
 	{
 	  unsigned char attr_val = 1;
 
 	  retval = H5Awrite (a_id, H5T_NATIVE_UCHAR, &attr_val);
 
 	  H5Aclose (a_id);
 	}
@@ -602,19 +629,23 @@ save_hdf5_empty (hid_t loc_id, const cha
 	empty = true;
     }
 
   if (!empty)
     return 0;
 
   space_hid = H5Screate_simple (1, &sz, 0);
   if (space_hid < 0) return space_hid;
-
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_IDX, space_hid, 
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_IDX, space_hid, 
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       return data_hid;
     }
   
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
 		     H5P_DEFAULT, dims) >= 0;
@@ -634,17 +665,21 @@ save_hdf5_empty (hid_t loc_id, const cha
 //    < 0  Error condition
 int
 load_hdf5_empty (hid_t loc_id, const char *name, dim_vector &d)
 {
   if (!hdf5_check_attr(loc_id, "OCTAVE_EMPTY_MATRIX"))
     return 0;
 
   hsize_t hdims, maxdims;
+#if HAVE_HDF5_18
+  hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
+#else
   hid_t data_hid = H5Dopen (loc_id, name);
+#endif
   hid_t space_id = H5Dget_space (data_hid);
   H5Sget_simple_extent_dims (space_id, &hdims, &maxdims);
   int retval;
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, dims, hdims);
 
   retval = H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
 		    H5P_DEFAULT, dims);
@@ -717,32 +752,39 @@ add_hdf5_data (hid_t loc_id, const octav
   octave_value val = tc;
   // FIXME: diagonal & permutation matrices currently don't know how to save
   // themselves, so we convert them first to normal matrices using A = A(:,:).
   // This is a temporary hack.
   if (val.is_diag_matrix () || val.is_perm_matrix ())
     val = val.full_value ();
 
   std::string t = val.type_name();
-
+#if HAVE_HDF5_18
+  data_id = H5Gcreate (loc_id, name.c_str (), H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_id = H5Gcreate (loc_id, name.c_str (), 0);
+#endif
   if (data_id < 0)
     goto error_cleanup;
 
   // attach the type of the variable
   type_id = H5Tcopy (H5T_C_S1); H5Tset_size (type_id, t.length () + 1);
   if (type_id < 0)
     goto error_cleanup;
 
   dims[0] = 0;
   space_id = H5Screate_simple (0 , dims, 0);
   if (space_id < 0)
     goto error_cleanup;
-
+#if HAVE_HDF5_18
+  data_type_id = H5Dcreate (data_id, "type",  type_id, space_id,
+  			    H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_type_id = H5Dcreate (data_id, "type",  type_id, space_id, H5P_DEFAULT);
+#endif
   if (data_type_id < 0 || H5Dwrite (data_type_id, type_id, H5S_ALL, H5S_ALL, 
 				    H5P_DEFAULT, t.c_str ()) < 0)
     goto error_cleanup;
 
   // Now call the real function to save the variable
   retval = val.save_hdf5 (data_id, "value", save_as_floats);
 
   // attach doc string as comment:
diff --git a/src/oct-hdf5.h b/src/oct-hdf5.h
--- a/src/oct-hdf5.h
+++ b/src/oct-hdf5.h
@@ -19,23 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave__hdf5_h)
 #define octave_hdf5_h 1
 
 #if defined (HAVE_HDF5)
-
-#if !defined (H5_USE_16_API)
-#define H5_USE_16_API 1
-#endif
-
 #include <hdf5.h>
-
 #endif
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-base-int.cc b/src/ov-base-int.cc
--- a/src/ov-base-int.cc
+++ b/src/ov-base-int.cc
@@ -345,19 +345,23 @@ octave_base_int_matrix<T>::save_hdf5 (hi
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv (rank-i-1);
  
   space_hid = H5Screate_simple (rank, hdims, 0);
 
   if (space_hid < 0) return false;
-
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid, 
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid, 
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 
   retval = H5Dwrite (data_hid, save_type_hid, H5S_ALL, H5S_ALL,
 		     H5P_DEFAULT, this->matrix.data()) >= 0;
@@ -376,17 +380,21 @@ octave_base_int_matrix<T>::load_hdf5 (hi
   bool retval = false;
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     this->matrix.resize(dv);
   if (empty)
       return (empty > 0);
 
+#if HAVE_HDF5_18
+  hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
+#else
   hid_t data_hid = H5Dopen (loc_id, name);
+#endif
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
   
   if (rank < 1)
     {
       H5Sclose (space_id);
       H5Dclose (data_hid);
@@ -535,18 +543,23 @@ octave_base_int_scalar<T>::save_hdf5 (hi
   hid_t save_type_hid = HDF5_SAVE_TYPE;
   bool retval = true;
   hsize_t dimens[3];
   hid_t space_hid = -1, data_hid = -1;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
 
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid, 
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid, 
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       return false;
     }
 
   retval = H5Dwrite (data_hid, save_type_hid, H5S_ALL, H5S_ALL,
 		     H5P_DEFAULT, &(this->scalar)) >= 0;
@@ -557,17 +570,21 @@ octave_base_int_scalar<T>::save_hdf5 (hi
   return retval;
 }
 
 template <class T>
 bool
 octave_base_int_scalar<T>::load_hdf5 (hid_t loc_id, const char *name)
 {
   hid_t save_type_hid = HDF5_SAVE_TYPE;
+#if HAVE_HDF5_18
+  hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
+#else
   hid_t data_hid = H5Dopen (loc_id, name);
+#endif
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
 
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       return false;
diff --git a/src/ov-bool-mat.cc b/src/ov-bool-mat.cc
--- a/src/ov-bool-mat.cc
+++ b/src/ov-bool-mat.cc
@@ -427,19 +427,23 @@ octave_bool_matrix::save_hdf5 (hid_t loc
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv (rank-i-1);
 
   space_hid = H5Screate_simple (rank, hdims, 0);
   if (space_hid < 0) return false;
-
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_HBOOL, space_hid, 
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_HBOOL, space_hid, 
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 
   octave_idx_type nel = m.nelem ();
   bool *mtmp = m.fortran_vec ();
@@ -464,17 +468,21 @@ octave_bool_matrix::load_hdf5 (hid_t loc
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize(dv);
   if (empty)
     return (empty > 0);
 
+#if HAVE_HDF5_18
+  hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
+#else
   hid_t data_hid = H5Dopen (loc_id, name);
+#endif
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
   
   if (rank < 1)
     {
       H5Dclose (data_hid);
       return false;
diff --git a/src/ov-bool-sparse.cc b/src/ov-bool-sparse.cc
--- a/src/ov-bool-sparse.cc
+++ b/src/ov-bool-sparse.cc
@@ -339,36 +339,43 @@ octave_sparse_bool_matrix::save_hdf5 (hi
 {
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
-
+#if HAVE_HDF5_18
+  hid_t group_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   hid_t group_hid = H5Gcreate (loc_id, name, 0);
+#endif
   if (group_hid < 0)
     return false;
 
   hid_t space_hid = -1, data_hid = -1;
   bool retval = true;
   SparseBoolMatrix m = sparse_bool_matrix_value ();
   octave_idx_type tmp;
   hsize_t hdims[2];
 
   space_hid = H5Screate_simple (0, hdims, 0);
   if (space_hid < 0) 
     {
       H5Gclose (group_hid);
       return false;
     }
-
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid,
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid,
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   tmp = m.rows ();
@@ -376,18 +383,23 @@ octave_sparse_bool_matrix::save_hdf5 (hi
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }    
 
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid,
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid,
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   tmp = m.cols ();
@@ -396,18 +408,23 @@ octave_sparse_bool_matrix::save_hdf5 (hi
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }    
 
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid, 
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid, 
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   tmp = m.nzmax ();
@@ -429,18 +446,23 @@ octave_sparse_bool_matrix::save_hdf5 (hi
   space_hid = H5Screate_simple (2, hdims, 0);
 
   if (space_hid < 0) 
     {
       H5Gclose (group_hid);
       return false;
     }
 
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid, 
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid, 
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   octave_idx_type * itmp = m.xcidx ();
@@ -462,18 +484,23 @@ octave_sparse_bool_matrix::save_hdf5 (hi
   space_hid = H5Screate_simple (2, hdims, 0);
 
   if (space_hid < 0) 
     {
       H5Gclose (group_hid);
       return false;
     }
 
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid, 
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid, 
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   itmp = m.xridx ();
@@ -482,18 +509,23 @@ octave_sparse_bool_matrix::save_hdf5 (hi
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (group_hid, "data", H5T_NATIVE_HBOOL, space_hid, 
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (group_hid, "data", H5T_NATIVE_HBOOL, space_hid, 
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   OCTAVE_LOCAL_BUFFER (hbool_t, htmp, m.nzmax ());  
@@ -517,21 +549,29 @@ octave_sparse_bool_matrix::load_hdf5 (hi
   hsize_t rank;
   
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize(dv);
   if (empty)
     return (empty > 0);
-  
+
+#if HAVE_HDF5_18
+  group_hid = H5Gopen (loc_id, name, H5P_DEFAULT);
+#else
   group_hid = H5Gopen (loc_id, name);
+#endif
   if (group_hid < 0 ) return false;
 
+#if HAVE_HDF5_18
+  data_hid = H5Dopen (group_hid, "nr", H5P_DEFAULT);
+#else
   data_hid = H5Dopen (group_hid, "nr");
+#endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
@@ -541,17 +581,21 @@ octave_sparse_bool_matrix::load_hdf5 (hi
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
+#if HAVE_HDF5_18
+  data_hid = H5Dopen (group_hid, "nc", H5P_DEFAULT);
+#else
   data_hid = H5Dopen (group_hid, "nc");
+#endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
@@ -560,18 +604,22 @@ octave_sparse_bool_matrix::load_hdf5 (hi
   if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, &nc) < 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
-  
+
+#if HAVE_HDF5_18
+  data_hid = H5Dopen (group_hid, "nz", H5P_DEFAULT);
+#else
   data_hid = H5Dopen (group_hid, "nz");
+#endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
@@ -585,17 +633,21 @@ octave_sparse_bool_matrix::load_hdf5 (hi
     }
 
   H5Dclose (data_hid);
 
   SparseBoolMatrix m (static_cast<octave_idx_type> (nr),
 		      static_cast<octave_idx_type> (nc),
 		      static_cast<octave_idx_type> (nz));
 
+#if HAVE_HDF5_18
+  data_hid = H5Dopen (group_hid, "cidx", H5P_DEFAULT);
+#else
   data_hid = H5Dopen (group_hid, "cidx");
+#endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 2)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
@@ -623,17 +675,21 @@ octave_sparse_bool_matrix::load_hdf5 (hi
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
   H5Dclose (data_hid);
 
+#if HAVE_HDF5_18
+  data_hid = H5Dopen (group_hid, "ridx", H5P_DEFAULT);
+#else
   data_hid = H5Dopen (group_hid, "ridx");
+#endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 2)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
@@ -659,17 +715,21 @@ octave_sparse_bool_matrix::load_hdf5 (hi
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
   H5Dclose (data_hid);
 
+#if HAVE_HDF5_18
+  data_hid = H5Dopen (group_hid, "data", H5P_DEFAULT);
+#else
   data_hid = H5Dopen (group_hid, "data");
+#endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 2)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
diff --git a/src/ov-bool.cc b/src/ov-bool.cc
--- a/src/ov-bool.cc
+++ b/src/ov-bool.cc
@@ -165,19 +165,23 @@ octave_bool::save_hdf5 (hid_t loc_id, co
 			bool /* save_as_floats */)
 {
   hsize_t dimens[3];
   hid_t space_hid = -1, data_hid = -1;
   bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
-
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid, 
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid, 
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       return false;
     }
 
   double tmp = double_value ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL,
@@ -187,17 +191,21 @@ octave_bool::save_hdf5 (hid_t loc_id, co
   H5Sclose (space_hid);
 
   return retval;
 }
 
 bool
 octave_bool::load_hdf5 (hid_t loc_id, const char *name)
 {
+#if HAVE_HDF5_18
+  hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
+#else
   hid_t data_hid = H5Dopen (loc_id, name);
+#endif
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
 
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       return false;
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -1029,17 +1029,21 @@ octave_cell::save_hdf5 (hid_t loc_id, co
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   hsize_t rank = dv.length (); 
   hid_t space_hid = -1, data_hid = -1, size_hid = -1;
 
+#if HAVE_HDF5_18
+  data_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Gcreate (loc_id, name, 0);
+#endif
 
   if (data_hid < 0)
     return false;
 
   // Have to save cell array shape, since can't have a 
   // dataset of groups....
 
   space_hid = H5Screate_simple (1, &rank, 0);
@@ -1051,18 +1055,23 @@ octave_cell::save_hdf5 (hid_t loc_id, co
     }
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (hsize_t i = 0; i < rank; i++)
     hdims[i] = dv(rank-i-1);
 
+#if HAVE_HDF5_18
+  size_hid = H5Dcreate (data_hid, "dims", H5T_NATIVE_IDX, space_hid, 
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   size_hid = H5Dcreate (data_hid, "dims", H5T_NATIVE_IDX, space_hid, 
 			H5P_DEFAULT);
+#endif
   if (size_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (data_hid);
       return false;
     }
 
   if (H5Dwrite (size_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
@@ -1112,22 +1121,30 @@ octave_cell::load_hdf5 (hid_t loc_id, co
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize(dv);
   if (empty)
     return (empty > 0);
 
+#if HAVE_HDF5_18
+  hid_t group_id = H5Gopen (loc_id, name, H5P_DEFAULT);
+#else
   hid_t group_id = H5Gopen (loc_id, name);
+#endif
 
   if (group_id < 0)
     return false;
 
+#if HAVE_HDF5_18
+  hid_t data_hid = H5Dopen (group_id, "dims", H5P_DEFAULT);
+#else
   hid_t data_hid = H5Dopen (group_id, "dims");
+#endif
   hid_t space_hid = H5Dget_space (data_hid);
   hsize_t rank = H5Sget_simple_extent_ndims (space_hid);
   if (rank != 1) 
     {
       H5Dclose (data_hid);
       H5Gclose (group_id);
       return false;
     }
@@ -1161,25 +1178,29 @@ octave_cell::load_hdf5 (hid_t loc_id, co
 
   herr_t retval2 = -1;
 
   Cell m (dv);
 
   int current_item = 0;
 
   hsize_t num_obj = 0;
+#if HAVE_HDF5_18
+  group_id = H5Gopen (loc_id, name, H5P_DEFAULT); 
+#else
   group_id = H5Gopen (loc_id, name); 
+#endif
   H5Gget_num_objs (group_id, &num_obj);
   H5Gclose (group_id);
 
   for (octave_idx_type i = 0; i < dv.numel (); i++)
     {
 
       if (current_item >= static_cast<int> (num_obj))
-        retval2 = -1;
+	retval2 = -1;
       else
 	retval2 = H5Giterate (loc_id, name, &current_item,
 			      hdf5_read_next_data, &dsub);
       
       if (retval2 <= 0)
 	break;
 
       octave_value ov = dsub.tc;
diff --git a/src/ov-class.cc b/src/ov-class.cc
--- a/src/ov-class.cc
+++ b/src/ov-class.cc
@@ -1394,37 +1394,49 @@ octave_class::save_hdf5 (hid_t loc_id, c
   hid_t group_hid = -1;
   hid_t type_hid = -1;
   hid_t space_hid = -1;
   hid_t class_hid = -1;
   hid_t data_hid = -1;
   Octave_map m;
   Octave_map::iterator i;
 
+#if HAVE_HDF5_18
+  group_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   group_hid = H5Gcreate (loc_id, name, 0);
+#endif
   if (group_hid < 0)
     goto error_cleanup;
 
   // Add the class name to the group
   type_hid = H5Tcopy (H5T_C_S1); H5Tset_size (type_hid, c_name.length () + 1);
   if (type_hid < 0)
     goto error_cleanup;
 
   hdims[0] = 0;
   space_hid = H5Screate_simple (0 , hdims, 0);
   if (space_hid < 0)
     goto error_cleanup;
-
+#if HAVE_HDF5_18
+  class_hid = H5Dcreate (group_hid, "classname",  type_hid, space_hid,
+			 H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   class_hid = H5Dcreate (group_hid, "classname",  type_hid, space_hid,
 			 H5P_DEFAULT);
+#endif
   if (class_hid < 0 || H5Dwrite (class_hid, type_hid, H5S_ALL, H5S_ALL, 
 				    H5P_DEFAULT, c_name.c_str ()) < 0)
     goto error_cleanup;
 
+#if HAVE_HDF5_18
+  data_hid = H5Gcreate (group_hid, "value", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Gcreate (group_hid, "value", 0);
+#endif
   if (data_hid < 0)
     goto error_cleanup;
 
   if (load_path::find_method (class_name (), "saveobj") != std::string ())
     {
       octave_value in = new octave_class (*this);
       octave_value_list tmp = feval ("saveobj", in, 1);
       if (! error_state)
@@ -1487,22 +1499,29 @@ octave_class::load_hdf5 (hid_t loc_id, c
 
   herr_t retval2 = 0;
   Octave_map m (dim_vector (1, 1));
   int current_item = 0;
   hsize_t num_obj = 0;
   int slen = 0;
   hsize_t rank = 0;
 
+#if HAVE_HDF5_18
+  group_hid = H5Gopen (loc_id, name, H5P_DEFAULT);
+#else
   group_hid = H5Gopen (loc_id, name);
+#endif
   if (group_hid < 0)
     goto error_cleanup;
 
-  
+#if HAVE_HDF5_18
+  data_hid = H5Dopen (group_hid, "classname", H5P_DEFAULT);
+#else
   data_hid = H5Dopen (group_hid, "classname");
+#endif
 
   if (data_hid < 0)
     goto error_cleanup;
 
   type_hid = H5Dget_type (data_hid);
 
   type_class_hid = H5Tget_class (type_hid);
 
@@ -1541,18 +1560,21 @@ octave_class::load_hdf5 (hid_t loc_id, c
       H5Dclose (data_hid);
       data_hid = -1;
 
       c_name = classname;
     }
   while (0);
   reconstruct_exemplar ();
 
-
+#if HAVE_HDF5_18
+  subgroup_hid = H5Gopen (group_hid, name, H5P_DEFAULT); 
+#else
   subgroup_hid = H5Gopen (group_hid, name); 
+#endif
   H5Gget_num_objs (subgroup_hid, &num_obj);
   H5Gclose (subgroup_hid);
 
   while (current_item < static_cast<int> (num_obj)
 	 && (retval2 = H5Giterate (group_hid, name, &current_item,
 				   hdf5_read_next_data, &dsub)) > 0)
     {
       octave_value t2 = dsub.tc;
diff --git a/src/ov-complex.cc b/src/ov-complex.cc
--- a/src/ov-complex.cc
+++ b/src/ov-complex.cc
@@ -315,18 +315,22 @@ octave_complex::save_hdf5 (hid_t loc_id,
     return false;
 
   type_hid = hdf5_make_complex_type (H5T_NATIVE_DOUBLE);
   if (type_hid < 0) 
     {
       H5Sclose (space_hid);
       return false;
     }
-
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, 
+  			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, H5P_DEFAULT);
+#endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       return false;
     }
 
   Complex tmp = complex_value ();
@@ -339,17 +343,21 @@ octave_complex::save_hdf5 (hid_t loc_id,
 
   return retval;
 }
 
 bool
 octave_complex::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
+#if HAVE_HDF5_18
+  hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
+#else
   hid_t data_hid = H5Dopen (loc_id, name);
+#endif
   hid_t type_hid = H5Dget_type (data_hid);
 
   hid_t complex_type = hdf5_make_complex_type (H5T_NATIVE_DOUBLE);
 
   if (! hdf5_types_compatible (type_hid, complex_type))
     {
       H5Tclose (complex_type);
       H5Dclose (data_hid);
diff --git a/src/ov-cx-mat.cc b/src/ov-cx-mat.cc
--- a/src/ov-cx-mat.cc
+++ b/src/ov-cx-mat.cc
@@ -578,18 +578,22 @@ octave_complex_matrix::save_hdf5 (hid_t 
 #endif /* HAVE_HDF5_INT2FLOAT_CONVERSIONS */
 
   type_hid = hdf5_make_complex_type (save_type_hid);
   if (type_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
-
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, 
+  			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, H5P_DEFAULT);
+#endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       return false;
     }
 
   hid_t complex_type_hid = hdf5_make_complex_type (H5T_NATIVE_DOUBLE);
@@ -621,17 +625,21 @@ octave_complex_matrix::load_hdf5 (hid_t 
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize(dv);
   if (empty)
       return (empty > 0);
 
+#if HAVE_HDF5_18
+  hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
+#else
   hid_t data_hid = H5Dopen (loc_id, name);
+#endif
   hid_t type_hid = H5Dget_type (data_hid);
 
   hid_t complex_type = hdf5_make_complex_type (H5T_NATIVE_DOUBLE);
 
   if (! hdf5_types_compatible (type_hid, complex_type))
     {
       H5Tclose (complex_type);
       H5Dclose (data_hid);
diff --git a/src/ov-cx-sparse.cc b/src/ov-cx-sparse.cc
--- a/src/ov-cx-sparse.cc
+++ b/src/ov-cx-sparse.cc
@@ -392,35 +392,44 @@ octave_sparse_complex_matrix::save_hdf5 
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
+#if HAVE_HDF5_18
+  hid_t group_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   hid_t group_hid = H5Gcreate (loc_id, name, 0);
+#endif
   if (group_hid < 0)
     return false;
 
   hid_t space_hid = -1, data_hid = -1;
   bool retval = true;
   SparseComplexMatrix m = sparse_complex_matrix_value ();
   octave_idx_type tmp;
   hsize_t hdims[2];
 
   space_hid = H5Screate_simple (0, hdims, 0);
   if (space_hid < 0) 
     {
       H5Gclose (group_hid);
       return false;
     }
 
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid, 
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid, 
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   tmp = m.rows ();
@@ -429,18 +438,23 @@ octave_sparse_complex_matrix::save_hdf5 
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }    
 
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid, 
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid, 
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   tmp = m.cols ();
@@ -449,18 +463,23 @@ octave_sparse_complex_matrix::save_hdf5 
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }    
 
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid, 
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid, 
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   tmp = m.nzmax ();
@@ -482,18 +501,23 @@ octave_sparse_complex_matrix::save_hdf5 
   space_hid = H5Screate_simple (2, hdims, 0);
 
   if (space_hid < 0) 
     {
       H5Gclose (group_hid);
       return false;
     }
 
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid, 
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid, 
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   octave_idx_type * itmp = m.xcidx ();
@@ -515,18 +539,23 @@ octave_sparse_complex_matrix::save_hdf5 
   space_hid = H5Screate_simple (2, hdims, 0);
 
   if (space_hid < 0) 
     {
       H5Gclose (group_hid);
       return false;
     }
 
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid, 
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid, 
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   itmp = m.xridx ();
@@ -565,18 +594,22 @@ octave_sparse_complex_matrix::save_hdf5 
 
   hid_t type_hid = hdf5_make_complex_type (save_type_hid);
   if (type_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
-
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (group_hid, "data", type_hid, space_hid, 
+  			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (group_hid, "data", type_hid, space_hid, H5P_DEFAULT);
+#endif  
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
 
@@ -607,20 +640,28 @@ octave_sparse_complex_matrix::load_hdf5 
   
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize(dv);
   if (empty)
     return (empty > 0);
   
+#if HAVE_HDF5_18
+  group_hid = H5Gopen (loc_id, name, H5P_DEFAULT);
+#else
   group_hid = H5Gopen (loc_id, name);
+#endif
   if (group_hid < 0 ) return false;
 
+#if HAVE_HDF5_18
+  data_hid = H5Dopen (group_hid, "nr", H5P_DEFAULT);
+#else
   data_hid = H5Dopen (group_hid, "nr");
+#endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
@@ -630,17 +671,21 @@ octave_sparse_complex_matrix::load_hdf5 
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
+#if HAVE_HDF5_18
+  data_hid = H5Dopen (group_hid, "nc", H5P_DEFAULT);
+#else
   data_hid = H5Dopen (group_hid, "nc");
+#endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
@@ -649,18 +694,22 @@ octave_sparse_complex_matrix::load_hdf5 
   if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, &nc) < 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
-  
+
+#if HAVE_HDF5_18
+  data_hid = H5Dopen (group_hid, "nz", H5P_DEFAULT);
+#else
   data_hid = H5Dopen (group_hid, "nz");
+#endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
@@ -674,17 +723,21 @@ octave_sparse_complex_matrix::load_hdf5 
     }
 
   H5Dclose (data_hid);
 
   SparseComplexMatrix m (static_cast<octave_idx_type> (nr),
 			 static_cast<octave_idx_type> (nc),
 			 static_cast<octave_idx_type> (nz));
 
+#if HAVE_HDF5_18
+  data_hid = H5Dopen (group_hid, "cidx", H5P_DEFAULT);
+#else
   data_hid = H5Dopen (group_hid, "cidx");
+#endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 2)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
@@ -712,17 +765,21 @@ octave_sparse_complex_matrix::load_hdf5 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
   H5Dclose (data_hid);
 
+#if HAVE_HDF5_18
+  data_hid = H5Dopen (group_hid, "ridx", H5P_DEFAULT);
+#else
   data_hid = H5Dopen (group_hid, "ridx");
+#endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 2)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
@@ -747,17 +804,21 @@ octave_sparse_complex_matrix::load_hdf5 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
   H5Dclose (data_hid);
 
+#if HAVE_HDF5_18
+  data_hid = H5Dopen (group_hid, "data", H5P_DEFAULT);
+#else
   data_hid = H5Dopen (group_hid, "data");
+#endif
   hid_t type_hid = H5Dget_type (data_hid);
 
   hid_t complex_type = hdf5_make_complex_type (H5T_NATIVE_DOUBLE);
 
   if (! hdf5_types_compatible (type_hid, complex_type))
     {
       H5Tclose (complex_type);
       H5Dclose (data_hid);
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -646,17 +646,21 @@ octave_fcn_handle::load_binary (std::ist
 #if defined (HAVE_HDF5)
 bool
 octave_fcn_handle::save_hdf5 (hid_t loc_id, const char *name,
 			      bool save_as_floats)
 {
   bool retval = true;
 
   hid_t group_hid = -1;
+#if HAVE_HDF5_18
+  group_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   group_hid = H5Gcreate (loc_id, name, 0);
+#endif
   if (group_hid < 0)
     return false;
 
   hid_t space_hid = -1, data_hid = -1, type_hid = -1;;
 
   // attach the type of the variable
   type_hid = H5Tcopy (H5T_C_S1);
   H5Tset_size (type_hid, nm.length () + 1);
@@ -671,18 +675,22 @@ octave_fcn_handle::save_hdf5 (hid_t loc_
   hdims[1] = 0;
   space_hid = H5Screate_simple (0 , hdims, 0);
   if (space_hid < 0)
     {
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
-
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid, 
+  			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid, H5P_DEFAULT);
+#endif
   if (data_hid < 0 || H5Dwrite (data_hid, type_hid, H5S_ALL, H5S_ALL,
 				H5P_DEFAULT, nm.c_str ()) < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
@@ -698,18 +706,23 @@ octave_fcn_handle::save_hdf5 (hid_t loc_
       H5Tset_size (type_hid, stmp.length () + 1);
       if (type_hid < 0)
 	{
 	  H5Sclose (space_hid);
 	  H5Gclose (group_hid);
 	  return false;
 	}
 
+#if HAVE_HDF5_18
+      data_hid = H5Dcreate (group_hid, "fcn",  type_hid, space_hid,
+			    H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
       data_hid = H5Dcreate (group_hid, "fcn",  type_hid, space_hid,
 			    H5P_DEFAULT);
+#endif
       if (data_hid < 0 || H5Dwrite (data_hid, type_hid, H5S_ALL, H5S_ALL,
 				    H5P_DEFAULT, stmp.c_str ()) < 0)
 	{
 	  H5Sclose (space_hid);
 	  H5Tclose (type_hid);
 	  H5Gclose (group_hid);
 	  return false;
 	}
@@ -724,34 +737,44 @@ octave_fcn_handle::save_hdf5 (hid_t loc_
       size_t varlen = vars.size ();
 
       if (varlen > 0)
 	{
 	  hid_t as_id = H5Screate (H5S_SCALAR);
 
 	  if (as_id >= 0)
 	    {
+#if HAVE_HDF5_18
+	      hid_t a_id = H5Acreate (group_hid, "SYMBOL_TABLE",
+				      H5T_NATIVE_IDX, as_id, 
+				      H5P_DEFAULT, H5P_DEFAULT);
+
+#else
 	      hid_t a_id = H5Acreate (group_hid, "SYMBOL_TABLE",
 				      H5T_NATIVE_IDX, as_id, H5P_DEFAULT);
+#endif
 
 	      if (a_id >= 0)
 		{
 		  retval = (H5Awrite (a_id, H5T_NATIVE_IDX, &varlen) >= 0);
 
 		  H5Aclose (a_id);
 		}
 	      else
 		retval = false;
 
 	      H5Sclose (as_id);
 	    }
 	  else
 	    retval = false;
-
+#if HAVE_HDF5_18
+	  data_hid = H5Gcreate (group_hid, "symbol table", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
 	  data_hid = H5Gcreate (group_hid, "symbol table", 0);
+#endif
 	  if (data_hid < 0) 
 	    {
 	      H5Sclose (space_hid);
 	      H5Tclose (type_hid);
 	      H5Gclose (group_hid);
 	      return false;
 	    }
 
@@ -781,19 +804,23 @@ octave_fcn_handle::save_hdf5 (hid_t loc_
 	  H5Tclose (type_hid);
 	  H5Gclose (group_hid);
 	  return false;
 	}
 
       H5Tclose (type_hid);
       type_hid = H5Tcopy (H5T_C_S1);
       H5Tset_size (type_hid, octaveroot.length () + 1);
-
+#if HAVE_HDF5_18
+      hid_t a_id = H5Acreate (group_hid, "OCTAVEROOT",
+			      type_hid, space_hid, H5P_DEFAULT, H5P_DEFAULT);
+#else
       hid_t a_id = H5Acreate (group_hid, "OCTAVEROOT",
 			      type_hid, space_hid, H5P_DEFAULT);
+#endif
 
       if (a_id >= 0)
 	{
 	  retval = (H5Awrite (a_id, type_hid, octaveroot.c_str ()) >= 0);
 
 	  H5Aclose (a_id);
 	}
       else
@@ -814,17 +841,22 @@ octave_fcn_handle::save_hdf5 (hid_t loc_
 	  H5Gclose (group_hid);
 	  return false;
 	}
 
       H5Tclose (type_hid);
       type_hid = H5Tcopy (H5T_C_S1);
       H5Tset_size (type_hid, fpath.length () + 1);
 
+#if HAVE_HDF5_18
+      a_id = H5Acreate (group_hid, "FILE", type_hid, space_hid, 
+      			H5P_DEFAULT, H5P_DEFAULT);
+#else
       a_id = H5Acreate (group_hid, "FILE", type_hid, space_hid, H5P_DEFAULT);
+#endif
 
       if (a_id >= 0)
 	{
 	  retval = (H5Awrite (a_id, type_hid, fpath.c_str ()) >= 0);
 
 	  H5Aclose (a_id);
 	}
       else
@@ -842,21 +874,29 @@ bool
 octave_fcn_handle::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool success = true;
 
   hid_t group_hid, data_hid, space_hid, type_hid, type_class_hid, st_id;
   hsize_t rank;
   int slen;
 
+#if HAVE_HDF5_18
+  group_hid = H5Gopen (loc_id, name, H5P_DEFAULT);
+#else
   group_hid = H5Gopen (loc_id, name);
+#endif
   if (group_hid < 0)
     return false;
 
+#if HAVE_HDF5_18
+  data_hid = H5Dopen (group_hid, "nm", H5P_DEFAULT);
+#else
   data_hid = H5Dopen (group_hid, "nm");
+#endif
 
   if (data_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
   type_hid = H5Dget_type (data_hid);
@@ -908,17 +948,21 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
       return false;
     }
   H5Tclose (st_id);
   H5Dclose (data_hid);
   nm = nm_tmp;
 
   if (nm == "@<anonymous>")
     {
+#if HAVE_HDF5_18
+      data_hid = H5Dopen (group_hid, "fcn", H5P_DEFAULT);
+#else
       data_hid = H5Dopen (group_hid, "fcn");
+#endif
 
       if (data_hid < 0)
 	{
 	  H5Sclose (space_hid);
 	  H5Tclose (type_hid);
 	  H5Gclose (group_hid);
 	  return false;
 	}
@@ -983,31 +1027,40 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
       // HDF5 doesn't print out all sorts of error messages if we
       // call H5Aopen for a non-existing attribute
 
       H5E_auto_t err_func;
       void *err_func_data;
 
       // turn off error reporting temporarily, but save the error
       // reporting function:
+#if HAVE_HDF5_18
+      H5Eget_auto (H5E_DEFAULT, &err_func, &err_func_data);
+      H5Eset_auto (H5E_DEFAULT, 0, 0);
+#else
       H5Eget_auto (&err_func, &err_func_data);
       H5Eset_auto (0, 0);
+#endif
 
       hid_t attr_id = H5Aopen_name (group_hid, "SYMBOL_TABLE");
 
       if (attr_id >= 0)
 	{
 	  if (H5Aread (attr_id, H5T_NATIVE_IDX, &len) < 0)
 	    success = false;
 
 	  H5Aclose (attr_id);
 	}
 
       // restore error reporting:
+#if HAVE_HDF5_18
+      H5Eset_auto (H5E_DEFAULT, err_func, err_func_data);
+#else
       H5Eset_auto (err_func, err_func_data);
+#endif
 
       unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
       symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
       unwind_protect::add_fcn (symbol_table::erase_scope, local_scope);
@@ -1015,17 +1068,21 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
       symbol_table::set_scope (local_scope);
 
       octave_call_stack::push (local_scope, 0);
       unwind_protect::add_fcn (octave_call_stack::pop);
 
       if (len > 0 && success)
 	{
 	  hsize_t num_obj = 0;
+#if HAVE_HDF5_18
+	  data_hid = H5Gopen (group_hid, "symbol table", H5P_DEFAULT); 
+#else
 	  data_hid = H5Gopen (group_hid, "symbol table"); 
+#endif
 	  H5Gget_num_objs (data_hid, &num_obj);
 	  H5Gclose (data_hid);
 
 	  if (num_obj != static_cast<hsize_t>(len))
 	    {
 	      error ("load: failed to load anonymous function handle");
 	      success = false;
 	    }
@@ -1086,18 +1143,23 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
       // HDF5 doesn't print out all sorts of error messages if we
       // call H5Aopen for a non-existing attribute
 
       H5E_auto_t err_func;
       void *err_func_data;
 
       // turn off error reporting temporarily, but save the error
       // reporting function:
+#if HAVE_HDF5_18
+      H5Eget_auto (H5E_DEFAULT, &err_func, &err_func_data);
+      H5Eset_auto (H5E_DEFAULT, 0, 0);
+#else
       H5Eget_auto (&err_func, &err_func_data);
       H5Eset_auto (0, 0);
+#endif
 
       hid_t attr_id = H5Aopen_name (group_hid, "OCTAVEROOT");
       if (attr_id >= 0)
 	{
 	  H5Tclose (type_hid);
 	  type_hid = H5Aget_type (attr_id);
 	  type_class_hid = H5Tget_class (type_hid);
 
@@ -1147,17 +1209,21 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
 		  H5Tclose (st_id);
 		}
 
 	      H5Aclose (attr_id);
 	    }
 	}
 
       // restore error reporting:
+#if HAVE_HDF5_18
+      H5Eset_auto (H5E_DEFAULT, err_func, err_func_data);
+#else
       H5Eset_auto (err_func, err_func_data);
+#endif
 
       success = (success ? set_fcn (octaveroot, fpath) : success);
     }
 
   H5Tclose (type_hid);
   H5Sclose (space_hid);
   H5Gclose (group_hid);
 
diff --git a/src/ov-fcn-inline.cc b/src/ov-fcn-inline.cc
--- a/src/ov-fcn-inline.cc
+++ b/src/ov-fcn-inline.cc
@@ -268,17 +268,21 @@ octave_fcn_inline::load_binary (std::ist
 }
 
 #if defined (HAVE_HDF5)
 bool
 octave_fcn_inline::save_hdf5 (hid_t loc_id, const char *name,
 			      bool /* save_as_floats */)
 {
   hid_t group_hid = -1;
+#if HAVE_HDF5_18
+  group_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   group_hid = H5Gcreate (loc_id, name, 0);
+#endif
   if (group_hid < 0 ) return false;
 
   size_t len = 0;
   for (int i = 0; i < ifargs.length (); i++)
     if (len < ifargs(i).length ())
       len = ifargs(i).length ();
 
   hid_t space_hid = -1, data_hid = -1, type_hid = -1;;
@@ -294,19 +298,23 @@ octave_fcn_inline::save_hdf5 (hid_t loc_
   hdims[0] = len + 1;
 
   space_hid = H5Screate_simple (2, hdims, 0);
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
-
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (group_hid, "args", H5T_NATIVE_CHAR, space_hid,
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (group_hid, "args", H5T_NATIVE_CHAR, space_hid,
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   OCTAVE_LOCAL_BUFFER (char, s, ifargs.length () * (len + 1));
@@ -344,18 +352,22 @@ octave_fcn_inline::save_hdf5 (hid_t loc_
   hdims[0] = 0;
   space_hid = H5Screate_simple (0 , hdims, 0);
   if (space_hid < 0)
     {
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
-
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid, 
+  			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid, H5P_DEFAULT);
+#endif
   if (data_hid < 0 || H5Dwrite (data_hid, type_hid, H5S_ALL, H5S_ALL,
 				H5P_DEFAULT, nm.c_str ()) < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
@@ -364,18 +376,23 @@ octave_fcn_inline::save_hdf5 (hid_t loc_
   // attach the type of the variable
   H5Tset_size (type_hid, iftext.length () + 1);
   if (type_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (group_hid, "iftext",  type_hid, space_hid,
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (group_hid, "iftext",  type_hid, space_hid,
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0 || H5Dwrite (data_hid, type_hid, H5S_ALL, H5S_ALL,
 				H5P_DEFAULT, iftext.c_str ()) < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
@@ -390,20 +407,28 @@ octave_fcn_inline::save_hdf5 (hid_t loc_
 
 bool
 octave_fcn_inline::load_hdf5 (hid_t loc_id, const char *name)
 {
   hid_t group_hid, data_hid, space_hid, type_hid, type_class_hid, st_id;
   hsize_t rank;
   int slen;
 
+#if HAVE_HDF5_18
+  group_hid = H5Gopen (loc_id, name, H5P_DEFAULT);
+#else
   group_hid = H5Gopen (loc_id, name);
+#endif
   if (group_hid < 0 ) return false;
 
+#if HAVE_HDF5_18
+  data_hid = H5Dopen (group_hid, "args", H5P_DEFAULT);
+#else
   data_hid = H5Dopen (group_hid, "args");
+#endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 2)
     {
       H5Dclose (data_hid);
       H5Sclose (space_hid);
       H5Gclose (group_hid);
@@ -429,17 +454,21 @@ octave_fcn_inline::load_hdf5 (hid_t loc_
     }
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
   for (size_t i = 0; i < hdims[1]; i++)
     ifargs(i) = std::string (s1 + i*hdims[0]);
 
+#if HAVE_HDF5_18
+  data_hid = H5Dopen (group_hid, "nm", H5P_DEFAULT);
+#else
   data_hid = H5Dopen (group_hid, "nm");
+#endif
 
   if (data_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
   type_hid = H5Dget_type (data_hid);
@@ -487,17 +516,21 @@ octave_fcn_inline::load_hdf5 (hid_t loc_
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
   H5Tclose (st_id);
   H5Dclose (data_hid);
   nm = nm_tmp;
 
+#if HAVE_HDF5_18
+  data_hid = H5Dopen (group_hid, "iftext", H5P_DEFAULT);
+#else
   data_hid = H5Dopen (group_hid, "iftext");
+#endif
 
   if (data_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
   type_hid = H5Dget_type (data_hid);
diff --git a/src/ov-float.cc b/src/ov-float.cc
--- a/src/ov-float.cc
+++ b/src/ov-float.cc
@@ -184,19 +184,23 @@ octave_float_scalar::save_hdf5 (hid_t lo
 			  bool /* save_as_floats */)
 {
   hsize_t dimens[3];
   hid_t space_hid = -1, data_hid = -1;
   bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
-
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_FLOAT, space_hid, 
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_FLOAT, space_hid, 
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       return false;
     }
 
   float tmp = float_value ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL,
@@ -206,17 +210,21 @@ octave_float_scalar::save_hdf5 (hid_t lo
   H5Sclose (space_hid);
 
   return retval;
 }
 
 bool
 octave_float_scalar::load_hdf5 (hid_t loc_id, const char *name)
 {
+#if HAVE_HDF5_18
+  hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
+#else
   hid_t data_hid = H5Dopen (loc_id, name);
+#endif
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
 
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       return false;
diff --git a/src/ov-flt-complex.cc b/src/ov-flt-complex.cc
--- a/src/ov-flt-complex.cc
+++ b/src/ov-flt-complex.cc
@@ -300,18 +300,22 @@ octave_float_complex::save_hdf5 (hid_t l
     return false;
 
   type_hid = hdf5_make_complex_type (H5T_NATIVE_FLOAT);
   if (type_hid < 0) 
     {
       H5Sclose (space_hid);
       return false;
     }
-
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, 
+  			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else			
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, H5P_DEFAULT);
+#endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       return false;
     }
 
   FloatComplex tmp = float_complex_value ();
@@ -324,17 +328,21 @@ octave_float_complex::save_hdf5 (hid_t l
 
   return retval;
 }
 
 bool
 octave_float_complex::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
+#if HAVE_HDF5_18
+  hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
+#else
   hid_t data_hid = H5Dopen (loc_id, name);
+#endif
   hid_t type_hid = H5Dget_type (data_hid);
 
   hid_t complex_type = hdf5_make_complex_type (H5T_NATIVE_FLOAT);
 
   if (! hdf5_types_compatible (type_hid, complex_type))
     {
       H5Tclose (complex_type);
       H5Dclose (data_hid);
diff --git a/src/ov-flt-cx-mat.cc b/src/ov-flt-cx-mat.cc
--- a/src/ov-flt-cx-mat.cc
+++ b/src/ov-flt-cx-mat.cc
@@ -545,18 +545,22 @@ octave_float_complex_matrix::save_hdf5 (
 #endif /* HAVE_HDF5_INT2FLOAT_CONVERSIONS */
 
   type_hid = hdf5_make_complex_type (save_type_hid);
   if (type_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
-
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, 
+  			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, H5P_DEFAULT);
+#endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       return false;
     }
 
   hid_t complex_type_hid = hdf5_make_complex_type (H5T_NATIVE_FLOAT);
@@ -588,17 +592,21 @@ octave_float_complex_matrix::load_hdf5 (
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize(dv);
   if (empty)
       return (empty > 0);
 
+#if HAVE_HDF5_18
+  hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
+#else
   hid_t data_hid = H5Dopen (loc_id, name);
+#endif
   hid_t type_hid = H5Dget_type (data_hid);
 
   hid_t complex_type = hdf5_make_complex_type (H5T_NATIVE_FLOAT);
 
   if (! hdf5_types_compatible (type_hid, complex_type))
     {
       H5Tclose (complex_type);
       H5Dclose (data_hid);
diff --git a/src/ov-flt-re-mat.cc b/src/ov-flt-re-mat.cc
--- a/src/ov-flt-re-mat.cc
+++ b/src/ov-flt-re-mat.cc
@@ -570,19 +570,23 @@ octave_float_matrix::save_hdf5 (hid_t lo
     {
       float max_val, min_val;
 
       if (m.all_integers (max_val, min_val))
 	save_type_hid
 	  = save_type_to_hdf5 (get_save_type (max_val, min_val));
     }
 #endif /* HAVE_HDF5_INT2FLOAT_CONVERSIONS */
-  
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid, 
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid, 
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 
   float *mtmp = m.fortran_vec ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL,
@@ -601,17 +605,21 @@ octave_float_matrix::load_hdf5 (hid_t lo
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize(dv);
   if (empty)
       return (empty > 0);
 
+#if HAVE_HDF5_18
+  hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
+#else
   hid_t data_hid = H5Dopen (loc_id, name);
+#endif
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
   
   if (rank < 1)
     {
       H5Sclose (space_id);
       H5Dclose (data_hid);
diff --git a/src/ov-list.cc b/src/ov-list.cc
--- a/src/ov-list.cc
+++ b/src/ov-list.cc
@@ -681,17 +681,21 @@ octave_list::load_binary (std::istream& 
 
 #if defined (HAVE_HDF5)
 
 bool
 octave_list::save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats)
 {
   hid_t data_hid = -1;
 
+#if HAVE_HDF5_18
+  data_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Gcreate (loc_id, name, 0);
+#endif
   if (data_hid < 0) return false;
 
   // recursively add each element of the list to this group
   octave_value_list lst = list_value ();
 
   for (octave_idx_type i = 0; i < lst.length (); ++i)
     {
       // should we use lst.name_tags () to label the elements?
@@ -717,17 +721,21 @@ octave_list::load_hdf5 (hid_t loc_id,  c
   bool retval = false;
 
   hdf5_callback_data dsub;
 
   herr_t retval2 = -1;
   octave_value_list lst;
   int current_item = 0;
   hsize_t num_obj = 0;
+#if HAVE_HDF5_18
+  hid_t group_id = H5Gopen (loc_id, name, H5P_DEFAULT); 
+#else
   hid_t group_id = H5Gopen (loc_id, name); 
+#endif
   H5Gget_num_objs (group_id, &num_obj);
   H5Gclose (group_id);
 
   while (current_item < static_cast<int> (num_obj)
 	 && (retval2 = H5Giterate (loc_id, name, &current_item,
 				   hdf5_read_next_data, &dsub)) > 0)
     {
       lst.append (dsub.tc);
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -457,18 +457,22 @@ octave_range::save_hdf5 (hid_t loc_id, c
   if (space_hid < 0) return false;
 
   type_hid = hdf5_make_range_type (H5T_NATIVE_DOUBLE);
   if (type_hid < 0) 
     {
       H5Sclose (space_hid);
       return false;
     }
-
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, 
+  			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, H5P_DEFAULT);
+#endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       return false;
     }
   
   Range r = range_value ();
@@ -487,17 +491,21 @@ octave_range::save_hdf5 (hid_t loc_id, c
   return retval;
 }
 
 bool 
 octave_range::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
+#if HAVE_HDF5_18
+  hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
+#else
   hid_t data_hid = H5Dopen (loc_id, name);
+#endif
   hid_t type_hid = H5Dget_type (data_hid);
 
   hid_t range_type = hdf5_make_range_type (H5T_NATIVE_DOUBLE);
 
   if (! hdf5_types_compatible (type_hid, range_type))
     {
       H5Tclose (range_type);
       H5Dclose (data_hid);
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -598,19 +598,24 @@ octave_matrix::save_hdf5 (hid_t loc_id, 
     {
       double max_val, min_val;
 
       if (m.all_integers (max_val, min_val))
 	save_type_hid
 	  = save_type_to_hdf5 (get_save_type (max_val, min_val));
     }
 #endif /* HAVE_HDF5_INT2FLOAT_CONVERSIONS */
-  
+ 
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid, 
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid, 
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 
   double *mtmp = m.fortran_vec ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL,
@@ -629,17 +634,21 @@ octave_matrix::load_hdf5 (hid_t loc_id, 
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize(dv);
   if (empty)
       return (empty > 0);
 
+#if HAVE_HDF5_18
+  hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
+#else
   hid_t data_hid = H5Dopen (loc_id, name);
+#endif
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
   
   if (rank < 1)
     {
       H5Sclose (space_id);
       H5Dclose (data_hid);
diff --git a/src/ov-re-sparse.cc b/src/ov-re-sparse.cc
--- a/src/ov-re-sparse.cc
+++ b/src/ov-re-sparse.cc
@@ -405,35 +405,43 @@ octave_sparse_matrix::save_hdf5 (hid_t l
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
+#if HAVE_HDF5_18
+  hid_t group_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   hid_t group_hid = H5Gcreate (loc_id, name, 0);
+#endif
   if (group_hid < 0)
     return false;
 
   hid_t space_hid = -1, data_hid = -1;
   bool retval = true;
   SparseMatrix m = sparse_matrix_value ();
   octave_idx_type tmp;
   hsize_t hdims[2];
 
   space_hid = H5Screate_simple (0, hdims, 0);
   if (space_hid < 0) 
     {
       H5Gclose (group_hid);
       return false;
     }
-
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid, 
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid, 
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   tmp = m.rows ();
@@ -441,19 +449,23 @@ octave_sparse_matrix::save_hdf5 (hid_t l
 		     &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }    
-
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid, 
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid, 
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   tmp = m.cols ();
@@ -462,18 +474,23 @@ octave_sparse_matrix::save_hdf5 (hid_t l
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }    
 
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid, 
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else                   
   data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid, 
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   tmp = m.nzmax ();
@@ -495,18 +512,23 @@ octave_sparse_matrix::save_hdf5 (hid_t l
   space_hid = H5Screate_simple (2, hdims, 0);
 
   if (space_hid < 0) 
     {
       H5Gclose (group_hid);
       return false;
     }
 
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid, 
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid, 
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   octave_idx_type * itmp = m.xcidx ();
@@ -527,19 +549,23 @@ octave_sparse_matrix::save_hdf5 (hid_t l
 
   space_hid = H5Screate_simple (2, hdims, 0);
 
   if (space_hid < 0) 
     {
       H5Gclose (group_hid);
       return false;
     }
-
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid, 
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid, 
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   itmp = m.xridx ();
@@ -572,18 +598,23 @@ octave_sparse_matrix::save_hdf5 (hid_t l
       double max_val, min_val;
 
       if (m.all_integers (max_val, min_val))
 	save_type_hid
 	  = save_type_to_hdf5 (get_save_type (max_val, min_val));
     }
 #endif /* HAVE_HDF5_INT2FLOAT_CONVERSIONS */
 
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (group_hid, "data", save_type_hid, space_hid, 
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (group_hid, "data", save_type_hid, space_hid, 
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   double * dtmp = m.xdata ();
@@ -605,20 +636,28 @@ octave_sparse_matrix::load_hdf5 (hid_t l
   
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize(dv);
   if (empty)
     return (empty > 0);
   
+#if HAVE_HDF5_18
+  group_hid = H5Gopen (loc_id, name, H5P_DEFAULT);
+#else
   group_hid = H5Gopen (loc_id, name);
+#endif
   if (group_hid < 0) return false;
 
+#if HAVE_HDF5_18
+  data_hid = H5Dopen (group_hid, "nr", H5P_DEFAULT);
+#else
   data_hid = H5Dopen (group_hid, "nr");
+#endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
@@ -629,17 +668,21 @@ octave_sparse_matrix::load_hdf5 (hid_t l
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
+#if HAVE_HDF5_18
+  data_hid = H5Dopen (group_hid, "nc", H5P_DEFAULT);
+#else
   data_hid = H5Dopen (group_hid, "nc");
+#endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
@@ -650,17 +693,21 @@ octave_sparse_matrix::load_hdf5 (hid_t l
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
   
+#if HAVE_HDF5_18
+  data_hid = H5Dopen (group_hid, "nz", H5P_DEFAULT);
+#else
   data_hid = H5Dopen (group_hid, "nz");
+#endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
@@ -675,17 +722,21 @@ octave_sparse_matrix::load_hdf5 (hid_t l
     }
 
   H5Dclose (data_hid);
 
   SparseMatrix m (static_cast<octave_idx_type> (nr),
 		  static_cast<octave_idx_type> (nc),
 		  static_cast<octave_idx_type> (nz));
 
+#if HAVE_HDF5_18
+  data_hid = H5Dopen (group_hid, "cidx", H5P_DEFAULT);
+#else
   data_hid = H5Dopen (group_hid, "cidx");
+#endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 2)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
@@ -714,17 +765,21 @@ octave_sparse_matrix::load_hdf5 (hid_t l
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
   H5Dclose (data_hid);
 
+#if HAVE_HDF5_18
+  data_hid = H5Dopen (group_hid, "ridx", H5P_DEFAULT);
+#else
   data_hid = H5Dopen (group_hid, "ridx");
+#endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 2)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
@@ -749,17 +804,21 @@ octave_sparse_matrix::load_hdf5 (hid_t l
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
   H5Dclose (data_hid);
 
+#if HAVE_HDF5_18
+  data_hid = H5Dopen (group_hid, "data", H5P_DEFAULT);
+#else
   data_hid = H5Dopen (group_hid, "data");
+#endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 2)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
diff --git a/src/ov-scalar.cc b/src/ov-scalar.cc
--- a/src/ov-scalar.cc
+++ b/src/ov-scalar.cc
@@ -200,18 +200,23 @@ octave_scalar::save_hdf5 (hid_t loc_id, 
 {
   hsize_t dimens[3];
   hid_t space_hid = -1, data_hid = -1;
   bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
 
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid, 
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid, 
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       return false;
     }
 
   double tmp = double_value ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL,
@@ -221,17 +226,21 @@ octave_scalar::save_hdf5 (hid_t loc_id, 
   H5Sclose (space_hid);
 
   return retval;
 }
 
 bool
 octave_scalar::load_hdf5 (hid_t loc_id, const char *name)
 {
+#if HAVE_HDF5_18
+  hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
+#else
   hid_t data_hid = H5Dopen (loc_id, name);
+#endif
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
 
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       return false;
diff --git a/src/ov-str-mat.cc b/src/ov-str-mat.cc
--- a/src/ov-str-mat.cc
+++ b/src/ov-str-mat.cc
@@ -556,19 +556,23 @@ octave_char_matrix_str::save_hdf5 (hid_t
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv (rank-i-1);
  
   space_hid = H5Screate_simple (rank, hdims, 0);
   if (space_hid < 0)
     return false;
-
+#if HAVE_HDF5_18
+  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_CHAR, space_hid, 
+			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_CHAR, space_hid, 
 			H5P_DEFAULT);
+#endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 
   OCTAVE_LOCAL_BUFFER (char, s, dv.numel ());
 
@@ -591,17 +595,21 @@ octave_char_matrix_str::load_hdf5 (hid_t
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize(dv);
   if (empty)
     return (empty > 0);
 
+#if HAVE_HDF5_18
+  hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
+#else
   hid_t data_hid = H5Dopen (loc_id, name);
+#endif
   hid_t space_hid = H5Dget_space (data_hid);
   hsize_t rank = H5Sget_simple_extent_ndims (space_hid);
   hid_t type_hid = H5Dget_type (data_hid);
   hid_t type_class_hid = H5Tget_class (type_hid);
 
   if (type_class_hid == H5T_INTEGER)
     {
       if (rank < 1)
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -1482,17 +1482,21 @@ octave_struct::load_binary (std::istream
 
 #if defined (HAVE_HDF5)
 
 bool
 octave_struct::save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats)
 {
   hid_t data_hid = -1;
 
+#if HAVE_HDF5_18
+  data_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else
   data_hid = H5Gcreate (loc_id, name, 0);
+#endif
   if (data_hid < 0) return false;
 
   // recursively add each element of the structure to this group
   Octave_map m = map_value ();
 
   octave_idx_type nf = m.nfields ();
 
   // Iterating over the list of keys will preserve the order of the
@@ -1523,17 +1527,21 @@ octave_struct::load_hdf5 (hid_t loc_id, 
   bool retval = false;
 
   hdf5_callback_data dsub;
 
   herr_t retval2 = 0;
   Octave_map m (dim_vector (1, 1));
   int current_item = 0;
   hsize_t num_obj = 0;
-  hid_t group_id = H5Gopen (loc_id, name); 
+#if HAVE_HDF5_18
+  hid_t group_id = H5Gopen (loc_id, name, H5P_DEFAULT);
+#else
+  hid_t group_id = H5Gopen (loc_id, name);
+#endif
   H5Gget_num_objs (group_id, &num_obj);
   H5Gclose (group_id);
 
   // FIXME -- fields appear to be sorted alphabetically on loading.
   // Why is that happening?
 
   while (current_item < static_cast<int> (num_obj)
 	 && (retval2 = H5Giterate (loc_id, name, &current_item,
