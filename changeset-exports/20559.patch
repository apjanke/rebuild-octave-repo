# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1444095423 14400
#      Mon Oct 05 21:37:03 2015 -0400
# Node ID 0650b8431037461fd9d75761a92b7a8153fcac4d
# Parent  1a0a433c8263cd7bdc1379361d9e4729c1ea4ab0
eliminate more simple uses of error_state

* besselj.cc, bitfcns.cc, utils.cc, chol.cc, ov-java.cc:
Eliminate simple uses of error_state.

diff --git a/libinterp/corefcn/besselj.cc b/libinterp/corefcn/besselj.cc
--- a/libinterp/corefcn/besselj.cc
+++ b/libinterp/corefcn/besselj.cc
@@ -611,64 +611,61 @@ return @code{NaN}.\n\
             {
               if (kind < 0 || kind > 3)
                 error ("airy: expecting K = 0, 1, 2, or 3");
             }
           else
             error ("airy: K must be an integer value");
         }
 
-      if (! error_state)
-        {
-          int idx = nargin == 1 ? 0 : 1;
+      int idx = nargin == 1 ? 0 : 1;
 
-          if (args(idx).is_single_type ())
-            {
-              FloatComplexNDArray z = args(idx).float_complex_array_value ();
-
-              if (! error_state)
-                {
-                  Array<octave_idx_type> ierr;
-                  octave_value result;
+      if (args(idx).is_single_type ())
+        {
+          FloatComplexNDArray z = args(idx).float_complex_array_value ();
 
-                  if (kind > 1)
-                    result = biry (z, kind == 3, scale, ierr);
-                  else
-                    result = airy (z, kind == 1, scale, ierr);
+          if (! error_state)
+            {
+              Array<octave_idx_type> ierr;
+              octave_value result;
 
-                  if (nargout > 1)
-                    retval(1) = NDArray (ierr);
+              if (kind > 1)
+                result = biry (z, kind == 3, scale, ierr);
+              else
+                result = airy (z, kind == 1, scale, ierr);
 
-                  retval(0) = result;
-                }
-              else
-                error ("airy: Z must be a complex matrix");
+              if (nargout > 1)
+                retval(1) = NDArray (ierr);
+
+              retval(0) = result;
             }
           else
-            {
-              ComplexNDArray z = args(idx).complex_array_value ();
+            error ("airy: Z must be a complex matrix");
+        }
+      else
+        {
+          ComplexNDArray z = args(idx).complex_array_value ();
 
-              if (! error_state)
-                {
-                  Array<octave_idx_type> ierr;
-                  octave_value result;
+          if (! error_state)
+            {
+              Array<octave_idx_type> ierr;
+              octave_value result;
 
-                  if (kind > 1)
-                    result = biry (z, kind == 3, scale, ierr);
-                  else
-                    result = airy (z, kind == 1, scale, ierr);
+              if (kind > 1)
+                result = biry (z, kind == 3, scale, ierr);
+              else
+                result = airy (z, kind == 1, scale, ierr);
 
-                  if (nargout > 1)
-                    retval(1) = NDArray (ierr);
+              if (nargout > 1)
+                retval(1) = NDArray (ierr);
 
-                  retval(0) = result;
-                }
-              else
-                error ("airy: Z must be a complex matrix");
+              retval(0) = result;
             }
+          else
+            error ("airy: Z must be a complex matrix");
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
diff --git a/libinterp/corefcn/bitfcns.cc b/libinterp/corefcn/bitfcns.cc
--- a/libinterp/corefcn/bitfcns.cc
+++ b/libinterp/corefcn/bitfcns.cc
@@ -177,184 +177,184 @@ bitop (const std::string& fname, const o
           bool arg1_is_float = bitop_arg_is_float (args(1));
 
           if (! (arg0_is_int || arg1_is_int))
             {
               if (arg0_is_bool && arg1_is_bool)
                 {
                   boolNDArray x (args(0).bool_array_value ());
                   boolNDArray y (args(1).bool_array_value ());
-                  if (! error_state)
-                    retval = bitopx (fname, x, y).bool_array_value ();
+
+                  retval = bitopx (fname, x, y).bool_array_value ();
                 }
               else if (arg0_is_float && arg1_is_float)
                 {
                   uint64NDArray x (args(0).float_array_value ());
                   uint64NDArray y (args(1).float_array_value ());
-                  if (! error_state)
-                    retval = bitopx (fname, x, y).float_array_value ();
+
+                  retval = bitopx (fname, x, y).float_array_value ();
                 }
               else if (! (arg0_is_float || arg1_is_float))
                 {
                   uint64NDArray x (args(0).array_value ());
                   uint64NDArray y (args(1).array_value ());
-                  if (! error_state)
-                    retval = bitopx (fname, x, y).array_value ();
+
+                  retval = bitopx (fname, x, y).array_value ();
                 }
               else
                 {
                   int p = (arg0_is_float ? 1 : 0);
                   int q = (arg0_is_float ? 0 : 1);
 
                   uint64NDArray x (args(p).array_value ());
                   uint64NDArray y (args(q).float_array_value ());
-                  if (! error_state)
-                    retval = bitopx (fname, x, y).float_array_value ();
+
+                  retval = bitopx (fname, x, y).float_array_value ();
                 }
             }
           else
             {
               int p = (arg0_is_int ? 1 : 0);
               int q = (arg0_is_int ? 0 : 1);
 
               NDArray dx = args(p).array_value ();
 
               if (args(q).type_id () == octave_uint64_matrix::static_type_id ()
                   || args(q).type_id () == octave_uint64_scalar::static_type_id ())
                 {
                   uint64NDArray x (dx);
                   uint64NDArray y = args(q).uint64_array_value ();
-                  if (! error_state)
-                    retval = bitopx (fname, x, y);
+
+                  retval = bitopx (fname, x, y);
                 }
               else if (args(q).type_id () == octave_uint32_matrix::static_type_id ()
                        || args(q).type_id () == octave_uint32_scalar::static_type_id ())
                 {
                   uint32NDArray x (dx);
                   uint32NDArray y = args(q).uint32_array_value ();
-                  if (! error_state)
-                    retval = bitopx (fname, x, y);
+
+                  retval = bitopx (fname, x, y);
                 }
               else if (args(q).type_id () == octave_uint16_matrix::static_type_id ()
                        || args(q).type_id () == octave_uint16_scalar::static_type_id ())
                 {
                   uint16NDArray x (dx);
                   uint16NDArray y = args(q).uint16_array_value ();
-                  if (! error_state)
-                    retval = bitopx (fname, x, y);
+
+                  retval = bitopx (fname, x, y);
                 }
               else if (args(q).type_id () == octave_uint8_matrix::static_type_id ()
                        || args(q).type_id () == octave_uint8_scalar::static_type_id ())
                 {
                   uint8NDArray x (dx);
                   uint8NDArray y = args(q).uint8_array_value ();
-                  if (! error_state)
-                    retval = bitopx (fname, x, y);
+
+                  retval = bitopx (fname, x, y);
                 }
               else if (args(q).type_id () == octave_int64_matrix::static_type_id ()
                        || args(q).type_id () == octave_int64_scalar::static_type_id ())
                 {
                   int64NDArray x (dx);
                   int64NDArray y = args(q).int64_array_value ();
-                  if (! error_state)
-                    retval = bitopx (fname, x, y);
+
+                  retval = bitopx (fname, x, y);
                 }
               else if (args(q).type_id () == octave_int32_matrix::static_type_id ()
                        || args(q).type_id () == octave_int32_scalar::static_type_id ())
                 {
                   int32NDArray x (dx);
                   int32NDArray y = args(q).int32_array_value ();
-                  if (! error_state)
-                    retval = bitopx (fname, x, y);
+
+                  retval = bitopx (fname, x, y);
                 }
               else if (args(q).type_id () == octave_int16_matrix::static_type_id ()
                        || args(q).type_id () == octave_int16_scalar::static_type_id ())
                 {
                   int16NDArray x (dx);
                   int16NDArray y = args(q).int16_array_value ();
-                  if (! error_state)
-                    retval  = bitopx (fname, x, y);
+
+                  retval  = bitopx (fname, x, y);
                 }
               else if (args(q).type_id () == octave_int8_matrix::static_type_id ()
                        || args(q).type_id () == octave_int8_scalar::static_type_id ())
                 {
                   int8NDArray x (dx);
                   int8NDArray y = args(q).int8_array_value ();
-                  if (! error_state)
-                    retval = bitopx (fname, x, y);
+
+                  retval = bitopx (fname, x, y);
                 }
               else
                 error ("%s: invalid operand type", fname.c_str ());
             }
         }
       else if (args(0).class_name () == args(1).class_name ())
         {
           if (args(0).type_id () == octave_uint64_matrix::static_type_id ()
               || args(0).type_id () == octave_uint64_scalar::static_type_id ())
             {
               uint64NDArray x = args(0).uint64_array_value ();
               uint64NDArray y = args(1).uint64_array_value ();
-              if (! error_state)
-                retval = bitopx (fname, x, y);
+
+              retval = bitopx (fname, x, y);
             }
           else if (args(0).type_id () == octave_uint32_matrix::static_type_id ()
                    || args(0).type_id () == octave_uint32_scalar::static_type_id ())
             {
               uint32NDArray x = args(0).uint32_array_value ();
               uint32NDArray y = args(1).uint32_array_value ();
-              if (! error_state)
-                retval = bitopx (fname, x, y);
+
+              retval = bitopx (fname, x, y);
             }
           else if (args(0).type_id () == octave_uint16_matrix::static_type_id ()
                    || args(0).type_id () == octave_uint16_scalar::static_type_id ())
             {
               uint16NDArray x = args(0).uint16_array_value ();
               uint16NDArray y = args(1).uint16_array_value ();
-              if (! error_state)
-                retval = bitopx (fname, x, y);
+
+              retval = bitopx (fname, x, y);
             }
           else if (args(0).type_id () == octave_uint8_matrix::static_type_id ()
                    || args(0).type_id () == octave_uint8_scalar::static_type_id ())
             {
               uint8NDArray x = args(0).uint8_array_value ();
               uint8NDArray y = args(1).uint8_array_value ();
-              if (! error_state)
-                retval = bitopx (fname, x, y);
+
+              retval = bitopx (fname, x, y);
             }
           else if (args(0).type_id () == octave_int64_matrix::static_type_id ()
                    || args(0).type_id () == octave_int64_scalar::static_type_id ())
             {
               int64NDArray x = args(0).int64_array_value ();
               int64NDArray y = args(1).int64_array_value ();
-              if (! error_state)
-                retval = bitopx (fname, x, y);
+
+              retval = bitopx (fname, x, y);
             }
           else if (args(0).type_id () == octave_int32_matrix::static_type_id ()
                    || args(0).type_id () == octave_int32_scalar::static_type_id ())
             {
               int32NDArray x = args(0).int32_array_value ();
               int32NDArray y = args(1).int32_array_value ();
-              if (! error_state)
-                retval = bitopx (fname, x, y);
+
+              retval = bitopx (fname, x, y);
             }
           else if (args(0).type_id () == octave_int16_matrix::static_type_id ()
                    || args(0).type_id () == octave_int16_scalar::static_type_id ())
             {
               int16NDArray x = args(0).int16_array_value ();
               int16NDArray y = args(1).int16_array_value ();
-              if (! error_state)
-                retval = bitopx (fname, x, y);
+
+              retval = bitopx (fname, x, y);
             }
           else if (args(0).type_id () == octave_int8_matrix::static_type_id ()
                    || args(0).type_id () == octave_int8_scalar::static_type_id ())
             {
               int8NDArray x = args(0).int8_array_value ();
               int8NDArray y = args(1).int8_array_value ();
-              if (! error_state)
-                retval = bitopx (fname, x, y);
+
+              retval = bitopx (fname, x, y);
             }
           else
             error ("%s: invalid operand type", fname.c_str ());
         }
       else
         error ("%s: must have matching operand types", fname.c_str ());
     }
   else
@@ -455,62 +455,59 @@ bitshift (float a, int n, int64_t mask)
     return static_cast<int64_t> (a) & mask;
 }
 
 // Note that the bitshift operators are undefined if shifted by more
 // bits than in the type, so we need to test for the size of the
 // shift.
 
 #define DO_BITSHIFT(T) \
-  if (! error_state) \
-    { \
-      double d1, d2; \
+  double d1, d2; \
  \
-      if (n.all_integers (d1, d2)) \
-        { \
-          int m_nel = m.numel (); \
-          int n_nel = n.numel (); \
+  if (n.all_integers (d1, d2)) \
+    { \
+      int m_nel = m.numel (); \
+      int n_nel = n.numel (); \
+ \
+      bool is_scalar_op = (m_nel == 1 || n_nel == 1); \
  \
-          bool is_scalar_op = (m_nel == 1 || n_nel == 1); \
- \
-          dim_vector m_dv = m.dims (); \
-          dim_vector n_dv = n.dims (); \
+      dim_vector m_dv = m.dims (); \
+      dim_vector n_dv = n.dims (); \
  \
-          bool is_array_op = (m_dv == n_dv); \
+      bool is_array_op = (m_dv == n_dv); \
  \
-          if (is_array_op || is_scalar_op) \
-            { \
-              T ## NDArray result; \
+      if (is_array_op || is_scalar_op) \
+        { \
+          T ## NDArray result; \
  \
-              if (m_nel != 1) \
-                result.resize (m_dv); \
-              else \
-                result.resize (n_dv); \
+          if (m_nel != 1) \
+            result.resize (m_dv); \
+          else \
+            result.resize (n_dv); \
  \
-              for (int i = 0; i < m_nel; i++) \
-                if (is_scalar_op) \
-                  for (int k = 0; k < n_nel; k++) \
-                    if (static_cast<int> (n(k)) >= bits_in_type) \
-                      result(i+k) = 0; \
-                    else \
-                      result(i+k) = bitshift (m(i), static_cast<int> (n(k)), mask); \
+          for (int i = 0; i < m_nel; i++) \
+            if (is_scalar_op) \
+              for (int k = 0; k < n_nel; k++) \
+                if (static_cast<int> (n(k)) >= bits_in_type) \
+                  result(i+k) = 0; \
                 else \
-                  if (static_cast<int> (n(i)) >= bits_in_type) \
-                    result(i) = 0;                                      \
-                  else                                          \
-                    result(i) = bitshift (m(i), static_cast<int> (n(i)), mask); \
+                  result(i+k) = bitshift (m(i), static_cast<int> (n(k)), mask); \
+            else \
+              if (static_cast<int> (n(i)) >= bits_in_type) \
+                result(i) = 0; \
+              else \
+                result(i) = bitshift (m(i), static_cast<int> (n(i)), mask); \
  \
-              retval = result; \
-            } \
-          else \
-            error ("bitshift: size of A and N must match, or one operand must be a scalar"); \
+          retval = result; \
         } \
       else \
-        error ("bitshift: expecting integer as second argument"); \
-    }
+        error ("bitshift: size of A and N must match, or one operand must be a scalar"); \
+    } \
+  else \
+    error ("bitshift: expecting integer as second argument"); \
 
 #define DO_UBITSHIFT(T, N) \
   do \
     { \
       int bits_in_type = octave_ ## T :: nbits (); \
       T ## NDArray m = m_arg.T ## _array_value (); \
         octave_ ## T mask = octave_ ## T::max (); \
       if ((N) < bits_in_type) \
@@ -596,19 +593,16 @@ bitshift (10, [-2, -1, 0, 1, 2])\n\
                   if (error_state)
                     error ("bitshift: N must be an integer");
                   else if (nbits < 0)
                     error ("bitshift: N must be positive");
                 }
             }
         }
 
-      if (error_state)
-        return retval;
-
       octave_value m_arg = args(0);
       std::string cname = m_arg.class_name ();
 
       if (cname == "uint8")
         DO_UBITSHIFT (uint8, nbits < 8 ? nbits : 8);
       else if (cname == "uint16")
         DO_UBITSHIFT (uint16, nbits < 16 ? nbits : 16);
       else if (cname == "uint32")
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -1210,30 +1210,26 @@ get_dimensions (const octave_value& a, c
     {
       octave_idx_type nr = a.rows ();
       octave_idx_type nc = a.columns ();
 
       if (nr == 1 || nc == 1)
         {
           Array<double> v = a.vector_value ();
 
-          if (error_state)
-            return;
-
           octave_idx_type n = v.numel ();
           dim.resize (n);
           for (octave_idx_type i = 0; i < n; i++)
             dim(i) = static_cast<int> (fix (v(i)));
         }
       else
         error ("%s (A): use %s (size (A)) instead", warn_for, warn_for);
     }
 
-  if (! error_state)
-    check_dimensions (dim, warn_for); // May set error_state.
+  check_dimensions (dim, warn_for);
 }
 
 
 void
 get_dimensions (const octave_value& a, const char *warn_for,
                 octave_idx_type& nr, octave_idx_type& nc)
 {
   if (a.is_scalar_type ())
@@ -1244,41 +1240,38 @@ get_dimensions (const octave_value& a, c
     {
       nr = a.rows ();
       nc = a.columns ();
 
       if ((nr == 1 && nc == 2) || (nr == 2 && nc == 1))
         {
           Array<double> v = a.vector_value ();
 
-          if (error_state)
-            return;
 
           nr = static_cast<octave_idx_type> (fix (v (0)));
           nc = static_cast<octave_idx_type> (fix (v (1)));
         }
       else
         error ("%s (A): use %s (size (A)) instead", warn_for, warn_for);
     }
 
-  if (! error_state)
-    check_dimensions (nr, nc, warn_for); // May set error_state.
+  check_dimensions (nr, nc, warn_for);
 }
 
 void
 get_dimensions (const octave_value& a, const octave_value& b,
                 const char *warn_for, octave_idx_type& nr, octave_idx_type& nc)
 {
   nr = a.is_empty () ? 0 : a.int_value ();
   nc = b.is_empty () ? 0 : b.int_value ();
 
   if (error_state)
     error ("%s: expecting two scalar arguments", warn_for);
   else
-    check_dimensions (nr, nc, warn_for); // May set error_state.
+    check_dimensions (nr, nc, warn_for);
 }
 
 octave_idx_type
 dims_to_numel (const dim_vector& dims, const octave_value_list& idx)
 {
   octave_idx_type retval;
 
   octave_idx_type len = idx.length ();
@@ -1296,18 +1289,17 @@ dims_to_numel (const dim_vector& dims, c
             retval *= dv(i);
           else if (idxi.is_numeric_type ())
             retval *= idxi.numel ();
           else
             {
               try
                 {
                   idx_vector jdx = idxi.index_vector ();
-                  if (error_state)
-                    break;
+
                   retval *= jdx.length (dv(i));
                 }
               catch (index_exception& e)
                 {
                   error ("dims_to_numel: Invalid IDX %s. %s",
                                                         e.idx (), e.explain ());
                 }
             }
@@ -1453,43 +1445,33 @@ character @nospell{\"@xbackslashchar{}0\
   int nargin = args.length ();
   octave_idx_type n = 0;
 
   if (nargin == 2)
     n = args(1).idx_type_value ();
   else if (nargin != 1)
     print_usage ();
 
-  if (! error_state)
-    {
-      unwind_protect frame;
-
-      frame.protect_var (error_state);
+  unwind_protect frame;
 
-      frame.protect_var (discard_error_messages);
-      discard_error_messages = true;
+  frame.protect_var (discard_error_messages);
+  discard_error_messages = true;
 
-      try
-        {
-          idx_vector idx = args(0).index_vector (true);
+  try
+    {
+      idx_vector idx = args(0).index_vector (true);
 
-          if (! error_state)
-            {
-              if (nargin == 2)
-                retval = idx.extent (n) <= n;
-              else
-                retval = true;
-            }
-          else
-            retval = false;
-        }
-      catch (const octave_execution_exception&)
-        {
-          retval = false;
-        }
+      if (nargin == 2)
+        retval = idx.extent (n) <= n;
+      else
+        retval = true;
+    }
+  catch (const octave_execution_exception&)
+    {
+      retval = false;
     }
 
   return retval;
 }
 
 /*
 %!assert (isindex ([1, 2, 3]))
 %!assert (isindex (1:3))
@@ -1537,50 +1519,45 @@ do_simple_cellfun (octave_value_list (*f
           else if (dims != ccells[i].dims ())
             {
               error ("%s: cell arguments must have matching sizes", fun_name);
               break;
             }
         }
     }
 
-  if (! error_state)
-    {
-      for (int i = 0; i < nargout; i++)
-        rcells[i].clear (dims);
+  for (int i = 0; i < nargout; i++)
+    rcells[i].clear (dims);
 
-      for (octave_idx_type j = 0; j < numel; j++)
-        {
-          for (int i = 0; i < nargin; i++)
-            if (iscell[i])
-              new_args(i) = ccells[i](j);
+  for (octave_idx_type j = 0; j < numel; j++)
+    {
+      for (int i = 0; i < nargin; i++)
+        if (iscell[i])
+          new_args(i) = ccells[i](j);
 
-          octave_quit ();
+      octave_quit ();
 
-          const octave_value_list tmp = fun (new_args, nargout);
+      const octave_value_list tmp = fun (new_args, nargout);
 
-          if (tmp.length () < nargout)
-            {
-              error ("%s: do_simple_cellfun: internal error", fun_name);
-              break;
-            }
-          else
-            {
-              for (int i = 0; i < nargout; i++)
-                rcells[i](j) = tmp(i);
-            }
+      if (tmp.length () < nargout)
+        {
+          error ("%s: do_simple_cellfun: internal error", fun_name);
+          break;
+        }
+      else
+        {
+          for (int i = 0; i < nargout; i++)
+            rcells[i](j) = tmp(i);
         }
     }
 
-  if (! error_state)
-    {
-      retval.resize (nargout);
-      for (int i = 0; i < nargout; i++)
-        retval(i) = rcells[i];
-    }
+  retval.resize (nargout);
+
+  for (int i = 0; i < nargout; i++)
+    retval(i) = rcells[i];
 
   return retval;
 }
 
 octave_value
 do_simple_cellfun (octave_value_list (*fun) (const octave_value_list&, int),
                    const char *fun_name, const octave_value_list& args)
 {
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -155,17 +155,17 @@ sparse matrices.\n\
   if (nargin < 1 || nargin > 3 || nargout > 3
       || (! args(0).is_sparse_type () && nargout > 2))
     {
       print_usage ();
       return retval;
     }
 
   int n = 1;
-  while (n < nargin && ! error_state)
+  while (n < nargin)
     {
       std::string tmp = args(n++).string_value ();
 
       if (! error_state)
         {
           if (tmp.compare ("vector") == 0)
             vecout = true;
           else if (tmp.compare ("lower") == 0)
@@ -174,191 +174,170 @@ sparse matrices.\n\
             LLt = false;
           else
             error ("chol: unexpected second or third input");
         }
       else
         error ("chol: expecting trailing string arguments");
     }
 
-  if (! error_state)
-    {
-      octave_value arg = args(0);
+  octave_value arg = args(0);
 
-      octave_idx_type nr = arg.rows ();
-      octave_idx_type nc = arg.columns ();
+  octave_idx_type nr = arg.rows ();
+  octave_idx_type nc = arg.columns ();
+
+  int arg_is_empty = empty_arg ("chol", nr, nc);
 
-      int arg_is_empty = empty_arg ("chol", nr, nc);
+  if (arg_is_empty < 0)
+    return retval;
+  if (arg_is_empty > 0)
+    return octave_value (Matrix ());
 
-      if (arg_is_empty < 0)
-        return retval;
-      if (arg_is_empty > 0)
-        return octave_value (Matrix ());
+  if (arg.is_sparse_type ())
+    {
+      octave_idx_type info;
+      bool natural = (nargout != 3);
+      bool force = nargout > 1;
 
-      if (arg.is_sparse_type ())
+      if (arg.is_real_type ())
         {
-          octave_idx_type info;
-          bool natural = (nargout != 3);
-          bool force = nargout > 1;
+          SparseMatrix m = arg.sparse_matrix_value ();
 
-          if (arg.is_real_type ())
-            {
-              SparseMatrix m = arg.sparse_matrix_value ();
+          SparseCHOL fact (m, info, natural, force);
 
-              if (! error_state)
-                {
-                  SparseCHOL fact (m, info, natural, force);
-
-                  if (nargout == 3)
-                    {
-                      if (vecout)
-                        retval(2) = fact.perm ();
-                      else
-                        retval(2) = fact.Q ();
-                    }
+          if (nargout == 3)
+            {
+              if (vecout)
+                retval(2) = fact.perm ();
+              else
+                retval(2) = fact.Q ();
+            }
 
-                  if (nargout > 1 || info == 0)
-                    {
-                      retval(1) = info;
-                      if (LLt)
-                        retval(0) = fact.L ();
-                      else
-                        retval(0) = fact.R ();
-                    }
-                  else
-                    error ("chol: input matrix must be positive definite");
-                }
+          if (nargout > 1 || info == 0)
+            {
+              retval(1) = info;
+              if (LLt)
+                retval(0) = fact.L ();
+              else
+                retval(0) = fact.R ();
             }
-          else if (arg.is_complex_type ())
-            {
-              SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
-
-              if (! error_state)
-                {
-                  SparseComplexCHOL fact (m, info, natural, force);
+          else
+            error ("chol: input matrix must be positive definite");
+        }
+      else if (arg.is_complex_type ())
+        {
+          SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
-                  if (nargout == 3)
-                    {
-                      if (vecout)
-                        retval(2) = fact.perm ();
-                      else
-                        retval(2) = fact.Q ();
-                    }
+          SparseComplexCHOL fact (m, info, natural, force);
 
-                  if (nargout > 1 || info == 0)
-                    {
-                      retval(1) = info;
-                      if (LLt)
-                        retval(0) = fact.L ();
-                      else
-                        retval(0) = fact.R ();
-                    }
-                  else
-                    error ("chol: input matrix must be positive definite");
-                }
+          if (nargout == 3)
+            {
+              if (vecout)
+                retval(2) = fact.perm ();
+              else
+                retval(2) = fact.Q ();
+            }
+
+          if (nargout > 1 || info == 0)
+            {
+              retval(1) = info;
+              if (LLt)
+                retval(0) = fact.L ();
+              else
+                retval(0) = fact.R ();
             }
           else
-            gripe_wrong_type_arg ("chol", arg);
+            error ("chol: input matrix must be positive definite");
         }
-      else if (arg.is_single_type ())
+      else
+        gripe_wrong_type_arg ("chol", arg);
+    }
+  else if (arg.is_single_type ())
+    {
+      if (arg.is_real_type ())
         {
-          if (arg.is_real_type ())
-            {
-              FloatMatrix m = arg.float_matrix_value ();
-
-              if (! error_state)
-                {
-                  octave_idx_type info;
-
-                  FloatCHOL fact;
-                  fact = FloatCHOL (m, info, LLt != true);
+          FloatMatrix m = arg.float_matrix_value ();
 
-                  if (nargout == 2 || info == 0)
-                    {
-                      retval(1) = info;
-                      retval(0) = get_chol (fact);
-                    }
-                  else
-                    error ("chol: input matrix must be positive definite");
-                }
-            }
-          else if (arg.is_complex_type ())
-            {
-              FloatComplexMatrix m = arg.float_complex_matrix_value ();
+          octave_idx_type info;
 
-              if (! error_state)
-                {
-                  octave_idx_type info;
+          FloatCHOL fact;
+          fact = FloatCHOL (m, info, LLt != true);
 
-                  FloatComplexCHOL fact;
-                  if (LLt)
-                    fact = FloatComplexCHOL (m.transpose (), info);
-                  else
-                    fact = FloatComplexCHOL (m, info);
-
-                  if (nargout == 2 || info == 0)
-                    {
-                      retval(1) = info;
-                      if (LLt)
-                        retval(0) = get_chol_l (fact);
-                      else
-                        retval(0) = get_chol_r (fact);
-                    }
-                  else
-                    error ("chol: input matrix must be positive definite");
-                }
+          if (nargout == 2 || info == 0)
+            {
+              retval(1) = info;
+              retval(0) = get_chol (fact);
             }
           else
-            gripe_wrong_type_arg ("chol", arg);
+            error ("chol: input matrix must be positive definite");
+        }
+      else if (arg.is_complex_type ())
+        {
+          FloatComplexMatrix m = arg.float_complex_matrix_value ();
+
+          octave_idx_type info;
+
+          FloatComplexCHOL fact;
+          if (LLt)
+            fact = FloatComplexCHOL (m.transpose (), info);
+          else
+            fact = FloatComplexCHOL (m, info);
+
+          if (nargout == 2 || info == 0)
+            {
+              retval(1) = info;
+              if (LLt)
+                retval(0) = get_chol_l (fact);
+              else
+                retval(0) = get_chol_r (fact);
+            }
+          else
+            error ("chol: input matrix must be positive definite");
         }
       else
+        gripe_wrong_type_arg ("chol", arg);
+    }
+  else
+    {
+      if (arg.is_real_type ())
         {
-          if (arg.is_real_type ())
-            {
-              Matrix m = arg.matrix_value ();
-
-              if (! error_state)
-                {
-                  octave_idx_type info;
-
-                  CHOL fact;
-                  fact = CHOL (m, info, LLt != true);
+          Matrix m = arg.matrix_value ();
 
-                  if (nargout == 2 || info == 0)
-                    {
-                      retval(1) = info;
-                      retval(0) = get_chol (fact);
-                    }
-                  else
-                    error ("chol: input matrix must be positive definite");
-                }
-            }
-          else if (arg.is_complex_type ())
-            {
-              ComplexMatrix m = arg.complex_matrix_value ();
+          octave_idx_type info;
+
+          CHOL fact;
+          fact = CHOL (m, info, LLt != true);
 
-              if (! error_state)
-                {
-                  octave_idx_type info;
-
-                  ComplexCHOL fact;
-                  fact = ComplexCHOL (m, info, LLt != true);
-
-                  if (nargout == 2 || info == 0)
-                    {
-                      retval(1) = info;
-                      retval(0) = get_chol (fact);
-                    }
-                  else
-                    error ("chol: input matrix must be positive definite");
-                }
+          if (nargout == 2 || info == 0)
+            {
+              retval(1) = info;
+              retval(0) = get_chol (fact);
             }
           else
-            gripe_wrong_type_arg ("chol", arg);
+            error ("chol: input matrix must be positive definite");
         }
+      else if (arg.is_complex_type ())
+        {
+          ComplexMatrix m = arg.complex_matrix_value ();
+
+          octave_idx_type info;
+
+          ComplexCHOL fact;
+          fact = ComplexCHOL (m, info, LLt != true);
+
+          if (nargout == 2 || info == 0)
+            {
+              retval(1) = info;
+              retval(0) = get_chol (fact);
+            }
+          else
+            error ("chol: input matrix must be positive definite");
+        }
+      else
+        gripe_wrong_type_arg ("chol", arg);
     }
 
   return retval;
 }
 
 /*
 %!assert (chol ([2, 1; 1, 1]), [sqrt(2), 1/sqrt(2); 0, 1/sqrt(2)], sqrt (eps))
 %!assert (chol (single ([2, 1; 1, 1])), single ([sqrt(2), 1/sqrt(2); 0, 1/sqrt(2)]), sqrt (eps ("single")))
@@ -400,105 +379,87 @@ the Cholesky@tie{}factorization.\n\
           if (arg.is_sparse_type ())
             {
               octave_idx_type info;
 
               if (arg.is_real_type ())
                 {
                   SparseMatrix m = arg.sparse_matrix_value ();
 
-                  if (! error_state)
-                    {
-                      SparseCHOL chol (m, info);
+                  SparseCHOL chol (m, info);
 
-                      if (info == 0)
-                        retval = chol.inverse ();
-                      else
-                        error ("cholinv: A must be positive definite");
-                    }
+                  if (info == 0)
+                    retval = chol.inverse ();
+                  else
+                    error ("cholinv: A must be positive definite");
                 }
               else if (arg.is_complex_type ())
                 {
                   SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
-                  if (! error_state)
-                    {
-                      SparseComplexCHOL chol (m, info);
+                  SparseComplexCHOL chol (m, info);
 
-                      if (info == 0)
-                        retval = chol.inverse ();
-                      else
-                        error ("cholinv: A must be positive definite");
-                    }
+                  if (info == 0)
+                    retval = chol.inverse ();
+                  else
+                    error ("cholinv: A must be positive definite");
                 }
               else
                 gripe_wrong_type_arg ("cholinv", arg);
             }
           else if (arg.is_single_type ())
             {
               if (arg.is_real_type ())
                 {
                   FloatMatrix m = arg.float_matrix_value ();
 
-                  if (! error_state)
-                    {
-                      octave_idx_type info;
-                      FloatCHOL chol (m, info);
-                      if (info == 0)
-                        retval = chol.inverse ();
-                      else
-                        error ("cholinv: A must be positive definite");
-                    }
+                  octave_idx_type info;
+                  FloatCHOL chol (m, info);
+                  if (info == 0)
+                    retval = chol.inverse ();
+                  else
+                    error ("cholinv: A must be positive definite");
                 }
               else if (arg.is_complex_type ())
                 {
                   FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
-                  if (! error_state)
-                    {
-                      octave_idx_type info;
-                      FloatComplexCHOL chol (m, info);
-                      if (info == 0)
-                        retval = chol.inverse ();
-                      else
-                        error ("cholinv: A must be positive definite");
-                    }
+                  octave_idx_type info;
+                  FloatComplexCHOL chol (m, info);
+                  if (info == 0)
+                    retval = chol.inverse ();
+                  else
+                    error ("cholinv: A must be positive definite");
                 }
               else
                 gripe_wrong_type_arg ("chol", arg);
             }
           else
             {
               if (arg.is_real_type ())
                 {
                   Matrix m = arg.matrix_value ();
 
-                  if (! error_state)
-                    {
-                      octave_idx_type info;
-                      CHOL chol (m, info);
-                      if (info == 0)
-                        retval = chol.inverse ();
-                      else
-                        error ("cholinv: A must be positive definite");
-                    }
+                  octave_idx_type info;
+                  CHOL chol (m, info);
+                  if (info == 0)
+                    retval = chol.inverse ();
+                  else
+                    error ("cholinv: A must be positive definite");
                 }
               else if (arg.is_complex_type ())
                 {
                   ComplexMatrix m = arg.complex_matrix_value ();
 
-                  if (! error_state)
-                    {
-                      octave_idx_type info;
-                      ComplexCHOL chol (m, info);
-                      if (info == 0)
-                        retval = chol.inverse ();
-                      else
-                        error ("cholinv: A must be positive definite");
-                    }
+                  octave_idx_type info;
+                  ComplexCHOL chol (m, info);
+                  if (info == 0)
+                    retval = chol.inverse ();
+                  else
+                    error ("cholinv: A must be positive definite");
                 }
               else
                 gripe_wrong_type_arg ("chol", arg);
             }
         }
     }
   else
     print_usage ();
@@ -549,64 +510,58 @@ diagonal elements.  @code{chol2inv (@var
       else
         {
           if (arg.is_sparse_type ())
             {
               if (arg.is_real_type ())
                 {
                   SparseMatrix r = arg.sparse_matrix_value ();
 
-                  if (! error_state)
-                    retval = chol2inv (r);
+                  retval = chol2inv (r);
                 }
               else if (arg.is_complex_type ())
                 {
                   SparseComplexMatrix r = arg.sparse_complex_matrix_value ();
 
-                  if (! error_state)
-                    retval = chol2inv (r);
+                  retval = chol2inv (r);
                 }
               else
                 gripe_wrong_type_arg ("chol2inv", arg);
             }
           else if (arg.is_single_type ())
             {
               if (arg.is_real_type ())
                 {
                   FloatMatrix r = arg.float_matrix_value ();
 
-                  if (! error_state)
-                    retval = chol2inv (r);
+                  retval = chol2inv (r);
                 }
               else if (arg.is_complex_type ())
                 {
                   FloatComplexMatrix r = arg.float_complex_matrix_value ();
 
-                  if (! error_state)
-                    retval = chol2inv (r);
+                  retval = chol2inv (r);
                 }
               else
                 gripe_wrong_type_arg ("chol2inv", arg);
 
             }
           else
             {
               if (arg.is_real_type ())
                 {
                   Matrix r = arg.matrix_value ();
 
-                  if (! error_state)
-                    retval = chol2inv (r);
+                  retval = chol2inv (r);
                 }
               else if (arg.is_complex_type ())
                 {
                   ComplexMatrix r = arg.complex_matrix_value ();
 
-                  if (! error_state)
-                    retval = chol2inv (r);
+                  retval = chol2inv (r);
                 }
               else
                 gripe_wrong_type_arg ("chol2inv", arg);
             }
         }
     }
   else
     print_usage ();
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -826,34 +826,26 @@ make_java_index (JNIEnv* jni_env, const 
   jclass_ref ocls (jni_env, jni_env->FindClass ("[I"));
   jobjectArray retval = jni_env->NewObjectArray (idx.length (), ocls, 0);
 
   for (int i = 0; i < idx.length (); i++)
     try
       {
         idx_vector v = idx(i).index_vector ();
 
-        if (! error_state)
-          {
-            jintArray_ref i_array (jni_env, jni_env->NewIntArray (v.length ()));
-            jint *buf = jni_env->GetIntArrayElements (i_array, 0);
-
-            for (int k = 0; k < v.length (); k++)
-              buf[k] = v(k);
-
-            jni_env->ReleaseIntArrayElements (i_array, buf, 0);
-            jni_env->SetObjectArrayElement (retval, i, i_array);
-
-            check_exception (jni_env);
-
-            if (error_state)
-              break;
-          }
-        else
-          break;
+        jintArray_ref i_array (jni_env, jni_env->NewIntArray (v.length ()));
+        jint *buf = jni_env->GetIntArrayElements (i_array, 0);
+
+        for (int k = 0; k < v.length (); k++)
+          buf[k] = v(k);
+
+        jni_env->ReleaseIntArrayElements (i_array, buf, 0);
+        jni_env->SetObjectArrayElement (retval, i, i_array);
+
+        check_exception (jni_env);
       }
     catch (index_exception& e)
       {
         // Rethrow to allow more info to be reported later.
         e.set_pos_if_unset (idx.length (), i+1);
         throw;
       }
 
@@ -863,22 +855,19 @@ make_java_index (JNIEnv* jni_env, const 
 static octave_value
 get_array_elements (JNIEnv* jni_env, jobject jobj,
                     const octave_value_list& idx)
 {
   octave_value retval;
   jobject_ref resObj (jni_env);
   jobject_ref java_idx (jni_env, make_java_index (jni_env, idx));
 
-  if (! error_state)
-    {
-      jclass_ref helperClass (jni_env, find_octave_class (jni_env, "org/octave/ClassHelper"));
-      jmethodID mID = jni_env->GetStaticMethodID (helperClass, "arraySubsref", "(Ljava/lang/Object;[[I)Ljava/lang/Object;");
-      resObj = jni_env->CallStaticObjectMethod (helperClass, mID, jobj, jobject (java_idx));
-    }
+  jclass_ref helperClass (jni_env, find_octave_class (jni_env, "org/octave/ClassHelper"));
+  jmethodID mID = jni_env->GetStaticMethodID (helperClass, "arraySubsref", "(Ljava/lang/Object;[[I)Ljava/lang/Object;");
+  resObj = jni_env->CallStaticObjectMethod (helperClass, mID, jobj, jobject (java_idx));
 
   if (resObj)
     retval = box (jni_env, resObj);
   else
     retval = check_exception (jni_env);
 
   restore_fpu_state ();
 
@@ -891,17 +880,17 @@ set_array_elements (JNIEnv* jni_env, job
 {
   octave_value retval;
 
   jclass_ref rhsCls (jni_env);
   jobject_ref resObj (jni_env);
   jobject_ref rhsObj (jni_env);
   jobject_ref java_idx (jni_env, make_java_index (jni_env, idx));
 
-  if (! error_state && unbox (jni_env, rhs, rhsObj, rhsCls))
+  if (unbox (jni_env, rhs, rhsObj, rhsCls))
     {
       jclass_ref helperClass (jni_env, find_octave_class (jni_env, "org/octave/ClassHelper"));
       jmethodID mID = jni_env->GetStaticMethodID (helperClass, "arraySubsasgn",
           "(Ljava/lang/Object;[[ILjava/lang/Object;)Ljava/lang/Object;");
       resObj = jni_env->CallStaticObjectMethod (helperClass, mID,
           jobj, jobject (java_idx), jobject (rhsObj));
     }
 
@@ -980,22 +969,17 @@ convert_to_string (JNIEnv *jni_env, jobj
 
               for (int i = 0; i < len; i++)
                 {
                   jstring_ref js (jni_env, reinterpret_cast<jstring> (jni_env->GetObjectArrayElement (array, i)));
 
                   if (js)
                     c(i) = octave_value (jstring_to_string (jni_env, js), type);
                   else
-                    {
-                      c(i) = check_exception (jni_env);
-
-                      if (error_state)
-                        break;
-                    }
+                    c(i) = check_exception (jni_env);
                 }
 
               retval = octave_value (c);
             }
           else
             {
               cls = jni_env->FindClass ("java/lang/Object");
               jmethodID mID = jni_env->GetMethodID (cls, "toString", "()Ljava/lang/String;");
@@ -1563,18 +1547,16 @@ Java_org_octave_Octave_call (JNIEnv *env
   int nargin = env->GetArrayLength (argin);
 
   octave_value_list varargin, varargout;
 
   for (int i = 0; i < nargin; i++)
     varargin(i) = box (env, env->GetObjectArrayElement (argin, i), 0);
 
   varargout = feval (fname, varargin, nargout);
-  if (error_state)
-    return false;
 
   jobjectArray_ref out_objs (env, argout), out_clss (env);
   out_objs.detach ();
   return unbox (env, varargout, out_objs, out_clss);
 }
 
 JNIEXPORT void JNICALL
 Java_org_octave_OctaveReference_doFinalize (JNIEnv *, jclass, jint ID)
@@ -1593,48 +1575,41 @@ Java_org_octave_Octave_doInvoke (JNIEnv 
       octave_value val = it->second;
       int len = env->GetArrayLength (args);
       octave_value_list oct_args;
 
       for (int i = 0; i < len; i++)
         {
           jobject_ref jobj (env, env->GetObjectArrayElement (args, i));
           oct_args(i) = box (env, jobj, 0);
-
-          if (error_state)
-            break;
         }
 
-      if (! error_state)
+      BEGIN_INTERRUPT_WITH_EXCEPTIONS;
+
+      if (val.is_function_handle ())
+        {
+          octave_function *fcn = val.function_value ();
+          feval (fcn, oct_args);
+        }
+      else if (val.is_cell () && val.length () > 0
+               && (val.rows () == 1 || val.columns () == 1)
+               && val.cell_value()(0).is_function_handle ())
         {
-          BEGIN_INTERRUPT_WITH_EXCEPTIONS;
-
-          if (val.is_function_handle ())
-            {
-              octave_function *fcn = val.function_value ();
-              feval (fcn, oct_args);
-            }
-          else if (val.is_cell () && val.length () > 0
-                   && (val.rows () == 1 || val.columns () == 1)
-                   && val.cell_value()(0).is_function_handle ())
-            {
-              Cell c = val.cell_value ();
-              octave_function *fcn = c(0).function_value ();
-
-              for (int i=1; i<c.numel (); i++)
-                oct_args(len+i-1) = c(i);
-
-              if (! error_state)
-                feval (fcn, oct_args);
-            }
-          else
-            error ("trying to invoke non-invocable object");
-
-          END_INTERRUPT_WITH_EXCEPTIONS;
+          Cell c = val.cell_value ();
+          octave_function *fcn = c(0).function_value ();
+
+          for (int i=1; i<c.numel (); i++)
+            oct_args(len+i-1) = c(i);
+
+          feval (fcn, oct_args);
         }
+      else
+        error ("trying to invoke non-invocable object");
+
+      END_INTERRUPT_WITH_EXCEPTIONS;
     }
 }
 
 JNIEXPORT void JNICALL
 Java_org_octave_Octave_doEvalString (JNIEnv *env, jclass, jstring cmd)
 {
   std::string s = jstring_to_string (env, cmd);
   int pstatus;
@@ -1748,70 +1723,58 @@ octave_java::subsasgn (const std::string
         {
           // field assignment
           octave_value_list ovl;
           count++;
           ovl(0) = octave_value (this);
           ovl(1) = (idx.front ())(0);
           ovl(2) = rhs;
           feval ("__java_set__", ovl, 0);
-          if (! error_state)
-            {
-              count++;
-              retval = octave_value (this);
-            }
+
+          count++;
+          retval = octave_value (this);
         }
       else if (type.length () > 2 && type[1] == '(')
         {
           std::list<octave_value_list> new_idx;
           std::list<octave_value_list>::const_iterator it = idx.begin ();
           new_idx.push_back (*it++);
           new_idx.push_back (*it++);
           octave_value_list u = subsref (type.substr (0, 2), new_idx, 1);
-          if (! error_state)
-            {
-              std::list<octave_value_list> next_idx (idx);
-              next_idx.erase (next_idx.begin ());
-              next_idx.erase (next_idx.begin ());
-              u(0).subsasgn (type.substr (2), next_idx, rhs);
-              if (! error_state)
-                {
-                  count++;
-                  retval = octave_value (this);
-                }
-            }
+
+          std::list<octave_value_list> next_idx (idx);
+          next_idx.erase (next_idx.begin ());
+          next_idx.erase (next_idx.begin ());
+          u(0).subsasgn (type.substr (2), next_idx, rhs);
+
+          count++;
+          retval = octave_value (this);
         }
       else if (type[1] == '.')
         {
           octave_value_list u = subsref (type.substr (0, 1), idx, 1);
-          if (! error_state)
-            {
-              std::list<octave_value_list> next_idx (idx);
-              next_idx.erase (next_idx.begin ());
-              u(0).subsasgn (type.substr (1), next_idx, rhs);
-              if (! error_state)
-                {
-                  count++;
-                  retval = octave_value (this);
-                }
-            }
+
+          std::list<octave_value_list> next_idx (idx);
+          next_idx.erase (next_idx.begin ());
+          u(0).subsasgn (type.substr (1), next_idx, rhs);
+
+          count++;
+          retval = octave_value (this);
         }
       else
         error ("invalid indexing/assignment on Java object");
       break;
 
     case '(':
       if (current_env)
         {
           set_array_elements (current_env, to_java (), idx.front (), rhs);
-          if (! error_state)
-            {
-              count++;
-              retval = octave_value (this);
-            }
+
+          count++;
+          retval = octave_value (this);
         }
       break;
 
     default:
       error ("Java object cannot be indexed with %c", type[0]);
       break;
     }
 
@@ -2117,18 +2080,17 @@ Function will directly call initialize_j
 
 #ifdef HAVE_JAVA
   octave_value retval;
 
   retval = 0;
 
   initialize_java ();
 
-  if (! error_state)
-    retval = 1;
+  retval = 1;
 
   return retval;
 #else
   error ("__java_init__: Octave was not compiled with Java interface");
   return octave_value ();
 #endif
 }
 
@@ -2170,37 +2132,34 @@ x = javaObject (\"java.lang.StringBuffer
 @seealso{javaMethod, javaArray}\n\
 @end deftypefn")
 {
 #ifdef HAVE_JAVA
   octave_value retval;
 
   initialize_java ();
 
-  if (! error_state)
+  JNIEnv *current_env = octave_java::thread_jni_env ();
+
+  if (args.length () > 0)
     {
-      JNIEnv *current_env = octave_java::thread_jni_env ();
-
-      if (args.length () > 0)
+      if (args(0).is_string ())
         {
-          if (args(0).is_string ())
-            {
-              std::string classname = args(0).string_value ();
-
-              octave_value_list tmp;
-              for (int i=1; i<args.length (); i++)
-                tmp(i-1) = args(i);
-              retval = octave_java::do_javaObject (current_env, classname, tmp);
-            }
-          else
-            error ("javaObject: CLASSNAME must be a string");
+          std::string classname = args(0).string_value ();
+
+          octave_value_list tmp;
+          for (int i=1; i<args.length (); i++)
+            tmp(i-1) = args(i);
+          retval = octave_java::do_javaObject (current_env, classname, tmp);
         }
       else
-        print_usage ();
+        error ("javaObject: CLASSNAME must be a string");
     }
+  else
+    print_usage ();
 
   return retval;
 #else
   error ("javaObject: Octave was not compiled with Java interface");
   return octave_value ();
 #endif
 }
 
@@ -2238,49 +2197,46 @@ equivalent\n\
 @seealso{methods, javaObject}\n\
 @end deftypefn")
 {
 #ifdef HAVE_JAVA
   octave_value retval;
 
   initialize_java ();
 
-  if (! error_state)
+  JNIEnv *current_env = octave_java::thread_jni_env ();
+
+  if (args.length () > 1)
     {
-      JNIEnv *current_env = octave_java::thread_jni_env ();
-
-      if (args.length () > 1)
+      if (args(0).is_string ())
         {
-          if (args(0).is_string ())
+          std::string methodname = args(0).string_value ();
+
+          octave_value_list tmp;
+          for (int i=2; i<args.length (); i++)
+            tmp(i-2) = args(i);
+
+          if (args(1).is_java ())
             {
-              std::string methodname = args(0).string_value ();
-
-              octave_value_list tmp;
-              for (int i=2; i<args.length (); i++)
-                tmp(i-2) = args(i);
-
-              if (args(1).is_java ())
-                {
-                  octave_java *jobj = TO_JAVA (args(1));
-                  retval = jobj->do_javaMethod (current_env, methodname, tmp);
-                }
-              else if (args(1).is_string ())
-                {
-                  std::string cls = args(1).string_value ();
-                  retval = octave_java::do_javaMethod (current_env, cls, methodname, tmp);
-                }
-              else
-                error ("javaMethod: OBJ must be a Java object or a string");
+              octave_java *jobj = TO_JAVA (args(1));
+              retval = jobj->do_javaMethod (current_env, methodname, tmp);
+            }
+          else if (args(1).is_string ())
+            {
+              std::string cls = args(1).string_value ();
+              retval = octave_java::do_javaMethod (current_env, cls, methodname, tmp);
             }
           else
-            error ("javaMethod: METHODNAME must be a string");
+            error ("javaMethod: OBJ must be a Java object or a string");
         }
       else
-        print_usage ();
+        error ("javaMethod: METHODNAME must be a string");
     }
+  else
+    print_usage ();
 
   return retval;
 #else
   error ("javaMethod: Octave was not compiled with Java interface");
   return octave_value ();
 #endif
 }
 
@@ -2313,45 +2269,42 @@ equivalent\n\
 @seealso{__java_set__, javaMethod, javaObject}\n\
 @end deftypefn")
 {
 #ifdef HAVE_JAVA
   octave_value retval;
 
   initialize_java ();
 
-  if (! error_state)
+  JNIEnv *current_env = octave_java::thread_jni_env ();
+
+  if (args.length () == 2)
     {
-      JNIEnv *current_env = octave_java::thread_jni_env ();
-
-      if (args.length () == 2)
+      if (args(1).is_string ())
         {
-          if (args(1).is_string ())
+          std::string name = args(1).string_value ();
+
+          if (args(0).is_java ())
             {
-              std::string name = args(1).string_value ();
-
-              if (args(0).is_java ())
-                {
-                  octave_java *jobj = TO_JAVA (args(0));
-                  retval = jobj->do_java_get (current_env, name);
-                }
-              else if (args(0).is_string ())
-                {
-                  std::string cls = args(0).string_value ();
-                  retval = octave_java::do_java_get (current_env, cls, name);
-                }
-              else
-                error ("__java_get__: OBJ must be a Java object or a string");
+              octave_java *jobj = TO_JAVA (args(0));
+              retval = jobj->do_java_get (current_env, name);
+            }
+          else if (args(0).is_string ())
+            {
+              std::string cls = args(0).string_value ();
+              retval = octave_java::do_java_get (current_env, cls, name);
             }
           else
-            error ("__java_get__: NAME must be a string");
+            error ("__java_get__: OBJ must be a Java object or a string");
         }
       else
-        print_usage ();
+        error ("__java_get__: NAME must be a string");
     }
+  else
+    print_usage ();
 
   return retval;
 #else
   error ("__java_get__: Octave was not compiled with Java interface");
   return octave_value ();
 #endif
 }
 
@@ -2378,45 +2331,42 @@ equivalent\n\
 @seealso{__java_get__, javaMethod, javaObject}\n\
 @end deftypefn")
 {
 #ifdef HAVE_JAVA
   octave_value retval;
 
   initialize_java ();
 
-  if (! error_state)
+  JNIEnv *current_env = octave_java::thread_jni_env ();
+
+  if (args.length () == 3)
     {
-      JNIEnv *current_env = octave_java::thread_jni_env ();
-
-      if (args.length () == 3)
+      if (args(1).is_string ())
         {
-          if (args(1).is_string ())
+          std::string name = args(1).string_value ();
+
+          if (args(0).is_java ())
             {
-              std::string name = args(1).string_value ();
-
-              if (args(0).is_java ())
-                {
-                  octave_java *jobj = TO_JAVA (args(0));
-                  retval = jobj->do_java_set (current_env, name, args(2));
-                }
-              else if (args(0).is_string ())
-                {
-                  std::string cls = args(0).string_value ();
-                  retval = octave_java::do_java_set (current_env, cls, name, args(2));
-                }
-              else
-                error ("__java_set__: OBJ must be a Java object or a string");
+              octave_java *jobj = TO_JAVA (args(0));
+              retval = jobj->do_java_set (current_env, name, args(2));
+            }
+          else if (args(0).is_string ())
+            {
+              std::string cls = args(0).string_value ();
+              retval = octave_java::do_java_set (current_env, cls, name, args(2));
             }
           else
-            error ("__java_set__: NAME must be a string");
+            error ("__java_set__: OBJ must be a Java object or a string");
         }
       else
-        print_usage ();
+        error ("__java_set__: NAME must be a string");
     }
+  else
+    print_usage ();
 
   return retval;
 #else
   error ("__java_set__: Octave was not compiled with Java interface");
   return octave_value ();
 #endif
 }
 
@@ -2426,33 +2376,30 @@ DEFUN (java2mat, args, ,
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifdef HAVE_JAVA
   octave_value_list retval;
 
   initialize_java ();
 
-  if (! error_state)
+  JNIEnv *current_env = octave_java::thread_jni_env ();
+
+  if (args.length () == 1)
     {
-      JNIEnv *current_env = octave_java::thread_jni_env ();
-
-      if (args.length () == 1)
+      if (args(0).is_java ())
         {
-          if (args(0).is_java ())
-            {
-              octave_java *jobj = TO_JAVA (args(0));
-              retval(0) = box_more (current_env, jobj->to_java (), 0);
-            }
-          else
-            retval(0) = args(0);
+          octave_java *jobj = TO_JAVA (args(0));
+          retval(0) = box_more (current_env, jobj->to_java (), 0);
         }
       else
-        print_usage ();
+        retval(0) = args(0);
     }
+  else
+    print_usage ();
 
   return retval;
 #else
   error ("java2mat: Octave was not compiled with Java interface");
   return octave_value ();
 #endif
 }
 
