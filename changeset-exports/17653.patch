# HG changeset patch
# User Michael Goffioul <michael.goffioul@gmail.com>
# Date 1381777212 14400
#      Mon Oct 14 15:00:12 2013 -0400
# Branch classdef
# Node ID bb2fa6e5b3482787740c0252ecf41f5dd8e616b1
# Parent  a98902bda11a4514b7b9b0844479bf95b42905fa
# Parent  a09511ebf7efea3a3cb783880a26d9889f8f03bf
maint: periodic merge of default to classdef

diff --git a/.dir-locals.el b/.dir-locals.el
--- a/.dir-locals.el
+++ b/.dir-locals.el
@@ -1,10 +1,11 @@
 ((nil .
       ((c-file-style . "gnu")
        (indent-tabs-mode . nil)
        (fill-column . 72)
-       (eval . (when (string-match "\\.h\\'" (buffer-file-name))
-                 (unless (string-match "/gnulib/" (buffer-file-name))
-                   (c++-mode)
-                   (c-set-style "gnu"))))))
+       (eval . (when (and (buffer-file-name)
+                          (string-match-p "\\.h\\'" (buffer-file-name))
+                          (not (string-match-p "/gnulib/" (buffer-file-name))))
+                 (c++-mode)
+                 (c-set-style "gnu")))))
  (change-log-mode . ((indent-tabs-mode . t)))
  (makefile-mode . ((indent-tabs-mode . t))))
diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -1,8 +1,9 @@
+<pre>
 Summary of important user-visible changes for version 4.0:
 ---------------------------------------------------------
 
  ** A new GUI is now available with Octave.
 
  ** Warning states may now be set temporarily, until the end of the
     current function, using the syntax
 
@@ -1465,8 +1466,9 @@ Summary of important user-visible change
       loadimage           spfind     spsumsq
       mark_as_command     spinv      str2mat
       mark_as_rawcommand  spkron     unmark_command
       spatan2             splchol    unmark_rawcommand
       spchol              split
       spchol2inv          splu
 
 See NEWS.3 for old news.
+</pre>
diff --git a/bootstrap.conf b/bootstrap.conf
--- a/bootstrap.conf
+++ b/bootstrap.conf
@@ -64,16 +64,17 @@ gnulib_modules="
   readdir
   readlink
   realloc-gnu
   rename
   rmdir
   round
   roundf
   select
+  setenv
   sigaction
   signal
   sigprocmask
   sleep
   stat
   stddef
   stdint
   stdio
diff --git a/libgui/default-qt-settings.in b/libgui/default-qt-settings.in
--- a/libgui/default-qt-settings.in
+++ b/libgui/default-qt-settings.in
@@ -23,49 +23,58 @@ mru_file_list=@Invalid()
 
 [terminal]
 fontSize=%DEFAULT_TERMINAL_FONT_SIZE%
 fontName=%DEFAULT_TERMINAL_FONT%
 cursorBlinking=true
 cursorType=ibeam
 
 [MainWindow]
-geometry="@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\0\0\0\x14\0\0\0'\0\0\x4;\0\0\x3\x4\0\0\0\x1e\0\0\0\x45\0\0\x4\x31\0\0\x2\xfa\0\0\0\0\0\0)"
-windowState="@ByteArray(\0\0\0\xff\0\0\0\0\xfd\0\0\0\x1\0\0\0\x1\0\0\x4\x14\0\0\x2]\xfc\x2\0\0\0\x1\xfc\0\0\0\x42\0\0\x2]\0\0\x1\xa7\0\xff\xff\xff\xfc\x1\0\0\0\x2\xfc\0\0\0\0\0\0\x1y\0\0\0X\0\xff\xff\xff\xfc\x2\0\0\0\x3\xfb\0\0\0\x1e\0\x46\0i\0l\0\x65\0s\0\x44\0o\0\x63\0k\0W\0i\0\x64\0g\0\x65\0t\x1\0\0\0\x42\0\0\0\xc0\0\0\0\x97\0\xff\xff\xff\xfb\0\0\0\x1a\0W\0o\0r\0k\0s\0p\0\x61\0\x63\0\x65\0V\0i\0\x65\0w\x1\0\0\x1\b\0\0\0\xce\0\0\0q\0\xff\xff\xff\xfb\0\0\0\"\0H\0i\0s\0t\0o\0r\0y\0\x44\0o\0\x63\0k\0W\0i\0\x64\0g\0\x65\0t\x1\0\0\x1\xdc\0\0\0\xc3\0\0\0\x93\0\xff\xff\xff\xfc\0\0\x1\x7f\0\0\x2\x95\0\0\x1,\0\xff\xff\xff\xfa\0\0\0\0\x2\0\0\0\x3\xfb\0\0\0$\0T\0\x65\0r\0m\0i\0n\0\x61\0l\0\x44\0o\0\x63\0k\0W\0i\0\x64\0g\0\x65\0t\x1\0\0\0\0\xff\xff\xff\xff\0\0\0\xe1\0\xff\xff\xff\xfb\0\0\0\x14\0\x46\0i\0l\0\x65\0\x45\0\x64\0i\0t\0o\0r\x1\0\0\0\0\xff\xff\xff\xff\0\0\0k\0\xff\xff\xff\xfb\0\0\0.\0\x44\0o\0\x63\0u\0m\0\x65\0n\0t\0\x61\0t\0i\0o\0n\0\x44\0o\0\x63\0k\0W\0i\0\x64\0g\0\x65\0t\x1\0\0\0\0\xff\xff\xff\xff\0\0\0\xba\0\xff\xff\xff\0\0\0\0\0\0\x2]\0\0\0\x4\0\0\0\x4\0\0\0\b\0\0\0\b\xfc\0\0\0\x1\0\0\0\x2\0\0\0\x1\0\0\0\x16\0M\0\x61\0i\0n\0T\0o\0o\0l\0\x42\0\x61\0r\x1\0\0\0\0\xff\xff\xff\xff\0\0\0\0\0\0\0\0)"
-current_directory_list=/scratch/jwe/build/octave
+geometry=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\xff\xff\xff\xfa\0\0\0\x13\0\0\x4\xc1\0\0\x3\xb4\0\0\0\x4\0\0\0\x31\0\0\x4\xb7\0\0\x3\xaa\0\0\0\0\0\0)
+windowState="@ByteArray(\0\0\0\xff\0\0\0\0\xfd\0\0\0\x1\0\0\0\x1\0\0\x4\xb4\0\0\x3#\xfc\x2\0\0\0\x1\xfc\0\0\0@\0\0\x3#\0\0\x1\x7f\0\xff\xff\xff\xfc\x1\0\0\0\x2\xfc\0\0\0\0\0\0\x2\x1c\0\0\0\xb4\0\xff\xff\xff\xfc\x2\0\0\0\x3\xfb\0\0\0\x1e\0\x46\0i\0l\0\x65\0s\0\x44\0o\0\x63\0k\0W\0i\0\x64\0g\0\x65\0t\x1\0\0\0@\0\0\x1#\0\0\0\x89\0\xff\xff\xff\xfb\0\0\0\x1a\0W\0o\0r\0k\0s\0p\0\x61\0\x63\0\x65\0V\0i\0\x65\0w\x1\0\0\x1i\0\0\0\xd4\0\0\0\x63\0\xff\xff\xff\xfb\0\0\0\"\0H\0i\0s\0t\0o\0r\0y\0\x44\0o\0\x63\0k\0W\0i\0\x64\0g\0\x65\0t\x1\0\0\x2\x43\0\0\x1 \0\0\0\x87\0\xff\xff\xff\xfc\0\0\x2\"\0\0\x2\x92\0\0\x1,\0\xff\xff\xff\xfc\x2\0\0\0\x2\xfb\0\0\0\x1c\0N\0\x65\0w\0s\0\x44\0o\0\x63\0k\0W\0i\0\x64\0g\0\x65\0t\x1\0\0\0@\0\0\0\xdb\0\0\0\x14\0\xff\xff\xff\xfc\0\0\x1!\0\0\x2\x42\0\0\0\xfb\x1\0\0\x1e\xfa\0\0\0\0\x2\0\0\0\x3\xfb\0\0\0$\0T\0\x65\0r\0m\0i\0n\0\x61\0l\0\x44\0o\0\x63\0k\0W\0i\0\x64\0g\0\x65\0t\x1\0\0\0\0\xff\xff\xff\xff\0\0\0\xdc\0\xff\xff\xff\xfb\0\0\0\x14\0\x46\0i\0l\0\x65\0\x45\0\x64\0i\0t\0o\0r\x1\0\0\0\0\xff\xff\xff\xff\0\0\0\x64\0\xff\xff\xff\xfb\0\0\0.\0\x44\0o\0\x63\0u\0m\0\x65\0n\0t\0\x61\0t\0i\0o\0n\0\x44\0o\0\x63\0k\0W\0i\0\x64\0g\0\x65\0t\x1\0\0\0\0\xff\xff\xff\xff\0\0\0\xae\0\xff\xff\xff\0\0\0\0\0\0\x3#\0\0\0\x4\0\0\0\x4\0\0\0\b\0\0\0\b\xfc\0\0\0\x1\0\0\0\x2\0\0\0\x1\0\0\0\x16\0M\0\x61\0i\0n\0T\0o\0o\0l\0\x42\0\x61\0r\x1\0\0\0\0\xff\xff\xff\xff\0\0\0\0\0\0\0\0)"
 
 [DockWidgets]
-TerminalDockWidget=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\0\0\x1\x7f\0\0\0\x42\0\0\x4\x13\0\0\x2\x7f\0\0\x1\x7f\0\0\0\x42\0\0\x4\x13\0\0\x2\x7f\0\0\0\0\0\0)
+NewsDockWidget_floating_geometry=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\0\0\0\0\0\0\0\0\0\0\0\x63\0\0\0\x1d\0\0\0\0\0\0\0\0\0\0\0\x63\0\0\0\x1d\0\0\0\0\0\0)
+TerminalDockWidget_floating_geometry=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\xff\xff\xfd\xa8\xff\xff\xfd\xee\xff\xff\xfe\v\xff\xff\xfe\v\xff\xff\xfd\xa8\xff\xff\xfd\xee\xff\xff\xfe\v\xff\xff\xfe\v\0\0\0\0\0\0)
 TerminalDockWidgetFloating=false
 TerminalDockWidgetVisible=true
-WorkspaceView=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\0\0\0\0\0\0\x1\b\0\0\x1x\0\0\x1\xd5\0\0\0\0\0\0\x1\b\0\0\x1x\0\0\x1\xd5\0\0\0\0\0\0)
+WorkspaceView=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\0\0\0\0\0\0\x1i\0\0\x2\x1b\0\0\x2<\0\0\0\0\0\0\x1i\0\0\x2\x1b\0\0\x2<\0\0\0\0\0\0)
 WorkspaceViewFloating=false
 WorkspaceViewVisible=true
-HistoryDockWidget=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\0\0\0\0\0\0\x1\xdc\0\0\x1x\0\0\x2\x9e\0\0\0\0\0\0\x1\xdc\0\0\x1x\0\0\x2\x9e\0\0\0\0\0\0)
+HistoryDockWidget=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\0\0\0\0\0\0\x2\x43\0\0\x2\x1b\0\0\x3\x62\0\0\0\0\0\0\x2\x43\0\0\x2\x1b\0\0\x3\x62\0\0\0\0\0\0)
 HistoryDockWidgetFloating=false
 HistoryDockWidgetVisible=true
-FilesDockWidget=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\0\0\0\0\0\0\0\x42\0\0\x1x\0\0\x1\x1\0\0\0\0\0\0\0\x42\0\0\x1x\0\0\x1\x1\0\0\0\0\0\0)
+FilesDockWidget=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\0\0\0\0\0\0\0@\0\0\x2\x1b\0\0\x1\x62\0\0\0\0\0\0\0@\0\0\x2\x1b\0\0\x1\x62\0\0\0\0\0\0)
 FilesDockWidgetFloating=false
 FilesDockWidgetVisible=true
-DocumentationDockWidget=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\xff\xff\xfb\xb3\xff\xff\xfb\xb1\xff\xff\xfe\v\xff\xff\xfe\v\xff\xff\xfb\xb3\xff\xff\xfb\xb1\xff\xff\xfe\v\xff\xff\xfe\v\0\0\0\0\0\0)
+DocumentationDockWidget=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\xff\xff\xfd\x31\xff\xff\xfd^\xff\xff\xfe\v\xff\xff\xfe\v\xff\xff\xfd\x31\xff\xff\xfd^\xff\xff\xfe\v\xff\xff\xfe\v\0\0\0\0\0\0)
 DocumentationDockWidgetFloating=false
 DocumentationDockWidgetVisible=true
-FileEditor=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\xff\xff\xfb\xb3\xff\xff\xfb\xb1\xff\xff\xfe\v\xff\xff\xfe\v\xff\xff\xfb\xb3\xff\xff\xfb\xb1\xff\xff\xfe\v\xff\xff\xfe\v\0\0\0\0\0\0)
+FileEditor=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\xff\xff\xfc\x18\xff\xff\xfc|\xff\xff\xfe\v\xff\xff\xfe\v\xff\xff\xfc\x18\xff\xff\xfc|\xff\xff\xfe\v\xff\xff\xfe\v\0\0\0\0\0\0)
 FileEditorFloating=false
 FileEditorVisible=true
+HistoryDockWidget_floating_geometry=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\0\0\0\0\0\0\0\0\0\0\0\x63\0\0\0\x1d\0\0\0\0\0\0\0\0\0\0\0\x63\0\0\0\x1d\0\0\0\0\0\0)
+FilesDockWidget_floating_geometry=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\0\0\0\0\0\0\0\0\0\0\0\x63\0\0\0\x1d\0\0\0\0\0\0\0\0\0\0\0\x63\0\0\0\x1d\0\0\0\0\0\0)
+DocumentationDockWidget_floating_geometry=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\xff\xff\xfd\xa8\xff\xff\xfd\xee\xff\xff\xfe\v\xff\xff\xfe\v\xff\xff\xfd\xa8\xff\xff\xfd\xee\xff\xff\xfe\v\xff\xff\xfe\v\0\0\0\0\0\0)
+FileEditor_floating_geometry=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\0\0\0\0\0\0\0\0\0\0\x1\xf3\0\0\x1\x8f\0\0\0\0\0\0\0\0\0\0\x1\xf3\0\0\x1\x8f\0\0\0\0\0\0)
+WorkspaceView_floating_geometry=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\0\0\0\0\0\0\0\0\0\0\0\x63\0\0\0\x1d\0\0\0\0\0\0\0\0\0\0\0\x63\0\0\0\x1d\0\0\0\0\0\0)
+NewsDockWidget=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\0\0\x2\"\0\0\0@\0\0\x4\xb3\0\0\x1\x1a\0\0\x2\"\0\0\0@\0\0\x4\xb3\0\0\x1\x1a\0\0\0\0\0\0)
+NewsDockWidgetFloating=false
+NewsDockWidgetVisible=true
+TerminalDockWidget=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\0\0\x2\"\0\0\x1!\0\0\x4\xb3\0\0\x3\x43\0\0\x2\"\0\0\x1!\0\0\x4\xb3\0\0\x3\x43\0\0\0\0\0\0)
 
 [workspaceview]
 local_collapsed=false
 global_collapsed=false
 persistent_collapsed=false
-column_state=@ByteArray(\0\0\0\xff\0\0\0\0\0\0\0\x1\0\0\0\x1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1\xf4\0\0\0\x5\x1\0\0\x1\0\0\0\0\0\0\0\0\0\0\0\0\x64\xff\xff\xff\xff\0\0\0\x81\0\0\0\0\0\0\0\x1\0\0\x1\xf4\0\0\0\x5\0\0\0\0)
+column_state=@ByteArray(\0\0\0\xff\0\0\0\0\0\0\0\x1\0\0\0\x1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x2\x12\0\0\0\x5\x1\0\0\x1\0\0\0\0\0\0\0\0\0\0\0\0\x64\xff\xff\xff\xff\0\0\0\x81\0\0\0\0\0\0\0\x2\0\0\x1\x90\0\0\0\x4\0\0\0\0\0\0\0\x82\0\0\0\x1\0\0\0\0)
 
 [filesdockwidget]
 sort_files_by_column=0
 sort_files_by_order=0
-column_state=@ByteArray(\0\0\0\xff\0\0\0\0\0\0\0\x1\0\0\0\0\0\0\0\0\x1\0\0\0\0\0\0\0\0\0\0\0\x4\xe\0\0\0\x3\0\0\0\x3\0\0\0\x64\0\0\0\x2\0\0\0\x64\0\0\0\x1\0\0\0\x64\0\0\x1\x63\0\0\0\x4\x1\x1\0\x1\0\0\0\0\0\0\0\0\0\0\0\0\x64\xff\xff\xff\xff\0\0\0\x81\0\0\0\0\0\0\0\x2\0\0\x1\x63\0\0\0\x1\0\0\0\0\0\0\0\0\0\0\0\x3\0\0\0\0)
+column_state=@ByteArray(\0\0\0\xff\0\0\0\0\0\0\0\x1\0\0\0\0\0\0\0\0\x1\0\0\0\0\0\0\0\0\0\0\0\x4\xe\0\0\0\x3\0\0\0\x3\0\0\0\x64\0\0\0\x2\0\0\0\x64\0\0\0\x1\0\0\0\x64\0\0\x2\v\0\0\0\x4\x1\x1\0\x1\0\0\0\0\0\0\0\0\0\0\0\0\x64\xff\xff\xff\xff\0\0\0\x81\0\0\0\0\0\0\0\x2\0\0\x2\v\0\0\0\x1\0\0\0\0\0\0\0\0\0\0\0\x3\0\0\0\0)
 showFilenames=true
 showFileSize=false
 showFileType=false
 showLastModified=false
 showHiddenFiles=false
 sync_octave_directory=true
 useAlternatingRowColors=true
diff --git a/libgui/src/icons/graphic_logo_NewsDockWidget.png b/libgui/src/icons/graphic_logo_NewsDockWidget.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..473158d6a9fdd880b4d3129aa8e2919b31ac79fe
GIT binary patch
literal 1589
zc$@(>2Fm$~P)<h;3K|Lk000e1NJLTq001BW001Be1^@s6b9#F800001b5ch_0Itp)
z=>Px#24YJ`L;zp_U;toc6lO{Q000SaNLh0L01FcU01FcV0GgZ_00007bV*G`2i*z@
z5(xtWrEix200p&4L_t(o!^M|vjFr_9$N&GC^Xz@wr7S4Bx&$l|0ti8aidv*gO|>dC
zbfcuL@r8a-Bk?`#7hn6Oxd>`oQz+UXmY`^j1!I~T0?}d%tc$w4TJQw{5qE`^W!Yu#
z+jFKL?!B<+Uc47+oaD)!JojYgH}lMybB6d9X?*Sdz^OE-@J1nKsPF<I6DsT%vPXpf
z5pshH-xNXT>Pvp;QGsx%m&s((nwy(B^VN>?lx$YvjVgo)Ap}GSC80t{;kTf#A^DUF
z+E>jur|*;jE_kI~Bec0HTqWc%At3@&5$2r(BJ5VOTZK6lQ4v%t*-(I7E9BBuGtOx_
zC4lKKzjvDwPl_-iLeo3|^U=zCD)^_8?}+e26{eiBij+DbrYJdGgjWlhRzY(6MPrw@
zkppD|Ok2Bswy3NY;_Q6nG$kp*tO}N?$g+)BPu@|=;4e3SS|wr^3)uu0+}^Nn+Y8tK
zrRmQA0Kwsa_;}hnWQPQp{QUMh6+9!v9HBr2CM5IG@L>(`<iD<&nl7ul%ryDTW4F!v
z@0zE^r9R(9n59w~_V@QcJZWvXdPsnYYg&InV6_P2DzGAik}tP3O`D%gCJm=SCcoJ1
z=C&dP09SlDe$}>E=zXJ*ad-d*niv2cacT>S>lQ6q^qrh9Uc4BA9uHiKN)8wudYc)V
z!RH_I-Xk>o>$axz`*9lOqgmH#Q9qV}M7n20DySYqPZ$Xk(1eI&jy^q<kp&ADROEE!
z%9Y3TO}}|%0+v*@1AuG44#OkFkK5ZH`pFxk8qXl}X(0)axc!5rm!_{njW=xhM+t+K
zN=@(n>u=e*XXmps#%7!d9~?Gv<h?(Y-I&|8+y)h=0YKk~5zCGa3>-Odpyy@)@ZLj2
zhRi^@P#(B~X6pd7x*!PdsH?9B%<OBsf&fqpAdybj96Ho<0|1D~NsX8KG=t&1**iks
zaMPCE?>gsP1b~_MBw5n1a~iAkTbIm$*$M#bNj_36!jn2Lww7`L%E`d<myK)t)myv1
zB5a<+X_j*9AoR9bh4Tg9lbG3-(A&jsP<r|Qh_rMa;4{L0;PS=)EoU}~;<}S<!%Bcd
zvz!3ta=F~TTqZNx1;L<X*zv5G!KeCin(?0w-iF^b1G&(mPDq!{X7Bl;v-6R_xw8OR
zN`h#L(FB-pMmY#O^xV|z6X$nKJcU+V3e=lT2n}>oUc%p6f8N^;pvHMvN+EZjzhv2f
ztDa68K}BzLWTGq4Fz^1uZ=J>(uuJKo4gjXF$IcV}oqgF-MQ(+V)k2sG7=+oY{v8>8
zN{7)mV9nwK8~4tPASWd&U!T~xULbP{w_qxXfQH}A8joA2o?Y3N%Vp8mwgG)@8}N2Z
zE9kq|?LBkaRUeJHJX#V!mTrmw)*<A06<XmcPE{f~a~y7-RF9}DuZ^VkwBgG~e}pqf
zjRFiH3<5(}XQ!34;P0EAHshSo+o8}v?+u~%2)&_s^DaEPbvM4~PnXkh5FXr%cs!0+
zJdRi_ifAl`s(1p`!)tlc5bXZhJB{{h?`?l*MsGm=F)VM}k9n_l;P0Ot#Gc+1O7#<x
z2w6DYzqZEA%IkizWMd<Re^PRi$e>B6Fd<!7SA#3Z)M7$y4E2dB#GS$k(3=U-bu@$C
z?XTh54R>K!UBht*5?^(9m*0N%@l6+vx5L|Z>u?N)$PX=fJ>~?Xt0SncQUogK%X%D0
zWia(X3!ZCR2sidT!24qW2fMl|>;DfVAGdg86Bf68hKx6;0!l$~Tsxi_IRUUP-HG3}
z+=q$TeaK0WcWQ>C0|PrM0!Sv476RyE0$W`@+N(yvu{g9AAhh7TIK+y;(NLT1!G(u*
zU_#&L_*qBt+$@FJtnaV%J|GHI|9;WJBhf#+p=zizVxbx47%{~Iq#0<18=V0(8wkng
nx+7;S`QyEJetg2s5WxQc3^hu3hoJgH00000NkvXXu0mjf!_V#k

diff --git a/libgui/src/icons/graphic_logo_ReleaseWidget.png b/libgui/src/icons/graphic_logo_ReleaseWidget.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..c392857905d2edc3f46a43c46c2cbcd9b4e69cee
GIT binary patch
literal 1594
zc$@(`2F3Y_P)<h;3K|Lk000e1NJLTq001BW001Be1^@s6b9#F800001b5ch_0Itp)
z=>Px#24YJ`L;zp_U;toc6lO{Q000SaNLh0L01FcU01FcV0GgZ_00007bV*G`2i*z@
z5)Uh3N?_{%00p{9L_t(o!^Ky9Y}Mrzex7sQUvJynGRsF>DFKJ10)jvgnTo7x6hC0m
zMu^5Zt^P5IL^o$>Ox$$)$6Rdv*vwG;=wJjzM+g{Vwjczj6REAU?Kb>~qM~cZ3Z=BY
zxA)^c`{UjVMSHOqns}05?#b`toacS+bI$u7;ybKn$3Fw7Ql-M%gjlG;c|wL&*e_&{
z2;UKMrwZQ`LFdLF{m>&1<8U`4k%-mT*K^Tp9p@`qufp3@2oXXEh!9Fbg^<i|#@|Hp
zX%)1uUwBU6X#<$IwOvEBWhz`R<QO3#0#gyDlLI2`R<c`#Nfl8Mlqgx10l8Vo#`O!&
zX+A9g^S69(w-Qf^FeF0LGytYoD<7!fFG{{I!jDuKbIJlzDukG&<a`lcE99UGBCQLi
zJkv%-M+{)j=GMzaWup)i(<`SbNf9PguvSIZ?z(p7{#*fXe(SRW5xYppTDV|k)xmu)
zFMpx-Spb0GXh3{2XB!g30+{(yYlRA)7h<VUAOaJT>DBOI4e;dOuA4nLB6XQ*<oU<$
zUi|M(Pfv|~^(kQ%i^bXB-~aH8&8dyU0+_z3<wgP<MOdr?%YsmHOLOg<6_H59FbX#F
zm3p_V1t|b<*_+eW?<-1qUn68OJOBet3;>TgwYuzkt5>f+qvUJWtU;hB7A{#Q2~0|P
zTa+?`PhaM}N6PF^`)cR*V-)S<#n)@rKh8jSuxD&6D49%87zq>5gb2k4o*OPmU0q#X
zNt>FQj{Cds+**x>f_4CK?Kk195b@*o_FrGIr@Ur7nWlv#Kw{;;8ZREa38mh!_w^hB
z^R?36ub1EP?&lx=ap9D>6XCDMj2n0VRdN8!x}LEi;xqv08#{LGKs0*n(4n5&0l<3?
z5kXyD-Ek17Vq-X<9=MWb+W@q<APDZMsH_Cc>>E`<04M_x9vmz^a-`>001%OH1<scZ
zZ}z^BxBhhRfqyvXTnK=f_avF~Bj>c}n;IAi1H%FIX6pcKC;3QLgr`iNZ7sQi=F7lK
zmrQND<?T-o6Ly2(d$N?bw+vX}PB*}rlwrD4+uoGN&29+2Jd=R=nm2q&*biJ<{NJ%>
zlgPf8ZyDwSn=(rZU@n<V9!$pLlUxuCA;V6vVg?`UOKRMIHd<u}0LhdUIw4&mk@&@b
zIy)Z;oI4wU#Uv<<u`mp#n^6+N4m~&a*Xb)drjMcsy;*h2KsW1E{JG^Pz3l)>orlE~
z^7FY3Yoo4YK4}CMy@lh#UE!)59yt2;sEN><T}%&k05E?$K0N8^<(D)nlIw&l5yDi!
zAeC71_t2!#5usUebk`S)LP$zZ<?9o>whLrw<`hgN5zz4H;%WHV?1_1a@WtoWp|5Qx
z`r3Blz2+9scW?V*!ki@^Prj@$Cje>O9RjRF$Z0CH%u$@GL}bxa+&-fcg>GbhEcSUD
z{`;FtF`>L1Fn}-!3|*a_cFNjk!|w9{dq-8ulrSNvDo`O-UN8~&&aJ}P;ZRNnnwpwm
zW*BJQfoRiR7++ovc%Q9p965Y=1kI=MjcWw*f(Rxmi8KH}NmQ2=;lTw{FmFN$CYOeg
zYd`62-GTUvbr?UP9LV+^5{J9HN7ntMVOI@>e^7FU$dE}WGa+4AQHrZ4m!Z0>2$kUi
z6g!0zpf{dE*FYS-tvhi2&igQ?qU!Vj0DwNed%-k2y6=FVg`ptQLrdB(a)L=EA(Rv-
z0u}TnJPyU;n0=@j8`@UEO*#Lhzu<peUHSF@ha!(#aZN4OG=GV>H>d(iL3Ug_!Hk>)
zuwt+izis{{rY8;}DM31^83v-!{dob1L?V^~(8Vy`b(Lr@D2HQqXw87gh*YyftOy(p
zWr-eKcw|4S`@X_89g%Yr6ebeBKi}<G6exLW^{QiqzuTi~s4!xc8I~F`%LAktXqgk8
s0W^!I$PL}0@eRMf|K3kdIvE1^Km6b{j?m5DE&u=k07*qoM6N<$f~!&2*Z=?k

diff --git a/libgui/src/icons/letter_logo_NewsDockWidget.png b/libgui/src/icons/letter_logo_NewsDockWidget.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..ed5395e8356498e61d55bd875bef3529aae29e20
GIT binary patch
literal 1882
zc$@)R2c`IlP)<h;3K|Lk000e1NJLTq001BW001Be1^@s6b9#F800001b5ch_0Itp)
z=>Px#24YJ`L;(K){{a7>y{D4^000SaNLh0L01FcU01FcV0GgZ_00007bV*G`2i*z@
z5iv2}t30&;00!DgL_t(o!=0CVY}CgQ$3HXsJNxcz41QsQdE<r#5QLy$pp*uxKGc|~
zN=u}sBILhTY8ugpTB%iORrR5&(54TmY1B$_go;qorZlZ+P!a?vZJ<C4CIJE=JZx-(
zU)X2g`R;x@{lh-nXB#k#wEE5NZ#Da!@668b3U`o)|M5;Fa9ZP3wy03&R92`+kyGhY
zk#1G_w~D;(R1T@qx@+}(&s~Vz?&rE!PcLyI-*zfnoC>Of3aAQB1gC-yeTVcviO6rA
z(%4WpFLBQRR=m>a3dJ@#l?D|lQ4v(ZsSYg;QzFXLK#4d(L`h>LLUJJYsL0NSx_SS(
zCjcw|eDcdqcve*kRmGf$sDg?xzbL{3Qwx|M52!A56sQnl^kktW9nv)5IhPC>Fllqj
z&rUov_qkId$w>oPzURaSb-GK1nS-7W(j9TaXR2d-YI>ZSSa4gf-cM#}OoY7E4^>x>
zzOea^kNqA1<z_^<uzW9>2>~qLeWJ=Ke^8-bMag+xpu(29Q~2Dh;=9Q&-o1E+f<4c$
zAk}<PFiWM<(%0Ab{rmTXyK-~#T=8aWEo7sr;M8MYL5)>q(Ysz8U_sXfVgt>TmX|L8
zNF)+uGU+9+t_<C#<AiwtY8#HmLhm0|kvJYOFg4;%`Of`i+>4mcfI8GU%nVgUKq790
zdCe(Vm=$_k7n<R7&3iUh#kgk?1+(Gi%}5m#Mb58(#ElC<(Li@uDpEX0ykH`jf~l~n
zIy#~41Al*suJ-H0{o2LLS+;6j-ki?jIsEm;bX+^sSEoq%7_ZfR=_7~Ned|7U6f^<^
zjh|;)q42TB#_byqPJg&UWRMmS0TF77Do9s-h=SVHBh;Gl#@^kelKsPD7tc11190Ku
z2ORG%0O0Z8yh$85dc}@R>AAM~sUw%qy-+td9jMCpO3KT>{t3OrrncuSM_x|pYmLz#
zD#=HGOzgo&0O)9I$y*$twdoQ!TAHYwF>83N>C%O9%x#}x&-~;H{}Qvkz;TU4B44Sh
zu4YPUxkV~!WT;Uv)Jn_Bs4R(*I`;A?!{;Xq%gG~$^ZLyb0H}y4YfFN)248&g?MqIB
zASeXPyqD1llh*(Z)3-GYaPsJ(VLd&N;zmo;g!9&v1bDN@JQU@2fr!W*GFm32wtCh)
z$||b>Xu0wM?XA}UxOVv>W;UUznnH*7*6Bn4S-qFt)qLswVSU#8T9&O^Kiofc^zbd?
zpLfzu4OSRDe%AoH+ON}}=o#^5?n0K=eRNb94iAAG$&+ZjXq=t-QAg-)RStkn-uryd
zYUb54d%=B_R#XlD@3`KY$3V^8h2!i@3lwiQRc{ri{P4?gGLEHo=8*BxHQ>ZsZ_w6!
zWh6}VYRB1B0dHoS&1Rdj>9jCZc#xqgAZCNrz!MH638u{+$3R8ZOro*);4xk|k_U(O
zy@C(JJeI~v+8f>@K_-*=T1#u|4<bP@1F)1vqA7_MA%h1-7UfLz!^9SEX7v~bMjM{9
za1o{D)9LECPO?8SE=*&kWgsLplVIsfynOu8o<?9w;IWiLw>_}qcgdi5rHFwzdZOhl
z>Yc%on_cvFciz(QvQ_IixbH7{V+DnUdDSr|=M!1HHx~e`{2S-;{%%;i(~*5%MT%9x
zDYRefVdst0`JRnQu4Q%W#{rlzdjYEBH`}SCBO`%Me7D-Rb~nF#^9z{PBVdSxA{>AB
zEQ>}>n>9b5fjJ8oF|E9k?v5MdSW2CKo%ESQs0K8r(roBXajs^~t*_;}^FSfkX%(q;
zDyAypL~u^nzM_gJYfC3xJF?C1kp5LYmD8t#fnX>`TWhP`vJm-iY#1<;`p{cfXo&Y_
zp&6k!e)!)ue)PXK+LD>c-HbY$iO1ta<8flKDA8Dqf_M?d(@N#GmC(Mq;hc#*;k{i8
z&BPn#4ZIl*=eyW?=qme~db!$ndmy0*V91!7V`jKJ!r%Ym1^MLG6NuCaR1RLH1reb;
z<JsSwps_1Odn%+e9g@g+dNLv1Y0uUE45zzOym#>&OE3SE!s3#=!!4OiB9o1y`^ABW
zRQRcid|Y+pIp%V22Nj}$Ff$gRDB_4Xp)Z7vbcSU&j?r-HX(Dr%fcL`y+S}SD!9b3#
z*BY+5Pd~LEk#0fOfJ6oh=U@dDz#H^tJ)LP!N7|Ffddvi`j@s5^L_06j-P=cRPY=B}
zZ_=AcoRzyh4TEP727%ae5&5dBYz-v$Xce4_ITdk3??-iNPDBDRN;BQePF(u=ci-Oj
zd_2?dGoq5o_&(ttCHm`w&WThxm8VstUR9Q=AfsN&xiBT2%8R0I$9qpaIPQ}0f0ZWB
Uel&RuiU0rr07*qoM6N<$f>+m?e*gdg

diff --git a/libgui/src/icons/letter_logo_ReleaseWidget.png b/libgui/src/icons/letter_logo_ReleaseWidget.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..3f2dd3d761dc727783bd40d84a005ae80ae665a3
GIT binary patch
literal 1937
zc$@)|2X6R@P)<h;3K|Lk000e1NJLTq001BW001Be1^@s6b9#F800001b5ch_0Itp)
z=>Px#24YJ`L;(K){{a7>y{D4^000SaNLh0L01FcU01FcV0GgZ_00007bV*G`2i*z@
z5i%IIH1`?+00$9CL_t(o!=0CVj8(-Q$3MT{oOAa+c<;(C4@F=V6cmBV;+81T`iOv4
zT576A?O!(0T3egi)YLYOwP`A?nkKdO5!V<E(WaqltwbSURYX9$7lq|jUJJX5`@FmN
z?!EWSuYW9i;llEqWOC-5IrE#(?>jTUnGw#A=D+?)7&sm0RF<ny=Tv5@NXn`7s7QyZ
zyssi}IhFOQw7f8PqURivoUU@-t6Qfzk%yhia;Ji-paQCb6TzvVN1sQ_FN(+?oRV&+
zyEt>+05kuQb`@evoJxa=3{w$Q!KohY9EOI<@IVQjAfn_kG7$riD^+AgL*2z6o)^IE
zzyJ5UPIyvPDpbXsh^T^!FfkQ!)$kY-lL0jqj+hD&MpqFI=OYgGd782jeI~6=`OTKA
zCp^<Al09pH87sFeP^T}bFt*?Gez`*@++363#?eW}C4$p>wL4oRor!q27pf0zd~Vra
zm;MO=r85+E%~(ZYP=L!{+EVS5zo@WSMH%oqro!?GL;3pnA?Gr`_;k-UVk;kDQm%QA
zV3y0}rKhLo=a;RFUKseN%oT4|ZxIVs1*abK3Tn(56+h?B0VcKYBGK2($jZt|0GUjN
zLLoox)!C6-vYDt1ptfOSBJzH|iX`!XfvJ&n%1<vF#rY)j1yF}Nhnb<O2uSFTDX#;C
zB8-o`&5O+N1KE2PRwp>`BnoDw?9Ir<QsK^P7rB#$Al26~Di;p9NW5Son1ZRWq$WP7
z?X|DHO#6|~%KH-tV-<|39L=TEXHt1-J#BA{pr^A47&)Kd&ANNP{LZ`|U&<4)G(eF4
z1|uqj>(c2*7p@yUze=QE77+mv#-*yrS6@P`cJ480&3Jp&OXRY>rxoCug^RfDk@cwd
z3!MZu?zazyb{$%F&j<UOo~xUX4^-u6!zwF(c)jjrN$WE<;LJdwrzJseq-1aT6^U7k
z0QjQy@EJP?cz@07TsV0ObFRCg^zG3x_Q2!&c~8t%0h@y`4DYM1sp)rXkhl;7Qhj~w
z+w@8a;Nae!W&hl;^xMp;Ur4?$$9r$T#)dWjD%I^sZ!QC<3YGd{LH&DO#XIlXu=isP
zf}jF0^IndhFl8CgC|@$tymwa_z$MdXQdKjSu@fe7{jGPD)rGOx$wM<Nz?&`gkP1rk
zN8}7M`dIzJ;{Zg2u@_A)y|*6PU)F5wgvlqF8du@)-r5AaH8`Ku)x39isXVf3G})eR
zx;xuAy#If^`r@BUb;CzhQ8)jl!FSr>!OZ`37QcDU0PROUqc_u4dT;x@mB+rn`~<Ot
zNmH-j_In>9Rx$W8o)~wmYcI?h0I)Ni4Nf)wgQY1~%;wJfenKL3>hL`xP`uf2HM27Z
zG?CI|Ja_`Y+=VxD{cU$rJMF5{x9yFac;#<TpVp=dcry!%#p1zYK0iJP!{fxTW2%@D
z^<@caE*w;Wn{WRP$<$EHjAtHynBChN0chO#4xMdB7(S|MP=LHQyhnmUq40ylEiJzY
zgJ29`ISu1EiKmeMAt|D4i%%tS`7-97puotgYLcm;C6(&Gx}*ePW~4uSmw7jSZBT&2
zeG!qF1k+#UmCd(wrGcS=$8rvR@Tw>Nm<@)^7BLV<SG<xb-D8;6*-m#yTgk}yi)+h_
zPMz^3To4i!`_CJne6-<|06Q~9yf+sB%>E}$Wwi_HS2&8#s>l!(a0*8bb+O{}t>x?a
z1b~Wog2|U%$&U190QPK4lgsuJPb5zQXv{ha66oN|@WJ|*`2Cu1VY(OrLnIPm^QYUH
zay-Dq+LM}2n^ji=h@v7*jhmQJcP+WCZ;{`&9@T*6T%H9TIhw{@bLyq1E7n$kZB>z4
zr(&uiP6X$KM`u=ZSMA8NjvdA3Psl&Dm<vXa1_QxRjMkPG(^EC_4=w03lf{v@_Q(+L
z%_1`*Z~XG3Rv!DfmDX(G>`q2)%_Nga;>je5M4WgcK`fbK$cT}mr)~J71x+S)hxc|U
zG81o@H}GaO>}==m^#^$4U^fSPP7e}^0EV0pbIc5PM*P*!?~)tt-hxP-zy<wBX+cEj
zD0o&kXGpi_IFgHK%SU7io~}YfN8WRwx4_np96R<jF@4{^sTeY>Y;((Ivu7860o?D_
zUai8fRpcwG$F5^;;O?M8JP^hvLQ<h4bV5%AU*rp1`S~Uq8t*5ZFb%vf0UT*<JqrZ}
z<a)E=kh|%g)rfQmat%l*(ys>6AGN$echS?9_k5A}WQra$!K<UTWfSqXeROp9(B0KV
zcV{Qvnap-M*WEC9a$OLJ%@C3Asmk4f3|v|Tr(#Y;+|m1^IyEOEffyqT9bA~%``br0
zJos#~(CZ7LQYiQy;XG6P>2=PDR6CXXRb;WMOjkjUyD1M0Q`V_GFY2DyamTEaw$lFt
Xi(S~%ECMWe00000NkvXXu0mjf_A9Qm

diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -404,16 +404,34 @@ file_editor_tab::paste (const QWidget *I
 {
   if (ID != this)
     return;
 
   _edit_area->paste ();
 }
 
 void
+file_editor_tab::context_help (const QWidget *ID, bool doc)
+{
+  if (ID != this)
+    return;
+
+  _edit_area->context_help_doc (doc);
+}
+
+void
+file_editor_tab::context_edit (const QWidget *ID)
+{
+  if (ID != this)
+    return;
+
+  _edit_area->context_edit ();
+}
+
+void
 file_editor_tab::save_file (const QWidget *ID)
 {
   if (ID != this)
     return;
 
   save_file (_file_name);
 }
 void
@@ -461,16 +479,25 @@ file_editor_tab::run_file (const QWidget
   if (_edit_area->isModified ())
     save_file (_file_name);
 
   QFileInfo info (_file_name);
   emit run_file_signal (info);
 }
 
 void
+file_editor_tab::context_run (const QWidget *ID)
+{
+  if (ID != this)
+    return;
+
+  _edit_area->context_run ();
+}
+
+void
 file_editor_tab::toggle_bookmark (const QWidget *ID)
 {
   if (ID != this)
     return;
 
   int line, cur;
   _edit_area->getCursorPosition (&line, &cur);
 
@@ -908,16 +935,17 @@ file_editor_tab::load_file (const QStrin
   if (!file.open (QFile::ReadOnly))
     return file.errorString ();
 
   QTextStream in (&file);
   QApplication::setOverrideCursor (Qt::WaitCursor);
   _edit_area->setText (in.readAll ());
   QApplication::restoreOverrideCursor ();
 
+  _copy_available = false;     // no selection yet available
   set_file_name (fileName);
   update_window_title (false); // window title (no modification)
   _edit_area->setModified (false); // loaded file is not modified yet
 
   return QString ();
 }
 
 void
diff --git a/libgui/src/m-editor/file-editor-tab.h b/libgui/src/m-editor/file-editor-tab.h
--- a/libgui/src/m-editor/file-editor-tab.h
+++ b/libgui/src/m-editor/file-editor-tab.h
@@ -65,22 +65,25 @@ public slots:
   void file_name_query (const QWidget *ID);
 
   void set_focus (const QWidget *ID);
   void undo (const QWidget *ID);
   void redo (const QWidget *ID);
   void copy (const QWidget *ID);
   void cut (const QWidget *ID);
   void paste (const QWidget *ID);
+  void context_help (const QWidget *ID, bool);
+  void context_edit (const QWidget *ID);
   void save_file (const QWidget *ID);
   void save_file (const QWidget *ID, const QString& fileName,
                   bool remove_on_success);
   void save_file_as (const QWidget *ID);
   void print_file (const QWidget *ID);
   void run_file (const QWidget *ID);
+  void context_run (const QWidget *ID);
   void toggle_bookmark (const QWidget *ID);
   void next_bookmark (const QWidget *ID);
   void previous_bookmark (const QWidget *ID);
   void remove_bookmark (const QWidget *ID);
 
   void toggle_breakpoint (const QWidget *ID);
   void next_breakpoint (const QWidget *ID);
   void previous_breakpoint (const QWidget *ID);
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -462,16 +462,33 @@ file_editor::request_cut (void)
 
 void
 file_editor::request_paste (void)
 {
   emit fetab_paste (_tab_widget->currentWidget ());
 }
 
 void
+file_editor::request_context_help (bool)
+{
+  emit fetab_context_help (_tab_widget->currentWidget (), false);
+}
+void
+file_editor::request_context_doc (bool)
+{
+  emit fetab_context_help (_tab_widget->currentWidget (), true);
+}
+
+void
+file_editor::request_context_edit (bool)
+{
+  emit fetab_context_edit (_tab_widget->currentWidget ());
+}
+
+void
 file_editor::request_save_file (void)
 {
   emit fetab_save_file (_tab_widget->currentWidget ());
 }
 
 void
 file_editor::request_save_file_as (void)
 {
@@ -487,16 +504,22 @@ file_editor::request_print_file (void)
 
 void
 file_editor::request_run_file (void)
 {
   emit fetab_run_file (_tab_widget->currentWidget ());
 }
 
 void
+file_editor::request_context_run (bool)
+{
+  emit fetab_context_run (_tab_widget->currentWidget ());
+}
+
+void
 file_editor::request_toggle_bookmark (void)
 {
   emit fetab_toggle_bookmark (_tab_widget->currentWidget ());
 }
 
 void
 file_editor::request_next_bookmark (void)
 {
@@ -696,16 +719,17 @@ file_editor::handle_editor_state_changed
                                           const QString& file_name)
 {
   // In case there is some scenario where traffic could be coming from
   // all the file editor tabs, just process info from the current active tab.
   if (sender () == _tab_widget->currentWidget ())
     {
       _copy_action->setEnabled (copy_available);
       _cut_action->setEnabled (copy_available);
+      _context_run_action->setEnabled (copy_available);
 
       if (!file_name.isEmpty ())
         {
           ced = QDir::cleanPath (file_name);
           int lastslash = ced.lastIndexOf ('/');
 
           // Test against > 0 because if somehow the directory is "/" the
           // slash should be retained.  Otherwise, last slash is removed.
@@ -757,19 +781,21 @@ file_editor::construct (void)
   _undo_action = new QAction (QIcon (":/actions/icons/undo.png"),
                                       tr ("&Undo"), _tool_bar);
 
   _redo_action = new QAction (QIcon (":/actions/icons/redo.png"),
                                       tr ("&Redo"), _tool_bar);
 
   _copy_action = new QAction (QIcon (":/actions/icons/editcopy.png"),
                               tr ("&Copy"), _tool_bar);
+  _copy_action->setEnabled (false);
 
   _cut_action = new QAction (QIcon (":/actions/icons/editcut.png"),
                               tr ("Cu&t"), _tool_bar);
+  _cut_action->setEnabled (false);
 
   _paste_action
     = new QAction (QIcon (":/actions/icons/editpaste.png"),
                    tr ("Paste"), _tool_bar);
 
   _next_bookmark_action = new QAction (tr ("&Next Bookmark"), _tool_bar);
 
   _previous_bookmark_action = new QAction (tr ("Pre&vious Bookmark"), _tool_bar);
@@ -789,17 +815,16 @@ file_editor::construct (void)
     = new QAction (QIcon (":/actions/icons/bp_toggle.png"),
                    tr ("Toggle &breakpoint"), _tool_bar);
   QAction *remove_all_breakpoints_action
     = new QAction (QIcon (":/actions/icons/bp_rm_all.png"),
                    tr ("&Remove All breakpoints"), _tool_bar);
 
   _comment_selection_action
     = new QAction (tr ("&Comment"), _tool_bar);
-
   _uncomment_selection_action
     = new QAction (tr ("&Uncomment"), _tool_bar);
 
   _find_action = new QAction (QIcon (":/actions/icons/search.png"),
                                       tr ("&Find and Replace"), _tool_bar);
 
   _run_action = new QAction (QIcon (":/actions/icons/artsbuilderexecute.png"),
                              tr ("Save File And Run"), _tool_bar);
@@ -861,17 +886,20 @@ file_editor::construct (void)
 
   _mru_file_menu = new QMenu (tr ("&Recent Editor Files"), fileMenu);
   for (int i = 0; i < MaxMRUFiles; ++i)
     _mru_file_menu->addAction (_mru_file_actions[i]);
 
   fileMenu->addAction (new_action);
   fileMenu->addAction (open_action);
   fileMenu->addMenu (_mru_file_menu);
-
+  fileMenu->addSeparator ();
+  _context_edit_action =
+    fileMenu->addAction (QIcon (), tr ("&Edit Function"),
+                         this, SLOT (request_context_edit (bool)));
   fileMenu->addSeparator ();
   fileMenu->addAction (_save_action);
   fileMenu->addAction (_save_as_action);
 
   fileMenu->addSeparator ();
   _close_action =
       fileMenu->addAction (QIcon::fromTheme("window-close",
                                   QIcon (":/actions/icons/fileclose.png")),
@@ -920,18 +948,31 @@ file_editor::construct (void)
   _debug_menu->addAction (previous_breakpoint_action);
   _debug_menu->addAction (remove_all_breakpoints_action);
   _debug_menu->addSeparator ();
   // The other debug actions will be added by the main window.
   _menu_bar->addMenu (_debug_menu);
 
   QMenu *_run_menu = new QMenu (tr ("&Run"), _menu_bar);
   _run_menu->addAction (_run_action);
+  _context_run_action =
+    _run_menu->addAction (QIcon (), tr ("Run &Selection"),
+                           this, SLOT (request_context_run (bool)));
+  _context_run_action->setEnabled (false);
   _menu_bar->addMenu (_run_menu);
 
+  QMenu *_help_menu = new QMenu (tr ("&Help"), _menu_bar);
+  _context_help_action =
+    _help_menu->addAction (QIcon (), tr ("&Help on Keyword"),
+                           this, SLOT (request_context_help (bool)));
+  _context_doc_action =
+    _help_menu->addAction (QIcon (), tr ("&Documentation on Keyword"),
+                           this, SLOT (request_context_doc (bool)));
+  _menu_bar->addMenu (_help_menu);
+
   // shortcuts
   set_shortcuts (true);
 
   // layout
   QVBoxLayout *vbox_layout = new QVBoxLayout ();
   vbox_layout->addWidget (_menu_bar);
   vbox_layout->addWidget (_tool_bar);
   vbox_layout->addWidget (_tab_widget);
@@ -1102,28 +1143,37 @@ file_editor::add_file_editor_tab (file_e
            f, SLOT (copy (const QWidget*)));
 
   connect (this, SIGNAL (fetab_cut (const QWidget*)),
            f, SLOT (cut (const QWidget*)));
 
   connect (this, SIGNAL (fetab_paste (const QWidget*)),
            f, SLOT (paste (const QWidget*)));
 
+  connect (this, SIGNAL (fetab_context_help (const QWidget*, bool)),
+           f, SLOT (context_help (const QWidget*, bool)));
+
+  connect (this, SIGNAL (fetab_context_edit (const QWidget*)),
+           f, SLOT (context_edit (const QWidget*)));
+
   connect (this, SIGNAL (fetab_save_file (const QWidget*)),
            f, SLOT (save_file (const QWidget*)));
 
   connect (this, SIGNAL (fetab_save_file_as (const QWidget*)),
            f, SLOT (save_file_as (const QWidget*)));
 
   connect (this, SIGNAL (fetab_print_file (const QWidget*)),
            f, SLOT (print_file (const QWidget*)));
 
   connect (this, SIGNAL (fetab_run_file (const QWidget*)),
            f, SLOT (run_file (const QWidget*)));
 
+  connect (this, SIGNAL (fetab_context_run (const QWidget*)),
+           f, SLOT (context_run (const QWidget*)));
+
   connect (this, SIGNAL (fetab_toggle_bookmark (const QWidget*)),
            f, SLOT (toggle_bookmark (const QWidget*)));
 
   connect (this, SIGNAL (fetab_next_bookmark (const QWidget*)),
            f, SLOT (next_bookmark (const QWidget*)));
 
   connect (this, SIGNAL (fetab_previous_bookmark (const QWidget*)),
            f, SLOT (previous_bookmark (const QWidget*)));
@@ -1194,33 +1244,37 @@ file_editor::pasteClipboard ()
   }
 }
 
 void
 file_editor::set_shortcuts (bool set)
 {
   if (set)
     {
-      _comment_selection_action->setShortcut (Qt::ControlModifier + Qt::Key_7);
-      _uncomment_selection_action->setShortcut (Qt::ControlModifier + Qt::Key_8);
+      _comment_selection_action->setShortcut (Qt::ControlModifier + Qt::Key_R);
+      _uncomment_selection_action->setShortcut (Qt::SHIFT + Qt::ControlModifier + Qt::Key_R);
 
       _copy_action->setShortcut (QKeySequence::Copy);
       _cut_action->setShortcut (QKeySequence::Cut);
       _paste_action->setShortcut (QKeySequence::Paste);
+      _context_help_action->setShortcut (QKeySequence::HelpContents);
+      _context_doc_action->setShortcut (Qt::SHIFT + Qt::Key_F1);
 
       _find_action->setShortcut (QKeySequence::Find);
       _goto_line_action->setShortcut (Qt::ControlModifier+ Qt::Key_G);
 
       _next_bookmark_action->setShortcut (Qt::Key_F2);
       _previous_bookmark_action->setShortcut (Qt::SHIFT + Qt::Key_F2);
       _toggle_bookmark_action->setShortcut (Qt::Key_F7);
 
       _print_action->setShortcut (QKeySequence::Print);
-      _run_action->setShortcut (Qt::ControlModifier+ Qt::Key_R);
+      _run_action->setShortcut (Qt::Key_F5);
+      _context_run_action->setShortcut (Qt::Key_F9);
 
+      _context_edit_action->setShortcut (Qt::ControlModifier + Qt::Key_E);
       _save_action->setShortcut (QKeySequence::Save);
       _save_as_action->setShortcut (QKeySequence::SaveAs);
       _close_action->setShortcut (QKeySequence::Close);
 
       _redo_action->setShortcut (QKeySequence::Redo);
       _undo_action->setShortcut (QKeySequence::Undo);
     }
   else
@@ -1228,27 +1282,30 @@ file_editor::set_shortcuts (bool set)
       QKeySequence no_key = QKeySequence ();
 
       _comment_selection_action->setShortcut (no_key);
       _uncomment_selection_action->setShortcut (no_key);
 
       _copy_action->setShortcut (no_key);
       _cut_action->setShortcut (no_key);
       _paste_action->setShortcut (no_key);
+      _context_help_action->setShortcut (no_key);
 
       _find_action->setShortcut (no_key);
       _goto_line_action->setShortcut (no_key);
 
       _next_bookmark_action->setShortcut (no_key);
       _previous_bookmark_action->setShortcut (no_key);
       _toggle_bookmark_action->setShortcut (no_key);
 
       _print_action->setShortcut (no_key);
       _run_action->setShortcut (no_key);
+      _context_run_action->setShortcut (no_key);
 
+      _context_edit_action->setShortcut (no_key);
       _save_action->setShortcut (no_key);
       _save_as_action->setShortcut (no_key);
       _close_action->setShortcut (no_key);
 
       _redo_action->setShortcut (no_key);
       _undo_action->setShortcut (no_key);
     }
 }
@@ -1256,30 +1313,32 @@ file_editor::set_shortcuts (bool set)
 void
 file_editor::check_actions ()
 {
   bool  have_tabs = _tab_widget->count () > 0;
 
   _comment_selection_action->setEnabled (have_tabs);
   _uncomment_selection_action->setEnabled (have_tabs);
 
-  _copy_action->setEnabled (have_tabs);
-  _cut_action->setEnabled (have_tabs);
   _paste_action->setEnabled (have_tabs);
+  _context_help_action->setEnabled (have_tabs);
+  _context_doc_action->setEnabled (have_tabs);
 
   _find_action->setEnabled (have_tabs);
   _goto_line_action->setEnabled (have_tabs);
 
   _next_bookmark_action->setEnabled (have_tabs);
   _previous_bookmark_action->setEnabled (have_tabs);
   _toggle_bookmark_action->setEnabled (have_tabs);
+  _remove_bookmark_action->setEnabled (have_tabs);
 
   _print_action->setEnabled (have_tabs);
   _run_action->setEnabled (have_tabs);
 
+  _context_edit_action->setEnabled (have_tabs);
   _save_action->setEnabled (have_tabs);
   _save_as_action->setEnabled (have_tabs);
   _close_action->setEnabled (have_tabs);
   _close_all_action->setEnabled (have_tabs);
   _close_others_action->setEnabled (have_tabs && _tab_widget->count () > 1);
 
   _undo_action->setEnabled (have_tabs);
   _redo_action->setEnabled (have_tabs);
diff --git a/libgui/src/m-editor/file-editor.h b/libgui/src/m-editor/file-editor.h
--- a/libgui/src/m-editor/file-editor.h
+++ b/libgui/src/m-editor/file-editor.h
@@ -69,20 +69,23 @@ signals:
                         bool remove_on_success);
   // No fetab_open, functionality in editor
   // No fetab_new, functionality in editor
   void fetab_undo (const QWidget* ID);
   void fetab_redo (const QWidget* ID);
   void fetab_copy (const QWidget* ID);
   void fetab_cut (const QWidget* ID);
   void fetab_paste (const QWidget* ID);
+  void fetab_context_help (const QWidget* ID, bool);
+  void fetab_context_edit (const QWidget* ID);
   void fetab_save_file (const QWidget* ID);
   void fetab_save_file_as (const QWidget* ID);
   void fetab_print_file (const QWidget* ID);
   void fetab_run_file (const QWidget* ID);
+  void fetab_context_run (const QWidget* ID);
   void fetab_toggle_bookmark (const QWidget* ID);
   void fetab_next_bookmark (const QWidget* ID);
   void fetab_previous_bookmark (const QWidget* ID);
   void fetab_remove_bookmark (const QWidget* ID);
   void fetab_toggle_breakpoint (const QWidget* ID);
   void fetab_next_breakpoint (const QWidget* ID);
   void fetab_previous_breakpoint (const QWidget* ID);
   void fetab_remove_all_breakpoints (const QWidget* ID);
@@ -109,19 +112,23 @@ public slots:
   void request_mru_open_file (QAction *action);
   void request_print_file (void);
 
   void request_undo (void);
   void request_redo (void);
   void request_copy (void);
   void request_cut (void);
   void request_paste (void);
+  void request_context_help (bool);
+  void request_context_doc (bool);
+  void request_context_edit (bool);
   void request_save_file (void);
   void request_save_file_as (void);
   void request_run_file (void);
+  void request_context_run (bool);
   void request_toggle_bookmark (void);
   void request_next_bookmark (void);
   void request_previous_bookmark (void);
   void request_remove_bookmark (void);
 
   void request_toggle_breakpoint (void);
   void request_next_breakpoint (void);
   void request_previous_breakpoint (void);
@@ -185,28 +192,32 @@ private:
   QMenu *_debug_menu;
 
   QAction *_comment_selection_action;
   QAction *_uncomment_selection_action;
 
   QAction *_copy_action;
   QAction *_cut_action;
   QAction *_paste_action;
+  QAction *_context_help_action;
+  QAction *_context_doc_action;
 
   QAction *_find_action;
   QAction *_goto_line_action;
 
   QAction *_next_bookmark_action;
   QAction *_previous_bookmark_action;
   QAction *_toggle_bookmark_action;
   QAction * _remove_bookmark_action;
 
   QAction *_print_action;
   QAction *_run_action;
+  QAction *_context_run_action;
 
+  QAction *_context_edit_action;
   QAction *_save_action;
   QAction *_save_as_action;
   QAction *_close_action;
   QAction *_close_all_action;
   QAction *_close_others_action;
 
   QAction *_redo_action;
   QAction *_undo_action;
diff --git a/libgui/src/m-editor/octave-qscintilla.cc b/libgui/src/m-editor/octave-qscintilla.cc
--- a/libgui/src/m-editor/octave-qscintilla.cc
+++ b/libgui/src/m-editor/octave-qscintilla.cc
@@ -35,16 +35,63 @@ along with Octave; see the file COPYING.
 
 octave_qscintilla::octave_qscintilla (QWidget *p)
     : QsciScintilla (p)
 { }
 
 octave_qscintilla::~octave_qscintilla ()
 { }
 
+void
+octave_qscintilla::get_global_textcursor_pos (QPoint *global_pos, QPoint *local_pos)
+{
+  long position = SendScintilla (QsciScintillaBase::SCI_GETCURRENTPOS);
+  long point_x  = SendScintilla
+                    (QsciScintillaBase::SCI_POINTXFROMPOSITION,0,position);
+  long point_y  = SendScintilla
+                    (QsciScintillaBase::SCI_POINTYFROMPOSITION,0,position);
+  *local_pos = QPoint (point_x,point_y);  // local cursor position
+  *global_pos = mapToGlobal (*local_pos); // global position of cursor
+}
+
+// determine the actual word and whether we are in an octave or matlab script
+bool
+octave_qscintilla::get_actual_word ()
+{
+  QPoint global_pos, local_pos;
+  get_global_textcursor_pos (&global_pos, &local_pos);
+  _word_at_cursor = wordAtPoint (local_pos);
+  QString lexer_name = lexer ()->lexer ();
+  return ((lexer_name == "octave" || lexer_name == "matlab")
+          && !_word_at_cursor.isEmpty ());
+}
+
+// call documentation or help on the current word
+void
+octave_qscintilla::context_help_doc (bool documentation)
+{
+  if (get_actual_word ())
+    contextmenu_help_doc (documentation);
+}
+
+// call edit the function related to the current word
+void
+octave_qscintilla::context_edit ()
+{
+  if (hasSelectedText ())
+    contextmenu_edit (true);
+}
+
+// call edit the function related to the current word
+void
+octave_qscintilla::context_run ()
+{
+  if (hasSelectedText ())
+    contextmenu_run (true);
+}
 
 #ifdef HAVE_QSCI_VERSION_2_6_0
 // context menu requested
 void
 octave_qscintilla::contextMenuEvent (QContextMenuEvent *e)
 {
   QMenu *context_menu = createStandardContextMenu ( );  // standard menu
 
@@ -53,23 +100,17 @@ octave_qscintilla::contextMenuEvent (QCo
 
   if (e->reason () == QContextMenuEvent::Mouse)
     { // context menu by mouse
       global_pos = e->globalPos ();            // global mouse position
       local_pos  = e->pos ();                  // local mouse position
     }
   else
     { // context menu by keyboard or other: get point of text cursor
-      long position = SendScintilla (QsciScintillaBase::SCI_GETCURRENTPOS);
-      long point_x  = SendScintilla
-                        (QsciScintillaBase::SCI_POINTXFROMPOSITION,0,position);
-      long point_y  = SendScintilla
-                        (QsciScintillaBase::SCI_POINTYFROMPOSITION,0,position);
-      local_pos = QPoint (point_x,point_y);  // local cursor position
-      global_pos = mapToGlobal (local_pos); // global position of cursor
+      get_global_textcursor_pos (&global_pos, &local_pos);
       QRect editor_rect = geometry ();      // editor rect mapped to global
       editor_rect.moveTopLeft
               (parentWidget ()->mapToGlobal (editor_rect.topLeft ()));
       if (!editor_rect.contains (global_pos))  // is cursor outside editor?
         global_pos = editor_rect.topLeft ();   // yes, take top left corner
     }
 
   // additional custom entries of the context menu
@@ -77,27 +118,66 @@ octave_qscintilla::contextMenuEvent (QCo
 
   // help menu: get the position of the mouse or the text cursor
   // (only for octave files)
   QString lexer_name = lexer ()->lexer ();
   if (lexer_name == "octave" || lexer_name == "matlab")
     {
       _word_at_cursor = wordAtPoint (local_pos);
       if (!_word_at_cursor.isEmpty ())
-        context_menu->addAction (tr ("help") + " " + _word_at_cursor,
-                                this, SLOT (contextmenu_help (bool)));
+        {
+          context_menu->addAction (tr ("Help on") + " " + _word_at_cursor,
+                                  this, SLOT (contextmenu_help (bool)));
+          context_menu->addAction (tr ("Documentation on") + " " + _word_at_cursor,
+                                  this, SLOT (contextmenu_doc (bool)));
+          context_menu->addAction (tr ("Edit") + " " + _word_at_cursor,
+                                  this, SLOT (contextmenu_edit (bool)));
+        }
+      context_menu->addSeparator ();   // separator before custom entries
+      if (hasSelectedText ())
+        context_menu->addAction (tr ("&Run Selection"),
+                                 this, SLOT (contextmenu_run (bool)));
     }
 
   // finaly show the menu
   context_menu->exec (global_pos);
 }
 #endif
 
 
-// handle the menu entry for calling help
+// handle the menu entry for calling help or doc
+void
+octave_qscintilla::contextmenu_doc (bool)
+{
+  contextmenu_help_doc (true);
+}
 void
 octave_qscintilla::contextmenu_help (bool)
 {
-  QString command = "help " + _word_at_cursor;
+  contextmenu_help_doc (false);
+}
+
+// common function with flag for documentation
+void
+octave_qscintilla::contextmenu_help_doc (bool documentation)
+{
+  QString command;
+  if (documentation)
+    command = "doc ";
+  else
+    command = "help ";
+  emit execute_command_in_terminal_signal (command + _word_at_cursor);
+}
+
+void
+octave_qscintilla::contextmenu_edit (bool)
+{
+  emit execute_command_in_terminal_signal (QString("edit ") + _word_at_cursor);
+}
+
+void
+octave_qscintilla::contextmenu_run (bool)
+{
+  QString command = selectedText ();
   emit execute_command_in_terminal_signal (command);
 }
 
 #endif
diff --git a/libgui/src/m-editor/octave-qscintilla.h b/libgui/src/m-editor/octave-qscintilla.h
--- a/libgui/src/m-editor/octave-qscintilla.h
+++ b/libgui/src/m-editor/octave-qscintilla.h
@@ -36,24 +36,33 @@ class octave_qscintilla : public QsciSci
 public:
 
   octave_qscintilla (QWidget *p);
   ~octave_qscintilla ();
 
 #ifdef HAVE_QSCI_VERSION_2_6_0
   virtual void contextMenuEvent (QContextMenuEvent *e);
 #endif
+  void context_help_doc (bool);
+  void context_edit ();
+  void context_run ();
+  void get_global_textcursor_pos (QPoint *global_pos, QPoint *local_pos);
+  bool get_actual_word ();
 
 signals:
 
   void execute_command_in_terminal_signal (const QString&);
 
 private slots:
 
   void contextmenu_help (bool);
+  void contextmenu_doc (bool);
+  void contextmenu_help_doc (bool);
+  void contextmenu_edit (bool);
+  void contextmenu_run (bool);
 
 private:
 
   QString _word_at_cursor;
 
 };
 
 #endif
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -64,16 +64,17 @@ create_default_editor (QWidget *p)
   return 0;
 #endif
 }
 
 main_window::main_window (QWidget *p)
   : QMainWindow (p),
     _workspace_model (new workspace_model ()),
     status_bar (new QStatusBar ()),
+    news_window (new news_dock_widget (this)),
     command_window (new terminal_dock_widget (this)),
     history_window (new history_dock_widget (this)),
     file_browser_window (new files_dock_widget (this)),
     doc_browser_window (new documentation_dock_widget (this)),
     editor_window (create_default_editor (this)),
     workspace_window (new workspace_view (this)),
     find_files_dlg (0),
     _octave_main_thread (0),
@@ -88,16 +89,17 @@ main_window::main_window (QWidget *p)
 }
 
 main_window::~main_window (void)
 {
   // Destroy the terminal first so that STDERR stream is redirected back
   // to its original pipe to capture error messages at exit.
 
   delete editor_window;     // first one for dialogs of modified editor-tabs
+  delete news_window;
   delete command_window;
   delete workspace_window;
   delete doc_browser_window;
   delete file_browser_window;
   delete history_window;
   delete status_bar;
   delete _workspace_model;
   if (find_files_dlg) 
@@ -242,16 +244,41 @@ main_window::handle_new_figure_request (
 
 void
 main_window::open_online_documentation_page (void)
 {
   QDesktopServices::openUrl (QUrl ("http://octave.org/doc/interpreter"));
 }
 
 void
+main_window::display_release_notes (void)
+{
+  display_url_in_window (QUrl ("file://" OCTAVE_OCTETCDIR "/NEWS"));
+}
+
+void
+main_window::display_url_in_window (const QUrl& url)
+{
+  QWidget *w = new QWidget;
+
+  QTextBrowser *browser = new QTextBrowser (w);
+  browser->setSource (url);
+
+  QVBoxLayout *vlayout = new QVBoxLayout;
+  vlayout->addWidget (browser);
+
+  w->setLayout (vlayout);
+  w->setWindowTitle (tr ("Octave Release Notes"));
+  w->setWindowIcon (QIcon (_release_notes_icon));
+  w->show ();
+  w->raise ();
+  w->activateWindow ();
+}
+
+void
 main_window::open_bug_tracker_page (void)
 {
   QDesktopServices::openUrl (QUrl ("http://octave.org/bugs.html"));
 }
 
 void
 main_window::open_octave_packages_page (void)
 {
@@ -336,16 +363,21 @@ main_window::notice_settings (const QSet
       if (! name.isEmpty ())
         { // if children has a name
           icon = widget_icon_data[icon_set_found].path; // prefix or octave-logo
           if (widget_icon_data[icon_set_found].name != "NONE")
             icon = icon + name + ".png"; // add widget name and ext.
           widget->setWindowIcon (QIcon (icon));
         }
     }
+  if (widget_icon_data[icon_set_found].name != "NONE")
+     _release_notes_icon = widget_icon_data[icon_set_found].path
+                           + "ReleaseWidget.png";
+  else
+     _release_notes_icon = ":/actions/icons/logo.png";
 
   int icon_size = settings->value ("toolbar_icon_size",24).toInt ();
   _main_tool_bar->setIconSize (QSize (icon_size,icon_size));
 
   resource_manager::update_network_settings ();
 }
 
 
@@ -648,24 +680,18 @@ main_window::write_settings (void)
 }
 
 
 // Connecting the signals emitted when the visibility of a widget changes.
 // This has to be done after the window is shown (see octave-gui.cc)
 void
 main_window::connect_visibility_changed (void)
 {
-  command_window->connect_visibility_changed ();
-  history_window->connect_visibility_changed ();
-  file_browser_window->connect_visibility_changed ();
-  doc_browser_window->connect_visibility_changed ();
-#ifdef HAVE_QSCINTILLA
-  editor_window->connect_visibility_changed ();
-#endif
-  workspace_window->connect_visibility_changed ();
+  foreach (octave_dock_widget *widget, dock_widget_list ())
+    widget->connect_visibility_changed ();
 }
 
 void
 main_window::copyClipboard (void)
 {
   if (_current_directory_combo_box->hasFocus ())
     {
       QLineEdit * edit = _current_directory_combo_box->lineEdit ();
@@ -858,16 +884,17 @@ main_window::construct (void)
   connect_uiwidget_links ();
 
   setWindowTitle ("Octave");
 
   setDockOptions (QMainWindow::AnimatedDocks
                   | QMainWindow::AllowNestedDocks
                   | QMainWindow::AllowTabbedDocks);
 
+  addDockWidget (Qt::RightDockWidgetArea, news_window);
   addDockWidget (Qt::RightDockWidgetArea, command_window);
   addDockWidget (Qt::RightDockWidgetArea, doc_browser_window);
   tabifyDockWidget (command_window, doc_browser_window);
 
 #ifdef HAVE_QSCINTILLA
   addDockWidget (Qt::RightDockWidgetArea, editor_window);
   tabifyDockWidget (command_window, editor_window);
 #endif
@@ -1016,16 +1043,18 @@ main_window::construct_menu_bar (void)
 
   construct_edit_menu (menu_bar);
 
   construct_debug_menu (menu_bar);
 
   construct_window_menu (menu_bar);
 
   construct_help_menu (menu_bar);
+
+  construct_news_menu (menu_bar);
 }
 
 void
 main_window::construct_file_menu (QMenuBar *p)
 {
   QMenu *file_menu = p->addMenu (tr ("&File"));
 
   construct_new_menu (file_menu);
@@ -1261,16 +1290,19 @@ main_window::construct_window_menu (QMen
     (window_menu, tr ("Show Workspace"), true, ctrl_shift + Qt::Key_3);
 
   QAction *show_editor_action = construct_window_menu_item
     (window_menu, tr ("Show Editor"), true, ctrl_shift + Qt::Key_4);
 
   QAction *show_documentation_action = construct_window_menu_item
     (window_menu, tr ("Show Documentation"), true, ctrl_shift + Qt::Key_5);
 
+  QAction *show_news_action = construct_window_menu_item
+    (window_menu, tr ("Show News Window"), true, ctrl_shift + Qt::Key_6);
+
   window_menu->addSeparator ();
 
   QAction *command_window_action = construct_window_menu_item
     (window_menu, tr ("Command Window"), false, ctrl + Qt::Key_0);
 
   QAction *history_action = construct_window_menu_item
     (window_menu, tr ("Command History"), false, ctrl + Qt::Key_1);
 
@@ -1281,16 +1313,19 @@ main_window::construct_window_menu (QMen
     (window_menu, tr ("Workspace"), false, ctrl + Qt::Key_3);
 
   QAction *editor_action = construct_window_menu_item
     (window_menu, tr ("Editor"), false, ctrl + Qt::Key_4);
 
   QAction *documentation_action = construct_window_menu_item
     (window_menu, tr ("Documentation"), false, ctrl + Qt::Key_5);
 
+  QAction *news_action = construct_window_menu_item
+    (window_menu, tr ("News"), false, ctrl + Qt::Key_6);
+
   window_menu->addSeparator ();
 
   QAction *reset_windows_action
     = window_menu->addAction (tr ("Reset Default Window Layout"));
 
   connect (show_command_window_action, SIGNAL (toggled (bool)),
            command_window, SLOT (setVisible (bool)));
 
@@ -1318,16 +1353,22 @@ main_window::construct_window_menu (QMen
 #ifdef HAVE_QSCINTILLA
   connect (show_editor_action, SIGNAL (toggled (bool)),
            editor_window, SLOT (setVisible (bool)));
 
   connect (editor_window, SIGNAL (active_changed (bool)),
            show_editor_action, SLOT (setChecked (bool)));
 #endif
 
+  connect (show_news_action, SIGNAL (toggled (bool)),
+           news_window, SLOT (setVisible (bool)));
+
+  connect (news_window, SIGNAL (active_changed (bool)),
+           show_news_action, SLOT (setChecked (bool)));
+
   connect (show_documentation_action, SIGNAL (toggled (bool)),
            doc_browser_window, SLOT (setVisible (bool)));
 
   connect (doc_browser_window, SIGNAL (active_changed (bool)),
            show_documentation_action, SLOT (setChecked (bool)));
 
   connect (command_window_action, SIGNAL (triggered ()),
            command_window, SLOT (focus ()));
@@ -1341,16 +1382,19 @@ main_window::construct_window_menu (QMen
   connect (file_browser_action, SIGNAL (triggered ()),
            file_browser_window, SLOT (focus ()));
 
 #ifdef HAVE_QSCINTILLA
   connect (editor_action, SIGNAL (triggered ()),
            editor_window, SLOT (focus ()));
 #endif
 
+  connect (news_action, SIGNAL (triggered ()),
+           news_window, SLOT (focus ()));
+
   connect (documentation_action, SIGNAL (triggered ()),
            doc_browser_window, SLOT (focus ()));
 
   connect (reset_windows_action, SIGNAL (triggered ()),
            this, SLOT (reset_windows ()));
 }
 
 void
@@ -1415,16 +1459,34 @@ main_window::construct_documentation_men
   connect (ondisk_documentation_action, SIGNAL (triggered ()),
            doc_browser_window, SLOT (focus ()));
 
   connect (online_documentation_action, SIGNAL (triggered ()),
            this, SLOT (open_online_documentation_page ()));
 }
 
 void
+main_window::construct_news_menu (QMenuBar *p)
+{
+  QMenu *news_menu = p->addMenu (tr ("&News"));
+
+  QAction *release_notes_action
+    = news_menu->addAction (tr ("Release Notes"));
+
+  QAction *current_news_action
+    = news_menu->addAction (tr ("Community News"));
+
+  connect (release_notes_action, SIGNAL (triggered ()),
+           this, SLOT (display_release_notes ()));
+
+  connect (current_news_action, SIGNAL (triggered ()),
+           news_window, SLOT (show ()));
+}
+
+void
 main_window::construct_tool_bar (void)
 {
   _main_tool_bar = addToolBar ("Main");
 
   _main_tool_bar->setObjectName ("MainToolBar");
   _main_tool_bar->addAction (_new_script_action);
   _main_tool_bar->addAction (_open_action);
 
diff --git a/libgui/src/main-window.h b/libgui/src/main-window.h
--- a/libgui/src/main-window.h
+++ b/libgui/src/main-window.h
@@ -46,16 +46,17 @@ along with Octave; see the file COPYING.
 
 // Own includes
 #include "dialog.h"
 #include "resource-manager.h"
 #include "workspace-model.h"
 #include "workspace-view.h"
 #include "history-dock-widget.h"
 #include "files-dock-widget.h"
+#include "news-dock-widget.h"
 #include "terminal-dock-widget.h"
 #include "documentation-dock-widget.h"
 #include "octave-qt-link.h"
 #include "octave-dock-widget.h"
 #include "find-files-dialog.h"
 
 /**
  * \class MainWindow
@@ -103,16 +104,17 @@ public slots:
   void handle_clear_workspace_request (void);
   void handle_clear_history_request (void);
   void handle_rename_variable_request (const QString& old_name,
                                        const QString& new_name);
   void handle_undo_request (void);
   void new_file (const QString& commands = QString ());
   void open_file (const QString& file_name = QString ());
   void open_online_documentation_page (void);
+  void display_release_notes (void);
   void open_bug_tracker_page (void);
   void open_octave_packages_page (void);
   void open_agora_page (void);
   void open_contribute_page (void);
   void open_developer_page (void);
   void process_settings_dialog_request (void);
   void show_about_octave (void);
   void notice_settings (const QSettings *settings);
@@ -211,18 +213,22 @@ private:
   void construct_debug_menu (QMenuBar *p);
   QAction *construct_window_menu_item (QMenu *p, const QString& item,
                                        bool checkable,
                                        const QKeySequence& key);
   void construct_window_menu (QMenuBar *p);
   void construct_help_menu (QMenuBar *p);
   void construct_documentation_menu (QMenu *p);
 
+  void construct_news_menu (QMenuBar *p);
+
   void construct_tool_bar (void);
 
+  void display_url_in_window (const QUrl& url);
+
   void establish_octave_link (void);
 
   void save_workspace_callback (const std::string& file);
 
   void load_workspace_callback (const std::string& file);
 
   void rename_variable_callback (const name_pair& names);
 
@@ -258,37 +264,42 @@ private:
   void queue_command (QString command);  // Data models.
 
   workspace_model *_workspace_model;
 
   // Toolbars.
   QStatusBar *status_bar;
 
   // Subwindows.
+  news_dock_widget *news_window;
   terminal_dock_widget *command_window;
   history_dock_widget *history_window;
   files_dock_widget *file_browser_window;
   documentation_dock_widget *doc_browser_window;
   file_editor_interface *editor_window;
   workspace_view *workspace_window;
   QList<octave_dock_widget *> dock_widget_list ()
   {
     QList<octave_dock_widget *> list = QList<octave_dock_widget *> ();
+    list.append (static_cast<octave_dock_widget *> (news_window));
     list.append (static_cast<octave_dock_widget *> (command_window));
     list.append (static_cast<octave_dock_widget *> (history_window));
     list.append (static_cast<octave_dock_widget *> (file_browser_window));
     list.append (static_cast<octave_dock_widget *> (doc_browser_window));
 #ifdef HAVE_QSCINTILLA
     list.append (static_cast<octave_dock_widget *> (editor_window));
 #endif
     list.append (static_cast<octave_dock_widget *> (workspace_window));
     return list;
   }
 
+  QString _release_notes_icon;
+
   QToolBar *_main_tool_bar;
+
   QMenu *_debug_menu;
 
   QAction *_debug_continue;
   QAction *_debug_step_into;
   QAction *_debug_step_over;
   QAction *_debug_step_out;
   QAction *_debug_quit;
 
diff --git a/libgui/src/module.mk b/libgui/src/module.mk
--- a/libgui/src/module.mk
+++ b/libgui/src/module.mk
@@ -31,28 +31,32 @@ octave_gui_ICONS = \
   src/icons/filesave.png \
   src/icons/find.png \
   src/icons/gear.png \
   src/icons/folder_new.png \
   src/icons/graphic_logo_DocumentationDockWidget.png \
   src/icons/graphic_logo_FileEditor.png \
   src/icons/graphic_logo_FilesDockWidget.png \
   src/icons/graphic_logo_HistoryDockWidget.png \
+  src/icons/graphic_logo_NewsDockWidget.png \
   src/icons/graphic_logo_TerminalDockWidget.png \
   src/icons/graphic_logo_WorkspaceView.png \
+  src/icons/graphic_logo_ReleaseWidget.png \
   src/icons/help_index.png \
   src/icons/home.png \
   src/icons/icons_license \
   src/icons/jabber_protocol.png \
   src/icons/letter_logo_DocumentationDockWidget.png \
   src/icons/letter_logo_FileEditor.png \
   src/icons/letter_logo_FilesDockWidget.png \
   src/icons/letter_logo_HistoryDockWidget.png \
+  src/icons/letter_logo_NewsDockWidget.png \
   src/icons/letter_logo_TerminalDockWidget.png \
   src/icons/letter_logo_WorkspaceView.png \
+  src/icons/letter_logo_ReleaseWidget.png \
   src/icons/logo.png \
   src/icons/ok.png \
   src/icons/question.png \
   src/icons/redled.png \
   src/icons/redo.png \
   src/icons/reload.png \
   src/icons/search.png \
   src/icons/star.png \
@@ -80,32 +84,32 @@ endif
 octave_gui_MOC += \
   src/moc-dialog.cc \
   src/moc-documentation-dock-widget.cc \
   src/moc-files-dock-widget.cc \
   src/moc-history-dock-widget.cc \
   src/moc-main-window.cc \
   src/moc-octave-qt-link.cc \
   src/moc-settings-dialog.cc \
+  src/moc-news-dock-widget.cc \
   src/moc-terminal-dock-widget.cc \
   src/moc-color-picker.cc \
   src/moc-welcome-wizard.cc \
   src/moc-workspace-model.cc \
   src/moc-workspace-view.cc \
   src/moc-find-files-dialog.cc \
   src/moc-find-files-model.cc \
   src/qtinfo/moc-parser.cc \
   src/qtinfo/moc-webinfo.cc \
   src/moc-octave-dock-widget.cc
 
 octave_gui_RC = src/qrc-resource.cc
 
 octave_gui_UI = \
-  src/settings-dialog.ui \
-  src/welcome-wizard.ui
+  src/settings-dialog.ui
 
 octave_gui_UI_H = $(patsubst src/%.ui, src/ui-%.h, $(octave_gui_UI))
 
 BUILT_SOURCES += $(octave_gui_UI_H)
 
 noinst_HEADERS += \
   src/dialog.h \
   src/octave-dock-widget.h \
@@ -120,16 +124,17 @@ noinst_HEADERS += \
   src/main-window.h \
   src/octave-gui.h \
   src/octave-main-thread.h \
   src/octave-qt-link.h \
   src/qtinfo/parser.h \
   src/qtinfo/webinfo.h \
   src/resource-manager.h \
   src/settings-dialog.h \
+  src/news-dock-widget.h \
   src/terminal-dock-widget.h \
   src/color-picker.h \
   src/welcome-wizard.h \
   src/find-files-dialog.h \
   src/find-files-model.h \
   src/workspace-model.h \
   src/workspace-view.h
 
@@ -146,16 +151,17 @@ src_libgui_src_la_SOURCES = \
   src/octave-dock-widget.cc \
   src/octave-gui.cc \
   src/octave-main-thread.cc \
   src/octave-qt-link.cc \
   src/qtinfo/parser.cc \
   src/qtinfo/webinfo.cc \
   src/resource-manager.cc \
   src/settings-dialog.cc \
+  src/news-dock-widget.cc \
   src/terminal-dock-widget.cc \
   src/color-picker.cc \
   src/welcome-wizard.cc \
   src/find-files-dialog.cc \
   src/find-files-model.cc \
   src/workspace-model.cc \
   src/workspace-view.cc
 
diff --git a/libgui/src/news-dock-widget.cc b/libgui/src/news-dock-widget.cc
new file mode 100644
--- /dev/null
+++ b/libgui/src/news-dock-widget.cc
@@ -0,0 +1,137 @@
+/*
+
+Copyright (C) 2013 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <iostream>
+
+#include <QThread>
+
+#include "news-dock-widget.h"
+
+#include "Array.h"
+#include "str-vec.h"
+#include "url-transfer.h"
+
+#include "version.h"
+
+news_dock_widget::news_dock_widget (QWidget *p)
+  : octave_dock_widget (p), browser (new QTextBrowser (this))
+{
+  setObjectName ("NewsDockWidget");
+  setWindowIcon (QIcon (":/icons/logo.png"));
+  set_title (tr ("Community News"));
+
+  browser->setObjectName ("OctaveNews");
+  browser->setOpenExternalLinks (true);
+
+  setWidget (browser);
+
+  load_news ();
+}
+
+void
+news_dock_widget::load_news (void)
+{
+  QString base_url = "http://octave.org";
+  QString page = "community-news.html";
+
+  QThread *worker_thread = new QThread;
+
+  news_reader *reader = new news_reader (base_url, page);
+
+  reader->moveToThread (worker_thread);
+
+  connect (reader, SIGNAL (display_news_signal (const QString&)),
+           this, SLOT (display_news (const QString&)));
+
+  connect (worker_thread, SIGNAL (started (void)), reader, SLOT (process ()));
+
+  connect (reader, SIGNAL (finished (void)), worker_thread, SLOT (quit ()));
+
+  connect (reader, SIGNAL (finished (void)), reader, SLOT (deleteLater ()));
+
+  connect (worker_thread, SIGNAL (finished (void)),
+           worker_thread, SLOT (deleteLater ()));
+
+  worker_thread->start ();
+}
+
+static const char fixed_news[] = "<html>\n\
+<body>\n\
+<p>\n\
+This window will be used to inform you about Octave community events.\n\
+Octave may show it to you even if you've chosen hide the window by\n\
+default.  We'll try not to bother you too much, but we do want to keep\n\
+you up to date with the latest information about important bug fixes,\n\
+new releases, or any other news that all Octave users should be aware of.\n\
+</p>\n\
+<p>\n\
+Currently, Octave's community news source seems to be unavailable.\n\
+For the latest news, please check\n\
+<a href=\"http://octave.org/community-news.html\">http://octave.org/community-news.html</a>\n\
+when you have a connection to the web.\n\
+</p>\n\
+<p>\n\
+<small><em>&mdash; The Octave Developers, " OCTAVE_RELEASE_DATE "</em></small>\n\
+</body>\n\
+</html>\n";
+
+void
+news_dock_widget::display_news (const QString& news)
+{
+  if (news.contains ("this-is-the-gnu-octave-community-news-page"))
+    {
+      browser->setHtml (news);
+
+      if (news.contains ("critical-news-event") && ! isVisible ())
+        setVisible (true);
+    }
+  else
+    browser->setHtml (fixed_news);
+}
+
+void
+news_reader::process (void)
+{
+  // Run this part in a separate thread so Octave can continue to run
+  // while we wait for the page to load.  Then emit the signal to
+  // display it when we have the page contents.
+
+  QString url = base_url + "/" + page;
+  std::ostringstream buf;
+  url_transfer octave_dot_org (url.toStdString (), buf);
+
+  Array<std::string> param;
+  octave_dot_org.http_get (param);
+
+  QString html_text;
+
+  if (octave_dot_org.good ())
+    html_text = QString::fromStdString (buf.str ());
+
+  emit display_news_signal (html_text);
+
+  emit finished ();
+}
diff --git a/libgui/src/news-dock-widget.h b/libgui/src/news-dock-widget.h
new file mode 100644
--- /dev/null
+++ b/libgui/src/news-dock-widget.h
@@ -0,0 +1,74 @@
+/*
+
+Copyright (C) 2013 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef NEWSDOCKWIDGET_H
+#define NEWSDOCKWIDGET_H
+
+#include <QTextBrowser>
+
+#include "octave-dock-widget.h"
+
+class news_dock_widget : public octave_dock_widget
+{
+  Q_OBJECT
+
+public:
+
+  news_dock_widget (QWidget *parent = 0);
+
+  void load_news (void);
+
+protected slots:
+
+  void display_news (const QString& news);
+
+private:
+
+  QTextBrowser *browser;
+};
+
+class news_reader : public QObject
+{
+  Q_OBJECT
+ 
+public:
+
+  news_reader (const QString& xbase_url, const QString& xpage)
+    : QObject (), base_url (xbase_url), page (xpage) { }
+ 
+public slots:
+
+    void process (void);
+ 
+signals:
+
+  void display_news_signal (const QString& news);
+
+  void finished (void);
+ 
+private:
+
+  QString base_url;
+  QString page;
+};
+
+#endif // NEWSDOCKWIDGET_H
diff --git a/libgui/src/octave-gui.cc b/libgui/src/octave-gui.cc
--- a/libgui/src/octave-gui.cc
+++ b/libgui/src/octave-gui.cc
@@ -20,16 +20,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <QtGui/QApplication>
+#include <QTextCodec>
 #include <QTranslator>
 
 #include <iostream>
 
 #include <unistd.h>
 #include <fcntl.h>
 
 #if defined (HAVE_SYS_IOCTL_H)
@@ -92,16 +93,19 @@ dissociate_terminal (void)
 int
 octave_start_gui (int argc, char *argv[], bool fork)
 {
   if (fork)
     dissociate_terminal ();
 
   QApplication application (argc, argv);
 
+  // Set the codec for all strings
+  QTextCodec::setCodecForCStrings(QTextCodec::codecForName("UTF-8"));
+
   // install translators for the gui and qt text
   QTranslator gui_tr, qt_tr, qsci_tr;
   resource_manager::config_translators (&qt_tr,&qsci_tr,&gui_tr);
   application.installTranslator (&qt_tr);
   application.installTranslator (&qsci_tr);
   application.installTranslator (&gui_tr);
 
   while (true)
diff --git a/libgui/src/resource.qrc b/libgui/src/resource.qrc
--- a/libgui/src/resource.qrc
+++ b/libgui/src/resource.qrc
@@ -41,23 +41,27 @@
         <file>icons/bp_next.png</file>
         <file>icons/db_cont.png</file>
         <file>icons/db_step.png</file>
         <file>icons/db_step_in.png</file>
         <file>icons/db_step_out.png</file>
         <file>icons/db_stop.png</file>
         <file>icons/letter_logo_FilesDockWidget.png</file>
         <file>icons/letter_logo_FileEditor.png</file>
+        <file>icons/letter_logo_NewsDockWidget.png</file>
         <file>icons/letter_logo_TerminalDockWidget.png</file>
         <file>icons/letter_logo_HistoryDockWidget.png</file>
         <file>icons/letter_logo_WorkspaceView.png</file>
         <file>icons/letter_logo_DocumentationDockWidget.png</file>
+        <file>icons/letter_logo_ReleaseWidget.png</file>
         <file>icons/graphic_logo_FilesDockWidget.png</file>
         <file>icons/graphic_logo_FileEditor.png</file>
+        <file>icons/graphic_logo_NewsDockWidget.png</file>
         <file>icons/graphic_logo_TerminalDockWidget.png</file>
         <file>icons/graphic_logo_HistoryDockWidget.png</file>
         <file>icons/graphic_logo_WorkspaceView.png</file>
         <file>icons/graphic_logo_DocumentationDockWidget.png</file>
+        <file>icons/graphic_logo_ReleaseWidget.png</file>
         <file>icons/widget-close.png</file>
         <file>icons/widget-dock.png</file>
         <file>icons/widget-undock.png</file>
     </qresource>
 </RCC>
diff --git a/libgui/src/welcome-wizard.cc b/libgui/src/welcome-wizard.cc
--- a/libgui/src/welcome-wizard.cc
+++ b/libgui/src/welcome-wizard.cc
@@ -1,10 +1,11 @@
 /*
 
+Copyright (C) 2013 John W. Eaton
 Copyright (C) 2011-2012 Jacob Dawid
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -19,26 +20,105 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include <QApplication>
+#include <QHBoxLayout>
+#include <QVBoxLayout>
+#include <QLabel>
+#include <QPushButton>
+
 #include "welcome-wizard.h"
 #include "resource-manager.h"
-#include "ui-welcome-wizard.h"
 
 welcome_wizard::welcome_wizard (QWidget *p)
-  : QDialog (p), _ui (new Ui::welcome_wizard)
+  : QDialog (p)
 {
-  _ui->setupUi (this);
-  QString label_text = _ui->label_config_file->text ();
-  label_text.replace (QString ("__%1__"),
-                      resource_manager::get_settings_file ());
-  _ui->label_config_file->setText (label_text);
+  setWindowTitle (tr ("Welcome to GNU Octave"));
+
+  setEnabled (true);
+  resize (600, 480);
+  setMinimumSize (QSize (600, 480));
+
+
+  QVBoxLayout *page_layout = new QVBoxLayout (this);
+  setLayout (page_layout);
+
+  QHBoxLayout *message_and_logo = new QHBoxLayout;
+
+  QVBoxLayout *message = new QVBoxLayout;
+
+  QLabel *title = new QLabel (tr ("Welcome to Octave!"));
+  QFont ft;
+  ft.setPointSize (20);
+  title->setFont (ft);
+
+  QLabel *msg_1 = new QLabel (tr ("You seem to be using the Octave graphical interface for the first  time on this computer.  Click 'Finish' to write a configuration file  and launch Octave GUI."));
+  msg_1->setWordWrap (true);
+
+  QString msg_2_text = QString (tr ("The configuration file is stored in %1. "
+                                    "If that file exists, you will not see this "
+                                    "dialog when Octave starts again.").
+                                    arg (resource_manager::get_settings_file ()));
+  QLabel *msg_2 = new QLabel (msg_2_text);
+  msg_2->setWordWrap (true);
+
+  message->addWidget (title);
+  message->addWidget (msg_1);
+  message->addWidget (msg_2);
+
+  QSpacerItem *logo_filler = new QSpacerItem (40, 20, QSizePolicy::Expanding,
+                                              QSizePolicy::Minimum);
+
+  QLabel *logo = new QLabel;
+  QPixmap logo_pixmap (":/actions/icons/logo.png");
+  logo->setPixmap (logo_pixmap.scaledToHeight (150));
+
+  message_and_logo->addLayout (message);
+  message_and_logo->addItem (logo_filler);
+  message_and_logo->addWidget (logo);
+
+  QLabel *links = new QLabel
+    (tr ("<html><head>\n"
+         "<style>\n"
+         "a:link { text-decoration: underline; color: #0000ff; }\n"
+         "</style>\n"
+         "<head/><body>\n"
+         "<p>For more information about Octave:</p>\n"
+         "<ul>\n"
+         "<li>Visit <a href=\"http://octave.org\">http://octave.org</a></li>\n"
+         "<li>Get the documentation online as <a href=\"http://www.gnu.org/software/octave/doc/interpreter/index.html\">html</a>- or <a href=\"http://www.gnu.org/software/octave/octave.pdf\">pdf</span></a>-document</li>\n"
+         "<li>Open the documentation browser of Octave GUI with the help menu</li>\n"
+         "</ul>\n"
+         "</body></html>"),
+     this);
+  links->setWordWrap (true);
+  links->setOpenExternalLinks (true);
+
+  QSpacerItem *hfill = new QSpacerItem (40, 20, QSizePolicy::Expanding,
+                                        QSizePolicy::Minimum);
+
+  QPushButton *finish_button = new QPushButton;
+  finish_button->setText (tr ("Finish"));
+
+  QSpacerItem *vspace = new QSpacerItem (20, 40, QSizePolicy::Minimum);
+
+  QHBoxLayout *button_bar = new QHBoxLayout;
+
+  button_bar->addItem (hfill);
+  button_bar->addWidget (finish_button);
+
+  QSpacerItem *vfill = new QSpacerItem (20, 40, QSizePolicy::Minimum,
+                                        QSizePolicy::Expanding);
+
+  page_layout->addLayout (message_and_logo);
+  page_layout->addWidget (links);
+  page_layout->addItem (vspace);
+  page_layout->addLayout (button_bar);
+  page_layout->addItem (vfill);
+
+  connect (finish_button, SIGNAL (clicked ()), this, SLOT (accept ()));
 }
-
-welcome_wizard::~welcome_wizard()
-{
-  delete _ui;
-}
diff --git a/libgui/src/welcome-wizard.h b/libgui/src/welcome-wizard.h
--- a/libgui/src/welcome-wizard.h
+++ b/libgui/src/welcome-wizard.h
@@ -1,10 +1,11 @@
 /*
 
+Copyright (C) 2013 John W. Eaton
 Copyright (C) 2011-2012 Jacob Dawid
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -20,27 +21,20 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifndef WELCOMEWIZARD_H
 #define WELCOMEWIZARD_H
 
 #include <QDialog>
 
-namespace Ui {
-  class welcome_wizard;
-}
-
 class welcome_wizard : public QDialog
 {
   Q_OBJECT
 
-  public:
-  explicit welcome_wizard (QWidget *parent = 0);
-  ~welcome_wizard ();
+public:
 
-public slots:
+  welcome_wizard (QWidget *parent = 0);
 
-private:
-  Ui::welcome_wizard *_ui;
+  ~welcome_wizard (void) { }
 };
 
 #endif // WELCOMEWIZARD_H
diff --git a/libgui/src/welcome-wizard.ui b/libgui/src/welcome-wizard.ui
deleted file mode 100644
--- a/libgui/src/welcome-wizard.ui
+++ /dev/null
@@ -1,145 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<ui version="4.0">
- <class>welcome_wizard</class>
- <widget class="QDialog" name="welcome_wizard">
-  <property name="enabled">
-   <bool>true</bool>
-  </property>
-  <property name="geometry">
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>480</width>
-    <height>320</height>
-   </rect>
-  </property>
-  <property name="minimumSize">
-   <size>
-    <width>480</width>
-    <height>320</height>
-   </size>
-  </property>
-  <property name="maximumSize">
-   <size>
-    <width>480</width>
-    <height>320</height>
-   </size>
-  </property>
-  <property name="windowTitle">
-   <string>Welcome to GNU Octave</string>
-  </property>
-  <layout class="QVBoxLayout" name="verticalLayout_2">
-   <item>
-    <layout class="QVBoxLayout" name="verticalLayout_7">
-     <item>
-      <widget class="QLabel" name="label_2">
-       <property name="font">
-        <font>
-         <pointsize>20</pointsize>
-        </font>
-       </property>
-       <property name="text">
-        <string>Welcome to Octave!</string>
-       </property>
-      </widget>
-     </item>
-     <item>
-      <widget class="QLabel" name="label_4">
-       <property name="text">
-        <string>You seem to be using the Octave graphical interface for the first  time on this computer.  Click 'Finish' to write a configuration file  and launch Octave GUI. </string>
-       </property>
-       <property name="wordWrap">
-        <bool>true</bool>
-       </property>
-      </widget>
-     </item>
-     <item>
-      <widget class="QLabel" name="label_config_file">
-       <property name="text">
-        <string>The configuration file is stored in __%1__. If that file exists, you will not see this dialog when Octave starts again.</string>
-       </property>
-       <property name="wordWrap">
-        <bool>true</bool>
-       </property>
-      </widget>
-     </item>
-     <item>
-      <widget class="QLabel" name="label_3">
-       <property name="text">
-        <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;For more information about Octave,&lt;/p&gt;
-&lt;ul&gt;
-&lt;li&gt;visit &lt;a href=&quot;http://octave.org&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;http://octave.org&lt;/span&gt;&lt;/a&gt;,&lt;/li&gt;
-&lt;li&gt; get the documentation online as &lt;a href=&quot;http://www.gnu.org/software/octave/doc/interpreter/index.html&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;html&lt;/span&gt;&lt;/a&gt;- or &lt;a href=&quot;http://www.gnu.org/software/octave/octave.pdf&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;pdf&lt;/span&gt;&lt;/a&gt;-document, or&lt;/li&gt;
-&lt;li&gt;open the documentation browser of Octave GUI with the help menu.&lt;/li&gt;
-&lt;/ul&gt;
-&lt;/body&gt;&lt;/html&gt;</string>
-       </property>
-       <property name="wordWrap">
-        <bool>true</bool>
-       </property>
-       <property name="openExternalLinks">
-        <bool>true</bool>
-       </property>
-      </widget>
-     </item>
-     <item>
-      <spacer name="verticalSpacer_5">
-       <property name="orientation">
-        <enum>Qt::Vertical</enum>
-       </property>
-       <property name="sizeHint" stdset="0">
-        <size>
-         <width>20</width>
-         <height>40</height>
-        </size>
-       </property>
-      </spacer>
-     </item>
-     <item>
-      <layout class="QHBoxLayout" name="horizontalLayout_7">
-       <item>
-        <spacer name="horizontalSpacer_5">
-         <property name="orientation">
-          <enum>Qt::Horizontal</enum>
-         </property>
-         <property name="sizeHint" stdset="0">
-          <size>
-           <width>40</width>
-           <height>20</height>
-          </size>
-         </property>
-        </spacer>
-       </item>
-       <item>
-        <widget class="QPushButton" name="finishButton">
-         <property name="text">
-          <string>Finish</string>
-         </property>
-        </widget>
-       </item>
-      </layout>
-     </item>
-    </layout>
-   </item>
-  </layout>
- </widget>
- <resources/>
- <connections>
-  <connection>
-   <sender>finishButton</sender>
-   <signal>clicked()</signal>
-   <receiver>welcome_wizard</receiver>
-   <slot>accept()</slot>
-   <hints>
-    <hint type="sourcelabel">
-     <x>577</x>
-     <y>372</y>
-    </hint>
-    <hint type="destinationlabel">
-     <x>323</x>
-     <y>199</y>
-    </hint>
-   </hints>
-  </connection>
- </connections>
-</ui>
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -7338,20 +7338,23 @@ Encode a double matrix or array @var{x} 
             {                                                           \
               const X##NDArray in = args(0).  X## _array_value ();      \
               size_t inlen =                                            \
                 in.numel () * sizeof (X## _t) / sizeof (char);          \
               const char* inc =                                         \
                 reinterpret_cast<const char*> (in.data ());             \
               char* out;                                                \
               if (! error_state                                         \
-                  && octave_base64_encode (inc, inlen, &out))          \
-                retval(0) = octave_value (out);                         \
+                  && octave_base64_encode (inc, inlen, &out))           \
+                {                                                       \
+                  retval(0) = octave_value (out);                       \
+                  ::free (out);                                         \
+                }                                                       \
             }
-                                          
+
           MAKE_INT_BRANCH(int8)
           else MAKE_INT_BRANCH(int16)
           else MAKE_INT_BRANCH(int32)
           else MAKE_INT_BRANCH(int64)
           else MAKE_INT_BRANCH(uint8)
           else MAKE_INT_BRANCH(uint16)
           else MAKE_INT_BRANCH(uint32)
           else MAKE_INT_BRANCH(uint64)
@@ -7365,29 +7368,35 @@ Encode a double matrix or array @var{x} 
           const Array<float> in = args(0).float_array_value ();
           size_t inlen;
           inlen = in.numel () * sizeof (float) / sizeof (char); 
           const char*  inc;
           inc = reinterpret_cast<const char*> (in.data ());  
           char* out;
           if (! error_state 
               && octave_base64_encode (inc, inlen, &out))
-            retval(0) = octave_value (out);
+            {
+              retval(0) = octave_value (out);
+              ::free (out);
+            }
         }                 
       else
         {
           const Array<double> in = args(0).array_value ();
           size_t inlen;
           inlen = in.numel () * sizeof (double) / sizeof (char); 
           const char*  inc;
           inc = reinterpret_cast<const char*> (in.data ());   
           char* out;
           if (! error_state 
               && octave_base64_encode (inc, inlen, &out))
-            retval(0) = octave_value (out);
+            {
+              retval(0) = octave_value (out);
+              ::free (out);
+            }
         }
     }  
   return retval;
 }
 
 /*
 %!assert (base64_encode (single (pi)), "2w9JQA==")
 %!assert (base64_encode (uint8 ([0 0 0])), "AAAA")
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -1116,36 +1116,51 @@ do_dbstack (const octave_value_list& arg
   octave_value_list retval;
 
   unwind_protect frame;
 
   octave_idx_type curr_frame = -1;
 
   size_t nskip = 0;
 
-  if (args.length () == 1)
+  octave_idx_type len = args.length ();
+
+  // dbstack accepts up to 2 arguments.
+
+  if (len == 1 || len == 2)
     {
       int n = 0;
 
-      octave_value arg = args(0);
-
-      if (arg.is_string ())
+      for (octave_idx_type i = 0; i < len && ! error_state; i++)
         {
-          std::string s_arg = arg.string_value ();
+          octave_value arg = args(i);
+
+          if (arg.is_string ())
+            {
+              std::string s_arg = arg.string_value ();
+
+              // Skip "-completenames", octave returns full names anyway.
 
-          n = atoi (s_arg.c_str ());
+              if (s_arg == "-completenames")
+                continue;
+
+              n = atoi (s_arg.c_str ());
+            }
+          else
+            n = arg.int_value ();
+
+          if (! error_state && n <= 0)
+            error ("dbstack: N must be a non-negative integer");
         }
-      else
-        n = args(0).int_value ();
 
       if (n > 0)
         nskip = n;
-      else
-        error ("dbstack: N must be a non-negative integer");
     }
+  else if (len)
+    print_usage ();
 
   if (! error_state)
     {
       octave_map stk = octave_call_stack::backtrace (nskip, curr_frame);
 
       if (nargout == 0)
         {
           octave_idx_type nframes_to_display = stk.numel ();
@@ -1209,20 +1224,25 @@ show_octave_dbstack (void)
 {
   do_dbstack (octave_value_list (), 0, std::cerr);
 }
 
 DEFUN (dbstack, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Command} {} dbstack\n\
 @deftypefnx {Command} {} dbstack @var{n}\n\
+@deftypefnx {Command} {} dbstack @var{-completenames}\n\
 @deftypefnx {Built-in Function} {[@var{stack}, @var{idx}] =} dbstack (@dots{})\n\
 Display or return current debugging function stack information.\n\
 With optional argument @var{n}, omit the @var{n} innermost stack frames.\n\
 \n\
+Although accepted, the argument @var{-completenames} is silently ignored.\n\
+Octave always returns absolute file names. The arguments @var{n} and\n\
+@var{-completenames} can be both specified in any order.\n\
+\n\
 The optional return argument @var{stack} is a struct array with the\n\
 following fields:\n\
 \n\
 @table @asis\n\
 @item file\n\
 The name of the m-file where the function code is located.\n\
 \n\
 @item name\n\
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -1611,18 +1611,16 @@ opengl_renderer::draw_surface (const sur
         i1 = i;
 
       for (int j = 0; j < zc; j++)
         {
           if (y_mat)
             j1 = j;
 
           clip(i,j) = is_nan_or_inf (x(i1,j), y(i,j1), z(i,j));
-          if (fc_mode == 1 || fc_mode == 2)
-            clip(i,j) |= (xisnan (c(i,j)) || xisinf (c(i,j)));
         }
     }
 
   if (fa_mode > 0 || ea_mode > 0)
     {
       // FIXME: implement alphadata conversion
       //a = props.get_alpha_data ();
     }
@@ -1671,20 +1669,35 @@ opengl_renderer::draw_surface (const sur
               if (y_mat)
                 {
                   i1 = i-1;
                   i2 = i;
                 }
 
               for (int j = 1; j < zr; j++)
                 {
-                  if (clip(j-1, i-1) || clip (j, i-1)
-                      || clip (j-1, i) || clip (j, i))
+
+                  if (clip(j-1, i-1) || clip(j, i-1)
+                      || clip(j-1, i) || clip(j, i))
                     continue;
 
+                  if (fc_mode == 1)
+                    {
+                      // "flat" only needs color at lower-left vertex
+                      if (! xfinite (c(j-1,i-1)))
+                        continue;
+                    }
+                  else if (fc_mode == 2)
+                    {
+                      // "interp" needs valid color at all 4 vertices
+                      if (! (xfinite (c(j-1, i-1)) && xfinite (c(j, i-1))
+                             && xfinite (c(j-1, i)) && xfinite (c(j, i))))
+                        continue;
+                    }
+
                   if (x_mat)
                     {
                       j1 = j-1;
                       j2 = j;
                     }
 
                   glBegin (GL_QUADS);
 
@@ -1862,16 +1875,29 @@ opengl_renderer::draw_surface (const sur
                       i2 = i;
                     }
 
                   for (int j = 1; j < zr; j++)
                     {
                       if (clip(j-1,i) || clip(j,i))
                         continue;
 
+                      if (ec_mode == 1)
+                        {
+                          // "flat" only needs color at lower-left vertex
+                          if (! xfinite (c(j-1,i)))
+                            continue;
+                        }
+                      else if (ec_mode == 2)
+                        {
+                          // "interp" needs valid color at both vertices
+                          if (! (xfinite (c(j-1, i)) && xfinite (c(j, i))))
+                            continue;
+                        }
+
                       if (x_mat)
                         {
                           j1 = j-1;
                           j2 = j;
                         }
 
                       glBegin (GL_LINES);
 
@@ -1946,16 +1972,29 @@ opengl_renderer::draw_surface (const sur
                       j2 = j;
                     }
 
                   for (int i = 1; i < zc; i++)
                     {
                       if (clip(j,i-1) || clip(j,i))
                         continue;
 
+                      if (ec_mode == 1)
+                        {
+                          // "flat" only needs color at lower-left vertex
+                          if (! xfinite (c(j,i-1)))
+                            continue;
+                        }
+                      else if (ec_mode == 2)
+                        {
+                          // "interp" needs valid color at both vertices
+                          if (! (xfinite (c(j, i-1)) && xfinite (c(j, i))))
+                            continue;
+                        }
+
                       if (y_mat)
                         {
                           i1 = i-1;
                           i2 = i;
                         }
 
                       glBegin (GL_LINES);
 
@@ -2075,22 +2114,27 @@ opengl_renderer::draw_surface (const sur
                 continue;
 
               if (x_mat)
                 j1 = j;
 
               if ((do_edge && mecolor.numel () == 0)
                   || (do_face && mfcolor.numel () == 0))
                 {
+                  if (! xfinite (c(j,i)))
+                    continue;  // Skip NaNs in color data
+
                   for (int k = 0; k < 3; k++)
                     cc(k) = c(j,i,k);
                 }
 
-              Matrix lc = (do_edge ? (mecolor.numel () == 0 ? cc : mecolor) : Matrix ());
-              Matrix fc = (do_face ? (mfcolor.numel () == 0 ? cc : mfcolor) : Matrix ());
+              Matrix lc = (do_edge ? (mecolor.numel () == 0 ? cc : mecolor)
+                                   : Matrix ());
+              Matrix fc = (do_face ? (mfcolor.numel () == 0 ? cc : mfcolor)
+                                   : Matrix ());
 
               draw_marker (x(j1,i), y(j,i1), z(j,i), lc, fc);
             }
         }
 
       end_marker ();
     }
 }
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -1194,60 +1194,63 @@ double_radio_property::do_set (const oct
   return false;
 }
 
 bool
 array_property::validate (const octave_value& v)
 {
   bool xok = false;
 
-  // FIXME -- should we always support []?
-  if (v.is_empty () && v.is_numeric_type ())
-    return true;
-
   // check value type
   if (type_constraints.size () > 0)
     {
-      if(type_constraints.find (v.class_name()) != type_constraints.end())
+      if (type_constraints.find (v.class_name ()) != type_constraints.end ())
         xok = true;
 
       // check if complex is allowed (it's also of class "double", so
       // checking that alone is not enough to ensure real type)
       if (type_constraints.find ("real") != type_constraints.end ()
           && v.is_complex_type ())
         xok = false;
     }
   else
     xok = v.is_numeric_type ();
 
   if (xok)
     {
+      if (size_constraints.size () == 0)
+        return true;
+
       dim_vector vdims = v.dims ();
       int vlen = vdims.length ();
 
       xok = false;
 
-      // check value size
-      if (size_constraints.size () > 0)
-        for (std::list<dim_vector>::const_iterator it = size_constraints.begin ();
-             ! xok && it != size_constraints.end (); ++it)
-          {
-            dim_vector itdims = (*it);
-
-            if (itdims.length () == vlen)
-              {
-                xok = true;
-
-                for (int i = 0; xok && i < vlen; i++)
-                  if (itdims(i) >= 0 && itdims(i) != vdims(i))
-                    xok = false;
-              }
-          }
-      else
-        return true;
+      // check dimensional size constraints until a match is found
+      for (std::list<dim_vector>::const_iterator it = size_constraints.begin ();
+           ! xok && it != size_constraints.end (); ++it)
+        {
+          dim_vector itdims = (*it);
+
+          if (itdims.length () == vlen)
+            {
+              xok = true;
+
+              for (int i = 0; xok && i < vlen; i++)
+                {
+                  if (itdims(i) > 0)
+                    {
+                      if (itdims(i) != vdims(i))
+                        xok = false;
+                    }
+                  else if (v.is_empty ())
+                    break;
+                }
+            }
+        }
     }
 
   return xok;
 }
 
 bool
 array_property::is_equal (const octave_value& v) const
 {
@@ -2727,36 +2730,51 @@ base_properties::get_property_dynamic (c
     }
   else
     return it->second;
 }
 
 void
 base_properties::set_parent (const octave_value& val)
 {
-  double tmp = val.double_value ();
+  double hnp = val.double_value ();
 
   graphics_handle new_parent = octave_NaN;
 
   if (! error_state)
     {
-      new_parent = gh_manager::lookup (tmp);
-
-      if (new_parent.ok ())
-        {
-          graphics_object parent_obj = gh_manager::get_object (get_parent ());
-
-          parent_obj.remove_child (__myhandle__);
-
-          parent = new_parent.as_octave_value ();
-
-          ::adopt (parent.handle_value (), __myhandle__);
-        }
+      if (hnp == __myhandle__)
+        error ("set: can not set object parent to be object itself");
       else
-        error ("set: invalid graphics handle (= %g) for parent", tmp);
+        {
+          new_parent = gh_manager::lookup (hnp);
+
+          if (new_parent.ok ())
+            {
+              // Remove child from current parent
+              graphics_object old_parent_obj;
+              old_parent_obj = gh_manager::get_object (get_parent ());
+              old_parent_obj.remove_child (__myhandle__);
+
+              // Check new parent's parent is not this child to avoid recursion
+              graphics_object new_parent_obj;
+              new_parent_obj = gh_manager::get_object (new_parent);
+              if (new_parent_obj.get_parent () == __myhandle__)
+                {
+                  // new parent's parent gets child's original parent
+                  new_parent_obj.get_properties ().set_parent (get_parent ().as_octave_value ());
+                }
+
+              // Set parent property to new_parent and do adoption
+              parent = new_parent.as_octave_value ();
+              ::adopt (parent.handle_value (), __myhandle__);
+            }
+          else
+            error ("set: invalid graphics handle (= %g) for parent", hnp);
+        }
     }
   else
     error ("set: expecting parent to be a graphics handle");
 }
 
 void
 base_properties::mark_modified (void)
 {
@@ -3928,42 +3946,43 @@ figure::reset_default_properties (void)
 }
 
 // ---------------------------------------------------------------------
 
 void
 axes::properties::init (void)
 {
   position.add_constraint (dim_vector (1, 4));
-  position.add_constraint (dim_vector (0, 0));
   outerposition.add_constraint (dim_vector (1, 4));
+  tightinset.add_constraint (dim_vector (1, 4));
+  looseinset.add_constraint (dim_vector (1, 4));
   colororder.add_constraint (dim_vector (-1, 3));
   dataaspectratio.add_constraint (dim_vector (1, 3));
   plotboxaspectratio.add_constraint (dim_vector (1, 3));
+  alim.add_constraint (2);
+  clim.add_constraint (2);
   xlim.add_constraint (2);
   ylim.add_constraint (2);
   zlim.add_constraint (2);
-  clim.add_constraint (2);
-  alim.add_constraint (2);
   xtick.add_constraint (dim_vector (1, -1));
   ytick.add_constraint (dim_vector (1, -1));
   ztick.add_constraint (dim_vector (1, -1));
+  ticklength.add_constraint (dim_vector (1, 2));
   Matrix vw (1, 2, 0);
   vw(1) = 90;
   view = vw;
   view.add_constraint (dim_vector (1, 2));
   cameraposition.add_constraint (dim_vector (1, 3));
+  cameratarget.add_constraint (dim_vector (1, 3));
   Matrix upv (1, 3, 0.0);
   upv(2) = 1.0;
   cameraupvector = upv;
   cameraupvector.add_constraint (dim_vector (1, 3));
   currentpoint.add_constraint (dim_vector (2, 3));
-  ticklength.add_constraint (dim_vector (1, 2));
-  tightinset.add_constraint (dim_vector (1, 4));
-  looseinset.add_constraint (dim_vector (1, 4));
+  // No constraints for hidden transform properties
   update_font ();
 
   x_zlim.resize (1, 2);
 
   sx = "linear";
   sy = "linear";
   sz = "linear";
 
@@ -5564,18 +5583,21 @@ axes::properties::get_boundingbox (bool 
                   get_position ().matrix_value ()
                   : get_outerposition ().matrix_value ());
   Matrix parent_size (parent_pix_size);
 
   if (parent_size.numel () == 0)
     {
       graphics_object obj = gh_manager::get_object (get_parent ());
 
-      parent_size =
-       obj.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
+      if (obj.valid_object ())
+        parent_size =
+          obj.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
+      else
+        parent_size = default_figure_position ();
     }
 
   pos = convert_position (pos, get_units (), "pixels", parent_size);
 
   pos(0)--;
   pos(1)--;
   pos(1) = parent_size(1) - pos(1) - pos(3);
 
@@ -7661,18 +7683,21 @@ uicontrol::properties::get_boundingbox (
 {
   Matrix pos = get_position ().matrix_value ();
   Matrix parent_size (parent_pix_size);
 
   if (parent_size.numel () == 0)
     {
       graphics_object obj = gh_manager::get_object (get_parent ());
 
-      parent_size =
-       obj.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
+      if (obj.valid_object ())
+        parent_size =
+          obj.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
+      else
+        parent_size = default_figure_position ();
     }
 
   pos = convert_position (pos, get_units (), "pixels", parent_size);
 
   pos(0)--;
   pos(1)--;
   pos(1) = parent_size(1) - pos(1) - pos(3);
 
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -1080,16 +1080,22 @@ class color_property : public base_prope
 {
 public:
   color_property (const color_values& c, const radio_values& v)
     : base_property ("", graphics_handle ()),
       current_type (color_t), color_val (c), radio_val (v),
       current_val (v.default_value ())
   { }
 
+  color_property (const radio_values& v, const color_values& c)
+    : base_property ("", graphics_handle ()),
+      current_type (radio_t), color_val (c), radio_val (v),
+      current_val (v.default_value ())
+  { }
+
   color_property (const std::string& nm, const graphics_handle& h,
                   const color_values& c = color_values (),
                   const radio_values& v = radio_values ())
     : base_property (nm, h),
       current_type (color_t), color_val (c), radio_val (v),
       current_val (v.default_value ())
   { }
 
@@ -1421,23 +1427,25 @@ class row_vector_property : public array
 {
 public:
   row_vector_property (const std::string& nm, const graphics_handle& h,
                        const octave_value& m)
     : array_property (nm, h, m)
   {
     add_constraint (dim_vector (-1, 1));
     add_constraint (dim_vector (1, -1));
+    add_constraint (dim_vector (0, 0));
   }
 
   row_vector_property (const row_vector_property& p)
     : array_property (p)
   {
     add_constraint (dim_vector (-1, 1));
     add_constraint (dim_vector (1, -1));
+    add_constraint (dim_vector (0, 0));
   }
 
   void add_constraint (const std::string& type)
   {
     array_property::add_constraint (type);
   }
 
   void add_constraint (const dim_vector& dims)
@@ -2393,17 +2401,17 @@ class OCTINTERP_API base_properties
 {
 public:
   base_properties (const std::string& ty = "unknown",
                    const graphics_handle& mh = graphics_handle (),
                    const graphics_handle& p = graphics_handle ());
 
   virtual ~base_properties (void) { }
 
-  virtual std::string graphics_object_name (void) const { return "unknonwn"; }
+  virtual std::string graphics_object_name (void) const { return "unknown"; }
 
   void mark_modified (void);
 
   void override_defaults (base_graphics_object& obj);
 
   virtual void init_integerhandle (const octave_value&)
     {
       panic_impossible ();
@@ -3358,23 +3366,24 @@ public:
       string_property __graphics_toolkit__ s , gtk_manager::default_toolkit ()
       any_property __guidata__ h , Matrix ()
       any_property __plot_stream__ h , Matrix ()
     END_PROPERTIES
 
   protected:
     void init (void)
       {
+        alphamap.add_constraint (dim_vector (-1, 1));
         colormap.add_constraint (dim_vector (-1, 3));
-        alphamap.add_constraint (dim_vector (-1, 1));
+        outerposition.add_constraint (dim_vector (1, 4));
         paperposition.add_constraint (dim_vector (1, 4));
+        papersize.add_constraint (dim_vector (1, 2));
         pointershapecdata.add_constraint (dim_vector (16, 16));
         pointershapehotspot.add_constraint (dim_vector (1, 2));
         position.add_constraint (dim_vector (1, 4));
-        outerposition.add_constraint (dim_vector (1, 4));
       }
 
   private:
     mutable graphics_toolkit toolkit;
   };
 
 private:
   properties xproperties;
@@ -4174,18 +4183,18 @@ public:
       string_property displayname , ""
       radio_property erasemode , "{normal}|none|xor|background"
       // FIXME: interpreter is not a property of Matlab line objects.
       //        Octave uses this for legend() with the string displayname.
       radio_property interpreter , "{tex}|none|latex"
       radio_property linestyle , "{-}|--|:|-.|none"
       double_property linewidth , 0.5
       radio_property marker , "{none}|+|o|*|.|x|s|square|d|diamond|^|v|>|<|p|pentagram|h|hexagram"
-      color_property markeredgecolor , "{auto}|none"
-      color_property markerfacecolor , "auto|{none}"
+      color_property markeredgecolor , color_property (radio_values ("{auto}|none"), color_values (0, 0, 0))
+      color_property markerfacecolor , color_property (radio_values ("auto|{none}"), color_values (0, 0, 0))
       double_property markersize , 6
       row_vector_property xdata u , default_data ()
       string_property xdatasource , ""
       row_vector_property ydata u , default_data ()
       string_property ydatasource , ""
       row_vector_property zdata u , Matrix ()
       string_property zdatasource , ""
 
@@ -4266,20 +4275,20 @@ public:
             set_positionmode ("manual");
         }
     }
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
 
     BEGIN_PROPERTIES (text)
-      color_property backgroundcolor , "{none}"
+      color_property backgroundcolor , color_property (radio_values ("{none}"), color_values (1, 1, 1))
       color_property color u , color_values (0, 0, 0)
       string_property displayname , ""
-      color_property edgecolor , "{none}"
+      color_property edgecolor , color_property (radio_values ("{none}"), color_values (0, 0, 0))
       bool_property editing , "off"
       radio_property erasemode , "{normal}|none|xor|background"
       array_property extent rG , Matrix (1, 4, 0.0)
       radio_property fontangle u , "{normal}|italic|oblique"
       string_property fontname u , OCTAVE_DEFAULT_FONTNAME
       double_property fontsize u , 10
       radio_property fontunits , "inches|centimeters|normalized|{points}|pixels"
       radio_property fontweight u , "light|{normal}|demi|bold"
@@ -4449,16 +4458,19 @@ public:
         cdata.add_constraint ("single");
         cdata.add_constraint ("logical");
         cdata.add_constraint ("uint8");
         cdata.add_constraint ("uint16");
         cdata.add_constraint ("int16");
         cdata.add_constraint ("real");
         cdata.add_constraint (dim_vector (-1, -1));
         cdata.add_constraint (dim_vector (-1, -1, 3));
+        alphadata.add_constraint (dim_vector (-1, -1));
+        alphadata.add_constraint ("double");
+        alphadata.add_constraint ("uint8");
       }
 
   private:
     void update_alphadata (void)
       {
         if (alphadatamapping_is ("scaled"))
           set_alim (alphadata.get_limits ());
         else
@@ -4584,19 +4596,18 @@ public:
       array_property facevertexalphadata , Matrix ()
       array_property facevertexcdata , Matrix ()
       // FIXME: interpreter is not a property of a Matlab patch.
       //        Octave uses this for legend() with the string displayname.
       radio_property interpreter , "{tex}|none|latex"
       radio_property linestyle , "{-}|--|:|-.|none"
       double_property linewidth , 0.5
       radio_property marker , "{none}|+|o|*|.|x|s|square|d|diamond|^|v|>|<|p|pentagram|h|hexagram"
-      //radio_property marker , "{none}|+|o|*|.|x|s|d|^|v|>|<|p|h"
-      color_property markeredgecolor , "none|{auto}|flat"
-      color_property markerfacecolor , "{none}|auto|flat"
+      color_property markeredgecolor , color_property (radio_values ("none|{auto}|flat"), color_values (0, 0, 0))
+      color_property markerfacecolor , color_property (radio_values ("{none}|auto|flat"), color_values (0, 0, 0))
       double_property markersize , 6
       radio_property normalmode , "{auto}|manual"
       double_property specularcolorreflectance , 1.0
       double_property specularexponent , 10.0
       double_property specularstrength , 0.6
       array_property vertexnormals , Matrix ()
       array_property vertices , Matrix ()
       array_property xdata u , Matrix ()
@@ -4617,23 +4628,25 @@ public:
     END_PROPERTIES
 
   protected:
     void init (void)
       {
         xdata.add_constraint (dim_vector (-1, -1));
         ydata.add_constraint (dim_vector (-1, -1));
         zdata.add_constraint (dim_vector (-1, -1));
+        faces.add_constraint (dim_vector (-1, -1));
         vertices.add_constraint (dim_vector (-1, 2));
         vertices.add_constraint (dim_vector (-1, 3));
         cdata.add_constraint (dim_vector (-1, -1));
         cdata.add_constraint (dim_vector (-1, -1, 3));
         facevertexcdata.add_constraint (dim_vector (-1, 1));
         facevertexcdata.add_constraint (dim_vector (-1, 3));
         facevertexalphadata.add_constraint (dim_vector (-1, 1));
+        vertexnormals.add_constraint (dim_vector (-1, -1));
       }
 
   private:
     void update_xdata (void) { set_xlim (xdata.get_limits ()); }
     void update_ydata (void) { set_ylim (ydata.get_limits ()); }
     void update_zdata (void) { set_zlim (zdata.get_limits ()); }
 
     void update_cdata (void)
@@ -4698,27 +4711,26 @@ public:
       string_property cdatasource , ""
       double_property diffusestrength , 0.6
       string_property displayname , ""
       double_radio_property edgealpha , double_radio_property (1.0, radio_values ("flat|interp"))
       color_property edgecolor , color_property (color_values (0, 0, 0), radio_values ("none|flat|interp"))
       radio_property edgelighting , "{none}|flat|gouraud|phong"
       radio_property erasemode , "{normal}|none|xor|background"
       double_radio_property facealpha , double_radio_property (1.0, radio_values ("flat|interp|texturemap"))
-      color_property facecolor , "none|{flat}|interp|texturemap"
+      color_property facecolor , color_property (radio_values ("none|{flat}|interp|texturemap"), color_values (0, 0, 0))
       radio_property facelighting , "{none}|flat|gouraud|phong"
       // FIXME: interpreter is not a Matlab surface property
       //        Octave uses this for legend() with the string displayname.
       radio_property interpreter , "{tex}|none|latex"
       radio_property linestyle , "{-}|--|:|-.|none"
       double_property linewidth , 0.5
       radio_property marker , "{none}|+|o|*|.|x|s|square|d|diamond|^|v|>|<|p|pentagram|h|hexagram"
-      //radio_property marker , "{none}|+|o|*|.|x|s|d|^|v|>|<|p|h"
-      color_property markeredgecolor , "none|{auto}|flat"
-      color_property markerfacecolor , "{none}|auto|flat"
+      color_property markeredgecolor , color_property (radio_values ("none|{auto}|flat"), color_values (0, 0, 0))
+      color_property markerfacecolor , color_property (radio_values ("{none}|auto|flat"), color_values (0, 0, 0))
       double_property markersize , 6
       radio_property meshstyle , "{both}|row|column"
       radio_property normalmode u , "{auto}|manual"
       double_property specularcolorreflectance , 1
       double_property specularexponent , 10
       double_property specularstrength , 0.9
       array_property vertexnormals u , Matrix ()
       array_property xdata u , Matrix ()
@@ -4742,26 +4754,24 @@ public:
     END_PROPERTIES
 
   protected:
     void init (void)
       {
         xdata.add_constraint (dim_vector (-1, -1));
         ydata.add_constraint (dim_vector (-1, -1));
         zdata.add_constraint (dim_vector (-1, -1));
-        alphadata.add_constraint ("single");
+        cdata.add_constraint ("double");
+        cdata.add_constraint ("single");
+        cdata.add_constraint (dim_vector (-1, -1));
+        cdata.add_constraint (dim_vector (-1, -1, 3));
         alphadata.add_constraint ("double");
         alphadata.add_constraint ("uint8");
         alphadata.add_constraint (dim_vector (-1, -1));
         vertexnormals.add_constraint (dim_vector (-1, -1, 3));
-        cdata.add_constraint ("single");
-        cdata.add_constraint ("double");
-        cdata.add_constraint ("uint8");
-        cdata.add_constraint (dim_vector (-1, -1));
-        cdata.add_constraint (dim_vector (-1, -1, 3));
       }
 
   private:
     void update_alphadata (void)
       {
         if (alphadatamapping_is ("scaled"))
           set_alim (alphadata.get_limits ());
         else
@@ -5057,17 +5067,16 @@ public:
   private:
     std::string cached_units;
 
   protected:
     void init (void)
       {
         cdata.add_constraint ("double");
         cdata.add_constraint ("single");
-        cdata.add_constraint ("uint8");
         cdata.add_constraint (dim_vector (-1, -1, 3));
         position.add_constraint (dim_vector (1, 4));
         sliderstep.add_constraint (dim_vector (1, 2));
         cached_units = get_units ();
       }
     
     void update_text_extent (void);
 
@@ -5278,17 +5287,16 @@ public:
       string_property tooltipstring , ""
     END_PROPERTIES
 
   protected:
     void init (void)
       {
         cdata.add_constraint ("double");
         cdata.add_constraint ("single");
-        cdata.add_constraint ("uint8");
         cdata.add_constraint (dim_vector (-1, -1, 3));
       }
   };
 
 private:
   properties xproperties;
 
 public:
@@ -5332,17 +5340,16 @@ public:
       string_property tooltipstring , ""
     END_PROPERTIES
 
   protected:
     void init (void)
       {
         cdata.add_constraint ("double");
         cdata.add_constraint ("single");
-        cdata.add_constraint ("uint8");
         cdata.add_constraint (dim_vector (-1, -1, 3));
       }
   };
 
 private:
   properties xproperties;
 
 public:
diff --git a/libinterp/corefcn/oct-tex-lexer.in.ll b/libinterp/corefcn/oct-tex-lexer.in.ll
--- a/libinterp/corefcn/oct-tex-lexer.in.ll
+++ b/libinterp/corefcn/oct-tex-lexer.in.ll
@@ -25,23 +25,48 @@ along with Octave; see the file COPYING.
 %option reentrant
 %option bison-bridge
 
 %top {
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "txt-eng.h"
-#include "oct-tex-parser.h"
 }
 
 %x	NUM_MODE
 %x	MAYBE_NUM_MODE
 
+%{
+
+// The generated code may include unistd.h.  We need that to happen
+// before defining isatty to be prefixed with the gnulib namespace
+// identifier.
+
+#include <sys/types.h>
+#include <unistd.h>
+
+#include "txt-eng.h"
+#include "oct-tex-parser.h"
+
+#if defined (GNULIB_NAMESPACE)
+// Calls to the following functions appear in the generated output from
+// flex without the namespace tag.  Redefine them so we will use them
+// via the gnulib namespace.
+#define fprintf GNULIB_NAMESPACE::fprintf
+#define fread GNULIB_NAMESPACE::fread
+#define fwrite GNULIB_NAMESPACE::fwrite
+#define getc GNULIB_NAMESPACE::getc
+#define isatty GNULIB_NAMESPACE::isatty
+#define malloc GNULIB_NAMESPACE::malloc
+#define realloc GNULIB_NAMESPACE::realloc
+#endif
+
+%}
+
 D       [0-9]
 NUM	(({D}+\.?{D}*)|(\.{D}+))
 
 %%
 
 %{
 // Numeric values
 %}
diff --git a/libinterp/corefcn/oct-tex-parser.yy b/libinterp/corefcn/oct-tex-parser.yy
--- a/libinterp/corefcn/oct-tex-parser.yy
+++ b/libinterp/corefcn/oct-tex-parser.yy
@@ -28,16 +28,25 @@ along with Octave; see the file COPYING.
 #endif
 
 #include "txt-eng.h"
 #include "oct-tex-parser.h"
 
 extern int octave_tex_lex (YYSTYPE *, void *);
 static void yyerror (text_parser_tex& parser, const char *s);
 
+#if defined (GNULIB_NAMESPACE)
+// Calls to the following functions appear in the generated output from
+// Bison without the namespace tag.  Redefine them so we will use them
+// via the gnulib namespace.
+#define fclose GNULIB_NAMESPACE::fclose
+#define fprintf GNULIB_NAMESPACE::fprintf
+#define malloc GNULIB_NAMESPACE::malloc
+#endif
+
 #define scanner parser.get_scanner ()
 %}
 
 %name-prefix="octave_tex_"
 %define api.pure
 %parse-param { text_parser_tex& parser } 
 %lex-param { void *scanner }
 
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -405,17 +405,19 @@ urlwrite (\"http://www.google.com/search
       error ("urlwrite: unable to open file");
       return retval;
     }
 
   unwind_protect_safe frame;
 
   frame.add_fcn (delete_file, filename);
 
-  url_transfer curl = url_transfer (url, method, param, ofile);
+  url_transfer curl = url_transfer (url, ofile);
+
+  curl.http_action (param, method);
 
   ofile.close ();
 
   if (curl.good ())
     frame.discard ();
 
   if (nargout > 0)
     {
@@ -530,17 +532,19 @@ s = urlread (\"http://www.google.com/sea
         {
           error ("urlread: number of elements in PARAM must be even");
           return retval;
         }
     }
 
   std::ostringstream buf;
 
-  url_transfer curl = url_transfer (url, method, param, buf);
+  url_transfer curl = url_transfer (url, buf);
+
+  curl.http_action (param, method);
 
   if (curl.good ())
     {
       if (nargout > 0)
         {
           // Return empty string if no error occured.
           retval(2) = curl.good () ? "" : curl.lasterror ();
           retval(1) = curl.good ();
diff --git a/libinterp/octave-value/ov-str-mat.cc b/libinterp/octave-value/ov-str-mat.cc
--- a/libinterp/octave-value/ov-str-mat.cc
+++ b/libinterp/octave-value/ov-str-mat.cc
@@ -671,34 +671,34 @@ octave_char_matrix_str::load_hdf5 (hid_t
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       return true;
     }
   else
     {
       // This is cruft for backward compatiability and easy data
       // importation
-      if (rank == 0)
+      if (rank == 0) //FIXME: Does rank==0 even exist for strings in HDF5?
         {
           // a single string:
           int slen = H5Tget_size (type_hid);
           if (slen < 0)
             {
               H5Tclose (type_hid);
               H5Sclose (space_hid);
               H5Dclose (data_hid);
               return false;
             }
           else
             {
               OCTAVE_LOCAL_BUFFER (char, s, slen);
               // create datatype for (null-terminated) string
               // to read into:
               hid_t st_id = H5Tcopy (H5T_C_S1);
-              H5Tset_size (st_id, slen);
+              H5Tset_size (st_id, slen+1);
               if (H5Dread (data_hid, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT, s) < 0)
                 {
                   H5Tclose (st_id);
                   H5Tclose (type_hid);
                   H5Sclose (space_hid);
                   H5Dclose (data_hid);
                   return false;
                 }
@@ -726,36 +726,36 @@ octave_char_matrix_str::load_hdf5 (hid_t
               return false;
             }
           else
             {
               // hdf5 string arrays store strings of all the
               // same physical length (I think), which is
               // slightly wasteful, but oh well.
 
-              OCTAVE_LOCAL_BUFFER (char, s, elements * slen);
+              OCTAVE_LOCAL_BUFFER (char, s, elements * (slen+1));
 
               // create datatype for (null-terminated) string
               // to read into:
               hid_t st_id = H5Tcopy (H5T_C_S1);
-              H5Tset_size (st_id, slen);
+              H5Tset_size (st_id, slen+1);
 
               if (H5Dread (data_hid, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT, s) < 0)
                 {
                   H5Tclose (st_id);
                   H5Tclose (type_hid);
                   H5Sclose (space_hid);
                   H5Dclose (data_hid);
                   return false;
                 }
 
-              charMatrix chm (elements, slen - 1);
+              charMatrix chm (elements, slen, ' ');
               for (hsize_t i = 0; i < elements; ++i)
                 {
-                  chm.insert (s + i*slen, i, 0);
+                  chm.insert (s + i*(slen+1), i, 0);
                 }
 
               matrix = chm;
 
               H5Tclose (st_id);
               H5Tclose (type_hid);
               H5Sclose (space_hid);
               H5Dclose (data_hid);
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -795,21 +795,27 @@ octave_user_function::bind_automatic_var
 
 void
 octave_user_function::restore_warning_states (void)
 {
   octave_value val = symbol_table::varval (".saved_warning_states.");
 
   if (val.is_defined ())
     {
-      octave_map m = val.map_value ();
+      // Don't use the usual approach of attempting to extract a value
+      // and then checking error_state since this code might be
+      // executing when error_state is already set.  But do fail
+      // spectacularly if .saved_warning_states. is not an octave_map
+      // (or octave_scalar_map) object.
 
-      if (error_state)
+      if (! val.is_map ())
         panic_impossible ();
 
+      octave_map m = val.map_value ();
+
       Cell ids = m.contents ("identifier");
       Cell states = m.contents ("state");
 
       for (octave_idx_type i = 0; i < m.numel (); i++)
         Fwarning (ovl (states(i), ids(i)));
     }
 }
 
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -255,17 +255,17 @@ make_statement (T *arg)
 %type <sep_type> sep_no_nl opt_sep_no_nl nl opt_nl sep opt_sep
 %type <tree_type> input
 %type <tree_constant_type> string constant magic_colon
 %type <tree_anon_fcn_handle_type> anon_fcn_handle
 %type <tree_fcn_handle_type> fcn_handle
 %type <tree_matrix_type> matrix_rows
 %type <tree_cell_type> cell_rows
 %type <tree_expression_type> matrix cell
-%type <tree_expression_type> primary_expr oper_expr
+%type <tree_expression_type> primary_expr oper_expr power_expr
 %type <tree_expression_type> simple_expr colon_expr assign_expr expression
 %type <tree_identifier_type> identifier fcn_name magic_tilde
 %type <tree_funcall_type> superclass_identifier meta_identifier
 %type <octave_user_function_type> function1 function2
 %type <tree_index_expression_type> word_list_cmd
 %type <tree_colon_expression_type> colon_expr1
 %type <tree_argument_list_type> arg_list word_list assign_lhs
 %type <tree_argument_list_type> cell_or_matrix_row
@@ -316,16 +316,23 @@ make_statement (T *arg)
 %left ':'
 %left '-' '+' EPLUS EMINUS
 %left '*' '/' LEFTDIV EMUL EDIV ELEFTDIV
 %right UNARY EXPR_NOT
 %left POW EPOW HERMITIAN TRANSPOSE
 %right PLUS_PLUS MINUS_MINUS
 %left '(' '.' '{'
 
+// How to clean up if there is a parse error.  We handle deleting tokens
+// and comments seperately and separators are just characters.  The
+// remaining items are dynamically allocated parse tree objects that
+// must be deleted.
+%destructor { } <sep_type> <tok_val> <comment_type> <dummy_type> <>
+%destructor { delete $$; } <*>
+
 // Where to start.
 %start input
 
 %%
 
 // ==============================
 // Statements and statement lists
 // ==============================
@@ -388,17 +395,20 @@ statement       : expression
 // These are not really like expressions since they can't appear on
 // the RHS of an assignment.  But they are also not like commands (IF,
 // WHILE, etc.
 
 word_list_cmd   : identifier word_list
                   {
                     $$ = parser.make_index_expression ($1, $2, '(');
                     if (! $$)
-                      ABORT_PARSE;
+                      {
+                        // make_index_expression deleted $1 and $2.
+                        ABORT_PARSE;
+                      }
                   }
                 ;
 
 word_list       : string
                   { $$ = new tree_argument_list ($1); }
                 | word_list string
                   {
                     $1->append ($2);
@@ -593,35 +603,47 @@ oper_expr       : primary_expr
                 | oper_expr PLUS_PLUS
                   { $$ = parser.make_postfix_op (PLUS_PLUS, $1, $2); }
                 | oper_expr MINUS_MINUS
                   { $$ = parser.make_postfix_op (MINUS_MINUS, $1, $2); }
                 | oper_expr '(' ')'
                   {
                     $$ = parser.make_index_expression ($1, 0, '(');
                     if (! $$)
-                      ABORT_PARSE;
+                      {
+                        // make_index_expression deleted $1.
+                        ABORT_PARSE;
+                      }
                   }
                 | oper_expr '(' arg_list ')'
                   {
                     $$ = parser.make_index_expression ($1, $3, '(');
                     if (! $$)
-                      ABORT_PARSE;
+                      {
+                        // make_index_expression deleted $1 and $3.
+                        ABORT_PARSE;
+                      }
                   }
                 | oper_expr '{' '}'
                   {
                     $$ = parser.make_index_expression ($1, 0, '{');
                     if (! $$)
-                      ABORT_PARSE;
+                      {
+                        // make_index_expression deleted $1.
+                        ABORT_PARSE;
+                      }
                   }
                 | oper_expr '{' arg_list '}'
                   {
                     $$ = parser.make_index_expression ($1, $3, '{');
                     if (! $$)
-                      ABORT_PARSE;
+                      {
+                        // make_index_expression deleted $1 and $3.
+                        ABORT_PARSE;
+                      }
                   }
                 | oper_expr HERMITIAN
                   { $$ = parser.make_postfix_op (HERMITIAN, $1, $2); }
                 | oper_expr TRANSPOSE
                   { $$ = parser.make_postfix_op (TRANSPOSE, $1, $2); }
                 | oper_expr indirect_ref_op STRUCT_ELT
                   { $$ = parser.make_indirect_ref ($1, $3->text ()); }
                 | oper_expr indirect_ref_op '(' expression ')'
@@ -631,19 +653,19 @@ oper_expr       : primary_expr
                 | MINUS_MINUS oper_expr %prec UNARY
                   { $$ = parser.make_prefix_op (MINUS_MINUS, $2, $1); }
                 | EXPR_NOT oper_expr %prec UNARY
                   { $$ = parser.make_prefix_op (EXPR_NOT, $2, $1); }
                 | '+' oper_expr %prec UNARY
                   { $$ = parser.make_prefix_op ('+', $2, $1); }
                 | '-' oper_expr %prec UNARY
                   { $$ = parser.make_prefix_op ('-', $2, $1); }
-                | oper_expr POW oper_expr
+                | oper_expr POW power_expr
                   { $$ = parser.make_binary_op (POW, $1, $2, $3); }
-                | oper_expr EPOW oper_expr
+                | oper_expr EPOW power_expr
                   { $$ = parser.make_binary_op (EPOW, $1, $2, $3); }
                 | oper_expr '+' oper_expr
                   { $$ = parser.make_binary_op ('+', $1, $2, $3); }
                 | oper_expr '-' oper_expr
                   { $$ = parser.make_binary_op ('-', $1, $2, $3); }
                 | oper_expr '*' oper_expr
                   { $$ = parser.make_binary_op ('*', $1, $2, $3); }
                 | oper_expr '/' oper_expr
@@ -657,26 +679,88 @@ oper_expr       : primary_expr
                 | oper_expr EDIV oper_expr
                   { $$ = parser.make_binary_op (EDIV, $1, $2, $3); }
                 | oper_expr LEFTDIV oper_expr
                   { $$ = parser.make_binary_op (LEFTDIV, $1, $2, $3); }
                 | oper_expr ELEFTDIV oper_expr
                   { $$ = parser.make_binary_op (ELEFTDIV, $1, $2, $3); }
                 ;
 
+power_expr      : primary_expr
+                  { $$ = $1; }
+                | power_expr PLUS_PLUS
+                  { $$ = parser.make_postfix_op (PLUS_PLUS, $1, $2); }
+                | power_expr MINUS_MINUS
+                  { $$ = parser.make_postfix_op (MINUS_MINUS, $1, $2); }
+                | power_expr '(' ')'
+                  {
+                    $$ = parser.make_index_expression ($1, 0, '(');
+                    if (! $$)
+                      {
+                        // make_index_expression deleted $1.
+                        ABORT_PARSE;
+                      }
+                  }
+                | power_expr '(' arg_list ')'
+                  {
+                    $$ = parser.make_index_expression ($1, $3, '(');
+                    if (! $$)
+                      {
+                        // make_index_expression deleted $1 and $3.
+                        ABORT_PARSE;
+                      }
+                  }
+                | power_expr '{' '}'
+                  {
+                    $$ = parser.make_index_expression ($1, 0, '{');
+                    if (! $$)
+                      {
+                        // make_index_expression deleted $1.
+                        ABORT_PARSE;
+                      }
+                  }
+                | power_expr '{' arg_list '}'
+                  {
+                    $$ = parser.make_index_expression ($1, $3, '{');
+                    if (! $$)
+                      {
+                        // make_index_expression deleted $1 and $3.
+                        ABORT_PARSE;
+                      }
+                  }
+                | power_expr indirect_ref_op STRUCT_ELT
+                  { $$ = parser.make_indirect_ref ($1, $3->text ()); }
+                | power_expr indirect_ref_op '(' expression ')'
+                  { $$ = parser.make_indirect_ref ($1, $4); }
+                | PLUS_PLUS power_expr %prec POW
+                  { $$ = parser.make_prefix_op (PLUS_PLUS, $2, $1); }
+                | MINUS_MINUS power_expr %prec POW
+                  { $$ = parser.make_prefix_op (MINUS_MINUS, $2, $1); }
+                | EXPR_NOT power_expr %prec POW
+                  { $$ = parser.make_prefix_op (EXPR_NOT, $2, $1); }
+                | '+' power_expr %prec POW
+                  { $$ = parser.make_prefix_op ('+', $2, $1); }
+                | '-' power_expr %prec POW
+                  { $$ = parser.make_prefix_op ('-', $2, $1); }
+                ;
+
 colon_expr      : colon_expr1
                   { $$ = parser.finish_colon_expression ($1); }
                 ;
 
 colon_expr1     : oper_expr
                   { $$ = new tree_colon_expression ($1); }
                 | colon_expr1 ':' oper_expr
                   {
                     if (! ($$ = $1->append ($3)))
-                      ABORT_PARSE;
+                      {
+                        delete $1;
+                        delete $3;
+                        ABORT_PARSE;
+                      }
                   }
                 ;
 
 simple_expr     : colon_expr
                   { $$ = $1; }
                 | simple_expr LSHIFT simple_expr
                   { $$ = parser.make_binary_op (LSHIFT, $1, $2, $3); }
                 | simple_expr RSHIFT simple_expr
@@ -839,17 +923,20 @@ select_command  : if_command
 
 // ============
 // If statement
 // ============
 
 if_command      : IF stash_comment if_cmd_list END
                   {
                     if (! ($$ = parser.finish_if_command ($1, $3, $4, $2)))
-                      ABORT_PARSE;
+                      {
+                        // finish_if_command deleted $3.
+                        ABORT_PARSE;
+                      }
                   }
                 ;
 
 if_cmd_list     : if_cmd_list1
                   { $$ = $1; }
                 | if_cmd_list1 else_clause
                   {
                     $1->append ($2);
@@ -884,17 +971,20 @@ else_clause     : ELSE stash_comment opt
 
 // ================
 // Switch statement
 // ================
 
 switch_command  : SWITCH stash_comment expression opt_sep case_list END
                   {
                     if (! ($$ = parser.finish_switch_command ($1, $3, $5, $6, $2)))
-                      ABORT_PARSE;
+                      {
+                        // finish_switch_command deleted $3 adn $5.
+                        ABORT_PARSE;
+                      }
                   }
                 ;
 
 case_list       : // empty
                   { $$ = new tree_switch_case_list (); }
                 | default_case
                   { $$ = new tree_switch_case_list ($1); }
                 | case_list1
@@ -929,90 +1019,104 @@ default_case    : OTHERWISE stash_commen
 // Looping
 // =======
 
 loop_command    : WHILE stash_comment expression stmt_begin opt_sep opt_list END
                   {
                     $3->mark_braindead_shortcircuit (lexer.fcn_file_full_name);
 
                     if (! ($$ = parser.make_while_command ($1, $3, $6, $7, $2)))
-                      ABORT_PARSE;
+                      {
+                        // make_while_command deleted $3 and $6.
+                        ABORT_PARSE;
+                      }
                   }
                 | DO stash_comment opt_sep opt_list UNTIL expression
                   {
-                    if (! ($$ = parser.make_do_until_command ($5, $4, $6, $2)))
-                      ABORT_PARSE;
+                    $$ = parser.make_do_until_command ($5, $4, $6, $2);
                   }
                 | FOR stash_comment assign_lhs '=' expression stmt_begin opt_sep opt_list END
                   {
                     if (! ($$ = parser.make_for_command (FOR, $1, $3, $5, 0,
-                                                  $8, $9, $2)))
-                      ABORT_PARSE;
+                                                         $8, $9, $2)))
+                      {
+                        // make_for_command deleted $3, $5, and $8.
+                        ABORT_PARSE;
+                      }
                   }
                 | FOR stash_comment '(' assign_lhs '=' expression ')' opt_sep opt_list END
                   {
                     if (! ($$ = parser.make_for_command (FOR, $1, $4, $6, 0,
-                                                  $9, $10, $2)))
-                      ABORT_PARSE;
+                                                         $9, $10, $2)))
+                      {
+                        // make_for_command deleted $4, $6, and $9.
+                        ABORT_PARSE;
+                      }
                   }
                 | PARFOR stash_comment assign_lhs '=' expression stmt_begin opt_sep opt_list END
                   {
                     if (! ($$ = parser.make_for_command (PARFOR, $1, $3, $5,
-                                                  0, $8, $9, $2)))
-                      ABORT_PARSE;
+                                                         0, $8, $9, $2)))
+                      {
+                        // make_for_command deleted $3, $5, and $8.
+                        ABORT_PARSE;
+                      }
                   }
                 | PARFOR stash_comment '(' assign_lhs '=' expression ',' expression ')' opt_sep opt_list END
                   {
                     if (! ($$ = parser.make_for_command (PARFOR, $1, $4, $6,
-                                                  $8, $11, $12, $2)))
-                      ABORT_PARSE;
+                                                         $8, $11, $12, $2)))
+                      {
+                        // make_for_command deleted $4, $6, $8, and $11.
+                        ABORT_PARSE;
+                      }
                   }
                 ;
 
 // =======
 // Jumping
 // =======
 
 jump_command    : BREAK
-                  {
-                    if (! ($$ = parser.make_break_command ($1)))
-                      ABORT_PARSE;
-                  }
+                  { $$ = parser.make_break_command ($1); }
                 | CONTINUE
-                  {
-                    if (! ($$ = parser.make_continue_command ($1)))
-                      ABORT_PARSE;
-                  }
+                  { $$ = parser.make_continue_command ($1); }
                 | FUNC_RET
-                  {
-                    if (! ($$ = parser.make_return_command ($1)))
-                      ABORT_PARSE;
-                  }
+                  { $$ = parser.make_return_command ($1); }
                 ;
 
 // ==========
 // Exceptions
 // ==========
 
 except_command  : UNWIND stash_comment opt_sep opt_list CLEANUP
                   stash_comment opt_sep opt_list END
                   {
                     if (! ($$ = parser.make_unwind_command ($1, $4, $8, $9, $2, $6)))
-                      ABORT_PARSE;
+                      {
+                        // make_unwind_command deleted $4 and $8.
+                        ABORT_PARSE;
+                      }
                   }
                 | TRY stash_comment opt_sep opt_list CATCH stash_comment
                   opt_sep opt_list END
                   {
                     if (! ($$ = parser.make_try_command ($1, $4, $7, $8, $9, $2, $6)))
-                      ABORT_PARSE;
+                      {
+                        // make_try_command deleted $4 and $8.
+                        ABORT_PARSE;
+                      }
                   }
                 | TRY stash_comment opt_sep opt_list END
                   {
                     if (! ($$ = parser.make_try_command ($1, $4, 0, 0, $5, $2, 0)))
-                      ABORT_PARSE;
+                      {
+                        // make_try_command deleted $4.
+                        ABORT_PARSE;
+                      }
                   }
                 ;
 
 // ===========================================
 // Some 'subroutines' for function definitions
 // ===========================================
 
 push_fcn_symtab : // empty
@@ -1084,17 +1188,20 @@ param_list1     : // empty
                   {
                     $1->mark_as_formal_parameters ();
                     if ($1->validate (tree_parameter_list::in))
                       {
                         lexer.mark_as_variables ($1->variable_names ());
                         $$ = $1;
                       }
                     else
-                      ABORT_PARSE;
+                      {
+                        delete $1;
+                        ABORT_PARSE;
+                      }
                   }
                 ;
 
 param_list2     : param_list_elt
                   { $$ = new tree_parameter_list ($1); }
                 | param_list2 ',' param_list_elt
                   {
                     $1->append ($3);
@@ -1126,29 +1233,35 @@ return_list     : '[' ']'
 
                     // Even though this parameter list can contain only
                     // a single identifier, we still need to validate it
                     // to check for varargin or varargout.
 
                     if (tmp->validate (tree_parameter_list::out))
                       $$ = tmp;
                     else
-                      ABORT_PARSE;
+                      {
+                        delete tmp;
+                        ABORT_PARSE;
+                      }
                   }
                 | '[' return_list1 ']'
                   {
                     lexer.looking_at_return_list = false;
 
                     // Check for duplicate parameter names, varargin,
                     // or varargout.
 
                     if ($2->validate (tree_parameter_list::out))
                       $$ = $2;
                     else
-                      ABORT_PARSE;
+                      {
+                        delete $2;
+                        ABORT_PARSE;
+                      }
                   }
                 ;
 
 return_list1    : identifier
                   { $$ = new tree_parameter_list (new tree_decl_elt ($1)); }
                 | return_list1 ',' identifier
                   {
                     $1->append (new tree_decl_elt ($3));
@@ -1157,17 +1270,27 @@ return_list1    : identifier
                 ;
 
 // =======================
 // Script or function file
 // =======================
 
 file            : INPUT_FILE opt_nl opt_list END_OF_INPUT
                   {
-                    if (! lexer.reading_fcn_file)
+                    if (lexer.reading_fcn_file)
+                      {
+                        // Delete the dummy statement_list we created
+                        // after parsing the function.  Any function
+                        // definitions found in the file have already
+                        // been stored in the symbol table or in
+                        // octave_base_parser::primary_fcn_ptr.
+
+                        delete $3;
+                      }
+                    else
                       {
                         tree_statement *end_of_script
                           = parser.make_end ("endscript", true,
                                              lexer.input_line_number,
                                              lexer.current_input_column);
 
                         parser.make_script ($3, end_of_script);
                       }
@@ -1241,18 +1364,17 @@ function1       : fcn_name function2
 
                     delete $1;
 
                     if (lexer.parsing_classdef_get_method)
                       fname.insert (0, "get.");
                     else if (lexer.parsing_classdef_set_method)
                       fname.insert (0, "set.");
 
-                    if (! ($$ = parser.frob_function (fname, $2)))
-                      ABORT_PARSE;
+                    $$ = parser.frob_function (fname, $2);
                   }
                 ;
 
 function2       : param_list opt_sep opt_list function_end
                   { $$ = parser.start_function ($1, $3, $4); }
                 | opt_sep opt_list function_end
                   { $$ = parser.start_function (0, $2, $3); }
                 ;
@@ -2276,16 +2398,21 @@ octave_base_parser::make_unwind_command 
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       int l = unwind_tok->line ();
       int c = unwind_tok->column ();
 
       retval = new tree_unwind_protect_command (body, cleanup_stmts,
                                                 lc, mc, tc, l, c);
     }
+  else
+    {
+      delete body;
+      delete cleanup_stmts;
+    }
 
   return retval;
 }
 
 // Build a try-catch command.
 
 tree_command *
 octave_base_parser::make_try_command (token *try_tok,
@@ -2322,16 +2449,21 @@ octave_base_parser::make_try_command (to
                   cleanup_stmts->pop_front ();
                 }
             }
         }
 
       retval = new tree_try_catch_command (body, cleanup_stmts, id,
                                            lc, mc, tc, l, c);
     }
+  else
+    {
+      delete body;
+      delete cleanup_stmts;
+    }
 
   return retval;
 }
 
 // Build a while command.
 
 tree_command *
 octave_base_parser::make_while_command (token *while_tok,
@@ -2350,42 +2482,43 @@ octave_base_parser::make_while_command (
 
       lexer.looping--;
 
       int l = while_tok->line ();
       int c = while_tok->column ();
 
       retval = new tree_while_command (expr, body, lc, tc, l, c);
     }
+  else
+    {
+      delete expr;
+      delete body;
+    }
 
   return retval;
 }
 
 // Build a do-until command.
 
 tree_command *
 octave_base_parser::make_do_until_command (token *until_tok,
                                            tree_statement_list *body,
                                            tree_expression *expr,
                                            octave_comment_list *lc)
 {
-  tree_command *retval = 0;
-
   maybe_warn_assign_as_truth_value (expr);
 
   octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
   lexer.looping--;
 
   int l = until_tok->line ();
   int c = until_tok->column ();
 
-  retval = new tree_do_until_command (expr, body, lc, tc, l, c);
-
-  return retval;
+  return new tree_do_until_command (expr, body, lc, tc, l, c);
 }
 
 // Build a for command.
 
 tree_command *
 octave_base_parser::make_for_command (int tok_id, token *for_tok,
                                       tree_argument_list *lhs,
                                       tree_expression *expr,
@@ -2420,63 +2553,58 @@ octave_base_parser::make_for_command (in
         {
           if (parfor)
             bison_error ("invalid syntax for parfor statement");
           else
             retval = new tree_complex_for_command (lhs, expr, body,
                                                    lc, tc, l, c);
         }
     }
+  else
+    {
+      delete lhs;
+      delete expr;
+      delete maxproc;
+      delete body;
+    }
 
   return retval;
 }
 
 // Build a break command.
 
 tree_command *
 octave_base_parser::make_break_command (token *break_tok)
 {
-  tree_command *retval = 0;
-
   int l = break_tok->line ();
   int c = break_tok->column ();
 
-  retval = new tree_break_command (l, c);
-
-  return retval;
+  return new tree_break_command (l, c);
 }
 
 // Build a continue command.
 
 tree_command *
 octave_base_parser::make_continue_command (token *continue_tok)
 {
-  tree_command *retval = 0;
-
   int l = continue_tok->line ();
   int c = continue_tok->column ();
 
-  retval = new tree_continue_command (l, c);
-
-  return retval;
+  return new tree_continue_command (l, c);
 }
 
 // Build a return command.
 
 tree_command *
 octave_base_parser::make_return_command (token *return_tok)
 {
-  tree_command *retval = 0;
-
   int l = return_tok->line ();
   int c = return_tok->column ();
 
-  retval = new tree_return_command (l, c);
-
-  return retval;
+  return new tree_return_command (l, c);
 }
 
 // Start an if command.
 
 tree_if_command_list *
 octave_base_parser::start_if_command (tree_expression *expr,
                                       tree_statement_list *list)
 {
@@ -2512,16 +2640,18 @@ octave_base_parser::finish_if_command (t
             {
               elt->line (l);
               elt->column (c);
             }
         }
 
       retval = new tree_if_command (list, lc, tc, l, c);
     }
+  else
+    delete list;
 
   return retval;
 }
 
 // Build an elseif clause.
 
 tree_if_clause *
 octave_base_parser::make_elseif_clause (token *elseif_tok,
@@ -2563,16 +2693,21 @@ octave_base_parser::finish_switch_comman
             {
               elt->line (l);
               elt->column (c);
             }
         }
 
       retval = new tree_switch_command (expr, list, lc, tc, l, c);
     }
+  else
+    {
+      delete expr;
+      delete list;
+    }
 
   return retval;
 }
 
 // Build a switch case.
 
 tree_switch_case *
 octave_base_parser::make_switch_case (token *case_tok,
@@ -3111,16 +3246,20 @@ octave_base_parser::make_index_expressio
                                            tree_argument_list *args,
                                            char type)
 {
   tree_index_expression *retval = 0;
 
   if (args && args->has_magic_tilde ())
     {
       bison_error ("invalid use of empty argument (~) in index expression");
+
+      delete expr;
+      delete args;
+
       return retval;
     }
 
   int l = expr->line ();
   int c = expr->column ();
 
   if (! expr->is_postfix_indexed ()) 
     expr->set_postfix_index (type);
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -1455,45 +1455,84 @@ Array<T>::delete_elements (int dim, cons
         }
     }
 }
 
 template <class T>
 void
 Array<T>::delete_elements (const Array<idx_vector>& ia)
 {
-  if (ia.length () == 1)
+  int ial = ia.length ();
+
+  if (ial == 1)
     delete_elements (ia(0));
   else
     {
-      int len = ia.length (), k, dim = -1;
-      for (k = 0; k < len; k++)
+      int k, dim = -1;
+      for (k = 0; k < ial; k++)
         {
           if (! ia(k).is_colon ())
             {
               if (dim < 0)
                 dim = k;
               else
                 break;
             }
         }
       if (dim < 0)
         {
           dim_vector dv = dimensions;
           dv(0) = 0;
           *this = Array<T> (dv);
         }
-      else if (k == len)
+      else if (k == ial)
         {
           delete_elements (dim, ia(dim));
         }
       else
         {
-          (*current_liboctave_error_handler)
-            ("a null assignment can only have one non-colon index");
+          // Allow the null assignment to succeed if it won't change
+          // anything because the indices reference an empty slice,
+          // provided that there is at most one non-colon (or
+          // equivalent) index.  So, we still have the requirement of
+          // deleting a slice, but it is OK if the slice is empty.
+
+          // For compatibility with Matlab, stop checking once we see
+          // more than one non-colon index or an empty index.  Matlab
+          // considers "[]" to be an empty index but not "false".  We
+          // accept both.
+
+          bool empty_assignment = false;
+
+          int num_non_colon_indices = 0;
+
+          int nd = ndims ();
+
+          for (int i = 0; i < ial; i++)
+            {
+              octave_idx_type dim_len = i >= nd ? 1 : dimensions(i);
+
+              if (ia(i).length (dim_len) == 0)
+                {
+                  empty_assignment = true;
+                  break;
+                }
+
+              if (! ia(i).is_colon_equiv (dim_len))
+                {
+                  num_non_colon_indices++;
+
+                  if (num_non_colon_indices == 2)
+                    break;
+                }
+            }
+
+          if (! empty_assignment)
+            (*current_liboctave_error_handler)
+              ("a null assignment can only have one non-colon index");
         }
     }
 
 }
 
 template <class T>
 Array<T>&
 Array<T>::insert (const Array<T>& a, octave_idx_type r, octave_idx_type c)
diff --git a/liboctave/array/Sparse.cc b/liboctave/array/Sparse.cc
--- a/liboctave/array/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -1210,21 +1210,26 @@ Sparse<T>::delete_elements (const idx_ve
           copy_or_memcpy (nz - ubi, tmp.data () + ubi, xdata () + lbi);
           fill_or_memset (new_nz, static_cast<octave_idx_type> (0), ridx ());
           copy_or_memcpy (lb, tmp.cidx () + 1, cidx () + 1);
           mx_inline_sub (nc - ub, xcidx () + 1, tmp.cidx () + ub + 1, ubi - lbi);
         }
       else
         *this = index (idx.complement (nc));
     }
-  else
+  else if (idx.length (nel) != 0)
     {
-      *this = index (idx_vector::colon);
-      delete_elements (idx);
-      *this = transpose (); // We want a row vector.
+      if (idx.is_colon_equiv (nel))
+        *this = Sparse<T> ();
+      else
+        {
+          *this = index (idx_vector::colon);
+          delete_elements (idx);
+          *this = transpose (); // We want a row vector.
+        }
     }
 }
 
 template <class T>
 void
 Sparse<T>::delete_elements (const idx_vector& idx_i, const idx_vector& idx_j)
 {
   assert (ndims () == 2);
@@ -1319,18 +1324,31 @@ Sparse<T>::delete_elements (const idx_ve
           // This is done by transposing, deleting columns, then transposing
           // again.
           Sparse<T> tmp = transpose ();
           tmp.delete_elements (idx_j, idx_i);
           *this = tmp.transpose ();
         }
     }
   else
-    (*current_liboctave_error_handler)
-      ("a null assignment can only have one non-colon index");
+    {
+      // Empty assignment (no elements to delete) is OK if there is at
+      // least one zero-length index and at most one other index that is
+      // non-colon (or equivalent) index.  Since we only have two
+      // indices, we just need to check that we have at least one zero
+      // length index.  Matlab considers "[]" to be an empty index but
+      // not "false".  We accept both.
+
+      bool empty_assignment
+        = (idx_i.length (nr) == 0 || idx_j.length (nc) == 0);
+
+      if (! empty_assignment)
+        (*current_liboctave_error_handler)
+          ("a null assignment can only have one non-colon index");
+    }
 }
 
 template <class T>
 void
 Sparse<T>::delete_elements (int dim, const idx_vector& idx)
 {
   if (dim == 0)
     delete_elements (idx, idx_vector::colon);
diff --git a/liboctave/util/cmd-edit.cc b/liboctave/util/cmd-edit.cc
--- a/liboctave/util/cmd-edit.cc
+++ b/liboctave/util/cmd-edit.cc
@@ -1594,17 +1594,24 @@ command_editor::do_decode_prompt_string 
                 temp = octave_env::base_pathname (temp);
 
                 goto add_string;
               }
 
             case 'w':
             case 'W':
               {
-                temp = octave_env::get_current_directory ();
+                try
+                  {
+                    temp = octave_env::get_current_directory ();
+                  }
+                catch (octave_execution_exception)
+                  {
+                    temp = "";
+                  }
 
                 std::string home_dir = octave_env::get_home_directory ();
 
                 if (c == 'W' && (home_dir.empty () || temp != home_dir))
                   {
                     if (temp != "/" && temp != "//")
                       {
                         size_t pos = temp.rfind ('/');
diff --git a/liboctave/util/data-conv.cc b/liboctave/util/data-conv.cc
--- a/liboctave/util/data-conv.cc
+++ b/liboctave/util/data-conv.cc
@@ -622,23 +622,16 @@ oct_data_conv::data_type_as_string (oct_
 
 static void
 gripe_unrecognized_float_fmt (void)
 {
   (*current_liboctave_error_handler)
     ("unrecognized floating point format requested");
 }
 
-static void
-gripe_data_conversion (const char *from, const char *to)
-{
-  (*current_liboctave_error_handler)
-    ("unable to convert from %s to %s format", from, to);
-}
-
 // But first, some data conversion routines.
 
 // Currently, we only handle conversions for the IEEE types.  To fix
 // that, make more of the following routines work.
 
 // FIXME -- assumes sizeof (Complex) == 8
 // FIXME -- assumes sizeof (double) == 8
 // FIXME -- assumes sizeof (float) == 4
diff --git a/liboctave/util/lo-utils.cc b/liboctave/util/lo-utils.cc
--- a/liboctave/util/lo-utils.cc
+++ b/liboctave/util/lo-utils.cc
@@ -21,16 +21,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cctype>
+#include <cerrno>
 #include <cstdlib>
 #include <cstdio>
 #include <cstring>
 #include <cfloat>
 
 #include <limits>
 #include <string>
 
@@ -82,36 +83,22 @@ strsave (const char *s)
     return 0;
 
   int len = strlen (s);
   char *tmp = new char [len+1];
   tmp = strcpy (tmp, s);
   return tmp;
 }
 
-// This function was adapted from xputenv from Karl Berry's kpathsearch
-// library.
-
-// FIXME -- make this do the right thing if we don't have a
-// SMART_PUTENV.
-
 void
 octave_putenv (const std::string& name, const std::string& value)
 {
-  int new_len = name.length () + value.length () + 2;
-
-  char *new_item = static_cast<char*> (gnulib::malloc (new_len));
-
-  sprintf (new_item, "%s=%s", name.c_str (), value.c_str ());
-
-  // As far as I can see there's no way to distinguish between the
-  // various errors; putenv doesn't have errno values.
-
-  if (gnulib::putenv (new_item) < 0)
-    (*current_liboctave_error_handler) ("putenv (%s) failed", new_item);
+  if (gnulib::setenv (name.c_str (), value.c_str (), true) < 0)
+    (*current_liboctave_error_handler) ("putenv: %s",
+                                        gnulib::strerror (errno));
 }
 
 std::string
 octave_fgets (FILE *f)
 {
   bool eof;
   return octave_fgets (f, eof);
 }
diff --git a/liboctave/util/oct-base64.cc b/liboctave/util/oct-base64.cc
--- a/liboctave/util/oct-base64.cc
+++ b/liboctave/util/oct-base64.cc
@@ -77,14 +77,15 @@ octave_base64_decode (const std::string&
         (*current_liboctave_error_handler)
           ("base64_decode: incorrect input size");
       else
         {
           octave_idx_type len = (outlen * sizeof (char)) / sizeof (double);
           retval.resize (dim_vector (1, len));
           double *dout = reinterpret_cast<double*> (out);
           std::copy (dout, dout + len, retval.fortran_vec ());
+          ::free (out);
         }
     }
 
   return retval;
 }
 
diff --git a/liboctave/util/url-transfer.cc b/liboctave/util/url-transfer.cc
--- a/liboctave/util/url-transfer.cc
+++ b/liboctave/util/url-transfer.cc
@@ -40,17 +40,18 @@ along with Octave; see the file COPYING.
 #include "url-transfer.h"
 
 #ifdef HAVE_CURL
 #include <curl/curl.h>
 #include <curl/curlver.h>
 #include <curl/easy.h>
 #endif
 
-void base_url_transfer::delete_file (const std::string& file)
+void
+base_url_transfer::delete_file (const std::string& file)
 {
   octave_unlink (file);
 }
 
 void
 base_url_transfer::mget_directory (const std::string& directory,
                                    const std::string& target)
 {
@@ -204,16 +205,18 @@ base_url_transfer::mput_directory (const
         }
       else
         {
           ok = false;
           errmsg = "__ftp_mput__: can not read the directory '"
             + realdir + "'";
         }
     }
+
+  return file_list;
 }
 
 #if defined (HAVE_CURL)
 
 static int
 write_data (void *buffer, size_t size, size_t nmemb, void *streamp)
 {
   std::ostream& stream = *(static_cast<std::ostream*> (streamp));
@@ -268,86 +271,68 @@ throw_away (void *, size_t size, size_t 
     } \
   while (0)
 
 class curl_transfer : public base_url_transfer
 {
 public:
 
   curl_transfer (void)
-    : base_url_transfer (), curl (curl_easy_init ()), errnum ()
+    : base_url_transfer (), curl (curl_easy_init ()), errnum (), url (),
+      userpwd ()
   {
     if (curl)
       valid = true;
     else
       errmsg = "can not create curl object";
   }
 
-  curl_transfer (const std::string& host_arg, const std::string& user_arg,
+  curl_transfer (const std::string& host, const std::string& user_arg,
                  const std::string& passwd, std::ostream& os)
-    : base_url_transfer (host_arg, user_arg, passwd, os),
-      curl (curl_easy_init ()), errnum ()
+    : base_url_transfer (host, user_arg, passwd, os),
+      curl (curl_easy_init ()), errnum (), url (), userpwd ()
   {
     if (curl)
       valid = true;
     else
       {
         errmsg = "can not create curl object";
         return;
       }
 
     init (user_arg, passwd, std::cin, os);
 
-    std::string url ("ftp://" + host_arg);
+    url = "ftp://" + host;
     SETOPT (CURLOPT_URL, url.c_str ());
 
-    // Setup the link, with no transfer.
+    // Set up the link, with no transfer.
     perform ();
   }
 
-  curl_transfer (const std::string& url, const std::string& method,
-                 const Array<std::string>& param, std::ostream& os)
-    : base_url_transfer (url, method, param, os),
-      curl (curl_easy_init ()), errnum ()
+  curl_transfer (const std::string& url_str, std::ostream& os)
+    : base_url_transfer (url_str, os), curl (curl_easy_init ()), errnum (),
+      url (), userpwd ()
   {
     if (curl)
       valid = true;
     else
       {
         errmsg = "can not create curl object";
         return;
       }
 
     init ("", "", std::cin, os);
 
     SETOPT (CURLOPT_NOBODY, 0);
 
     // Restore the default HTTP request method to GET after setting
-    // NOBODY to true and back to false.  This is needed for backward
-    // compatibility with versions of libcurl < 7.18.2.
+    // NOBODY to true (in the init method) and back to false (above).
+    // This is needed for backward compatibility with versions of
+    // libcurl < 7.18.2.
     SETOPT (CURLOPT_HTTPGET, 1);
-
-    // Don't need to store the parameters here as we can't change
-    // the URL after the object is created
-    std::string query_string = form_query_string (param);
-
-    if (method == "get")
-      {
-        query_string = url + "?" + query_string;
-        SETOPT (CURLOPT_URL, query_string.c_str ());
-      }
-    else if (method == "post")
-      {
-        SETOPT (CURLOPT_URL, url.c_str ());
-        SETOPT (CURLOPT_POSTFIELDS, query_string.c_str ());
-      }
-    else
-      SETOPT (CURLOPT_URL, url.c_str ());
-
-    perform ();
   }
 
   ~curl_transfer (void)
   {
     if (curl)
       curl_easy_cleanup (curl);
   }
 
@@ -396,84 +381,32 @@ public:
   void binary (void)
   {
     ascii_mode = false;
     SETOPT (CURLOPT_TRANSFERTEXT, 0);
   }
 
   void cwd (const std::string& path)
   {
-    struct curl_slist *slist = 0;
-
-    unwind_protect frame;
-    frame.add_fcn (curl_slist_free_all, slist);
-
-    std::string cmd = "cwd " + path;
-    slist = curl_slist_append (slist, cmd.c_str ());
-    SETOPT (CURLOPT_POSTQUOTE, slist);
-
-    perform ();
-    if (! good ())
-      return;
-
-    SETOPT (CURLOPT_POSTQUOTE, 0);
+    ftp_file_or_dir_action (path, "cwd");
   }
 
   void del (const std::string& file)
   {
-    struct curl_slist *slist = 0;
-
-    unwind_protect frame;
-    frame.add_fcn (curl_slist_free_all, slist);
-
-    std::string cmd = "dele " + file;
-    slist = curl_slist_append (slist, cmd.c_str ());
-    SETOPT (CURLOPT_POSTQUOTE, slist);
-
-    perform ();
-    if (! good ())
-      return;
-
-    SETOPT (CURLOPT_POSTQUOTE, 0);
+    ftp_file_or_dir_action (file, "dele");
   }
 
   void rmdir (const std::string& path)
   {
-    struct curl_slist *slist = 0;
-
-    unwind_protect frame;
-    frame.add_fcn (curl_slist_free_all, slist);
-
-    std::string cmd = "rmd " + path;
-    slist = curl_slist_append (slist, cmd.c_str ());
-    SETOPT (CURLOPT_POSTQUOTE, slist);
-
-    perform ();
-    if (! good ())
-      return;
-
-    SETOPT (CURLOPT_POSTQUOTE, 0);
+    ftp_file_or_dir_action (path, "rmd");
   }
 
   void mkdir (const std::string& path)
   {
-    struct curl_slist *slist = 0;
-
-    unwind_protect frame;
-    frame.add_fcn (curl_slist_free_all, slist);
-
-    std::string cmd = "mkd " + path;
-    slist = curl_slist_append (slist, cmd.c_str ());
-    SETOPT (CURLOPT_POSTQUOTE, slist);
-
-    perform ();
-    if (! good ())
-      return;
-
-    SETOPT (CURLOPT_POSTQUOTE, 0);
+    ftp_file_or_dir_action (path, "mkd");
   }
 
   void rename (const std::string& oldname, const std::string& newname)
   {
     struct curl_slist *slist = 0;
 
     unwind_protect frame;
     frame.add_fcn (curl_slist_free_all, slist);
@@ -488,82 +421,82 @@ public:
     if (! good ())
       return;
 
     SETOPT (CURLOPT_POSTQUOTE, 0);
   }
 
   void put (const std::string& file, std::istream& is)
   {
-    std::string url = "ftp://" + host + "/" + file;
+    url = "ftp://" + host_or_url + "/" + file;
     SETOPT (CURLOPT_URL, url.c_str ());
     SETOPT (CURLOPT_UPLOAD, 1);
     SETOPT (CURLOPT_NOBODY, 0);
     std::istream& old_is = set_istream (is);
 
     perform ();
     if (! good ())
       return;
 
     set_istream (old_is);
     SETOPT (CURLOPT_NOBODY, 1);
     SETOPT (CURLOPT_UPLOAD, 0);
-    url = "ftp://" + host;
+    url = "ftp://" + host_or_url;
     SETOPT (CURLOPT_URL, url.c_str ());
   }
 
   void get (const std::string& file, std::ostream& os)
   {
-    std::string url = "ftp://" + host + "/" + file;
+    url = "ftp://" + host_or_url + "/" + file;
     SETOPT (CURLOPT_URL, url.c_str ());
     SETOPT (CURLOPT_NOBODY, 0);
     std::ostream& old_os = set_ostream (os);
 
     perform ();
     if (! good ())
       return;
 
     set_ostream (old_os);
     SETOPT (CURLOPT_NOBODY, 1);
-    url = "ftp://" + host;
+    url = "ftp://" + host_or_url;
     SETOPT (CURLOPT_URL, url.c_str ());
   }
 
   void dir (void)
   {
-    std::string url = "ftp://" + host + "/";
+    url = "ftp://" + host_or_url + "/";
     SETOPT (CURLOPT_URL, url.c_str ());
     SETOPT (CURLOPT_NOBODY, 0);
 
     perform ();
     if (! good ())
       return;
 
     SETOPT (CURLOPT_NOBODY, 1);
-    url = "ftp://" + host;
+    url = "ftp://" + host_or_url;
     SETOPT (CURLOPT_URL, url.c_str ());
   }
 
   string_vector list (void)
   {
     string_vector retval;
 
     std::ostringstream buf;
-    std::string url = "ftp://" + host + "/";
+    url = "ftp://" + host_or_url + "/";
     SETOPTR (CURLOPT_WRITEDATA, static_cast<void*> (&buf));
     SETOPTR (CURLOPT_URL, url.c_str ());
     SETOPTR (CURLOPT_DIRLISTONLY, 1);
     SETOPTR (CURLOPT_NOBODY, 0);
 
     perform ();
     if (! good ())
       return retval;
 
     SETOPTR (CURLOPT_NOBODY, 1);
-    url = "ftp://" + host;
+    url = "ftp://" + host_or_url;
     SETOPTR (CURLOPT_WRITEDATA, static_cast<void*> (curr_ostream));
     SETOPTR (CURLOPT_DIRLISTONLY, 0);
     SETOPTR (CURLOPT_URL, url.c_str ());
 
     // Count number of directory entries
     std::string str = buf.str ();
     octave_idx_type n = 0;
     size_t pos = 0;
@@ -590,17 +523,17 @@ public:
     return retval;
   }
 
   void get_fileinfo (const std::string& filename, double& filesize,
                      time_t& filetime, bool& fileisdir)
   {
     std::string path = pwd ();
 
-    std::string url = "ftp://" + host + "/" + path + "/" + filename;
+    url = "ftp://" + host_or_url + "/" + path + "/" + filename;
     SETOPT (CURLOPT_URL, url.c_str ());
     SETOPT (CURLOPT_FILETIME, 1);
     SETOPT (CURLOPT_HEADERFUNCTION, throw_away);
     SETOPT (CURLOPT_WRITEFUNCTION, throw_away);
 
     // FIXME
     // The MDTM command fails for a directory on the servers I tested
     // so this is a means of testing for directories. It also means
@@ -622,17 +555,17 @@ public:
     filetime = ft;
     double fs;
     curl_easy_getinfo (curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &fs);
     filesize = fs;
 
     SETOPT (CURLOPT_WRITEFUNCTION, write_data);
     SETOPT (CURLOPT_HEADERFUNCTION, 0);
     SETOPT (CURLOPT_FILETIME, 0);
-    url = "ftp://" + host;
+    url = "ftp://" + host_or_url;
     SETOPT (CURLOPT_URL, url.c_str ());
 
     // The MDTM command seems to reset the path to the root with the
     // servers I tested with, so cd again into the correct path. Make
     // the path absolute so that this will work even with servers that
     // don't end up in the root after an MDTM command.
     cwd ("/" + path);
   }
@@ -666,21 +599,78 @@ public:
 
     SETOPTR (CURLOPT_HEADERFUNCTION, 0);
     SETOPTR (CURLOPT_WRITEHEADER, 0);
     SETOPTR (CURLOPT_POSTQUOTE, 0);
 
     return retval;
   }
 
+  void http_get (const Array<std::string>& param)
+  {
+    url = host_or_url;
+
+    std::string query_string = form_query_string (param);
+
+    if (! query_string.empty ())
+      url += "?" + query_string;
+
+    SETOPT (CURLOPT_URL, url.c_str ());
+
+    perform ();
+  }
+
+  void http_post (const Array<std::string>& param)
+  {
+    SETOPT (CURLOPT_URL, host_or_url.c_str ());
+
+    std::string query_string = form_query_string (param);
+
+    SETOPT (CURLOPT_POSTFIELDS, query_string.c_str ());
+
+    perform ();
+  }
+
+  void http_action (const Array<std::string>& param, const std::string& action)
+  {
+    if (action.empty () || action == "get")
+      http_get (param);
+    else if (action == "post")
+      http_post (param);
+    else
+      {
+        ok = false;
+        errmsg = "curl_transfer: unknown http action";
+      }
+  }
+
 private:
 
+  // Pointer to cURL object.
   CURL *curl;
+
+  // cURL error code.
   CURLcode errnum;
 
+  // The cURL library changed the curl_easy_setopt call to make an
+  // internal copy of string parameters in version 7.17.0. Prior
+  // versions only held a pointer to a string provided by the caller
+  // that must persist for the lifetime of the CURL handle.
+  //
+  // The associated API did not change, only the behavior of the library
+  // implementing the function call.
+  //
+  // To be compatible with any version of cURL, the caller must keep a
+  // copy of all string parameters associated with a CURL handle until
+  // the handle is released. The curl_handle::curl_handle_rep class
+  // contains the pointer to the CURL handle and so is the best
+  // candidate for storing the strings as well. (bug #36717)
+  std::string url;
+  std::string userpwd;
+
   // No copying!
 
   curl_transfer (const curl_transfer&);
 
   curl_transfer& operator = (const curl_transfer&);
 
   void init (const std::string& user, const std::string& passwd,
              std::istream& is, std::ostream& os)
@@ -745,16 +735,39 @@ private:
         if (i < param.numel ()-1)
           query << "&";
       }
 
     query.flush ();
 
     return query.str ();
   }
+
+  void ftp_file_or_dir_action (const std::string& file_or_dir,
+                               const std::string& action)
+  {
+    struct curl_slist *slist = 0;
+
+    unwind_protect frame;
+
+    frame.add_fcn (curl_slist_free_all, slist);
+
+    std::string cmd = action + " " + file_or_dir;
+
+    slist = curl_slist_append (slist, cmd.c_str ());
+
+    SETOPT (CURLOPT_POSTQUOTE, slist);
+
+    perform ();
+
+    if (! good ())
+      return;
+
+    SETOPT (CURLOPT_POSTQUOTE, 0);
+  }
 };
 
 #undef SETOPT
 
 #else
 
 static void
 disabled_error (void)
@@ -782,18 +795,17 @@ url_transfer::url_transfer (const std::s
                             const std::string& passwd, std::ostream& os)
   : rep (new REP_CLASS (host, user, passwd, os))
 {
 #if !defined (HAVE_CURL)
   disabled_error ();
 #endif
 }
 
-url_transfer::url_transfer (const std::string& url, const std::string& method,
-                            const Array<std::string>& param, std::ostream& os)
-  : rep (new REP_CLASS (url, method, param, os))
+url_transfer::url_transfer (const std::string& url, std::ostream& os)
+  : rep (new REP_CLASS (url, os))
 {
 #if !defined (HAVE_CURL)
   disabled_error ();
 #endif
 }
 
 #undef REP_CLASS
diff --git a/liboctave/util/url-transfer.h b/liboctave/util/url-transfer.h
--- a/liboctave/util/url-transfer.h
+++ b/liboctave/util/url-transfer.h
@@ -42,34 +42,33 @@ private:
     curl_xfer->cwd ("..");
   }
 
 public:
 
   friend class url_transfer;
 
   base_url_transfer (void)
-    : count (1), host (), userpwd (), valid (false), ascii_mode (false),
-      ok (true), errmsg (), curr_istream (&std::cin), curr_ostream (&std::cout)
+    : count (1), host_or_url (), valid (false), ftp (false),
+      ascii_mode (false), ok (true), errmsg (),
+      curr_istream (&std::cin), curr_ostream (&std::cout)
   { }
 
-  base_url_transfer (const std::string& host_arg,
+  base_url_transfer (const std::string& host,
                      const std::string& /* user_arg */,
                      const std::string& /* passwd */,
                      std::ostream& os)
-    : count (1), host (host_arg), userpwd (), valid (false),
+    : count (1), host_or_url (host), valid (false), ftp (true),
       ascii_mode (false), ok (true), errmsg (), curr_istream (&std::cin),
       curr_ostream (&os) { }
 
-  base_url_transfer (const std::string& /* url */,
-                     const std::string& /* method */,
-                     const Array<std::string>& /* param */,
-                     std::ostream& os)
-    : count (1), host (), userpwd (), valid (false), ascii_mode (false),
-      ok (true), errmsg (), curr_istream (&std::cin), curr_ostream (&os) { }
+  base_url_transfer (const std::string& url, std::ostream& os)
+    : count (1), host_or_url (url), valid (false), ftp (false),
+      ascii_mode (false), ok (true), errmsg (),
+      curr_istream (&std::cin), curr_ostream (&os) { }
 
   virtual ~base_url_transfer (void) { }
 
   bool is_valid (void) const { return valid; }
 
   bool good (void) const { return valid && ok; }
 
   virtual void perform (void) { }
@@ -123,22 +122,32 @@ public:
 
   virtual void get_fileinfo (const std::string& /* filename */,
                              double& /* filesize */,
                              time_t& /* filetime */,
                              bool& /* fileisdir */) { }
 
   virtual std::string pwd (void) { return std::string (); }
 
+  virtual void http_get (const Array<std::string>& /* param */) { }
+
+  virtual void http_post (const Array<std::string>& /* param */) { }
+
+  virtual void http_action (const Array<std::string>& /* param */,
+                            const std::string& /* action */) { }
+
 protected:
 
+  // Reference count.
   octave_refcount<size_t> count;
-  std::string host;
-  std::string userpwd;
+
+  // Host for ftp transfers or full URL for http requests.
+  std::string host_or_url;
   bool valid;
+  bool ftp;
   bool ascii_mode;
   bool ok;
   std::string errmsg;
   std::istream *curr_istream;
   std::ostream *curr_ostream;
 
 private:
 
@@ -153,18 +162,17 @@ class url_transfer
 {
 public:
 
   url_transfer (void);
 
   url_transfer (const std::string& host, const std::string& user,
                 const std::string& passwd, std::ostream& os);
 
-  url_transfer (const std::string& url, const std::string& method,
-                const Array<std::string>& param, std::ostream& os);
+  url_transfer (const std::string& url, std::ostream& os);
 
   url_transfer (const url_transfer& h) : rep (h.rep)
   {
     rep->count++;
   }
 
   ~url_transfer (void)
   {
@@ -252,14 +260,24 @@ public:
   void get_fileinfo (const std::string& filename, double& filesize,
                      time_t& filetime, bool& fileisdir)
   {
     rep->get_fileinfo (filename, filesize, filetime, fileisdir);
   }
 
   std::string pwd (void) { return rep->pwd (); }
 
+  void http_get (const Array<std::string>& param) { rep->http_get (param); }
+
+  void http_post (const Array<std::string>& param) { rep->http_post (param); }
+
+  void http_action (const Array<std::string>& param,
+                    const std::string& action)
+  {
+    rep->http_action (param, action);
+  }
+
 private:
 
   base_url_transfer *rep;
 };
 
 #endif
diff --git a/m4/acinclude.m4 b/m4/acinclude.m4
--- a/m4/acinclude.m4
+++ b/m4/acinclude.m4
@@ -1462,25 +1462,25 @@ AC_DEFUN([OCTAVE_IEEE754_DATA_FORMAT], [
 dnl
 dnl Check for CallInst::addAttribute API
 dnl
 AC_DEFUN([OCTAVE_LLVM_CALLINST_ADDATTRIBUTE_API], [
   AC_CACHE_CHECK([check LLVM::CallInst::addAttribute arg type is llvm::Attributes],
     [octave_cv_callinst_addattribute_arg_is_attributes],
     [AC_LANG_PUSH(C++)
       AC_COMPILE_IFELSE(
-        [AC_LANG_PROGRAM([
+        [AC_LANG_PROGRAM([[
 #ifdef HAVE_LLVM_IR_FUNCTION_H
           #include <llvm/IR/Instructions.h>
           #include <llvm/IR/Attributes.h>
 #else
           #include <llvm/Instructions.h>
           #include <llvm/Attributes.h>
 #endif
-          ], [[
+          ]], [[
           llvm::CallInst *callinst;
           llvm::AttrBuilder attr_builder;
           attr_builder.addAttribute(llvm::Attributes::StructRet);
           llvm::Attributes attrs = llvm::Attributes::get(llvm::getGlobalContext(), attr_builder);
           callinst->addAttribute (1, attrs);
         ]])],
         octave_cv_callinst_addattribute_arg_is_attributes=yes,
         octave_cv_callinst_addattribute_arg_is_attributes=no)
@@ -1529,19 +1529,19 @@ dnl
 dnl Check for Function::addFnAttr API
 dnl
 AC_DEFUN([OCTAVE_LLVM_FUNCTION_ADDFNATTR_API], [
   AC_CACHE_CHECK([check LLVM::Function::addFnAttr arg type is llvm::Attributes],
     [octave_cv_function_addfnattr_arg_is_attributes],
     [AC_LANG_PUSH(C++)
       AC_COMPILE_IFELSE(
         [AC_LANG_PROGRAM([[
-#ifdef LLVM_HAVE_IR_FUNCTION_H
-          #include <llvm/Function.h>
-          #include <llvm/Attributes.h>
+#ifdef HAVE_LLVM_IR_FUNCTION_H
+          #include <llvm/IR/Function.h>
+          #include <llvm/IR/Attributes.h>
 #else
           #include <llvm/Function.h>
           #include <llvm/Attributes.h>
 #endif
           ]], [[
           llvm::Function *llvm_function;
           llvm_function->addFnAttr (llvm::Attributes::AlwaysInline);
         ]])],
diff --git a/scripts/general/cart2pol.m b/scripts/general/cart2pol.m
--- a/scripts/general/cart2pol.m
+++ b/scripts/general/cart2pol.m
@@ -14,49 +14,47 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{theta}, @var{r}] =} cart2pol (@var{x}, @var{y})
 ## @deftypefnx {Function File} {[@var{theta}, @var{r}, @var{z}] =} cart2pol (@var{x}, @var{y}, @var{z})
-## @deftypefnx {Function File} {[@var{theta}, @var{r}] =} cart2pol (@var{c})
-## @deftypefnx {Function File} {[@var{theta}, @var{r}, @var{z}] =} cart2pol (@var{c})
-## @deftypefnx {Function File} {@var{p} =} cart2pol (@dots{})
+## @deftypefnx {Function File} {[@var{theta}, @var{r}] =} cart2pol (@var{C})
+## @deftypefnx {Function File} {[@var{theta}, @var{r}, @var{z}] =} cart2pol (@var{C})
+## @deftypefnx {Function File} {@var{P} =} cart2pol (@dots{})
 ##
 ## Transform Cartesian to polar or cylindrical coordinates.
 ##
 ## @var{theta} describes the angle relative to the positive x-axis.
 ## @var{r} is the distance to the z-axis @w{(0, 0, z)}.
-## @var{x}, @var{y} (and @var{z}) must be the same shape, or scalar.
-## If called with a single matrix argument then each row of @var{c}
+## @var{x}, @var{y} (, and @var{z}) must be the same shape, or scalar.
+## If called with a single matrix argument then each row of @var{C}
 ## represents the Cartesian coordinate (@var{x}, @var{y} (, @var{z})).
 ##
 ## If only a single return argument is requested then return a matrix
-## @var{p} where each row represents one polar/(cylindrical) coordinate
+## @var{P} where each row represents one polar/(cylindrical) coordinate
 ## (@var{theta}, @var{phi} (, @var{z})).
 ## @seealso{pol2cart, cart2sph, sph2cart}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
-function [theta, r, z] = cart2pol (x, y, z)
+function [theta, r, z] = cart2pol (x, y, z = [])
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
   if (nargin == 1)
     if (ismatrix (x) && (columns (x) == 2 || columns (x) == 3))
       if (columns (x) == 3)
         z = x(:,3);
-      else
-        z = [];
       endif
       y = x(:,2);
       x = x(:,1);
     else
       error ("cart2pol: matrix input must have 2 or 3 columns [X, Y (, Z)]");
     endif
   elseif (nargin == 2)
     if (! ((ismatrix (x) && ismatrix (y))
@@ -71,35 +69,35 @@ function [theta, r, z] = cart2pol (x, y,
       error ("cart2pol: arguments must be matrices of same size, or scalar");
     endif
   endif
 
   theta = atan2 (y, x);
   r = sqrt (x .^ 2 + y .^ 2);
 
   if (nargout <= 1)
-    theta = [theta, r, z];
+    theta = [theta(:), r(:), z(:)];
   endif
 
 endfunction
 
 
 %!test
 %! x = [0, 1, 2];
 %! y = 0;
 %! [t, r] = cart2pol (x, y);
 %! assert (t, [0, 0, 0]);
 %! assert (r, x);
 
 %!test
 %! x = [0, 1, 2];
 %! y = [0, 1, 2];
-%! [t, r] = cart2pol (x, y);
-%! assert (t, [0, pi/4, pi/4], sqrt (eps));
-%! assert (r, sqrt (2)*[0, 1, 2], sqrt (eps));
+%! P = cart2pol (x, y);
+%! assert (P(:,1), [0; pi/4; pi/4], sqrt (eps));
+%! assert (P(:,2), sqrt (2)*[0; 1; 2], sqrt (eps));
 
 %!test
 %! x = [0, 1, 2];
 %! y = [0, 1, 2];
 %! z = [0, 1, 2];
 %! [t, r, z2] = cart2pol (x, y, z);
 %! assert (t, [0, pi/4, pi/4], sqrt (eps));
 %! assert (r, sqrt (2)*[0, 1, 2], sqrt (eps));
diff --git a/scripts/general/cart2sph.m b/scripts/general/cart2sph.m
--- a/scripts/general/cart2sph.m
+++ b/scripts/general/cart2sph.m
@@ -21,21 +21,21 @@
 ## @deftypefnx {Function File} {[@var{theta}, @var{phi}, @var{r}] =} cart2sph (@var{C})
 ## @deftypefnx {Function File} {@var{S} =} cart2sph (@dots{})
 ## Transform Cartesian to spherical coordinates.
 ##
 ## @var{theta} describes the angle relative to the positive x-axis.
 ## @var{phi} is the angle relative to the xy-plane.
 ## @var{r} is the distance to the origin @w{(0, 0, 0)}.
 ## @var{x}, @var{y}, and @var{z} must be the same shape, or scalar.
-## If called with a single matrix argument then each row of @var{c}
+## If called with a single matrix argument then each row of @var{C}
 ## represents the Cartesian coordinate (@var{x}, @var{y}, @var{z}).
 ##
 ## If only a single return argument is requested then return a matrix
-## @var{s} where each row represents one spherical coordinate
+## @var{S} where each row represents one spherical coordinate
 ## (@var{theta}, @var{phi}, @var{r}).
 ## @seealso{sph2cart, cart2pol, pol2cart}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
 function [theta, phi, r] = cart2sph (x, y, z)
@@ -61,17 +61,17 @@ function [theta, phi, r] = cart2sph (x, 
     endif
   endif
 
   theta = atan2 (y, x);
   phi = atan2 (z, sqrt (x .^ 2 + y .^ 2));
   r = sqrt (x .^ 2 + y .^ 2 + z .^ 2);
 
   if (nargout <= 1)
-    theta = [theta, phi, r];
+    theta = [theta(:), phi(:), r(:)];
   endif
 
 endfunction
 
 
 %!test
 %! x = [0, 1, 2];
 %! y = [0, 1, 2];
@@ -80,20 +80,20 @@ endfunction
 %! assert (t, [0, pi/4, pi/4], eps);
 %! assert (p, [0, 1, 1]*atan (sqrt (0.5)), eps);
 %! assert (r, [0, 1, 2]*sqrt (3), eps);
 
 %!test
 %! x = 0;
 %! y = [0, 1, 2];
 %! z = [0, 1, 2];
-%! [t, p, r] = cart2sph (x, y, z);
-%! assert (t, [0, 1, 1] * pi/2, eps);
-%! assert (p, [0, 1, 1] * pi/4, eps);
-%! assert (r, [0, 1, 2] * sqrt (2), eps);
+%! S = cart2sph (x, y, z);
+%! assert (S(:,1), [0; 1; 1] * pi/2, eps);
+%! assert (S(:,2), [0; 1; 1] * pi/4, eps);
+%! assert (S(:,3), [0; 1; 2] * sqrt (2), eps);
 
 %!test
 %! x = [0, 1, 2];
 %! y = 0;
 %! z = [0, 1, 2];
 %! [t, p, r] = cart2sph (x, y, z);
 %! assert (t, [0, 0, 0]);
 %! assert (p, [0, 1, 1] * pi/4);
diff --git a/scripts/general/pol2cart.m b/scripts/general/pol2cart.m
--- a/scripts/general/pol2cart.m
+++ b/scripts/general/pol2cart.m
@@ -14,48 +14,47 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{x}, @var{y}] =} pol2cart (@var{theta}, @var{r})
 ## @deftypefnx {Function File} {[@var{x}, @var{y}, @var{z}] =} pol2cart (@var{theta}, @var{r}, @var{z})
-## @deftypefnx {Function File} {[@var{x}, @var{y}] =} pol2cart (@var{p})
-## @deftypefnx {Function File} {[@var{x}, @var{y}, @var{z}] =} pol2cart (@var{p})
+## @deftypefnx {Function File} {[@var{x}, @var{y}] =} pol2cart (@var{P})
+## @deftypefnx {Function File} {[@var{x}, @var{y}, @var{z}] =} pol2cart (@var{P})
 ## @deftypefnx {Function File} {@var{C} =} pol2cart (@dots{})
 ## Transform polar or cylindrical to Cartesian coordinates.
 ##
 ## @var{theta}, @var{r}, (and @var{z}) must be the same shape, or scalar.
 ## @var{theta} describes the angle relative to the positive x-axis.
 ## @var{r} is the distance to the z-axis (0, 0, z).
-## If called with a single matrix argument then each row of @var{p}
-## represents the polar/(cylindrical) coordinate (@var{x}, @var{y} (, @var{z})).
+## If called with a single matrix argument then each row of @var{P}
+## represents the polar/(cylindrical) coordinate (@var{theta}, @var{r} (,
+## @var{z})).
 ##
 ## If only a single return argument is requested then return a matrix
 ## @var{C} where each row represents one Cartesian coordinate
 ## (@var{x}, @var{y} (, @var{z})).
 ## @seealso{cart2pol, sph2cart, cart2sph}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
-function [x, y, z] = pol2cart (theta, r, z)
+function [x, y, z] = pol2cart (theta, r, z = [])
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
   if (nargin == 1)
     if (ismatrix (theta) && (columns (theta) == 2 || columns (theta) == 3))
       if (columns (theta) == 3)
         z = theta(:,3);
-      else
-        z = [];
       endif
       r = theta(:,2);
       theta = theta(:,1);
     else
       error ("pol2cart: matrix input must have 2 or 3 columns [THETA, R (, Z)]");
     endif
   elseif (nargin == 2)
     if (! ((ismatrix (theta) && ismatrix (r))
@@ -70,35 +69,35 @@ function [x, y, z] = pol2cart (theta, r,
       error ("pol2cart: arguments must be matrices of same size, or scalar");
     endif
   endif
 
   x = r .* cos (theta);
   y = r .* sin (theta);
 
   if (nargout <= 1)
-    x  = [x, y, z];
+    x = [x(:), y(:), z(:)];
   endif
 
 endfunction
 
 
 %!test
 %! t = [0, 0.5, 1] * pi;
 %! r = 1;
 %! [x, y] = pol2cart (t, r);
 %! assert (x, [1, 0, -1], sqrt (eps));
 %! assert (y, [0, 1,  0], sqrt (eps));
 
 %!test
 %! t = [0, 1, 1] * pi/4;
 %! r = sqrt (2) * [0, 1, 2];
-%! [x, y] = pol2cart (t, r);
-%! assert (x, [0, 1, 2], sqrt (eps));
-%! assert (y, [0, 1, 2], sqrt (eps));
+%! C = pol2cart (t, r);
+%! assert (C(:,1), [0; 1; 2], sqrt (eps));
+%! assert (C(:,2), [0; 1; 2], sqrt (eps));
 
 %!test
 %! t = [0, 1, 1] * pi/4;
 %! r = sqrt (2) * [0, 1, 2];
 %! z = [0, 1, 2];
 %! [x, y, z2] = pol2cart (t, r, z);
 %! assert (x, [0, 1, 2], sqrt (eps));
 %! assert (y, [0, 1, 2], sqrt (eps));
diff --git a/scripts/general/sph2cart.m b/scripts/general/sph2cart.m
--- a/scripts/general/sph2cart.m
+++ b/scripts/general/sph2cart.m
@@ -14,24 +14,24 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{x}, @var{y}, @var{z}] =} sph2cart (@var{theta}, @var{phi}, @var{r})
 ## @deftypefnx {Function File} {[@var{x}, @var{y}, @var{z}] =} sph2cart (@var{S})
-## @deftypefnx {Function File} {C =} sph2cart (@dots{})
+## @deftypefnx {Function File} {@var{C} =} sph2cart (@dots{})
 ## Transform spherical to Cartesian coordinates.
 ##
 ## @var{theta} describes the angle relative to the positive x-axis.
 ## @var{phi} is the angle relative to the xy-plane.
 ## @var{r} is the distance to the origin @w{(0, 0, 0)}.
 ## @var{theta}, @var{phi}, and @var{r} must be the same shape, or scalar.
-## If called with a single matrix argument then each row of @var{s}
+## If called with a single matrix argument then each row of @var{S}
 ## represents the spherical coordinate (@var{theta}, @var{phi}, @var{r}).
 ##
 ## If only a single return argument is requested then return a matrix
 ## @var{C} where each row represents one Cartesian coordinate
 ## (@var{x}, @var{y}, @var{z}).
 ## @seealso{cart2sph, pol2cart, cart2pol}
 ## @end deftypefn
 
@@ -61,17 +61,17 @@ function [x, y, z] = sph2cart (theta, ph
     endif
   endif
 
   x = r .* cos (phi) .* cos (theta);
   y = r .* cos (phi) .* sin (theta);
   z = r .* sin (phi);
 
   if (nargout <= 1)
-    x = [x, y, z];
+    x = [x(:), y(:), z(:)];
   endif
 
 endfunction
 
 
 %!test
 %! t = [0, 0, 0];
 %! p = [0, 0, 0];
@@ -80,20 +80,20 @@ endfunction
 %! assert (x, r);
 %! assert (y, [0, 0, 0]);
 %! assert (z, [0, 0, 0]);
 
 %!test
 %! t = 0;
 %! p = [0, 0, 0];
 %! r = [0, 1, 2];
-%! [x, y, z] = sph2cart (t, p, r);
-%! assert (x, r);
-%! assert (y, [0, 0, 0]);
-%! assert (z, [0, 0, 0]);
+%! C = sph2cart (t, p, r);
+%! assert (C(:,1), r(:));
+%! assert (C(:,2), [0; 0; 0]);
+%! assert (C(:,3), [0; 0; 0]);
 
 %!test
 %! t = [0, 0, 0];
 %! p = 0;
 %! r = [0, 1, 2];
 %! [x, y, z] = sph2cart (t, p, r);
 %! assert (x, r);
 %! assert (y, [0, 0, 0]);
diff --git a/scripts/help/get_first_help_sentence.m b/scripts/help/get_first_help_sentence.m
--- a/scripts/help/get_first_help_sentence.m
+++ b/scripts/help/get_first_help_sentence.m
@@ -102,44 +102,38 @@ function [text, status] = first_sentence
   ## such as @deftypefn, @deftypefnx, @defvar, etc.
   keep = true (size (help_text));
   def_idx = strfind (help_text, "@def");
   if (! isempty (def_idx))
     endl_idx = find (help_text == "\n");
     for k = 1:length (def_idx)
       endl = endl_idx(find (endl_idx > def_idx(k), 1));
       if (isempty (endl))
-        keep(def_idx(k):end) = false;
-      else
-        keep(def_idx(k):endl) = false;
+        endl = numel (keep);
       endif
+      keep(def_idx(k):endl) = false;
     endfor
 
     ## Remove the @end ... that corresponds to the @def we removed above
     def1 = def_idx(1);
     space_idx = find (help_text == " ");
     space_idx = space_idx (find (space_idx > def1, 1));
     bracket_idx = find (help_text == "{" | help_text == "}");
     bracket_idx = bracket_idx (find (bracket_idx > def1, 1));
     if (isempty (space_idx) && isempty (bracket_idx))
       error ("get_first_help_sentence: couldn't parse texinfo");
     endif
     sep_idx = min (space_idx, bracket_idx);
     def_type = help_text(def1+1:sep_idx-1);
 
-    end_idx = strfind (help_text, sprintf ("@end %s", def_type));
+    end_idx = strfind (help_text, sprintf ("@end %s", def_type))(1);
     if (isempty (end_idx))
       error ("get_first_help_sentence: couldn't parse texinfo");
     endif
-    endl = endl_idx(find (endl_idx > end_idx, 1));
-    if (isempty (endl))
-      keep(end_idx:end) = false;
-    else
-      keep(end_idx:endl) = false;
-    endif
+    keep(end_idx:end) = false;
 
     help_text = help_text(keep);
   endif
 
   ## Run makeinfo to generate plain text
   [help_text, status] = __makeinfo__ (help_text, "plain text");
 
   ## Extract first line with plain text method.
diff --git a/scripts/image/image.m b/scripts/image/image.m
--- a/scripts/image/image.m
+++ b/scripts/image/image.m
@@ -116,22 +116,23 @@ function h = __img__ (hax, x, y, img, va
     y = [1, rows(img)];
   endif
 
   xdata = x([1, end]);
   ydata = y([1, end]);
 
   if (numel (x) > 2 && numel (y) > 2)
     ## Test data for non-linear spacing which is unsupported
-    ## FIXME: Need a better check on linearity
-    tol = 100*eps;
+    tol = .01;  # 1% tolerance.  FIXME: this value was chosen without thought.
     dx = diff (x);
+    dxmean = (max (x) - min (x)) / (numel (x) - 1);
+    dx = abs ((dx - dxmean) / dxmean);
     dy = diff (y);
-    dx = std (dx) / mean (abs (dx));
-    dy = std (dy) / mean (abs (dy));
+    dymean = (max (y) - min (y)) / (numel (y) - 1);
+    dy = abs ((dy - dymean) / dymean);
     if (any (dx > tol) || any (dy > tol))
       warning ("image: non-linear X, Y data is ignored.  IMG will be shown with linear mapping");
     endif
   endif
 
   htmp = __go_image__ (hax, "cdata", img, "xdata", xdata, "ydata", ydata,
                        "cdatamapping", "direct", varargin {:});
 
diff --git a/scripts/image/imformats.m b/scripts/image/imformats.m
--- a/scripts/image/imformats.m
+++ b/scripts/image/imformats.m
@@ -217,17 +217,16 @@ function formats = default_formats ()
             "ICO",  {"ico"},          true;
             "JBG",  {"jbg"},          false;
             "JBIG", {"jbig"},         false;
             "JP2",  {"jp2", "jpx"},   true;
             "JPEG", {"jpg", "jpeg"},  false; # there is also a JPG coder
             "PBM",  {"pbm"},          false;
             "PCX",  {"pcx"},          true;
             "PGM",  {"pgm"},          false;
-            "PGM",  {"pgm"},          false;
             "PNG",  {"png"},          true;
             ## PNM is a family of formats supporting portable bitmaps (PBM),
             ## graymaps (PGM), and pixmaps (PPM). There is no file format
             ## associated with pnm itself. If PNM is used as the output format
             ## specifier, then GraphicsMagick automatically selects the most
             ## appropriate format to represent the image.
             "PNM",  {"pnm"},          true;
             "PPM",  {"ppm"},          false;
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -224,18 +224,18 @@ function ret = edit (varargin)
       case "GET"
         if (isfield (FUNCTION, toupper (stateval)))
           ret = FUNCTION.(toupper (stateval));
         else
           ret = FUNCTION;
         endif
         return;
       otherwise
-        ## If none of the states match, assume both inputs are
-        ## actually both file names to be opened
+        ## If none of the states match, assume both inputs are actually
+        ## file names to be opened.
         editfilelist = varargin;
     endswitch
   elseif (nargin > 2)
     if (iscellstr (varargin))
       editfilelist = varargin;
     else
       error ("edit: if supplying more than one input all inputs must be strings containing field names to open.");
     endif
@@ -262,17 +262,17 @@ function ret = edit (varargin)
     ## Call edit on each of the files in the list if there are more than 1
     for i = 1:numel (editfilelist)
       edit (editfilelist{i});
     endfor
 
   else
   
     ## Only one file name was supplied, get it from the cell array
-    file = editfilelist{1};
+    file = tilde_expand (editfilelist{1});
 
     ## Check whether the user is trying to edit a builtin or compiled function.
     switch (exist (file))
       case {3, 5}
         error ("edit: unable to edit a built-in or compiled function");
     endswitch
 
     ## Checks for whether the file is
@@ -295,30 +295,30 @@ function ret = edit (varargin)
 
     ## Create list of explicit and implicit file names.
     filelist = {file};
     ## If file has no extension, add file.m and file.cc to the list.
     idx = rindex (file, ".");
     if (idx == 0)
       if (isempty (regexp (file, '\.m$')))
         ## No ".m" at the end of the file, add to the list.
-        filelist{end+1} = [file ".m"];
+        filelist(end+1) = [file ".m"];
       endif
       if (isempty (regexp (file, '\.cc$')))
         ## No ".cc" at the end of the file, add to the list.
-        filelist{end+1} = [file ".cc"];
+        filelist(end+1) = [file ".cc"];
       endif
     endif
 
     ## If the file includes a path, it may be an overloaded function.
-    if (! strcmp (file, "@") && index (file, filesep))
+    if (! index (file, "@") && index (file, filesep))
       ## No "@" at the beginning of the file, add to the list.
       numfiles = numel (filelist);
       for n = 1:numfiles
-        filelist{n+numfiles} = ["@" filelist{n}];
+        filelist(n+numfiles) = ["@" filelist{n}];
       endfor
     endif
 
     ## Search the entire path for the 1st instance of a file in the list.
     fileandpath = "";
     for n = 1:numel (filelist)
       filetoedit = file_in_path (path, filelist{n});
       if (! isempty (filetoedit))
@@ -348,17 +348,17 @@ function ret = edit (varargin)
         else
           fclose (fid);
         endif
         do_edit (FUNCTION.EDITOR, fileandpath, FUNCTION.MODE);
         return;
       endif
     endif
 
-    ## If editing a new file that is neither a m-file or an oct-file,
+    ## If editing a new file that is neither an m-file or an oct-file,
     ## just edit it.
     fileandpath = file;
     idx = rindex (file, ".");
     name = file(1:idx-1);
     ext = file(idx+1:end);
     if (! any (strcmp (ext, {"cc", "m"})))
       ## Some unknown file.  Just open it up.
       do_edit (FUNCTION.EDITOR, fileandpath, FUNCTION.MODE);
diff --git a/scripts/miscellaneous/mkoctfile.m b/scripts/miscellaneous/mkoctfile.m
--- a/scripts/miscellaneous/mkoctfile.m
+++ b/scripts/miscellaneous/mkoctfile.m
@@ -138,18 +138,19 @@
 ## @end example
 ##
 ## @end table
 ## @end deftypefn
 
 function [output, status] = mkoctfile (varargin)
 
   bindir = octave_config_info ("bindir");
+  ext = octave_config_info ("EXEEXT");
 
-  shell_script = fullfile (bindir, sprintf ("mkoctfile-%s", OCTAVE_VERSION));
+  shell_script = fullfile (bindir, sprintf ("mkoctfile-%s%s", OCTAVE_VERSION, ext));
 
   if (! exist (shell_script, "file"))
     __gripe_missing_component__ ("mkoctfile", "mkoctfile");
   endif
 
   cmd = ['"' shell_script '"'];
   for i = 1:nargin
     cmd = [cmd ' "' varargin{i} '"'];
diff --git a/scripts/miscellaneous/orderfields.m b/scripts/miscellaneous/orderfields.m
--- a/scripts/miscellaneous/orderfields.m
+++ b/scripts/miscellaneous/orderfields.m
@@ -14,29 +14,28 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{t}, @var{p}] =} orderfields (@var{s1})
 ## @deftypefnx {Function File} {[@var{t}, @var{p}] =} orderfields (@var{s1}, @var{s2})
-## Return a copy of @var{s1} with fields arranged alphabetically or
-## as specified by @var{s2}.
+## Return a copy of @var{s1} with fields arranged alphabetically or as
+## specified by @var{s2}.
 ##
 ## Given one struct, arrange field names in @var{s1} alphabetically.
 ##
-## If the second argument is a struct, arrange field names in @var{s1}
-## as they appear in @var{s2}.  The second argument may also specify the
-## order in a permutation vector or a cell array of strings containing
-## the fieldnames of @var{s1} in the desired order.
+## If the second argument is a struct, arrange field names in @var{s1} as they
+## appear in @var{s2}.  The second argument may also specify the order in a
+## permutation vector or a cell array of strings containing the fieldnames of
+## @var{s1} in the desired order.
 ##
 ## The optional second output argument @var{p} is assigned the permutation
-## vector
-## which converts the original name order into the new name order.
+## vector which converts the original name order into the new name order.
 ##
 ## Examples:
 ##
 ## @example
 ## @group
 ## s = struct ("d", 4, "b", 2, "a", 1, "c", 3);
 ## t1 = orderfields (s)
 ##      @result{} t1 =
@@ -90,33 +89,33 @@
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 ## Adapted-By: jwe
 
 function [t, p] = orderfields (s1, s2)
 
   if (nargin == 1 || nargin == 2)
     if (! isstruct (s1))
-      error ("orderfields: expecting argument to be a struct");
+      error ("orderfields: S1 must be a struct");
     endif
   else
     print_usage ();
   endif
 
   if (nargin == 1)
     ## One structure: return the fields in alphabetical order.
     if (isstruct (s1))
       names = sort (fieldnames (s1));
     endif
   elseif (nargin == 2)
     if (isstruct (s2))
       ## Two structures: return the fields in the order of s2.
       names = fieldnames (s2);
       if (! isequal (sort (fieldnames (s1)), sort (names)))
-        error ("orderfields: structures do not have same fields");
+        error ("orderfields: structures do not have the same fields");
       endif
     elseif (iscellstr (s2))
       ## A structure and a list of fields: order by the list of fields.
       t1 = sort (fieldnames (s1));
       t2 = sort (s2(:));
       if (! isequal (t1, t2))
         error ("orderfields: name list does not match structure fields");
       endif
@@ -125,27 +124,33 @@ function [t, p] = orderfields (s1, s2)
       ## A structure and a permutation vector: permute the order of s1.
       names = fieldnames (s1);
       t1 = sort (s2);
       t1 = t1(:)';
       t2 = 1:numel (names);
       if (! isequal (t1, t2))
         error ("orderfields: invalid permutation vector");
       endif
-      names = names (s2);
+      names = names(s2);
     endif
   endif
 
+  ## Corner case of empty struct
+  if (isempty (names))
+    t = struct ();
+    p = [];
+  endif
+
   ## Find permutation vector which converts the original name order
   ## into the new name order.  Note: could save a couple of sorts
   ## in some cases, but performance isn't critical.
 
   if (nargout == 2)
-    [oldel, oldidx] = sort (fieldnames (s1));
-    [newel, newidx] = sort (names);
+    [~, oldidx] = sort (fieldnames (s1));
+    [~, newidx] = sort (names);
     p = oldidx(newidx);
   endif
 
   ## Permute the names in the structure.
   if (numel (s1) == 0)
     args = cell (1, 2 * numel (names));
     args(1:2:end) = names;
     args(2:2:end) = {[]};
@@ -190,8 +195,11 @@ endfunction
 %! aa.y = 3;
 %! aa(2).x = {4, 5};
 %! bb.y = {6, 7};
 %! bb.x = 8;
 %! aa(2) = orderfields (bb, aa);
 %! assert (aa(2).x, 8);
 %! assert (aa(2).y{1}, 6);
 
+## Corner case of empty struct, bug #40224
+%!assert (orderfields (struct ()), struct ())
+
diff --git a/scripts/pkg/private/configure_make.m b/scripts/pkg/private/configure_make.m
--- a/scripts/pkg/private/configure_make.m
+++ b/scripts/pkg/private/configure_make.m
@@ -23,19 +23,20 @@
 ## @end deftypefn
 
 function configure_make (desc, packdir, verbose)
   ## Perform ./configure, make, make install in "src".
   if (exist (fullfile (packdir, "src"), "dir"))
     src = fullfile (packdir, "src");
     octave_bindir = octave_config_info ("bindir");
     ver = version ();
-    mkoctfile_program = fullfile (octave_bindir, sprintf ("mkoctfile-%s", ver));
-    octave_config_program = fullfile (octave_bindir, sprintf ("octave-config-%s", ver));
-    octave_binary = fullfile (octave_bindir, sprintf ("octave-%s", ver));
+    ext = octave_config_info ("EXEEXT");
+    mkoctfile_program = fullfile (octave_bindir, sprintf ("mkoctfile-%s%s", ver, ext));
+    octave_config_program = fullfile (octave_bindir, sprintf ("octave-config-%s%s", ver, ext));
+    octave_binary = fullfile (octave_bindir, sprintf ("octave-%s%s", ver, ext));
     cenv = {"MKOCTFILE"; mkoctfile_program;
             "OCTAVE_CONFIG"; octave_config_program;
             "OCTAVE"; octave_binary;
             "INSTALLDIR"; desc.dir};
     scenv = sprintf ("%s=\"%s\" ", cenv{:});
 
     if (! exist (mkoctfile_program, "file"))
       __gripe_missing_component__ ("pkg", "mkoctfile");
diff --git a/scripts/plot/appearance/daspect.m b/scripts/plot/appearance/daspect.m
--- a/scripts/plot/appearance/daspect.m
+++ b/scripts/plot/appearance/daspect.m
@@ -22,17 +22,17 @@
 ## @deftypefnx {Function File} {} daspect (@var{mode})
 ## @deftypefnx {Function File} {@var{data_aspect_ratio_mode} =} daspect ("mode")
 ## @deftypefnx {Function File} {} daspect (@var{hax}, @dots{})
 ## Query or set the data aspect ratio of the current axes.
 ##
 ## The aspect ratio is a normalized 3-element vector representing the span of
 ## the x, y, and z-axis limits.
 ## 
-## @code{(daspect (@var{mode}))}
+## @code{daspect (@var{mode})}
 ##
 ## Set the data aspect ratio mode of the current axes.  @var{mode} is
 ## either @qcode{"auto"} or @qcode{"manual"}.
 ## 
 ## @code{daspect (@qcode{"mode"})}
 ##
 ## Return the data aspect ratio mode of the current axes.
 ## 
@@ -64,17 +64,17 @@ function daratio = daspect (varargin)
   if (nargin > 1)
     print_usage ();
   endif
 
   if (nargin == 0)
     daratio = get (hax, "dataaspectratio");
   else
     arg = varargin{1};
-    if (isreal (arg))
+    if (isnumeric (arg))
       if (numel (arg) == 2)
         set (hax, "dataaspectratio", [arg, 1]);
       elseif (numel (arg) == 3)
         set (hax, "dataaspectratio", arg);
       else
         error ("daspect: DATA_ASPECT_RATIO must be a 2 or 3 element vector");
       endif
     elseif (ischar (arg))
diff --git a/scripts/plot/appearance/pbaspect.m b/scripts/plot/appearance/pbaspect.m
--- a/scripts/plot/appearance/pbaspect.m
+++ b/scripts/plot/appearance/pbaspect.m
@@ -65,17 +65,17 @@ function pbratio = pbaspect (varargin)
   if (nargin > 1)
     print_usage ();
   endif
 
   if (nargin == 0)
     pbratio = get (hax, "plotboxaspectratio");
   else
     arg = varargin{1};
-    if (isreal (arg))
+    if (isnumeric (arg))
       if (numel (arg) == 2)
         set (hax, "plotboxaspectratio", [arg, 1]);
       elseif (numel (arg) == 3)
         set (hax, "plotboxaspectratio", arg);
       else
         error ("pbaspect: PLOT_BOX_ASPECT_RATIO must be a 2 or 3 element vector");
       endif
     elseif (ischar (arg))
diff --git a/scripts/plot/draw/fill.m b/scripts/plot/draw/fill.m
--- a/scripts/plot/draw/fill.m
+++ b/scripts/plot/draw/fill.m
@@ -67,94 +67,92 @@
 
 function h = fill (varargin)
 
   [hax, varargin] = __plt_get_axis_arg__ ("fill", varargin{:});
 
   hlist = [];
   iargs = __find_patches__ (varargin{:});
 
+  opts = {};
+  if (numel (varargin) > iargs(end) + 2)
+    opts = varargin(iargs(end)+3 : end);
+  endif
+  
+  if (! all (cellfun (@(x) iscolorspec (x), varargin(iargs + 2))))
+    print_usage ();
+  endif
+
   oldfig = [];
   if (! isempty (hax))
     oldfig = get (0, "currentfigure");
   endif
   unwind_protect
     hax = newplot (hax);
     old_nxtplt = get (hax, "nextplot");
-    set (hax, "nextplot", "add");
+    unwind_protect
+      set (hax, "nextplot", "add");
+
+      for i = 1 : length (iargs)
+        cdata = varargin{iargs(i) + 2};
+
+        ## Matlab uses flat/interp shading based on orientation of cdata.
+        if (isnumeric (cdata) && isrow (cdata))
+          popt = ["facecolor", "flat", opts];
+        else
+          popt = opts;
+        endif
 
-    for i = 1 : length (iargs)
-      if (i == length (iargs))
-        args = varargin(iargs(i):end);
-      else
-        args = varargin(iargs(i):iargs(i+1)-1);
+        [htmp, fail] = __patch__ (hax, varargin{iargs(i)+(0:1)}, cdata,
+                                       popt{:});
+        if (fail)
+          print_usage ();
+        endif
+        
+        hlist(end+1, 1) = htmp;
+      endfor
+
+    unwind_protect_cleanup
+      if (strcmp (old_nxtplt, "replace"))
+        set (hax, "nextplot", old_nxtplt);
       endif
-      [htmp, fail] = __patch__ (hax, args{:});
-      if (fail)
-        print_usage ();
-      endif
-      hlist(end + 1, 1) = htmp;
-    endfor
-
-    if (strcmp (old_nxtplt, "replace"))
-      set (hax, "nextplot", old_nxtplt);
-    endif
+    end_unwind_protect
 
   unwind_protect_cleanup
     if (! isempty (oldfig))
       set (0, "currentfigure", oldfig);
     endif
   end_unwind_protect
 
   if (nargout > 0)
     h = hlist;
   endif
 
 endfunction
 
 function iargs = __find_patches__ (varargin)
-  iargs = [];
-  i = 1;
-  while (i < nargin)
-    iargs(end + 1) = i;
-    if (ischar (varargin{i})
-        && (strcmpi (varargin{i}, "faces")
-            || strcmpi (varargin{i}, "vertices")))
-      i += 4;
-    elseif (isnumeric (varargin{i}))
-      i += 2;
-    endif
+  iargs = 1:3:nargin;
+  optidx = find (! cellfun (@isnumeric, varargin(iargs)), 1);
+  iargs(optidx:end) = [];
+endfunction
 
-    if (i <= nargin)
-      while (true);
-        if (ischar (varargin{i})
-            && (strcmpi (varargin{i}, "faces")
-                || strcmpi (varargin{i}, "vertices")))
-          break;
-        elseif (isnumeric (varargin{i}))
-          ## Assume its the colorspec
-          i++;
-          break;
-        elseif (ischar (varargin{i}))
-          colspec = tolower (varargin{i});
-          collen = length (colspec);
-          if (any (strncmp (colspec, 
-                            {"blue", "black", "k", "red", "green", ...
-                             "yellow", "magenta", "cyan", "white"},
-                            collen)))
-            i++;
-            break;
-          endif
-        else
-          i += 2;
-        endif
-      endwhile
+function retval = iscolorspec (arg)
+  retval = false;
+  if (ischar (arg))
+    persistent colors = {"y", "yellow", "r", "red", "m", "magenta", ...
+                         "c", "cyan", "g", "green", "b", "blue", ...
+                         "w", "white", "k", "black"};
+    if (any (strcmpi (arg, colors)))
+      retval = true;
     endif
-  endwhile
-
+  elseif (isnumeric (arg))
+    ## Assume any numeric argument is correctly formatted cdata.
+    ## Let patch worry about the multple different input formats
+    retval = true;
+  endif
 endfunction
 
 
 %!demo
 %! clf;
 %! t1 = (1/16:1/8:1) * 2*pi;
 %! t2 = ((1/16:1/8:1) + 1/32) * 2*pi;
 %! x1 = sin (t1) - 0.8;
diff --git a/scripts/plot/draw/isosurface.m b/scripts/plot/draw/isosurface.m
--- a/scripts/plot/draw/isosurface.m
+++ b/scripts/plot/draw/isosurface.m
@@ -169,18 +169,17 @@ function varargout = isosurface (varargi
         pa = patch ("Faces", fvc.faces, "Vertices", fvc.vertices,
                     "FaceVertexCData", fvc.facevertexcdata,
                     "FaceColor", "flat", "EdgeColor", "none");
       else
         pa = patch ("Faces", fvc.faces, "Vertices", fvc.vertices,
                     "FaceColor", "g", "EdgeColor", "k");
       endif
       if (! ishold ())
-        set (hax, "view", [-37.5, 30],
-                  "xgrid", "on", "ygrid", "on", "zgrid", "on");
+        set (hax, "view", [-37.5, 30], "box", "off");
       endif
     case 1
       varargout = {fvc};
     case 2
       varargout = {fvc.faces, fvc.vertices};
     case 3
       varargout = {fvc.faces, fvc.vertices, fvc.facevertexcdata};
     otherwise
@@ -190,16 +189,17 @@ function varargout = isosurface (varargi
 endfunction
 
 
 %!demo
 %! clf;
 %! [x,y,z] = meshgrid (-2:0.5:2, -2:0.5:2, -2:0.5:2);
 %! v = x.^2 + y.^2 + z.^2;
 %! isosurface (x, y, z, v, 1);
+%! axis equal;
 %! title ('isosurface of a sphere');
 
 %!shared x, y, z, val
 %! [x, y, z]  = meshgrid (0:1, 0:1, 0:1); # Points for single
 %! val        = [0, 0; 0, 0];             # cube and a 3-D
 %! val(:,:,2) = [0, 0; 1, 0];             # array of values
 
 %!test
diff --git a/scripts/plot/draw/pcolor.m b/scripts/plot/draw/pcolor.m
--- a/scripts/plot/draw/pcolor.m
+++ b/scripts/plot/draw/pcolor.m
@@ -58,17 +58,18 @@
 
 function h = pcolor (varargin)
 
   [hax, varargin, nargin] = __plt_get_axis_arg__ ("pcolor", varargin{:});
 
   if (nargin == 1)
     c = varargin{1};
     [nr, nc] = size (c);
-    [x, y] = meshgrid (1:nc, 1:nr);
+    x = 1:nc;
+    y = 1:nr;
     z = zeros (nr, nc);
   elseif (nargin == 3)
     x = varargin{1};
     y = varargin{2};
     c = varargin{3};
     z = zeros (size (c));
   else
     print_usage ();
@@ -80,16 +81,46 @@ function h = pcolor (varargin)
   endif
   unwind_protect
     hax = newplot (hax);
     htmp = surface (x, y, z, c);
 
     set (htmp, "facecolor", "flat");
     if (! ishold ())
       set (hax, "view", [0, 90], "box", "on");
+      ## FIXME: Maybe this should be in the general axis limit setting routine?
+      ##        When values are integers (such as from meshgrid), we want to
+      ##        use tight limits for pcolor, mesh, surf, etc.  Situation is
+      ##        complicated immensely by vector or matrix input and meshgrid()
+      ##        or ndgrid() format.
+      meshgrid_fmt = true;
+      if (isvector (x))
+        xrng = x(isfinite (x));
+      else
+        xrng = x(1, isfinite (x(1,:)));    # meshgrid format (default)
+        if (all (xrng == xrng(1)))
+          xrng = x(isfinite (x(:,1)), 1);  # ndgrid format
+          meshgrid_fmt = false;
+        endif
+      endif
+      if (isvector (y))
+        yrng = y(isfinite (y));
+      else
+        if (meshgrid_fmt)
+          yrng = y(isfinite (y(:,1)), 1);
+        else
+          yrng = y(1, isfinite (y(1,:)));
+        endif
+      endif
+      if (all (xrng == fix (xrng)))
+        xlim ([min(xrng), max(xrng)]);
+      endif
+      if (all (yrng == fix (yrng)))
+        ylim ([min(yrng), max(yrng)]);
+      endif
     endif
 
   unwind_protect_cleanup
     if (! isempty (oldfig))
       set (0, "currentfigure", oldfig);
     endif
   end_unwind_protect
 
diff --git a/scripts/plot/draw/private/__errcomm__.m b/scripts/plot/draw/private/__errcomm__.m
--- a/scripts/plot/draw/private/__errcomm__.m
+++ b/scripts/plot/draw/private/__errcomm__.m
@@ -53,17 +53,18 @@ function retval = __errcomm__ (caller, h
         break;
       endif
       if (! ismatrix (arg))
         error ("%s: data argument %d must be numeric", caller, k-1);
       endif
       if (isvector (arg))
         arg = arg(:);
       endif
-      if (any (size (arg) != sz))
+      if (! isscalar (arg) && ((isvector (arg) && numel (arg) != prod (sz))
+          || any (size (arg) != sz)))
         error ("%s: size of argument %d does not match others", caller, k-1);
       endif
       data{++ndata} = arg;
       if (ndata > 6)
         error ("%s: too many arguments to plot", caller);
       endif
     endwhile
   endwhile
diff --git a/scripts/plot/draw/rectangle.m b/scripts/plot/draw/rectangle.m
--- a/scripts/plot/draw/rectangle.m
+++ b/scripts/plot/draw/rectangle.m
@@ -19,17 +19,16 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} rectangle ()
 ## @deftypefnx {Function File} {} rectangle (@dots{}, "Position", @var{pos})
 ## @deftypefnx {Function File} {} rectangle (@dots{}, "Curvature", @var{curv})
 ## @deftypefnx {Function File} {} rectangle (@dots{}, "EdgeColor", @var{ec})
 ## @deftypefnx {Function File} {} rectangle (@dots{}, "FaceColor", @var{fc})
 ## @deftypefnx {Function File} {} rectangle (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} rectangle (@dots{})
-##
 ## Draw a rectangular patch defined by @var{pos} and @var{curv}.
 ## 
 ## The variable @code{@var{pos}(1:2)} defines the lower left-hand corner of
 ## the patch and @code{@var{pos}(3:4)} defines its width and height.  By
 ## default, the value of @var{pos} is @code{[0, 0, 1, 1]}.
 ##
 ## The variable @var{curv} defines the curvature of the sides of the rectangle
 ## and may be a scalar or two-element vector with values between 0 and 1.
@@ -38,17 +37,17 @@
 ## If @var{curv} is a two-element vector, then the first element is the
 ## curvature along the x-axis of the patch and the second along y-axis.
 ##
 ## If @var{curv} is a scalar, it represents the curvature of the shorter of the
 ## two sides of the rectangle and the curvature of the other side is defined
 ## by
 ##
 ## @example
-## min (pos (1:2)) / max (pos (1:2)) * curv
+## min (pos(1:2)) / max (pos(1:2)) * curv
 ## @end example
 ##
 ## Additional property/value pairs are passed to the underlying patch command. 
 ## 
 ## If the first argument @var{hax} is an axes handle, then plot into this axis,
 ## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a graphics handle to the created
@@ -88,24 +87,24 @@ function hg = __rectangle__ (hax, vararg
   fc = "none";
 
   while (iarg < length (varargin))
     arg = varargin{iarg};
     if (ischar (arg))
       if (strcmpi (arg, "position"))
         pos = varargin{iarg+1};
         varargin(iarg:iarg+1) = [];
-        if (!isvector (pos) || numel (pos) != 4)
+        if (! isvector (pos) || numel (pos) != 4)
           error ("rectangle: position must be a 4 element vector");
         endif
       elseif (strcmpi (arg, "curvature"))
         curv2 = varargin{iarg+1};
         varargin(iarg:iarg+1) = [];
         if (!isnumeric (curv2) || (numel (curv2) != 1 && numel (curv2) != 2))
-          error ("rectangle: curvature must be a 2 element vector or a scalar");
+          error ("rectangle: curvature must be a 2-element vector or a scalar");
         endif
         if (any (curv2 < 0) || any (curv2 > 1))
           error ("rectangle: curvature values must be between 0 and 1");
         endif
       elseif (strcmpi (arg, "edgecolor"))
         ec = varargin{iarg+1};
         varargin(iarg:iarg+1) = [];
       elseif (strcmpi (arg, "facecolor"))
@@ -115,45 +114,45 @@ function hg = __rectangle__ (hax, vararg
         iarg ++;
       endif
     else
       iarg ++;
     endif
   endwhile
 
   if (numel (curv2) == 1)
-    [a, ai] = min (pos (3 : 4));
-    [b, bi] = max (pos (3 : 4));
+    [a, ai] = min (pos(3:4));
+    [b, bi] = max (pos(3:4));
     if (ai < bi)
       curv = [curv2, curv2 .* a ./ b];
     else
       curv = [curv2 .* a ./ b, curv2];
     endif
   else
     curv = curv2;
   endif
 
-  if (all (curv) < 0.01)
+  if (all (curv < 0.01))
     ## Special case : no curvature
     x = [pos(1), pos(1) + pos(3), pos(1) + pos(3), pos(1), pos(1)];
     y = [pos(2), pos(2), pos(2) + pos(4), pos(2) + pos(4), pos(2)];
   else
     p = pi / 2 * [0 : 15] / 15;
-    c = curv .* pos(3 : 4) / 2;
+    c = curv .* pos(3:4) / 2;
     cx = c(1) * sin (p) - c(1);
     cy = c(2) * cos (p) - c(2);
     x = [pos(1) - fliplr(cx), pos(1) + pos(3) + cx, ...
          pos(1) + pos(3) + fliplr(cx), pos(1) - cx, pos(1)];
     y = [pos(2) - fliplr(cy), pos(2) - cy, pos(2) + pos(4) + fliplr(cy), ...
          pos(2) + pos(4) + cy, pos(2) + c(2)];
   endif
 
   hg = hggroup ();
 
-  h = patch ("xdata", x(:), "ydata", y(:), "facecolor", fc, "edgecolor", ec, ...
+  h = patch ("xdata", x(:), "ydata", y(:), "facecolor", fc, "edgecolor", ec,
              "parent", hg, varargin{:});
 
   addproperty ("curvature", hg, "data", curv2);
   addproperty ("position",  hg, "data", pos);
   addproperty ("edgecolor", hg, "patchedgecolor", get (h, "edgecolor"));
   addproperty ("linewidth", hg, "patchlinewidth", get (h, "linewidth"));
   addproperty ("linestyle", hg, "patchlinestyle", get (h, "linestyle"));
   addproperty ("facecolor", hg, "patchfacecolor", get (h, "facecolor"));
@@ -161,68 +160,67 @@ function hg = __rectangle__ (hax, vararg
   addlistener (hg, "curvature", @update_data);
   addlistener (hg, "position",  @update_data);
   addlistener (hg, "edgecolor", @update_props);
   addlistener (hg, "linewidth", @update_props);
   addlistener (hg, "linestyle", @update_props);
   addlistener (hg, "facecolor", @update_props);
 endfunction
 
-function update_data (h, d)
+function update_data (h, ~)
   persistent recursion = false;
 
   ## Don't allow recursion
-  if (!recursion)
+  if (! recursion)
     unwind_protect
       recursion = true;
 
       kids = get (h, "children");
       pos = get (h, "position");
       curv2 = get (h, "curvature");
 
       if (numel (curv2) == 1)
-        [a, ai] = min (pos (3 : 4));
-        [b, bi] = max (pos (3 : 4));
+        [a, ai] = min (pos(3:4));
+        [b, bi] = max (pos(3:4));
         if (ai < bi)
           curv = [curv2, curv2 .* a ./ b];
         else
           curv = [curv2 .* a ./ b, curv2];
         endif
       else
         curv = curv2;
       endif
 
-      if (all (curv) < 0.01)
+      if (all (curv < 0.01))
         ## Special case : no curvature
         x = [pos(1), pos(1) + pos(3), pos(1) + pos(3), pos(1), pos(1)];
         y = [pos(2), pos(2), pos(2) + pos(4), pos(2) + pos(4), pos(2)];
       else
         p = pi / 2 * [0 : 15] / 15;
-        c = curv .* pos(3 : 4) / 2;
+        c = curv .* pos(3:4) / 2;
         cx = c(1) * sin (p) - c(1);
         cy = c(2) * cos (p) - c(2);
         x = [pos(1) - fliplr(cx), pos(1) + pos(3) + cx, ...
              pos(1) + pos(3) + fliplr(cx), pos(1) - cx, pos(1)];
         y = [pos(2) - fliplr(cy), pos(2) - cy, pos(2) + pos(4) + fliplr(cy), ...
              pos(2) + pos(4) + cy, pos(2) + c(2)];
       endif
 
       set (kids, "xdata", x, "ydata", y);
     unwind_protect_cleanup
       recursion = false;
     end_unwind_protect
   endif
 endfunction
 
-function update_props (h, d)
+function update_props (h, ~)
   kids = get (h, "children");
-  set (kids, "edgecolor", get (h, "edgecolor"),
-             "linewidth", get (h, "linewidth"),
-             "linestyle", get (h, "linestyle"),
-             "facecolor", get (h, "facecolor"));
+  set (kids, {"edgecolor", "linewidth", "linestyle", "facecolor"},
+     get (h, {"edgecolor", "linewidth", "linestyle", "facecolor"}));
+  
 endfunction
 
 
 %!demo
 %! clf;
 %! axis equal;
 %! rectangle ('Position', [0.05, 0.05, 0.9, 0.9], 'Curvature', [0.5, 0.5]);
 %! title ('rectangle() with corners curved');
diff --git a/scripts/statistics/base/skewness.m b/scripts/statistics/base/skewness.m
--- a/scripts/statistics/base/skewness.m
+++ b/scripts/statistics/base/skewness.m
@@ -1,8 +1,9 @@
+## Copyright (C) 2013 Julien Bect
 ## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
@@ -13,89 +14,158 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} skewness (@var{x})
-## @deftypefnx {Function File} {} skewness (@var{x}, @var{dim})
-## Compute the skewness of the elements of the vector @var{x}.
+## @deftypefnx {Function File} {} skewness (@var{x}, @var{flag})
+## @deftypefnx {Function File} {} skewness (@var{x}, @var{flag}, @var{dim})
+## Compute the sample skewness of the elements of @var{x}:
 ## @tex
 ## $$
-## {\rm skewness} (x) = {1\over N \sigma^3} \sum_{i=1}^N (x_i-\bar{x})^3
+## {\rm skewness} (@var{x}) = {{{1\over N}\,
+##          \sum_{i=1}^N (@var{x}_i - \bar{@var{x}})^3} \over \sigma^3},
 ## $$
-## where $\bar{x}$ is the mean value of $x$.
+## where $N$ is the length of @var{x}, $\bar{@var{x}}$ its mean and $\sigma$
+## its (uncorrected) standard deviation.
 ## @end tex
 ## @ifnottex
 ##
 ## @example
-## skewness (x) = 1/N std(x)^(-3) sum ((x - mean(x)).^3)
+## @group
+##                mean ((@var{x} - mean (@var{x})).^3)
+## skewness (@var{X}) = ------------------------.
+##                       std (@var{x}).^3
+## @end group
 ## @end example
 ##
 ## @end ifnottex
 ##
 ## @noindent
-## If @var{x} is a matrix, return the skewness along the
-## first non-singleton dimension of the matrix.  If the optional
+## The optional argument @var{flag} controls which normalization is used.
+## If @var{flag} is equal to 1 (default value, used when @var{flag} is omitted
+## or empty), return the sample skewness as defined above.  If @var{flag} is
+## equal to 0, return the adjusted skewness coefficient instead:
+## @tex
+## $$
+## {\rm skewness} (@var{x}) = {\sqrt{N (N - 1)} \over N - 2} \times \,
+##   {{{1 \over N} \sum_{i=1}^N (@var{x}_i - \bar{@var{x}})^3} \over \sigma^3}
+## $$
+## @end tex
+## @ifnottex
+##
+## @example
+## @group
+##                   sqrt (N*(N-1))   mean ((@var{x} - mean (@var{x})).^3)
+## skewness (@var{X}, 0) = -------------- * ------------------------.
+##                       (N - 2)             std (@var{x}).^3
+## @end group
+## @end example
+##
+## @end ifnottex
+## The adjusted skewness coefficient is obtained by replacing the sample second
+## and third central moments by their bias-corrected versions.
+##
+## If @var{x} is a matrix, or more generally a multi-dimensional array, return
+## the skewness along the first non-singleton dimension.  If the optional
 ## @var{dim} argument is given, operate along this dimension.
+##
 ## @seealso{var, kurtosis, moment}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 29 July 1994
 ## Adapted-By: jwe
 
-function retval = skewness (x, dim)
+function y = skewness (x, flag, dim)
 
-  if (nargin != 1 && nargin != 2)
+  if (nargin < 1) || (nargin > 3)
     print_usage ();
   endif
 
   if (! (isnumeric (x) || islogical (x)))
     error ("skewness: X must be a numeric vector or matrix");
   endif
 
+  if (nargin < 2 || isempty (flag))
+    flag = 1;  # default: do not use the "bias corrected" version
+  else
+    if ((! isscalar (flag)) || (flag != 0 && flag != 1))
+      error ("skewness: FLAG must be 0 or 1");
+    endif
+  endif
+
   nd = ndims (x);
   sz = size (x);
-  if (nargin != 2)
+  if (nargin < 3)
     ## Find the first non-singleton dimension.
     (dim = find (sz > 1, 1)) || (dim = 1);
   else
-    if (!(isscalar (dim) && dim == fix (dim))
-        || !(1 <= dim && dim <= nd))
+    if (!(isscalar (dim) && dim == fix (dim)) || !(1 <= dim && dim <= nd))
       error ("skewness: DIM must be an integer and a valid dimension");
     endif
   endif
 
   n = sz(dim);
   sz(dim) = 1;
-  x = center (x, dim);  # center also promotes integer to double for next line
-  retval = zeros (sz, class (x));
-  s = std (x, [], dim);
-  idx = find (s > 0);
-  x = sum (x .^ 3, dim);
-  retval(idx) = x(idx) ./ (n * s(idx) .^ 3);
+
+  x = center (x, dim);   # center also promotes integer, logical to double
+  s = std (x, 1, dim);   # Normalize with 1/N
+  y = sum (x .^ 3, dim);
+  idx = (s != 0);
+  y(idx) ./= (n * s(idx) .^ 3);
+  y(! idx) = NaN;
+
+  ## Apply bias correction to the second and third central sample moment
+  if (flag == 0)
+    if (n > 2)
+      y *= sqrt (n * (n - 1)) / (n - 2);
+    else
+      y(:) = NaN;
+    endif
+  endif
 
 endfunction
 
 
-%!assert (skewness ([-1,0,1]), 0)
-%!assert (skewness ([-2,0,1]) < 0)
-%!assert (skewness ([-1,0,2]) > 0)
-%!assert (skewness ([-3,0,1]) == -1*skewness ([-1,0,3]))
+%!assert (skewness ([-1, 0, 1]), 0)
+%!assert (skewness ([-2, 0, 1]) < 0)
+%!assert (skewness ([-1, 0, 2]) > 0)
+%!assert (skewness ([-3, 0, 1]) == -1 * skewness ([-1, 0, 3]))
+%!assert (skewness (ones (3, 5)), NaN (1, 5))
+
 %!test
 %! x = [0; 0; 0; 1];
 %! y = [x, 2*x];
-%! assert(all (abs (skewness (y) - [0.75, 0.75]) < sqrt (eps)));
+%! assert (skewness (y), 1.154700538379251 * [1 1], 5*eps);
+
+%!assert (skewness ([1:5 10; 1:5 10],  0, 2), 1.439590274527954 * [1; 1], eps)
+%!assert (skewness ([1:5 10; 1:5 10],  1, 2), 1.051328089232020 * [1; 1], 2*eps)
+%!assert (skewness ([1:5 10; 1:5 10], [], 2), 1.051328089232020 * [1; 1], 2*eps)
+
+## Test behaviour on single input
+%!assert (skewness (single ([1:5 10])), single (1.0513283), eps ("single"))
+%!assert (skewness (single ([1 2]), 0), single (NaN))
 
-%!assert (skewness (single (1)), single (0))
+## Verify no "division-by-zero" warnings
+%!test
+%! wstate = warning ("query", "Octave:divide-by-zero");
+%! unwind_protect
+%!   lastwarn ("");  # clear last warning
+%!   skewness (1);
+%!   assert (lastwarn (), "");
+%! unwind_protect_cleanup
+%!   warning (wstate, "Octave:divide-by-zero");
+%! end_unwind_protect
 
-%% Test input validation
+## Test input validation
 %!error skewness ()
 %!error skewness (1, 2, 3)
-%!error skewness (['A'; 'B'])
-%!error skewness (1, ones (2,2))
-%!error skewness (1, 1.5)
-%!error skewness (1, 0)
-%!error skewness (1, 3)
-
+%!error <X must be a numeric vector or matrix> skewness (['A'; 'B'])
+%!error <FLAG must be 0 or 1> skewness (1, 2)
+%!error <FLAG must be 0 or 1> skewness (1, [1 0])
+%!error <DIM must be an integer> skewness (1, [], ones (2,2))
+%!error <DIM must be an integer> skewness (1, [], 1.5)
+%!error <DIM must be .* a valid dimension> skewness (1, [], 0)
+%!error <DIM must be .* a valid dimension> skewness (1, [], 3)
diff --git a/test/index.tst b/test/index.tst
--- a/test/index.tst
+++ b/test/index.tst
@@ -222,8 +222,282 @@
 %!assert (d(2), 0);
 %!assert (dd(2), 0);
 %!assert (dd(6,1), 0);
 %!error d(6,6);
 %!error dd(6,6);
 %!error d(3,6);
 %!error dd(3,6);
 
+## bug 31287
+%!test
+%! y = ones (2, 2, 2);
+%! x = ones (2, 2, 2);
+%! x(false) = [];
+%! assert (x, y);
+
+%!test
+%! y = ones (2, 2, 2);
+%! x = ones (2, 2, 2);
+%! x(false,[]) = [];
+%! assert (x, y);
+
+%!test
+%! y = ones (2, 2, 2);
+%! x = ones (2, 2, 2);
+%! x(false,[],false) = [];
+%! assert (x, y);
+
+%!shared x, y
+%! y = ones (2, 2, 2);
+%! x = ones (2, 2, 2);
+%! x(false, 1) = [];
+%! assert (x, y);
+
+%!shared x, y
+%! y = ones (2, 2, 2);
+%! x = ones (2, 2, 2);
+%! x(false, false) = [];
+%! assert (x, y);
+
+%!test
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! x([], []) = [];
+%! assert (x, y);
+
+%!test
+%! y = sparse (ones (2, 2));
+%! x = sparse (ones (2, 2));
+%! x([], []) = [];
+%! assert (x, y);
+
+%!test
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! x(1, []) = [];
+%! assert (x, y);
+
+%!test
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! x([], 1, []) = [];
+%! assert (x, y);
+
+%!test
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! x(1, [], 1, 1) = [];
+%! assert (x, y);
+
+%!test
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! x([], 1, 1) = [];
+%! assert (x, y);
+
+%!test
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! ea2 = ones (3, 2, 0, 2);
+%! x(1, ea2) = [];
+%! assert (x, y);
+
+%!test
+%! y = sparse (ones (2, 2));
+%! x = sparse (ones (2, 2));
+%! ea2 = ones (3, 2, 0, 2);
+%! x(1, ea2) = [];
+%! assert (x, y);
+
+%!test
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! ea2 = ones (3, 2, 0, 2);
+%! x([], 1, ea2) = [];
+%! assert (x, y);
+
+%!test
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! ea2 = ones (3, 2, 0, 2);
+%! x(1, ea2, ea2) = [];
+%! assert (x, y);
+
+%!test
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! ea2 = ones (3, 2, 0, 2);
+%! x(1, ea2, 1) = [];
+%! assert (x, y);
+
+%!test
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! x(false, 1) = [];
+%! assert (x, y);
+
+%!test
+%! y = sparse (ones (2, 2));
+%! x = sparse (ones (2, 2));
+%! x(false, 1) = [];
+%! assert (x, y);
+
+%!test
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! x(1, [], false) = [];
+%! assert (x, y);
+
+%!test
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! x(false, false) = [];
+%! assert (x, y);
+
+%!test
+%! y = sparse (ones (2, 2));
+%! x = sparse (ones (2, 2));
+%! x(false, false) = [];
+%! assert (x, y);
+
+%!test
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! x(false, [], false) = [];
+%! assert (x, y);
+
+%!test
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! x([], false, false, false) = [];
+%! assert (x, y);
+
+%!test
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! x(1, [], false, false) = [];
+%! assert (x, y);
+
+%!test
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! x(:, false) = [];
+%! assert (x, y);
+
+%!test
+%! y = sparse (ones (2, 2));
+%! x = sparse (ones (2, 2));
+%! x(:, false) = [];
+%! assert (x, y);
+
+%!test
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! x(false, :) = [];
+%! assert (x, y);
+
+%!test
+%! y = sparse (ones (2, 2));
+%! x = sparse (ones (2, 2));
+%! x(false, :) = [];
+%! assert (x, y);
+
+%!test
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! x(false, :, [], 1) = [];
+%! assert (x, y);
+
+%!test
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! x(:, [], false) = [];
+%! assert (x, y);
+
+%!shared x, y
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%!error x(1, 1, []) = [];
+
+%!shared x, y
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! x(false, false, 1) = [];
+%! assert (x, y);
+
+%!shared x, y
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! x(false, false, []) = [];
+%! assert (x, y);
+
+%!shared x, y
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! x(false, false, [], false) = [];
+%! assert (x, y);
+
+%!shared x, y
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! x(1, false, [], false) = [];
+%! assert (x, y);
+
+%!shared x, y
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! x(:, false, 1) = [];
+%! assert (x, y);
+
+%!test
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! x([]) = [];
+%! assert (x, y);
+
+%!test
+%! y = sparse (ones (2, 2));
+%! x = sparse (ones (2, 2));
+%! x([]) = [];
+%! assert (x, y);
+
+%!test
+%! y = [];
+%! x = ones (2, 2);
+%! x(:) = [];
+%! assert (x, y);
+
+%!test
+%! y = sparse ([]);
+%! x = sparse (ones (2, 2));
+%! x(:) = [];
+%! assert (x, y);
+
+%!test
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! x(false) = [];
+%! assert (x, y);
+
+%!test
+%! y = sparse (ones (2, 2));
+%! x = sparse (ones (2, 2));
+%! x(false) = [];
+%! assert (x, y);
+
+%!test
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! x([], false) = [];
+%! assert (x, y);
+
+%!test
+%! y = sparse (ones (2, 2));
+%! x = sparse (ones (2, 2));
+%! x([], false) = [];
+%! assert (x, y);
+
+%!test
+%! y = ones (2, 2);
+%! x = ones (2, 2);
+%! x([], false, :) = [];
+%! assert (x, y);
diff --git a/test/parser.tst b/test/parser.tst
--- a/test/parser.tst
+++ b/test/parser.tst
@@ -75,17 +75,29 @@
 %! assert (1 && a ++, false);
 %! assert (0 || a --, true);
 %! a = 5; b = 2;
 %! b +=a ++;
 %! assert (b, 7);
 
 ## Level 11 (transpose and exponentiation)
 %!test
+%! a = 2;
+%! assert (2 ^a++, 4)
+%! assert (a, 3)
+%! assert (2 ^--a ^2, 16)
+%! assert (a, 2)
+%! assert (2 ^++a, 8)
+%! assert (a, 3)
+%! assert (a' ^2, 9)
+%! assert (2 ^sin(0), 1)
 %! assert (-2 ^2, -4);
+%! assert (2 ^+1 ^3, 8)
+%! assert (2 ^-1 ^3, 0.125)
+%! assert (2 ^~0 ^2, 4)
 %! assert (!0 ^0, false);
 %! assert (2*3 ^2, 18);
 %! assert (2+3 ^2, 11);
 %! assert ([1:10](1:2 ^2), [1 2 3 4]);
 %! assert (3>2 ^2, false);
 %! assert (1&0 ^0, true);
 %! assert (0|0 ^0, true);
 %! assert (1&&0 ^0, true);
@@ -191,31 +203,26 @@
 %! b = {1 2 3 4 5};
 %! assert (b{(a. b1 + 1)}, 4);
 %! b = 1:5;
 %! assert (b(a. b1 + 1), 4);
 %! assert ([2 3].^2', [4; 9]);
 ## Level 12 (postfix increment and decrement)
 ## No tests possible since a++-- is not valid
 ## Level 11 (transpose and exponentiation)
-## Note: Exponentiation should be left-to-right, but Octave does right-to-left.
-##       See bug #33304.
 %!test
 %! assert (2^3**2, 64);
 %! assert ([2 3].^2.', [4;9]);
 %! assert ([2 3].'.^2, [4;9]);
 %! assert (3*4i'.', 0 - 12i);
 %! assert (3*4i.'.', 0 + 12i);
 %! assert (2^-4^3, (1/16)^3);
 %! assert (2^+4^3, 16^3);
 %! assert (2^~0^2, 4);
 
-## Note: Exponentiation should be left-to-right, but Octave does right-to-left.
-##       See bug #33304.
-
 ## Level 10 (unary plus/minus, prefix increment/decrement, not)
 %!test
 %! assert (+-+1, -1);
 %! a = -1;
 %! assert (!++a, true);
 %! assert (a, 0);
 %! assert (-~a, -1);
 %! assert (!~--a, true);
@@ -270,8 +277,9 @@
 %! assert (R(pi/2), [cos(pi/2), -sin(pi/2); sin(pi/2),cos(pi/2)]);
 
 ## Check that xyz is tagged as a variable in the parser.  Both
 ## expressions must remain on one line for this test to work as
 ## intended.
 %!test
 %! xyz(1) = 1; xyz /= 1;
 %! assert (xyz, 1);
+
