# HG changeset patch
# User Rik <rik@octave.org>
# Date 1459400966 25200
#      Wed Mar 30 22:09:26 2016 -0700
# Node ID 3d60ed163b708487c68fac281448ae957545f3eb
# Parent  3d25f9f4a62b58be2072f21902dd080e1bfd7393
maint: Eliminate bad spacing around '='.

* Figure.h, PopupMenuControl.cc, annotation-dialog.cc, gl-select.h,
files-dock-widget.cc, find-files-dialog.cc, history-dock-widget.cc,
file-editor.cc, main-window.cc, webinfo.cc, resource-manager.cc,
shortcut-manager.cc, workspace-view.cc, __ichol__.cc, __ilu__.cc,
__lin_interpn__.cc, bitfcns.cc, debug.cc, filter.cc, ft-text-renderer.cc,
graphics.cc, graphics.in.h, hex2num.cc, jit-typeinfo.cc, load-save.cc,
ls-mat5.cc, mxarray.in.h, oct-stream.cc, pr-output.cc, variables.cc,
__init_fltk__.cc, __magick_read__.cc, chol.cc, ov-struct.cc, op-scm-cs.cc,
pt-assign.cc, CollocWt.cc, randpoisson.c, inputParser.m, quadgk.m, waitbar.m,
imwrite.m, __imread__.m, textread.m, fileattrib.m, __xzip__.m, what.m,
fsolve.m, fix_depends.m, stemleaf.m, bicgstab.m, ichol.m, io.tst:
maint: Eliminate bad spacing around '='.

diff --git a/libgui/graphics/Figure.h b/libgui/graphics/Figure.h
--- a/libgui/graphics/Figure.h
+++ b/libgui/graphics/Figure.h
@@ -36,23 +36,23 @@ class QToolBar;
 namespace QtHandles
 {
 
 enum MouseMode
 {
   // NOTE: These values must match the order of the buttons in the
   // MouseModeActionGroup object.
 
-  NoMode        = 0,
-  RotateMode    = 1,
-  ZoomInMode    = 2,
-  ZoomOutMode   = 3,
-  PanMode       = 4,
-  TextMode      = 5,
-  SelectMode    = 6
+  NoMode      = 0,
+  RotateMode  = 1,
+  ZoomInMode  = 2,
+  ZoomOutMode = 3,
+  PanMode     = 4,
+  TextMode    = 5,
+  SelectMode  = 6
 };
 
 class Container;
 class FigureWindow;
 class MenuBar;
 class ToolBar;
 
 class MouseModeActionGroup;
diff --git a/libgui/graphics/PopupMenuControl.cc b/libgui/graphics/PopupMenuControl.cc
--- a/libgui/graphics/PopupMenuControl.cc
+++ b/libgui/graphics/PopupMenuControl.cc
@@ -100,20 +100,18 @@ void PopupMenuControl::update (int pId)
 
     case uicontrol::properties::ID_VALUE:
       m_blockUpdate = true;
         {
           Matrix value = up.get_value ().matrix_value ();
 
           if (value.numel () > 0)
             {
-              if (value(0) !=  static_cast<int>(value(0)))
-                {
+              if (value(0) != static_cast<int>(value(0)))
                 warning ("popupmenu value should be integer");
-                }
               else
                 {
                   int newIndex = int (value(0)) - 1;
 
                   if (newIndex >= 0 && newIndex < box->count ())
                     {
                       if (newIndex != box->currentIndex ())
                         box->setCurrentIndex (newIndex);
diff --git a/libgui/graphics/annotation-dialog.cc b/libgui/graphics/annotation-dialog.cc
--- a/libgui/graphics/annotation-dialog.cc
+++ b/libgui/graphics/annotation-dialog.cc
@@ -142,17 +142,17 @@ annotation_dialog::get_gui_props ()
   props.append (ovl ("color", Utils::toRgb (ui->btn_color->palette ().color (QPalette::Button))));
   props.append (ovl ("linestyle", ui->cb_line_style->currentText ().toStdString ()));
 }
 
 void
 annotation_dialog::set_gui_props ()
 {
   // set the gui to the values from the props
-  octave_idx_type len  = props.length ();
+  octave_idx_type len = props.length ();
 
   for (int i=0; i<len/2; i++)
     {
       std::string name = props(i*2).string_value ();
 
       if (name == "textbox")
         {
           Matrix position = props(2*i +1).matrix_value ();
diff --git a/libgui/graphics/gl-select.h b/libgui/graphics/gl-select.h
--- a/libgui/graphics/gl-select.h
+++ b/libgui/graphics/gl-select.h
@@ -25,18 +25,18 @@ along with Octave; see the file COPYING.
 
 #include <map>
 
 #include "gl-render.h"
 #include "oct-opengl.h"
 
 enum select_flags
 {
-  select_ignore_hittest  = 0x01,
-  select_last            = 0x02
+  select_ignore_hittest = 0x01,
+  select_last           = 0x02
 };
 
 class opengl_selector : public opengl_renderer
 {
 public:
   opengl_selector (void) : size (5) { }
 
   virtual ~opengl_selector (void) { }
diff --git a/libgui/src/files-dock-widget.cc b/libgui/src/files-dock-widget.cc
--- a/libgui/src/files-dock-widget.cc
+++ b/libgui/src/files-dock-widget.cc
@@ -921,17 +921,17 @@ files_dock_widget::copyClipboard ()
 }
 
 void
 files_dock_widget::pasteClipboard ()
 {
   if (_current_directory->hasFocus ())
     {
       QClipboard *clipboard = QApplication::clipboard ();
-      QString str =  clipboard->text ();
+      QString str = clipboard->text ();
       QLineEdit * edit = _current_directory->lineEdit ();
       if (edit && str.length () > 0)
         edit->insert (str);
     }
 }
 
 void
 files_dock_widget::selectAll ()
diff --git a/libgui/src/find-files-dialog.cc b/libgui/src/find-files-dialog.cc
--- a/libgui/src/find-files-dialog.cc
+++ b/libgui/src/find-files-dialog.cc
@@ -134,21 +134,21 @@ find_files_dialog::find_files_dialog (QW
                                     Qt::AscendingOrder).toUInt ()));
 
   connect (_file_list, SIGNAL (doubleClicked (const QModelIndex&)),
            this,       SLOT (item_double_clicked (const QModelIndex &)));
 
   _status_bar = new QStatusBar;
   _status_bar->showMessage (tr ("Idle."));
 
-  _find_button =  new QPushButton (tr ("Find"));
+  _find_button = new QPushButton (tr ("Find"));
   _find_button->setToolTip (tr ("Start search for matching files"));
   connect (_find_button, SIGNAL (clicked ()), this, SLOT (start_find ()));
 
-  _stop_button =  new QPushButton (tr ("Stop"));
+  _stop_button = new QPushButton (tr ("Stop"));
   _stop_button->setToolTip (tr ("Stop searching"));
   _stop_button->setEnabled (false);
   connect (_stop_button, SIGNAL (clicked ()), this, SLOT (stop_find ()));
 
   // layout everything
   QDialogButtonBox * button_box = new QDialogButtonBox (Qt::Vertical);
   button_box->addButton (_find_button, QDialogButtonBox::ActionRole);
   button_box->addButton (_stop_button, QDialogButtonBox::ActionRole);
@@ -252,17 +252,17 @@ find_files_dialog::start_find ()
   m->clear ();
 
   QDirIterator::IteratorFlags flags = QDirIterator::NoIteratorFlags;
   if (_recurse_dirs_check->isChecked ())
     flags |= QDirIterator::Subdirectories;
 
   QDir::Filters filters = QDir::Dirs|QDir::NoDotAndDotDot|QDir::Files;
   if (! _name_case_check->isChecked ())
-    filters |=  QDir::CaseSensitive;
+    filters |= QDir::CaseSensitive;
 
   QStringList nameFilters;
   nameFilters.append (_file_name_edit->text ());
 
   if (_dir_iterator) delete _dir_iterator;
 
   _dir_iterator = new QDirIterator (_start_dir_edit->text (), nameFilters,
                                     filters, flags);
diff --git a/libgui/src/history-dock-widget.cc b/libgui/src/history-dock-widget.cc
--- a/libgui/src/history-dock-widget.cc
+++ b/libgui/src/history-dock-widget.cc
@@ -321,17 +321,17 @@ history_dock_widget::copyClipboard ()
 }
 
 void
 history_dock_widget::pasteClipboard ()
 {
   if (_filter->lineEdit ()->hasFocus ())
     {
       QClipboard *clipboard = QApplication::clipboard ();
-      QString str =  clipboard->text ();
+      QString str = clipboard->text ();
       if (str.length () > 0)
         _filter->lineEdit ()->insert (str);
     }
 }
 
 void
 history_dock_widget::selectAll ()
 {
@@ -349,9 +349,9 @@ void history_dock_widget::handle_visibil
 {
   octave_dock_widget::handle_visibility (visible);
 
   if (visible)
     {
       int filter_state = _filter_checkbox->isChecked ();
       filter_activate (filter_state);
     }
-}
\ No newline at end of file
+}
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -216,18 +216,18 @@ file_editor::request_new_script (const Q
   request_new_file (commands);
 }
 
 void
 file_editor::request_new_function (bool)
 {
   bool ok;
   // get the name of the new function
-  QString new_name  = QInputDialog::getText (this, tr ("New Function"),
-                      tr ("New function name:\n"), QLineEdit::Normal, "", &ok);
+  QString new_name = QInputDialog::getText (this, tr ("New Function"),
+                     tr ("New function name:\n"), QLineEdit::Normal, "", &ok);
   if (ok && new_name.length () > 0)
     {
       // append suffix if it not already exists
       if (new_name.rightRef (2) != ".m")
         new_name.append (".m");
       // check whether new files are created without prompt
       QSettings *settings = resource_manager::get_settings ();
       if (! settings->value ("editor/create_new_file",false).toBool ())
@@ -1682,28 +1682,28 @@ file_editor::construct (void)
 
   _edit_nav_menu = _edit_menu->addMenu (tr ("Navi&gation"));
 
   _goto_line_action = add_action (_edit_nav_menu, QIcon (),
           tr ("Go &to Line..."), SLOT (request_goto_line (bool)));
 
   _edit_cmd_menu->addSeparator ();
 
-  _move_to_matching_brace  = add_action (_edit_nav_menu, QIcon (),
+  _move_to_matching_brace = add_action (_edit_nav_menu, QIcon (),
           tr ("Move to Matching Brace"), SLOT (request_move_match_brace (bool)));
-  _sel_to_matching_brace  = add_action (_edit_nav_menu, QIcon (),
+  _sel_to_matching_brace = add_action (_edit_nav_menu, QIcon (),
           tr ("Select to Matching Brace"), SLOT (request_sel_match_brace (bool)));
 
   _edit_nav_menu->addSeparator ();
 
-  _previous_bookmark_action =  add_action (_edit_nav_menu, QIcon (),
+  _previous_bookmark_action = add_action (_edit_nav_menu, QIcon (),
           tr ("Pre&vious Bookmark"), SLOT (request_previous_bookmark (bool)));
-  _next_bookmark_action =  add_action (_edit_nav_menu, QIcon (),
+  _next_bookmark_action = add_action (_edit_nav_menu, QIcon (),
           tr ("&Next Bookmark"), SLOT (request_next_bookmark (bool)));
-  _toggle_bookmark_action =  add_action (_edit_nav_menu, QIcon (),
+  _toggle_bookmark_action = add_action (_edit_nav_menu, QIcon (),
           tr ("Toggle &Bookmark"), SLOT (request_toggle_bookmark (bool)));
   _remove_bookmark_action = add_action (_edit_nav_menu, QIcon (),
           tr ("&Remove All Bookmarks"), SLOT (request_remove_bookmark (bool)));
 
   _edit_menu->addSeparator ();
 
   _preferences_action = add_action (_edit_menu, resource_manager::icon ("preferences-system"),
           tr ("&Preferences..."), SLOT (request_preferences (bool)));
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -788,17 +788,17 @@ main_window::confirm_shutdown_octave (vo
       QSettings *settings = resource_manager::get_settings ();
 
       if (settings->value ("prompt_to_exit", false).toBool ())
         {
           int ans = QMessageBox::question (this, tr ("Octave"),
                                            tr ("Are you sure you want to exit Octave?"),
                                            QMessageBox::Ok | QMessageBox::Cancel, QMessageBox::Ok);
 
-          if (ans !=  QMessageBox::Ok)
+          if (ans != QMessageBox::Ok)
             closenow = false;
         }
 
 #ifdef HAVE_QSCINTILLA
       if (closenow)
         closenow = editor_window->check_closing ();
 #endif
     }
@@ -1167,17 +1167,17 @@ main_window::copyClipboard (void)
 
 void
 main_window::pasteClipboard (void)
 {
   if (_current_directory_combo_box->hasFocus ())
     {
       QLineEdit * edit = _current_directory_combo_box->lineEdit ();
       QClipboard *clipboard = QApplication::clipboard ();
-      QString str =  clipboard->text ();
+      QString str = clipboard->text ();
       if (edit && str.length () > 0)
         {
           edit->insert (str);
         }
     }
   else
     emit pasteClipboard_signal ();
 }
@@ -1962,17 +1962,17 @@ main_window::construct_help_menu (QMenuB
 
   construct_documentation_menu (help_menu);
 
   help_menu->addSeparator ();
 
   _report_bug_action = add_action (help_menu, QIcon (),
             tr ("Report Bug"), SLOT (open_bug_tracker_page ()));
 
-  _octave_packages_action =  add_action (help_menu, QIcon (),
+  _octave_packages_action = add_action (help_menu, QIcon (),
             tr ("Octave Packages"), SLOT (open_octave_packages_page ()));
 
   _agora_action = add_action (help_menu, QIcon (),
             tr ("Share Code"), SLOT (open_agora_page ()));
 
   _contribute_action = add_action (help_menu, QIcon (),
             tr ("Contribute to Octave"), SLOT (open_contribute_page ()));
 
diff --git a/libgui/src/qtinfo/webinfo.cc b/libgui/src/qtinfo/webinfo.cc
--- a/libgui/src/qtinfo/webinfo.cc
+++ b/libgui/src/qtinfo/webinfo.cc
@@ -302,14 +302,14 @@ webinfo::selectAll ()
 
 
 void
 webinfo::pasteClipboard ()
 {
   if (_search_line_edit->hasFocus ())
     {
       QClipboard *clipboard = QApplication::clipboard ();
-      QString str =  clipboard->text ();
+      QString str = clipboard->text ();
       if (str.length () > 0)
         _search_line_edit->insert (str);
     }
 }
 
diff --git a/libgui/src/resource-manager.cc b/libgui/src/resource-manager.cc
--- a/libgui/src/resource-manager.cc
+++ b/libgui/src/resource-manager.cc
@@ -236,17 +236,17 @@ void
 resource_manager::do_set_settings (const QString& file)
 {
   delete settings;
   settings = new QSettings (file, QSettings::IniFormat);
 
   if (! (settings
          && QFile::exists (settings->fileName ())
          && settings->isWritable ()
-         && settings->status () ==  QSettings::NoError))
+         && settings->status () == QSettings::NoError))
     {
       QString msg = QString (QT_TR_NOOP (
         "The settings file\n%1\n"
         "does not exist and can not be created.\n"
         "Make sure you have read and write permissions to\n%2\n\n"
         "Octave GUI must be closed now."));
       QMessageBox::critical (0, QString (QT_TR_NOOP ("Octave Critical Error")),
           msg.arg (do_get_settings_file ()).arg (do_get_settings_directory ()));
diff --git a/libgui/src/shortcut-manager.cc b/libgui/src/shortcut-manager.cc
--- a/libgui/src/shortcut-manager.cc
+++ b/libgui/src/shortcut-manager.cc
@@ -85,17 +85,17 @@ shortcut_manager::instance_ok (void)
 
 void
 shortcut_manager::do_init_data ()
 {
   QKeySequence ctrl;
   int prefix;
 #if defined (Q_OS_MAC)
   // Use CMD key as an equivalent of Ctrl key on other platforms
-  ctrl =  Qt::MetaModifier;
+  ctrl = Qt::MetaModifier;
   // Some of octave default shortcuts on windows/linux are already defined
   // as system wide shortcuts on Mac Os X (almost all Function keys).
   // Prefix those with Option (Alt) modifier to avoid conflicts.
   prefix = Qt::AltModifier;
 #else
   ctrl = Qt::ControlModifier;
   prefix = Qt::NoModifier;
 #endif
@@ -684,17 +684,17 @@ shortcut_manager::do_import_export (int 
 
   // get the filename to read or write the shortcuts,
   // the default extension is .osc (octave shortcuts)
   if (action != OSC_DEFAULT)
     {
       QString file;
 
       if (action == OSC_IMPORT)
-        file  = QFileDialog::getOpenFileName (this,
+        file = QFileDialog::getOpenFileName (this,
                     tr ("Import shortcuts from file ..."), QString (),
                     tr ("Octave Shortcut Files (*.osc);;All Files (*)"),
                     0,QFileDialog::DontUseNativeDialog);
       else if (action == OSC_EXPORT)
         file = QFileDialog::getSaveFileName (this,
                     tr ("Export shortcuts into file ..."), QString (),
                     tr ("Octave Shortcut Files (*.osc);;All Files (*)"),
                     0,QFileDialog::DontUseNativeDialog);
diff --git a/libgui/src/workspace-view.cc b/libgui/src/workspace-view.cc
--- a/libgui/src/workspace-view.cc
+++ b/libgui/src/workspace-view.cc
@@ -379,18 +379,18 @@ workspace_view::handle_contextmenu_renam
 
       QInputDialog* inputDialog = new QInputDialog ();
 
       inputDialog->setOptions (QInputDialog::NoButtons);
 
       bool ok = false;
 
       QString new_name
-        =  inputDialog->getText (0, "Rename Variable", "New name:",
-                                 QLineEdit::Normal, var_name, &ok);
+        = inputDialog->getText (0, "Rename Variable", "New name:",
+                                QLineEdit::Normal, var_name, &ok);
 
       if (ok && ! new_name.isEmpty ())
         {
           QAbstractItemModel *m = view->model ();
           m->setData (index, new_name, Qt::EditRole);
         }
     }
 }
@@ -435,17 +435,17 @@ workspace_view::handle_contextmenu_filte
 
 void
 workspace_view::handle_model_changed (void)
 {
 //  view->resizeRowsToContents ();
   // Just modify those rows that have been added rather than go through
   // the whole list.  For-loop test will handle when number of rows reduced.
   QFontMetrics fm = view->fontMetrics ();
-  int row_height =  fm.height ();
+  int row_height = fm.height ();
   int new_row_count = _filter_model.rowCount ();
   for (int i = view_previous_row_count; i < new_row_count; i++)
     view->setRowHeight (i, row_height);
   view_previous_row_count = new_row_count;
 }
 
 void
 workspace_view::notice_settings (const QSettings *settings)
diff --git a/libinterp/corefcn/__ichol__.cc b/libinterp/corefcn/__ichol__.cc
--- a/libinterp/corefcn/__ichol__.cc
+++ b/libinterp/corefcn/__ichol__.cc
@@ -296,17 +296,17 @@ void ichol_t (const octave_matrix_t& sm,
               // If the element in the j position of the row is zero,
               // then it will become non-zero, so we add it to the
               // vector that tracks non-zero elements in the working row.
               if (w_data[j] == zero)
                 {
                   vec[ind] = j;
                   ind++;
                 }
-              w_data[j] -=  ichol_mult (data_l[jj], data_l[jjrow]);
+              w_data[j] -= ichol_mult (data_l[jj], data_l[jjrow]);
             }
           // Update the actual column first element and
           // update the linked list of the jrow row.
           if ((jjrow + 1) < jend)
             {
               Lfirst[jrow]++;
               j = jrow;
               jrow = Llist[jrow];
@@ -373,17 +373,17 @@ void ichol_t (const octave_matrix_t& sm,
 
       if (! ichol_checkpivot (data_l[total_len]))
         break;
 
       // Once elements are dropped and compensation of column sums are done,
       // scale the elements by the pivot.
       data_l[total_len] = std::sqrt (data_l[total_len]);
       for (jj = total_len + 1; jj < (total_len + w_len); jj++)
-        data_l[jj] /=  data_l[total_len];
+        data_l[jj] /= data_l[total_len];
       total_len += w_len;
       // Check if there are too many elements to be indexed with
       // octave_idx_type type due to fill-in during the process.
       if (total_len < 0)
         error ("ichol: integer overflow.  Too many fill-in elements in L");
 
       cidx_l[k+1] = cidx_l[k] - cidx_l[0] + w_len;
 
diff --git a/libinterp/corefcn/__ilu__.cc b/libinterp/corefcn/__ilu__.cc
--- a/libinterp/corefcn/__ilu__.cc
+++ b/libinterp/corefcn/__ilu__.cc
@@ -111,17 +111,17 @@ void ilu_0 (octave_matrix_t& sm, const s
           jrow = ridx[j];
         }
       uptr[k] = j;
       if (opt != OFF)
         data[uptr[k]] -= r;
 
       if (opt != ROW)
         for (jj = uptr[k] + 1; jj < cidx[k+1]; jj++)
-          data[jj] /=  data[uptr[k]];
+          data[jj] /= data[uptr[k]];
 
       if (k != jrow)
         error ("ilu: A has a zero on the diagonal");
 
       if (data[j] == T(0))
         error ("ilu: encountered a pivot equal to 0");
 
       for (i = j1; i < j2; i++)
diff --git a/libinterp/corefcn/__lin_interpn__.cc b/libinterp/corefcn/__lin_interpn__.cc
--- a/libinterp/corefcn/__lin_interpn__.cc
+++ b/libinterp/corefcn/__lin_interpn__.cc
@@ -190,17 +190,17 @@ lin_interpn (int n, M *X, const M V, M *
   M Vi = M (Y[0].dims ());
 
   OCTAVE_LOCAL_BUFFER (const T *, y, n);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, size, n);
 
   for (int i = 0; i < n; i++)
     {
       y[i] = Y[i].data ();
-      size[i] =  V.dims ()(i);
+      size[i] = V.dims ()(i);
     }
 
   OCTAVE_LOCAL_BUFFER (const T *, x, n);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, scale, n);
 
   const T *v = V.data ();
   T *vi = Vi.fortran_vec ();
   octave_idx_type Ni = Vi.numel ();
@@ -222,17 +222,17 @@ lin_interpn (int n, M *X, const M V, M *
       for (int i = 0; i < n; i++)
         {
           if (X[i].dims () != V.dims ())
             error ("interpn: incompatible size of argument number %d", i+1);
 
           M tmp = M (dim_vector (size[i], 1));
 
           for (octave_idx_type j = 0; j < size[i]; j++)
-            tmp(j) =  X[i](scale[i]*j);
+            tmp(j) = X[i](scale[i]*j);
 
           X[i] = tmp;
         }
     }
 
   for (int i = 0; i < n; i++)
     {
       if (! isvector (X[i]) && X[i].numel () != size[i])
diff --git a/libinterp/corefcn/bitfcns.cc b/libinterp/corefcn/bitfcns.cc
--- a/libinterp/corefcn/bitfcns.cc
+++ b/libinterp/corefcn/bitfcns.cc
@@ -260,17 +260,17 @@ bitop (const std::string& fname, const o
               retval = bitopx (fname, x, y);
             }
           else if (args(q).type_id () == octave_int16_matrix::static_type_id ()
                    || args(q).type_id () == octave_int16_scalar::static_type_id ())
             {
               int16NDArray x (dx);
               int16NDArray y = args(q).int16_array_value ();
 
-              retval  = bitopx (fname, x, y);
+              retval = bitopx (fname, x, y);
             }
           else if (args(q).type_id () == octave_int8_matrix::static_type_id ()
                    || args(q).type_id () == octave_int8_scalar::static_type_id ())
             {
               int8NDArray x (dx);
               int8NDArray y = args(q).int8_array_value ();
 
               retval = bitopx (fname, x, y);
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -455,19 +455,19 @@ bp_table::instance_ok (void)
 
   return true;
 }
 
 // Clear all reasons to stop, other than breakpoints
 void
 bp_table::dbclear_all_signals (void)
 {
-  Vdebug_on_error   = false;  bp_table::errors_that_stop.clear ();
-  Vdebug_on_caught  = false;  bp_table::caught_that_stop.clear ();
-  Vdebug_on_warning = false;  bp_table::warnings_that_stop.clear ();
+  Vdebug_on_error     = false;  bp_table::errors_that_stop.clear ();
+  Vdebug_on_caught    = false;  bp_table::caught_that_stop.clear ();
+  Vdebug_on_warning   = false;  bp_table::warnings_that_stop.clear ();
   Vdebug_on_interrupt = false;
 }
 
 // Process the "warn", "errs", "caught" and "intr" fields for a call of
 // "dbstop (p)".
 void
 bp_table::dbstop_process_map_args (const octave_map& mv)
 {
diff --git a/libinterp/corefcn/filter.cc b/libinterp/corefcn/filter.cc
--- a/libinterp/corefcn/filter.cc
+++ b/libinterp/corefcn/filter.cc
@@ -40,18 +40,18 @@ along with Octave; see the file COPYING.
 
 template <typename T>
 MArray<T>
 filter (MArray<T>& b, MArray<T>& a, MArray<T>& x, MArray<T>& si,
         int dim = 0)
 {
   MArray<T> y;
 
-  octave_idx_type a_len  = a.numel ();
-  octave_idx_type b_len  = b.numel ();
+  octave_idx_type a_len = a.numel ();
+  octave_idx_type b_len = b.numel ();
 
   octave_idx_type ab_len = a_len > b_len ? a_len : b_len;
 
   // FIXME: The two lines below should be unecessary because
   //        this template is called with a and b as column vectors
   //        already.  However the a.resize line is currently (2011/04/26)
   //        necessary to stop bug #33164.
   b.resize (dim_vector (ab_len, 1), 0.0);
diff --git a/libinterp/corefcn/ft-text-renderer.cc b/libinterp/corefcn/ft-text-renderer.cc
--- a/libinterp/corefcn/ft-text-renderer.cc
+++ b/libinterp/corefcn/ft-text-renderer.cc
@@ -1136,17 +1136,17 @@ ft_text_renderer::render (text_element *
           }
           break;
 
         case ROTATION_180:
           {
             Array<idx_vector> idx (dim_vector (3, 1));
             idx(0) = idx_vector (':');
             idx(1) = idx_vector (pixels.dim2 ()-1, -1, -1);
-            idx(2)=  idx_vector (pixels.dim3 ()-1, -1, -1);
+            idx(2) = idx_vector (pixels.dim3 ()-1, -1, -1);
             pixels = uint8NDArray (pixels.index (idx));
           }
           break;
 
         case ROTATION_270:
           {
             Array<octave_idx_type> perm (dim_vector (3, 1));
             perm(0) = 0;
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -2214,17 +2214,17 @@ graphics_object::set (const Array<std::s
     error ("set: number of names must match number of value columns (%d != %d)",
            pnames.numel (), values.columns ());
 
   octave_idx_type k = pnames.columns ();
 
   for (octave_idx_type column = 0; column < k; column++)
     {
       caseless_str pname = pnames(column);
-      octave_value val  = values(row, column);
+      octave_value val = values(row, column);
 
       set_value_or_default (pname, val);
     }
 }
 
 /*
 ## test set with cell array arguments
 %!test
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -1744,17 +1744,17 @@ private:
       children_list.push_front (*p);
   }
 
   Matrix do_get_children (bool return_hidden) const;
 
   Matrix do_get_all_children (void) const
   {
     Matrix retval (children_list.size (), 1);
-    octave_idx_type i  = 0;
+    octave_idx_type i = 0;
 
     for (const_children_list_iterator p = children_list.begin ();
          p != children_list.end (); p++)
       retval(i++) = *p;
     return retval;
   }
 
   bool do_remove_child (double child)
@@ -2381,29 +2381,29 @@ private:
   }
 
   Cell do_available_toolkits_list (void) const
   {
     Cell m (1 , available_toolkits.size ());
 
     octave_idx_type i = 0;
     for (const_available_toolkits_iterator p = available_toolkits.begin ();
-         p !=  available_toolkits.end (); p++)
+         p != available_toolkits.end (); p++)
       m(i++) = *p;
 
     return m;
   }
 
   Cell do_loaded_toolkits_list (void) const
   {
     Cell m (1 , loaded_toolkits.size ());
 
     octave_idx_type i = 0;
     for (const_loaded_toolkits_iterator p = loaded_toolkits.begin ();
-         p !=  loaded_toolkits.end (); p++)
+         p != loaded_toolkits.end (); p++)
       m(i++) = p->first;
 
     return m;
   }
 
   void do_unload_all_toolkits (void)
   {
     while (! loaded_toolkits.empty ())
diff --git a/libinterp/corefcn/hex2num.cc b/libinterp/corefcn/hex2num.cc
--- a/libinterp/corefcn/hex2num.cc
+++ b/libinterp/corefcn/hex2num.cc
@@ -118,17 +118,17 @@ hex2num ([\"402df854\"; \"41200000\"], \
             }
 
           if (nc < nchars)
             num.ival <<= (nchars - nc) * 4;
 
           m(i) = num.dval;
         }
 
-      retval =  m;
+      retval = m;
     }
   else
     {
       ColumnVector m (nr);
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           union
@@ -156,17 +156,17 @@ hex2num ([\"402df854\"; \"41200000\"], \
             }
 
           if (nc < nchars)
             num.ival <<= (nchars - nc) * 4;
 
           m(i) = num.dval;
         }
 
-      retval =  m;
+      retval = m;
     }
 
   return retval;
 }
 
 /*
 %!assert (hex2num (["c00";"bff";"000";"3ff";"400"]), [-2:2]')
 %!assert (hex2num (["c00";"bf8";"000";"3f8";"400"], "single"), single([-2:2])')
diff --git a/libinterp/corefcn/jit-typeinfo.cc b/libinterp/corefcn/jit-typeinfo.cc
--- a/libinterp/corefcn/jit-typeinfo.cc
+++ b/libinterp/corefcn/jit-typeinfo.cc
@@ -813,17 +813,17 @@ jit_operation::add_overload (const jit_f
 
   over(idx) = func;
 }
 
 const jit_function&
 jit_operation::overload (const std::vector<jit_type*>& types) const
 {
   static jit_function null_overload;
-  for (size_t i  =0; i < types.size (); ++i)
+  for (size_t i = 0; i < types.size (); ++i)
     if (! types[i])
       return null_overload;
 
   if (types.size () >= overloads.size ())
     return do_generate (types);
 
   const Array<jit_function>& over = overloads[types.size ()];
   dim_vector dv (over.dims ());
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -1093,17 +1093,17 @@ parse_save_options (const string_vector 
           save_as_floats = true;
 #else
           err_disabled_feature ("save", "HDF5");
 #endif
         }
 #ifdef HAVE_ZLIB
       else if (argv[i] == "-zip" || argv[i] == "-z")
         {
-          use_zlib  = true;
+          use_zlib = true;
         }
 #endif
       else if (argv[i] == "-struct")
         {
           retval.append (argv[i]);
         }
       else if (argv[i][0] == '-' && argv[i] != "-")
         {
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -520,17 +520,17 @@ read_mat5_binary_element (std::istream& 
       is.read (inbuf, element_length);
 
       // We uncompress the first 8 bytes of the header to get the buffer length
       // This will fail with an error Z_MEM_ERROR
       uLongf destLen = 8;
       OCTAVE_LOCAL_BUFFER (unsigned int, tmp, 2);
       if (uncompress (reinterpret_cast<Bytef *> (tmp), &destLen,
                       reinterpret_cast<Bytef *> (inbuf), element_length)
-          ==  Z_MEM_ERROR)
+          == Z_MEM_ERROR)
         error ("load: error probing size of compressed data element");
 
       // Why should I have to initialize outbuf as I'll just overwrite!!
       if (swap)
         swap_bytes<4> (tmp, 2);
 
       destLen = tmp[1] + 8;
       std::string outbuf (destLen, ' ');
@@ -1903,17 +1903,17 @@ save_mat5_array_length (const double* va
         }
 
       // The code below is disabled since get_save_type currently doesn't
       // deal with integer types.  This will need to be activated if
       // get_save_type is changed.
 
       // double max_val = val[0];
       // double min_val = val[0];
-      // bool all_integers =  true;
+      // bool all_integers = true;
       //
       // for (int i = 0; i < nel; i++)
       //   {
       //     double val = val[i];
       //
       //     if (val > max_val)
       //       max_val = val;
       //
@@ -1958,17 +1958,17 @@ save_mat5_array_length (const float* /* 
 
 
       // The code below is disabled since get_save_type currently doesn't
       // deal with integer types.  This will need to be activated if
       // get_save_type is changed.
 
       // float max_val = val[0];
       // float min_val = val[0];
-      // bool all_integers =  true;
+      // bool all_integers = true;
       //
       // for (int i = 0; i < nel; i++)
       //   {
       //     float val = val[i];
       //
       //     if (val > max_val)
       //       max_val = val;
       //
diff --git a/libinterp/corefcn/mxarray.in.h b/libinterp/corefcn/mxarray.in.h
--- a/libinterp/corefcn/mxarray.in.h
+++ b/libinterp/corefcn/mxarray.in.h
@@ -498,17 +498,17 @@ public:
   static void *calloc (size_t n, size_t t);
 
   static char *strsave (const char *str)
   {
     char *retval = 0;
 
     if (str)
       {
-        mwSize sz =  sizeof (mxChar) * (strlen (str) + 1);
+        mwSize sz = sizeof (mxChar) * (strlen (str) + 1);
         retval = static_cast<char *> (mxArray::malloc (sz));
         strcpy (retval, str);
       }
 
     return retval;
   }
 
   static octave_value as_octave_value (const mxArray *ptr);
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -3782,17 +3782,17 @@ textscan::skip_whitespace (delimited_str
           if (prev == eol1 && eol1 != eol2 && c1 == eol2)
             lines--;
           prev = c1;
         }
 
       if (c1 == comment_char)           // see if we match an open comment
         {
           // save stream state in case we have to restore it
-          char *pos   = is.tellg ();
+          char *pos = is.tellg ();
           std::ios::iostate state = is.rdstate ();
 
           std::string tmp (comment_len, '\0');
           char *look = is.read (&tmp[0], comment_len-1, pos); // already read first char
           if (is && ! strncmp (comment_style(0).string_value ().substr (1)
                                .c_str (), look, comment_len-1))
             {
               found_comment = true;
@@ -6716,17 +6716,17 @@ convert_data (const T *data, void *conv_
 {
   bool retval = true;
 
   bool swap
     = ((oct_mach_info::words_big_endian ()
         && flt_fmt == oct_mach_info::flt_fmt_ieee_little_endian)
        || flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian);
 
-  bool do_float_conversion =  flt_fmt != oct_mach_info::float_format ();
+  bool do_float_conversion = flt_fmt != oct_mach_info::float_format ();
 
   typedef typename ultimate_element_type<T>::type ult_elt_type;
 
   switch (output_type)
     {
     case oct_data_conv::dt_char:
       convert_chars<ult_elt_type, char> (data, conv_data, n_elts);
       break;
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -942,17 +942,17 @@ set_complex_format (int x_max, int x_min
       else
         {
           int ex = 4;
           if (x_max > 100 || x_min > 100)
             ex++;
 
           if (print_eng)
             {
-              i_fw =  3 + prec + ex;
+              i_fw = 3 + prec + ex;
               r_fw = i_fw + 1;
               if (inf_or_nan && i_fw < 5)
                 {
                   i_fw = 5;
                   r_fw = 6;
                 }
               r_fmt = float_format (r_fw, ex, prec - 1, std::ios::fixed);
               i_fmt = float_format (i_fw, ex, prec - 1, std::ios::fixed);
@@ -3603,17 +3603,17 @@ init_format_state (void)
   print_big_e = false;
   print_g = false;
   print_eng = false;
 }
 
 static void
 set_output_prec_and_fw (int prec, int fw)
 {
-  Voutput_precision =  prec;
+  Voutput_precision = prec;
   Voutput_max_field_width = fw;
 }
 
 static std::string format_string ("short");
 
 static void
 set_format_style (int argc, const string_vector& argv)
 {
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -1680,17 +1680,17 @@ do_who (int argc, const string_vector& a
 
           frame.add_fcn (symbol_table::clear_variables);
 
           feval ("load", octave_value (nm), 0);
 
           std::string newmsg = std::string ("Variables in the file ")
             + nm + ":\n\n";
 
-          retval =  do_who (i, argv, return_list, verbose, newmsg);
+          retval = do_who (i, argv, return_list, verbose, newmsg);
 
           return retval;
         }
       else if (argv[i] == "-regexp")
         have_regexp = true;
       else if (argv[i] == "global")
         global_only = true;
       else if (argv[i][0] == '-')
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -1693,18 +1693,18 @@ private:
                 }
               else if (Fl::event_button () == 3)
                 {
                   pixel2status (ax_obj, pos_x, pos_y,
                                 Fl::event_x (), Fl::event_y () - menu_dy ());
                   Matrix zoom_box (1,4,0);
                   zoom_box (0) = pos_x;
                   zoom_box (1) = pos_y;
-                  zoom_box (2) =  Fl::event_x ();
-                  zoom_box (3) =  Fl::event_y () - menu_dy ();
+                  zoom_box (2) = Fl::event_x ();
+                  zoom_box (3) = Fl::event_y () - menu_dy ();
                   canvas->set_zoom_box (zoom_box);
                   canvas->zoom (true);
                   mark_modified ();
                   return 1;
                 }
 
               break;
 
diff --git a/libinterp/dldfcn/__magick_read__.cc b/libinterp/dldfcn/__magick_read__.cc
--- a/libinterp/dldfcn/__magick_read__.cc
+++ b/libinterp/dldfcn/__magick_read__.cc
@@ -159,22 +159,22 @@ get_region_range (const octave_value& re
 
 static std::map<std::string, octave_idx_type>
 calculate_region (const octave_scalar_map& options)
 {
   std::map<std::string, octave_idx_type> region;
   const Cell pixel_region = options.getfield ("region").cell_value ();
 
   // Subtract 1 to account for 0 indexing.
-  const Range rows     = get_region_range (pixel_region (0));
-  const Range cols     = get_region_range (pixel_region (1));
-  region["row_start"]  = rows.base () -1;
-  region["col_start"]  = cols.base () -1;
-  region["row_end"]    = rows.max ()  -1;
-  region["col_end"]    = cols.max ()  -1;
+  const Range rows    = get_region_range (pixel_region (0));
+  const Range cols    = get_region_range (pixel_region (1));
+  region["row_start"] = rows.base () -1;
+  region["col_start"] = cols.base () -1;
+  region["row_end"]   = rows.max ()  -1;
+  region["col_end"]   = cols.max ()  -1;
 
   // Length of the area to load into the Image Pixel Cache.  We use max and
   // min to account for cases where last element of range is the range limit.
   region["row_cache"] = region["row_end"] - region["row_start"] +1;
   region["col_cache"] = region["col_end"] - region["col_start"] +1;
 
   // How much we have to shift in the memory when doing the loops.
   region["row_shift"] = region["col_cache"] * rows.inc ();
@@ -466,18 +466,18 @@ read_images (std::vector<Magick::Image>&
                 pix -= col_shift;
               }
           }
         break;
       }
 
     case Magick::GrayscaleMatteType:    // Grayscale image with opacity
       {
-        img   = T (dim_vector (nRows, nCols, 1, nFrames));
-        T alpha   (dim_vector (nRows, nCols, 1, nFrames));
+        img = T (dim_vector (nRows, nCols, 1, nFrames));
+        T alpha (dim_vector (nRows, nCols, 1, nFrames));
         P *img_fvec = img.fortran_vec ();
         P *a_fvec   = alpha.fortran_vec ();
 
         octave_idx_type idx = 0;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
             OCTAVE_QUIT;
             const Magick::PixelPacket *pix
@@ -510,19 +510,19 @@ read_images (std::vector<Magick::Image>&
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
             OCTAVE_QUIT;
             const Magick::PixelPacket *pix
               = imvec[frameidx(frame)].getConstPixels (col_start, row_start,
                                                        col_cache, row_cache);
 
             octave_idx_type idx = 0;
-            P *rbuf   = img_fvec;
-            P *gbuf   = img_fvec + color_stride;
-            P *bbuf   = img_fvec + color_stride * 2;
+            P *rbuf = img_fvec;
+            P *gbuf = img_fvec + color_stride;
+            P *bbuf = img_fvec + color_stride * 2;
 
             for (octave_idx_type col = 0; col < nCols; col++)
               {
                 for (octave_idx_type row = 0; row < nRows; row++)
                   {
                     rbuf[idx] = pix->red   / divisor;
                     gbuf[idx] = pix->green / divisor;
                     bbuf[idx] = pix->blue  / divisor;
@@ -534,37 +534,37 @@ read_images (std::vector<Magick::Image>&
             img_fvec += frame_stride;
           }
         break;
       }
 
     case Magick::PaletteMatteType:    // Indexed color image with opacity
     case Magick::TrueColorMatteType:  // Truecolor image with opacity
       {
-        img   = T (dim_vector (nRows, nCols, 3, nFrames));
-        T alpha   (dim_vector (nRows, nCols, 1, nFrames));
+        img = T (dim_vector (nRows, nCols, 3, nFrames));
+        T alpha (dim_vector (nRows, nCols, 1, nFrames));
         P *img_fvec = img.fortran_vec ();
         P *a_fvec   = alpha.fortran_vec ();
 
         const octave_idx_type frame_stride = color_stride * 3;
 
         // Unlike the index for the other channels, this one won't need
         // to be reset on each frame since it's a separate matrix.
         octave_idx_type a_idx = 0;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
             OCTAVE_QUIT;
             const Magick::PixelPacket *pix
               = imvec[frameidx(frame)].getConstPixels (col_start, row_start,
                                                        col_cache, row_cache);
 
             octave_idx_type idx = 0;
-            P *rbuf   = img_fvec;
-            P *gbuf   = img_fvec + color_stride;
-            P *bbuf   = img_fvec + color_stride * 2;
+            P *rbuf = img_fvec;
+            P *gbuf = img_fvec + color_stride;
+            P *bbuf = img_fvec + color_stride * 2;
 
             for (octave_idx_type col = 0; col < nCols; col++)
               {
                 for (octave_idx_type row = 0; row < nRows; row++)
                   {
                     rbuf[idx]     = pix->red     / divisor;
                     gbuf[idx]     = pix->green   / divisor;
                     bbuf[idx]     = pix->blue    / divisor;
@@ -577,32 +577,32 @@ read_images (std::vector<Magick::Image>&
             img_fvec += frame_stride;
           }
         retval(2) = alpha;
         break;
       }
 
     case Magick::ColorSeparationType:  // Cyan/Magenta/Yellow/Black (CMYK) image
       {
-        img   = T (dim_vector (nRows, nCols, 4, nFrames));
+        img = T (dim_vector (nRows, nCols, 4, nFrames));
         P *img_fvec = img.fortran_vec ();
 
         const octave_idx_type frame_stride = color_stride * 4;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
             OCTAVE_QUIT;
             const Magick::PixelPacket *pix
               = imvec[frameidx(frame)].getConstPixels (col_start, row_start,
                                                        col_cache, row_cache);
 
             octave_idx_type idx = 0;
-            P *cbuf   = img_fvec;
-            P *mbuf   = img_fvec + color_stride;
-            P *ybuf   = img_fvec + color_stride * 2;
-            P *kbuf   = img_fvec + color_stride * 3;
+            P *cbuf = img_fvec;
+            P *mbuf = img_fvec + color_stride;
+            P *ybuf = img_fvec + color_stride * 2;
+            P *kbuf = img_fvec + color_stride * 3;
 
             for (octave_idx_type col = 0; col < nCols; col++)
               {
                 for (octave_idx_type row = 0; row < nRows; row++)
                   {
                     cbuf[idx] = pix->red     / divisor;
                     mbuf[idx] = pix->green   / divisor;
                     ybuf[idx] = pix->blue    / divisor;
@@ -615,18 +615,18 @@ read_images (std::vector<Magick::Image>&
             img_fvec += frame_stride;
           }
         break;
       }
 
     // Cyan, magenta, yellow, and black with alpha (opacity) channel
     case Magick::ColorSeparationMatteType:
       {
-        img   = T (dim_vector (nRows, nCols, 4, nFrames));
-        T alpha   (dim_vector (nRows, nCols, 1, nFrames));
+        img = T (dim_vector (nRows, nCols, 4, nFrames));
+        T alpha (dim_vector (nRows, nCols, 1, nFrames));
         P *img_fvec = img.fortran_vec ();
         P *a_fvec   = alpha.fortran_vec ();
 
         const octave_idx_type frame_stride = color_stride * 4;
 
         // Unlike the index for the other channels, this one won't need
         // to be reset on each frame since it's a separate matrix.
         octave_idx_type a_idx = 0;
@@ -637,20 +637,20 @@ read_images (std::vector<Magick::Image>&
               = imvec[frameidx(frame)].getConstPixels (col_start, row_start,
                                                        col_cache, row_cache);
             // Note that for CMYKColorspace + matte (CMYKA), the opacity is
             // stored in the assocated IndexPacket.
             const Magick::IndexPacket *apix
               = imvec[frameidx(frame)].getConstIndexes ();
 
             octave_idx_type idx = 0;
-            P *cbuf   = img_fvec;
-            P *mbuf   = img_fvec + color_stride;
-            P *ybuf   = img_fvec + color_stride * 2;
-            P *kbuf   = img_fvec + color_stride * 3;
+            P *cbuf = img_fvec;
+            P *mbuf = img_fvec + color_stride;
+            P *ybuf = img_fvec + color_stride * 2;
+            P *kbuf = img_fvec + color_stride * 3;
 
             for (octave_idx_type col = 0; col < nCols; col++)
               {
                 for (octave_idx_type row = 0; row < nRows; row++)
                   {
                     cbuf[idx]     = pix->red     / divisor;
                     mbuf[idx]     = pix->green   / divisor;
                     ybuf[idx]     = pix->blue    / divisor;
@@ -989,19 +989,19 @@ encode_indexed_images (std::vector<Magic
       m_img.syncPixels ();
       imvec.push_back (m_img);
     }
 }
 
 static void
 encode_bool_image (std::vector<Magick::Image>& imvec, const boolNDArray& img)
 {
-  const octave_idx_type nFrames   = img.ndims () < 4 ? 1 : img.dims ()(3);
-  const octave_idx_type nRows     = img.rows ();
-  const octave_idx_type nCols     = img.columns ();
+  const octave_idx_type nFrames = img.ndims () < 4 ? 1 : img.dims ()(3);
+  const octave_idx_type nRows   = img.rows ();
+  const octave_idx_type nCols   = img.columns ();
 
   // The initialized image will be black, this is for the other pixels
   const Magick::Color white ("white");
 
   const bool *img_fvec = img.fortran_vec ();
   octave_idx_type img_idx = 0;
   for (octave_idx_type frame = 0; frame < nFrames; frame++)
     {
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -913,17 +913,17 @@ If @var{info} is not present, an error m
 %! assert (norm (A1(p,p) - single (Ac), Inf) < 2e1*eps ("single"));
 
 %!test
 %! cu = chol (triu (A), "upper");
 %! cl = chol (tril (A), "lower");
 %! assert (cu, cl', eps);
 
 %!test
-%! cca  = chol (Ac);
+%! cca   = chol (Ac);
 %!
 %! ccal  = chol (Ac, "lower");
 %! ccal2 = chol (tril (Ac), "lower");
 %!
 %! ccau  = chol (Ac, "upper");
 %! ccau2 = chol (triu (Ac), "upper");
 %!
 %! assert (cca'*cca,     Ac, eps);
@@ -931,17 +931,17 @@ If @var{info} is not present, an error m
 %! assert (ccau2'*ccau2, Ac, eps);
 %!
 %! assert (cca, ccal',  eps);
 %! assert (cca, ccau,   eps);
 %! assert (cca, ccal2', eps);
 %! assert (cca, ccau2,  eps);
 
 %!test
-%! cca  = chol (single (Ac));
+%! cca   = chol (single (Ac));
 %!
 %! ccal  = chol (single (Ac), "lower");
 %! ccal2 = chol (tril (single (Ac)), "lower");
 %!
 %! ccau  = chol (single (Ac), "upper");
 %! ccau2 = chol (triu (single (Ac)), "upper");
 %!
 %! assert (cca'*cca,     single (Ac), eps ("single"));
@@ -961,17 +961,17 @@ If @var{info} is not present, an error m
 %!
 %! b = [0,  1,  2,  3;
 %!     -1,  0,  1,  2;
 %!     -2, -1,  0,  1;
 %!     -3, -2, -1,  0];
 %!
 %! ca = a + i*b;
 %!
-%! cca  = chol (ca);
+%! cca   = chol (ca);
 %!
 %! ccal  = chol (ca, "lower");
 %! ccal2 = chol (tril (ca), "lower");
 %!
 %! ccau  = chol (ca, "upper");
 %! ccau2 = chol (triu (ca), "upper");
 %!
 %! assert (cca'*cca,     ca, 16*eps);
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -1980,17 +1980,17 @@ A(1)\n\
   assert (ext == rdv(dim));
   if (nd == 2)
     {
       rdv(0) = rdv(1-dim);
       rdv(1) = 1;
     }
   else
     {
-      for (int i =  dim + 1; i < nd; i++)
+      for (int i = dim + 1; i < nd; i++)
         rdv(i-1) = rdv(i);
 
       rdv.resize (nd-1);
     }
 
   octave_map map (rdv);
   Array<idx_vector> ia (dim_vector (nd, 1), idx_vector::colon);
 
diff --git a/libinterp/operators/op-scm-cs.cc b/libinterp/operators/op-scm-cs.cc
--- a/libinterp/operators/op-scm-cs.cc
+++ b/libinterp/operators/op-scm-cs.cc
@@ -107,17 +107,17 @@ DEFBINOP (el_div, sparse_complex_matrix,
 
   octave_value retval;
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
-  retval =  octave_value (v1.sparse_complex_matrix_value () / d);
+  retval = octave_value (v1.sparse_complex_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP_FN (el_pow, sparse_complex_matrix, complex, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, complex)
 {
diff --git a/libinterp/parse-tree/pt-assign.cc b/libinterp/parse-tree/pt-assign.cc
--- a/libinterp/parse-tree/pt-assign.cc
+++ b/libinterp/parse-tree/pt-assign.cc
@@ -261,17 +261,17 @@ tree_multi_assignment::rvalue (int)
                   idx.push_back (octave_value_list (octave_value (1)));
                   ult.set_index ("{", idx);
                 }
 
               if (k + nel > n)
                 error ("some elements undefined in return list");
 
               // This won't do a copy.
-              octave_value_list ovl  = rhs_val.slice (k, nel);
+              octave_value_list ovl = rhs_val.slice (k, nel);
 
               ult.assign (octave_value::op_asn_eq,
                           octave_value (ovl, true));
 
               retval_list.push_back (ovl);
 
               k += nel;
             }
diff --git a/liboctave/numeric/CollocWt.cc b/liboctave/numeric/CollocWt.cc
--- a/liboctave/numeric/CollocWt.cc
+++ b/liboctave/numeric/CollocWt.cc
@@ -345,17 +345,17 @@ dfopr (octave_idx_type n, octave_idx_typ
         }
     }
   else
     {
       double y = 0.0;
 
       for (octave_idx_type j = 0; j < nt; j++)
         {
-          double x  = root[j];
+          double x = root[j];
 
           double ax = x * (1.0 - x);
 
           if (n0 == 0)
             ax = ax / x / x;
 
           if (n1 == 0)
             ax = ax / (1.0 - x) / (1.0 - x);
diff --git a/liboctave/numeric/randpoisson.c b/liboctave/numeric/randpoisson.c
--- a/liboctave/numeric/randpoisson.c
+++ b/liboctave/numeric/randpoisson.c
@@ -469,17 +469,17 @@ poisson_rejection_float (double lambda, 
       p[i] = em;
     }
 }
 
 /* The cutoff of L <= 1e8 in the following two functions before using
  * the normal approximation is based on:
  *   > L=1e8; x=floor(linspace(0,2*L,1000));
  *   > max(abs(normal_pdf(x,L,L)-poisson_pdf(x,L)))
- *   ans =  1.1376e-28
+ *   ans = 1.1376e-28
  * For L=1e7, the max is around 1e-9, which is within the step size of RUNI.
  * For L>1e10 the pprsc function breaks down, as I saw from the histogram
  * of a large sample, so 1e8 is both small enough and large enough. */
 
 /* Generate a set of poisson numbers with the same distribution */
 void
 oct_fill_randp (double L, octave_idx_type n, double *p)
 {
diff --git a/scripts/general/inputParser.m b/scripts/general/inputParser.m
--- a/scripts/general/inputParser.m
+++ b/scripts/general/inputParser.m
@@ -241,19 +241,19 @@
 ##
 ## @end deftypefn
 
 ## Author: Carnë Draug <carandraug@octave.org>
 
 classdef inputParser < handle
   properties
     ## TODO set input checking for this properties
-    CaseSensitive     = false;
-    FunctionName      = "";
-    KeepUnmatched     = false;
+    CaseSensitive = false;
+    FunctionName  = "";
+    KeepUnmatched = false;
     # PartialMatching = true;   # TODO unimplemented
     # StructExpand    = true;   # TODO unimplemented
   endproperties
 
   properties (SetAccess = protected)
     Parameters    = cell ();
     Results       = struct ();
     Unmatched     = struct ();
@@ -272,17 +272,17 @@ classdef inputParser < handle
 
     ## List of ParamValues and Switch names to ease searches
     ParamValueNames = cell ();
     SwitchNames     = cell ();
 
     ## When checking for fieldnames in a Case Insensitive way, this variable
     ## holds the correct identifier for the last searched named using the
     ## is_argname method.
-    last_name  = "";
+    last_name = "";
   endproperties
 
   properties (Access = protected, Constant = true)
     ## Default validator, always returns scalar true.
     def_val = @() true;
   endproperties
 
   methods
diff --git a/scripts/general/quadgk.m b/scripts/general/quadgk.m
--- a/scripts/general/quadgk.m
+++ b/scripts/general/quadgk.m
@@ -427,17 +427,17 @@ function [q, err] = __quadgk_eval__ (f, 
              0.1047900103222502e+00,  0.1406532597155259e+00, ...
              0.1690047266392679e+00,  0.1903505780647854e+00, ...
              0.2044329400752989e+00,  0.2094821410847278e+00, ...
              0.2044329400752989e+00,  0.1903505780647854e+00, ...
              0.1690047266392679e+00,  0.1406532597155259e+00, ...
              0.1047900103222502e+00,  0.6309209262997855e-01, ...
              0.2293532201052922e-01]);
 
-  persistent weights7  = ...
+  persistent weights7 = ...
       diag ([0.1294849661688697e+00,  0.2797053914892767e+00, ...
              0.3818300505051889e+00,  0.4179591836734694e+00, ...
              0.3818300505051889e+00,  0.2797053914892767e+00, ...
              0.1294849661688697e+00]);
 
   halfwidth = diff (subs, [], 2) ./ 2;
   center = sum (subs, 2) ./ 2;
   x = (halfwidth * abscissa) + center;
diff --git a/scripts/gui/waitbar.m b/scripts/gui/waitbar.m
--- a/scripts/gui/waitbar.m
+++ b/scripts/gui/waitbar.m
@@ -164,17 +164,17 @@ function updatecancelbutton (hf, dummy, 
   if (! strcmpi (get (hf, "__graphics_toolkit__"), "qt"))
     return
   endif
 
   hbtn = findobj (hf, "type", "uicontrol", "-and", "style", "pushbutton");
   cb = get (hf, "createcancelbtn");
   if (! isempty (cb))
     if (isempty (hbtn))
-      units =  get (hax, "units");
+      units = get (hax, "units");
       fpos = get (hf, "position");
       set (hax, "units", "pixels");
       apos = get (hax, "position");
 
       fpos (2) -= 40;
       fpos (4) += 40;
       apos (2) += 40;
       set (hf, "position", fpos);
@@ -183,17 +183,17 @@ function updatecancelbutton (hf, dummy, 
       hbtn = uicontrol ("style", "pushbutton", "string", "Cancel", ...
                         "position", [fpos(3)-100 10 60 25],...
                         "callback", cb, "parent", hf);
     else
       set (hbtn, "callback", cb);
     endif
   elseif (! isempty (hbtn))
     delete (hbtn);
-    units =  get (hax, "units");
+    units = get (hax, "units");
     fpos = get (hf, "position");
     set (hax, "units", "pixels");
     apos = get (hax, "position");
 
     fpos (2) += 40;
     fpos (4) -= 40;
     apos (2) -= 40;
     set (hf, "position", fpos);
diff --git a/scripts/image/imwrite.m b/scripts/image/imwrite.m
--- a/scripts/image/imwrite.m
+++ b/scripts/image/imwrite.m
@@ -137,32 +137,32 @@ endfunction
 %!    [r, cmap, a] = imread (filename, "Index", "all");
 %!  unwind_protect_cleanup
 %!    unlink (filename);
 %!  end_unwind_protect
 %!endfunction
 
 ## typical usage with grayscale uint8 images
 %!testif HAVE_MAGICK
-%! gray  = randi (255, 10, 10, 1, "uint8");
-%! r  = write_and_read (".tif", gray);
+%! gray = randi (255, 10, 10, 1, "uint8");
+%! r = write_and_read (".tif", gray);
 %! assert (r, gray)
 
 ## grayscale uint8 images with alpha channel
 %!testif HAVE_MAGICK
 %! gray  = randi (255, 10, 10, 1, "uint8");
 %! alpha = randi (255, 10, 10, 1, "uint8");
 %! [r, ~, a] = write_and_read (".tif", gray, "Alpha", alpha);
 %! assert (r, gray)
 %! assert (a, alpha)
 
 ## multipage grayscale uint8 images
 %!testif HAVE_MAGICK
-%! gray  = randi (255, 10, 10, 1, 5, "uint8");
-%! r     = write_and_read (".tif", gray);
+%! gray = randi (255, 10, 10, 1, 5, "uint8");
+%! r    = write_and_read (".tif", gray);
 %! assert (r, gray)
 
 ## multipage RGB uint8 images with alpha channel
 %!testif HAVE_MAGICK
 %! gray  = randi (255, 10, 10, 3, 5, "uint8");
 %! alpha = randi (255, 10, 10, 1, 5, "uint8");
 %! [r, ~, a] = write_and_read (".tif", gray, "Alpha", alpha);
 %! assert (r, gray)
diff --git a/scripts/image/private/__imread__.m b/scripts/image/private/__imread__.m
--- a/scripts/image/private/__imread__.m
+++ b/scripts/image/private/__imread__.m
@@ -37,17 +37,17 @@ function varargout = __imread__ (filenam
 
   if (nargin < 1)
     print_usage ("imread");
   elseif (! ischar (filename))
     error ("imread: FILENAME must be a string");
   endif
 
   ## keep track of the varargin offset we're looking at each moment
-  offset    = 1;
+  offset = 1;
 
   ## It is possible for an file with multiple pages to have very different
   ## images on each page. Specifically, they may have different sizes. Because
   ## of this, we need to first find out the index of the images to read so
   ## we can set up defaults for things such as PixelRegion later on.
   options = struct ("index", 1);  # default image index
 
   ## Index is the only option that can be defined without the parameter/value
diff --git a/scripts/io/textread.m b/scripts/io/textread.m
--- a/scripts/io/textread.m
+++ b/scripts/io/textread.m
@@ -137,17 +137,17 @@ function varargout = textread (filename,
   if (fid == -1)
     error ("textread: could not open '%s' for reading", filename);
   endif
 
   ## Skip header lines if requested
   headerlines = find (strcmpi (varargin, "headerlines"), 1);
   if (! isempty (headerlines))
     ## Beware of missing or wrong headerline value
-    if (headerlines  == numel (varargin)
+    if (headerlines == numel (varargin)
        || ! isnumeric (varargin{headerlines + 1}))
       error ("textread: missing or invalid value for 'headerlines'" );
     endif
     ## Avoid conveying floats to fskipl
     varargin{headerlines + 1} = round (varargin{headerlines + 1});
     ## Beware of zero valued headerline, fskipl would skip to EOF
     if (varargin{headerlines + 1} > 0)
       fskipl (fid, varargin{headerlines + 1});
diff --git a/scripts/miscellaneous/fileattrib.m b/scripts/miscellaneous/fileattrib.m
--- a/scripts/miscellaneous/fileattrib.m
+++ b/scripts/miscellaneous/fileattrib.m
@@ -118,17 +118,17 @@ function [status, msg, msgid] = fileattr
       modestr = info.modestr;
       r(i).UserRead = (modestr(2) == "r");
       r(i).UserWrite = (modestr(3) == "w");
       r(i).UserExecute = (modestr(4) == "x");
       if (isunix ())
         r(i).GroupRead = (modestr(5) == "r");
         r(i).GroupWrite = (modestr(6) == "w");
         r(i).GroupExecute = (modestr(7) == "x");
-        r(i).OtherRead  = (modestr(8) == "r");
+        r(i).OtherRead = (modestr(8) == "r");
         r(i).OtherWrite = (modestr(9) == "w");
         r(i).OtherExecute = (modestr(10) == "x");
       else
         r(i).GroupRead = NaN;
         r(i).GroupWrite = NaN;
         r(i).GroupExecute = NaN;
         r(i).OtherRead = NaN;
         r(i).OtherWrite = NaN;
diff --git a/scripts/miscellaneous/private/__xzip__.m b/scripts/miscellaneous/private/__xzip__.m
--- a/scripts/miscellaneous/private/__xzip__.m
+++ b/scripts/miscellaneous/private/__xzip__.m
@@ -88,18 +88,18 @@ function filelist = __xzip__ (commandnam
       endif
     else
       ## FIXME: This does not work when you try to compress directories
       ##        The resulting name is dir/.gz which is totally wrong.
       ##        See bug #43431.
       movefile (cellfun (@(x) sprintf ("%s.%s", x, extension),
                          fnames, "uniformoutput", false), cwd);
       if (nargout > 0)
-        filelist  = cellfun (@(x) sprintf ("%s.%s", x, extension),
-                             files, "uniformoutput", false);
+        filelist = cellfun (@(x) sprintf ("%s.%s", x, extension),
+                            files, "uniformoutput", false);
       endif
     endif
 
   unwind_protect_cleanup
     cd (cwd);
     if (nargin == 4)
       confirm_recursive_rmdir (false, "local");
       rmdir (outdir, "s");
diff --git a/scripts/miscellaneous/what.m b/scripts/miscellaneous/what.m
--- a/scripts/miscellaneous/what.m
+++ b/scripts/miscellaneous/what.m
@@ -142,17 +142,17 @@ function __display_filenames__ (msg, p, 
     maxlen = max (cellfun ("length", f));
     ncols = max (1, floor (terminal_size ()(2) / (maxlen + 3)));
     fmt = sprintf ("   %%-%ds", maxlen);
     fmt = repmat (fmt, [1, ncols]);
     fmt = [fmt "\n"];
 
     nrows = ceil (length (f) / ncols);
     for i = 1 : nrows
-      args  = f(i:nrows:end);
+      args = f(i:nrows:end);
       if (length (args) < ncols)
         args(end+1 : ncols) = {""};
       endif
       printf (fmt, args{:});
     endfor
   endif
 
 endfunction
diff --git a/scripts/optimization/fsolve.m b/scripts/optimization/fsolve.m
--- a/scripts/optimization/fsolve.m
+++ b/scripts/optimization/fsolve.m
@@ -554,17 +554,17 @@ endfunction
 %! b0 = 3;
 %! a0 = 0.2;
 %! x = 0:.5:5;
 %! noise = 1e-5 * sin (100*x);
 %! y = exp (-a0*x) + b0 + noise;
 %! c_opt = [a0, b0];
 %! tol = 1e-5;
 %!
-%! [c, fval, info, output] =  fsolve (@(c) (exp(-c(1)*x) + c(2) - y), [0, 0]);
+%! [c, fval, info, output] = fsolve (@(c) (exp(-c(1)*x) + c(2) - y), [0, 0]);
 %! assert (info > 0);
 %! assert (norm (c - c_opt, Inf) < tol);
 %! assert (norm (fval) < norm (noise));
 
 %!function y = cfun (x)
 %!  y(1) = (1+i)*x(1)^2 - (1-i)*x(2) - 2;
 %!  y(2) = sqrt (x(1)*x(2)) - (1-2i)*x(3) + (3-4i);
 %!  y(3) = x(1) * x(2) - x(3)^2 + (3+2i);
diff --git a/scripts/pkg/private/fix_depends.m b/scripts/pkg/private/fix_depends.m
--- a/scripts/pkg/private/fix_depends.m
+++ b/scripts/pkg/private/fix_depends.m
@@ -48,17 +48,17 @@ function deps_cell = fix_depends (depend
         endif
         version = fix_version (nm.ver);
         ## If no version is specified for the dependency
         ## we say that the version should be greater than
         ## or equal to "0.0.0".
       else
         package = tolower (strtrim (dep));
         operator = ">=";
-        version  = "0.0.0";
+        version = "0.0.0";
       endif
       deps_cell{i} = struct ("package", package,
                              "operator", operator,
                              "version", version);
     else
       error ("incorrect syntax for dependency '%s' in the DESCRIPTION file\n",
              dep);
     endif
diff --git a/scripts/plot/draw/stemleaf.m b/scripts/plot/draw/stemleaf.m
--- a/scripts/plot/draw/stemleaf.m
+++ b/scripts/plot/draw/stemleaf.m
@@ -243,17 +243,17 @@ function plotstr = stemleaf (x, caption,
     endif
     if (! signbit (max_x))
       stems = [stems, 0 : fix(max_x/stem_step)+1 ];
     endif
   endif
 
   ## Vectorized version provided by Rik Wehbring (rik@octave.org)
   ## Determine leaves for each stem:
-  new_line  = 1;
+  new_line = 1;
   for kx = 2: numel (stems)
 
     stem_sign = signbit (stems(kx));
     if (stems(kx) <= 0)
       idx = ((x <= stems(kx)*stem_step) & (x > (stems(kx-1)*stem_step))
               & (signbit (x) == stem_sign));
       xlf = abs (x(idx) - stems(kx)*stem_step);
     else
diff --git a/scripts/sparse/bicgstab.m b/scripts/sparse/bicgstab.m
--- a/scripts/sparse/bicgstab.m
+++ b/scripts/sparse/bicgstab.m
@@ -72,19 +72,19 @@
 function [x, flag, relres, iter, resvec] = bicgstab (A, b, tol, maxit,
                                                      M1, M2, x0)
 
   if (nargin >= 2 && nargin <= 7 && isvector (full (b)))
 
     if (ischar (A))
       A = str2func (A);
     elseif (isnumeric(A) && issquare (A))
-      Ax  = @(x) A  * x;
+      Ax = @(x) A  * x;
     elseif (isa (A, "function_handle"))
-      Ax  = @(x) feval (A, x);
+      Ax = @(x) feval (A, x);
     else
       error ("bicgstab: A must be a square matrix or function");
     endif
 
     if (nargin < 3 || isempty (tol))
       tol = 1e-6;
     endif
 
diff --git a/scripts/sparse/ichol.m b/scripts/sparse/ichol.m
--- a/scripts/sparse/ichol.m
+++ b/scripts/sparse/ichol.m
@@ -232,17 +232,17 @@ function L = ichol (A, opts = struct ())
     A_in = A_in';
   else
     A_in = tril (A);
   endif
 
   ## Delegate to specialized ICHOL
   switch (opts.type)
     case "nofill"
-      L  = __ichol0__ (A_in, opts.michol);
+      L = __ichol0__ (A_in, opts.michol);
     case "ict"
       L = __icholt__ (A_in, opts.droptol, opts.michol);
   endswitch
 
   if (strcmp (opts.shape, "upper"))
     L = L';
   endif
 
diff --git a/test/io.tst b/test/io.tst
--- a/test/io.tst
+++ b/test/io.tst
@@ -236,17 +236,17 @@
 %!         STR.matrix_fld == [1.1,2;3,4] && ...
 %!         STR.string_fld == "Octave" && ...
 %!         STR.struct_fld.x == 0 && ...
 %!         STR.struct_fld.y == 1 );
 %!
 %!
 %! save ("-binary", struct_dat,
 %!       "-struct", "STR", "matrix_fld", "str*_fld");
-%! STR =  load (struct_dat);
+%! STR = load (struct_dat);
 %!
 %! assert (!isfield (STR,"scalar_fld") && ...
 %!         STR.matrix_fld == [1.1,2;3,4] && ...
 %!         STR.string_fld == "Octave" && ...
 %!         STR.struct_fld.x == 0 && ...
 %!         STR.struct_fld.y == 1);
 %!
 %! delete (struct_dat);
