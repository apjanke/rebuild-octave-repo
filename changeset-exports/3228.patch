# HG changeset patch
# User jwe
# Date 913228933 0
#      Wed Dec 09 18:42:13 1998 +0000
# Node ID dbcc24961c444ad6ab8eac1d59fead867fca0a14
# Parent  e090571062eeb9506ef178e0c93cea0ef21ed3dd
[project @ 1998-12-09 18:42:12 by jwe]

diff --git a/scripts/control/DEMOcontrol.m b/scripts/control/DEMOcontrol.m
--- a/scripts/control/DEMOcontrol.m
+++ b/scripts/control/DEMOcontrol.m
@@ -16,17 +16,17 @@
 # along with Octave; see the file COPYING.  If not, write to the Free
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 function DEMOcontrol()
 # Controls toolbox demo.
 # Demo programs: bddemo.m, frdemo.m, analdemo.m, moddmeo.m, rldemo.m
 #  
 # Written by David Clem August 15, 1994
-# $Revision: 1.2 $    
+# $Revision: 2.0.0.0 $    
 
   disp(' O C T A V E    C O N T R O L   S Y S T E M S   T O O L B O X')
 
   while (1)
     clc
     k = 0;
     while (k > 8 || k < 1),
       k = menu("Octave Controls System Toolbox Demo", ...
diff --git a/scripts/control/abcddim.m b/scripts/control/abcddim.m
--- a/scripts/control/abcddim.m
+++ b/scripts/control/abcddim.m
@@ -30,21 +30,40 @@ function [n, m, p] = abcddim (a, b, c, d
 # Note: n = 0 (pure gain block) is returned without warning.
 #
 # Returns n = m = p = -1 if the system is not compatible.
 #
 # See also: is_abcd
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
 # a s hodel: modified to accept pure-gain systems aug 1996
-# $Revision: 1.15 $
+# $Revision: 1.16 $
 # $Log: abcddim.m,v $
-# Revision 1.15  1998-11-06 16:15:36  jwe
+# Revision 1.16  1998-12-09 18:42:12  jwe
 # *** empty log message ***
 #
+# Revision 2.0.0.0  1998/12/08  21:36:51  hodel
+# Branch for beta release patches
+#
+# Revision 2.0  1998/12/08  21:34:56  hodel
+# Initial beta release of signals-as-lists rewrite;
+# sysdimensions now takes opt as an argument
+#
+# Revision 2.0.0.1  1998/12/08  20:54:18  hodel
+# sysdimensions takes opt parameter now
+#
+# Revision 2.0.0.0  1998/12/08  20:30:08  hodel
+# beta release revision
+#
+# Revision 2.0  1998/12/08  20:27:55  hodel
+# Initial list rewrite of OCST
+#
+# Revision 1.2  1998/10/05 17:12:56  hodelas
+# various bug changes
+#
 # Revision 1.1.1.1  1998/05/19 20:24:05  jwe
 #
 # Revision 1.4  1997/12/01 16:44:22  scotte
 # *** empty log message ***
 #
 # Revision 1.3  1997/02/12 15:38:14  hodel
 # *** empty log message ***
 #
diff --git a/scripts/control/abcddims.m b/scripts/control/abcddims.m
--- a/scripts/control/abcddims.m
+++ b/scripts/control/abcddims.m
@@ -19,16 +19,16 @@
 function [y,my,ny] = abcddims (x)
 
 # Usage: [y,my,ny] = abcddims (x)
 #
 # Used internally in abcddim.  If x is a zero-size matrix, both dimensions
 # get set to 0.  my and ny are the row and column dimensions of the result.
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) Feb 1997
-# $Revision: 1.1.1.1 $
+# $Revision: 2.0.0.0 $
 
   y = x;
   if(isempty(y))
     y = [];
   endif
   [my,ny] = size(y);
 endfunction
diff --git a/scripts/control/analdemo.m b/scripts/control/analdemo.m
--- a/scripts/control/analdemo.m
+++ b/scripts/control/analdemo.m
@@ -15,17 +15,17 @@
 # You should have received a copy of the GNU General Public License 
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function analdemo()
 # Octave Controls toolbox demo: State Space analysis demo
 # Written by David Clem August 15, 1994
 # Updated by John Ingram December 1996
-# $Revision: 1.4 $
+# $Revision: 2.0.0.0 $
   
   while (1)
     clc
     k=0;
     while(k > 8 || k < 1)
       k = menu("Octave State Space Analysis Demo", ...
         "System grammians (gram, dgram)", ...
         "System zeros (tzero)", ...
diff --git a/scripts/control/are.m b/scripts/control/are.m
--- a/scripts/control/are.m
+++ b/scripts/control/are.m
@@ -30,17 +30,17 @@ function x = are (a, b, c, opt)
 # Solution method: apply Laub's Schur method (IEEE Trans. Auto. Contr,
 # 1979) to the appropriate Hamiltonian matrix.
 #
 # opt is an option passed to the eigenvalue balancing routine default is "B".
 #
 # See also: balance
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
-# $Revision: 1.18 $
+# $Revision: 1.19 $
 
   if (nargin == 3 || nargin == 4)
     if (nargin == 4)
       if (! (strcmp (opt, "N") || strcmp (opt, "P") ...
 	     || strcmp (opt, "S") || strcmp (opt, "B") ...
 	     || strcmp (opt, "n") || strcmp (opt, "p") ...
 	     || strcmp (opt, "s") || strcmp (opt, "b")))
 	warning ("are: opt has an invalid value; setting to B");
diff --git a/scripts/control/bddemo.m b/scripts/control/bddemo.m
--- a/scripts/control/bddemo.m
+++ b/scripts/control/bddemo.m
@@ -39,17 +39,17 @@ function bddemo()
 
   while (1)
     clc
     k=0;
     while(k > 14 || k < 1)
       k = menu("Octave Block Diagram Manipulations Demo", ...
   	"sysadd/syssub: F(s) = G(s) +/- H(s)", ...
  	"sysappend: add new inputs/outputs", ...
-	"syschnames: change names of inputs, outputs, and/or states", ...
+	"syssetsignals: change names of inputs, outputs, and/or states", ...
 	"sysconnect: connect specified system inputs/outputs", ...
 	"syscont/sysdisc: extract the continuous (discrete) part of a system", ...
 	"sysdup: duplicate specified inputs/outputs", ...
 	"sysgroup: group two systems into a single system,", ...
 	"sysmult: F(s) = G(s)*H(s) (series connection)", ...
 	"sysprune: keep only specified inputs/outputs", ...
 	"sysscale: scale inputs/outputs by specified gain matrices", ...
 	"parallel: parallel connection of two systems", ...
@@ -115,31 +115,33 @@ function bddemo()
       run_cmd
       disp("Notice that empty matrices can be listed for the D matrix if")
       disp("all entries are zeros.")
       disp(" ")
       disp("sys1 is thus:")
       sysout(sys1);
       prompt
     elseif (k == 3)
-      disp("syschnames:")
-      help syschnames
+      disp("syssetsignals:")
+      help syssetsignals
       disp("Example system");
       a = rand(3,3);
       b = rand(3,2);
       c = rand(2,3);
       sys = ss2sys(a,b,c);
       sysout(sys);
       prompt
       disp("Change state names to larry, moe, and curly as follows:")
-      sys = syschnames(sys,"st",1:3,["larry";"moe  " ; "curly"]);
-      cmd = "sys = syschnames(sys,\"st\",1:3,[\"larry\";\"moe  \" ; \"curly\"]);";
+      cmd = "sys = syssetsignals(sys,\"st\",list(\"larry\",\"moe  \" , \"curly\"));";
       run_cmd
       disp("Indicate that output 2 is discrete-time:")
-      cmd = "sys = syschnames(sys,\"yd\",2,1);";
+      cmd = "sys = syssetsignals(sys,\"yd\",1,2);";
+      run_cmd
+      disp("Change output 2 name to \"Vir\"");
+      cmd = "sys = syssetsignals(sys,\"out\",\"Vir\",2);";
       run_cmd
       disp("Resulting system is:")
       sysout(sys);
       prompt
     elseif (k == 4)
       help sysconnect
       prompt
       disp("********* N O T E *********")
@@ -287,29 +289,29 @@ function bddemo()
       sysout(sys2);
       cmd = "sysp = parallel(sys1,sys2);";
       run_cmd
       disp("sysp=")
       sysout(sysp);
       prompt
       disp("parallel can be used for multiple input systems as well:")
 
-      in1 = ["u1.1";"u1.2"];
-      in2 = ["u2.1";"u2.2"];
-      out1 = ["y1.1";"y1.2"];
-      out2 = ["y2.1";"y2.2"];
+      in1 = list("u1.1","u1.2");
+      in2 = list("u2.1","u2.2");
+      out1 = list("y1.1","y1.2");
+      out2 = list("y2.1","y2.2");
 
       sys1 = ss2sys([-1,0;0 -2],eye(2),eye(2),[]);
       sys2 = ss2sys([-2,0;0 -4],eye(2),eye(2),[]);
 
-      sys1 = syschnames(sys1,"in",1:2,in1);
-      sys1 = syschnames(sys1,"out",1:2,out1);
+      sys1 = syssetsignals(sys1,"in",in1);
+      sys1 = syssetsignals(sys1,"out",out1);
 
-      sys2 = syschnames(sys2,"in",1:2,in2);
-      sys2 = syschnames(sys2,"out",1:2,out2);
+      sys2 = syssetsignals(sys2,"in",in2);
+      sys2 = syssetsignals(sys2,"out",out2);
      
       disp("sys1=")
       sysout(sys1);
       disp("sys2=")
       sysout(sys2);
       cmd = "sysp = parallel(sys1,sys2);";
       run_cmd
       disp("sysp=")
@@ -538,17 +540,17 @@ function bddemo()
           disp("  r(t) ---> (+) --->| K(s) |--->| P(s) | ----> y(t)");
           disp("            -^      --------    --------  |");
           disp("             |                            |");
           disp("             ------------------------------");
           disp(" ")
       disp("Step 1: We've already created systems P and K.  Create a sum ")
       disp("block as follows:")
       implicit_str_to_num_ok = "warn";
-      cmd = "S = ss2sys([],[],[],[1 -1],0,0,0,[],[""r(t)"";""y(t)""],""e(t)"");";
+      cmd = "S = ss2sys([],[],[],[1 -1],0,0,0,[],list(""r(t)"",""y(t)""),""e(t)"");";
       run_cmd
       implicit_str_to_num_ok = 1;
       disp("You may avoid the string conversion warning by setting the ")
       disp("Octave global variables implicit_str_to_num_ok = 1");
       disp(" ");
       disp("(You may wish to look at help ss2sys to see what the above does)");
       disp("S=")
       sysout(S)
diff --git a/scripts/control/bode.m b/scripts/control/bode.m
--- a/scripts/control/bode.m
+++ b/scripts/control/bode.m
@@ -52,18 +52,37 @@ function [mag,phase,w] = bode(sys,w,outp
 # ||G(jw)|| or ||G(exp(jwT))|| and phase information is not computed.
 
 # Written by John Ingram  July 10th, 1996
 # Based on previous code
 # By R. Bruce Tenison, July 13, 1994
 # Modified by David Clem November 13, 1994
 # again by A. S. Hodel July 1995 (smart plot range, etc.)
 # Modified by Kai P. Mueller September 28, 1997 (multiplot mode)
-# $Revision: 1.6 $
+# $Revision: 2.0.0.0 $
 # $Log: bode.m,v $
+# Revision 2.0.0.0  1998/12/08  21:36:52  hodel
+# Branch for beta release patches
+#
+# Revision 2.0  1998/12/08  21:34:57  hodel
+# Initial beta release of signals-as-lists rewrite;
+# sysdimensions now takes opt as an argument
+#
+# Revision 2.0.0.1  1998/12/08  20:54:19  hodel
+# sysdimensions takes opt parameter now
+#
+# Revision 2.0.0.0  1998/12/08  20:30:09  hodel
+# beta release revision
+#
+# Revision 2.0  1998/12/08  20:27:56  hodel
+# Initial list rewrite of OCST
+#
+# Revision 1.7  1998/10/21 12:46:59  hodelas
+# moved grid command so that grid appears in plots
+#
 # Revision 1.6  1998/09/04 20:57:18  hodelas
 # fixed bodquist bug (use reshape instead of  transpose); removed extraneous
 # output from bode.
 #
 # Bodquist is now much faster
 #
 # Revision 1.4  1998/08/24 15:50:03  hodelas
 # updated documentation
@@ -133,24 +152,23 @@ function [mag,phase,w] = bode(sys,w,outp
       tistr = "(jw)";
     endif
     xlabel(xlstr);
     ylabel("Gain in dB");
     if(is_siso(sys))
       if (gnuplot_has_multiplot)
         subplot(2,1,1);
       endif
-      title(["|[Y/U]",tistr,"|, u=", inname, ...
-	", y=",outname]);
+      title(["|[Y/U]",tistr,"|, u=", nth(inname,1),", y=",nth(outname,1)]);
     else
       title([ "||Y(", tistr, ")/U(", tistr, ")||"]);
       disp("MIMO plot from")
-      outlist(inname,"	");
+      disp(outlist(inname,"	"));
       disp("to")
-      outlist(outname,"	");
+      disp(outlist(outname,"	"));
     endif
     wv = [min(w), max(w)];
     md = 20*log10(mag);
 
     axvec = axis2dlim([vec(w),vec(md)]);
     axvec(1:2) = wv;
     axis(axvec);
     grid("on");
@@ -162,17 +180,17 @@ function [mag,phase,w] = bode(sys,w,outp
         prompt('Press any key for phase plot');
       endif
       axvec = axis2dlim([vec(w),vec(phase)]);
       axvec(1:2) = wv;
       axis(axvec);
       xlabel(xlstr);
       ylabel("Phase in deg");
       title([ "phase([Y/U]", tistr, ...
-	 "), u=", (inname),", y=",(outname)]);
+	 "), u=", nth(inname,1),", y=",nth(outname,1)]);
       grid("on");
       semilogx(w,phase);
       # This should be the default for subsequent plot commands.
       if(gnuplot_has_multiplot)
         oneplot();
       endif
     endif
     mag = phase = w = [];
diff --git a/scripts/control/bode_bounds.m b/scripts/control/bode_bounds.m
--- a/scripts/control/bode_bounds.m
+++ b/scripts/control/bode_bounds.m
@@ -19,32 +19,17 @@
 function [wmin,wmax] = bode_bounds(zer,pol,DIGITAL,tsam)
 # function [wmin,wmax] = bode_bounds(zer,pol,DIGITAL{,tsam})
 # get default range of frequencies for system zeros and poles
 #
 # frequency range is the interval [10^wmin,10^wmax]
 #
 # used internally in freqresp
 
-# $Revision: 1.4 $
-# $Log: bode_bounds.m,v $
-# Revision 1.4  1998/10/05 17:12:56  hodelas
-# various bug changes
-#
-# Revision 1.2  1998/08/18 21:21:19  hodelas
-# updated for simpler interface
-#
-#
-# Revision 1.2  1997/11/24  15:39:38  mueller
-# floating overflow on digital systems fixed
-# The overflow occurs if the system has poles or zeros at 0 (log(0)/tsamp)
-#
-# Revision 1.1  1997/11/24  15:36:31  mueller
-# Initial revision
-#
+# $Revision: 2.0.0.0 $
 
   # make sure zer,pol are row vectors
   if(!isempty(pol)) pol = reshape(pol,1,length(pol)); endif
   if(!isempty(zer)) zer = reshape(zer,1,length(zer)); endif
 
 # check for natural frequencies away from omega = 0
   if (DIGITAL)
     # The 2nd conditions prevents log(0) in the next log command
diff --git a/scripts/control/buildssic.m b/scripts/control/buildssic.m
--- a/scripts/control/buildssic.m
+++ b/scripts/control/buildssic.m
@@ -103,36 +103,17 @@ function [sys] = buildssic(Clst,Ulst,Ols
 #
 #     GW = buildssic([1 4;2 4;3 1],[3],[2 3 5],[3 4],G,W1,W2,One);
 #
 # where "One" is a unity gain (auxillary) function with order 0.
 # (e.g. One = ugain(1);)
 #
 
 # Written by Kai Mueller April 1998
-# $Revision: 1.2 $
-# $Log: buildssic.m,v $
-# Revision 1.2  1998/10/12  10:04:14  mueller
-# bugfix: build of discrete systems corrected.
-# The previous version did not sum up the discrete states.
-#
-# Revision 1.1  1998/10/12  08:51:49  mueller
-# Initial revision
-#
-# Revision 1.1.1.1  1998/05/19 20:24:05  jwe
-#
-# Revision 1.1  1998/05/05 17:02:56  scotte
-# Initial revision
-#
-# Revision 1.2  1998/05/05  08:19:59  mueller
-# minor corrections
-#
-# Revision 1.1  1998/05/04  15:09:32  mueller
-# Initial revision
-#
+# $Revision: 2.0.0.0 $
 
   if((nargin < 5) || (nargin > 12))
     usage("[sys] = buildssic(Clst,Ulst,Olst,Ilst,s1,s2,s3,s4,s5,s6,s7,s8)");
   endif
   if (nargin >= 5)
     if (!is_struct(s1))
       error("---> s1 must be a structed system.");
     endif
diff --git a/scripts/control/c2d.m b/scripts/control/c2d.m
--- a/scripts/control/c2d.m
+++ b/scripts/control/c2d.m
@@ -44,30 +44,17 @@ function dsys = c2d (sys, opt, T)
 #
 #   x[n+1] = Ad x[n] + Bd u[n]
 #
 # Note: This function adds _d to the names of the new discrete states.   
 
 # Written by R.B. Tenison (btenison@eng.auburn.edu)
 # October 1993
 # Updated by John Ingram for system data structure August 1996
-# SYS_INTERNAL accesses members of system data structure
-# $Log: c2d.m,v $
-# Revision 1.13  1998-11-06 16:15:36  jwe
-# *** empty log message ***
-#
-# Revision 1.3  1998/07/21 14:53:08  hodelas
-# use isempty instead of size tests; use sys calls to reduce direct
-# access to system structure elements
-#
-# Revision 1.2  1998/07/01 16:23:35  hodelas
-# Updated c2d, d2c to perform bilinear transforms.
-# Updated several files per bug updates from users.
-#
-# $Revision: 1.13 $
+# $Revision: 1.14 $
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
 # parse input arguments
   if(nargin < 1 | nargin > 3)
     usage("dsys=c2d(sys[,T])");
   elseif (!is_struct(sys))
@@ -98,81 +85,68 @@ function dsys = c2d (sys, opt, T)
     error(["illegal option passed: ",opt])
   endif
 
   sys = sysupdate(sys,"ss");
   [n,nz,m,p] = sysdimensions(sys);
 
   if (n == 0)
     warning("c2d: sys has no continuous states; setting outputs to discrete");
-    dsys = syschnames(sys,"yd",1:p,ones(1:p));
+    dsys = syssetsignals(sys,"yd",ones(1:p));
   elseif(strcmp(opt,"ex"))
     # construct new state-space (a,b,c,d) for continuous subsystem
     [csys,Acd] = syscont(sys);   	# extract continuous subsystem
     [csys_a, csys_b, csys_c, csys_d] = sys2ss(csys);
     [ sys_a,  sys_b,  sys_c,  sys_d] = sys2ss( sys);
-    if(isempty(Acd))
-      Bmat = sys_b;
-    elseif(isempty(csys_b))
-      Bmat = Acd;
-    else
-      Bmat = [Acd csys_b];
-    endif
+    if(isempty(Acd))                Bmat = sys_b;
+    elseif(isempty(csys_b))         Bmat = Acd;
+    else                            Bmat = [Acd csys_b];     endif
     
     row_zer = columns(Bmat);
-    col_zer = csys.n + row_zer;
+    csysn = sysdimensions(csys);
+    col_zer = csysn + row_zer;
 
+    [csysa,csysb,csysc,csysd] = sys2ss(csys);
     if(isempty(Bmat) )
       warning("c2d: no inputs to continuous subsystem.");
-      mat = csys.a;
+      mat = csysa;
     else
-      mat = [csys.a Bmat ; zeros( row_zer,col_zer) ];
+      mat = [csysa Bmat ; zeros( row_zer,col_zer) ];
     endif
 
     matexp = expm(mat * T);
   
-    Abar = matexp( 1:csys.n , 1:(csys.n + columns(Acd)) );  
-    Bbar = matexp( 1:csys.n , (columns(Abar) + 1):columns(matexp) );
-
-    dsys = sys;
-
-    dsys.a(1:csys.n , : ) = Abar;
-    dsys.b(1:csys.n , : ) = Bbar;
-
-    dsys.sys = [2 0 0 1];
+    Abar = matexp( 1:csysn , 1:(csysn + columns(Acd)) );  
+    Bbar = matexp( 1:csysn , (columns(Abar) + 1):columns(matexp) );
 
-    dsys.tsam = T;
-    dsys.n = 0;
-    dsys.nz = rows(dsys.a);
-
-    dsys.yd = ones(1,rows(dsys.c));
-
-    for ii = 1:csys.n
-      strval = [dezero((dsys.stname(ii,:))),"_d"];
-      dsys.stname(ii,(1:length(strval))) = [strval];
+    newnz = rows(Abar);
+    outlist = ones(1,rows(csysc));
+    [stnames,innames,outnames] = sysgetsignals(csys);
+    dsys = ss2sys(Abar,Bbar,csysc,csysd,T,0,newnz,stnames,innames, ...
+	outnames,outlist);
+    # rename states
+    for ii=1:newnz
+      strval = sprintf("%s_d",sysgetsignals(dsys,"st",ii,1));
+      dsys = syssetsignals(dsys,"st",strval,ii);
     endfor
 
   elseif(strcmp(opt,"bi"))
     if(is_digital(sys))
       error("c2d: system is already digital")
     else
       # convert with bilinear transform
       [a,b,c,d,tsam,n,nz,stname,inname,outname,yd] = sys2ss(sys);
       IT = (2/T)*eye(size(a));
       A = (IT+a)/(IT-a);
       iab = (IT-a)\b;
       tk=2/sqrt(T);
       B = tk*iab;
       C = tk*(c/(IT-a));
       D = d + (c*iab);
-      stnamed="";
-      for kk=1:rows(stname)
-        tmp =  [dezero(stname(kk,:)),"_d"];
-        stnamed(kk,1:length(tmp)) = tmp;
-      endfor
+      stnamed = strappend(stname,"_d");
       dsys = ss2sys(A,B,C,D,T,0,rows(A),stnamed,inname,outname);
     endif
   else
     error(["Bad option=",opt])
   endif
   
   implicit_str_to_num_ok = save_val;	# restore value
 
diff --git a/scripts/control/com2str.m b/scripts/control/com2str.m
--- a/scripts/control/com2str.m
+++ b/scripts/control/com2str.m
@@ -20,17 +20,17 @@ function retval = com2str(zz,flg)
 # usage retval = com2str(zz{,flg})
 #  
 # convert complex number to a string
 # zz: complex number
 # flg: format flag
 #      0 (default):            -1, 0, 1,   1i,   1 + 0.5i
 #      1 (for use with zpout): -1, 0, + 1, + 1i, + 1 + 0.5i
 #
-# $Revision: 1.1 $
+# $Revision: 2.0.0.0 $
 
   if (nargin < 1 | nargin > 2)
     usage("com2str(zz{,flg})");
   endif
   if(nargin == 1)
     flg = 0;
   endif
  
diff --git a/scripts/control/controldemo.m b/scripts/control/controldemo.m
--- a/scripts/control/controldemo.m
+++ b/scripts/control/controldemo.m
@@ -16,17 +16,17 @@
 # along with Octave; see the file COPYING.  If not, write to the Free
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 function DEMOcontrol()
 # Controls toolbox demo.
 # Demo programs: bddemo.m, frdemo.m, analdemo.m, moddmeo.m, rldemo.m
 #  
 # Written by David Clem August 15, 1994
-# $Revision: 1.1 $    
+# $Revision: 2.0.0.0 $    
 
   disp(' O C T A V E    C O N T R O L   S Y S T E M S   T O O L B O X')
 
   while (1)
     clc
     k = 0;
     while (k > 8 || k < 1),
       k = menu("Octave Controls System Toolbox Demo", ...
diff --git a/scripts/control/ctrb.m b/scripts/control/ctrb.m
--- a/scripts/control/ctrb.m
+++ b/scripts/control/ctrb.m
@@ -30,33 +30,23 @@ function Qs = ctrb(sys, b)
   #       The numerical properties of is_controllable()
   #       are much better for controllability tests.
   # See also: obsv, is_observable, is_controllable
   # ------------------------------------------------------
 
   # Written by Kai P. Mueller November 4, 1997
   # based on is_controllable.m of Scottedward Hodel
   # modified by
-  # $Revision: 1.1.1.1 $
-  # $Log: ctrb.m,v $
-  # Revision 1.1.1.1  1998/05/19 20:24:06  jwe
-  #
-  # Revision 1.2  1997/12/01 16:51:50  scotte
-  # updated by Mueller 27 Nov 97
-  #
-# Revision 1.2  1997/11/25  11:15:54  mueller
-# name confict with function mb removed
-#
+  # $Revision: 2.0.0.0 $
 
   if (nargin == 2)
     a = sys;
   elseif (nargin == 1 && is_struct(sys))
     sysupdate(sys,"ss");
-    a = sys.a;
-    b = sys.b;
+    [a,b] = sys2ss(sys);
   else
     usage("ctrb(sys [, b])")
   endif
 
   if (!is_abcd(a,b))
     Qs = [];
   else
     # no need to check dimensions, we trust is_abcd().
diff --git a/scripts/control/d2c.m b/scripts/control/d2c.m
--- a/scripts/control/d2c.m
+++ b/scripts/control/d2c.m
@@ -48,32 +48,17 @@ function csys = d2c(sys,opt)
 #        .
 #        x = A1 x + B1 u
 #
 # The sample time used is that of the system. (see syschtsam).
   
 # Written by R. Bruce Tenison August 23, 1994
 # Updated by John Ingram for system data structure  August 1996
 # SYS_INTERNAL accesses members of system data structure
-# $Revision: 1.3 $ 
-# $Log: d2c.m,v $
-# Revision 1.3  1998/08/13 16:27:21  hodelas
-# Fixed warning message
-#
-# Revision 1.2  1998/07/01 16:23:36  hodelas
-# Updated c2d, d2c to perform bilinear transforms.
-# Updated several files per bug updates from users.
-#
-# Revision 1.4  1997/02/20 16:18:52  hodel
-# added warning about poles near 1.
-#
-# Revision 1.3  1997/02/20 16:07:26  hodel
-# Added gradient descent code so that d2c returns the same function
-# as c2d started with		a.s.hodel@eng.auburn.edu
-#
+# $Revision: 2.0.0.0 $ 
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
   if( (nargin != 1) & (nargin != 2) )
     usage("csys = d2c(sys[,tol]), csys = d2c(sys,opt)");
   elseif (!is_struct(sys))
     error("sys must be in system data structure");
@@ -89,19 +74,19 @@ function csys = d2c(sys,opt)
     error("tol must be a postive scalar")
   elseif(opt > 1e-2)
     warning(["d2c: ridiculous error tolerance passed=",num2str(opt); ...
 	", intended c2d call?"])
   else
     tol = opt;
     opt = "log";
   endif
-  T = sys.tsam;
+  T = sysgettsam(sys);
 
-  if(opt == "bi")
+  if(strcmp(opt,"bi"))
     # bilinear transform
     # convert with bilinear transform
     if (! is_digital(sys) )
        error("d2c requires a discrete time system for input")
     endif
     [a,b,c,d,tsam,n,nz,stname,inname,outname,yd] = sys2ss(sys);
 
     poles = eig(a);
@@ -111,29 +96,25 @@ function csys = d2c(sys,opt)
 
     I = eye(size(a));
     tk = 2/sqrt(T);
     A = (2/T)*(a-I)/(a+I);
     iab = (I+a)\b;
     B = tk*iab;
     C = tk*(c/(I+a));
     D = d- (c*iab);
-    stnamed="";
-    for kk=1:rows(stname)
-      tmp =  [dezero(stname(kk,:)),"_c"];
-      stnamec(kk,1:length(tmp)) = tmp;
-    endfor
+    stnamec = strappend(stname,"_c");
     csys = ss2sys(A,B,C,D,0,rows(A),0,stnamec,inname,outname);
-  elseif(opt == "log")
+  elseif(strcmp(opt,"log"))
     sys = sysupdate(sys,"ss");
     [n,nz,m,p] = sysdimensions(sys);
   
     if(nz == 0)
       warning("d2c: all states continuous; setting outputs to agree");
-      csys = syschnames(sys,"yd",1:p,zeros(1,1:p));
+      csys = syssetsignals(sys,"yd",zeros(1,1:p));
       return;
     elseif(n != 0)
       warning(["d2c: n=",num2str(n),">0; performing c2d first"]);
       sys = c2d(sys,T);
     endif
     [a,b] = sys2ss(sys);
   
     [ma,na] = size(a);
@@ -214,30 +195,25 @@ function csys = d2c(sys,opt)
       endif
   
       if(FmallErr == 0)
         eps1 = 0;
       endif
       
     endwhile
   
-    csys = sys;
-    csys.a = Mall(1:na,1:na);
+    [aa,bb,cc,dd,tsam,nn,nz,stnam,innam,outnam,yd] = sys2ss(sys);
+    aa = Mall(1:na,1:na);
     if(!isempty(b))
-      csys.b = Mall(1:na,(na+1):(na+nb));
+      bb = Mall(1:na,(na+1):(na+nb));
     endif
+    csys = ss2sys(aa,bb,cc,dd,0,na,0,stnam,innam,outnam);
     
-    csys.n = na;
-    csys.nz = 0;
-  
-    csys.sys = [2 0 0 1];
-  
-    csys.yd = zeros(1,rows(csys.c));
-    
-    for ii = (sys.n + 1):rows(sys.stname)
-      strval = [(csys.stname(ii,:)),"_c"];
-      csys.stname(ii,(1:length(strval))) = [strval];
+    # update names
+    nn = sysdimensions(sys);
+    for ii = (nn+1):na
+      strval = sprintf("%s_c",sysgetsignals(csys,"st",ii,1));
+      csys = syssetsignals(csys,"st",strval,ii);
     endfor
-    csys = syschtsam(csys,0);
   endif
 
   implicit_str_to_num_ok = save_val;	# restore value
 endfunction
diff --git a/scripts/control/damp.m b/scripts/control/damp.m
--- a/scripts/control/damp.m
+++ b/scripts/control/damp.m
@@ -24,26 +24,17 @@ function damp(p, tsam)
 #      If p is a system, tsam must not be specified.
 #      If p is a matrix and tsam is specified, eigenvalues
 #      of p are assumed to be in z-domain.
 #
 # See also: eig
 
 # Written by Kai P. Mueller September 29, 1997.
 # Update
-# $Revision: 1.1.1.1 $
-# $Log: damp.m,v $
-# Revision 1.1.1.1  1998/05/19 20:24:06  jwe
-#
-# Revision 1.3  1997/12/01 16:51:50  scotte
-# updated by Mueller 27 Nov 97
-#
-# Revision 1.1  1997/11/11  17:32:13  mueller
-# Initial revision
-#
+# $Revision: 2.0.0.0 $
 
   # assume a continuous system
   DIGITAL = 0;
   if(nargin < 1 || nargin > 2)
     usage("damp(p,[ tsamp])")
   endif
   if(is_struct(p))
     if (nargin != 1)
diff --git a/scripts/control/dare.m b/scripts/control/dare.m
--- a/scripts/control/dare.m
+++ b/scripts/control/dare.m
@@ -42,21 +42,17 @@
 ## opt is an option passed to the eigenvalue balancing routine default
 ## is "B".
 ##
 ## See also: balance, are
 
 ## Author: A. S. Hodel <scotte@eng.auburn.edu>
 ## Created: August 1993
 ## Adapted-By: jwe
-## $Revision: 1.15 $
-## $Log: dare.m,v $
-## Revision 1.15  1998-11-06 16:15:36  jwe
-## *** empty log message ***
-##
+## $Revision: 1.16 $
 
 function x = dare (a, b, c, r, opt)
 
   if (nargin == 4 | nargin == 5)
     if (nargin == 5)
       if (opt != "N" || opt != "P" || opt != "S" || opt != "B")
 	warning ("dare: opt has an invalid value -- setting to B");
 	opt = "B";
diff --git a/scripts/control/dcgain.m b/scripts/control/dcgain.m
--- a/scripts/control/dcgain.m
+++ b/scripts/control/dcgain.m
@@ -17,41 +17,36 @@
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 function gm = dcgain(sys, tol)
 # Usage: gm = dcgain(sys[, tol])
 #      Returns dc-gain matrix. If dc-gain is infinity
 #      an empty matrix is returned.
 #      The argument tol is an optional tolerance for the condition
 #      number of A-Matrix in sys (default tol = 1.0e-10)
+#      Prints a warning message of the system is unstable.
 #
-# See also: (nothing)
 
 # Written by Kai P Mueller (mueller@ifr.ing.tu-bs.de) October 1, 1997
-# Updated
-# $Revision: 1.1.1.1 $
-# $Log: dcgain.m,v $
-# Revision 1.1.1.1  1998/05/19 20:24:06  jwe
-#
-# Revision 1.3  1997/12/01 16:51:50  scotte
-# updated by Mueller 27 Nov 97
-#
-# Revision 1.1  1997/11/11  17:32:46  mueller
-# Initial revision
-#
+# $Revision: 2.0.0.0 $
 
   if((nargin < 1) || (nargin > 2) || (nargout > 1))
     usage("[gm, ok] = dcgain(sys[, tol])");
   endif
   if(!is_struct(sys))
     error("dcgain: first argument is not a system data structure.")
   endif
   sys = sysupdate(sys, "ss");
-  aa = sys.a;
+  [aa,bb,cc,dd] = sys2ss(sys);
   if (is_digital(sys))  aa = aa - eye(size(aa));  endif
   if (nargin == 1)  tol = 1.0e-10;  endif
   r = rank(aa, tol);
   if (r < rows(aa))
     gm = [];
   else
-    gm = -sys.c / aa * sys.b + sys.d;
+    gm = -cc / aa * bb + dd;
+  endif
+  if(!is_stable(sys))
+    [nn,nz,mm,pp] = sysdimensions(sys);
+    warning("dcgain: unstable system; dimensions [nc=%d,nz=%d,mm=%d,pp=%d]", ...
+      nn,nz,mm,pp);
   endif
 endfunction
diff --git a/scripts/control/dezero.m b/scripts/control/dezero.m
--- a/scripts/control/dezero.m
+++ b/scripts/control/dezero.m
@@ -21,64 +21,39 @@
 ##
 ## Remove trailing blank entries and all zero entries from the string s.
 
 ## Author: Kurt Hornik <Kurt.Hornik@ci.tuwien.ac.at>
 ## Adapted-By: jwe
 ## Adapted from deblank by A. S. Hodel (a.s.hodel@eng.auburn.edu)
 ## 	(the name dezero is a reference to the Fermilab D0 experiment,
 ##      where my sister did her PhD research) 
-## $Revision: 1.1.1.1 $
-## $Log: dezero.m,v $
-## Revision 1.1.1.1  1998/05/19 20:24:13  jwe
-##
-## Revision 1.3  1997/03/11 14:42:41  scotte
-## fixed implicit_str_to_num_ok bug a.s.hodel@eng.auburn.edu
-##
-## Revision 1.2  1997/03/03 22:52:20  hodel
-## fixed problem with conversion to/from numerical value
-## a.s.hodel@eng.auburn.edu
-##
-## Revision 1.1  1997/02/12 11:34:56  hodel
-## Initial revision
-##
-## Revision 1.3  1997/02/07 15:24:35  scotte
-## fixed to remove all null characters, then call deblank
-##
+## $Revision: 2.0.0.0 $
 
 function t = dezero (s)
 
+  # delete the next line if you're stubbornly going to use dezero.
+  error("dezero is no longer supported.");
+
   if (nargin != 1)
     usage ("dezero (s)");
   elseif (isstr (s))
 
     save_val = implicit_str_to_num_ok;
     implicit_str_to_num_ok = 1;
 
-    #disp("dezero: entry, s=")
-    #s
-    #disp("/dezero")
-
     [nr, nc] = size (s);
     len = nr * nc;
 
     if (len == 0)
       t = s;
     else
 
-      #disp("dezero: 1, s=")
-      #s
-      #disp("/dezero")
-
       s = reshape (s, 1, len);
 
-      #disp("dezero: 2, s=")
-      #s
-      #disp("/dezero")
-
       # need to remove zeros first, then call deblank
       s = 1*s;
       t = deblank(setstr(s(find(s != 0) )));
     endif
 
     implicit_str_to_num_ok = save_val;
 
   else
diff --git a/scripts/control/dgkfdemo.m b/scripts/control/dgkfdemo.m
--- a/scripts/control/dgkfdemo.m
+++ b/scripts/control/dgkfdemo.m
@@ -14,32 +14,17 @@
 # 
 # You should have received a copy of the GNU General Public License 
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function dgkfdemo()
 # Octave Controls toolbox demo: H2/Hinfinity options demos
 # Written by A. S. Hodel June 1995
-# $Revision: 1.2 $
-# $Log: dgkfdemo.m,v $
-# Revision 1.2  1998/08/24 15:50:06  hodelas
-# updated documentation
-#
-# Revision 1.1.1.1  1998/05/19 20:24:06  jwe
-#
-# Revision 1.5  1998/05/05 17:03:18  scotte
-# update 5 May 1998 by Kai Mueller
-#
-# Revision 1.2  1998/05/05  10:02:46  mueller
-# new H_inf demo (jet707 MIMO design)
-#
-# Revision 1.1  1998/05/05  09:59:28  mueller
-# Initial revision
-#
+# $Revision: 2.0.0.0 $
  
   save_val = page_screen_output;
   page_screen_output = 1;
   while (1)
     clc
     menuopt=0;
     while(menuopt > 10 || menuopt < 1)
       menuopt = menu('Octave H2/Hinfinity options demo', ...
@@ -103,17 +88,17 @@ function dgkfdemo()
       prompt
       help lqg
       disp("Example system")
       A = [0 1; .5 .5];
       B = [0 ; 2];
       G = eye(2)
       C = [1 1];
       sys = ss2sys(A,[B G],C);
-      sys = syschnames(sys,"in",1:3, \
+      sys = syssetsignals(sys,"in", ...
 		       ["control input"; "disturbance 1"; "disturbance 2"]);
       sysout(sys)
       prompt
       disp("Filtering/estimator parameters:")
       SigW = eye(2)
       SigV = 1
       prompt
       disp("State space (LQR) parameters Q and R are:")
@@ -204,23 +189,23 @@ function dgkfdemo()
       disp("u(t)-->o-->| 1/s^2 |-->o-> y1");
       disp("       ^   ---------   ^");
       disp("       |               |");
       disp("      w1(t)           w2(t)");
       disp(" ")
       disp("w enters the system through B1, u through B2")
       disp("z = [y1 ; y2] is obtained through C1, y=y1 through C2");
       disp(" ")
-      cmd = "A = [0 1; 0 0]; B1 = [0 0;1 0]; B2 = [0;1];";
+      cmd = "A = [0 1; 0 0];  B1 = [0 0;1 0]; B2 = [0;1];";
       disp(cmd)
       eval(cmd);
-      cmd = "C1 = [1 0; 0 0]; C2 = [1 0]; D11 = zeros(2);";
+      cmd = "C1 = [1 0; 0 0]; C2 = [1 0];    D11 = zeros(2);";
       disp(cmd)
       eval(cmd);
-      cmd = "D12 = [0;1]; D21 = [0 1]; D22 = 0; D = [D11 D12; D21 D22];";
+      cmd = "D12 = [0;1];    D21 = [0 1];    D22 = 0; D = [D11 D12; D21 D22];";
       disp(cmd)
       eval(cmd);
       disp("Design objective: compute U(s)=K(s)Y1(s) to minimize the closed")
       disp("loop impulse response from w(t) =[w1; w2] to z(t) = [y1; y2]");
       prompt
       disp("First: pack system:")
       cmd="Asys = ss2sys(A,[B1 B2], [C1;C2] , D);";
       run_cmd
@@ -263,23 +248,24 @@ function dgkfdemo()
       cmd = "Asys = ss2sys(A,B,C);";
       run_cmd
       disp('The infinity norm must be computed iteratively by')
       disp('binary search.  For this example, we select tolerance tol = 0.01, ')
       disp('min gain gmin = 1e-2, max gain gmax=1e4.')
       disp('Search quits when upper bound <= (1+tol)*lower bound.')
       cmd = "tol = 0.01; gmin = 1e-2; gmax = 1e+4;";
       run_cmd
-      cmd = "AsysH2 = hinfnorm(Asys,tol,gmin,gmax)"
+      cmd = "[AsysHinf,gmin,gmax] = hinfnorm(Asys,tol,gmin,gmax)"
       run_cmd
       disp("Check: look at max value of magntude Bode plot of Asys:");
       [M,P,w] = bode(Asys);
-      loglog(w,M);
       xlabel('Omega')
-      ylabel('|Asys(j omega)|')
+      ylabel('|Asys(j omega)| ')
+      grid();
+      semilogx(w,M);
       disp(["Max magnitude is ",num2str(max(M)), ...
 	", compared with gmin=",num2str(gmin)," and gmax=", ...
         num2str(gmax),"."])
       prompt
       disp('Example 2: unstable plant')
       cmd = "A = [0 1; 2 1]; B = [0 ; 1]; C = [1 0]; sys_poles = eig(A)";
       run_cmd
       disp("Pack into system format:")
@@ -305,28 +291,28 @@ function dgkfdemo()
       C2 = [1 0]
       D11 = zeros(2);
       D12 = [0;1];
       D21 = [0 1];
       D22 = 0;
       D = [D11 D12; D21 D22]
       prompt
       disp("First: pack system:")
-      cmd="Asys = ss2sys(A,[B1 B2], [C1;C2] , D)";
+      cmd="Asys = ss2sys(A,[B1 B2], [C1;C2] , D);";
       run_cmd
       prompt
       disp("Open loop multivariable Bode plot: (will take a moment)")
       cmd="bode(Asys);";
       run_cmd
       prompt
       disp("Controller design command: (only need 1st two output arguments)")
       gmax = 1000
       gmin = 0.1
       gtol = 0.01
-      cmd="[K,gain] = hinfsyn(Asys,1,1,gmin,gmax,gtol)";
+      cmd="[K,gain] = hinfsyn(Asys,1,1,gmin,gmax,gtol);";
       run_cmd
       disp("Check: close the loop and then compute h2norm:")
       prompt
       cmd="K_loop = sysgroup(Asys,K);";
       run_cmd
       cmd = "Kcl = sysconnect(K_loop,[3,4],[4,3]);";
       run_cmd
       cmd = "Kcl = sysprune(Kcl,[1,2],[1,2]);";
diff --git a/scripts/control/dgram.m b/scripts/control/dgram.m
--- a/scripts/control/dgram.m
+++ b/scripts/control/dgram.m
@@ -20,13 +20,13 @@ function m = dgram(a,b)
   # m = dgram(a,b)
   # Return controllability grammian of discrete time system
   #
   #  x(k+1) = a x(k) + b u(k)
   #
   # a m a' - m + b*b' = 0 
 
   # Written by A. S. Hodel July 1995
-  # $Revision: 1.11 $
+  # $Revision: 1.12 $
 
   # let dlyap do the error checking...
   m = dlyap(a,b*b');
 endfunction
diff --git a/scripts/control/dhinfdemo.m b/scripts/control/dhinfdemo.m
--- a/scripts/control/dhinfdemo.m
+++ b/scripts/control/dhinfdemo.m
@@ -35,17 +35,17 @@
 #	    -----| K |<-------
 #	         +---+
 #
 #	W1 and W2 are the robustness and performancs weighting
 #       functions
 
 # K. Mueller, <mueller@ifr.ing.tu-bs.de>
 # Technical University of Braunschweig, IfR
-# $Revision: 1.2 $  $Date: 1998/10/12 10:11:13 $
+# $Revision: 2.0.0.0 $  $Date: 1998/12/08 21:36:55 $
 #
 
 echo off
 disp(" ");
 disp("    --------------------------------------------------");
 disp("    Discrete H_infinity optimal control for the plant:");
 disp(" ");
 disp("	                   0.39958z + 0.14700");
diff --git a/scripts/control/dlqe.m b/scripts/control/dlqe.m
--- a/scripts/control/dlqe.m
+++ b/scripts/control/dlqe.m
@@ -40,17 +40,17 @@ function [l, m, p, e] = dlqe (a, g, c, s
 #   m = Ricatti equation solution
 #   p = the estimate error covariance after the measurement update
 #   e = closed loop poles of (A - L C)
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August, 1993.
 # Modified for discrete time by R. Bruce Tenison (btenison@eng.auburn.edu)
 # October, 1993
 
-# $Revision: 1.14 $
+# $Revision: 1.15 $
 
   if (nargin != 5 && nargin != 6)
     error ("dlqe: invalid number of arguments");
   endif
 
 # The problem is dual to the regulator design, so transform to dlqr call.
 
   if (nargin == 5)
diff --git a/scripts/control/dlqg.m b/scripts/control/dlqg.m
--- a/scripts/control/dlqg.m
+++ b/scripts/control/dlqg.m
@@ -42,37 +42,37 @@ function [K,Q,P,Ee,Er] = dlqg(A,B,C,G,Si
 #  A,B,C,G, or Sys: state space representation of system.  
 #  Sigw, Sigv: covariance matrices of independent Gaussian noise processes 
 #      (as above)
 #  Q, R: state, control weighting matrices for dlqr call respectively.  
 #
 # See also: lqg, dlqe, dlqr
 
 # Written by A. S. Hodel August 1995
-# $Revision: 1.2 $
+# $Revision: 2.0.0.0 $
 
 warning("dlqg: obsolete. use lqg instead (system data structure format)");
 
 if (nargin == 5)
   # system data structure format
   
   # check that it really is system data structure
   if(! is_struct(A) )
     error("dlqg: 5 arguments, first argument is not a system data structure structure")
   endif
 
   sys = sysupdate(sys,"ss");    # make sure in proper form
-  [ndstates,nin,nout] = abcddim(sys.a, sys.b, sys.c, sys.d);
+  [ncstates,ndstates,nin,nout] = sysdimensions(sys);
   if(ndstates == -1)
     error("this message should never appear: bad system dimensions");
   endif
 
-  if(sys.n)
+  if(ncstates)
     error("dlqg: system has continuous-time states (try lqg?)")
-  elseif(sys.nz < 1)
+  elseif(ndstates < 1)
     error("dlqg: system has no discrete time states")
   elseif(nin <= columns(Sigw))
     error(["dlqg: ",num2str(nin)," inputs provided, noise dimension is ", ...
 	num2str(columns(Sigw))])
   elseif(nout != columns(Sigv))
     error(["dlqg: number of outputs (",num2str(nout),") incompatible with ", ...
 	"dimension of Sigv (",num2str(columns(Sigv)),")"])
   endif
diff --git a/scripts/control/dlqr.m b/scripts/control/dlqr.m
--- a/scripts/control/dlqr.m
+++ b/scripts/control/dlqr.m
@@ -41,17 +41,17 @@ function [k, p, e] = dlqr (a, b, q, r, s
 # References:
 #   Anderson and Moore, Optimal Control: Linear Quadratic Methods,
 #     Prentice-Hall, 1990, pp. 56-58
 #   Kuo, Digital Control Systems, Harcourt Brace Jovanovich, 1992, 
 #     section 11-5-2.
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
 # Converted to discrete time by R. B. Tenison
 # (btenison@eng.auburn.edu) October 1993
-# $Revision: 1.15 $
+# $Revision: 1.16 $
 
   if (nargin != 4 && nargin != 5)
     error ("dlqr: invalid number of arguments");
   endif
 
 # Check a.
   if ((n = is_square (a)) == 0)
     error ("dlqr: requires 1st parameter(a) to be square");
diff --git a/scripts/control/dlyap.m b/scripts/control/dlyap.m
--- a/scripts/control/dlyap.m
+++ b/scripts/control/dlyap.m
@@ -29,17 +29,17 @@ function x = dlyap (a, b)
 # or
 #
 #  a' x a - x + b' b = 0
 #
 # whichever is appropriate.  Uses Schur decomposition as in Kitagawa
 # (1977).
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
-# $Revision: 1.13 $
+# $Revision: 1.14 $
 
   if ((n = is_square (a)) == 0)
     warning ("dlyap: a must be square");
   endif
 
   if ((m = is_square (b)) == 0)
     [n1, m] = size (b);
     if (n1 == n)
diff --git a/scripts/control/dmr2d.m b/scripts/control/dmr2d.m
--- a/scripts/control/dmr2d.m
+++ b/scripts/control/dmr2d.m
@@ -21,17 +21,18 @@ function [dsys,fidx] = dmr2d (sys, idx, 
 # Usage: [dsys,fidx] = dmr2d (sys, idx, sprefix, Ts2 {,cuflg})
 # convert a multirate digital system to a single rate digital system
 # states specified by idx, sprefix are sampled at Ts2, all others
 # are sampled at Ts1 = sysgettsam(sys).
 # inputs:
 #   sys: discrete time system;
 #        dmr2d exits with an error if sys is not discrete
 #   idx: list of states with sampling time sys.tsam (may be empty)
-#   sprefix: string prefix of states with sampling time sys.tsam (may be empty)
+#   sprefix: list of string prefixes of states with sampling time 
+#    sys.tsam (may be empty)
 #   Ts2: sampling time of states not specified by idx, sprefix
 #        must be an integer multiple of sys.tsam
 #   cuflg: "constant u flag" if cuflg is nonzero then the system inputs are 
 #        assumed to be constant over the revised sampling interval Ts2.
 #        Otherwise, since the inputs can change during the interval
 #        t in [k Ts2, (k+1) Ts2], an additional set of inputs is
 #        included in the revised B matrix so that these intersample inputs
 #        may be included in the single-rate system.
@@ -52,27 +53,17 @@ function [dsys,fidx] = dmr2d (sys, idx, 
 #
 #   fidx: indices of "formerly fast" states specified by idx and sprefix;
 #         these states are updated to the new slower) sampling interval
 #
 #
 #  WARNING: Not thoroughly tested yet; especially when cuflg == 0.
 
 # Adapted from c2d by a.s.hodel@eng.auburn.edu
-# $Log: dmr2d.m,v $
-# Revision 1.1  1998/07/21 14:40:55  hodelas
-# First attempt at multirate systems analysis
-#
-# Revision 1.2  1998/07/21 14:13:44  hodel
-# squaring A  to get a11^nstp
-#
-# Revision 1.1  1998/07/21 12:41:46  hodel
-# Initial revision
-#
-#
+
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
   # parse input arguments
   if(nargin != 4 | nargout > 2)
     usage("[dsys,fidx] = dmr2d (sys, idx, sprefix, Ts2 {,cuflg})");
 
   elseif (!is_struct(sys))
@@ -86,18 +77,18 @@ function [dsys,fidx] = dmr2d (sys, idx, 
       ") must be a vector"]);
 
   elseif (any(idx <= 0))
     idv = find(idx <= 0);
     ii = idv(1);
     error(["idx(",num2str(ii),")=",num2str(idx(ii)), ...
       "; entries of idx must be positive"]);
 
-  elseif(!(isstr(sprefix) | isempty(sprefix)))
-    error("sprefix must be a string or empty");
+  elseif(!(is_signal_list(sprefix) | isempty(sprefix)))
+    error("sprefix must be a signal list (see is_signal_list) or empty");
 
   elseif(!is_sample(Ts2))
     error(["Ts2=",num2str(Ts2),"; invalid sampling time"]);
 
   endif
 
   # optional argument: cuflg
   if(nargin <= 4)
@@ -126,24 +117,24 @@ function [dsys,fidx] = dmr2d (sys, idx, 
     fidx = [];
     dsys = sys;
     return
   elseif(isempty(sprefix))
     fidx = idx;
   else
     fidx = reshape(idx,1,length(idx));
     # find states whose name begins with any strings in sprefix.
-    ns = rows(sprefix);
+    ns = length(sprefix);
     for kk=1:ns
-      spk = dezero(sprefix(kk,:));  # get next prefix and length
+      spk = nth(sprefix,kk);  # get next prefix and length
       spl = length(spk);
 
       # check each state name
       for ii=1:nz
-        sti = dezero(stname(ii,:));  # compare spk with this state name
+        sti = nth(stname,ii);  # compare spk with this state name
         if(length(sti) >= spl)
           # if the prefix matches and ii isn't already in the list, add ii
           if(strcmp(sti(1:spl),spk) & !any(fidx == ii) ) 
             fidx = sort([fidx,ii]);
           endif
         endif
       endfor
     endfor
@@ -232,17 +223,17 @@ function [dsys,fidx] = dmr2d (sys, idx, 
 
     # similar for b1 block (checking for cuflg first!)
     b1w = a11*b1w;
     if(cuflg)
       b1b = b1b + b1w;        # update b1 block just like we did a12
     else
       b1b = [b1b, b1w];       # append new inputs
       newin = strappend(innamenz,["_d",num2str(kk-1)]);
-      inname = str2mat(inname,newin);
+      inname = append(inname,newin);
     endif
   endfor
 
   # reconstruct system and return
   da(bki,bki) = a11h;
   db(bki,1:columns(b1b)) = b1b;
   if(!isempty(bki2))
     da(bki,bki2) = a12b;
diff --git a/scripts/control/fir2sys.m b/scripts/control/fir2sys.m
--- a/scripts/control/fir2sys.m
+++ b/scripts/control/fir2sys.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1996 A. Scottedward Hodel 
+# Copyright (C) 1996,1998 A. Scottedward Hodel 
 #
 # This file is part of Octave. 
 #
 # Octave is free software; you can redistribute it and/or modify it 
 # under the terms of the GNU General Public License as published by the 
 # Free Software Foundation; either version 2, or (at your option) any 
 # later version. 
 # 
@@ -27,76 +27,35 @@ function sys = fir2sys (num,tsam,inname,
   #   inname: name of input signal 
   #   outname: name of output signal
   # outputs:  sys (system data structure)
    
   #  Written by R. Bruce Tenison  July 29, 1994
   #  Name changed to TF2SYS July 1995
   #  updated for new system data structure format July 1996
   # adapted from tf2sys july 1996
-  # $Revision: 1.1.1.1 $
+  # $Revision: 2.0.0.0 $
 
   save_val = implicit_str_to_num_ok;
   implicit_str_to_num_ok = 1;
 
   #  Test for the correct number of input arguments
-  if ((nargin < 2) || (nargin > 4))
+  if (nargin < 1 | nargin > 4)
     usage('sys=fir2sys(num[,tsam,inname,outname])');
-    return
   endif
 
-  # check input format 
-  if( !is_vector(num) )
-    error(['num (',num2str(rows(num)),'x',num2str(columns(num)), ...
-	') must be a vector'])
-  endif
-
+  # let tf2sys do the argument checking
   den = [1,zeros(1,length(num)-1)];
 
   # check sampling interval (if any)
-  if(nargin <= 1)
-    tsam = 1;		# default
-  elseif (isempty(tsam))
-    tsam = 1;
-  endif
-  if ( (! (is_scalar(tsam) && (imag(tsam) == 0) )) || (tsam <= 0) )
-    error('fir tsam must be a positive real scalar')
-  endif
+  if(nargin <= 1)               tsam = 1;		# default 
+  elseif (isempty(tsam))        tsam = 1;		endif
 
   #  Set name of input
-  if(nargin < 3)
-    inname = "u";
-  elseif(isempty(inname))
-    inname = "u";
-  endif
-  if (rows(inname) > 1)
-    warning(['fir2sys:,' num2str(rows(inname)),' input names given, 1st used.'])
-    inname = (inname(1,:));
-  endif
+  if(nargin < 3)  inname = sysdefioname(1,"u");        endif
 
   #  Set name of output
-  if(nargin < 4)
-    outname = "y";
-  elseif(isempty(outname))
-    outname = "y";
-  endif
-  if (rows(outname) > 1)
-    warning(['fir2sys: ',num2str(rows(outname)),...
-      ' output names given, 1st used.'])
-    outname = (outname(1,:));
-  endif
+  if(nargin < 4)  outname = sysdefioname(1,"y"); 	endif
+
+  sys = tf2sys(num,den,tsam,inname,outname);
   
-  sys.num = num;
-  sys.den = den;
-
-  #  Set the system vector:  active = 0(tf), updated = [1 0 0];
-  sys.sys = [0 1 0 0];
-
-  #  Set defaults
-  sys.tsam = tsam;
-  sys.inname = inname;
-  sys.outname = outname;
-  sys.nz = length(den)-1;
-  sys.n = 0;
-  sys.yd = 1;
-
   implicit_str_to_num_ok = save_val;
 endfunction
diff --git a/scripts/control/frdemo.m b/scripts/control/frdemo.m
--- a/scripts/control/frdemo.m
+++ b/scripts/control/frdemo.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1996 A. Scottedward Hodel 
+# Copyright (C) 1996,1998 A. Scottedward Hodel 
 #
 # This file is part of Octave. 
 #
 # Octave is free software; you can redistribute it and/or modify it 
 # under the terms of the GNU General Public License as published by the 
 # Free Software Foundation; either version 2, or (at your option) any 
 # later version. 
 #  
@@ -15,28 +15,29 @@
 # You should have received a copy of the GNU General Public License 
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function frdemo()
 # Octave Controls toolbox demo: Frequency Response demo
 # Written by David Clem August 15, 1994 
 
-# $Revision: 1.3 $
+# $Revision: 2.0.0.0 $
 # a s hodel: updated to match new order of ss2zp outputs
 # J Ingram:  updated for system data structure format August 1996
 
   disp("")
   clc
   j = 0;
-  while (j != 3)
+  while (j != 4)
     disp("");
     j = menu("Octave Controls Systems Toolbox Frequency Response Demo",...
              'Bode analysis (bode)',...
              'Nyquist analysis (nyquist)',...
+	     "Nichols analysis (nichols)", ...
              'Return to main demo menu');
    
     if (j == 1)
       k1 = 0;
       while (k1 != 4)
         disp("\n");
         clc
 
@@ -117,25 +118,30 @@ function frdemo()
           cmd = "bode(sys3,wrange);";
           run_cmd;
           prompt; 
 
           disp("")
           clc
       	  disp("\nExample #4, The state-space system from example 3 will be");
           disp("grouped with the system from example 2 to form a MIMO system");
-          disp("The commands to do this grouping are as follows:");
-          sys2=sysupdate(sys2,"ss");
-          [nn,nz,mm,pp] = sysdimensions(sys2);
-          sys2 = syschnames(sys2,"out",1:pp,"y_sys2");
-          sys2 = syschnames(sys2,"in",1:mm,"u_sys2");
-          sys2 = syschnames(sys2,"st",1:nn,sysdefioname(nn+nz,"x_sys2"));
+          disp("The commands to do this grouping are as follows (changing signal");
+          disp("names for clarity):");
+          cmd = "sys2 = syssetsignals(sys2,\"out\",\"y_sys2\");";
+          disp(cmd);  eval(cmd);
+          cmd = "sys2 = syssetsignals(sys2,\"in\",\"u_sys2\");";
+          disp(cmd);  eval(cmd);
+          cmd = "nn = sysdimensions(sys2);";
+          disp(cmd);  eval(cmd);
+          cmd = "[nn,nz] = sysdimensions(sys2);";
+          disp(cmd);  eval(cmd);
+          cmd = "sys2 = syssetsignals(sys2,\"st\",sysdefioname(nn+nz,\"x_sys2\"));";
+          disp(cmd);  eval(cmd);
           cmd = "sys_mimo = sysgroup(sys2,sys3);";
-          disp(cmd); 
-          eval(cmd);
+          disp(cmd); eval(cmd);
           disp("The resulting state-space system (after changing signal names");
           disp("in sys2) is");
           cmd = "sysout(sys_mimo)";
           eval(cmd);
           disp("\nNotice that there are now 2 inputs and 2 outputs, and that it did");
  	  disp("not matter what form the two systems were in when they were grouped.");
           disp(["\nTo view the system\'s bode plots, execute the",...
         	" following command:\n"])
@@ -247,24 +253,26 @@ function frdemo()
           cmd = "bode(sys3,wrange);";
           run_cmd;
           prompt;	  
           
           disp("")
           clc
           disp("\nExample #4, We will now examine a MIMO state-space system.  Systems");
           disp("two and three will be grouped.");
-          sys2=sysupdate(sys2,"ss");
-          [nn,nz,mm,pp] = sysdimensions(sys2);
-          sys2 = syschnames(sys2,"out",1:pp,"y_sys2");
-          sys2 = syschnames(sys2,"in",1:mm,"u_sys2");
-          sys2 = syschnames(sys2,"st",1:nn,sysdefioname(nn+nz,"x_sys2"));
+          cmd = "[nn,nz] = sysdimensions(sys2);";
+          disp(cmd); eval(cmd);
+          cmd = "sys2 = syssetsignals(sys2,\"out\",\"y_sys2\");";
+          disp(cmd); eval(cmd);
+          cmd = "sys2 = syssetsignals(sys2,\"in\",\"u_sys2\");";
+          disp(cmd); eval(cmd);
+          cmd = "sys2 = syssetsignals(sys2,\"st\",sysdefioname(nn+nz,\"x_sys2\"));";
+          disp(cmd); eval(cmd);
           cmd = "sys_mimo = sysgroup(sys2,sys3);";
-          disp(cmd);
-          eval(cmd);
+          disp(cmd); eval(cmd);
           cmd = "sysout(sys_mimo);";
           disp(cmd);
           eval(cmd);
           disp("\nTo view the system's bode plots, execute the following command:\n")
       	  cmd = "bode(sys_mimo);";
           run_cmd;
           prompt
 
@@ -396,24 +404,26 @@ function frdemo()
           run_cmd;	  
           prompt
 
           disp("")
           clc
           disp("Example #4,  Nyquist can be used for MIMO systems if the system has");
           disp("an equal number of inputs and outputs.  Otherwise, nyquist returns");
           disp("an error.  To examine a MIMO system, systems 2 and 3 will be grouped");
-          sys2=sysupdate(sys2,"ss");
-          [nn,nz,mm,pp] = sysdimensions(sys2);
-          sys2 = syschnames(sys2,"out",1:pp,"y_sys2");
-          sys2 = syschnames(sys2,"in",1:mm,"u_sys2");
-          sys2 = syschnames(sys2,"st",1:nn,sysdefioname(nn+nz,"x_sys2"));
+          cmd = "[nn,nz] = sysdimensions(sys2);";
+          disp(cmd); eval(cmd);
+          cmd = "sys2 = syssetsignals(sys2,\"out\",\"y_sys2\");";
+          disp(cmd); eval(cmd);
+          cmd = "sys2 = syssetsignals(sys2,\"in\",\"u_sys2\");";
+          disp(cmd); eval(cmd);
+          cmd = "sys2 = syssetsignals(sys2,\"st\",sysdefioname(nn+nz,\"x_sys2\"));";
+          disp(cmd); eval(cmd);
           cmd = "sys_mimo = sysgroup(sys2,sys3);";
-          disp(cmd);
-          eval(cmd);
+          disp(cmd); eval(cmd);
           cmd = "sysout(sys_mimo);";
           disp(cmd);
           eval(cmd);
           disp("\nTo view the system's nyquist plot, execute the following command:\n")
       	  cmd = "nyquist(sys_mimo);";
  	  run_cmd;
           prompt
           disp("\nTo view the nyquist plots for selected  channels, the command form changes:")
@@ -573,11 +583,14 @@ function frdemo()
                
         elseif( k2 == 3 )
           disp("\nMixed system nyquist analysis\n");
           disp("Nyquist exits with an error if it is passed a ""mixed"" system (one")
           disp("with both continuous and discrete states).  Use c2d or d2c to")
           disp("convert the system to either pure digital or pure continuous form");
         endif
       endwhile 
+    elseif (j == 3)
+      help nichols
+      prompt
     endif
   endwhile
 endfunction
diff --git a/scripts/control/freqchkw.m b/scripts/control/freqchkw.m
--- a/scripts/control/freqchkw.m
+++ b/scripts/control/freqchkw.m
@@ -16,17 +16,17 @@
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function USEW = freqchkw(w)
   # function USEW = freqchkw(w)
   # used by freqresp to check that input frequency vector is legal
 
   # A S Hodel July 1996
-  # $Revision: 1.1.1.1 $
+  # $Revision: 2.0.0.0 $
 
   if(isempty(w))
     USEW = 0;
   elseif(!is_vector(w))
     error(["w (",num2str(rows(w)),"x",num2str(columns(w)), ...
       "): must be [], a vector or a scalar"]);
   elseif( (max(abs(imag(w))) != 0) && (min(real(w)) <= 0) )
     error("w must have real positive entries");
diff --git a/scripts/control/freqresp.m b/scripts/control/freqresp.m
--- a/scripts/control/freqresp.m
+++ b/scripts/control/freqresp.m
@@ -23,17 +23,17 @@ function [ff,w] = freqresp(sys,USEW,w);
   # USEW returned by freqchkw 
   # w: optional, must be present if USEW is given
   #
   # returns: ff = vector of finite G(j*w) entries (or || G(j*w) || for MIMO)
   #          w = vector of frequencies used
   #      ff and w are both returned as row vectors
 
   #  Written by: R. Bruce Tenison July 11, 1994
-  # $Revision: 1.6 $
+  # $Revision: 2.0.0.0 $
   # SYS_INTERNAL accesses members of system data structure
 
   save_val = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
   # Check Args
   if( (nargin < 2) || (nargin > 4) )
     usage ("[ff,w] = freqresp(sys,USEW{,w})");
diff --git a/scripts/control/gram.m b/scripts/control/gram.m
--- a/scripts/control/gram.m
+++ b/scripts/control/gram.m
@@ -20,13 +20,13 @@ function m = gram(a,b)
   # m = gram(a,b)
   # Return controllability grammian of continuous time system
   #
   #  dx/dt = a x + b u
   #
   # a m + a' + b*b' = 0 
 
   # Written by A. S. Hodel 
-  # $Revision: 1.2 $
+  # $Revision: 2.0.0.0 $
 
   # let lyap do the error checking...
   m = lyap(a,b*b');
 endfunction
diff --git a/scripts/control/h2norm.m b/scripts/control/h2norm.m
--- a/scripts/control/h2norm.m
+++ b/scripts/control/h2norm.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1996 A. Scottedward Hodel 
+# Copyright (C) 1996,1998 A. Scottedward Hodel 
 #
 # This file is part of Octave. 
 #
 # Octave is free software; you can redistribute it and/or modify it 
 # under the terms of the GNU General Public License as published by the 
 # Free Software Foundation; either version 2, or (at your option) any 
 # later version. 
 # 
@@ -11,48 +11,49 @@
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
 # for more details.
 # 
 # You should have received a copy of the GNU General Public License 
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
-function out = h2norm(sys)
-  # Usage: out = h2norm(sys)
+function h2gain = h2norm(sys)
+  # Usage: h2gain = h2norm(sys)
   #
   # Computes the H2 norm system data structure (continuous time only)
   # sys = system data structure [see ss2sys()]
-  # returns out = Inf if system is unstable
+  # returns h2gain = Inf if system is unstable
   #
   # Reference:
   # Doyle, Glover, Khargonekar, Francis, "State Space Solutions to Standard
   # H2 and Hinf Control Problems", IEEE TAC August 1989
   #
 
   # A. S. Hodel Aug 1995
   # updated for system data structure by John Ingram November 1996
-  # $Revision: 1.2 $
+  # $Revision: 2.0.0.0 $
 
   if((nargin != 1))
-    usage("out = h2norm(sys)");
+    usage("h2gain = h2norm(sys)");
   elseif(!is_struct(sys))
     error("Sys must be in system data structure");
   end
   dflg = is_digital(sys);
 
   if(!is_stable(sys))
     warning("h2norm: unstable input system; returning Inf");
-    out = Inf;
+    h2gain = Inf;
   else
     # compute gain
     [a,b,c,d] = sys2ss(sys);
     if(dflg)
       M = dlyap(a,b*b');
     else
       M = lyap (a,b*b');
     endif
     if( min(real(eig(M))) < 0)
       error("h2norm: grammian not >= 0 (lightly damped modes?)")
     endif
-    out = sqrt(d'*d + trace(c*M*c'));
+
+    h2gain = sqrt(trace(d'*d + c*M*c'));
   endif
 endfunction
diff --git a/scripts/control/h2syn.m b/scripts/control/h2syn.m
--- a/scripts/control/h2syn.m
+++ b/scripts/control/h2syn.m
@@ -37,28 +37,17 @@ function [K,gain, Kc, Kf, Pc,  Pf] = h2s
   #    Kc: full information control (system data structure)
   #    Kf: state estimator (system data structure)
   #       WARNING: incorporation of the is_dgkf nonsingular transformations
   #       Ru and Ry into Kc and Kf has not been tested.  
   #    Pc: ARE solution matrix for regulator subproblem
   #    Pf: ARE solution matrix for filter subproblem
 
   # Updated for System structure December 1996 by John Ingram
-  # $Revision: 1.2 $
-  # $Log: h2syn.m,v $
-  # Revision 1.2  1998/07/01 16:23:36  hodelas
-  # Updated c2d, d2c to perform bilinear transforms.
-  # Updated several files per bug updates from users.
-  #
-  # Revision 1.4  1997/03/11 15:24:28  scotte
-  # fixed bugs in return system data structure signal names a.s.hodel@eng.auburn.edu
-  #
-  # Revision 1.3  1997/03/03 22:54:42  hodel
-  # fixed details for update to octave 2.0.x
-  # a.s.hodel@eng.auburn.edu
+  # $Revision: 2.0.0.0 $
 
   if ((nargin < 3) | (nargin > 4))
     usage("[K,gain, Kc, Kf, Pc, Pf] = h2syn(Asys,nu,ny[,tol])");
   elseif(nargin == 3 )
     [chkdgkf,dgs] = is_dgkf(Asys,nu,ny);
   elseif(nargin == 4)
     [chkdgkf,dgs] = is_dgkf(Asys,nu,ny,tol);
   endif
@@ -116,64 +105,47 @@ function [K,gain, Kc, Kf, Pc,  Pf] = h2s
   g1 = h2norm(Kc1);
   g2 = h2norm(Kf1);
   
   # compute optimal closed loop gain
   gain = sqrt ( g1*g1 + g2*g2 );
 
   if(nargout)
     Kst = strappend(Ast,"_K");
-    Kin = strappend(Aout((nout-ny+1):(nout),:),"_K");
-    Kout = strappend(Ain((nin-nu+1):(nin),:),"_K");
+    Kin = strappend(Aout((nout-ny+1):(nout)),"_K");
+    Kout = strappend(Ain((nin-nu+1):(nin)),"_K");
 
     # compute systems for return
     K = ss2sys(KA,-L2/Ru,Ry\F2,zeros(nu,ny),Atsam,ncstates,ndstates,Kst,Kin,Kout);
   endif
 
   if (nargout > 2)
     #system full information control state names
-    for ii=1:rows(Ast)
-      tmp = [dezero(Ast(ii,:)),"_FI"];
-      stname2(ii,1:length(tmp)) = tmp;
-    endfor
+    stname2 = strappend(Ast,"_FI");
 
    #system full information control input names
-    for ii=1:rows(Ast)
-      tmp = [dezero(Ast(ii,:)),"_FI_in"];
-      inname2(ii,1:length(tmp)) = tmp;
-    endfor
+   inname2 = strappend(Ast,"_FI_in");
  
     #system full information control output names
-    for ii=1:(rows(Aout)-ny)
-      tmp = [dezero(Aout(ii,:)),"_FI_out"];
-      outname2(ii,1:length(tmp)) = tmp;
-    endfor
+    outname2 = strappend(Aout(1:(nout-ny)),"_FI_out");
 
     nz = rows (Cz);
     nw = columns (Bw);
 
     Kc = ss2sys(AF2, In, CzF2, zeros(nz,nn), Atsam, ...
 	ncstates, ndstates, stname2, inname2, outname2);
   endif
 
   if (nargout >3)
     #fix system state estimator state names
-    for ii=1:rows(Ast)
-      tmp = [dezero(Ast(ii,:)),"_Kf"];
-      stname3(ii,1:length(tmp)) = tmp;
-    endfor
+    stname3 = strappend(Ast,"_Kf");
 
     #fix system state estimator input names
-    for ii=1:rows(Ast)
-      tmp = [dezero(Ast(ii,:)),"_Kf_noise"];
-      inname3(ii,1:length(tmp)) = tmp;
-    endfor
+    inname3 = strappend(Ast,"_Kf_noise");
 
     #fix system state estimator output names
-    for ii=1:rows(Ast)
-      tmp = [dezero(Ast(ii,:)),"_est"];
-      outname3(ii,1:length(tmp)) = tmp;
-    endfor
+    outname3 = strappend(Ast,"_est");
 
     Kf = ss2sys(AL2, BwL2, In, zeros(nn,nw),Atsam,  ...
       ncstates, ndstates, stname3, inname3,outname3);
   endif
+
 endfunction
diff --git a/scripts/control/hinf_ctr.m b/scripts/control/hinf_ctr.m
--- a/scripts/control/hinf_ctr.m
+++ b/scripts/control/hinf_ctr.m
@@ -26,24 +26,21 @@ function K = hinf_ctr(dgs,F,H,Z,g)
   #           F, H:         feedback and filter gain (not partitioned)
   #           g:            final gamma value
   # outputs: 
   #           controller K (system data structure)
   #
   # Do not attempt to use this at home; no argument checking performed.
 
   # A. S. Hodel August 1995
-  # $Revision: 1.2 $
+  # $Revision: 2.0.0.0 $
   # Revised by Kai P Mueller April 1998 to solve the general H_infinity
   # problem using unitary transformations Q (on w and z)
   # and non-singular transformations R (on u and y).
-  # $Revision: 1.2 $
-  # $Log: hinf_ctr.m,v $
-  # Revision 1.2  1998/07/10 21:44:31  hodelas
-  # d11 -> D11 (was uninitialized)
+  # $Revision: 2.0.0.0 $
 
   nw = dgs.nw;
   nu = dgs.nu;
   nz = dgs.nz;
   ny = dgs.ny;
   d22nz = dgs.Dyu_nz;
   
   B1  = dgs.Bw;
diff --git a/scripts/control/hinfdemo.m b/scripts/control/hinfdemo.m
--- a/scripts/control/hinfdemo.m
+++ b/scripts/control/hinfdemo.m
@@ -94,45 +94,17 @@
 #	    -----| K |<-------
 #	         +---+
 #
 #	W1 and W2 are the robustness and performancs weighting
 #       functions
 
 
 # Kai P. Mueller 30-APR-1998 <mueller@ifr.ing.tu-bs.de
-# $Revision: 1.3 $
-# $Log: hinfdemo.m,v $
-# Revision 1.3  1998/10/12  13:59:16  mueller
-# discrete examples added
-#
-# Revision 1.2  1998/10/12  10:09:40  mueller
-# SISO example added, the augmented plant has one input
-# and two output.
-#
-# Revision 1.1  1998/10/12  08:52:21  mueller
-# Initial revision
-#
-# Revision 1.1.1.1  1998/05/19 20:24:06  jwe
-#
-# Revision 1.1  1998/05/05 17:03:42  scotte
-# Initial revision
-#
-# Revision 1.4  1998/05/05  09:49:19  mueller
-# comment corrections
-#
-# Revision 1.3  1998/05/05  08:46:27  mueller
-# comments added
-#
-# Revision 1.2  1998/05/04  17:49:56  mueller
-# miscellaneous cleanup
-#
-# Revision 1.1  1998/05/04  15:10:34  mueller
-# Initial revision
-#
+# $Revision: 2.0.0.0 $
 
 yn = [];
 while (length(yn) < 1)
   yn = input(" * [s]iso, [m]imo, or [d]iscrete design? [no default]: ","S");
 endwhile
 if ((yn(1) == "s") | (yn(1) == 'S'))
   sys_type = 1;
 elseif ((yn(1) == "m") | (yn(1) == 'M'))
diff --git a/scripts/control/hinfnorm.m b/scripts/control/hinfnorm.m
--- a/scripts/control/hinfnorm.m
+++ b/scripts/control/hinfnorm.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1996 A. Scottedward Hodel 
+# Copyright (C) 1996,1998 A. Scottedward Hodel 
 #
 # This file is part of Octave. 
 #
 # Octave is free software; you can redistribute it and/or modify it 
 # under the terms of the GNU General Public License as published by the 
 # Free Software Foundation; either version 2, or (at your option) any 
 # later version. 
 # 
@@ -34,17 +34,17 @@ function [g gmin gmax] = hinfnorm(sys,to
   #       Default: 1e-9
   #
   # References:
   # Doyle, Glover, Khargonekar, Francis, "State space solutions to standard
   #    H2 and Hinf control problems", IEEE TAC August 1989
   # Iglesias and Glover, "State-Space approach to discrete-time Hinf control,"
   #    Int. J. Control, vol 54, #5, 1991
   # Zhou, Doyle, Glover, "Robust and Optimal Control," Prentice-Hall, 1996
-  # $Revision: 1.6 $
+  # $Revision: 2.0.0.0 $
 
   if((nargin == 0) || (nargin > 4))
     usage("[g gmin gmax] = hinfnorm(sys[,tol,gmin,gmax,ptol])");
   elseif(!is_struct(sys))
     error("Sys must be a system data structure");
   endif
 
   # set defaults where applicable
@@ -59,16 +59,17 @@ function [g gmin gmax] = hinfnorm(sys,to
   sys = sysupdate(sys,"ss");
   [A,B,C,D] = sys2ss(sys);
   [n,nz,m,p] = sysdimensions(sys);
 
   # eigenvalues of A must all be stable
   if(!is_stable(sys))
     warning(["hinfnorm: unstable system (is_stable, ptol=",num2str(ptol), ...
       "), returning Inf"]);
+    g = Inf;
   endif
 
   Dnrm = norm(D);
   if(nargin < 3)
     gmin = max(1e-9,Dnrm); 	# min gain value
   elseif(gmin < Dnrm)
     warning(["hinfnorm: setting Gmin=||D||=",num2str(Dnrm)]);
   endif
diff --git a/scripts/control/hinfsyn.m b/scripts/control/hinfsyn.m
--- a/scripts/control/hinfsyn.m
+++ b/scripts/control/hinfsyn.m
@@ -51,42 +51,22 @@ function [K,g,GW,Xinf,Yinf] = hinfsyn(As
   #        g:   designed gain value
   #       GW:   closed loop system
   #     Xinf:   ARE solution matrix for regulator subproblem
   #     Yinf:   ARE solution matrix for filter subproblem
 
 
   # A. S. Hodel August 1995
   # Updated for Packed system structures December 1996 by John Ingram
-  # $Revision: 1.5 $
+  # $Revision: 2.0.0.0 $
   #
   # Revised by Kai P Mueller April 1998 to solve the general H_infinity
   # problem using unitary transformations Q (on w and z)
   # and non-singular transformations R (on u and y).
-  # $Revision: 1.5 $
-  # $Log: hinfsyn.m,v $
-  # Revision 1.5  1998/08/24 15:50:10  hodelas
-  # updated documentation
-  #
-  # Revision 1.3  1998/07/01 16:23:37  hodelas
-  # Updated c2d, d2c to perform bilinear transforms.
-  # Updated several files per bug updates from users.
-  #
-  # Revision 1.2  1998/06/25 12:35:38  hodelas
-  # fixed controller input/output signal name code
-  #
-  # Revision 1.4  1998/06/25 12:40:35  hodel
-  # fixed error in input/output names in the controller
-  #
-  # Revision 1.3  1998/05/05 17:03:59  scotte
-  # update 5 May 1998 by Kai Mueller
-  #
-# Revision 1.2  1998/05/05  08:57:16  mueller
-# comments added
-#
+  # $Revision: 2.0.0.0 $
 
   old_page_val = page_screen_output;
   page_screen_output = 0;
 
   if( (nargin < 1) | (nargin > 8) )
     usage("[K,g,GW,Xinf,Yinf] = hinfsyn(Asys,nu,ny,gmin,gmax,gtol,ptol,tol)");
   endif
   # set default arguments
@@ -365,18 +345,18 @@ function [K,g,GW,Xinf,Yinf] = hinfsyn(As
       printf("----------------------------------------");
       printf("--------------------------------------\n");
       Z = inv(eye(ncstates) - Yinf*Xinf/g/g);
       F = -R \ (d1dot'*C1 + BB'*Xinf);
       H = -(B1*ddot1' + Yinf*CC') / Rtilde;
       K = hinf_ctr(dgs,F,H,Z,g);
 
       Kst = strappend(Ast,"_K");
-      Kin = strappend(Aout((nout-ny+1):(nout),:),"_K");
-      Kout = strappend(Ain((nin-nu+1):(nin),:),"_K");
+      Kin = strappend(Aout((nout-ny+1):(nout)),"_K");
+      Kout = strappend(Ain((nin-nu+1):(nin)),"_K");
       [Ac, Bc, Cc, Dc] = sys2ss(K);
       K = ss2sys(Ac,Bc,Cc,Dc,Atsam,ncstates,ndstates,Kst,Kin,Kout);
       if (nargout >= 3)
 	GW = starp(Asys, K);
       endif
     endif
     
   elseif(ndstates)
diff --git a/scripts/control/hinfsyn_chk.m b/scripts/control/hinfsyn_chk.m
--- a/scripts/control/hinfsyn_chk.m
+++ b/scripts/control/hinfsyn_chk.m
@@ -30,17 +30,17 @@ function [retval,Pc,Pf] = hinfsyn_chk(A,
   # outputs: 
   #   retval: = 1 if g exceeds optimal Hinf closed loop gain, else 0
   #   Pc: solution of "regulator" H-inf ARE
   #   Pf: solution of "filter" H-inf ARE
   #
   # Do not attempt to use this at home; no argument checking performed.
 
   # A. S. Hodel August 1995
-  # $Revision: 1.1 $
+  # $Revision: 2.0.0.0 $
 
   Pc = Pf = [];
 
   # Construct the two Hamiltonians
   g2 = 1/(g*g);
   Hc = [ A ,  g2*B1*B1' - B2*B2'; -C1'*C1 , -A'];
   Hf = [ A' , g2*C1'*C1 - C2'*C2; -B1*B1' , -A];
 
diff --git a/scripts/control/impulse.m b/scripts/control/impulse.m
--- a/scripts/control/impulse.m
+++ b/scripts/control/impulse.m
@@ -31,26 +31,17 @@ function [y, t] = impulse(sys, inp, tsto
 # When the step function is invoked with the output parameter y
 # a plot is not displayed.
 #
 # See also: step, stepimp
 
 # Written by Kai P. Mueller October 2, 1997
 # based on lsim.m of Scottedward Hodel
 # modified by
-# $Revision: 1.1.1.1 $
-# $Log: impulse.m,v $
-# Revision 1.1.1.1  1998/05/19 20:24:07  jwe
-#
-# Revision 1.3  1997/12/01 16:51:50  scotte
-# updated by Mueller 27 Nov 97
-#
-# Revision 1.1  1997/11/11  17:33:06  mueller
-# Initial revision
-#
+# $Revision: 2.0.0.0 $
 
   if((nargin < 1) || (nargin > 4))
     usage("[y, u] = impulse(sys[, inp, tstop, n])");
   endif
 
   if(nargout > 2)
     usage("[y, u] = impulse(sys[, inp, tstop, n])");
   endif
diff --git a/scripts/control/is_abcd.m b/scripts/control/is_abcd.m
--- a/scripts/control/is_abcd.m
+++ b/scripts/control/is_abcd.m
@@ -24,26 +24,17 @@ function retval = is_abcd(a, b, c, d)
   # The matrices b, c, or d may be omitted.
   # ------------------------------------------------------
   # 
   # see also: abcddim
 
   # Written by Kai P. Mueller November 4, 1997
   # based on is_controllable.m of Scottedward Hodel
   # modified by
-  # $Revision: 1.1.1.1 $
-  # $Log: is_abcd.m,v $
-  # Revision 1.1.1.1  1998/05/19 20:24:07  jwe
-  #
-  # Revision 1.1  1997/12/01 16:51:50  scotte
-  # Initial revision
-  #
-# Revision 1.1  1997/11/25  11:17:41  mueller
-# Initial revision
-#
+  # $Revision: 2.0.0.0 $
 
   retval = 0;
   switch (nargin)
     case (1)
       # A only
       [na, ma] = size(a);
       if (na != ma)
         disp("Matrix A ist not square.")
diff --git a/scripts/control/is_controllable.m b/scripts/control/is_controllable.m
--- a/scripts/control/is_controllable.m
+++ b/scripts/control/is_controllable.m
@@ -32,23 +32,22 @@ function [retval,U] = is_controllable (a
 # tol is a roundoff paramter, set to 10*eps if omitted.
 #
 # See also: size, rows, columns, length, is_matrix, is_scalar, is_vector
 #     is_observable, is_stabilizable, is_detectable, krylov, krylovb
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August, 1993.
 # Updated by A. S. Hodel (scotte@eng.auburn.edu) Aubust, 1995 to use krylovb 
 # Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 for packed systems
-# SYS_INTERNAL accesses members of packed system structure
-# $Revision: 1.14 $
+# $Revision: 1.15 $
 
   deftol = 1;    # assume default tolerance
   if(nargin < 1 | nargin > 3)
-    usage(sprintf("[retval,U] = %s\n\t%s", "is_controllable(a {, b ,tol})", ...
-	"is_controllable(sys{,tol})"));
+    usage("[retval,U] = %s\n\t%s", "is_controllable(a {, b ,tol})", ...
+	"is_controllable(sys{,tol})");
   elseif(is_struct(a))
     # system structure passed.
     sys = sysupdate(a,"ss");
     [a,bs] = sys2ss(sys);
     if(nargin > 2)
       usage("[retval,U] = is_controllable(sys{,tol})");
     elseif(nargin == 2)
       tol = b;		% get tolerance
@@ -63,33 +62,35 @@ function [retval,U] = is_controllable (a
       deftol = 1;
     endif
   endif
 
   # check for default tolerance
   if(deftol) tol = 1000*eps; endif
 
   # check tol dimensions
-  if( !is_sample(tol) )
-    error("is_controllable: tol must be a positive scalar!");
+  if( !is_scalar(tol) )
+    error("is_controllable: tol(%dx%d) must be a scalar", ...
+	rows(tol),columns(tol));
+  elseif( !is_sample(tol) )
+    error("is_controllable: tol=%e must be positive",tol);
   endif
 
   # check dimensions compatibility
   n = is_square (a);
   [nr, nc] = size (b);
 
   if (n == 0 | n != nr | nc == 0)
-    warning(["is_controllable: a=(",num2str(rows(a)),"x", ...
-      num2str(columns(a)),"), b=(",num2str(nr),"x",num2str(nc),")"])
+    warning("is_controllable: a=(%dx%d), b(%dx%d)",rows(a),columns(a),nr,nc);
     retval = 0;
   else
     # call block-krylov subspace routine to get an orthogonal basis
     # of the controllable subspace.
     if(nc == 1)
-      [U,H,Ucols] = krylov(a,b,n,tol);
+      [U,H,Ucols] = krylov(a,b,n,tol,1);
       U = U(:,1:Ucols);
     else
       [U,Ucols] = krylovb(a,b,n,tol);
       U = U(:,1:Ucols);
     endif
 
     retval = (Ucols == n);
   endif
diff --git a/scripts/control/is_detectable.m b/scripts/control/is_detectable.m
--- a/scripts/control/is_detectable.m
+++ b/scripts/control/is_detectable.m
@@ -26,31 +26,28 @@ function [retval,U] = is_detectable (a,c
 #
 # Returns 1 if the system, a, is detectable, 1 if the pair (a, c) is 
 # detectable, or 0 if not.
 #
 # See also: size, rows, columns, length, is_matrix, is_scalar, is_vector.
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
 # Updated by John Ingram (ingraje@eng.auburn.edu) July 1996.
-# SYS_INTERNAL accesses members of system structure
-# $Revision: 1.1.1.1 $ 
+# $Revision: 2.0.0.0 $ 
 
   if( nargin < 1) 
     usage("[retval,U] = is_detectable(a , c {, tol})");
   elseif(is_struct(a))
     # system form
     if(nargin == 2)
       tol = c;
     elseif(nargin > 2)
       usage("[retval,U] = is_detectable(sys {, tol})");
     endif
-    a = sysupdate(a,"ss");
-    c = a.c;
-    a = a.a;
+    [a,b,c] = sys2ss(a);
   elseif(nargin > 3)
     usage("[retval,U] = is_detectable(a , c {, tol})");
   endif
   if(exist("tol"))
     [retval,U] = is_stabilizable (a', c', tol);
   else
     [retval,U] = is_stabilizable (a', c');
   endif
diff --git a/scripts/control/is_dgkf.m b/scripts/control/is_dgkf.m
--- a/scripts/control/is_dgkf.m
+++ b/scripts/control/is_dgkf.m
@@ -65,17 +65,17 @@ function [retval,dgkf_struct] = is_dgkf(
   #     and relations to risk sensitivity,"
   #     Systems & Control Letters 11, Oct. 1988, pp 167-172.
   # [4] P. A. Iglesias and K. Glover, "State-space approach to discrete-time
   #     H-infinity control."  Int. J. Control, 1991, V. 54, #5, 1031-1073.
   #
   
   #  Written by A. S. Hodel
   #  Updated by John Ingram July 1996 to accept structured systems
-  #  $Revision: 1.7 $
+  #  $Revision: 2.0.0.0 $
   #
   # Revised by Kai P Mueller April 1998 to solve the general H_infinity
   # problem using unitary transformations Q (on w and z)
   # and non-singular transformations R (on u and y) such
   # that the Dzu and Dyw matrices of the transformed plant
   #
   #    ~
   #    P  (the variable Asys here)
@@ -87,27 +87,17 @@ function [retval,dgkf_struct] = is_dgkf(
   #     12   12  12  12
   #
   #    ~            T
   #    D  = R   D   Q   = [ 0 I ] or [ I ].
   #     21   21  21  21
   #
   # This transformation together with the algorithm in [1] solves
   # the general problem (see [2] for example). 
-  # $Revision: 1.7 $
-  # $Log: is_dgkf.m,v $
-  # Revision 1.7  1998/08/19 19:11:18  hodelas
-  # uniform interface for is_dgkf among h2syn, hinfsyn
-  #
-  # Revision 1.6  1998/07/13 21:05:03  hodelas
-  # Updated for discrete time systems
-  #
-  # fixed typo in error messages; use system functions instead of
-  #   direct access to system structure
-  #
+  # $Revision: 2.0.0.0 $
 
   if (nargin < 3) | (nargin > 4)
     usage("[retval,dgkf_struct] = is_dgkf(Asys,nu,ny{,tol})");
   elseif (! is_scalar(nu) | ! is_scalar(ny) )
     error("is_dgkf: arguments 2 and 3 must be scalars")
   elseif (! is_struct(Asys) )
     error("Argument 1 must be a system data structure");
   endif
diff --git a/scripts/control/is_digital.m b/scripts/control/is_digital.m
--- a/scripts/control/is_digital.m
+++ b/scripts/control/is_digital.m
@@ -17,23 +17,26 @@
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function DIGITAL = is_digital(sys)
 # function DIGITAL = is_digital(sys)
 # retrurn nonzero if system is digital
 # exits with an error of sys is a mixed (continuous and discrete) system
 
 # a s hodel July 1996
-# $Revision: 1.1.1.1 $
+# $Revision: 2.0.0.0 $
 # SYS_INTERNAL accesses members of system structure
 
   # checked for sampled data system (mixed)
   # discrete system
-  cont = sum(sys.yd == 0) + sys.n;
-  dig = sum(sys.yd != 0) + sys.nz + sys.tsam;
+  sysyd = sysgetsignals(sys,"yd");
+  [nn,nz] = sysdimensions(sys);
+  cont = sum(sysyd == 0) + nn;
+  tsam = sysgettsam(sys);
+  dig = sum(sysyd != 0) + nz + tsam;
   if( cont*dig != 0)
    sysout(sys);
    error("continuous/discrete system; use syscont, sysdisc, or c2d first");
   else
-    DIGITAL = (sys.tsam > 0);
+    DIGITAL = (tsam > 0);
   endif
  
 endfunction
diff --git a/scripts/control/is_observable.m b/scripts/control/is_observable.m
--- a/scripts/control/is_observable.m
+++ b/scripts/control/is_observable.m
@@ -26,31 +26,28 @@ function [retval,U] = is_observable (a,c
 #
 # Returns 1 if the system, a, is observable, 1 if the pair (a, c) is 
 # observable, or 0 if not.
 #
 # See also: size, rows, columns, length, is_matrix, is_scalar, is_vector.
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
 # Updated by John Ingram (ingraje@eng.auburn.edu) July 1996.
-# SYS_INTERNAL accesses members of system structure
-# $Revision: 1.14 $ 
+# $Revision: 1.15 $ 
 
   if( nargin < 1) 
     usage("[retval,U] = is_observable(a , c {, tol})");
   elseif(is_struct(a))
     # system form
     if(nargin == 2)
       tol = c;
     elseif(nargin > 2)
       usage("[retval,U] = is_observable(sys {, tol})");
     endif
-    a = sysupdate(a,"ss");
-    c = a.c;
-    a = a.a;
+    [a,b,c] = sys2ss(a);
   elseif(nargin > 3)
     usage("[retval,U] = is_observable(a , c {, tol})");
   endif
   if(exist("tol"))
     [retval,U] = is_controllable (a', c', tol);
   else
     [retval,U] = is_controllable (a', c');
   endif
diff --git a/scripts/control/is_sample.m b/scripts/control/is_sample.m
--- a/scripts/control/is_sample.m
+++ b/scripts/control/is_sample.m
@@ -17,13 +17,13 @@
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function out = is_sample(Ts)
 #
 # out = is_sample(Ts): return true if Ts is a legal sampling time
 # (real,scalar, > 0)
 
 # A. S. Hodel July 1995
-# $Revision: 1.1 $
+# $Revision: 2.0.0.0 $
 
 out = (is_scalar(Ts) && (Ts == abs(Ts)) && (Ts != 0) );
 
 endfunction
diff --git a/scripts/control/is_siso.m b/scripts/control/is_siso.m
--- a/scripts/control/is_siso.m
+++ b/scripts/control/is_siso.m
@@ -16,17 +16,17 @@
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function  SISO = is_siso(sys)
 # function SISO = is_siso(sys)
 # return nonzero if the system sys is single-input, single-output.
 
 # a s hodel July 1996, 1998
-# $Revision: 1.2 $
+# $Revision: 2.0.0.0 $
 # SYS_INTERNAL accesses members of system structure
 
   if(nargin != 1)
     usage("SISO = is_siso(sys)");
   elseif( !is_struct(sys))
     error("input must be a system structure (see ss2sys, tf2sys, zp2sys)");
   endif
 
diff --git a/scripts/control/is_stabilizable.m b/scripts/control/is_stabilizable.m
--- a/scripts/control/is_stabilizable.m
+++ b/scripts/control/is_stabilizable.m
@@ -28,67 +28,53 @@ function [retval,U] = is_stabilizable (a
 # complete re-orthogonalization to obtain an orthogonal basis of the
 # Krylov subspace.
 #
 #   span ([b,a*b,...,a^   b]).
 #
 # tol is a roundoff paramter, set to 200*eps if omitted.
 #
 # See also: size, rows, columns, length, is_matrix, is_scalar, is_vector
-#     is_observable, is_stabilizable, is_detectable, krylov, krylovb
+#     is_observable, is_stabilizable, is_detectable
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August, 1993.
 # Updated by A. S. Hodel (scotte@eng.auburn.edu) Aubust, 1995 to use krylovb 
 # Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 to accept systems
-# SYS_INTERNAL accesses members of system structure
-# $Revision: 1.1.1.1 $
+# $Revision: 2.0.0.0 $
 
-  if(nargin < 1)
-    usage("[retval,U] = is_stabilizable(a {, b ,tol})");
+  if(nargin < 1)        usage("[retval,U] = is_stabilizable(a {, b ,tol})");
   elseif(is_struct(a))
     # sustem passed.
     if(nargin == 2)
       tol = b;          % get tolerance
     elseif(nargin > 2)
       usage("[retval,U] = is_stabilizable(sys{,tol})");
     endif
-    sys = sysupdate(a,"ss");
-    a = sys.a;
-    b = sys.b;
+    [a,b] = sys2ss(sys);
   else
     # a,b arguments sent directly.
     if(nargin > 3)
       usage("[retval,U] = is_stabilizable(a {, b ,tol})");
     endif
   endif
 
   if(exist("tol"))
     [retval,U] = is_controllable(a,b,tol);
   else
     [retval,U] = is_controllable(a,b);
     tol = 1e2*rows(b)*eps;
   endif
   
-  #disp("is_stabilzable: is_controllable returns")
-  #retval
-  #U
-  #disp("/is_stabilzable: is_controllable returns")
-
   if( !retval & columns(U) > 0)
     # now use an ordered Schur decomposition to get an orthogonal
     # basis of the unstable subspace...
     n = rows(a);
     [ua,s] = schur(-(a+eye(n)*tol),'A');
     k = sum( real(eig(a)) >= 0 );	# count unstable poles 
 
-    #disp("is_stabilizable: unstable poles found:")
-    #k
-    #s
-    #disp("/is_stabilizable: unstable poles found:")
-    
     if( k > 0 )
       ua = ua(:,1:k);
       # now see if span(ua) is contained in span(U)
       retval = (norm(ua - U*U'*ua) < tol);
     else
       retval = 1;			# all poles stable
     endif
   endif
diff --git a/scripts/control/is_stable.m b/scripts/control/is_stable.m
--- a/scripts/control/is_stable.m
+++ b/scripts/control/is_stable.m
@@ -26,48 +26,39 @@ function retval = is_stable (a, tol, dis
 # tol is a roundoff paramter, set to 200*eps if omitted.
 # disc != 0: stable if eig(a) in unit circle
 #         0: stable if eig(a) in open LHP (default)
 #
 # See also: size, rows, columns, length, is_matrix, is_scalar, is_vector
 #     is_observable, is_stabilizable, is_detectable, krylov, krylovb
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August, 1993.
-# Updated by A. S. Hodel (scotte@eng.auburn.edu) Aubust, 1995 to use krylovb 
 # Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 for systems
-# SYS_INTERNAL accesses members of system structure
-# $Revision: 1.1.1.1 $
+# Updated to simpler form by a.s.hodel 1998
+# $Revision: 2.0.0.0 $
 
-  if( (nargin < 1) | (nargin > 3) )
-    usage("is_stable(a {,tol,disc})");
+  if( (nargin < 1) | (nargin > 3) )   usage("is_stable(a {,tol,disc})");
   elseif(is_struct(a))
     # system was passed
-    if(nargin < 3)
-      disc = is_digital(a);
+    if(nargin < 3)			disc = is_digital(a);
     elseif(disc != is_digital(a))
-      warning(["is_stable: disc =",num2str(disc),", does not match system"])
+      warning("is_stable: disc =%d does not match system",disc)
     endif
     sys = sysupdate(a,"ss");
-    a = sys.a;
+    a = sys2ss(sys);
   else
-    if(nargin < 3)
-      disc = 0;
-    endif
+    if(nargin < 3)		disc = 0;		endif
     if(is_square(a) == 0)
-      error("non-square a matrix passed.")
+      error("A(%dx%d) must be square",rows(A), columns(A));
     endif
   endif
 
-  if( nargin < 2)
-    tol = 200*eps;
+  if(nargin < 2)		tol = 200*eps;
   elseif( !is_scalar(tol) )
-    error("is_stable: tol must be a scalar!");
+    error("is_stable: tol(%dx%d) must be a scalar",rows(tol),columns(tol));
   endif
  
   l = eig(a);
-  if(disc)
-    nbad = sum(abs(l)*(1+tol) > 1);
-  else
-    nbad = sum(real(l)+tol > 0);
-  endif
+  if(disc)	nbad = sum(abs(l)*(1+tol) > 1);
+  else		nbad = sum(real(l)+tol > 0);		endif
   retval = (nbad == 0);   
 
 endfunction
diff --git a/scripts/control/jet707.m b/scripts/control/jet707.m
--- a/scripts/control/jet707.m
+++ b/scripts/control/jet707.m
@@ -23,26 +23,17 @@ function outsys = jet707()
   # System inputs:   (1) thrust   and (2) elevator angle
   # System outputs:  (1) airspeed and (2) pitch angle
   # Ref: R. Brockhaus: Flugregelung (Flight Control), Springer, 1994
   #
   # see also: ord2
 
   # Written by Kai P. Mueller September 28, 1997
   # Updates
-  # $Revision: 1.1.1.1 $
-  # $Log: jet707.m,v $
-  # Revision 1.1.1.1  1998/05/19 20:24:07  jwe
-  #
-  # Revision 1.3  1997/12/01 16:51:50  scotte
-  # updated by Mueller 27 Nov 97
-  #
-# Revision 1.1  1997/11/11  17:33:24  mueller
-# Initial revision
-#
+  # $Revision: 2.0.0.0 $
 
   if (nargin != 0)
     usage("outsys = jet707()")
   endif
   if (nargin > 1)
     usage("outsys = jet707()")
   endif
 
diff --git a/scripts/control/lqe.m b/scripts/control/lqe.m
--- a/scripts/control/lqe.m
+++ b/scripts/control/lqe.m
@@ -35,30 +35,17 @@ function [k, p, e] = lqe (a, g, c, sigw,
 #
 # Returns:
 #
 #   k = observer gain, (A - K C) is stable
 #   p = solution of algebraic Riccati equation
 #   e = closed loop poles of (A - K C)
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August, 1993.
-# $Revision: 1.14 $
-# $Log: lqe.m,v $
-# Revision 1.14  1998-11-06 16:15:36  jwe
-# *** empty log message ***
-#
-# Revision 1.1.1.1  1998/05/19 20:24:07  jwe
-#
-# Revision 1.3  1997/09/19 21:36:54  scotte
-# *** empty log message ***
-#
-# Revision 1.2  1997/02/28 23:03:45  hodel
-# added parenthesis in if command (just in case)
-# a.s.hodel@eng.auburn.edu
-#
+# $Revision: 1.15 $
 
   if ( (nargin != 5) && (nargin != 6))
     error ("lqe: invalid number of arguments");
   endif
 
 # The problem is dual to the regulator design, so transform to lqr
 # call.
 
diff --git a/scripts/control/lqg.m b/scripts/control/lqg.m
--- a/scripts/control/lqg.m
+++ b/scripts/control/lqg.m
@@ -43,38 +43,31 @@ function [K,Q1,P1,Ee,Er] = lqg(sys,Sigw,
 #    Q: Solution of estimation algebraic Riccati equation
 #    Ee: estimator poles
 #    Es: controller poles
 #
 # See also: h2syn, lqe, lqr
 
 # Written by A. S. Hodel August 1995; revised for new system format
 # August 1996
-# $Revision: 1.1.1.1 $
-# $Log: lqg.m,v $
-# Revision 1.1.1.1  1998/05/19 20:24:07  jwe
-#
-# Revision 1.2  1997/03/01 00:21:33  hodel
-# fixed some string manipulation problems.
-#
+# $Revision: 2.0.0.0 $
 
 sav_val = implicit_str_to_num_ok;
 implicit_str_to_num_ok = 1;
 
 if ( (nargin < 5) | (nargin > 6))
   usage("[K,Q1,P1,Ee,Er] = lqg(sys,Sigw, Sigv,Q,R{,input_list})");
 
 elseif(!is_struct(sys) )
   error("sys must be in system data structure");
 endif
 
 DIG = is_digital(sys);
 [A,B,C,D,tsam,n,nz,stname,inname,outname] = sys2ss(sys);
-nout = rows(outname);
-nin = rows(inname);
+[n,nz,nin,nout] = sysdimensions(sys);
 if(nargin == 5)
   #construct default input_list
   input_list = (columns(Sigw)+1):nin;
 endif
 
 if( !(n+nz) )
     error(["lqg: 0 states in system"]);
 
@@ -85,31 +78,27 @@ elseif(nin != columns(Sigw)+ columns(R))
 elseif(nout != columns(Sigv))
   error(["lqg: sys has ",num2str(nout)," outputs, dim(Sigv)=", ...
 	num2str(columns(Sigv)),")"])
 elseif(length(input_list) != columns(R))
   error(["lqg: length(input_list)=",num2str(length(input_list)), ...
 	", columns(R)=", num2str(columns(R))]);
 endif
 
-varname = ["Sigw";"Sigv";"Q   ";"R   "];
-for kk=1:rows(varname);
-  stval = dezero(varname(kk,:));
-  cmd = ["chk = is_square(",stval,");"];
-  eval(cmd);
-  if(! chk )
-    error(["lqg: ",stval," is not square"]);
-  endif
+varname = list("Sigw","Sigv","Q","R");
+for kk=1:length(varname);
+  eval(sprintf("chk = is_square(%s);",nth(varname,kk)));
+  if(! chk ) error("lqg: %s is not square",nth(varname,kk)); endif
 endfor
 
 # permute (if need be)
 if(nargin == 6)
   all_inputs = sysreorder(nin,input_list);
   B = B(:,all_inputs);
-  inname = inname(all_inputs,:);
+  inname = inname(all_inputs);
 endif
 
 # put parameters into correct variables
 m1 = columns(Sigw);
 m2 = m1+1;
 G = B(:,1:m1);
 B = B(:,m2:nin);
 
@@ -123,33 +112,23 @@ else
   [Ke Q1 Ee] = lqe(A,G,C,Sigw,Sigv);
 endif
 Ac = A - Ke*C - B*Ks;
 Bc = Ke;
 Cc = -Ks;
 Dc = zeros(rows(Cc),columns(Bc));
 
 # fix state names
-for ii=1:rows(stname)
-  newst = [dezero(stname(ii,:)),"\\e"];
-  stname1(ii,1:length(newst)) = newst;
-endfor
+stname1 = strappend(stname,"_e");
 
 # fix controller output names
-inname = inname(m2:nin,:);
-for ii=1:rows(inname)
-  newst = [dezero(inname(ii,:)),"\\K"];
-  outname1(ii,1:length(newst)) = newst;
-endfor
+outname1 = strappend(inname(m2:nin),"_K");
 
 # fix controller input names
-for ii=1:rows(outname)
-  newst = [dezero(outname(ii,:)),"\\K"];
-  inname1(ii,1:length(newst)) = newst;
-endfor
+inname1 = strappend(outname,"_K");
 
 if(DIG)
   K = ss2sys(Ac,Bc,Cc,Dc,tsam,n,nz,stname1,inname1,outname1,1:rows(Cc));
 else
   K = ss2sys(Ac,Bc,Cc,Dc,tsam,n,nz,stname,inname1,outname1);
 endif
 
 implicit_str_to_num_ok = sav_val;
diff --git a/scripts/control/lqr.m b/scripts/control/lqr.m
--- a/scripts/control/lqr.m
+++ b/scripts/control/lqr.m
@@ -42,33 +42,19 @@ function [k, p, e] = lqr (a, b, q, r, s)
 #   k = state feedback gain, (A - B K) is stable and minimizes the
 #       cost functional
 #   p = solution of algebraic Riccati equation
 #   e = closed loop poles of (A - B K)
 #
 # reference: Anderson and Moore, OPTIMAL CONTROL: LINEAR QUADRATIC METHODS,
 # Prentice-Hall, 1990, pp. 56-58
 
-# $Revision: 1.13 $
+# $Revision: 1.14 $
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
-# $Log: lqr.m,v $
-# Revision 1.13  1998-11-06 16:15:36  jwe
-# *** empty log message ***
-#
-# Revision 1.1.1.1  1998/05/19 20:24:07  jwe
-#
-# Revision 1.4  1997/09/19 21:37:24  scotte
-# added references for feedback matrices
-# ,
-#
-#
-# Revision 1.2  1997/02/28 23:02:14  hodel
-# added parenthesis around if commands (just to be sure)
-# a.s.hodel@eng.auburn.edu
 
   # disp("lqr: entry");
 
   if ((nargin != 4) && (nargin != 5))
     error ("lqr: invalid number of arguments");
   endif
 
 # Check a.
diff --git a/scripts/control/lsim.m b/scripts/control/lsim.m
--- a/scripts/control/lsim.m
+++ b/scripts/control/lsim.m
@@ -30,50 +30,33 @@ function [y,x] = lsim(sys,u,t,x0)
 #
 # When the lsim function is invoked with output parameters:
 # [y,x] = lsim(sys,u,t,[x0])
 # a plot is not displayed, however, the data is returned in y = system output
 # and x = system states.
 
 # Written by David Clem, A. S. Hodel July 1995
 # modified by John Ingram for system format August 1996
-# $Revision: 1.1.1.1 $
-# $Log: lsim.m,v $
-# Revision 1.1.1.1  1998/05/19 20:24:07  jwe
-#
-# Revision 1.3  1997/12/01 16:51:50  scotte
-# updated by Mueller 27 Nov 97
-#
-# Revision 1.2  1997/11/24  16:13:39  mueller
-# old style c2d call fixed
-#
+# $Revision: 2.0.0.0 $
+
 
   if((nargin < 3)||(nargin > 4))
     usage("[y,x] = lsim(sys,u,t[,x0])");
   endif
 
   if(!is_struct(sys))
     error("sys must be in system data structure");
   endif
 
   sys = sysupdate(sys,"ss");
 
-  nout = rows(sys.c);
-  nin = columns(sys.b);
-  ncstates = sys.n;
-  ndstates = sys.nz;
+  [ncstates, ndstates, nin, nout] = sysdimensions(sys);
+  [a,b,c,d] = sys2ss(sys);
   
-  a = sys.a;
-  b = sys.b;
-  c = sys.c;
-  d = sys.d;
-  
-  if (nargin == 3)
-    x0 = zeros(columns(a),1);
-  endif
+  if (nargin == 3)     x0 = zeros(columns(a),1);        endif
 
   if(rows(u) ~= length(t))
     error("lsim: There should be an input value (row) for each time instant");
   endif
   if(columns(u) ~= columns(d))
     error("lsim: U and d should have the same number of inputs");
   endif
   if(columns(x0) > 1)
@@ -89,18 +72,17 @@ function [y,x] = lsim(sys,u,t,x0)
   n = max(size(t));
   for ii = 1:(n-1)
 
     # check if step size changed
     if (t(ii+1) - t(ii) != Ts)
       Ts = t(ii+1) - t(ii);
       # [F,G] = c2d(a,b,Ts);
       dsys = c2d(sys, Ts);
-      F = dsys.a;
-      G = dsys.b;
+      [F,G] = sys2ss(dsys);
     endif
 
     x(:,ii) = x0;
     x0 = F*x0 + G*u(:,ii);
   endfor
 
   # pick up last point
   x(:,n) = x0;
diff --git a/scripts/control/ltifr.m b/scripts/control/ltifr.m
--- a/scripts/control/ltifr.m
+++ b/scripts/control/ltifr.m
@@ -27,51 +27,52 @@ function out = ltifr(a,b,w)
   # this function takes the system matrices, A and B and
   # returns:               -1
   #          G(s) = (jw I-A) B
   #
   # for complex frequencies s = jw. 
 
   # R. B. Tenison, D. Clem, A. S. Hodel, July 1995
   # updated by John Ingram August 1996 for system format
-  # $Revision: 1.1.1.1 $
+  # $Revision: 2.0.0.0 $
   
   if ((nargin < 2) || (nargin > 3))
     error("incorrect number of input arguments");
   endif
 
   if (nargin == 2)
     sys = a;
     w = b;
+    if(!is_struct(sys))
+      error("two arguments: 1st must be a system data structure");
+    endif
 
     if (!is_vector(w))
       error("w must be a vector");
     endif
     
-    sys = sysupdate(sys,"ss");
+    [nn,nz,mm,pp] = sysdimensions(sys);
+    if(mm != 1)       error("sys has %d > 1 inputs",mm); endif
 
-    if(columns(sys.b) != 1)
-      error("sys is not an SISO system");
-    endif
-
-    a = sys.a;
-    b = sys.b;        
+    [a,b] = sys2ss(sys);
 
   else  
 
     if (columns(a) != rows(b)),
-      error("ltifr:  A, B not compatibly dimensioned");
+      error("ltifr:  A(%dx%d), B(%dx%d) not compatibly dimensioned", ...
+	rows(a), columns(a), rows(b), columns(b));
     endif
 
     if(columns(b) != 1)
-      error("ltifr: 2nd argument must be a single column vector");
+      error("ltifr: b(%dx%d) must be a single column vector", ...
+	rows(b),columns(b));
     endif
   
     if (!is_square(a))
-      error("ltifr:  A must be square.")
+      error("ltifr:  A(%dx$d) must be square.",rows(a),columns(a))
     endif
 
   endif
 
   if (!is_vector(w))
     error("w must be a vector");
   endif
 
diff --git a/scripts/control/mb.m b/scripts/control/mb.m
--- a/scripts/control/mb.m
+++ b/scripts/control/mb.m
@@ -1,27 +1,30 @@
-# $Revision: 1.1 $
+# I think that this m-file can be deleted
+# a.s.hodel@eng.auburn.edu - 4 Dec. 1998
+
+# $Revision: 2.0.0.0 $
 
 Ap = [0 1;1960 0];
 Bp = [0;-6261];
 Cp = [1 0];
 Dp = 0;
 
 Gp = ss2sys(Ap,Bp,Cp,Dp,0,2,0,[],"delta_i","delta_y");
-Gp = syschnames(Gp,"st",1,"delta_x1");
-Gp = syschnames(Gp,"st",2,"delta_x2");
+Gp = syssetsignals(Gp,"st","delta_x1",1);
+Gp = syssetsignals(Gp,"st","delta_x2",2);
 
 Ak = [-20 1;-22160 -200];
 Bk = [-20;-2160];
 Ck = [-3.5074 -0.0319];
 Dk = 0;
 
 Gk = ss2sys(Ak,Bk,Ck,Dk,0,2,0,[],"y","i");
-Gk = syschnames(Gk,"st",1,"x1");
-Gk = syschnames(Gk,"st",2,"x2");
+Gk = syssetsignals(Gk,"st","x1",1);
+Gk = syssetsignals(Gk,"st","x2",2);
 
 Gc = sysgroup(Gp,Gk);
 
 Gc = sysdup(Gc,[],[1 2]);
 # Gc = sysscale(Gc,[],diag([1,1,1,1]));
 
 Gc = sysconnect(Gc,[1 2],[4 3]);
 Gc = sysprune(Gc,1,[1 2]);
@@ -29,12 +32,15 @@ Gc = sysprune(Gc,1,[1 2]);
 disp("after pruning, closed loop system is")
 sysout(Gc)
 
 # Gc = sysdup(Gc,[],2);
 # Gc = sysconnect(Gc,1,3);
 # Gc = sysprune(Gc,1,1);
 
 is_stable(Gc)
-eig(Gc.a)
+Gca = sys2ss(Gc);
+eig(Gca)
 
-Acl = [Gp.a, -Gp.b*Gk.c; Gk.b*Gp.c, Gk.a]
+[Gpa,Gpb,Gpc,Gpd] = sys2ss(Gp);
+[Gka,Gkb,Gkc,Gkd] = sys2ss(Gk);
+Acl = [Gpa, -Gpb*Gkc; Gkb*Gpc, Gka]
 eig(Acl)
diff --git a/scripts/control/minfo.m b/scripts/control/minfo.m
--- a/scripts/control/minfo.m
+++ b/scripts/control/minfo.m
@@ -28,17 +28,17 @@ function [systype, nout, nin, ncstates, 
   #      nout is the number of outputs of the system
   #      nin is the number of inputs of the system
   #      ncstates is the number of continuous states of the system
   #	 ndstates is the number of discrete states of the system
 
   # Written by R. Bruce Tenison July 29, 1994
   # Modified by David Clem November 13, 1994
   # Modified by A. S. Hodel July 1995
-  # $Revision: 1.1.1.1 $
+  # $Revision: 2.0.0.0 $
 
   warning("minfo: obsolete.  Use sys2ss, sys2tf, or sys2zp.");
     
   if (nargin ~= 1 )
     disp('MINFO: Wrong number of arguments')
     systype = nout = nin = ncstates = ndstates = [];
   endif
   
diff --git a/scripts/control/moddemo.m b/scripts/control/moddemo.m
--- a/scripts/control/moddemo.m
+++ b/scripts/control/moddemo.m
@@ -15,17 +15,17 @@
 # You should have received a copy of the GNU General Public License 
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function moddemo()
 # Octave Controls toolbox demo: Model Manipulations demo
 # Written by David Clem August 15, 1994
 
-# $Revision: 1.1 $
+# $Revision: 2.0.0.0 $
 # a s hodel: updated to reflect updated output order in ss2zp
 
   while (1)
     clc
     disp('Octave Model Manipulations Demo')
     disp('=======================================')
     disp('  1)  Perform continuous to discrete time conversion (c2d)')
     disp('  2)  Convert from state space to zero / pole form (ss2zp)')
diff --git a/scripts/control/nichols.m b/scripts/control/nichols.m
--- a/scripts/control/nichols.m
+++ b/scripts/control/nichols.m
@@ -46,18 +46,16 @@ function [mag,phase,w] = nichols(sys,w,o
 #    w: the vector of frequency values used
 # If no output arguments are given, nichols plots the results to the screen.
 # Descriptive labels are automatically placed.  See xlabel, ylable, title,
 # and replot.
 #
 # Note: if the requested plot is for an MIMO system, mag is set to
 # ||G(jw)|| or ||G(exp(jwT))|| and phase information is not computed.
 
-# $Log$
-
   # check number of input arguments given
   if (nargin < 1 | nargin > 4)
     usage("[mag,phase,w] = nichols(sys[,w,outputs,inputs])");
   endif
   if(nargin < 2)
     w = [];
   endif
   if(nargin < 3)
diff --git a/scripts/control/nyquist.m b/scripts/control/nyquist.m
--- a/scripts/control/nyquist.m
+++ b/scripts/control/nyquist.m
@@ -60,25 +60,16 @@ function [realp,imagp,w] = nyquist(sys,w
 # presented; the returned information is of the magnitude 
 # ||G(jw)|| or ||G(exp(jwT))|| only; phase information is not computed.
    
   # By R. Bruce Tenison, July 13, 1994
   # A. S. Hodel July 1995 (adaptive frequency spacing, 
   #     remove acura parameter, etc.)
   # Revised by John Ingram July 1996 for system format
   #
-  # Revision 1.6  1998/02/09 13:03:37  scotte
-  # fixed oneplot/gset nokey to function only if gnuplot_has_multiplot
-  #
-# Revision 1.2  1997/11/24  17:27:58  mueller
-# call to oneplot() and gset nokey added
-#
-# Revision 1.1  1997/11/11  17:33:41  mueller
-# Initial revision
-#
 
   # Both bode and nyquist share the same introduction, so the common parts are 
   # in a file called bodquist.m.  It contains the part that finds the 
   # number of arguments, determines whether or not the system is SISO, and 
   # computes the frequency response.  Only the way the response is plotted is
   # different between the two functions.
 
   save_val = implicit_str_to_num_ok;	# save for later
@@ -129,17 +120,17 @@ function [realp,imagp,w] = nyquist(sys,w
         tstr = " G(jw) ";
       endif
       xlabel(["Re(",tstr,")"]);
       ylabel(["Im(",tstr,")"]);
   
       [stn, inn, outn] = sysgetsignals(sys);
       if(is_siso(sys))
         title(sprintf("Nyquist plot from %s to %s, w (rad/s) in [%e, %e]", ...
-	  inn, outn, w(1), w(length(w))) )
+	  nth(inn,1), nth(outn,1), w(1), w(length(w))) )
       endif
   
       gset nologscale xy;
 
       axis(axis2dlim([[vec(realp),vec(imagp)];[vec(realp),-vec(imagp)]]));
       plot(realp,imagp,"- ;+w;",realp,-imagp,"-@ ;-w;");
 
       # check for interactive plots
diff --git a/scripts/control/obsv.m b/scripts/control/obsv.m
--- a/scripts/control/obsv.m
+++ b/scripts/control/obsv.m
@@ -34,33 +34,23 @@ function Qb = obsv(sys, c)
   # Note: obsv() forms the observability matrix.
   #       The numerical properties of is_observable()
   #       are much better for observability tests.
   # See also:  ctrb, is_observable, is_controllable
   # ------------------------------------------------------
 
   # Written by Kai P. Mueller November 4, 1997
   # modified by
-  # $Revision: 1.1.1.1 $
-  # $Log: obsv.m,v $
-  # Revision 1.1.1.1  1998/05/19 20:24:07  jwe
-  #
-  # Revision 1.2  1997/12/01 16:51:50  scotte
-  # updated by Mueller 27 Nov 97
-  #
-# Revision 1.1  1997/11/25  11:17:05  mueller
-# Initial revision
-#
+  # $Revision: 2.0.0.0 $
 
   if (nargin == 2)
     a = sys;
   elseif (nargin == 1 && is_struct(sys))
     sysupdate(sys,"ss");
-    a = sys.a;
-    c = sys.c;
+    [a,b,c] = sys2ss(sys);
   else
     usage("obsv(sys [, c])")
   endif
 
   if (!is_abcd(a,c'))
     Qb = [];
   else
     # no need to check dimensions, we trust is_abcd().
diff --git a/scripts/control/ord2.m b/scripts/control/ord2.m
--- a/scripts/control/ord2.m
+++ b/scripts/control/ord2.m
@@ -33,26 +33,17 @@ function outsys = ord2(nfreq, damp, gain
   #      G = | |             |, |   |, [ 0  gain ], 0 |
   #          | \   w       0 /  \ 0 /                 |
   #          \                                        /
   #
   # See also: jet707 (MIMO example, Boeing 707-321 aircraft model)
 
   # Written by Kai P. Mueller September 28, 1997
   # Updates
-  # $Revision: 1.1.1.1 $
-  # $Log: ord2.m,v $
-  # Revision 1.1.1.1  1998/05/19 20:24:07  jwe
-  #
-  # Revision 1.3  1997/12/01 16:51:50  scotte
-  # updated by Mueller 27 Nov 97
-  #
-# Revision 1.1  1997/11/11  17:34:06  mueller
-# Initial revision
-#
+  # $Revision: 2.0.0.0 $
 
   if(nargin != 2 & nargin != 3)
     usage("outsys = ord2(nfreq, damp[, gain])")
   endif
   if (nargout > 1)
     usage("outsys = ord2(nfreq, damp[, gain])")
   endif
   if (nargin == 2)
diff --git a/scripts/control/outlist.m b/scripts/control/outlist.m
--- a/scripts/control/outlist.m
+++ b/scripts/control/outlist.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1996 A. Scottedward Hodel 
+# Copyright (C) 1996, 1998 A. Scottedward Hodel 
 #
 # This file is part of Octave. 
 #
 # Octave is free software; you can redistribute it and/or modify it 
 # under the terms of the GNU General Public License as published by the 
 # Free Software Foundation; either version 2, or (at your option) any 
 # later version. 
 # 
@@ -11,67 +11,59 @@
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
 # for more details.
 # 
 # You should have received a copy of the GNU General Public License 
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
-function outlist(lmat,tabchar,yd,ilist)
-# function outlist(lmat[,tabchar,yd,ilist])
+function str_val = outlist(name_list,tabchar,yd,ilist)
+# function str_val = outlist(name_list[,tabchar,yd,ilist])
 #
 # internal use only; minimal argument checking performed
 #
 # print an enumerated list of strings
 # inputs:
-#	lmat: matrix of strings (one per row)
+#	name_list: list of strings (one per entry)
 #	tabchar: tab character (default: none)
-#       yd: indices of strings to append with the string "(discrete)"
+#       yd: indices of entries to append with the string "(discrete)"
 #           (used by sysout; minimal checking of this argument)
 #	   yd = [] => all continuous
 #       ilist: index numbers to print with names
-#	  default: 1:rows(lmat)
+#	  default: 1:length(name_list)
 # outputs:
 #   prints the list to the screen, numbering each string in order.
 
-# A. S. Hodel Dec. 1995
-# $Revision: 1.1.1.1 $
-
-save_val = implicit_str_to_num_ok;	# save for later
-implicit_str_to_num_ok = 1;
+# A. S. Hodel Dec. 1995, 1998
+# $Revision: 2.0.0.0 $
 
 #save for restore later
 save_empty = empty_list_elements_ok;
 empty_list_elements_ok = 1;
 
-if( (nargin < 1) || (nargin > 4) )
-  usage("outlist(x[,tabchar,yd,ilist])");
+if( nargin < 1 | nargin > 4 )
+  usage("str_val = outlist(x[,tabchar,yd,ilist])");
 endif
 
-[m,n] = size(lmat);
-if(nargin < 4)
-  ilist = 1:m;
-endif
+m = length(name_list);
+if(nargin < 4)           ilist = 1:m;          endif
 if(nargin ==1)
   empty_list_elements_ok = 1;
   tabchar = "";
 endif
 
-if(nargin < 3)
-  yd = zeros(1,m);
-elseif(isempty(yd))
-  yd = zeros(1,m);
-endif
+if(nargin < 3)             yd = zeros(1,m);
+elseif(isempty(yd))        yd = zeros(1,m);          endif
 
-if((m >= 1) && (isstr(lmat)))
+str_val = "";
+dstr = list(""," (discrete)");
+if((m >= 1) && (is_list(name_list)))
   for ii=1:m
-    str = dezero([lmat(ii,:),setstr((yd(ii)*" (discrete)"))]);
-    #disp(["length(str)=",num2str(length(str))])
-    disp([tabchar,num2str(ilist(ii)),": ",str])
+    str_val = sprintf("%s%s%d: %s%s\n",str_val,tabchar, ii, ...
+	nth(name_list,ii),nth(dstr,yd(ii)+1));
   endfor
 else
-  disp([tabchar,"None"])
+  str_val = sprintf("%sNone",tabchar);
 endif
 
 empty_list_elements_ok = save_empty;
-implicit_str_to_num_ok = save_val;	# restore value
 endfunction
diff --git a/scripts/control/packedform.m b/scripts/control/packedform.m
--- a/scripts/control/packedform.m
+++ b/scripts/control/packedform.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1996 A. Scottedward Hodel 
+# Copyright (C) 1996,1998 A. Scottedward Hodel 
 #
 # This file is part of Octave. 
 #
 # Octave is free software; you can redistribute it and/or modify it 
 # under the terms of the GNU General Public License as published by the 
 # Free Software Foundation; either version 2, or (at your option) any 
 # later version. 
 # 
@@ -20,21 +20,21 @@
 save_var = page_screen_output;
 page_screen_output = 1;
 disp("Description of system data structure:")
 disp("A linear system is stored in a structure, and may be represented in")
 disp("ss (state space), tf (transfer function),  and/or zp (zero-pole-gain)")
 disp("form.")
 disp(" ")
 disp("variables in all representations:")
-disp("inname: string or a matrix of strings containing name(s) of system ")
-disp("        inputs");
+disp("inname: list of signal names (strings) containing name(s) of system ")
+disp("        inputs; see is_signal_list");
 disp("n: number of continuous states")
 disp("nz: number of discrete states")
-disp("outname: string or a matrix of strings containing name(s) of system ")
+disp("outname: list of signal names (strings) containing name(s) of system ")
 disp("        outputs");
 disp(" ")
 disp("variables in all representations:(cont'd)")
 disp("sys: system status vector.  This vector indicates both what")
 disp("     representation was used to initialize the system data structure")
 disp("     (called the primary system type) and which other representations")
 disp("     are currently up-to-date with the primary system type.")
 disp("     sys(0): primary system type")
@@ -77,22 +77,20 @@ disp(" ")
 disp("===============================")
 disp("variables in ss representations:")
 disp("a,b,c,d: usual state-space matrices.  If a system has both")
 disp("        continuous and discrete states, they are sorted so that")
 disp("        continuous states come first, then discrete states")
 disp(" ")
 disp("WARNING: some functions (e.g., bode) will not accept systems")
 disp("with both discrete and continuous states/outputs")
-disp("stname: string or matrix of strings containing name(s) of system")
+disp("stname: list of signal names (strings) containing name(s) of system ")
 disp("        states");
 disp("===============================")
 disp("Object oriented programming:")
 disp("It is recommended that users do not directly access the internal")
 disp("variables themselves, but use the interface functions")
-disp("        ss2sys        sys2ss      syschnames")
-disp("        tf2sys        sys2tf")
-disp("        zp2sys        sys2zp")
-disp("to create/access internal variables.  For developmental purposes,")
-disp("routines that directly access the internal structure of a system data")
-disp("structure either have the string \"sys\" in their name or else")
-disp("have the word SYS_INTERNAL in their revision comment block");
+disp("  fir2sys         ss2sys          tf2sys          sys2fir")
+disp("  sys2ss          sys2tf          sys2zp          syschtsam")
+disp("  sysdimensions   sysgetsignals   syssetsignals   sysgettype")
+disp("  zp2sys")
+disp("to create/access internal variables.  ");
 page_screen_output = save_var;
diff --git a/scripts/control/packsys.m b/scripts/control/packsys.m
--- a/scripts/control/packsys.m
+++ b/scripts/control/packsys.m
@@ -27,17 +27,17 @@ function Asys = packsys(a,b,c,d,dflg)
   #   dflg: 0 (continuous time)
   #
   # Note: discrete-state sampling time is not included!
   #
   
   # Written by R. Bruce Tenison  July 29, 1994
   # Modified by David Clem November 13, 1994
   # Modified by A. S. Hodel April 1995
-  # $Revision: 1.2 $
+  # $Revision: 2.0.0.0 $
 
   warning("packsys is obsolete!  Use ss2sys instead.");
   
   if (nargin < 3 || nargin > 5)
     disp("packsys: Invalid number of arguments")
   endif
 
   # check dflg
diff --git a/scripts/control/parallel.m b/scripts/control/parallel.m
--- a/scripts/control/parallel.m
+++ b/scripts/control/parallel.m
@@ -28,35 +28,30 @@ function sysp = parallel(Asys,Bsys)
 #         |--->|----> | Bsys |--->|----> y2
 #              |      --------    |
 #              --------------------
 #                   Ksys
 
 # Written by David Clem August 15, 1994
 # completely rewritten Oct 1996 a s hodel
 # SYS_INTERNAL accesses members of system structure
-# $Revision: 1.1.1.1 $
+# $Revision: 2.0.0.0 $
 
   if(nargin != 2)
     usage("sysp = parallel(Asys,Bsys)");
   endif
   if(! is_struct(Asys) )
     error("1st input argument is not a system data structure")
   elseif (! is_struct(Bsys) )
     error("2nd input argument is not a system data structure")
   endif
-  mA = rows(Asys.inname);
-  mB = rows(Bsys.inname);
+  [Ann,Anz,mA] = sysdimensions(Asys);
+  [Bnn,Bnz,mB] = sysdimensions(Bsys);
   if(mA != mB)
     error(["Asys has ",num2str(mA)," inputs, Bsys has ",num2str(mB)," inputs"]);
   endif
   sysp = sysgroup(Asys,Bsys);
   sysD = ss2sys([],[],[],[eye(mA);eye(mA)]);
   
-  #disp("sysp=")
-  #sysout(sysp)
-  #disp("sysD")
-  #sysout(sysD)
-
   sysp = sysmult(sysp,sysD);
-  sysp = syschnames(sysp,"in",1:mA,Asys.inname);
+  sysp = syssetsignals(sysp,"in",sysgetsignals(Asys,"in"));
   
 endfunction
diff --git a/scripts/control/place.m b/scripts/control/place.m
--- a/scripts/control/place.m
+++ b/scripts/control/place.m
@@ -35,26 +35,17 @@ function K = place(sys, P)
 %	      E-Mail: daniel@dea.icai.upco.es
 %
 %	      Phone: 34-1-5422800   Fax: 34-1-5596569
 %
 % Algorithm taken from "The Control Handbook", IEEE press pp. 209-212
 #
 # code adaped by A.S.Hodel (a.s.hodel@eng.auburn.edu) for use in controls
 # toolbox
-# $Revision: 1.1.1.1 $
-# $Log: place.m,v $
-# Revision 1.1.1.1  1998/05/19 20:24:08  jwe
-#
-# Revision 1.2  1997/03/10 21:41:10  scotte
-# *** empty log message ***
-#
-# Revision 1.1  1997/03/10 20:38:53  scotte
-# Initial revision
-#
+# $Revision: 2.0.0.0 $
 
   sav_val = empty_list_elements_ok;
   empty_list_elements_ok = 1;
   #
   # check arguments
   #
   if(!is_struct(sys))
     error("sys must be in system data structure format (see ss2sys)");
diff --git a/scripts/control/polyout.m b/scripts/control/polyout.m
--- a/scripts/control/polyout.m
+++ b/scripts/control/polyout.m
@@ -25,17 +25,17 @@ function y = polyout(c,x)
 # in a string or to the screen (if y is omitted)
 # x defaults to the string "s"
 #
 #  SEE ALSO: polyval, polyvalm, poly, roots, conv, deconv, residue, 
 #	filter, polyderiv, polyinteg
 
 # Written by A. Scottedward Hodel (scotte@eng.auburn.edu) May 1995)
 # Nov 1998: Correctly handles complex coefficients
-# $Revision$ 
+# $Revision: 2.0.0.0 $ 
   
   if (nargin < 1 ) || (nargin > 2) || (nargout < 0 ) || (nargout > 1)
     usage("[y = ] polyout(c,[x])");
   endif
 
   if (!is_vector(c))
     error("polyout: first argument must be a vector");
   endif
diff --git a/scripts/control/prompt.m b/scripts/control/prompt.m
--- a/scripts/control/prompt.m
+++ b/scripts/control/prompt.m
@@ -18,17 +18,17 @@
  
 function prompt(str)
 # function prompt([str])
 # Prompt user to continue
 # str: input string. Default value: "\n ---- Press a key to continue ---"
 # Written by David Clem August 15, 1994
 # Modified A. S. Hodel June 1995
 
-# $Revision: 1.2 $
+# $Revision: 2.0.0.0 $
 
 if(nargin > 1)
   usage("prompt([str])");
 elseif(nargin == 0)
   str = "\n ---- Press a key to continue ---";
 elseif ( !isstr(str) )
   error("prompt: input must be a string");
 endif
diff --git a/scripts/control/pzmap.m b/scripts/control/pzmap.m
--- a/scripts/control/pzmap.m
+++ b/scripts/control/pzmap.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1996 A. Scottedward Hodel 
+# Copyright (C) 1996,1998 A. Scottedward Hodel 
 #
 # This file is part of Octave. 
 #
 # Octave is free software; you can redistribute it and/or modify it 
 # under the terms of the GNU General Public License as published by the 
 # Free Software Foundation; either version 2, or (at your option) any 
 # later version. 
 # 
@@ -20,22 +20,16 @@ function [zer,pol]=pzmap(sys)
 # function [zer,pol]=pzmap(sys)
 # Plots the zeros and poles of a system in the complex plane.
 #
 # inputs: sys: system data structure
 # outputs: if omitted, the poles and zeros are plotted on the screen.
 #          otherwise, pol, zer are returned as the system poles and zeros.
 #          (see sys2zp for a preferable function call)
 
-# $Log: pzmap.m,v $
-# Revision 1.2  1998/07/14 22:01:28  hodelas
-# Changed to use axis2dlim (new function) to getplot limits;
-# Changed gnuplot plotting commands
-#
-
   save_val = implicit_str_to_num_ok;	# save for later
   save_emp = empty_list_elements_ok;
 
   implicit_str_to_num_ok = 1;
   empty_list_elements_ok = 1;
 
   if(nargin != 1)
     usage("pzmap(sys) or [zer,pol] = pzmap(sys)"); 
@@ -58,17 +52,18 @@ function [zer,pol]=pzmap(sys)
 
   # determine continuous or discrete plane
   vars = "sz";
   varstr = vars(is_digital(sys) + 1);
 
   # Plot the data
   gset nologscale xy;
   if(is_siso(sys))
-    title(["Pole-zero map from ",sys.inname," to ", sys.outname]);
+    title(sprintf("Pole-zero map from %s to %s", ...
+       sysgetsignals(sys,"in",1,1), sysgetsignals(sys,"out",1,1) ));
   endif
   xlabel(["Re(",varstr,")"]);
   ylabel(["Im(",varstr,")"]);
   grid;
 
   # compute axis limits
   axis(axis2dlim([zerdata;poldata]));
   grid
diff --git a/scripts/control/rldemo.m b/scripts/control/rldemo.m
--- a/scripts/control/rldemo.m
+++ b/scripts/control/rldemo.m
@@ -15,17 +15,17 @@
 # You should have received a copy of the GNU General Public License 
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function rldemo()
 # Octave Controls toolbox demo: Root Locus demo
 # Written by David Clem August 15, 1994
 # Updated by John Ingram December 1996
-# $Revision: 1.2 $
+# $Revision: 2.0.0.0 $
 
   while (1)
     clc
     k = menu("Octave Root Locus Demo", ...
     	"Display continuous system's open loop poles and zeros (pzmap)", ...
     	"Display discrete system's open loop poles and zeros (pzmap)", ...
     	"Display root locus diagram of SISO continuous system (rlocus)", ...
     	"Display root locus diagram of SISO discrete system (rlocus)", ...	
diff --git a/scripts/control/rlocus.m b/scripts/control/rlocus.m
--- a/scripts/control/rlocus.m
+++ b/scripts/control/rlocus.m
@@ -37,17 +37,17 @@ function [rldata,k_break,rlpol,gvec,real
   #        corresponding to to gain gvec(ii)
   #   gvec: gains used to compute root locus
   #   real_ax_pts: breakpoints of the real axis locus.
   
   # Convert the input to a transfer function if necessary
   # Written by Clem and Tenison
   # Updated by Kristi McGowan July 1996 for intelligent gain selection
   # Updated by John Ingram July 1996 for systems
-  # $Revision: 1.7 $
+  # $Revision: 2.0.0.0 $
   
   if (nargin < 1) | (nargin > 4)
     usage("rlocus(sys[,inc,mink,maxk])");
   endif
   
   [num,den] = sys2tf(sys);		# extract numerator/denom polyomials
   lnum = length(num);      lden = length(den);
   if(lden < 2)
@@ -183,17 +183,17 @@ function [rldata,k_break,rlpol,gvec,real
     axlim = axis2dlim(axdata);
     axlim(1:2) = [xmin xmax];
     gset nologscale xy;
     grid("on");
     rldata = [real(rlpolv), imag(rlpolv) ];
     axis(axlim);
     [stn,inname,outname] = sysgetsignals(sys);
     xlabel(sprintf("Root locus from %s to %s, gain=[%f,%f]: Real axis", ...
-	dezero(inname),dezero(outname),gvec(1),gvec(ngain)));
+	nth(inname,1),nth(outname,1),gvec(1),gvec(ngain)));
     ylabel("Imag. axis");
 	
     plot(real(rlpolv),imag(rlpolv),".1;locus points;", ...
 	real(olpol),imag(olpol),"x2;open loop poles;", ...
 	real(rlzer),imag(rlzer),"o3;zeros;");
     rldata = [];
   endif
 endfunction
diff --git a/scripts/control/rotg.m b/scripts/control/rotg.m
--- a/scripts/control/rotg.m
+++ b/scripts/control/rotg.m
@@ -17,12 +17,12 @@
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function [c,s] = rotg(a,b)
   #function [c,s] = rotg(a,b)
   # givens rotation calculation
   #
   # NOTE: Use [c,s] = givens(a,b) instead.
 
-  # $Revision: 1.1 $
+  # $Revision: 2.0.0.0 $
 
   [c,s] = givens(a,b);
 endfunction
diff --git a/scripts/control/run_cmd.m b/scripts/control/run_cmd.m
--- a/scripts/control/run_cmd.m
+++ b/scripts/control/run_cmd.m
@@ -1,30 +1,12 @@
 # run_cmd: short script used in demos
 # prints string cmd to the screen, then executes after a pause
 
-# $Revision: 1.1.1.1 $
-# $Log: run_cmd.m,v $
-# Revision 1.1.1.1  1998/05/19 20:24:05  jwe
-#
-# Revision 1.4  1997/02/20 16:07:26  hodel
-# added "fflush" after disp("executing")
-#
-# Revision 1.3  1997/02/12 15:38:14  hodel
-# added separator after command execution
-#
-# added blank line after eval(cmd)
-#
-# Revision 1.1  1997/02/12 11:35:08  hodel
-# Initial revision
-#
-# Revision 1.3  1997/02/07 15:44:13  scotte
-# Added "executing" string so that users would know that the command was
-# being processed
-#
+# $Revision: 2.0.0.0 $
 
 disp(["Command: ",cmd])
 puts("Press a key to execute command");
 fflush(stdout);
 kbhit();
 disp("  executing");
 fflush(stdout);
 eval(cmd);
diff --git a/scripts/control/series.m b/scripts/control/series.m
--- a/scripts/control/series.m
+++ b/scripts/control/series.m
@@ -33,17 +33,17 @@ function [a,b,c,d] = series(a1,b1,c1,d1,
 # outputs of system 2.
 #
 # Type of input: system data structure
 # Command:       syst=series(syst1,syst2)
 # Forms the series representation of the two mu system arguments.
 # Written by David Clem August 15, 1994
 
 # If two arguments input, take care of mu system case
-# $Revision: 1.1.1.1 $
+# $Revision: 2.0.0.0 $
 
   warning("series is superseded by sysmult; use sysmult instead.")
 
   muflag = 0;
   if(nargin == 2)
     temp=b1;
     [a1,b1,c1,d1]=sys2ss(a1);
     [a2,b2,c2,d2]=sys2ss(temp);
diff --git a/scripts/control/sortcom.m b/scripts/control/sortcom.m
--- a/scripts/control/sortcom.m
+++ b/scripts/control/sortcom.m
@@ -27,17 +27,17 @@ function [yy,idx] = sortcom(xx,opt)
 #  if opt != "im" then values with common real part/magnitude are
 #     sorted by imaginary part, i.e. a - jb followed by a + jb. 
 #     [Complex conjugate pairs may not be grouped consecutively if more than 2
 #     numbers share a common real part/magnitude]
 # yy: sorted values
 # idx: permutation vector: yy = xx(idx)
 
 # Written by A. S. Hodel June 1995
-# $Revision: 1.4 $
+# $Revision: 2.0.0.0 $
 
   if( nargin < 1 | nargin > 2 )
      usage("yy = sortcom(xx[,opt]");
   elseif( !(is_vector(xx) | isempty(xx) ))
     error("sortcom: first argument must be a vector");
   endif
 
   if(nargin == 1)         opt = "re";
diff --git a/scripts/control/ss2sys.m b/scripts/control/ss2sys.m
--- a/scripts/control/ss2sys.m
+++ b/scripts/control/ss2sys.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1996 A. Scottedward Hodel 
+# Copyright (C) 1996,1998 A. Scottedward Hodel 
 #
 # This file is part of Octave. 
 #
 # Octave is free software; you can redistribute it and/or modify it 
 # under the terms of the GNU General Public License as published by the 
 # Free Software Foundation; either version 2, or (at your option) any 
 # later version. 
 # 
@@ -11,34 +11,34 @@
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
 # for more details.
 # 
 # You should have received a copy of the GNU General Public License 
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
-function  outsys = ss2sys  (a,b,c,d,tsam,n,nz,stname,inname,outname,outlist)
-  # outsys = ss2sys  (a,b,c{,d,tsam,n,nz,stname,inname,outname,outlist})
+function  retsys = ss2sys  (a,b,c,d,tsam,n,nz,stname,inname,outname,outlist)
+  # retsys = ss2sys  (a,b,c{,d,tsam,n,nz,stname,inname,outname,outlist})
   # Create system structure from state-space data.   May be continous,
   # discrete, or mixed (sampeld-data)
   # inputs:
   #   a, b, c, d: usual state space matrices.
   #               default: d = zero matrix
   #   tsam: sampling rate.  Default: tsam = 0 (continuous system)
   #   n, nz: number of continuous, discrete states in the system
   #        default: tsam = 0: n = rows(a), nz = 0
   #                 tsam > 0: n = 0,       nz = rows(a), n 
   #        see below for system partitioning
-  #   stname: string matrix of state signal names
+  #   stname: list of strings of state signal names
   #           default (stname=[] on input): x_n for continuous states,
   #                    xd_n for discrete states
-  #   inname: string matrix of input signal names
+  #   inname: list of strings of input signal names
   #           default (inname = [] on input): u_n
-  #   outname: string matrix of input signal names
+  #   outname: list of strings of output signal names
   #           default (outname = [] on input): y_n
   #   outlist: list of indices of outputs y that are sampled
   #           default: (tsam = 0)  outlist = []
   #                    (tsam > 0)  outlist = 1:rows(c)
   #           Unlike states, discrete/continous outputs may appear
   #           in any order.
   #           Note: sys2ss returns a vector yd where
   #                 yd(outlist) = 1; all other entries of yd are 0.
@@ -67,153 +67,110 @@ function  outsys = ss2sys  (a,b,c,d,tsam
   #  ------------------------------------------------------
   #  outputs   | outname(cout,:) | outname(outlist,:)     |
   #  ------------------------------------------------------
   #
   #  where cout = list if indices in 1:rows(p) not contained in outlist.
   #
 
   #  Written by John Ingram (ingraje@eng.auburn.edu)  July 20, 1996
-  # $Revision: 1.3 $
-  # $Log: ss2sys.m,v $
-  # Revision 1.3  1998/07/01 20:55:08  hodelas
-  # Updated sysgroup, sys2ss, ss2sys to use system structure interface
-  #
-  # Revision 1.4  1997/03/11 15:19:27  scotte
-  # fixed warning message about inname dimensions a.s.hodel@eng.auburn.edu
-  #
+  # $Revision: 2.0.0.0 $
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
   #  Test for correct number of inputs
   if ((nargin < 3) | (nargin > 11))
-    error("Incorrect number of arguments");
+    usage("retsys = ss2sys  (a,b,c{,d,tsam,n,nz,stname,inname,outname,outlist})");
   endif
 
   # verify A, B, C, D arguments
   #  If D is not specified, set it to a zero matrix of appriate dimension.
-  if (nargin == 3) 
-    d = zeros(rows(c) , columns(b));
-  elseif (isempty(d))
-    d = zeros(rows(c) , columns(b));
-  endif
+  if (nargin == 3)          d = zeros(rows(c) , columns(b));
+  elseif (isempty(d))       d = zeros(rows(c) , columns(b));      endif
 
   #  Check the dimensions
   [na,m,p] = abcddim(a,b,c,d);
 
   #  If dimensions are wrong, exit function
   if (m == -1)
-    error("a,b,c,d matrix dimensions are not compatible");
+    error("a(%dx%d), b(%dx%d), c(%dx%d), d(%dx%d); incompatible", ...
+      rows(a), columns(a), rows(b), columns(b), rows(c), columns(c), ...
+      rows(d), columns(d));
   endif
 
   # check for tsam input
-  if(nargin < 5)
-    tsam = 0;
+  if(nargin < 5) tsam = 0;
   elseif( !( is_sample(tsam) | (tsam == 0) ) )
     error("tsam must be a nonnegative real scalar");
   endif
 
   # check for continuous states
-  if( (nargin < 6) & (tsam == 0) )
-    n = na;
-  elseif(nargin < 6)
-    n = 0;
+  if( (nargin < 6) & (tsam == 0) )               n = na;
+  elseif(nargin < 6)                             n = 0;
   elseif( (!is_scalar(n)) | (n < 0 ) | (n != round(n)) )
-    if(is_scalar(n))
-      error(["illegal value of n=",num2str(n)]);
-    else
-      error(["illegal value of n=(",num2str(rows(n)),"x", ...
-	num2str(columns(n)),")"]);
-    endif
+    if(is_scalar(n))     error("illegal value of n=%d,%e",n,n);
+    else                 error("illegal value of n=(%dx%d)", ...
+			   rows(n), columns(n));		endif
   endif
 
   # check for num discrete states
-  if( (nargin < 7) & (tsam == 0))
-    nz = 0;
-  elseif(nargin < 7)
-    nz = na - n;
+  if( (nargin < 7) & (tsam == 0)) 		nz = 0;
+  elseif(nargin < 7)				nz = na - n;
   elseif( (!is_scalar(nz)) | (nz < 0 ) | (nz != round(nz)) )
     if(is_scalar(nz))
       error(["illegal value of nz=",num2str(nz)]);
     else
       error(["illegal value of nz=(",num2str(rows(nz)),"x", ...
 	num2str(columns(nz)),")"]);
     endif
   endif
 
   #check for total number of states
   if( (n + nz) != na )
     error(["Illegal: a is ",num2str(na),"x",num2str(na),", n=", ...
 	num2str(n),", nz=",num2str(nz)]);
   endif
 
+  # construct system with default names
+  retsys.a = a;
+  retsys.b = b; 
+  retsys.c = c; 
+  retsys.d = d;
+
+  retsys.n = n;
+  retsys.nz = nz;
+  retsys.tsam = tsam;
+  retsys.yd = zeros(1,p);     # default value entered below
+
+  #  Set the system vector:  active = 2(ss), updated = [0 0 1];
+  retsys.sys = [2 0 0 1]; 
+
+  retsys.stname = sysdefstname(n,nz);
+  retsys.inname = sysdefioname(m,"u");
+  retsys.outname = sysdefioname(p,"y");
+
   # check for state names
-  if(nargin < 8)
-    stname = sysdefstname(n,nz);
-  else
-    nr = rows(stname);
-    if(na != nr)
-      error(["ss2sys: ",num2str(na),"system states,", ...
-	num2str(nr)," state names provided"]);
-    endif
+  if(nargin >= 8)
+    if(!isempty(stname)) retsys = syssetsignals(retsys,"st",stname); endif
   endif
 
   #check for input names
-  if(nargin < 9)
-    inname = sysdefioname(m,"u");
-  elseif( !isstr(inname) )
-    warning("ss2sys: inname=")
-    disp(inname);
-    error("inname must be a string or string matrix.");
-  elseif(rows(inname) != m )
-    warning("ss2sys: inname=")
-    disp(inname);
-    error(["inname has ",num2str(rows(inname))," rows, sys has ", ...
-      num2str(m)," inputs."]);
+  if(nargin >= 9)
+    if(!isempty(inname)) restys = syssetsignals(retsys,"in",inname); endif
   endif
 
   #check for output names
-  if(nargin < 10)
-    outname = sysdefioname(p,"y");
-  elseif( !isstr(outname) )
-    warning("ss2sys: outname=")
-    disp(outname);
-    error("outname must be a string or string matrix.");
-  elseif(rows(outname) != p )
-    warning("ss2sys: outname=")
-    disp(outname);
-    error(["outname has ",num2str(rows(outname))," rows, sys has ", ...
-      num2str(p)," outputs."]);
+  if(nargin >= 10)
+    if(!isempty(outname)) retsys = syssetsignals(retsys,"out",outname); endif
   endif
 
   # set up yd
   if(nargin < 11)
-    yd = ones(1,p)*(tsam > 0);
+    retsys = syssetsignals(retsys,"yd",ones(1,p)*(tsam > 0));
   else
-    yd = zeros(1,p);
-    yd(outlist) = ones(1,length(outlist));
-    if(max(outlist) > p)
-      error(["max outlist index=",num2str(max(outlist)), ...
-	" exceeds number of outputs=",num2str(p)]);
+    if(!isempty(outlist)) 
+      retsys = syssetsignals(retsys,"yd",outlist,ones(size(outlist)));
     endif
   endif
 
-  # Construct the state space system
-  outsys.a = a; 
-  outsys.b = b; 
-  outsys.c = c; 
-  outsys.d = d;
-
-  outsys.n = n;
-  outsys.nz = nz;
-  outsys.tsam = tsam;
-  outsys.yd = yd;
-
-  outsys.stname = stname;
-  outsys.inname = inname;
-  outsys.outname = outname;
-
-  #  Set the system vector:  active = 2(ss), updated = [0 0 1];
-  outsys.sys = [2 0 0 1]; 
-
   implicit_str_to_num_ok = save_val;	# restore value
 endfunction
diff --git a/scripts/control/ss2tf.m b/scripts/control/ss2tf.m
--- a/scripts/control/ss2tf.m
+++ b/scripts/control/ss2tf.m
@@ -29,17 +29,17 @@ function [num,den] = ss2tf(a,b,c,d)
 #                num(s)
 #          G(s)=-------
 #                den(s)
 #
 # used internally in system data structure manipulations
 
 # Written by R. Bruce Tenison (June 24, 1994) btenison@eng.auburn.edu
 # a s hodel: modified to allow for pure gain blocks Aug 1996
-# $Revision: 1.1.1.1 $
+# $Revision: 2.0.0.0 $
 
 # Check args
   [n,m,p] = abcddim(a,b,c,d);
   if (n == -1)
     num = [];
     den = [];
     error("ss2tf: Non compatible matrix arguments");
   elseif ( (m != 1) | (p != 1))
diff --git a/scripts/control/ss2zp.m b/scripts/control/ss2zp.m
--- a/scripts/control/ss2zp.m
+++ b/scripts/control/ss2zp.m
@@ -22,17 +22,17 @@ function [zer,pol,k] = ss2zp(a,b,c,d)
 # [pol,zer,k] = ss2zp(a,b,c,d) returns the poles and zeros of the state space 
 # system (a,b,c,d).  K is a gain associated with the zeros.
 #
 # used internally in system data structure manipulations
 
 # Written by David Clem August 15, 1994
 # Hodel: changed order of output arguments to zer, pol, k. July 1996
 # a s hodel: added argument checking, allow for pure gain blocks aug 1996
-# $Revision: 1.1.1.1 $
+# $Revision: 2.0.0.0 $
 
   if(nargin != 4)
     usage("[zer,pol,k] = ss2zp(a,b,c,d)");
   endif
 
   [n,m,p] = abcddim(a,b,c,d);
   if (n == -1)
     error("ss2tf: Non compatible matrix arguments");
diff --git a/scripts/control/starp.m b/scripts/control/starp.m
--- a/scripts/control/starp.m
+++ b/scripts/control/starp.m
@@ -41,26 +41,17 @@ function [sys] = starp(P, K, ny, nu);
 # If ny and nu "consume" all inputs and outputs of K then the result
 # is a lower fractional transformation. If ny and nu "consume" all
 # inputs and outputs of P then the result is an upper fractional
 # transformation.
 #
 # ny and/or nu may be negative (= negative feedback)
 
 # Written by Kai Mueller May 1998
-# $Revision: 1.1.1.1 $
-# $Log: starp.m,v $
-# Revision 1.1.1.1  1998/05/19 20:24:08  jwe
-#
-# Revision 1.1  1998/05/05 17:04:20  scotte
-# Initial revision
-#
-# Revision 1.1  1998/05/04  15:12:14  mueller
-# Initial revision
-#
+# $Revision: 2.0.0.0 $
 
   if((nargin != 2) && (nargin != 4))
     usage("[sys] = starp(P, K, ny, nu)");
   endif
   if (!is_struct(P))
     error("---> P must be in system data structure");
   endif
   if (!is_struct(K))
diff --git a/scripts/control/step.m b/scripts/control/step.m
--- a/scripts/control/step.m
+++ b/scripts/control/step.m
@@ -31,26 +31,17 @@ function [y, t] = step(sys, inp, tstop, 
 # When the step function is invoked with the output parameter y
 # a plot is not displayed.
 #
 # See also: impulse, stepimp
 
 # Written by Kai P. Mueller September 30, 1997
 # based on lsim.m of Scottedward Hodel
 # modified by
-# $Revision: 1.1.1.1 $
-# $Log: step.m,v $
-# Revision 1.1.1.1  1998/05/19 20:24:08  jwe
-#
-# Revision 1.3  1997/12/01 16:51:50  scotte
-# updated by Mueller 27 Nov 97
-#
-# Revision 1.1  1997/11/11  17:34:34  mueller
-# Initial revision
-#
+# $Revision: 2.0.0.0 $
 
   if((nargin < 1) || (nargin > 4))
     usage("[y, u] = step(sys[, inp, tstop, n])");
   endif
 
   if(nargout > 2)
     usage("[y, u] = step(sys[, inp, tstop, n])");
   endif
diff --git a/scripts/control/stepimp.m b/scripts/control/stepimp.m
--- a/scripts/control/stepimp.m
+++ b/scripts/control/stepimp.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1996 A. Scottedward Hodel
+# Copyright (C) 1996,1998 A. Scottedward Hodel
 #
 # This file is part of Octave. 
 #
 # Octave is free software; you can redistribute it and/or modify it 
 # under the terms of the GNU General Public License as published by the 
 # Free Software Foundation; either version 2, or (at your option) any 
 # later version. 
 # 
@@ -26,80 +26,51 @@ function [y, t] = stepimp(sitype, sys, i
 #
 # Limited argument checking; "do not attempt to do this at home".
 # Use step or impulse instead.
 #
 # See also:  step, impulse
 
 # Written by Kai P. Mueller October 2, 1997
 # based on lsim.m of Scottedward Hodel
-# $Revision: 1.1.1.1 $
-# $Log: stepimp.m,v $
-# Revision 1.1.1.1  1998/05/19 20:24:08  jwe
-#
-# Revision 1.4  1998/05/05 17:04:35  scotte
-# minor corrections by Kai Mueller 5 May 1998
-#
-# Revision 1.1  1998/05/04  15:12:42  mueller
-# Initial revision
-#
-# Revision 1.3  1997/12/01 16:51:50  scotte
-# updated by Mueller 27 Nov 97
-#
-# Revision 1.4  1997/11/26  17:41:18  mueller
-# impulse gives now expected results for continuous and discrete systems
-#
-# Revision 1.3  1997/11/24  18:57:57  mueller
-# gset autoscale for proper scaling
-#
-# Revision 1.2  1997/11/24  17:23:38  mueller
-# call to oneplot() and gset nokey added
-#
-# Revision 1.1  1997/11/11  17:34:50  mueller
-# Initial revision
-#
+# $Revision: 2.0.0.0 $
 
-  if (sitype == 1)
-    IMPULSE = 0;
-  elseif (sitype == 2)
-    IMPULSE = 1;
-  else
-    error("stepimp: illegal sitype argument.")
+  if (sitype == 1)         IMPULSE = 0;
+  elseif (sitype == 2)     IMPULSE = 1;
+  else		   	   error("stepimp: illegal sitype argument.")
   endif
   sys = sysupdate(sys,"ss");
 
   USE_DEF = 0;   # default tstop and n if we have to give up
   N_MIN = 50;    # minimum number of points
   N_MAX = 2000;  # maximum number of points
   T_DEF = 10.0;  # default simulation time
+
   # collect useful information about the system
-  NOUT = rows(sys.c);
-  NIN = columns(sys.b);
-  if (nargin < 3)
-    inp = 1;
-  elseif ((inp < 1) || (inp > NIN))
-    error("Argument inp out of range")
+  [ncstates,ndstates,NIN,NOUT] = sysdimensions(sys);
+  TSAMPLE = sysgettsam(sys);
+
+  if (nargin < 3)                      inp = 1;
+  elseif (inp < 1 | inp > NIN)         error("Argument inp out of range")
   endif
+
   DIGITAL = is_digital(sys);
   if (DIGITAL)
-    NSTATES = sys.nz;
-    TSAMPLE = sys.tsam;
+    NSTATES = ndstates;
     if (TSAMPLE < eps)
       error("stepimp: sampling time of discrete system too small.")
     endif
-  else
-    NSTATES = sys.n;
-  endif
+  else        NSTATES = ncstates;       endif
   if (NSTATES < 1)
-    error("step: n < 1, step response is trivial")
+    error("step: pure gain block (n_states < 1), step response is trivial");
   endif
   if (nargin < 5)
     # we have to compute the time when the system reaches steady state
     # and the step size
-    ev = eig(sys.a);
+    ev = eig(sys2ss(sys));
     if (DIGITAL)
       # perform bilinear transformation on poles in z
       for i = 1:NSTATES
         pole = ev(i);
 	if (abs(pole + 1) < 1.0e-10)
 	  ev(i) = 0;
 	else
 	  ev(i) = 2 / TSAMPLE * (pole - 1) / (pole + 1);
@@ -194,17 +165,18 @@ function [y, t] = stepimp(sitype, sys, i
       endif
       if (n > N_MAX)
     	tstop = (n - 1) * t_step;
 	t_step = tstop / (N_MAX - 1);
 	n = N_MAX;
       endif
     endif
     tstop = (n - 1) * t_step;
-    B = sys.b(:,inp);
+    [jnk,B] = sys2ss(sys);
+    B = B(:,inp);
     sys = c2d(sys, t_step);
   endif
   #printf("##STEPIMP-DEBUG: t_step=%f n=%d  tstop=%f\n", t_step, n, tstop);
 
   F = sys.a;
   G = sys.b(:,inp);
   C = sys.c;
   D = sys.d(:,inp);
@@ -251,17 +223,18 @@ function [y, t] = stepimp(sitype, sys, i
         ssys = ss2sys(F, G, C, D, t_step);
         gm = dcgain(ssys);
 	tt = "step";
       endif
       ncols = floor(sqrt(NOUT));
       nrows = ceil(NOUT / ncols);
       for i = 1:NOUT
         subplot(nrows, ncols, i);
-	title([tt, ": | ", sys.inname(inp,:), " -> ", sys.outname(i,:)]);
+	title(sprintf("%s: | %s -> %s", tt,sysgetsignals(sys,"in",inp,1), ...
+	  sysgetsignals(sys,"out",i,1)));
 	if (DIGITAL)
 	  [ts, ys] = stairs(t, y(i,:));
 	  ts = ts(1:2*n-2)';  ys = ys(1:2*n-2)';
 	  if (length(gm) > 0)
 	    yy = [ys; gm(i)*ones(size(ts))];
 	  else
 	    yy = ys;
 	  endif
@@ -280,17 +253,18 @@ function [y, t] = stepimp(sitype, sys, i
 	  ylabel("y(t)");
 	  plot(t, yy);
 	endif
       endfor
       # leave gnuplot in multiplot mode is bad style
       oneplot();
     else
       # plot everything in one diagram
-      title([tt, " response | ", sys.inname(inp,:), " -> all outputs"]);
+      title([tt, " response | ", sysgetsignals(sys,"in",inp,1), ...
+	" -> all outputs"]);
       if (DIGITAL)
         stairs(t, y(i,:));
       else
 	grid("on");
 	xlabel("time [s]");
 	ylabel("y(t)");
 	plot(t, y(i,:));
       endif
diff --git a/scripts/control/strappend.m b/scripts/control/strappend.m
--- a/scripts/control/strappend.m
+++ b/scripts/control/strappend.m
@@ -11,24 +11,26 @@
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
 # for more details.
 # 
 # You should have received a copy of the GNU General Public License 
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
-function retval = strappend(str,suffix);
-  # retval = strappend(str,suffix);
-  # append string suffix to each string in the string matrix str
+function retval = strappend(strlist,suffix);
+  # retval = strappend(strlist,suffix);
+  # append string suffix to each string in the list of strings strlist
   
   if(nargin != 2 | nargout > 1)
-    usage(" retval = strappend(str,suffix)");
-  elseif(!isstr(str) | !isstr(suffix))
-    error("Both arguments must be strings")
+    usage(" retval = strappend(strlist,suffix)");
+  elseif(!is_signal_list(strlist))
+    error("strlist must be a list of strings (see is_signal_list)");
+  elseif(!(isstr(suffix) & is_vector(suffix)))
+    error("suffix must be a single string");
   endif
 
-  for ii=1:rows(str)
-    newst = [dezero(str(ii,:)),suffix];
-    retval(ii,1:length(newst)) = (newst);
+  retval = list();
+  for ii=1:length(strlist)
+    retval(ii) = sprintf("%s%s",nth(strlist,ii),suffix);
   endfor
 
 endfunction
diff --git a/scripts/control/susball.m b/scripts/control/susball.m
--- a/scripts/control/susball.m
+++ b/scripts/control/susball.m
@@ -20,17 +20,18 @@
     eval(cmd);
     
     disp("Design LQG controller");
     cmd = "sysout(ballsys)";
     run_cmd
     disp("add noise inputs to system...")
  
     disp("discrete system:")
-    cmd = "ballsys = sysappend(ballsys,eye(ballsys.nz));";
+    [nn,nz,mm,pp] = sysdimensions(ballsys);
+    cmd = "ballsys = sysappend(ballsys,nz);";
     run_cmd 
 
     cmd = "sysout(ballsys)";
     run_cmd
 
     disp("Notice the two additional inputs, u_2, and u_3.  These are the ");
     disp("""entry points"" for the gaussian noise disturbance.");
     disp(" ");
@@ -39,17 +40,17 @@
     cmd = "ballsys=sysprune(ballsys,1,[]);";
     run_cmd
     cmd = "sysout(ballsys)";
     run_cmd
 
     disp("Now design an LQG controller: Sigw: input noise")
     Sigw = eye(2)
     disp("Now design an LQG controller: Sigv: measurement noise")
-    Sigv = eye(rows(ballsys.c))
+    Sigv = eye(pp);
 
     disp("State and input penalties:")
     Q = eye(2)
     R = 1
     disp("Controlled input is input 1");
 
     cmd="Ksys = lqg(ballsys,Sigw,Sigv,Q,R,1);";
     run_cmd
diff --git a/scripts/control/swap.m b/scripts/control/swap.m
--- a/scripts/control/swap.m
+++ b/scripts/control/swap.m
@@ -17,14 +17,14 @@
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function [a1,b1] = swap(a,b)
   # [a1,b1] = swap(a,b)
   # interchange a and b
 
   # A. S. Hodel July 24 1992
   # Conversion to Octave R. Bruce Tenison July 4, 1994
-  # $Revision: 1.1 $
+  # $Revision: 2.0.0.0 $
 
   a1 = b;
   b1 = a;
 endfunction
 
diff --git a/scripts/control/swapcols.m b/scripts/control/swapcols.m
--- a/scripts/control/swapcols.m
+++ b/scripts/control/swapcols.m
@@ -17,15 +17,15 @@
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function B = swapcols(A)
   # function B = swapcols(A)
   # permute columns of A into reverse order
   
   # A. S. Hodel July 23, 1992
   # Conversion to Octave R. Bruce Tenison July 4, 1994
-  # $Revision: 1.1 $
+  # $Revision: 2.0.0.0 $
 
   m = length(A(1,:));
   idx = m:-1:1;
   B = A(:,idx);
 endfunction
 
diff --git a/scripts/control/swaprows.m b/scripts/control/swaprows.m
--- a/scripts/control/swaprows.m
+++ b/scripts/control/swaprows.m
@@ -17,15 +17,15 @@
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function B = swaprows(A)
   # function B = swaprows(A)
   # permute rows of A into reverse order
 
   # A. S. Hodel July 23, 1992
   # Conversion to Octave R. Bruce Tenison July 4, 1994
-  # $Revision: 1.1.1.1 $
+  # $Revision: 2.0.0.0 $
   
   m = rows(A);
   idx = m:-1:1;
   B = A(idx,:);
 endfunction
 
diff --git a/scripts/control/sys2fir.m b/scripts/control/sys2fir.m
--- a/scripts/control/sys2fir.m
+++ b/scripts/control/sys2fir.m
@@ -11,36 +11,36 @@
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
 # for more details.
 # 
 # You should have received a copy of the GNU General Public License 
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
-function [c,tsam,input,output] = sys2fir(sys)
-# function [c,tsam,input,output] = sys2fir(sys)
+function [c,tsam,inname,outname] = sys2fir(sys)
+# function [c,tsam,inname,outname] = sys2fir(sys)
 # extract fir system from system data structure
 
-# $Revision: 1.1.1.1 $
+# $Revision: 2.0.0.0 $
 # a s hodel July 1996
 
-  sys=sysupdate(sys,"tf");		# make sure it's SISO
-  alph = sys.den(1);			# scale to get monic denominator
-  sys.den = sys.den/alph;
-  sys.num = sys.num/alph;
-  l = length(sys.den);
-  m = length(sys.num);
-  if( norm(sys.den(2:l)) )
+  # let sys2tf do most of the work
+
+  [num,den,tsam,inname,outname] = sys2tf(sys);
+
+  alph = den(1);			# scale to get monic denominator
+  den = den/alph;
+  num = num/alph;
+  l = length(den);
+  m = length(num);
+  if( norm(den(2:l)) )
     sysout(sys,"tf");
     error("denominator has poles away from origin");
   elseif( !is_digital(sys) )
     error("system must be discrete-time to be FIR");
   elseif(m != l)
     warning(["sys2fir: deg(num) - deg(den) = ",num2str(m-l), ...
 	"; coefficients must be shifted"]);
   endif
-  c = sys.num;
-  tsam = sys.tsam;
-  input = sys.inname;
-  output = sys.outname;
+  c = num;
 endfunction
 
diff --git a/scripts/control/sys2ss.m b/scripts/control/sys2ss.m
--- a/scripts/control/sys2ss.m
+++ b/scripts/control/sys2ss.m
@@ -36,41 +36,41 @@ function [a,b,c,d,tsam,n,nz,stname,innam
   #          inputs, and outputs, respectively
   #    yd: binary vector; yd(ii) is nonzero if output y is discrete.
   # 
   # A warning message is printed if the system is a mixed 
   # continuous/discrete system.
 
   # Written by David Clem August 19, 1994
   # Updates by John Ingram July 14, 1996
-  # $Revision: 1.4 $
+  # $Revision: 2.0.0.0 $
 
   if(nargin != 1)
     usage("[a,b,c,d,tsam,n,nz,stname,inname,outname,yd] = sys2ss(sys)")
   endif
 
   if (nargout > 11)
     warning(["sys2ss: ",num2str(nargout)," out arguments exceeds max=11"])
     usage("[a,b,c,d,tsam,n,nz,stname,inname,outname,yd] = sys2ss(sys)")
   endif
 
   if( ! is_struct(sys) )
     error("input argument must be a system data structure");
   endif
 
-  sys = sysupdate(sys,"ss");		#make sure ss is up to date
+  sys = sysupdate(sys,"ss");        # make sure state space data is there
+  [n,nz,m,p] = sysdimensions(sys);
+  [stname,inname,outname,yd] = sysgetsignals(sys);
+  tsam = sysgettsam(sys);
 
-  cont = sum(sys.yd == 0) + sys.n;
-  dig = sum(sys.yd != 0) + sys.nz + sys.tsam;
+  cont = sum(yd == 0) + n;
+  dig = sum(yd != 0) + nz + tsam;
   if(cont*dig)
     warning("sys2ss: input system is mixed continuous/discrete");
   endif
 
   a = sys.a;
   b = sys.b;
   c = sys.c;
   d = sys.d;
-  [n,nz,m,p] = sysdimensions(sys);
-  [stname,inname,outname,yd] = sysgetsignals(sys);
-  tsam = sysgettsam(sys);
 
 endfunction
 
diff --git a/scripts/control/sys2tf.m b/scripts/control/sys2tf.m
--- a/scripts/control/sys2tf.m
+++ b/scripts/control/sys2tf.m
@@ -26,17 +26,17 @@ function [num,den,tsam,inname,outname] =
 #                den(s)
 #
 # The user can also have the sampling time (TSAM), the name of the input 
 # (INNAME), and the output name (OUTNAME)
 
 # Written by R. Bruce Tenison (June 24, 1994) btenison@eng.auburn.edu
 # modified to make sys2tf by A. S. Hodel Aug 1995
 # modified again for updated system format by John Ingram July 1996
-# $Revision: 1.2 $
+# $Revision: 2.0.0.0 $
 
   if(nargin != 1)
     usage("[num,den,tsam,inname,outname] = sys2tf(Asys)");
   endif
 
   if( !is_struct(Asys))
     error("Asys must be a system data structure (see ss2sys, tf2sys, zp2sys)");
   elseif (! is_siso(Asys) )
@@ -45,14 +45,14 @@ function [num,den,tsam,inname,outname] =
         ", num2str(p)," outputs"]);
   endif
 
   Asys = sysupdate(Asys,"tf");		# just in case
 
   num = Asys.num;
   den = Asys.den;
   
-  tsam = Asys.tsam;
-  inname = Asys.inname;
-  outname = Asys.outname;
+  tsam = sysgettsam(Asys);
+  inname = sysgetsignals(Asys,"in");
+  outname = sysgetsignals(Asys,"out");
 
 endfunction
 
diff --git a/scripts/control/sys2zp.m b/scripts/control/sys2zp.m
--- a/scripts/control/sys2zp.m
+++ b/scripts/control/sys2zp.m
@@ -24,17 +24,17 @@ function [zer,pol,k,tsam,inname,outname]
 # outputs:
 #   zer: vector of system zeros
 #   pol: vector of system poles
 #   k: scalar leading coefficient
 #   tsam: sampling period. default: 0 (continuous system)
 #   inname, outname: input/output signal names (strings)
 
 # Created by John Ingram July 15 1996
-# $Revision: 1.2 $
+# $Revision: 2.0.0.0 $
 
   if(nargin != 1)
     usage("[zer,pol,k,tsam,inname,outname] = sys2zp(sys)");
   elseif( !is_struct(sys))
     error("sysconnect: sys must be in system data structure form")
   elseif (! is_siso(sys) )
     [n, nz, m, p] = sysdimensions(sys);
     error(["system is not SISO (",num2str(m)," inputs, ...
@@ -42,15 +42,15 @@ function [zer,pol,k,tsam,inname,outname]
   endif
 
   # update zero-pole form
   sys = sysupdate(sys,"zp");
 
   zer = sys.zer;
   pol = sys.pol;
   k = sys.k;
-  tsam = sys.tsam;
-  inname = sys.inname;
-  outname = sys.outname;
+  tsam    = sysgettsam(sys);
+  inname  = sysgetsignals(sys,"in");
+  outname = sysgetsignals(sys,"out");
 
 endfunction
 
 
diff --git a/scripts/control/sysadd.m b/scripts/control/sysadd.m
--- a/scripts/control/sysadd.m
+++ b/scripts/control/sysadd.m
@@ -31,17 +31,17 @@ function sys = sysadd(Gsys,Hsys)
 #             ----|  Gsys  |---
 #        u   |    ----------  +|         
 #        -----                (_)----> y
 #            |     ________   +|
 #             ----|  Hsys  |---
 #                  --------
 
 # Written by John Ingram July 1996
-# $Revision: 1.2 $
+# $Revision: 2.0.0.0 $
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
   if(nargin != 2)
     usage("sysadd:  [sys] = sysysadd(Gsys,Hsys)");
   endif
 
@@ -62,26 +62,25 @@ function sys = sysadd(Gsys,Hsys)
   [Gst, Gin, Gout, Gyd] = sysgetsignals(Gsys);
   [Hst, Hin, Hout, Hyd] = sysgetsignals(Hsys);
 
   # check for digital to continuous addition
   if (Gyd != Hyd)
     error("can not add a discrete output to a continuous output");
   endif
 
-  if( (Gsys.sys(1) == 0) | (Hsys.sys(1) == 0) )
+  if( strcmp(sysgettype(Gsys),"tf") | strcmp(sysgettype(Hsys),"tf") )
     # see if adding  transfer functions with identical denominators
-    Gsys = sysupdate(Gsys,"tf");
-    Hsys = sysupdate(Hsys,"tf");
-    if(Hsys.den == Gsys.den)
-      sys = Gsys;
-      sys.sys(1) = 0;
-      sys.num = sys.num + Hsys.num;
+    [Gnum,Gden,GT,Gin,Gout] = sys2tf(Gsys);
+    [Hnum,Hden,HT,Hin,Hout] = sys2tf(Hsys);
+    if( (Hden == Gden) & (HT == GT) )
+      sys = tf2sys(Gnum+Hnum,Gden,GT,Gin,Gout);
       return
     endif
+    # if not, we go on and do the usual thing...
   endif
 
   # make sure in ss form
   Gsys = sysupdate(Gsys,"ss");
   Hsys = sysupdate(Hsys,"ss");
 
   sys = sysgroup(Gsys,Hsys);
 
diff --git a/scripts/control/sysappend.m b/scripts/control/sysappend.m
--- a/scripts/control/sysappend.m
+++ b/scripts/control/sysappend.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1996 A. Scottedward Hodel 
+# Copyright (C) 1996,1998 A. Scottedward Hodel 
 #
 # This file is part of Octave. 
 #
 # Octave is free software; you can redistribute it and/or modify it 
 # under the terms of the GNU General Public License as published by the 
 # Free Software Foundation; either version 2, or (at your option) any 
 # later version. 
 # 
@@ -43,160 +43,125 @@ function retsys = sysappend(sys,b,c,d,ou
   # outputs are be assigned default names.  
   # yd is a vector of length rows(c), and indicates which new outputs are
   # discrete (yd(ii) = 1) and which are continuous (yd(ii) = 0).
   # Default value for yd is:
   #     sys = continuous or mixed: yd = zeros(1,rows(c))
   #     sys = discrete:            yd = ones(1,rows(c))
   
   # written by John Ingram August 1996
-  # $Revision: 1.2 $
-  # $Log: sysappend.m,v $
-  # Revision 1.2  1998/07/21 14:53:09  hodelas
-  # use isempty instead of size tests; use sys calls to reduce direct
-  # access to system structure elements
-  #
-  # Revision 1.1.1.1  1998/05/19 20:24:09  jwe
-  #
-  # Revision 1.2  1997/04/09 04:36:21  scotte
-  # Fixed to properly handle new names (syschnames does not let you
-  # change the number of names any more.)  a.s.hodel@eng.auburn.edu
-  #
+  # $Revision: 2.0.0.0 $
   
-  save_val = implicit_str_to_num_ok;	# save for later
-  implicit_str_to_num_ok = 1;
+  sav_implicit_str_to_num_ok = implicit_str_to_num_ok;	# save for later
+  sav_empty_list_elements_ok = empty_list_elements_ok;
+
+  empty_list_elements_ok = 1;                implicit_str_to_num_ok = 1;
   
   # check input arguments
   if ( (nargin < 2) | (nargin > 7) | (!is_struct(sys)))
     usage("retsys = sysappend(sys,b,c[,d,outname,inname,yd]) ");
-  endif
-  
-  # update system
-  sys = sysupdate(sys,"ss");
-  sys.sys = [2 0 0 1];
-  
-  #default c
-  if(nargin < 3)
-    c = [];
-  endif
-  
-  #default d
-  if(nargin < 4)
-    make_d = 1;
-  elseif(isempty(d))
-    make_d = 1;
-  else
-    make_d = 0;
-  endif
-  if(make_d)
-    d = zeros(rows(c)+rows(sys.c),columns(b) + rows(sys.inname));
-    #disp("sysappend: default d=")
-    #disp(d)
-    #disp("/sysappend: default d=")
-  endif
-
-  # add default input names for new inputs (if any)
-  old_m = rows(sys.inname);
-  new_m = max(columns(d),columns(b)+old_m);
-  old_inname = sys.inname;
-  if(new_m)
-    sys.inname = sysdefioname(new_m,"u");
-    if(old_m)
-      sys = syschnames(sys,"in",1:old_m,old_inname);
-    endif
-    if(nargin >= 6)
-      # input names were specified, check dimensions
-      if(rows(inname) != new_m - old_m)
-        inname
-        new_m
-        old_m
-        b
-        d
-        error(["inname has ",num2str(rows(inname))," entries, should have ", ...
-	  num2str( new_m - old_m )]);
-      endif
-      sys = syschnames(sys,"in",(old_m+1):new_m,inname);
-    endif
-  endif
-
-  #add default output names for new outputs (if any)
-  old_p = rows(sys.outname);
-  new_p = max(rows(d),rows(c)+old_p);
-
-  # default yd
-  if (nargin < 7)
-    # discrete if positive sampling time, no continuous states/outputs
-    yd = ones(1,new_p)*( ...
-         (sys.tsam > 0) & (sys.n == 0)  & isempty(find(sys.yd == 0)) ) ;
-  elseif ( (rows(c) != length(yd)) & (rows(d)) != yd)
-    error(["rows(c)=",num2str(rows(c)),", length(yd)=",num2str(length(yd))])
+  elseif(!is_struct(sys))
+    error("sys must be a system data structure");
   endif
   
-  old_outname = sys.outname;
-  if(new_p)
-    sys.outname = sysdefioname(new_p,"y");
-    if(old_p)
-      sys = syschnames(sys,"out",1:old_p,old_outname); 
+  # default system type must be state space form
+  [Aa,Ab,Ac,Ad,Ats,Ann,Anz,Ast,Ain,Aout,Ayd] = sys2ss(sys);
+  [Ann,Anz,Am,Ap] = sysdimensions(sys);
+
+  #default c
+  if(nargin < 3)      c = [];                                endif
+  
+  #default d
+  if(nargin < 4)     make_d = 1;
+  elseif(isempty(d)) make_d = 1;
+  else               make_d = 0;                             endif
+  if(make_d)         d = zeros(rows(c)+Ap,columns(b) + Am);  endif
+
+  #
+  # Append new input(s) if any
+  Bm = max(columns(d),columns(b)+Am);
+  if(Bm != Am)    
+    # construct new signal names
+    if(nargin >= 6)   # new names were passed
+      if(!isstr(inname))
+        error("inname must be a string");
+      elseif(rows(inname) != (Bm - Am))
+        error(sprintf("%d new inputs requested; inname(%dx%d)", ...
+	  (Bm-Am),rows(inname),columns(inname)));
+      endif
+    else
+      inname = sysdefioname(Bm,"u",(Am+1));
     endif
-    if(nargin >= 5)
-      # output names were specified, check dimensions
-      if(rows(outname) != new_p - old_p)
-        outname
-        new_p
-        old_p
-        c
-        d
-        error(["outname has ",num2str(rows(outname)), ...
-          " entries, should have ", num2str(new_p-old_p)]);
-      endif
-      sys = syschnames(sys,"out",(old_p+1):new_p,outname);
+    if(Am)   Ain = append(Ain,inname);
+    else     Ain = inname;		endif
+
+    # default b matrix
+    if(isempty(b))     b  = zeros(Ann+Anz,(Bm-Am));          
+    elseif(rows(b) != Ann+Anz | columns(b) != (Bm-Am))
+        error(sprintf("b(%dx%d); should be (%dx%d)", rows(b), columns(b), ...
+          (Ann+Anz), (Bm-Am)));
     endif
+
+    # append new b matrix
+    Ab = [Ab,b];    # empty_list_elements_ok=1 makes this ok
   endif
 
-  sys = syschnames(sys,"yd",(old_p+1):new_p,yd);
+  #
+  # Append new output(s) if any
+  Bp = max(rows(d),rows(c)+Ap);
+  if(Bp != Ap)  
 
-  # append new b matrix (if any)
-  if( max(size(b)) )
-    if(rows(b) != sys.n + sys.nz)
-      error(["sys has ",num2str(sys.n + sys.nz)," states; b has ", ...
-  	num2str(rows(b))," rows"]);
+    # construct new signal names, output classification
+    if(nargin >= 5)  # new names were passed
+      if(!isstr(outname))
+        error("outname must be a string");
+      elseif(rows(outname) != (Bp - Ap))
+        error(sprintf("%d new outputs requested; outname(%dx%d)", ...
+          (Bp-Ap),rows(outname),columns(outname)));
+      endif
     else
-      if(old_m)
-        sys.b = [sys.b,b];
-      else
-        sys.b = b;
-      endif
+      outname = sysdefioname(Bp,"y",(Ap+1));
     endif
-  endif
-  
-  # append new c matrix (if any)
-  if(max(size(c)))
-    if(columns(c) != sys.n + sys.nz)
-      error(["sys has ",num2str(sys.n + sys.nz)," states; c has ", ...
-  	num2str(columns(c))," columns"]);
+    if(Ap)   Aout = append(Aout,outname);
+    else     Aout = outname;                endif
+
+    # construct new yd entries
+    if(nargin == 7)
+      if(!is_vector(yd))
+        error(sprintf("yd(%dx%d) must be a vector",rows(yd),columns(yd)))
+      elseif(rows(c) != length(yd) & rows(d) != length(yd))
+        error(sprintf("length(yd) = %d; c(%dx%d), d(%dx%d); mismatch", ...
+	  length(yd), rows(c), columns(c),rows(d),columns(d)));
+      endif
     else
-      if(old_p)
-        sys.c = [sys.c;c];
-      else
-        sys.c = c;
-      endif
+      # default yd values
+      yd = ones(1,Bp)*( (Ats > 0) & (Ann == 0)  & isempty(find(Ayd == 0)) ) ;
+    endif
+    Ayd = [vec(Ayd);vec(yd)];
+
+    # default c matrix
+    if(isempty(c))      c = zeros((Bp-Ap),Ann+Anz);          
+    elseif(columns(c) != Ann+Anz | rows(c) != (Bp-Ap))
+        error(sprintf("c(%dx%d); should be (%dx%d)", rows(c), columns(c), ...
+          (Bp-Ap), (Ann+Anz) ));
     endif
+
+    # append new c matrix
+    Ac = [Ac;c];    # empty_list_elements_ok=1 makes this ok
   endif
+
+  # check d matrix
+  if(isempty(d)) d = zeros(Bp,Bm);
+  elseif(rows(d) != Bp | columns(d) != Bm)
+    error(sprintf("d(%dx%d) should be (%dx%d)",rows(d), columns(d), Bp, Bp));
+  endif
+
+  # Splice in original D matrix  
+  if(Am & Ap)          d(1:Ap, 1:Am) = Ad;       endif
+  Ad = d;
   
-  if(max(size(d)))
-    if( (rows(d) != new_p) | (columns(d) != new_m) )
-      error(["d = (",num2str(rows(d)),"x",num2str(columns(d)), ...
-  	") should be (",num2str(new_p),"x",num2str(new_m),")"]);
-    else
-      if(old_m & old_p)
-        d(1:old_p, 1:old_m) = sys.d;
-      endif
-      sys.d = d;
-    endif
-  endif
+  # construct return system
+  retsys = ss2sys(Aa,Ab,Ac,Ad,Ats,Ann,Anz,Ast,Ain,Aout,find(Ayd == 1));
   
-  # append new input names
-
-  retsys = sys;
-  
-  implicit_str_to_num_ok = save_val;	# restore value
+  implicit_str_to_num_ok = sav_implicit_str_to_num_ok;	# restore value
+  empty_list_elements_ok = sav_empty_list_elements_ok;
 
 endfunction
diff --git a/scripts/control/syschnames.m b/scripts/control/syschnames.m
--- a/scripts/control/syschnames.m
+++ b/scripts/control/syschnames.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1996 A. Scottedward Hodel 
+# Copyright (C) 1996,1998 A. Scottedward Hodel 
 #
 # This file is part of Octave. 
 #
 # Octave is free software; you can redistribute it and/or modify it 
 # under the terms of the GNU General Public License as published by the 
 # Free Software Foundation; either version 2, or (at your option) any 
 # later version. 
 # 
@@ -34,108 +34,14 @@ function retsys = syschnames(sys,opt,lis
 #    	names: strings or string arrays containing
 #              names corresponding to the lists above.  To
 # 	       change yd, use a vector.  Set the name to 0 for continuous, 
 #	       or 1 for discrete.
 # outputs:
 #    retsys=sys with appropriate signal names changed 
 #            (or yd values, where appropriate)
 
-# Written by John Ingram August 1996
-# $Revision: 1.3 $
-# $Log: syschnames.m,v $
-# Revision 1.3  1998/07/17 15:31:06  hodelas
-# use is_empty instead of max(size(...))
-#
-
-  save_val = implicit_str_to_num_ok;	# save for later
-  implicit_str_to_num_ok = 1;
-
-  if (nargin != 4)
-    usage("retsys=syschnames(sys,opt,list[,names])");
-  elseif (!is_struct(sys))
-    error("sys must be a system data structure");
-  elseif (isempty(opt))
-    opt = "out";
-  elseif( ! isstr(opt) )
-    error("opt must be a string");
-  elseif( ! (strcmp(opt,"out") + strcmp(opt,"yd") + ...
-    strcmp(opt,"in") + strcmp(opt,"st") ) )
-    error("opt must be one of [], ""out"", ""yd"", ""in"", or ""st""");
-  elseif(min(size(list)) > 1)
-    disp("syschnames: list=")
-    disp(list);
-    error("list must be a vector")
-  endif
-
-  if (strcmp(opt,"out"))
-    # update output names
-    sys.outname = syschnamesl(list,sys.outname,names,"outlist");
-  elseif (strcmp(opt,"in"))
-    sys.inname = syschnamesl(list,sys.inname,names, "inlist");
-  elseif (strcmp(opt,"st"))
-    sys.stname = syschnamesl(list,sys.stname,names,"stlist");
-  else
-    # it's yd
-    ym = max(size(list));
-    ys = min(size(list));
-    maxn = rows(sys.outname);
-
-    if(ym != 0)
-      if( (ym  > maxn) | (ys != 1) )
-        error(["system has ",num2str(maxn)," outputs, ", ...
-	  "list=(",num2str(rows(list)),"x",num2str(columns(list)),")"]);
-      endif
+# Written by John Ingram August 1996; updated by A. S. Hodel 1998
+# $Revision: 2.0.0.0 $
 
-      if( ym != length(names))
-        error(["list has ",num2str(ym)," entries, and names has ",...
-		num2str(length(names))," entries."]);
-      endif
-
-      if (min((names == 1) | (names == 0)) == 0)
-        error("yd must be either zero or one");
-      endif
-
-      if (max(list) > maxn)
-        error(["The largest entry in the list is ",num2str(max(list)),...
-		" exceeds number of outputs=",num2str(maxn)])
-      endif      
-
-      if (max(names) && (sys.tsam == 0) )
-        warning("syschnames: discrete outputs with tsam=0; setting tsam=1");
-        disp("	effected outputs are:")
-        if(is_siso(sys))
-          outlist(sys.outname,"	",[],list);
-        else
-          outlist(sys.outname(list,:),"	",[],list);
-        endif
-        sys.tsam = 1;
-      endif
-
-      # reshape everything as a column vector
-      sys.yd = reshape(sys.yd,length(sys.yd),1);
-      names  = reshape(names,length(names),1);
-
-	#disp("syschnames: list=")
-	#disp(list)
-	#disp("syschnames: names=")
-	#disp(names)
-	#disp("syschnames: sys.yd=")
-	#disp(sys.yd)
-
-      sys.yd(list) = names;
-    
-      if ((min(sys.yd) == 0) && (max(sys.yd) == 0) && (sys.tsam > 0) )
-        warning("discrete states but no discrete outputs selected");
-      endif
-
-    endif
-    
-  endif
-
-  retsys = sys;
-  implicit_str_to_num_ok = save_val;	# restore value
-
-  #disp("syschnames: exiting with")
-  #retsys
-  #disp("/syschnames")
+  retsys = syssetsignals(sys,opt,names,list);
 
 endfunction
diff --git a/scripts/control/syschtsam.m b/scripts/control/syschtsam.m
--- a/scripts/control/syschtsam.m
+++ b/scripts/control/syschtsam.m
@@ -18,28 +18,31 @@
  
 function retsys = syschtsam(sys,tsam)
 #
 # retsys = syschtsam(sys,tsam);
 #
 # This function changes the sampling time (tsam) of the system.
 
 # Written by John Ingram August 1996
-# $Revision: 1.1.1.1 $
+# $Revision: 2.0.0.0 $
 
   if (nargin != 2)
     usage("retsys = syschtsam(sys,tsam)");
   elseif (!is_struct(sys))
     error("sys must be in system data structure form");
   elseif(!is_scalar(tsam))
     disp("syschtsam:")
     tsam
     error("tsam must be a scalar")
   elseif ( ! (is_sample(tsam) | (tsam == 0) ) )
     error("tsam must be real, scalar, and greater than zero");
-  elseif (sys.tsam == 0)
-    error("The system is continuous, use c2d to make the system discrete");
+  elseif (sysgettsam(sys) == 0)
+    [nc,nz,mm,pp] = sysdimensions(sys);
+    warning("syschtsam: continuous system (nc=%d, nz=%d, mm=%d, pp=%d)", ...
+      nc,nz,mm,pp);
+    warning("syschtsam: The system is continuous, use c2d to make the system discrete");
   endif
 
   retsys = sys;  
   retsys.tsam = tsam;
 
 endfunction
diff --git a/scripts/control/sysconnect.m b/scripts/control/sysconnect.m
--- a/scripts/control/sysconnect.m
+++ b/scripts/control/sysconnect.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1996 A. Scottedward Hodel 
+# Copyright (C) 1996,1998 A. Scottedward Hodel 
 #
 # This file is part of Octave. 
 #
 # Octave is free software; you can redistribute it and/or modify it 
 # under the terms of the GNU General Public License as published by the 
 # Free Software Foundation; either version 2, or (at your option) any 
 # later version. 
 # 
@@ -45,27 +45,17 @@ function sys = sysconnect(sys,output_lis
 #                |                             |
 #                -------------------------------
 #
 # The input that has the summing junction added to it has an * added to the end 
 # of the input name.
 
 # A. S. Hodel August 1995
 # modified by John Ingram July 1996
-# $Revision: 1.1.1.1 $
-# $Log: sysconnect.m,v $
-# Revision 1.1.1.1  1998/05/19 20:24:09  jwe
-#
-# Revision 1.3  1997/03/03 19:21:06  hodel
-# removed calls to packsys: a.s.hodel@eng.auburn.edu
-#
-# Revision 1.2  1997/02/13 14:23:18  hodel
-# fixed bug in continuous<->discrete loop connection check.
-# a.s.hodel@eng.auburn.edu
-#
+# $Revision: 2.0.0.0 $
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
   if( (nargin < 3) | (nargin > 5) )
     usage("retsys = sysconnect(sys,output_list,input_list[,order,tol])");
   endif
 
@@ -95,19 +85,18 @@ function sys = sysconnect(sys,output_lis
       error("output_list and input_list must be of the same length")
     endif
     
     if(is_duplicate_entry(output_list) | is_duplicate_entry(input_list) )
       error("duplicate entry in input_list and/or output_list");
     endif
   endif
   
-  mm = rows(sys.inname);
-  pp = rows(sys.outname);
-  nn = rows(sys.stname);
+  [nc,nz,mm,pp] = sysdimensions(sys);
+  nn = nc+nz;
 
   if( !is_struct(sys))
     error("sys must be in structured system form")
   elseif(pp < li)
     error(["length(output_list)=",num2str(li),", sys has only ", ...
 	num2str(pp),"system outputs"])
   elseif(mm < li)
     error(["length(input_list)=",num2str(li),", sys has only ", ...
@@ -125,45 +114,48 @@ function sys = sysconnect(sys,output_lis
 
   # make sure we're in state space form
   sys = sysupdate(sys,'ss');
 
   # permute rows and columns of B,C,D matrices into pseudo-dgkf form...
   all_inputs = sysreorder(mm,input_list);
   all_outputs = sysreorder(pp,output_list);
 
-  sys.b = sys.b(:,all_inputs);
-  sys.c = sys.c(all_outputs,:);
-  sys.d = sys.d(all_outputs,all_inputs);
-  sys.yd = sys.yd(all_outputs);
+  [aa,bb,cc,dd] = sys2ss(sys);
+  bb = bb(:,all_inputs);
+  cc = cc(all_outputs,:);
+  dd = dd(all_outputs,all_inputs);
+
+  yd = sysgetsignals(sys,"yd");
+  yd = yd(all_outputs);
 
   # m1, p1 = number of inputs, outputs that are not being connected
   m1 = mm-li;
   p1 = pp-li;
 
   # m2, p2: 1st column, row of B, C that is being connected
   m2 = m1+1;
   p2 = p1+1;
 
   # partition system into a DGKF-like form; the loop is closed around
   # B2, C2
   if(m1 > 0)
-    B1 = sys.b(:,1:m1);
-    D21= sys.d(p2:pp,1:m1);
+    B1 = bb(:,1:m1);
+    D21= dd(p2:pp,1:m1);
   endif
-  B2 = sys.b(:,m2:mm);
+  B2 = bb(:,m2:mm);
   if(p1 > 0)
-    C1 = sys.c(1:p1,:);
-    D12= sys.d(1:p1,m2:mm);
+    C1 = cc(1:p1,:);
+    D12= dd(1:p1,m2:mm);
   endif
-  C2 = sys.c(p2:pp,:);
+  C2 = cc(p2:pp,:);
   if(m1*p1 > 0)
-    D11= sys.d(1:p1,1:m1);
+    D11= dd(1:p1,1:m1);
   endif
-  D22= sys.d(p2:pp,m2:mm);
+  D22= dd(p2:pp,m2:mm);
 
   if(norm(D22))
     warning("sysconnect: possible algebraic loop, D22 non-zero");
     D22i = (eye(size(D22))-D22);
     C2h = D22i\C2;
     if(m1 > 0)
       D21h = D22i\D21;
     endif
@@ -173,38 +165,38 @@ function sys = sysconnect(sys,output_lis
     if(m1 > 0)
       D21h = D21;
     endif
     D22h = D22;
 
   endif
 
   # check cont state -> disc output -> cont state
-  dyi = find(sys.yd(p2:pp));
+  dyi = find(yd(p2:pp));
 
   #disp("sysconnect: dyi=")
   #dyi
-  #sys.n
+  #nc
   #disp("/sysconnect");
 
-  if( (sys.n > 0) & find(dyi > 0) )
-    B2con = B2(1:sys.n,dyi);	# connection to cont states
-    C2hd = C2h(dyi,1:sys.n);	# cont states -> outputs
+  if( (nc > 0) & find(dyi > 0) )
+    B2con = B2(1:nc,dyi);	# connection to cont states
+    C2hd = C2h(dyi,1:nc);	# cont states -> outputs
   else
     B2con = C2hd = [];
   endif
 
   if(max(size(B2con)) & max(size(C2hd)) )
     if(norm(B2con*C2hd))
       warning("sysconnect: cont-state -> disc output -> cont state derivative");
       warning("    connection made; resulting system may not be meaningful");
     endif
   endif
 
-  Ac = sys.a+B2*C2h;
+  Ac = aa+B2*C2h;
   if(m1 > 0)
     B1c = B1 + B2*D21h;
   endif
   B2c = B2*(eye(size(D22h)) + D22h);
   if(p1*m1 > 0)
     D11c = D11 + D12*D21h;
   endif
   if(p1 > 0)
@@ -242,29 +234,30 @@ function sys = sysconnect(sys,output_lis
 
   Ip = eye(pp,pp);
   Po = Ip(:,all_outputs);
   back_outputs = Po*[1:pp]';
 
   Bc = Bc(:,back_inputs);
   Cc = Cc(back_outputs,:);
   Dc = Dc(back_outputs,back_inputs);
-  sys.yd = sys.yd(back_outputs);
+  yd = yd(back_outputs);
 
-  sys.a = Ac;
-  sys.b = Bc;
-  sys.c = Cc;
-  sys.d = Dc;
+  # rebuild system
+  Ts = sysgettsam(sys);
+  [stnam,innam,outnam] = sysgetsignals(sys);
+  sys = ss2sys(Ac,Bc,Cc,Dc,Ts,nc,nz,stnam,innam,outnam,find(yd));
 
+  # update connected input names
   for ii = 1:length(input_list)
-    strval = [dezero(sys.inname(input_list(ii),:)),"*"];
-    sys.inname(input_list(ii),(1:length(strval))) = [strval];
+    idx = input_list(ii);
+    strval = sprintf("%s*",nth(sysgetsignals(sys,"in",idx),1) );
+    sys = syssetsignals(sys,"in",strval,idx);
   endfor
   
-  if (sys.sys(1) == 0)
-    sysupdate(sys,'tf');
-  elseif (sys.sys(1) == 1)
-    sysupdate(sys,'zp');
+  # maintain original system type if it was SISO
+  if    (strcmp(sysgettype(sys),"tf") )       sysupdate(sys,'tf');
+  elseif(strcmp(sysgettype(sys),"zp") )       sysupdate(sys,'zp');
   endif
 
   implicit_str_to_num_ok = save_val;	# restore value  
 
 endfunction
diff --git a/scripts/control/syscont.m b/scripts/control/syscont.m
--- a/scripts/control/syscont.m
+++ b/scripts/control/syscont.m
@@ -24,17 +24,17 @@ function [csys,Acd,Ccd] = syscont(sys)
 # outputs: csys is the purely continuous input/output connections of
 #               sys
 #          Acd, Ccd: connections from discrete states to continuous states,
 #               discrete states to continuous outputs, respectively.
 #
 # returns csys empty if no continuous/continous path exists
 
 # Written by John Ingram August 1996
-# $Revision: 1.2 $
+# $Revision: 2.0.0.0 $
 
   save_val = implicit_str_to_num_ok;	# save for later
   save_empty = empty_list_elements_ok;
   empty_list_elements_ok = implicit_str_to_num_ok = 1;
 
   if (nargin != 1)
     usage("[csys,Acd,Ccd,Dcd] = syscont(sys)");
   elseif (!is_struct(sys))
@@ -55,24 +55,24 @@ function [csys,Acd,Ccd] = syscont(sys)
     warning("syscont: no continuous outputs");
   endif
 
   [sys_a, sys_b, sys_c, sys_d ] = sys2ss(sys);
   [sys_stname, sys_inname, sys_outname] = sysgetsignals(sys);
   [sys_n, sys_nz, sys_m, sys_p] = sysdimensions(sys);
   if(!isempty(st_c))
     Acc = sys_a(st_c,st_c);
-    stname = sys_stname(st_c, :);
+    stname = sys_stname(st_c);
     Bcc = sys_b(st_c,:);
     Ccc = sys_c(y_c,st_c);
     Acd = sys_a(st_c,st_d);
   else
     stname=[];
   endif
-  outname = sys_outname(y_c,:);
+  outname = sys_outname(y_c);
   Dcc = sys_d(y_c,:);
   Ccd = sys_c(y_c,st_d);
   inname = sys_inname;
   
   csys = ss2sys(Acc,Bcc,Ccc,Dcc,0,sys_n,0,stname,inname,outname);
 
   implicit_str_to_num_ok = save_val;	# restore value
   empty_list_elements_ok = save_empty;
diff --git a/scripts/control/syscont_disc.m b/scripts/control/syscont_disc.m
--- a/scripts/control/syscont_disc.m
+++ b/scripts/control/syscont_disc.m
@@ -23,21 +23,16 @@ function [n_tot,st_c,st_d,y_c,y_d] = sys
 # inputs: sys is a system data structure
 # outputs: n_tot: total number of states
 #	   st_c: vector of continuous state indices (empty if none)
 #	   st_d: vector of discrete state indices (empty if none)
 #	   y_c: vector of continuous output indices
 #	   y_d: vector of discrete output indices
 
 # Written by A. S. Hodel (a.s.hodel@eng.auburn.edu) Feb 1997
-# $Log: syscont_disc.m,v $
-# Revision 1.2  1998/07/15 12:29:13  hodelas
-# Updated to use sysdimensions.  Removed extraneous if commands (find now
-# returns empty matrix if none found)
-#
 
   # get ranges for discrete/continuous states and outputs
   [nn,nz,mm,pp,yd] = sysdimensions(sys);
   n_tot = nn + nz;
   st_c = 1:(nn);
   st_d = nn + (1:nz);
   y_c = find(yd == 0);		# y_c, y_d will be empty if there are none.
   y_d = find(yd == 1);
diff --git a/scripts/control/sysdefioname.m b/scripts/control/sysdefioname.m
--- a/scripts/control/sysdefioname.m
+++ b/scripts/control/sysdefioname.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1996 A. Scottedward Hodel 
+# Copyright (C) 1996,1998 A. Scottedward Hodel 
 #
 # This file is part of Octave. 
 #
 # Octave is free software; you can redistribute it and/or modify it 
 # under the terms of the GNU General Public License as published by the 
 # Free Software Foundation; either version 2, or (at your option) any 
 # later version. 
 # 
@@ -13,51 +13,37 @@
 # for more details.
 # 
 # You should have received a copy of the GNU General Public License 
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function ioname = sysdefioname(n,str,m)
 # function ioname = sysdefioname(n,str[,m])
-# return default input or output names given n, str, m
+# return list of default input or output names given n, str, m
 # n is the final value, str is the string prefix, and m is start value
 # ex: ioname = sysdefioname(5,"u",3)
 #
-# returns: 	ioname = 	u_3
-#				u_4
-#				u_5
+# returns: 	ioname =
+#               (
+#                 [1] = u_3
+#                 [2] = u_4
+#                 [3] = u_5
+#               )
 # used internally, minimal argument checking
 
-# $Log: sysdefioname.m,v $
-
-  save_val = implicit_str_to_num_ok;	# save for later
-  implicit_str_to_num_ok = 1;
-
   if (nargin < 2 | nargin > 3)
     usage("ioname = sysdefioname(n,str[,m])");
   endif
 
-  if (nargin == 2)
-    m = 1;
-  endif
+  if (nargin == 2)           m = min(1,n);            endif
 
+  ioname = list();
   jj = 1;
-
   if(n > 0 & m > 0 & m <= n)
     for ii = m:n
-      strval = [str,"_",num2str(ii)];
-      ioname(jj,1:length(strval)) = strval;
-      jj = jj+1;
+      ioname(ii+1-m) = sprintf("%s_%d",str,ii);
     endfor
-  elseif(n == 0)
-    ioname = "";
   elseif(m > n)
-    error(["start value m=",num2str(m)," > final value n=",num2str(n),"; bad!"])
+    error("str=%s; start value m=%d > final value n=%d",str,m,n);
   endif
 
-  if( !isstr(ioname) )
-    ioname = setstr(ioname);
-  endif
-
-  implicit_str_to_num_ok = save_val;	# restore value
- 
 endfunction
diff --git a/scripts/control/sysdefstname.m b/scripts/control/sysdefstname.m
--- a/scripts/control/sysdefstname.m
+++ b/scripts/control/sysdefstname.m
@@ -16,35 +16,25 @@
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function stname = sysdefstname(n,nz)
 # function stname = sysdefstname(n,nz)
 # return default state names given n, nz
 # used internally, minimal argument checking
 
-# $Revision: 1.2 $
+# $Revision: 2.0.0.0 $
 
-  sav_val = implicit_str_to_num_ok;
-  implicit_str_to_num_ok = 1;
-
-  stname = [];
+  stname = list();
   if(n > 0)
     for ii = 1:n
-      strval = ["x_",num2str(ii)];
-      stname(ii,1:length(strval)) = strval;
+      stname(ii) = sprintf("x_%d",ii);
     endfor
   endif
  
   # Set default names for discrete states
   if(nz > 0)
     for ii = (n+1):(n+nz)
-      strval = ["xd_",num2str(ii)];
-      stname(ii,1:length(strval)) = strval;
+      stname(ii) = sprintf("xd_%d",ii);
     endfor
   endif
 
-  if( !(isstr(stname) | (rows(stname) == 0) ) )
-    stname = setstr(stname);
-  endif
-
-  implicit_str_to_num_ok = sav_val;
 endfunction
diff --git a/scripts/control/sysdimensions.m b/scripts/control/sysdimensions.m
--- a/scripts/control/sysdimensions.m
+++ b/scripts/control/sysdimensions.m
@@ -11,35 +11,54 @@
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, write to the Free
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
-function [n,nz,m,p,yd] = sysdimensions(sys)
-# [n,nz,m,p[,yd]] = sysdimensions(sys)
-# return the number of states, inputs, and outputs in the system sys.
+function [n,nz,m,p,yd] = sysdimensions(sys,opt)
+# [n,nz,m,p,yd] = sysdimensions(sys{,opt})
+# return the number of states, inputs, and/or outputs in the system sys.
 # inputs: sys: system data structure
+#         opt: string
+#              "all" (default): return all output arguments (see below)
+#              "cst": return n=number of continuous states
+#              "dst": return n=number of discrete states
+#              "in":  return n=number of inputs
+#              "out": return n = number of outputs
 # outputs:
-#  n: number of continuous states
+#  n: number of continuous states (or the specified dimension as shown above)
 #  nz: number of discrete states
 #  m: number of system inputs
 #  p: number of system outputs
 #  yd: is the discrete output vector: yd(ii) = 1 if output ii is sampled,
 #   				    yd(ii) = 0 if output ii is continous
 #
 # see also: sysgetsignals, sysgettsam
 
-if(nargout > 5 | nargin != 1)
-  usage("[n,nz,m,p[,yd]] = sysdimensions(sys)");
+if(nargout > 5 | nargin < 1 | nargin > 2)
+  usage("[n,nz,m,p[,yd]] = sysdimensions(sys{,opt})");
 elseif(!is_struct(sys))
   usage("[n,nz,m,p] = sysdimensions(sys)");
+elseif(nargin == 1)
+  opt = "all";
 endif
 
 n = sys.n;
 nz = sys.nz;
-m = rows(sys.inname);
-p = rows(sys.outname);
+m = length(sysgetsignals(sys,"in"));
+p = length(sysgetsignals(sys,"out"));
 yd = sys.yd;
+legal_options = list("all","cst","dst","in","out");
+legal_values = list(n,n,nz,m,p);
+
+for ii=1:length(legal_options)
+  if(strcmp(nth(legal_options,ii),opt))
+    n = nth(legal_values,ii);
+    if(ii > 1 & nargout > 1)
+      warning("opt=%s, %d output arguments requested",opt,nargout);
+    endif
+  endif
+endfor
 
 endfunction
diff --git a/scripts/control/sysdisc.m b/scripts/control/sysdisc.m
--- a/scripts/control/sysdisc.m
+++ b/scripts/control/sysdisc.m
@@ -21,17 +21,17 @@ function [dsys,Adc,Cdc] = sysdisc(sys)
 # inputs: sys = system data structure
 # outputs:
 #    dsys: purely discrete portion of sys (returned empty if there is
 #          no purely discrete path from inputs to outputs)
 #    Adc, Cdc: connections from continuous states to discrete states/discrete
 #    outputs, respectively.
 #
 
-# $Revision: 1.1.1.1 $
+# $Revision: 2.0.0.0 $
 
   save_val = implicit_str_to_num_ok;	# save for later
   save_empty = empty_list_elements_ok;
   empty_list_elements_ok = implicit_str_to_num_ok = 1;
 
 
   if (nargin != 1)
     usage("[dsys,Adc,Cdc] = sysdisc(sys)");
@@ -48,43 +48,45 @@ function [dsys,Adc,Cdc] = sysdisc(sys)
   if(isempty(st_d) & isempty(y_d))
     error("sysdisc: expecting discrete states and/or continous outputs");
   elseif (isempty(st_d))
     warning("sysdisc: no discrete states");
   elseif(isempty(y_d))
     warning("sysdisc: no discrete outputs");
   endif
 
+  [aa,bb,cc,dd] = sys2ss(sys);
   if(!isempty(st_d) )
-    Add = sys.a( st_d , st_d);
-    stname = sys.stname(st_d , :);
-    Bdd = sys.b( st_d , :);
+    Add = aa( st_d , st_d);
+    stname = sysgetsignals(sys,"st",st_d);
+    Bdd = bb( st_d , :);
     if(!isempty(st_c))
-      Adc = sys.a( st_d , st_c);
+      Adc = aa( st_d , st_c);
     endif
     if(!isempty(y_d))
-      Cdd = sys.c(y_d , st_d);
+      Cdd = cc(y_d , st_d);
     endif
   else
     stname = [];
   endif
   if(!isempty(y_d))
-    Ddd = sys.d(y_d , :);
-    outname = sys.outname(y_d , :);
+    Ddd = dd(y_d , :);
+    outname = sysgetsignals(sys,"out",y_d);
     if(!isempty(st_c))
-      Cdc = sys.c(y_d , st_c);
+      Cdc = cc(y_d , st_c);
     endif
   else
     outname=[];
   endif
-  inname = sys.inname;
+  inname = sysgetsignals(sys,"in");
   outlist = 1:rows(outname);
 
   if(!isempty(outname))
-    dsys = ss2sys(Add,Bdd,Cdd,Ddd,sys.tsam,0,sys.nz,stname, ...
-	inname,outname,outlist);
+    tsam = sysgettsam(sys);
+    [nc,nz] = sysdimensions(sys);
+    dsys = ss2sys(Add,Bdd,Cdd,Ddd,tsam,0,nz,stname,inname,outname,outlist);
   else
     dsys=[];
   endif
   implicit_str_to_num_ok = save_val;	# restore value
   empty_list_elements_ok = save_empty;
 
 endfunction
diff --git a/scripts/control/sysdup.m b/scripts/control/sysdup.m
--- a/scripts/control/sysdup.m
+++ b/scripts/control/sysdup.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1996 A. Scottedward Hodel 
+# Copyright (C) 1996,1998 A. Scottedward Hodel 
 #
 # This file is part of Octave. 
 #
 # Octave is free software; you can redistribute it and/or modify it 
 # under the terms of the GNU General Public License as published by the 
 # Free Software Foundation; either version 2, or (at your option) any 
 # later version. 
 # 
@@ -38,99 +38,76 @@ function retsys = sysdup(Asys,output_lis
 #                      |       Asys       |
 #                      |                  |
 #     u2 ------------->|                  |----->y2 
 #     (input_list)     |                  |      (output_list)
 #                      --------------------     
 
 # A. S. Hodel August 1995
 # modified by John Ingram July 1996
-# $Revision: 1.2 $
+# $Revision: 2.0.0.0 $
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
   if( nargin != 3)
     usage("retsys = sysdup(Asys,output_list,input_list)");
   endif
 
   if( !is_struct(Asys))
     error("Asys must be a system data structure (see ss2sys, tf2sys, or zp2sys)")
   endif
 
-  if (Asys.sys(4) != 1)
-    Asys = sysupdate(Asys,'ss');
-  endif
-
-  mm = rows(Asys.inname);
-  pp = rows(Asys.outname);
+  Asys = sysupdate(Asys,"ss");
+  [nn,nz,mm,pp] = sysdimensions(Asys);
+  [aa,bb,cc,dd] = sys2ss(Asys);
 
   # first duplicate inputs
   if(is_vector(input_list))
     for ii=1:length(input_list);
-      Asys.b(:,mm+ii) = Asys.b(:,input_list(ii));
-      Asys.d(:,mm+ii) = Asys.d(:,input_list(ii));
+      bb(:,mm+ii) = bb(:,input_list(ii));
+      dd(:,mm+ii) = dd(:,input_list(ii));
     end
   elseif(!isempty(input_list))
     error("input_list must be a vector or empty");
   endif
 
 
   # now duplicate outputs
   osize = min(size(output_list));
   if(osize == 1)
     for ii=1:length(output_list);
-      Asys.c(pp+ii,:) = Asys.c(output_list(ii),:);
-      Asys.d(pp+ii,:) = Asys.d(output_list(ii),:);
+      cc(pp+ii,:) = cc(output_list(ii),:);
+      dd(pp+ii,:) = dd(output_list(ii),:);
     end
   elseif(osize != 0)
     error("output_list must be a vector or empty");
   endif
   
-  yd = Asys.yd(output_list);
-  Asys.yd = [Asys.yd yd];
-
-  # give default names to the added inputs
-  for ii=(mm+1):(mm+length(input_list))
-    orig_name = Asys.inname(input_list(ii-mm),:);
-
-    #disp("sysdup: orig_name=")
-    #orig_name
-    #disp("/sysdup")
+  [stnam,innam,outnam,yd] = sysgetsignals(Asys);
+  tsam = sysgettsam(Asys);
 
-    strval = [dezero(orig_name),"(dup)"];
-     
-    #disp("sysdup: strval=")
-    #strval
-    #disp("/sysdup")
+  # pack system and then rename signals
+  retsys = ss2sys(aa,bb,cc,dd,tsam,nn,nz);
+  retsys = syssetsignals(retsys,"in",innam,1:mm);
+  retsys = syssetsignals(retsys,"out",outnam,1:pp);
+  retsys = syssetsignals(retsys,"yd",yd,1:pp);
 
-    Asys.inname(ii,1:length(strval)) = [strval];
-     
-    #disp("sysdup: resulting Asys.inname:")
-    #Asys.inname
-    #disp("/sysdup");
-
+  # update added input names
+  for ii=(mm+1):(mm+length(input_list))
+    onum = input_list(ii-mm);
+    strval = sprintf("%s(dup)",sysgetsignals(retsys,"in",onum,1) );
+    retsys = syssetsignals(retsys,"in",strval,ii);
   endfor
 
+  # update added output names/discrete flags
   # give default names to the added outputs
   for jj=(pp+1):(pp+length(output_list))
-    if(isstr(Asys.outname))
-      orig_name =Asys.outname;
-    else
-      orig_name = Asys.outname(output_list(jj-pp),:);
-    endif
-    strval = [dezero(orig_name),"(dup)"];
-    Asys.outname(jj,1:length(strval)) = [strval];
-
+    onum = output_list(jj-pp);
+    strval = sprintf("%s(dup)",sysgetsignals(retsys,"out",onum,1) );
+    retsys = syssetsignals(retsys,"out",strval,jj);
+    dflg = sysgetsignals(retsys,"yd",onum);
+    retsys = syssetsignals(retsys,"yd",dflg,jj);
   endfor
 
-    
-
-  if(max(size(Asys.d)) > 1 )
-    Asys.sys = [2 0 0 1];	# change default form to state space
-				# tf and zp are no longer relevant
-  endif
-
-  retsys = Asys;
-
   implicit_str_to_num_ok = save_val;	# restore value
 
 endfunction
diff --git a/scripts/control/sysgetsignals.m b/scripts/control/sysgetsignals.m
--- a/scripts/control/sysgetsignals.m
+++ b/scripts/control/sysgetsignals.m
@@ -11,35 +11,97 @@
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
 # for more details.
 # 
 # You should have received a copy of the GNU General Public License 
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
-function [stname,inname,outname,yd] = sysgetsignals(sys)
-  # function [stname,inname,outname,yd] = sysgetsignals(sys)
+function [stname,inname,outname,yd] = sysgetsignals(sys,sigid,signum,strflg)
+  # [stname,inname,outname,yd] = sysgetsignals(sys)
+  # -or- siglist = sysgetsignals(sys,sigid)
+  # -or- signame = sysgetsignals(sys,sigid,signum{,strflg})
   # Get signal names from a system
   # inputs:
   #    sys: system data structure for the state space system
-  #
+  #    sigid: signal id: string, must be one of:
+  #      "in": input signals
+  #     "out": output signals
+  #      "st": state signals
+  #      "yd": value of yd
+  #    signum: index of signal  (e.g., out4 = sysgetsignals(sys,"out",4)
+  #            sets out4 to the name of the 4th output)
+  #    strflg: flag to return a string instead of a list;
+  #           strflg = 0: (default) return a list
+  #           strflg = 1: return a string; exits with an error if 
+  #                       length(signum) > 1
   # outputs:
-  #    stname, inname, outname: signal names (strings);  names of states,
+  #   if sigid is not specified:
+  #      stname, inname, outname: signal names (lists);  names of states,
   #          inputs, and outputs, respectively
-  #    yd: binary vector; yd(ii) is nonzero if output y is discrete.
+  #      yd: binary vector; yd(ii) is nonzero if output y is discrete.
+  #   if sigid is specified but signum is not specified:
+  #      stname: 
+  #          is the list of state names (sigid = "st")
+  #          is the list input names (sigid = "in")
+  #          is the list output names (sigid = "out")
+  #          is the logical vector indicate discrete outputs (sigid = "yd")
+  #   if all three input arguments are specified:
+  #          is the list of specified state, input, or output name(s) 
+  #          (sigid = "st", "in", or "out").  
+  #          is a logical flag indicating if output signum is continous
+  #               (sigval=0) or discrete (sigval = 1)
   # 
 
   # Adapted from ss2sys
 
-  if(nargin != 1 | nargout > 4)
-    usage("[stname,inname,outname,yd] = sysgetsignals(sys)")
+  if(nargin < 1 | nargin > 4 | nargout > 4)
+    usage("[stname{,inname,outname,yd}] = sysgetsignals(sys{,sigid,signum})")
+  elseif(nargin > 1 & nargout > 1)
+    usage("sig = sysgetsignals(sys,sigid{,signum,strflg})")
   elseif( ! is_struct(sys) )
     error("input argument must be a system data structure");
   endif
-  sys = sysupdate(sys,"ss");		#make sure ss is up to date
-  yd = sys.yd;
-  stname = sys.stname;
-  inname = sys.inname;
-  outname = sys.outname;
+  if(nargin < 4)  strflg = 0; endif
+  if(nargin == 1)
+    sys = sysupdate(sys,"ss");		#make sure ss is up to date
+    stname = sysgetsignals(sys,"st");
+    inname = sysgetsignals(sys,"in");
+    outname = sysgetsignals(sys,"out");
+    yd = sysgetsignals(sys,"yd");
+  elseif(!(isstr(sigid) & min(size(sigid)) == 1))
+    error(sprintf("sigid(%dx%d) must be a string)",rows(sigid),columns(sigid)));
+  else
+    if(strcmp("st",sigid))         stname = sys.stname;
+    elseif(strcmp("in",sigid))     stname = sys.inname;
+    elseif(strcmp("out",sigid))    stname = sys.outname;
+    elseif(strcmp("yd",sigid))     stname = vec(sys.yd)';
+    else
+      error(sprintf("sigid=%s must be \"st\", \"in\", \"out\", or \"yd\"", ...
+	sigid));
+    endif
+    if(nargin >= 3)
+      if(signum > length(stname))
+        error(sprintf("sysgetsignals(sys,\"%s\",%d):only %d entries.\n", ...
+	  sigid,signum, rows(stname)));
+      else
+        if(!is_scalar(strflg)) 
+          error("strflg must be a scalar");
+        endif
+        switch(strflg)
+        case(0),
+          stname = stname(signum);
+        case(1),
+          if(length(signum) > 1)
+            error("strflg=1, length(signum) = %d",length(signum));
+          endif
+          stname = nth(stname,signum);
+        otherwise,
+          error("Illegal value of strflg=%e",strflg);
+        endswitch
+        
+      endif
+    endif
+  endif
 
 endfunction
 
diff --git a/scripts/control/sysgettsam.m b/scripts/control/sysgettsam.m
--- a/scripts/control/sysgettsam.m
+++ b/scripts/control/sysgettsam.m
@@ -1,20 +1,13 @@
 function T = sysgettsam(sys)
 # T = sysgettsam(sys)
 # return the sampling time of the system
 
-# $Revision: 1.3 $
-# $Log: sysdimensions.m,v $
-# Revision 1.3  1997/03/10 21:35:13  scotte
-# added debugging code (commented out)
-#
-# Revision 1.2  1997/03/10 20:42:27  scotte
-# added warning message about nargout
-#
+# $Revision: 2.0.0.0 $
 
 if(!is_struct(sys))
   usage("T = sysgettsam(sys)");
 endif
 
 T = sys.tsam;
 
 endfunction
diff --git a/scripts/control/sysgettype.m b/scripts/control/sysgettype.m
--- a/scripts/control/sysgettype.m
+++ b/scripts/control/sysgettype.m
@@ -20,18 +20,16 @@ function systype = sysgettype(sys)
 # systype = sysgetype(sys)
 # return the initial system type of the system
 # inputs:
 #   sys: system data structure
 # outputs:
 #   systype: string indicating how the structure was initially 
 #            constructed:
 #      values: "ss", "zp", or "tf"
-#
-# $Log$
 
   if(!is_struct(sys))
     error("sysgettype: input sys is not a structure");
   endif
 
-  typestr = ["tf";"zp";"ss"];
-  systype = typestr(sys.sys(1) + 1, :);
+  typestr = list("tf","zp","ss");
+  systype = nth(typestr,sys.sys(1) + 1);
 endfunction
diff --git a/scripts/control/sysgroup.m b/scripts/control/sysgroup.m
--- a/scripts/control/sysgroup.m
+++ b/scripts/control/sysgroup.m
@@ -35,17 +35,17 @@ function sys = sysgroup(Asys,Bsys)
 # 
 # The function also rearranges the A,B,C matrices so that the 
 # continuous states come first and the discrete states come last.
 # If there are duplicate names, the second name has a unique suffix appended
 # on to the end of the name.
 
 # A. S. Hodel August 1995
 # modified by John Ingram July 1996
-# $Revision: 1.3 $
+# $Revision: 2.0.0.0 $
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
   save_emp = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
   if(nargin ~= 2)
@@ -66,51 +66,49 @@ function sys = sysgroup(Asys,Bsys)
 
   if(p1*m1*p2*m2 == 0)
     error("sysgroup: argument lacks inputs and/or outputs");
 
   elseif((Atsam + Btsam > 0) & (Atsam * Btsam == 0) )
     warning("sysgroup: creating combination of continuous and discrete systems")
 
   elseif(Atsam != Btsam)
-    error(["sysgroup: Asys.tsam=", ...
-       num2str(Atsam),", Bsys.tsam=",num2str(Btsam)]);
-
+    error("sysgroup: Asys.tsam=%e, Bsys.tsam =%e", Atsam, Btsam);
   endif
 
   A = [Aa,zeros(nA,nB); zeros(nB,nA),Ba];
   B = [Ab,zeros(nA,m2); zeros(nB,m1),Bb];
   C = [Ac,zeros(p1,nB); zeros(p2,nA),Bc];
   D = [Ad,zeros(p1,m2); zeros(p2,m1),Bd];
   tsam = max(Atsam,Btsam);
 
   # construct combined signal names; stnames must check for pure gain blocks
   if(isempty(Ast))
     stname = Bst;
   elseif(isempty(Bst))
     stname = Ast;
   else
-    stname  = str2mat(Ast, Bst);
+    stname  = append(Ast, Bst);
   endif
-  inname  = str2mat(Ain, Bin);
-  outname = str2mat(Aout,Bout);
+  inname  = append(Ain, Bin);
+  outname = append(Aout,Bout);
 
   # Sort states into continous first, then discrete
   dstates = ones(1,(nA+nB));
   if(An)
     dstates(1:(An)) = zeros(1,An);
   endif
   if(Bn)
     dstates((nA+1):(nA+Bn)) = zeros(1,Bn);
   endif
   [tmp,pv] = sort(dstates);
   A = A(pv,pv);
   B = B(pv,:);
   C = C(:,pv);
-  stname = stname(pv,:);
+  stname = stname(pv);
 
   # check for duplicate signal names
   inname = sysgroupn(inname,"input");
   stname = sysgroupn(stname,"state");
   outname = sysgroupn(outname,"output");
 
   # mark discrete outputs
   outlist = find([Ayd, Byd]);
diff --git a/scripts/control/sysgroupn.m b/scripts/control/sysgroupn.m
--- a/scripts/control/sysgroupn.m
+++ b/scripts/control/sysgroupn.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1996 A. Scottedward Hodel 
+# Copyright (C) 1996,1998 A. Scottedward Hodel 
 #
 # This file is part of Octave. 
 #
 # Octave is free software; you can redistribute it and/or modify it 
 # under the terms of the GNU General Public License as published by the 
 # Free Software Foundation; either version 2, or (at your option) any 
 # later version. 
 # 
@@ -14,44 +14,41 @@
 # 
 # You should have received a copy of the GNU General Public License 
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function names = sysgroupn(names,kind)
 # names = sysgroupn(names)
 # locate and mark duplicate names
+# inputs:
+#   names: list of signal names
+#   kind: kind of signal name (used for diagnostic message purposes only)
+# outputs:
+#   returns names with unique suffixes added; diagnostic warning
+#      message is printed to inform the user of the new signal name
 #
 #  used internally in sysgroup
 
-# $Revision: 1.1 $
-
-  #disp("sysgroupn: entry")
-  #names
-  #[lmatrws,lmatcls] = size(names)
-  #disp("/sysgroupn")
+# $Revision: 2.0.0.0 $
 
   # check for duplicate names
-  l = rows(names);
-  if(l > 1)
-    for ii = 1:(l-1);
-      #disp(["sysgroupn: ii=",num2str(ii)])
-      #names
-      #[lmatrws,lmatcls] = size(names)
-      #disp("/sysgroupn")
-      st1 = dezero(names(ii,:));
-      for jj = (ii+1):l
-	st2 = dezero(names(jj,:));
-        if(strcmp(st1,st2))
-          suffix = ["_",num2str(jj)];
-          warning(["sysgroup: Appending ",suffix," to duplicate ",kind,...
-		" name '",st2,"'."]);
-          strval = [st2,suffix];
-
-          #disp(["sysgroupn: length(strval)=",num2str(length(strval))]);
-	  #disp(["sysgroupn: length(st2)=",num2str(length(st2))]);
-
-	  names(jj,(1:length(strval))) = strval;
-        endif
-      endfor
-    endfor
-  endif
+  l = length(names);
+  ii = 1;
+  while(ii < l-1)
+    st1 = nth(names,ii);
+    jj = ii+1;
+    while ( jj < l)
+      st2 = nth(names,jj);
+      if(strcmp(st1,st2))
+        suffix = ["_",num2str(jj)];
+        warning("sysgroup: %s name(%d) = %s name(%d); appending suffix %s to %d", ...
+		kind,ii,kind,jj,suffix,jj);
+        strval = sprintf("%s%s",st2,suffix);
+        names(jj) = strval;
+        # restart the check (just to be sure there's no further duplications)
+        ii = 0; jj = l;
+      endif
+      jj = jj+1;
+    endwhile
+    ii = ii+1;
+  endwhile
 endfunction
diff --git a/scripts/control/sysmult.m b/scripts/control/sysmult.m
--- a/scripts/control/sysmult.m
+++ b/scripts/control/sysmult.m
@@ -31,17 +31,17 @@ function [sys] = sysmult(Asys,Bsys)
 #         ----------     ----------
 #
 # A warning occurs if there is direct feed-through
 # from an input of Bsys or a continuous state of Bsys through a discrete 
 # output of Bsys to a continuous state or output in Asys (system data structure form 
 # does not recognize discrete inputs)
 
 # Written by John Ingram July 1996
-# $Revision: 1.2 $
+# $Revision: 2.0.0.0 $
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
   if(nargin != 2)
     usage("sysmult:  [sys] = sysmult(Asys,Bsys)");
   endif
 
diff --git a/scripts/control/sysout.m b/scripts/control/sysout.m
--- a/scripts/control/sysout.m
+++ b/scripts/control/sysout.m
@@ -23,17 +23,17 @@ function retsys = sysout(sys,opt)
 # sys: system data structure
 # opt: []: primary system form (default)
 #      "ss": state space form
 #      "tf": transfer function form
 #      "zp": zero-pole form
 #      "all": all of the above
 
 # Written by A S Hodel: 1995-1996
-# $Revision: 1.2 $
+# $Revision: 2.0.0.0 $
 
 # save for restoring at end of routine
 save_val = implicit_str_to_num_ok;
 implicit_str_to_num_ok = 1;
 
 if( (nargin < 1) || (nargin > 2) )
   usage("sysout(sys[,opt])");
 endif
@@ -44,98 +44,93 @@ if(isempty(sys))
   return;
 endif
 
 if(! is_struct(sys))
   disp("sysout: input must be a system structure")
 endif
 
 # set up output type array
-farray = ["tf";"zp";"ss"];
-
 if( nargin == 1 )
-  opt = farray(sys.sys(1)+1,:);
+  opt = sysgettype(sys);
 else
   if( ! (strcmp(opt,"ss") + strcmp(opt,"tf") + ...
     strcmp(opt,"zp") + strcmp(opt,"all") ) )
     error("opt must be one of [], \"ss\", \"tf\", \"zp\", or \"all\"");
   endif
 endif
 
 # now check output for each form:
-if( !isempty(sys.inname) )
+[nn,nz,mm,pp] = sysdimensions(sys);
+if( mm > 0)
   disp("Input(s)")
-  outlist(sys.inname,"	")
+  disp(outlist(sysgetsignals(sys,"in"),"	"));
 else
   disp("Input(s): none");
 endif
-if ( ! isempty(sys.outname) )
+if (pp > 0)
   disp("Output(s):")
-  outlist(sys.outname,"	",sys.yd)
+  disp(outlist(sysgetsignals(sys,"out"), ...
+	"	",sysgetsignals(sys,"yd")) );
 else
   disp("Output(s): none");
 endif
-if(sys.tsam > 0)
-  disp(["Sampling interval: ",num2str(sys.tsam)]);
+if(sysgettsam(sys) > 0)
+  disp(["Sampling interval: ",num2str(sysgettsam(sys))]);
   str = "z";
 else
   str = "s";
 endif
 
 # transfer function form
 if( strcmp(opt,"tf") + strcmp(opt,"all") )
   sys = sysupdate(sys,"tf");		#make sure tf is up to date
   disp("transfer function form:")
-  tfout(sys.num,sys.den,str);
+  [num,den] = sys2tf(sys);
+  tfout(num,den,str);
 endif
 
 if( strcmp(opt,"zp") + strcmp(opt,"all") )
   sys = sysupdate(sys,"zp");		#make sure zp is up to date
   disp("zero-pole form:")
-  zpout(sys.zer, sys.pol,sys.k,str)
+  [zer,pol,kk] = sys2zp(sys);
+  zpout(zer, pol, kk,str)
 endif
 
 if( strcmp(opt,"ss") + strcmp(opt,"all") )
   sys = sysupdate(sys,"ss");
   disp("state-space form:");
-  disp([num2str(sys.n)," continuous states, ",  ...
-    num2str(sys.nz)," discrete states"]);
-  if( !isempty(sys.stname) )
+  disp([num2str(nn)," continuous states, ", num2str(nz)," discrete states"]);
+  if( nn+nz > 0)
     disp("State(s):")
-    xi = (sys.n+1):(sys.n+sys.nz);
-    xd = zeros(1,rows(sys.a));
+    xi = (nn+1):(nn+nz);
+    xd = zeros(1,nn+nz);
     if(!isempty(xi))
       xd(xi) = 1;
     endif
-    outlist(sys.stname,"	",xd);
+    disp(outlist(sysgetsignals(sys,"st"),"	",xd));
   else
     disp("State(s): none");
   endif
 
   # display matrix values?
-  dmat = (max( [ size(sys.a) size(sys.b) size(sys.c) size(sys.d) ] ) <= 32);
+  dmat = (max( [ (nn+nz), mm, pp ] ) <= 32);
 
-  disp(sprintf("A matrix: %d x %d",rows(sys.a),columns(sys.a)))
-  if(dmat)
-    disp(sys.a)
-  endif
+  printf("A matrix: %d x %d\n",nn,nn);
+  [aa,bb,cc,dd] = sys2ss(sys);
+  if(dmat) 	disp(aa); 	endif
 
-  disp(sprintf("B matrix: %d x %d",rows(sys.b),columns(sys.b)))
-  if(dmat)
-    disp(sys.b)
-  endif
+  printf("B matrix: %d x %d\n",nn,mm);
+  if(dmat)     disp(bb);              endif
 
-  disp(sprintf("C matrix: %d x %d",rows(sys.c),columns(sys.c)))
-  if(dmat)
-    disp(sys.c)
-  endif
-  disp(sprintf("D matrix: %d x %d",rows(sys.d),columns(sys.d)))
-  if(dmat)
-    disp(sys.d)
-  endif
+  printf("C matrix: %d x %d\n",pp,nn);
+  if(dmat) disp(cc);		endif
+
+  printf("D matrix: %d x %d\n",pp,nn);
+  if(dmat)       disp(dd);         endif
 endif
 
 if(nargout >= 1)
   retsys = sys;
 endif 
   
 # restore global variable
 implicit_str_to_num_ok = save_val;
diff --git a/scripts/control/sysprune.m b/scripts/control/sysprune.m
--- a/scripts/control/sysprune.m
+++ b/scripts/control/sysprune.m
@@ -33,28 +33,29 @@ function sys = sysprune(sys,output_list,
 #    (input_list)      |       Asys       | (output_list)
 #                      |                  |
 #   u2 (deleted) |---->|                  |----| y2  (deleted)
 #                      |                  |    
 #                      --------------------    
 
 # A. S. Hodel August 1995
 # Updated by John Ingram 7-15-96
-# $Revision: 1.2 $
+# $Revision: 2.0.0.0 $
 
   if( nargin != 3  )
     usage("retsys = sysprune(sys,output_list,input_list)");
   endif
 
   # default: no action
+  [nn,nz,mm,pp] = sysdimensions(sys);
   if(isempty(output_list))
-    outputlist = 1:rows(sys.outname);
+    outputlist = 1:pp;
   endif
   if(isempty(input_list))
-    input_list = 1:rows(sys.inname);
+    input_list = 1:mm;
   endif
 
   # check dimensions
   if( !(
 	(is_vector(output_list) | isempty(output_list)) 
 	& (is_vector(input_list) | isempty(input_list)) 
   ))
     error("sysprune: output_list and input_list must be vectors");
@@ -62,32 +63,33 @@ function sys = sysprune(sys,output_list,
     lo = length(output_list);
     li = length(input_list);
     
     if(is_duplicate_entry(output_list) || is_duplicate_entry(input_list) )
       error("sysprune: duplicate entry in input and/or output list");
     endif
   endif
   
-  m = rows(sys.inname);
-  p = rows(sys.outname);
+  m = mm;
+  p = pp;
 
   if( !is_struct(sys))
     error("Asys must be a system data structure (see ss2sys, tf2sys, or zp2sys)")
   elseif(p < lo)
     error([num2str(lo)," output_list entries, system has only ", ...
 	num2str(p)," outputs"]);
   elseif(m < li)
     error([num2str(li)," input_list entries, system has only ", ...
 	num2str(m)," inputs"]);
   endif
 
-  sys = sysupdate(sys,"ss");
-
-  sys.b = sys.b(:,input_list);
-  sys.c = sys.c(output_list,:);
-  sys.d = sys.d(output_list,input_list);
+  [aa,bb,cc,dd,tsam,nn,nz,stnam,innam,outnam,yd] = sys2ss(sys);
+  bb = bb(:,input_list);
+  cc = cc(output_list,:);
+  dd = dd(output_list,input_list);
+  yd = yd(output_list); 
 
-  sys.inname = sys.inname(input_list,:);
-  sys.outname = sys.outname(output_list,:); 
-  sys.yd = sys.yd(output_list); 
+  # this part needs rewritten for the list structure of signal names
+  innam  = innam(input_list);
+  outnam = outnam(output_list); 
   
+  sys = ss2sys(aa,bb,cc,dd,tsam,nn,nz,stnam,innam,outnam,find(yd));
 endfunction
diff --git a/scripts/control/sysreorder.m b/scripts/control/sysreorder.m
--- a/scripts/control/sysreorder.m
+++ b/scripts/control/sysreorder.m
@@ -23,17 +23,17 @@ function pv = sysreorder(vlen,list)
 #         list: a subset of {1:vlen}
 # pv: a permutation vector to order elements of [1:vlen] in -list-
 #         to the end of a vector
 # used internally by sysconnect to permute vector elements to their
 # desired locations.  No user-serviceable parts inside; do not attempt
 # to use this at home!
 
 # A. S. Hodel, Aug 1995
-# $Revision: 1.1.1.1 $
+# $Revision: 2.0.0.0 $
   
   #disp('sysreorder: entry')
   
   pv = 1:vlen;
   # make it a row vector
   list = reshape(list,1,length(list));
   A = pv'*ones(size(list));
   B = ones(size(pv'))*list;
diff --git a/scripts/control/sysrepdemo.m b/scripts/control/sysrepdemo.m
--- a/scripts/control/sysrepdemo.m
+++ b/scripts/control/sysrepdemo.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1996 A. Scottedward Hodel 
+# Copyright (C) 1996,1998 A. Scottedward Hodel 
 #
 # This file is part of Octave. 
 #
 # Octave is free software; you can redistribute it and/or modify it 
 # under the terms of the GNU General Public License as published by the 
 # Free Software Foundation; either version 2, or (at your option) any 
 # later version. 
 # 
@@ -18,32 +18,17 @@
  
 function sysrepdemo()
 
 # Octave Controls toolbox demo: System representation
 
 # Written by A. S. Hodel June 1995
 # Revised Aug 1995 for system data structure format
 
-# $Revision: 1.1.1.1 $
-# $Log: sysrepdemo.m,v $
-# Revision 1.1.1.1  1998/05/19 20:24:09  jwe
-#
-# Revision 1.4  1997/02/13 15:38:26  hodel
-# fixed misprint in zp2sys demo (needed empty zeros vector in option 3)
-#
-# Revision 1.3  1997/02/13 15:22:32  hodel
-# fixed typo in menu option
-#
-# Revision 1.2  1997/02/12 11:53:22  hodel
-# *** empty log message ***
-#
-# Revision 1.1  1997/02/12 11:35:14  hodel
-# Initial revision
-#
+# $Revision: 2.0.0.0 $
 
   save_val = page_screen_output;
   page_screen_output = 1;
 
   disp('System representation demo:')
   num = [5 -1];
   denom = [1 -2 6];
   a = b = c = [];
@@ -54,17 +39,17 @@ function sysrepdemo()
   ch_view = ch_update+1;
   ch_details = ch_view+1;
   ch_quit = ch_details+1;
   while(syschoice != ch_quit)
    disp(" ")
     syschoice = menu('Octave System Representation Menu', ...
       "General overview of system representation (DO THIS FIRST)", ...
       "Initialize a system (ss2sys, tf2sys, zp2sys)", ...
-      "Extract data from a system(sys2ss, sys2tf, sys2zp)", ...
+      "Extract data from a system(sys2ss, sys2tf, sys2zp, etc.)", ...
       "Update internal representation (sysupdate)", ...
       "View the internal contents of a system (sysout)", ...
       "Details of internal representation", ...
       "Return to main menu");
     if(syschoice == 1)  # general overview
       disp("The Octave Control Systems Toolbox (OCST) was designed to")
       disp("provide a simple user interface to a powerful set of tools.")
       disp(' ')
@@ -209,17 +194,17 @@ function sysrepdemo()
             elseif(ssopt == 3)
               disp("A summing junction that computes e(t) = r(t) - y(t) may be");
               disp("constructed as follows:");
               disp("First, we set the matrix D:")
               cmd = "D = [1 -1];";
               run_cmd
               disp("ss2sys allows the initialization of signal and state names")
               disp("(see option 4), so we initialize these as follows:")
-              cmd = "inname =  [\"r(t)\";\"y(t)\"];";
+              cmd = "inname = list(\"r(t)\",\"y(t)\");";
               run_cmd;
               cmd = "outname = \"e(t)\";";
 	      run_cmd
               disp("Since the system is continous time and without states,")
               disp("the ss2sys inputs tsam, n, and nz are all zero:")
               cmd = "sys = ss2sys([],[],[],D,0,0,0,[],inname,outname);";
               run_cmd
               disp("The resulting system is:")
@@ -409,28 +394,63 @@ function sysrepdemo()
         endif
       endwhile
     elseif(syschoice == ch_extract)  # extract system information
       disp("Extract information from a system data structure in a selected format:")
       disp("The actions of operations ss2sys, tf2sys, and zp2sys are reversed by")
       disp("respective functions sys2ss, sys2tf, and sys2zp.  The latter two");
       disp("functions are applicable only to SISO systems.")
       formopt = 0;
-      while(formopt != 4)
+      while(formopt != 8)
         formopt = menu("Extract system information", ...
 		"in state space form       (sys2ss)", ...
 		"in transfer function form (sys2tf)", ...
 		"in zero pole form         (sys2zp)", ...
+		"signal names       (sysgetsignals,syssetsignals)", ...
+		"sampling time         (sysgettsam)", ...
+		"signal dimensions  (sysdimensions)", ...
+		"primary system type   (sysgettype)", ...
 		"Return to system representation menu");
         if(formopt == 1)
 	  help sys2ss
 	elseif(formopt == 2)
 	  help sys2tf
 	elseif(formopt == 3)
 	  help sys2zp
+        elseif(formopt == 4)
+          help sysgetsignals
+          cmd="sys=ss2sys(rand(4),rand(4,2),rand(3,4));";
+          run_cmd
+          printf("Example: All signals names can be extracted by\n");
+          cmd = "[Ast,Ain,Aout,Ayd] = sysgetsignals(sys)";
+          run_cmd
+          printf("Example: Input signal names can be extracted as\n");
+          cmd = "Ain = sysgetsignals(sys,\"in\")";
+          run_cmd
+          printf("Example: The name of output signal 2 can be extracted as\n");
+          cmd = "Aout = sysgetsignals(sys,\"out\",2)";
+          run_cmd
+          printf("\nNotice that Aout is returned as a list; the signal name\n");
+          printf("itself is obtained by specifying the input parameter strflg\n");
+          cmd = "Aout = sysgetsignals(sys,\"out\",2,1)";
+	  run_cmd
+          prompt
+          cmd = "help syssetsignals";
+          run_cmd
+          printf("Example: set input 2 name to \"motor voltage\"\n");
+          cmd = "sys = syssetsignals(sys,\"in\",\"motor voltage\",2); sysout(sys)";
+          run_cmd
+          
+          printf("Other syssetsignals demos are in the Block diagram demo program bddemo\n");
+        elseif(formopt == 5)
+          help sysgettsam
+        elseif(formopt == 6)
+          help sysdimensions
+        elseif(formopt == 7)
+          help sysgettype
 	endif
 	prompt
       endwhile
     elseif(syschoice== ch_update)
       disp("The OCST system data structure format will store a system in the same format")
       disp("as that with which it was initialized.  For example, consider the following:")
       cmd = "sys=zp2sys([1 2],[3 4 5],6)";
       run_cmd
diff --git a/scripts/control/sysscale.m b/scripts/control/sysscale.m
--- a/scripts/control/sysscale.m
+++ b/scripts/control/sysscale.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1996 A. Scottedward Hodel 
+# Copyright (C) 1996,1998 A. Scottedward Hodel 
 #
 # This file is part of Octave. 
 #
 # Octave is free software; you can redistribute it and/or modify it 
 # under the terms of the GNU General Public License as published by the 
 # Free Software Foundation; either version 2, or (at your option) any 
 # later version. 
 # 
@@ -17,115 +17,117 @@
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function sys = sysscale(sys,outscale,inscale,outname,inname)
 #
 # function sys = sysscale(sys,outscale,inscale[,outname,inname])
 # scale inputs/outputs of a system.
 #
 # inputs:
-#   sys: structured system
+#   sys: system data structure
 #   outscale, inscale: constant matrices of appropriate dimension
 # output: sys: resulting open loop system:
 #
 #           -----------    -------    -----------
 #     u --->| inscale |--->| sys |--->| outscale |---> y
 #           -----------    -------    -----------
 # 
 # If the input names and output names are not given and the scaling matrices
 # are not square, then default names will be given to the inputs and/or
 # outputs.
 #
 # A warning message is printed if outscale attempts to add continuous
 # system outputs to discrete system outputs; otherwise yd is set appropriately
 
 # A. S. Hodel August 1995
 # modified by John Ingram 7-15-96
-# $Revision: 1.1.1.1 $
+# $Revision: 2.0.0.0 $
 
   if( (nargin < 3) || (nargin > 5)  )
     usage("retsys = sysscale(Asys,output_list,input_list{,inname,outname})");
   elseif (!is_struct(sys))
     error("sys must be a structured system");
   endif
+
+  [nn,nz,mm,pp] = sysdimensions(sys);
  
   # check for omitted scales
-  if(isempty(outscale))
-    outscale = eye(rows(sys.outname)); 
-  endif 
-  if(isempty(inscale))
-    inscale = eye(rows(sys.inname));
-  endif 
+  if(isempty(outscale))    outscale = eye(pp);     endif 
+  if(isempty(inscale))     inscale = eye(mm);      endif 
 
   # check dimensions of scaling matrices
-  if((columns(sys.b)!=rows(inscale)) & (columns(sys.d)!=rows(inscale)))
-    error('inscale is not compatible with the system inputs');
-  elseif( (columns(outscale)!=rows(sys.c)) & ...
-	(columns(outscale)!=rows(sys.d)))
-    error("outscale is not compatible with the system outputs");
+  if(mm!=rows(inscale))
+    error("inscale(%dx%d) should have %d rows(# system inputs)", ...
+      rows(inscale),columns(inscale),mm);
+  elseif( pp != columns(outscale) )
+    error("outscale(%dx%d) should have %d columns(# system outputs)", ...
+      rows(outscale), columns(outscale),pp);
   endif
-  
-  outc = find(sys.yd==0);
-  outd = find(sys.yd==1);
 
-  #disp("sysscale: outc,outd=")
-  #disp(outc)
-  #disp(outd)
-  #disp("sysscale")
+  sysyd = sysgetsignals(sys,"yd");
+  outc = find(sysyd==0);
+  outd = find(sysyd==1);
 
   if(length(outc) & length(outd))
     for ii = 1:rows(outscale)
       nci = norm(outscale(ii,outc));
       ndi = norm(outscale(ii,outd));
 
-      #disp(["sysscale: ii=",num2str(ii),", nci, ndi="])
-      #disp(nci)
-      #disp(ndi)
-      #disp("syscale")
-
       if( nci & ndi)
-        warning(["sysscale: outscale(",num2str(ii), ...
-	  ",:) sums continuous and discrete outputs; setting output to cont"])
-        yd(ii) = 0;
+        warning("sysscale: outscale(%d,:) sums continuous and discrete outputs; setting output to cont",ii)
+        sysyd(ii) = 0;
       else
-        yd(ii) = (ndi != 0);
+        sysyd(ii) = (ndi != 0);
       endif
-  
-      #disp(["sysscale: yd(,",num2str(ii),"=",num2str(yd(ii)),": press a key"]);
-      #kbhit
     endfor
   else
-    yd = ones(1,rows(outscale))*( length(outd) > 0);
+    sysyd = ones(1,rows(outscale))*( length(outd) > 0);
   endif
-  sys.yd = yd;
 
-  sys.b = (sys.b)*inscale;
-  sys.d = (sys.d)*inscale;
-  sys.c = outscale*(sys.c);
-  sys.d = outscale*(sys.d);
+  # check for SISO system type
+  if strcmp(sysgettype(sys),"tf")
+    [num,den,tsam,innam,outnam] = sys2tf(sys);
+    num = num*inscale*outscale;
+    sys = tf2sys(num,den,tsam,innam,outnam,find(sysyd));
+    return
+  elseif strcmp(sysgettype(sys),"zp")
+    [zer,pol,kk,tsam,innam,outnam] = sys2zp(sys);
+    kk = kk*inscale*outscale;
+    sys = zp2sys(zer,pol,k,tsam,innam,outnam,find(sysyd));
+    return
+  endif
+
+  # it's a state space system...
+
+  [sysa,sysb,sysc,sysd,systsam, ...
+    sysn,sysnz,sysstname,sysinname,sysoutname,oldyd] = sys2ss(sys);
+
+  sysb = sysb*inscale;
+  sysc = outscale*sysc;
+  sysd = outscale*sysd*inscale;
 
   if( !is_square(outscale) )
     # strip extra output names (if any)
-    sys.outname = sys.outname(1:min(rows(outscale),columns(outscale)),:);
+    sysoutname = sysoutname(1:min(rows(outscale),columns(outscale)));
     if( nargin < 4)
       warning("sysscale: outscale not square, outname not specified");
       warning("sysscale:  using default output names");
-      outname = sysdefioname(rows(sys.c),"y");
+      outname = sysdefioname(rows(sysc),"y");
     endif
   else
-    outname = sys.outname;
+    outname = sysoutname;
   endif
   if( !is_square(inscale) )
     # strip extra output names (if any)
-    sys.inname = sys.inname(1:min(rows(inscale),columns(inscale)),:);
+    sysinname = sysinname(1:min(rows(inscale),columns(inscale)));
     if(nargin < 5)
       warning("sysscale: inscale not square, inname not specified");
       warning("sysscale:  using default input names");
-      inname = sysdefioname(columns(sys.b),"u");
+      inname = sysdefioname(columns(sysb),"u");
     endif
   else
-    inname = sys.inname;
+    inname = sysgetsignals(sys,"in");
   endif
 
-  sys = syschnames(sys,"out",1:rows(outname),outname);
-  sys = syschnames(sys,"in",1:rows(inname),inname);
+  sys = ss2sys(sysa,sysb,sysc,sysd,systsam,nn,nz,sysstname, ...
+	inname,outname,find(sysyd==1));
 
 endfunction
diff --git a/scripts/control/syssub.m b/scripts/control/syssub.m
--- a/scripts/control/syssub.m
+++ b/scripts/control/syssub.m
@@ -31,74 +31,64 @@ function sys = syssub(Gsys,Hsys)
 #             ----|  Gsys  |---
 #        u   |    ----------  +|         
 #        -----                (_)----> y
 #            |     ________   -|
 #             ----|  Hsys  |---
 #                  --------
 
 # Written by John Ingram July 1996
-# $Revision: 1.1.1.1 $
+# $Revision: 2.0.0.0 $
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
   if(nargin != 2)
     usage("syssub:  [sys] = syssub(Gsys,Hsys)");
   endif
 
   # check inputs
   if(!is_struct(Gsys) | !is_struct(Hsys))
     error("Both Gsys and Hsys must be a system data structure");
   endif
 
   # check for compatibility
-  if(rows(Gsys.inname) != rows(Hsys.inname))
-    error("Gsys and Hsys must have the same number of inputs");
-  elseif(rows(Gsys.outname) != rows(Hsys.outname))
-    error("Gsys and Hsys must have the same number of outputs");
+  [n,nz,mg,pg] = sysdimensions(Gsys);
+  [n,nz,mh,ph] = sysdimensions(Hsys);
+  if(mg != mh)
+    error(sprintf("Gsys inputs(%d) != Hsys inputs (%d)",mg,mh));
+  elseif(pg != ph)
+    error(sprintf("Gsys outputs(%d) != Hsys outputs (%d)",pg,ph));
   endif
 
+  [Gst, Gin, Gout, Gyd] = sysgetsignals(Gsys);
+  [Hst, Hin, Hout, Hyd] = sysgetsignals(Hsys);
+
   # check for digital to continuous addition
-  if (Gsys.yd != Hsys.yd)
+  if (Gyd != Hyd)
     error("can not add a discrete output to a continuous output");
   endif
 
-  if( (Gsys.sys(1) == 0) | (Hsys.sys(1) == 0) )
+  if( strcmp(sysgettype(Gsys),"tf") | strcmp(sysgettype(Hsys),"tf") )
     # see if adding  transfer functions with identical denominators
-    Gsys = sysupdate(Gsys,"tf");
-    Hsys = sysupdate(Hsys,"tf");
-    if(Hsys.den == Gsys.den)
-      sys = Gsys;
-      sys.sys(1) = 0;
-      sys.num = sys.num - Hsys.num;
+    [Gnum,Gden,GT,Gin,Gout] = sys2tf(Gsys);
+    [Hnum,Hden,HT,Hin,Hout] = sys2tf(Hsys);
+    if( (Hden == Gden) & (HT == GT) )
+      sys = tf2sys(Gnum-Hnum,Gden,GT,Gin,Gout);
       return
     endif
+    # if not, we go on and do the usual thing...
   endif
 
   # make sure in ss form
   Gsys = sysupdate(Gsys,"ss");
   Hsys = sysupdate(Hsys,"ss");
 
-  #disp("syssub: Gsys=")
-  #sysout(Gsys,"ss");
-  #disp("syssub: Hsys=")
-  #sysout(Hsys,"ss")
-
   sys = sysgroup(Gsys,Hsys);
 
-  eyin = eye(columns(Gsys.b));
-  eyout = eye(rows(Gsys.c));
+  eyin = eye(mg); eyout = eye(pg);
 
-  inname = sys.inname(1:rows(Gsys.inname) , :);
-  outname = sys.outname(1:rows(Gsys.outname) , :);
-
-  #disp("syssub: before sysscale: sys.yd=")
-  #disp(sys.yd)
-  #disp("syssub:")
+  inname = Gin;
+  outname = Gout;
 
   sys = sysscale(sys,[eyout -eyout],[eyin;eyin],outname,inname);
 
-  #disp("syssub: sys.yd=")
-  #disp(sys.yd)
-  #disp("syssub: exiting")
-
 endfunction
diff --git a/scripts/control/sysupdate.m b/scripts/control/sysupdate.m
--- a/scripts/control/sysupdate.m
+++ b/scripts/control/sysupdate.m
@@ -29,41 +29,41 @@ function sys = sysupdate(sys,opt)
 #     if requested data in sys is already up to date then retsys=sys.
 #
 # conversion to tf or zp exits with an error if the system is
 # mixed continuous/digital
 #
 # see also: tf2sys, ss2sys, zp2sys, sysout, sys2ss, sys2tf, sys2zp
 
 # Written by John Ingram  7-9-96
-# $Revision: 1.1.1.1 $
+# $Revision: 2.0.0.0 $
 
   # check for correct number of inputs 
   if (nargin != 2)
     usage("newsys = sysupdate(sys,opt)");
   elseif(! is_struct(sys) )
    error("1st argument must be system data structure")
   elseif(! (strcmp(opt,"tf") + strcmp(opt,"zp") + ...
 	strcmp(opt,"ss") + strcmp(opt,"all")) )
     error("2nd argument must be \"tf\", \"zp\", \"ss\", or \"all\"");
   endif
 
   # check to make sure not trying to make a SISO system out of a MIMO sys
   if ( (strcmp(opt,"tf") + strcmp(opt,"zp") + strcmp(opt,"all")) ...
-	& (sys.sys(1) == 2) &  (! is_siso(sys) ) )
+	& strcmp(sysgettype(sys),"ss") &  (! is_siso(sys) ) )
     error("MIMO -> SISO update requested");
   endif
 
   # update transfer function if desired
   if ( (strcmp(opt, "tf") + strcmp(opt,"all"))&&  (!sys.sys(2)))
     # check to make sure the system is not discrete and continuous
     is_digital(sys);
 
     # if original system zero-pole
-    if (sys.sys(1) == 1)
+    if strcmp(sysgettype(sys),"zp")
       [sys.num,sys.den] = zp2tf(sys.zer,sys.pol,sys.k);
       sys.sys(2) = 1;
     # if original system is state-space
     elseif(sys.sys(1) == 2)
       [sys.num,sys.den] = ss2tf(sys.a,sys.b,sys.c,sys.d);
       sys.sys(2) = 1; 
     endif
   endif
diff --git a/scripts/control/tf2ss.m b/scripts/control/tf2ss.m
--- a/scripts/control/tf2ss.m
+++ b/scripts/control/tf2ss.m
@@ -34,18 +34,17 @@ function [a,b,c,d] = tf2ss(num,den)
   # may contain as many rows as there are outputs of the system 'y'.
   # The state space system matrices obtained from this function will be
   # in controllable canonical form as described in "Modern Control Theory",
   # [Brogan, 1991].
 
 
   # Written by R. Bruce Tenison (June 22, 1994) btenison@eng.auburn.edu
   # mod A S Hodel July, Aug  1995
-  # $Revision: 1.1.1.1 $
-  # $Log$ 
+  # $Revision: 2.0.0.0 $
 
   if(nargin != 2)        error("tf2ss: wrong number of input arguments")
   elseif(isempty(num))   error("tf2ss: empty numerator");
   elseif(isempty(den))   error("tf2ss: empy denominator");
   elseif(!is_vector(num)) 
     error(sprintf("num(%dx%d) must be a vector",rows(num),columns(num)));
   elseif(!is_vector(den)) 
     error(sprintf("den(%dx%d) must be a vector",rows(den),columns(den)));
diff --git a/scripts/control/tf2sys.m b/scripts/control/tf2sys.m
--- a/scripts/control/tf2sys.m
+++ b/scripts/control/tf2sys.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1996 A. Scottedward Hodel 
+# Copyright (C) 1996,1998 A. Scottedward Hodel 
 #
 # This file is part of Octave. 
 #
 # Octave is free software; you can redistribute it and/or modify it 
 # under the terms of the GNU General Public License as published by the 
 # Free Software Foundation; either version 2, or (at your option) any 
 # later version. 
 # 
@@ -24,28 +24,17 @@ function outsys = tf2sys(num,den,tsam,in
   #   num, den: coefficients of numerator/denominator polynomials
   #   tsam: sampling interval. default: 0 (continuous time)
   #   inname, outname: input/output signal names (string variables)
   # outputs: sys = system data structure
    
   #  Written by R. Bruce Tenison  July 29, 1994
   #  Name changed to TF2SYS July 1995
   #  updated for new system data structure format July 1996
-  # $Revision: 1.4 $
-  # $Log: tf2sys.m,v $
-  # Revision 1.4  1998/08/24 15:50:30  hodelas
-  # updated documentation
-  #
-  # Revision 1.2  1998/07/01 16:23:39  hodelas
-  # Updated c2d, d2c to perform bilinear transforms.
-  # Updated several files per bug updates from users.
-  #
-  # Revision 1.2  1997/02/12 22:45:57  hodel
-  # added debugging code (commented out)
-  #
+  # $Revision: 2.0.0.0 $
 
   save_val = implicit_str_to_num_ok;
   implicit_str_to_num_ok = 1;
 
   #  Test for the correct number of input arguments
   if ((nargin < 2) || (nargin > 5))
     usage('outsys=tf2sys(num,den[,tsam,inname,outname])');
     return
@@ -59,26 +48,22 @@ function outsys = tf2sys(num,den,tsam,in
       ') must be vectors'])
   endif
   
   # strip leading zero coefficients
   num = tf2sysl(num);
   den = tf2sysl(den);
 
   if (length(num) >  length(den))
-    error([ 'number of poles (', num2str(length(den)-1), ...
-	') < number of zeros (', num2str(length(num)-1),')']);
+    error("# of poles (%d) < # of zeros (%d)",length(den)-1, length(num)-1);
   endif
 
   # check sampling interval (if any)
-  if(nargin <= 2)
-    tsam = 0;		# default
-  elseif (isempty(tsam))
-    tsam = 0;
-  endif
+  if(nargin <= 2)           tsam = 0;		# default
+  elseif (isempty(tsam))    tsam = 0;           endif
   if ( (! (is_scalar(tsam) && (imag(tsam) == 0) )) || (tsam < 0) )
     error('tsam must be a positive real scalar')
   endif
 
   outsys.num = num;
   outsys.den = den;
 
   #  Set the system vector:  active = 0(tf), updated = [1 0 0];
@@ -90,37 +75,45 @@ function outsys = tf2sys(num,den,tsam,in
   outsys.nz = 0;
   outsys.yd = 0;	# assume discrete-time
   # check discrete time
   if(tsam > 0)
     [outsys.n,outsys.nz] = swap(outsys.n, outsys.nz);
     outsys.yd = 1;
   endif
 
-  outsys.inname = sysdefioname(1,"u");
+  outsys.inname  = sysdefioname(1,"u");
   outsys.outname = sysdefioname(1,"y");
-  outsys.stname = sysdefstname(outsys.n,outsys.nz);
+  outsys.stname  = sysdefstname(outsys.n,outsys.nz);
 
   #  Set name of input
   if (nargin > 3)
-    if (rows(inname) > 1)
-      warning(["tf2sys: ",num2str(rows(inname))," input names given, 1st used"]);
-      inname = inname(1,:);
+    # make sure its a list of a single string
+    if(!isempty(inname))
+      if(!is_list(inname))  inname = list(inname);  endif
+      if( !is_signal_list(inname) )
+        error("inname must be a string or list of strings");
+      endif
+      if(length(inname) > 1)
+        warning("tf2sys: %d input names provided; first used",length(inname));
+        inname = inname(1);
+      endif
+      outsys = syssetsignals(outsys,"in",inname);
     endif
-    outsys.inname(1,1:length(inname)) = inname;
   endif
 
   #  Set name of output
   if (nargin > 4)
-    if (rows(outname) > 1)
-      warning(["tf2sys: ",num2str(rows(outname)), ...
-	" output names given, 1st used"]);
-      outname = outname(1,:);  
+    if(!isempty(outname))
+      if(!is_list(outname))  outname = list(outname);  endif
+      if(!is_signal_list(outname))
+        error("outname must be a string or a list of strings");
+      endif
+      if(length(outname) > 1)
+        warning("tf2sys: %d output names provided; first used",length(outname));
+        outname = outname(1);
+      endif
+      outsys = syssetsignals(outsys,"out",outname);
     endif
-    outsys.outname(1,1:length(outname)) = outname;  
   endif 
 
-  #disp("tf2sys: returning")
-  #outsys
-  #disp("/tf2sys")
-  
   implicit_str_to_num_ok = save_val;
 endfunction
diff --git a/scripts/control/tf2sysl.m b/scripts/control/tf2sysl.m
--- a/scripts/control/tf2sysl.m
+++ b/scripts/control/tf2sysl.m
@@ -17,17 +17,17 @@
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function vec = tf2sysl(vec)
 # vec = tf2sysl(vec)
 #
 # used internally in tf2sys
 # strip leading zero coefficients to get the true polynomial length
 
-# $Revision: 1.1 $
+# $Revision: 2.0.0.0 $
 
 while( (length(vec) > 1) & (vec(1) == 0) )
   vec = vec(2:length(vec));
 endwhile
 if(vec(1) == 0)
   warning("tf2sys: polynomial has no nonzero coefficients!")
 endif
 
diff --git a/scripts/control/tf2zp.m b/scripts/control/tf2zp.m
--- a/scripts/control/tf2zp.m
+++ b/scripts/control/tf2zp.m
@@ -18,18 +18,17 @@
  
 function [zer,pol,k] = tf2zp(num,den)
 # Converts transfer functions to poles / zeros.
 #
 # [zer,pol,k] = tf2zp(num,den) returns the zeros and poles of the SISO system
 # defined by num/den.  K is a gain associated with the system zeros.
 
 # Written by A. S. Hodel, etc.
-# $Revision: 1.2 $
-# $Log: tf2zp.m,v $
+# $Revision: 2.0.0.0 $
 
   if(nargin == 2)
     if(length(den) > 1)          pol = roots(den);
     else                         pol=[];                   endif
     if(length(num) > 1)         zer = roots(num);
     else                        zer=[];                    endif
   else                    error("Incorrect number of input arguments");
   endif
diff --git a/scripts/control/tfout.m b/scripts/control/tfout.m
--- a/scripts/control/tfout.m
+++ b/scripts/control/tfout.m
@@ -23,17 +23,17 @@ function tfout(num,denom,x)
 # print formatted transfer function num(s)/d(s) 
 # to the screen
 # x defaults to the string "s"
 #
 #  SEE ALSO: polyval, polyvalm, poly, roots, conv, deconv, residue, 
 #	filter, polyderiv, polyinteg, polyout
 
 # Written by A. Scottedward Hodel (scotte@eng.auburn.edu) June 1995)
-# $Revision: 1.2 $
+# $Revision: 2.0.0.0 $
   
   save_val = implicit_str_to_num_ok;
   save_empty = empty_list_elements_ok;
   empty_list_elements_ok = implicit_str_to_num_ok = 1;
   
   if (nargin < 2 ) | (nargin > 3) | (nargout != 0 ) 
     usage("tfout(num,denom[,x])");
   endif
diff --git a/scripts/control/tzero.m b/scripts/control/tzero.m
--- a/scripts/control/tzero.m
+++ b/scripts/control/tzero.m
@@ -34,33 +34,17 @@ function [zer, gain] = tzero(A,B,C,D)
   #   zer: transmission zeros of the system
   #   gain: leading coefficient (pole-zero form) of SISO transfer function
   #         returns gain=0 if system is multivariable
   # References:
   # Hodel, "Computation of Zeros with Balancing," 1992 Lin. Alg. Appl.
   
   # R. Bruce Tenison July 4, 1994
   # A. S. Hodel Aug 1995: allow for MIMO and system data structures
-  # $Revision: 1.16 $ 
-  # $Log: tzero.m,v $
-  # Revision 1.16  1998-11-06 16:15:37  jwe
-  # *** empty log message ***
-  #
-  # Revision 1.7  1998/08/24 15:50:30  hodelas
-  # updated documentation
-  #
-  # Revision 1.4  1998/08/12 20:34:36  hodelas
-  # Updated to use system access calls instead of direct structure access
-  #
-  # Revision 1.3  1998/07/21 14:53:11  hodelas
-  # use isempty instead of size tests; use sys calls to reduce direct
-  # access to system structure elements
-  #
-  # Revision 1.2  1997/02/13 11:58:05  hodel
-  # tracked down error in zgfslv; added Log message
+  # $Revision: 1.17 $ 
 
   # get A,B,C,D and Asys variables, regardless of initial form
   if(nargin == 4)
     Asys = ss2sys(A,B,C,D);
   elseif( (nargin == 1) && (! is_struct(A)))
     usage("[zer,gain] = tzero(A,B,C,D) or zer = tzero(Asys)");
   elseif(nargin != 1)
     usage("[zer,gain] = tzero(A,B,C,D) or zer = tzero(Asys)");
diff --git a/scripts/control/tzero2.m b/scripts/control/tzero2.m
--- a/scripts/control/tzero2.m
+++ b/scripts/control/tzero2.m
@@ -22,18 +22,17 @@ function zr = tzero2 (a, b, c, d, bal)
 #
 # Compute the transmission zeros of a, b, c, d.
 #
 # bal = balancing option (see balance); default is "B".
 #
 # Needs to incorporate mvzero algorithm to isolate finite zeros.
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
-# $Revision: 1.1.1.1 $
-# $Log$
+# $Revision: 2.0.0.0 $
 
   if (nargin == 4)
     bal = "B";
   elseif (nargin != 5)
     error ("tzero: illegal number of arguments");
   endif
 
   [n, m, p] = abcddim (a, b, c, d);
diff --git a/scripts/control/ugain.m b/scripts/control/ugain.m
--- a/scripts/control/ugain.m
+++ b/scripts/control/ugain.m
@@ -23,27 +23,15 @@ function outsys = ugain(n)
   # complex systems from simple systems with buildssic.
   # Watch out if you are forming sampled systems since "ugain"
   # does not contain a sampling period.  
   #
   # See also: hinfdemo (MIMO H_infinty example, Boeing 707-321 aircraft model)
 
   # Written by Kai P. Mueller April, 1998
   # Updates
-  # $Revision: 1.1.1.1 $
-  # $Log: ugain.m,v $
-  # Revision 1.1.1.1  1998/05/19 20:24:10  jwe
-  #
-  # Revision 1.1  1998/05/05 17:04:45  scotte
-  # Initial revision
-  #
-# Revision 1.1  1998/05/04  15:15:37  mueller
-# Initial revision
-#
-  #
-# Initial revision
-#
+  # $Revision: 2.0.0.0 $
 
   if((nargin != 1) || (nargout > 1))
     usage("outsys = ugain(n)")
   endif
   outsys = ss2sys([],[],[],eye(n));
 endfunction
diff --git a/scripts/control/unpacksys.m b/scripts/control/unpacksys.m
--- a/scripts/control/unpacksys.m
+++ b/scripts/control/unpacksys.m
@@ -16,15 +16,15 @@
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function [a,b,c,d] = unpacksys(syst)
   # [a,b,c,d] = unpacksys(sys)
   # Obsolete.  Use sys2ss instead.
 
   # Written by David Clem August 19, 1994
-  # $Revision: 1.1.1.1 $
+  # $Revision: 2.0.0.0 $
 
   warning("unpacksys obsolete; calling sys2ss");
   [a,b,c,d] = sys2ss(syst);
 
 endfunction
 
diff --git a/scripts/control/wgt1o.m b/scripts/control/wgt1o.m
--- a/scripts/control/wgt1o.m
+++ b/scripts/control/wgt1o.m
@@ -25,30 +25,17 @@ function wsys = wgt1o(vl, vh, fc)
 # These function are part of thye augmented plant P (see hinfdemo
 # for an applicattion example).
 #
 # vl = Gain @ low frequencies
 # vh = Gain @ high frequencies
 # fc = Corner frequency (in Hz, *not* in rad/sec)
 
 # Written by Kai P. Mueller September 30, 1997
-# $Revision: 1.1.1.1 $
-# $Log: wgt1o.m,v $
-# Revision 1.1.1.1  1998/05/19 20:24:10  jwe
-#
-# Revision 1.1  1998/05/05 17:04:56  scotte
-# Initial revision
-#
-# Revision 1.2  1998/05/05  09:01:22  mueller
-# comments added
-#
-# Revision 1.1  1998/05/04  15:08:46  mueller
-# Initial revision
-#
-#
+# $Revision: 2.0.0.0 $
 
   if (nargin != 3)
     usage("wsys = wgt1o(vl, vh, fc)");
   endif
 
   if(nargout > 1)
     usage("wsys = wgt1o(vl, vh, fc)");
   endif
diff --git a/scripts/control/zgfmul.m b/scripts/control/zgfmul.m
--- a/scripts/control/zgfmul.m
+++ b/scripts/control/zgfmul.m
@@ -25,21 +25,17 @@ function y = zgfmul(a,b,c,d,x)
   #
   # References:
   # ZGEP: Hodel, "Computation of Zeros with Balancing," Linear algebra and
   #    its Applications, 1993
   # Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
   
   # A. S. Hodel July 24 1992
   # Conversion to Octave July 3, 1994
-  # $Revision: 1.1 $
-  # $Log: zgfmul.m,v $
-# Revision 1.1  1998/11/04  14:35:42  hodel
-# Initial revision
-#
+  # $Revision: 2.0.0.0 $
   
   [n,m] = size(b);
   [p,m1] = size(c);
   nm = n+m;
   y = zeros(nm+p,1);
 
   # construct F column by column
   for jj=1:n
diff --git a/scripts/control/zgfslv.m b/scripts/control/zgfslv.m
--- a/scripts/control/zgfslv.m
+++ b/scripts/control/zgfslv.m
@@ -17,18 +17,17 @@
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function x = zgfslv(n,m,p,b)
   # x = zgfslv(n,m,p,b)
   # solve system of equations for dense zgep problem
   
   # Written by A. Scotte Hodel
   # Converted to Octave by R Bruce Tenison, July 3, 1994
-  # $Revision: 1.2 $
-  # $Log: zgfslv.m,v $
+  # $Revision: 2.0.0.0 $
 
   nmp = n+m+p;
   gam1 = (2*n)+m+p;    gam2 = n+p;     gam3 = n+m;
 
   G1 = givens(sqrt(m),-sqrt(p))';
   G2 = givens(m+p,sqrt(n*(m+p)))';
 
   x = b;
diff --git a/scripts/control/zginit.m b/scripts/control/zginit.m
--- a/scripts/control/zginit.m
+++ b/scripts/control/zginit.m
@@ -24,33 +24,36 @@ function zz = zginit(a,b,c,d)
   # called by zgepbal
   # References:
   # ZGEP: Hodel, "Computation of Zeros with Balancing," Linear Algebra and
   #              its Applications, 1993
   # Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
   
   # A. S. Hodel July 24 1992
   # Conversion to Octave by R. Bruce Tenison, July 3, 1994
-  # $Revision: 1.1 $
-  # $Log: zginit.m,v $
+  # $Revision: 2.0.0.0 $
 
   [nn,mm] = size(b);
   [pp,mm] = size(d);
 
   nmp = nn+mm+pp;
 
   # set up log vector zz
   zz = zeros(nmp,1);
 
   # zz part 1:
   for i=1:nn
     # nonzero off diagonal entries of a
-    nidx = complement(i,1:nn);
-    a_row_i = a(i,nidx);                 a_col_i = a(nidx,i);
-    arnz = a_row_i(find(a_row_i != 0));  acnz = a_col_i(find(a_col_i != 0));
+    if(nn > 1)
+      nidx = complement(i,1:nn);
+      a_row_i = a(i,nidx);                 a_col_i = a(nidx,i);
+      arnz = a_row_i(find(a_row_i != 0));  acnz = a_col_i(find(a_col_i != 0));
+    else
+      arnz = acnz = [];
+    endif
 
     # row of b
     bidx = find(b(i,:) != 0);
     b_row_i = b(i,bidx);
 
     # column of c
     cidx = find(c(:,i) != 0);
     c_col_i = c(cidx,i);
diff --git a/scripts/control/zgpbal.m b/scripts/control/zgpbal.m
--- a/scripts/control/zgpbal.m
+++ b/scripts/control/zgpbal.m
@@ -33,29 +33,17 @@ function [retsys] = zgpbal(Asys)
   # zgpbal should be followed by zgpred
   # References:
   # ZGEP: Hodel, "Computation of Zeros with Balancing," 1992, Linear Algebra
   # and its Applications
   # Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
   
   # A. S. Hodel July 24 1992
   # Conversion to Octave by R. Bruce Tenison July 3, 1994
-  # $Revision: 1.1 $
-  # $Log: zgpbal.m,v $
-# Revision 1.1  1998/11/04  14:35:42  hodel
-# Initial revision
-#
-  # Revision 1.2  1998/08/24 15:50:31  hodelas
-  # updated documentation
-  #
-  # Revision 1.1.1.1  1998/05/19 20:24:10  jwe
-  #
-  # Revision 1.2  1997/02/13 11:54:59  hodel
-  # added debugging code (commented out).
-  #
+  # $Revision: 2.0.0.0 $
 
   if( (nargin != 1) | (!is_struct(Asys)))
     usage("retsys = zgpbal(Asys)");
   endif
 
   Asys = sysupdate(Asys,"ss");
   [a,b,c,d] = sys2ss(Asys);
 
diff --git a/scripts/control/zgreduce.m b/scripts/control/zgreduce.m
--- a/scripts/control/zgreduce.m
+++ b/scripts/control/zgreduce.m
@@ -18,17 +18,17 @@
  
 function retsys = zgreduce(Asys,meps)
 # function retsys = zgreduce(Asys,meps)
 # implementation of procedure REDUCE in (Emami-Naeini and Van Dooren, 
 # Automatica, # 1982).
 #
 # used internally in tzero; minimal argument checking performed
 
-#$Revision: 1.1.1.1 $
+#$Revision: 2.0.0.0 $
 # SYS_INTERNAL accesses members of system data structure
 
 is_digital(Asys);		# make sure it's pure digital/continuous
 
 exit_1 = 0;			# exit_1 = 1 or 2 on exit of loop
 
 if(Asys.n + Asys.nz == 0)
   exit_1 = 2;			# there are no finite zeros
diff --git a/scripts/control/zgrownorm.m b/scripts/control/zgrownorm.m
--- a/scripts/control/zgrownorm.m
+++ b/scripts/control/zgrownorm.m
@@ -17,17 +17,17 @@
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function [sig, tau] = zgrownorm(mat,meps)
 # function [nonz, zer] = zgrownorm(mat,meps)
 # used internally in tzero
 # returns nonz = number of rows of mat whose two norm exceeds meps
 #         zer = number of rows of mat whose two norm is less than meps
 
-# $Revision: 1.1 $
+# $Revision: 2.0.0.0 $
 
   rownorm = [];
   for ii=1:rows(mat)
     rownorm(ii) = norm(mat(ii,:));
   endfor
   sig = sum(rownorm > meps);
   tau = sum(rownorm <= meps);
 
diff --git a/scripts/control/zgscal.m b/scripts/control/zgscal.m
--- a/scripts/control/zgscal.m
+++ b/scripts/control/zgscal.m
@@ -23,17 +23,17 @@ function x = zgscal(a,b,c,d,z,n,m,p)
   # called by zgepbal
   #
   # References:
   # ZGEP: Hodel, "Computation of Zeros with Balancing," 1992, submitted to  LAA
   # Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
   
   # A. S. Hodel July 24 1992
   # Conversion to Octave R. Bruce Tenison July 3, 1994
-  # $Revision: 1.2 $
+  # $Revision: 2.0.0.0 $
 
   #**************************************************************************
   #initialize parameters:
   #  Givens rotations, diagonalized 2x2 block of F, gcg vector initialization
   #**************************************************************************
   nmp = n+m+p;
   
   #x_0 = x_{-1} = 0, r_0 = z
diff --git a/scripts/control/zgsgiv.m b/scripts/control/zgsgiv.m
--- a/scripts/control/zgsgiv.m
+++ b/scripts/control/zgsgiv.m
@@ -18,15 +18,15 @@
  
 function [a,b] = zgsgiv(c,s,a,b)
   # [a,b] = zgsgiv(c,s,a,b)
   # apply givens rotation c,s to row vectors a,b
   # No longer used in zero-balancing (zgpbal); kept for backward compatibility
   
   # A. S. Hodel July 29, 1992
   # Convertion to Octave by R. Bruce Tenison July 3, 1994
-  # $Revision: 1.1.1.1 $
+  # $Revision: 2.0.0.0 $
 
   t1 = c*a + s*b;
   t2 = -s*a + c*b;
   a = t1;
   b = t2;
 endfunction
diff --git a/scripts/control/zgshsr.m b/scripts/control/zgshsr.m
--- a/scripts/control/zgshsr.m
+++ b/scripts/control/zgshsr.m
@@ -19,17 +19,17 @@
 function x = zgshsr(y)
   # x = zgshsr(y)
   # apply householder vector based on e^(m) to 
   # (column vector) y.
   # Called by zgfslv
 
   # A. S. Hodel July 24, 1992
   # Conversion to Octave by R. Bruce Tenison July 3, 1994
-  # $Revision: 1.1.1.1 $
+  # $Revision: 2.0.0.0 $
 
   if(!is_vector(y))
     error(sprintf("y(%dx%d) must be a vector",rows(y),columns(y)));
   endif
   x = vec(y);
   m = length(x);
   if (m>1)
     beta = (1 + sqrt(m))*x(1) + sum(x(2:m));
diff --git a/scripts/control/zp2ss.m b/scripts/control/zp2ss.m
--- a/scripts/control/zp2ss.m
+++ b/scripts/control/zp2ss.m
@@ -12,37 +12,39 @@
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
 # for more details.
 # 
 # You should have received a copy of the GNU General Public License 
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function [a,b,c,d] = zp2ss(zer,pol,k)
+# [A,B,C,D] = zp2ss(zer,pol,k)
 # Conversion from zero / pole to state space.
+# Inputs: 
+#   zer,  pol: vectors of (possibly) complex poles and zeros of a transfer
+#              function.  Complex values must come in conjugate pairs
+#              (i.e., x+jy in zer means that x-jy is also in zer)
+#   k:  real scalar (leading coefficient)
+# Outputs:
+#  A, B, C, D:
 # The state space system
 #      .
 #      x = Ax + Bu
 #      y = Cx + Du
 #
 # is obtained from a vector of zeros and a vector of poles via the
 # function call [a,b,c,d] = zp2ss(zer,pol,k).  The vectors 'zer' and 
 # 'pol' may either be row or column vectors.  Each zero and pole that
 # has an imaginary part must have a conjugate in the list.
 # The number of poles must at least equal the number of zeros.
 # k is a gain that is associated with the zero vector.
 
 # Written by David Clem August 15, 1994
-# $Revision: 1.4 $
-# $Log: zp2ss.m,v $
-# Revision 1.4  1998/07/10 17:51:29  hodelas
-# Fixed bug in zp2ss system construction; overhauled zp2ssg2
-#
-#
-# calls: tf2sys, sysmult
+# $Revision: 2.0.0.0 $
 
   sav_val = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
   if(nargin != 3)
     error("Incorrect number of input arguments");
   endif
  
@@ -119,20 +121,22 @@ function [a,b,c,d] = zp2ss(zer,pol,k)
     otherwise
       error(["pcnt = ",num2str(pcnt)])
     endswitch
 
     # pack tf into system form and put in series with earlier realization
     zpsys1 = tf2sys(num,den,0,"u","yy");
 
     # change names to avoid warning messages from sysgroup
-    zpsys = syschnames(zpsys,"in",1,"u1");
+    zpsys  = syssetsignals(zpsys,"in","u1",1);
     zpsys1 = sysupdate(zpsys1,"ss");
-    zpsys = syschnames(zpsys,"st",(1:zpsys.n),sysdefioname(zpsys.n,"x"));
-    zpsys1 = syschnames(zpsys1,"st",(1:zpsys1.n),sysdefioname(zpsys1.n,"xx"));
+    nn     = sysdimensions(zpsys);        # working with continuous system
+    zpsys  = syssetsignals(zpsys,"st", sysdefioname(nn,"x"));
+    nn1    = sysdimensions(zpsys1);
+    zpsys1 = syssetsignals(zpsys1,"st",sysdefioname(nn1,"xx"));
 
     zpsys = sysmult(zpsys,zpsys1);
 
   endwhile 
 
   [a,b,c,d] = sys2ss(zpsys);
 
   empty_list_elements_ok = sav_val;
diff --git a/scripts/control/zp2ssg2.m b/scripts/control/zp2ssg2.m
--- a/scripts/control/zp2ssg2.m
+++ b/scripts/control/zp2ssg2.m
@@ -18,17 +18,17 @@
  
 function [poly,rvals] = zp2ssg2(rvals)
 # [poly,rvals] = zp2ssg2(rvals)
 #
 #  used internally in zp2ss
 # extract 2 values from rvals (if possible) and construct
 # a polynomial with those roots.
 
-# $Revision: 1.2 $
+# $Revision: 2.0.0.0 $
 # A. S. Hodel Aug 1996
 
 # locate imaginary roots (if any)
 cidx = find(imag(rvals));
 
 if(!isempty(cidx))
   # select first complex root, omit from cidx
   r1i = cidx(1);      r1 = rvals(r1i);     cidx = complement(r1i,cidx);
diff --git a/scripts/control/zp2sys.m b/scripts/control/zp2sys.m
--- a/scripts/control/zp2sys.m
+++ b/scripts/control/zp2sys.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1996 A. Scottedward Hodel 
+# Copyright (C) 1996,1998 A. Scottedward Hodel 
 #
 # This file is part of Octave. 
 #
 # Octave is free software; you can redistribute it and/or modify it 
 # under the terms of the GNU General Public License as published by the 
 # Free Software Foundation; either version 2, or (at your option) any 
 # later version. 
 # 
@@ -23,17 +23,17 @@ function  outsys = zp2sys (zer,pol,k,tsa
   #   zer: vector of system zeros
   #   pol: vector of system poles
   #   k: scalar leading coefficient
   #   tsam: sampling period. default: 0 (continuous system)
   #   inname, outname: input/output signal names (strings)
   # outputs: sys: system data structure
 
   #  Modified by John Ingram  July 20, 1996  
-  # $Revision: 1.2 $
+  # $Revision: 2.0.0.0 $
 
   save_val = implicit_str_to_num_ok;	# save for restoring later
   implicit_str_to_num_ok = 1;
 
   #  Test for the correct number of input arguments
   if ((nargin < 3) || (nargin > 6))
     usage("outsys = zp2sys(zer,pol,k[,tsam,inname,outname])");
   endif
@@ -90,27 +90,31 @@ function  outsys = zp2sys (zer,pol,k,tsa
   endif
 
   outsys.inname = sysdefioname(1,"u");
   outsys.outname = sysdefioname(1,"y");
   outsys.stname = sysdefstname(outsys.n,outsys.nz);
 
   #  Set name of input
   if (nargin > 4)
-    if (rows(inname) > 1)
-      warning("zp2sys: ",num2str(rows(inname))," input names given, 1st used");
-      inname = inname(1,:);
+    # make sure its a string
+    if(!isempty(inname))
+      if(!is_list(inname))  inname = list(inname); endif
+      if(!is_signal_list(inname))
+        error("inname must be a single signal name");
+      endif
+      outsys.inname = inname(1);
     endif
-    outsys.inname(1,1:length(inname)) = inname;
   endif
 
   #  Set name of output
   if (nargin > 5)
-    if (rows(outname) > 1)
-      warning("zp2sys: ",num2str(rows(outname)), ...
-	" output names given, 1st used");
-      outname = outname(1,:);  
+    if(!isempty(outname))
+      if(!is_list(outname))        outname = list(outname);    endif
+      if(!is_signal_list(outname))
+        error("outname must be a single signal name");
+      endif
+      outsys.outname = outname(1);
     endif
-    outsys.outname(1,1:length(outname)) = outname;  
   endif 
 
   implicit_str_to_num_ok = save_val;
 endfunction
diff --git a/scripts/control/zp2tf.m b/scripts/control/zp2tf.m
--- a/scripts/control/zp2tf.m
+++ b/scripts/control/zp2tf.m
@@ -27,17 +27,17 @@ function [num,den] = zp2tf(zer,pol,k)
 # Forms the transfer function num/den from
 # the vectors of poles and zeros.  K is a scalar gain associated with the
 # zeros.
 
 # Find out whether data was entered as a row or a column vector and
 # convert to a column vector if necessary
 # Written by A. S. Hodel with help from students Ingram, McGowan.
 # a.s.hodel@eng.auburn.edu
-# $Revision: 1.2 $
+# $Revision: 2.0.0.0 $
 #
 
   [rp,cp] = size(pol);
   [rz,cz] = size(zer);
 
   if(!(is_vector(zer) | isempty(zer)) )
     error(sprintf("zer(%dx%d) must be a vector",rz,cz));
   elseif(!(is_vector(pol) | isempty(pol)) )
diff --git a/scripts/control/zpout.m b/scripts/control/zpout.m
--- a/scripts/control/zpout.m
+++ b/scripts/control/zpout.m
@@ -23,17 +23,16 @@ function zpout(zer,pol,k,x)
 # print formatted zero-pole form
 # to the screen
 # x defaults to the string "s"
 #
 #  SEE ALSO: polyval, polyvalm, poly, roots, conv, deconv, residue, 
 #	filter, polyderiv, polyinteg, polyout
 
 # Written by A. Scottedward Hodel (scotte@eng.auburn.edu) June 1995)
-# $Log$
 
   save_val = implicit_str_to_num_ok;
   save_empty = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
   implicit_str_to_num_ok = 1;
 
   if (nargin < 3 ) | (nargin > 4) | (nargout != 0 )
