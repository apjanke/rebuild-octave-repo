# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1446754012 18000
#      Thu Nov 05 15:06:52 2015 -0500
# Node ID 19d6f94c21cbc98296ed5ae8d756569d9b3fff53
# Parent  4b00afb5e9c3aaf20bdde71ec16a708e273abdea
eliminate more uses of error_state

* graphics.cc, ls-mat5.cc, urlwrite.cc, xpow.cc, ov-class.cc:
Eliminate some uses of error_state.

diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -2146,26 +2146,21 @@ graphics_object::set (const octave_value
   if (nargin == 0)
     error ("graphics_object::set: Nothing to set");
   else if (nargin % 2 != 0)
     error ("set: invalid number of arguments");
   else
     {
       for (int i = 0; i < nargin; i += 2)
         {
-          caseless_str pname = args(i).string_value ();
-
-          if (! error_state)
-            {
-              octave_value val = args(i+1);
-
-              set_value_or_default (pname, val);
-            }
-          else
-            error ("set: expecting argument %d to be a property name", i);
+          caseless_str pname = args(i).string_value ("set: expecting argument %d to be a property name", i);
+
+          octave_value val = args(i+1);
+
+          set_value_or_default (pname, val);
         }
     }
 }
 
 /*
 ## test set with name, value pairs
 %!test
 %! hf = figure ("visible", "off");
@@ -11034,38 +11029,33 @@ undocumented.\n\
                     }
                 }
             }
 
           mono = (args.length () >= 3 ? args(2).bool_value () : false);
 
           if (! error_state)
             {
-              debug_file = (args.length () > 3 ? args(3).string_value () : "");
-
-              if (! error_state)
+              debug_file = (args.length () > 3 ? args(3).string_value ("drawnow: invalid DEBUG_FILE, expected a string value") : "");
+
+              graphics_handle h = gcf ();
+
+              if (h.ok ())
                 {
-                  graphics_handle h = gcf ();
-
-                  if (h.ok ())
-                    {
-                      graphics_object go = gh_manager::get_object (h);
-
-                      gh_manager::unlock ();
-
-                      go.get_toolkit ().print_figure (go, term, file,
-                                                      mono, debug_file);
-
-                      gh_manager::lock ();
-                    }
-                  else
-                    error ("drawnow: nothing to draw");
+                  graphics_object go = gh_manager::get_object (h);
+
+                  gh_manager::unlock ();
+
+                  go.get_toolkit ().print_figure (go, term, file,
+                                                  mono, debug_file);
+
+                  gh_manager::lock ();
                 }
               else
-                error ("drawnow: invalid DEBUG_FILE, expected a string value");
+                error ("drawnow: nothing to draw");
             }
           else
             error ("drawnow: invalid colormode MONO, expected a boolean value");
         }
       else
         print_usage ();
     }
 
@@ -11700,17 +11690,17 @@ In all cases, typing CTRL-C stops progra
           //        The only "good" implementation would require object
           //        listeners, similar to property listeners.
 
           time_t start = 0;
 
           if (timeout > 0)
             start = time (0);
 
-          while (! error_state)
+          while (true)
             {
               if (true)
                 {
                   gh_manager::auto_lock guard;
 
                   graphics_handle gh = gh_manager::lookup (h);
 
                   if (gh.ok ())
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -381,17 +381,17 @@ read_mat5_integer_data (std::istream& is
             goto data_read_error; \
           } \
   \
         octave_idx_type n = re.numel (); \
         tmp_pos = is.tellg (); \
         read_mat5_integer_data (is, re.fortran_vec (), n, swap, \
                                 static_cast<enum mat5_data_type> (type)); \
   \
-        if (! is || error_state) \
+        if (! is) \
           { \
             error ("load: reading matrix data for '%s'", retval.c_str ()); \
             goto data_read_error; \
           } \
   \
         is.seekg (tmp_pos + static_cast<std::streamoff>\
                   (READ_PAD (is_small_data_element, len))); \
   \
@@ -406,17 +406,17 @@ read_mat5_integer_data (std::istream& is
                        retval.c_str ()); \
                 goto data_read_error; \
               } \
   \
             n = im.numel (); \
             read_mat5_binary_data (is, im.fortran_vec (), n, swap, \
                                    static_cast<enum mat5_data_type> (type), flt_fmt); \
   \
-            if (! is || error_state) \
+            if (! is) \
               { \
                 error ("load: reading imaginary matrix data for '%s'", \
                        retval.c_str ()); \
                 goto data_read_error; \
               } \
   \
             ComplexNDArray ctmp (dims); \
   \
@@ -732,17 +732,17 @@ read_mat5_binary_element (std::istream& 
 
         for (octave_idx_type i = 0; i < n; i++)
           {
             octave_value tc2;
 
             std::string nm
               = read_mat5_binary_element (is, filename, swap, global, tc2);
 
-            if (! is || error_state)
+            if (! is)
               {
                 error ("load: reading cell data for '%s'", nm.c_str ());
                 goto data_read_error;
               }
 
             cell_array(i) = tc2;
           }
 
@@ -785,17 +785,17 @@ read_mat5_binary_element (std::istream& 
             goto data_read_error;
           }
 
         tmp_pos = is.tellg ();
 
         read_mat5_integer_data (is, ridx, nzmax, swap,
                                 static_cast<enum mat5_data_type> (type));
 
-        if (! is || error_state)
+        if (! is)
           {
             error ("load: reading sparse row data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         is.seekg (tmp_pos + static_cast<std::streamoff>
                   (READ_PAD (is_small_data_element, len)));
 
@@ -807,17 +807,17 @@ read_mat5_binary_element (std::istream& 
             goto data_read_error;
           }
 
         tmp_pos = is.tellg ();
 
         read_mat5_integer_data (is, cidx, nc + 1, swap,
                                 static_cast<enum mat5_data_type> (type));
 
-        if (! is || error_state)
+        if (! is)
           {
             error ("load: reading sparse column data for '%s'",
                    retval.c_str ());
             goto data_read_error;
           }
 
         is.seekg (tmp_pos + static_cast<std::streamoff>
                   (READ_PAD (is_small_data_element, len)));
@@ -838,17 +838,17 @@ read_mat5_binary_element (std::istream& 
             data = re.fortran_vec ();
           }
 
         tmp_pos = is.tellg ();
         read_mat5_binary_data (is, data, nnz, swap,
                                static_cast<enum mat5_data_type> (type),
                                flt_fmt);
 
-        if (! is || error_state)
+        if (! is)
           {
             error ("load: reading sparse matrix data for '%s'",
                    retval.c_str ());
             goto data_read_error;
           }
 
         is.seekg (tmp_pos + static_cast<std::streamoff>
                   (READ_PAD (is_small_data_element, len)));
@@ -864,17 +864,17 @@ read_mat5_binary_element (std::istream& 
                        retval.c_str ());
                 goto data_read_error;
               }
 
             read_mat5_binary_data (is, im.fortran_vec (), nnz, swap,
                                    static_cast<enum mat5_data_type> (type),
                                    flt_fmt);
 
-            if (! is || error_state)
+            if (! is)
               {
                 error ("load: reading imaginary sparse matrix data for '%s'",
                        retval.c_str ());
                 goto data_read_error;
               }
 
             for (octave_idx_type i = 0; i < nnz; i++)
               scm.xdata (i) = Complex (re (i), im (i));
@@ -887,17 +887,17 @@ read_mat5_binary_element (std::istream& 
       break;
 
     case MAT_FILE_FUNCTION_CLASS:
       {
         octave_value tc2;
         std::string nm
           = read_mat5_binary_element (is, filename, swap, global, tc2);
 
-        if (! is || error_state)
+        if (! is)
           goto data_read_error;
 
         // Octave can handle both "/" and "\" as a directory seperator
         // and so can ignore the separator field of m0. I think the
         // sentinel field is also save to ignore.
         octave_scalar_map m0 = tc2.scalar_map_value ();
         octave_scalar_map m1
           = m0.contents ("function_handle").scalar_map_value ();
@@ -1134,17 +1134,17 @@ read_mat5_binary_element (std::istream& 
           {
             for (octave_idx_type i = 0; i < n_fields; i++)
               {
                 if (field(i) == "MCOS")
                   {
                     octave_value fieldtc;
                     read_mat5_binary_element (is, filename, swap, global,
                                               fieldtc);
-                    if (! is || error_state)
+                    if (! is)
                       goto data_read_error;
 
                     elt[i](j) = fieldtc;
                   }
                 else
                   elt[i](j) = octave_value ();
               }
           }
@@ -1277,22 +1277,26 @@ read_mat5_binary_element (std::istream& 
 
                     if (! cls->reconstruct_parents ())
                       warning ("load: unable to reconstruct object inheritance");
 
                     tc = cls;
                     if (load_path::find_method (classname, "loadobj")
                         != std::string ())
                       {
-                        octave_value_list tmp = feval ("loadobj", tc, 1);
-
-                        if (! error_state)
-                          tc = tmp(0);
-                        else
-                          goto data_read_error;
+                        try
+                          {
+                            octave_value_list tmp = feval ("loadobj", tc, 1);
+
+                            tc = tmp(0);
+                          }
+                        catch (const octave_execution_exception&)
+                          {
+                            goto data_read_error;
+                          }
                       }
                   }
                 else
                   {
                     tc = m;
                     warning ("load: element has been converted to a structure");
                   }
               }
@@ -1368,17 +1372,17 @@ read_mat5_binary_element (std::istream& 
           }
 
         octave_idx_type n = re.numel ();
         tmp_pos = is.tellg ();
         read_mat5_binary_data (is, re.fortran_vec (), n, swap,
                                static_cast<enum mat5_data_type> (type),
                                flt_fmt);
 
-        if (! is || error_state)
+        if (! is)
           {
             error ("load: reading matrix data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         is.seekg (tmp_pos + static_cast<std::streamoff>
                   (READ_PAD (is_small_data_element, len)));
 
@@ -1394,17 +1398,17 @@ read_mat5_binary_element (std::istream& 
                 goto data_read_error;
               }
 
             n = im.numel ();
             read_mat5_binary_data (is, im.fortran_vec (), n, swap,
                                    static_cast<enum mat5_data_type> (type),
                                    flt_fmt);
 
-            if (! is || error_state)
+            if (! is)
               {
                 error ("load: reading imaginary matrix data for '%s'",
                        retval.c_str ());
                 goto data_read_error;
               }
 
             FloatComplexNDArray ctmp (dims);
 
@@ -1437,17 +1441,17 @@ read_mat5_binary_element (std::istream& 
           }
 
         octave_idx_type n = re.numel ();
         tmp_pos = is.tellg ();
         read_mat5_binary_data (is, re.fortran_vec (), n, swap,
                                static_cast<enum mat5_data_type> (type),
                                flt_fmt);
 
-        if (! is || error_state)
+        if (! is)
           {
             error ("load: reading matrix data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         is.seekg (tmp_pos + static_cast<std::streamoff>
                   (READ_PAD (is_small_data_element, len)));
 
@@ -1476,17 +1480,17 @@ read_mat5_binary_element (std::istream& 
                 goto data_read_error;
               }
 
             n = im.numel ();
             read_mat5_binary_data (is, im.fortran_vec (), n, swap,
                                    static_cast<enum mat5_data_type> (type),
                                    flt_fmt);
 
-            if (! is || error_state)
+            if (! is)
               {
                 error ("load: reading imaginary matrix data for '%s'",
                        retval.c_str ());
                 goto data_read_error;
               }
 
             ComplexNDArray ctmp (dims);
 
@@ -1606,17 +1610,17 @@ read_mat5_binary_file_header (std::istre
     {
       // Read the subsystem data block
       is.seekg (subsys_offset, std::ios::beg);
 
       octave_value tc;
       bool global;
       read_mat5_binary_element (is, filename, swap, global, tc);
 
-      if (!is || error_state)
+      if (! is)
         return -1;
 
       if (tc.is_uint8_type ())
         {
           const uint8NDArray itmp = tc.uint8_array_value ();
           octave_idx_type ilen = itmp.numel ();
 
           // Why should I have to initialize outbuf as just overwrite
@@ -1626,17 +1630,17 @@ read_mat5_binary_file_header (std::istre
           char *ctmp = const_cast<char *> (outbuf.c_str ());
           for (octave_idx_type j = 8; j < ilen; j++)
             ctmp[j-8] = itmp(j).char_value ();
 
           std::istringstream fh_ws (outbuf);
 
           read_mat5_binary_element (fh_ws, filename, swap, global, subsys_ov);
 
-          if (error_state)
+          if (! is)
             return -1;
         }
       else
         return -1;
 
       // Reposition to just after the header
       is.seekg (128, std::ios::beg);
     }
@@ -2698,21 +2702,26 @@ save_mat5_binary_element (std::ostream& 
         }
 
       octave_map m;
 
       if (tc.is_object ()
           && load_path::find_method (tc.class_name (),
                                      "saveobj") != std::string ())
         {
-          octave_value_list tmp = feval ("saveobj", tc, 1);
-          if (! error_state)
-            m = tmp(0).map_value ();
-          else
-            goto error_cleanup;
+          try
+            {
+              octave_value_list tmp = feval ("saveobj", tc, 1);
+
+              m = tmp(0).map_value ();
+            }
+          catch (const octave_execution_exception&)
+            {
+              goto error_cleanup;
+            }
         }
       else
         m = tc.map_value ();
 
       // an Octave structure */
       // recursively write each element of the structure
       {
         char buf[64];
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -185,22 +185,17 @@ private:
                                    const std::string& passwd,
                                    std::ostream& os)
   {
     curl_handle h = get_handle ();
 
     url_transfer obj (host, user, passwd, os);
 
     if (obj.is_valid ())
-      {
-        if (! error_state)
-          handle_map[h] = obj;
-        else
-          h = curl_handle ();
-      }
+      handle_map[h] = obj;
     else
       error ("support for url transfers was disabled when Octave was built");
 
     return h;
   }
 
   Matrix do_handle_list (void)
   {
@@ -629,20 +624,17 @@ Undocumented internal function\n\
 
       if (curl.is_valid ())
         {
           std::string path = "";
 
           if (nargin > 1)
             path = args(1).string_value ("__ftp_cwd__: PATH must be a string");
 
-          if (! error_state)
-            curl.cwd (path);
-          else
-            error ("__ftp_cwd__: expecting path as second argument");
+          curl.cwd (path);
         }
       else
         error ("__ftp_cwd__: invalid ftp handle");
     }
 
   return retval;
 }
 
@@ -839,20 +831,17 @@ Undocumented internal function\n\
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
       if (curl.is_valid ())
         {
           std::string file = args(1).string_value ("__ftp_delete__: FILE must be a string");
 
-          if (! error_state)
-            curl.del (file);
-          else
-            error ("__ftp_delete__: expecting file name as second argument");
+          curl.del (file);
         }
       else
         error ("__ftp_delete__: invalid ftp handle");
     }
 
   return retval;
 }
 
@@ -871,20 +860,17 @@ Undocumented internal function\n\
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
       if (curl.is_valid ())
         {
           std::string dir = args(1).string_value ("__ftp_rmdir__: DIR must be a string");
 
-          if (! error_state)
-            curl.rmdir (dir);
-          else
-            error ("__ftp_rmdir__: expecting directory name as second argument");
+          curl.rmdir (dir);
         }
       else
         error ("__ftp_rmdir__: invalid ftp handle");
     }
 
   return retval;
 }
 
@@ -903,20 +889,17 @@ Undocumented internal function\n\
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
       if (curl.is_valid ())
         {
           std::string dir = args(1).string_value ("__ftp_mkdir__: DIR must be a string");
 
-          if (! error_state)
-            curl.mkdir (dir);
-          else
-            error ("__ftp_mkdir__: expecting directory name as second argument");
+          curl.mkdir (dir);
         }
       else
         error ("__ftp_mkdir__: invalid ftp handle");
     }
 
   return retval;
 }
 
@@ -936,20 +919,17 @@ Undocumented internal function\n\
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
       if (curl.is_valid ())
         {
           std::string oldname = args(1).string_value ("__ftp_rename__: OLDNAME must be a string");
           std::string newname = args(2).string_value ("__ftp_rename__: NEWNAME must be a string");
 
-          if (! error_state)
-            curl.rename (oldname, newname);
-          else
-            error ("__ftp_rename__: expecting file names for second and third arguments");
+          curl.rename (oldname, newname);
         }
       else
         error ("__ftp_rename__: invalid ftp handle");
     }
 
   return retval;
 }
 
@@ -968,76 +948,71 @@ Undocumented internal function\n\
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
       if (curl.is_valid ())
         {
           std::string pat = args(1).string_value ("__ftp_mput__: PATTERN must be a string");
 
-          if (! error_state)
+          string_vector file_list;
+
+          glob_match pattern (file_ops::tilde_expand (pat));
+          string_vector files = pattern.glob ();
+
+          for (octave_idx_type i = 0; i < files.numel (); i++)
             {
-              string_vector file_list;
+              std::string file = files (i);
+
+              file_stat fs (file);
 
-              glob_match pattern (file_ops::tilde_expand (pat));
-              string_vector files = pattern.glob ();
+              if (! fs.exists ())
+                {
+                  error ("__ftp__mput: file does not exist");
+                  break;
+                }
 
-              for (octave_idx_type i = 0; i < files.numel (); i++)
+              if (fs.is_dir ())
                 {
-                  std::string file = files (i);
+                  file_list.append (curl.mput_directory ("", file));
 
-                  file_stat fs (file);
+                  if (! curl.good ())
+                    {
+                      error ("__ftp_mput__: %s", curl.lasterror().c_str());
+                      break;
+                    }
+                }
+              else
+                {
+                  // FIXME: Does ascii mode need to be flagged here?
+                  std::ifstream ifile (file.c_str (), std::ios::in |
+                                       std::ios::binary);
 
-                  if (! fs.exists ())
+                  if (! ifile.is_open ())
                     {
-                      error ("__ftp__mput: file does not exist");
+                      error ("__ftp_mput__: unable to open file");
                       break;
                     }
 
-                  if (fs.is_dir ())
-                    {
-                      file_list.append (curl.mput_directory ("", file));
+                  curl.put (file, ifile);
 
-                      if (! curl.good ())
-                        {
-                          error ("__ftp_mput__: %s", curl.lasterror().c_str());
-                          break;
-                        }
-                    }
-                  else
-                    {
-                      // FIXME: Does ascii mode need to be flagged here?
-                      std::ifstream ifile (file.c_str (), std::ios::in |
-                                           std::ios::binary);
+                  ifile.close ();
 
-                      if (! ifile.is_open ())
-                        {
-                          error ("__ftp_mput__: unable to open file");
-                          break;
-                        }
-
-                      curl.put (file, ifile);
-
-                      ifile.close ();
+                  if (! curl.good ())
+                    {
+                      error ("__ftp_mput__: %s", curl.lasterror().c_str());
+                      break;
+                    }
 
-                      if (! curl.good ())
-                        {
-                          error ("__ftp_mput__: %s", curl.lasterror().c_str());
-                          break;
-                        }
+                  file_list.append (file);
+                }
+            }
 
-                      file_list.append (file);
-                    }
-                }
-
-              if (nargout > 0)
-                retval = file_list;
-            }
-          else
-            error ("__ftp_mput__: expecting file name patter as second argument");
+          if (nargout > 0)
+            retval = file_list;
         }
       else
         error ("__ftp_mput__: invalid ftp handle");
     }
 
   return retval;
 }
 
@@ -1061,72 +1036,68 @@ Undocumented internal function\n\
       if (curl.is_valid ())
         {
           std::string file = args(1).string_value ("__ftp_mget__: PATTERN must be a string");
           std::string target;
 
           if (nargin == 3)
             target = args(2).string_value ("__ftp_mget__: TARGET must be a string") + file_ops::dir_sep_str ();
 
-          if (! error_state)
-            {
-              string_vector sv = curl.list ();
-              octave_idx_type n = 0;
-              glob_match pattern (file);
+          string_vector sv = curl.list ();
+          octave_idx_type n = 0;
+          glob_match pattern (file);
 
 
-              for (octave_idx_type i = 0; i < sv.numel (); i++)
+          for (octave_idx_type i = 0; i < sv.numel (); i++)
+            {
+              if (pattern.match (sv(i)))
                 {
-                  if (pattern.match (sv(i)))
-                    {
-                      n++;
+                  n++;
+
+                  time_t ftime;
+                  bool fisdir;
+                  double fsize;
 
-                      time_t ftime;
-                      bool fisdir;
-                      double fsize;
+                  curl.get_fileinfo (sv(i), fsize, ftime, fisdir);
 
-                      curl.get_fileinfo (sv(i), fsize, ftime, fisdir);
+                  if (fisdir)
+                    curl.mget_directory (sv(i), target);
+                  else
+                    {
+                      std::ofstream ofile ((target + sv(i)).c_str (),
+                                           std::ios::out |
+                                           std::ios::binary);
 
-                      if (fisdir)
-                        curl.mget_directory (sv(i), target);
-                      else
+                      if (! ofile.is_open ())
                         {
-                          std::ofstream ofile ((target + sv(i)).c_str (),
-                                               std::ios::out |
-                                               std::ios::binary);
-
-                          if (! ofile.is_open ())
-                            {
-                              error ("__ftp_mget__: unable to open file");
-                              break;
-                            }
-
-                          unwind_protect_safe frame;
-
-                          frame.add_fcn (delete_file, target + sv(i));
-
-                          curl.get (sv(i), ofile);
-
-                          ofile.close ();
-
-                          if (curl.good ())
-                            frame.discard ();
+                          error ("__ftp_mget__: unable to open file");
+                          break;
                         }
 
-                      if (! curl.good ())
-                        {
-                          error ("__ftp_mget__: %s", curl.lasterror().c_str());
-                          break;
-                        }
+                      unwind_protect_safe frame;
+
+                      frame.add_fcn (delete_file, target + sv(i));
+
+                      curl.get (sv(i), ofile);
+
+                      ofile.close ();
+
+                      if (curl.good ())
+                        frame.discard ();
+                    }
+
+                  if (! curl.good ())
+                    {
+                      error ("__ftp_mget__: %s", curl.lasterror().c_str());
+                      break;
                     }
                 }
-              if (n == 0)
-                error ("__ftp_mget__: file not found");
             }
-          else
-            error ("__ftp_mget__: expecting file name and target as second and third arguments");
+
+          if (n == 0)
+            error ("__ftp_mget__: file not found");
         }
       else
         error ("__ftp_mget__: invalid ftp handle");
     }
 
   return retval;
 }
diff --git a/libinterp/corefcn/xpow.cc b/libinterp/corefcn/xpow.cc
--- a/libinterp/corefcn/xpow.cc
+++ b/libinterp/corefcn/xpow.cc
@@ -49,16 +49,22 @@ along with Octave; see the file COPYING.
 
 #include "error.h"
 #include "oct-obj.h"
 #include "utils.h"
 #include "xpow.h"
 
 #include "bsxfun.h"
 
+static void
+gripe_failed_diagonalization (void)
+{
+  gripe_failed_diagonalization ();
+}
+
 static inline int
 xisint (double x)
 {
   return (D_NINT (x) == x
           && ((x >= 0 && x < std::numeric_limits<int>::max ())
               || (x <= 0 && x > std::numeric_limits<int>::min ())));
 }
 
@@ -101,20 +107,20 @@ xpow (double a, const Matrix& b)
 
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be a square matrix. Use .^ for elementwise power.");
   else
     {
-      EIG b_eig (b);
-
-      if (! error_state)
+      try
         {
+          EIG b_eig (b);
+
           ComplexColumnVector lambda (b_eig.eigenvalues ());
           ComplexMatrix Q (b_eig.eigenvectors ());
 
           for (octave_idx_type i = 0; i < nr; i++)
             {
               Complex elt = lambda(i);
               if (std::imag (elt) == 0.0)
                 lambda(i) = std::pow (a, std::real (elt));
@@ -124,18 +130,20 @@ xpow (double a, const Matrix& b)
           ComplexDiagMatrix D (lambda);
 
           ComplexMatrix C = Q * D * Q.inverse ();
           if (a > 0)
             retval = real (C);
           else
             retval = C;
         }
-      else
-        error ("xpow: matrix diagonalization failed");
+      catch (const octave_execution_exception&)
+        {
+          gripe_failed_diagonalization ();
+        }
     }
 
   return retval;
 }
 
 // -*- 3 -*-
 octave_value
 xpow (double a, const Complex& b)
@@ -154,35 +162,37 @@ xpow (double a, const ComplexMatrix& b)
   octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be a square matrix. Use .^ for elementwise power.");
   else
     {
       EIG b_eig (b);
 
-      if (! error_state)
+      try
         {
           ComplexColumnVector lambda (b_eig.eigenvalues ());
           ComplexMatrix Q (b_eig.eigenvectors ());
 
           for (octave_idx_type i = 0; i < nr; i++)
             {
               Complex elt = lambda(i);
               if (std::imag (elt) == 0.0)
                 lambda(i) = std::pow (a, std::real (elt));
               else
                 lambda(i) = std::pow (a, elt);
             }
           ComplexDiagMatrix D (lambda);
 
           retval = ComplexMatrix (Q * D * Q.inverse ());
         }
-      else
-        error ("xpow: matrix diagonalization failed");
+      catch (const octave_execution_exception&)
+        {
+          gripe_failed_diagonalization ();
+        }
     }
 
   return retval;
 }
 
 // -*- 5 -*-
 octave_value
 xpow (const Matrix& a, double b)
@@ -243,30 +253,32 @@ xpow (const Matrix& a, double b)
 
               retval = result;
             }
         }
       else
         {
           EIG a_eig (a);
 
-          if (! error_state)
+          try
             {
               ComplexColumnVector lambda (a_eig.eigenvalues ());
               ComplexMatrix Q (a_eig.eigenvectors ());
 
               for (octave_idx_type i = 0; i < nr; i++)
                 lambda(i) = std::pow (lambda(i), b);
 
               ComplexDiagMatrix D (lambda);
 
               retval = ComplexMatrix (Q * D * Q.inverse ());
             }
-          else
-            error ("xpow: matrix diagonalization failed");
+          catch (const octave_execution_exception&)
+            {
+              gripe_failed_diagonalization ();
+            }
         }
     }
 
   return retval;
 }
 
 // -*- 5d -*-
 octave_value
@@ -322,30 +334,32 @@ xpow (const Matrix& a, const Complex& b)
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be a square matrix. Use .^ for elementwise power.");
   else
     {
       EIG a_eig (a);
 
-      if (! error_state)
+      try
         {
           ComplexColumnVector lambda (a_eig.eigenvalues ());
           ComplexMatrix Q (a_eig.eigenvectors ());
 
           for (octave_idx_type i = 0; i < nr; i++)
             lambda(i) = std::pow (lambda(i), b);
 
           ComplexDiagMatrix D (lambda);
 
           retval = ComplexMatrix (Q * D * Q.inverse ());
         }
-      else
-        error ("xpow: matrix diagonalization failed");
+      catch (const octave_execution_exception&)
+        {
+          gripe_failed_diagonalization ();
+        }
     }
 
   return retval;
 }
 
 // -*- 7 -*-
 octave_value
 xpow (const Complex& a, double b)
@@ -370,35 +384,37 @@ xpow (const Complex& a, const Matrix& b)
   octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be a square matrix. Use .^ for elementwise power.");
   else
     {
       EIG b_eig (b);
 
-      if (! error_state)
+      try
         {
           ComplexColumnVector lambda (b_eig.eigenvalues ());
           ComplexMatrix Q (b_eig.eigenvectors ());
 
           for (octave_idx_type i = 0; i < nr; i++)
             {
               Complex elt = lambda(i);
               if (std::imag (elt) == 0.0)
                 lambda(i) = std::pow (a, std::real (elt));
               else
                 lambda(i) = std::pow (a, elt);
             }
           ComplexDiagMatrix D (lambda);
 
           retval = ComplexMatrix (Q * D * Q.inverse ());
         }
-      else
-        error ("xpow: matrix diagonalization failed");
+      catch (const octave_execution_exception&)
+        {
+          gripe_failed_diagonalization ();
+        }
     }
 
   return retval;
 }
 
 // -*- 9 -*-
 octave_value
 xpow (const Complex& a, const Complex& b)
@@ -418,35 +434,37 @@ xpow (const Complex& a, const ComplexMat
   octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be a square matrix. Use .^ for elementwise power.");
   else
     {
       EIG b_eig (b);
 
-      if (! error_state)
+      try
         {
           ComplexColumnVector lambda (b_eig.eigenvalues ());
           ComplexMatrix Q (b_eig.eigenvectors ());
 
           for (octave_idx_type i = 0; i < nr; i++)
             {
               Complex elt = lambda(i);
               if (std::imag (elt) == 0.0)
                 lambda(i) = std::pow (a, std::real (elt));
               else
                 lambda(i) = std::pow (a, elt);
             }
           ComplexDiagMatrix D (lambda);
 
           retval = ComplexMatrix (Q * D * Q.inverse ());
         }
-      else
-        error ("xpow: matrix diagonalization failed");
+      catch (const octave_execution_exception&)
+        {
+          gripe_failed_diagonalization ();
+        }
     }
 
   return retval;
 }
 
 // -*- 11 -*-
 octave_value
 xpow (const ComplexMatrix& a, double b)
@@ -507,30 +525,32 @@ xpow (const ComplexMatrix& a, double b)
 
               retval = result;
             }
         }
       else
         {
           EIG a_eig (a);
 
-          if (! error_state)
+          try
             {
               ComplexColumnVector lambda (a_eig.eigenvalues ());
               ComplexMatrix Q (a_eig.eigenvectors ());
 
               for (octave_idx_type i = 0; i < nr; i++)
                 lambda(i) = std::pow (lambda(i), b);
 
               ComplexDiagMatrix D (lambda);
 
               retval = ComplexMatrix (Q * D * Q.inverse ());
             }
-          else
-            error ("xpow: matrix diagonalization failed");
+          catch (const octave_execution_exception&)
+            {
+              gripe_failed_diagonalization ();
+            }
         }
     }
 
   return retval;
 }
 
 // -*- 12 -*-
 octave_value
@@ -542,30 +562,32 @@ xpow (const ComplexMatrix& a, const Comp
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be a square matrix. Use .^ for elementwise power.");
   else
     {
       EIG a_eig (a);
 
-      if (! error_state)
+      try
         {
           ComplexColumnVector lambda (a_eig.eigenvalues ());
           ComplexMatrix Q (a_eig.eigenvectors ());
 
           for (octave_idx_type i = 0; i < nr; i++)
             lambda(i) = std::pow (lambda(i), b);
 
           ComplexDiagMatrix D (lambda);
 
           retval = ComplexMatrix (Q * D * Q.inverse ());
         }
-      else
-        error ("xpow: matrix diagonalization failed");
+      catch (const octave_execution_exception&)
+        {
+          gripe_failed_diagonalization ();
+        }
     }
 
   return retval;
 }
 
 // -*- 12d -*-
 octave_value
 xpow (const ComplexDiagMatrix& a, const Complex& b)
@@ -1548,17 +1570,17 @@ xpow (float a, const FloatMatrix& b)
   octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be a square matrix. Use .^ for elementwise power.");
   else
     {
       FloatEIG b_eig (b);
 
-      if (! error_state)
+      try
         {
           FloatComplexColumnVector lambda (b_eig.eigenvalues ());
           FloatComplexMatrix Q (b_eig.eigenvectors ());
 
           for (octave_idx_type i = 0; i < nr; i++)
             {
               FloatComplex elt = lambda(i);
               if (std::imag (elt) == 0.0)
@@ -1570,18 +1592,20 @@ xpow (float a, const FloatMatrix& b)
 
           FloatComplexMatrix C = Q * D * Q.inverse ();
 
           if (a > 0)
             retval = real (C);
           else
             retval = C;
         }
-      else
-        error ("xpow: matrix diagonalization failed");
+      catch (const octave_execution_exception&)
+        {
+          gripe_failed_diagonalization ();
+        }
     }
 
   return retval;
 }
 
 // -*- 3 -*-
 octave_value
 xpow (float a, const FloatComplex& b)
@@ -1600,35 +1624,37 @@ xpow (float a, const FloatComplexMatrix&
   octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be a square matrix. Use .^ for elementwise power.");
   else
     {
       FloatEIG b_eig (b);
 
-      if (! error_state)
+      try
         {
           FloatComplexColumnVector lambda (b_eig.eigenvalues ());
           FloatComplexMatrix Q (b_eig.eigenvectors ());
 
           for (octave_idx_type i = 0; i < nr; i++)
             {
               FloatComplex elt = lambda(i);
               if (std::imag (elt) == 0.0)
                 lambda(i) = std::pow (a, std::real (elt));
               else
                 lambda(i) = std::pow (a, elt);
             }
           FloatComplexDiagMatrix D (lambda);
 
           retval = FloatComplexMatrix (Q * D * Q.inverse ());
         }
-      else
-        error ("xpow: matrix diagonalization failed");
+      catch (const octave_execution_exception&)
+        {
+          gripe_failed_diagonalization ();
+        }
     }
 
   return retval;
 }
 
 // -*- 5 -*-
 octave_value
 xpow (const FloatMatrix& a, float b)
@@ -1689,30 +1715,32 @@ xpow (const FloatMatrix& a, float b)
 
               retval = result;
             }
         }
       else
         {
           FloatEIG a_eig (a);
 
-          if (! error_state)
+          try
             {
               FloatComplexColumnVector lambda (a_eig.eigenvalues ());
               FloatComplexMatrix Q (a_eig.eigenvectors ());
 
               for (octave_idx_type i = 0; i < nr; i++)
                 lambda(i) = std::pow (lambda(i), b);
 
               FloatComplexDiagMatrix D (lambda);
 
               retval = FloatComplexMatrix (Q * D * Q.inverse ());
             }
-          else
-            error ("xpow: matrix diagonalization failed");
+          catch (const octave_execution_exception&)
+            {
+              gripe_failed_diagonalization ();
+            }
         }
     }
 
   return retval;
 }
 
 // -*- 5d -*-
 octave_value
@@ -1757,30 +1785,32 @@ xpow (const FloatMatrix& a, const FloatC
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be a square matrix. Use .^ for elementwise power.");
   else
     {
       FloatEIG a_eig (a);
 
-      if (! error_state)
+      try
         {
           FloatComplexColumnVector lambda (a_eig.eigenvalues ());
           FloatComplexMatrix Q (a_eig.eigenvectors ());
 
           for (octave_idx_type i = 0; i < nr; i++)
             lambda(i) = std::pow (lambda(i), b);
 
           FloatComplexDiagMatrix D (lambda);
 
           retval = FloatComplexMatrix (Q * D * Q.inverse ());
         }
-      else
-        error ("xpow: matrix diagonalization failed");
+      catch (const octave_execution_exception&)
+        {
+          gripe_failed_diagonalization ();
+        }
     }
 
   return retval;
 }
 
 // -*- 7 -*-
 octave_value
 xpow (const FloatComplex& a, float b)
@@ -1805,35 +1835,37 @@ xpow (const FloatComplex& a, const Float
   octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be a square matrix. Use .^ for elementwise power.");
   else
     {
       FloatEIG b_eig (b);
 
-      if (! error_state)
+      try
         {
           FloatComplexColumnVector lambda (b_eig.eigenvalues ());
           FloatComplexMatrix Q (b_eig.eigenvectors ());
 
           for (octave_idx_type i = 0; i < nr; i++)
             {
               FloatComplex elt = lambda(i);
               if (std::imag (elt) == 0.0)
                 lambda(i) = std::pow (a, std::real (elt));
               else
                 lambda(i) = std::pow (a, elt);
             }
           FloatComplexDiagMatrix D (lambda);
 
           retval = FloatComplexMatrix (Q * D * Q.inverse ());
         }
-      else
-        error ("xpow: matrix diagonalization failed");
+      catch (const octave_execution_exception&)
+        {
+          gripe_failed_diagonalization ();
+        }
     }
 
   return retval;
 }
 
 // -*- 9 -*-
 octave_value
 xpow (const FloatComplex& a, const FloatComplex& b)
@@ -1853,35 +1885,37 @@ xpow (const FloatComplex& a, const Float
   octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be a square matrix. Use .^ for elementwise power.");
   else
     {
       FloatEIG b_eig (b);
 
-      if (! error_state)
+      try
         {
           FloatComplexColumnVector lambda (b_eig.eigenvalues ());
           FloatComplexMatrix Q (b_eig.eigenvectors ());
 
           for (octave_idx_type i = 0; i < nr; i++)
             {
               FloatComplex elt = lambda(i);
               if (std::imag (elt) == 0.0)
                 lambda(i) = std::pow (a, std::real (elt));
               else
                 lambda(i) = std::pow (a, elt);
             }
           FloatComplexDiagMatrix D (lambda);
 
           retval = FloatComplexMatrix (Q * D * Q.inverse ());
         }
-      else
-        error ("xpow: matrix diagonalization failed");
+      catch (const octave_execution_exception&)
+        {
+          gripe_failed_diagonalization ();
+        }
     }
 
   return retval;
 }
 
 // -*- 11 -*-
 octave_value
 xpow (const FloatComplexMatrix& a, float b)
@@ -1942,30 +1976,32 @@ xpow (const FloatComplexMatrix& a, float
 
               retval = result;
             }
         }
       else
         {
           FloatEIG a_eig (a);
 
-          if (! error_state)
+          try
             {
               FloatComplexColumnVector lambda (a_eig.eigenvalues ());
               FloatComplexMatrix Q (a_eig.eigenvectors ());
 
               for (octave_idx_type i = 0; i < nr; i++)
                 lambda(i) = std::pow (lambda(i), b);
 
               FloatComplexDiagMatrix D (lambda);
 
               retval = FloatComplexMatrix (Q * D * Q.inverse ());
             }
-          else
-            error ("xpow: matrix diagonalization failed");
+          catch (const octave_execution_exception&)
+            {
+              gripe_failed_diagonalization ();
+            }
         }
     }
 
   return retval;
 }
 
 // -*- 12 -*-
 octave_value
@@ -1977,30 +2013,32 @@ xpow (const FloatComplexMatrix& a, const
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be a square matrix. Use .^ for elementwise power.");
   else
     {
       FloatEIG a_eig (a);
 
-      if (! error_state)
+      try
         {
           FloatComplexColumnVector lambda (a_eig.eigenvalues ());
           FloatComplexMatrix Q (a_eig.eigenvectors ());
 
           for (octave_idx_type i = 0; i < nr; i++)
             lambda(i) = std::pow (lambda(i), b);
 
           FloatComplexDiagMatrix D (lambda);
 
           retval = FloatComplexMatrix (Q * D * Q.inverse ());
         }
-      else
-        error ("xpow: matrix diagonalization failed");
+      catch (const octave_execution_exception&)
+        {
+          gripe_failed_diagonalization ();
+        }
     }
 
   return retval;
 }
 
 // -*- 12d -*-
 octave_value
 xpow (const FloatComplexDiagMatrix& a, const FloatComplex& b)
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -284,29 +284,24 @@ octave_class::dotref (const octave_value
   if (obvp == 0)
     {
       error ("malformed class");
       return retval;
     }
 
   octave_map my_map = (obvp != this) ? obvp->map_value () : map;
 
-  std::string nm = idx(0).string_value ();
+  std::string nm = idx(0).string_value ("invalid index for class");
 
-  if (! error_state)
-    {
-      octave_map::const_iterator p = my_map.seek (nm);
+  octave_map::const_iterator p = my_map.seek (nm);
 
-      if (p != my_map.end ())
-        retval = my_map.contents (p);
-      else
-        error ("class has no member '%s'", nm.c_str ());
-    }
+  if (p != my_map.end ())
+    retval = my_map.contents (p);
   else
-    gripe_invalid_index1 ();
+    error ("class has no member '%s'", nm.c_str ());
 
   return retval;
 }
 
 Matrix
 octave_class::size (void)
 {
   if (in_class_method () || called_from_builtin ())
@@ -650,47 +645,42 @@ octave_class::subsasgn_common (const oct
               {
                 std::list<octave_value_list>::const_iterator p = idx.begin ();
                 octave_value_list t_idx = *p;
 
                 octave_value_list key_idx = *++p;
 
                 assert (key_idx.length () == 1);
 
-                std::string key = key_idx(0).string_value ();
+                std::string key = key_idx(0).string_value ("invalid index for class assignment");
 
-                if (! error_state)
-                  {
-                    octave_value u;
+                octave_value u;
 
-                    if (! map.contains (key))
-                      u = octave_value::empty_conv (type.substr (2), rhs);
-                    else
-                      {
-                        Cell map_val = map.contents (key);
+                if (! map.contains (key))
+                  u = octave_value::empty_conv (type.substr (2), rhs);
+                else
+                  {
+                    Cell map_val = map.contents (key);
 
-                        Cell map_elt = map_val.index (idx.front (), true);
+                    Cell map_elt = map_val.index (idx.front (), true);
 
-                        u = numeric_conv (map_elt, type.substr (2));
-                      }
+                    u = numeric_conv (map_elt, type.substr (2));
+                  }
 
-                    std::list<octave_value_list> next_idx (idx);
-
-                    // We handled two index elements, so subsasgn to
-                    // needs to skip both of them.
+                std::list<octave_value_list> next_idx (idx);
 
-                    next_idx.erase (next_idx.begin ());
-                    next_idx.erase (next_idx.begin ());
-
-                    u.make_unique ();
+                // We handled two index elements, so subsasgn to
+                // needs to skip both of them.
 
-                    t_rhs = u.subsasgn (type.substr (2), next_idx, rhs);
-                  }
-                else
-                  gripe_invalid_index_for_assignment ();
+                next_idx.erase (next_idx.begin ());
+                next_idx.erase (next_idx.begin ());
+
+                u.make_unique ();
+
+                t_rhs = u.subsasgn (type.substr (2), next_idx, rhs);
               }
             else
               gripe_invalid_index_for_assignment ();
           }
           break;
 
         case '.':
           {
@@ -752,29 +742,24 @@ octave_class::subsasgn_common (const oct
           {
             if (n > 1 && type[1] == '.')
               {
                 std::list<octave_value_list>::const_iterator p = idx.begin ();
                 octave_value_list key_idx = *++p;
 
                 assert (key_idx.length () == 1);
 
-                std::string key = key_idx(0).string_value ();
+                std::string key = key_idx(0).string_value ("assignment to class element failed");
+
+                map.assign (idx.front (), key, t_rhs);
 
                 if (! error_state)
                   {
-                    map.assign (idx.front (), key, t_rhs);
-
-                    if (! error_state)
-                      {
-                        count++;
-                        retval = octave_value (this);
-                      }
-                    else
-                      gripe_failed_assignment ();
+                    count++;
+                    retval = octave_value (this);
                   }
                 else
                   gripe_failed_assignment ();
               }
             else
               {
                 if (t_rhs.is_object () || t_rhs.is_map ())
                   {
