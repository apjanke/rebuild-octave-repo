# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1525239380 14400
#      Wed May 02 01:36:20 2018 -0400
# Node ID 3ff9192b676ec5f2478b28f60ca62d8fb47f86ed
# Parent  389757b7b6af603b3aafe07d695c0b08d055b805
use auto keyword to declare iterator variables where possible

* dialog.cc, files-dock-widget.cc, history-dock-widget.cc,
file-editor.cc, octave-qt-link.cc, call-stack.cc, debug.cc,
dynamic-ld.cc, fcn-info.cc, fcn-info.h, genprops.awk, graphics.cc,
gtk-manager.cc, gtk-manager.h, hook-fcn.h, load-path.cc, load-save.cc,
ls-mat5.cc, mex.cc, oct-map.cc, oct-stream.cc, octave-link.cc,
regexp.cc, symscope.h, symtab.h, txt-eng.h, url-handle-manager.cc,
variables.cc, ov-base.cc, ov-class.cc, ov-classdef.cc,
ov-fcn-handle.cc, ov-java.cc, ov-struct.cc, bp-table.cc, jit-ir.cc,
jit-typeinfo.cc, pt-arg-list.cc, pt-arg-list.h, pt-array-list.cc,
pt-check.cc, pt-classdef.cc, pt-decl.h, pt-eval.cc, pt-idx.cc,
pt-jit.cc, pt-misc.cc, pt-pr-code.cc, pt-select.h, pt-stmt.h,
caseless-str.h, lo-regexp.cc:
Use auto keyword to declare iterator variables where possible.
Style fixes.

diff --git a/libgui/src/dialog.cc b/libgui/src/dialog.cc
--- a/libgui/src/dialog.cc
+++ b/libgui/src/dialog.cc
@@ -225,17 +225,17 @@ namespace octave
       view->setSelectionMode (QAbstractItemView::SingleSelection);
     else if (mode == "multiple")
       view->setSelectionMode (QAbstractItemView::ExtendedSelection);
     else
       view->setSelectionMode (QAbstractItemView::NoSelection);
 
     selector = view->selectionModel ();
     int i = 0;
-    for (QList<int>::const_iterator it = initial.begin ();
+    for (auto it = initial.begin ();
          it != initial.end (); it++)
       {
         QModelIndex idx = m_model->index (initial.value (i++) - 1, 0,
                                           QModelIndex ());
         selector->select (idx, QItemSelectionModel::Select);
       }
 
     bool fixed_layout = false;
diff --git a/libgui/src/files-dock-widget.cc b/libgui/src/files-dock-widget.cc
--- a/libgui/src/files-dock-widget.cc
+++ b/libgui/src/files-dock-widget.cc
@@ -545,55 +545,55 @@ namespace octave
   }
 
   void files_dock_widget::contextmenu_open (bool)
   {
 
     QItemSelectionModel *m = m_file_tree_view->selectionModel ();
     QModelIndexList rows = m->selectedRows ();
 
-    for (QModelIndexList::iterator it = rows.begin (); it != rows.end (); it++)
+    for (auto it = rows.begin (); it != rows.end (); it++)
       {
         QFileInfo file = m_file_system_model->fileInfo (*it);
         if (file.exists ())
           display_directory (file.absoluteFilePath ());
       }
   }
 
   void files_dock_widget::contextmenu_open_in_editor (bool)
   {
 
     QItemSelectionModel *m = m_file_tree_view->selectionModel ();
     QModelIndexList rows = m->selectedRows ();
 
-    for (QModelIndexList::iterator it = rows.begin (); it != rows.end (); it++)
+    for (auto it = rows.begin (); it != rows.end (); it++)
       {
         QFileInfo file = m_file_system_model->fileInfo (*it);
         if (file.exists ())
           emit open_file (file.absoluteFilePath ());
       }
   }
 
   void files_dock_widget::contextmenu_open_in_app (bool)
   {
     QItemSelectionModel *m = m_file_tree_view->selectionModel ();
     QModelIndexList rows = m->selectedRows ();
 
-    for (QModelIndexList::iterator it = rows.begin (); it != rows.end (); it++)
+    for (auto it = rows.begin (); it != rows.end (); it++)
       open_item_in_app (*it);
   }
 
   void files_dock_widget::contextmenu_copy_selection (bool)
   {
     QItemSelectionModel *m = m_file_tree_view->selectionModel ();
     QModelIndexList rows = m->selectedRows ();
 
     QStringList selection;
 
-    for (QModelIndexList::iterator it = rows.begin (); it != rows.end (); it++)
+    for (auto it = rows.begin (); it != rows.end (); it++)
       {
         QFileInfo info = m_file_system_model->fileInfo (*it);
 
         selection << info.fileName ();
       }
 
     QClipboard *clipboard = QApplication::clipboard ();
 
@@ -664,17 +664,17 @@ namespace octave
 
   }
 
   void files_dock_widget::contextmenu_delete (bool)
   {
     QItemSelectionModel *m = m_file_tree_view->selectionModel ();
     QModelIndexList rows = m->selectedRows ();
 
-    for (QModelIndexList::iterator it = rows.begin (); it != rows.end (); it++)
+    for (auto it = rows.begin (); it != rows.end (); it++)
       {
         QModelIndex index = *it;
 
         QFileInfo info = m_file_system_model->fileInfo (index);
 
         if (QMessageBox::question (this, tr ("Delete file/directory"),
                                    tr ("Are you sure you want to delete\n")
                                    + info.filePath (),
diff --git a/libgui/src/history-dock-widget.cc b/libgui/src/history-dock-widget.cc
--- a/libgui/src/history-dock-widget.cc
+++ b/libgui/src/history-dock-widget.cc
@@ -161,51 +161,49 @@ namespace octave
     emit command_double_clicked (modelIndex.data ().toString ());
   }
 
   void history_dock_widget::handle_contextmenu_copy (bool)
   {
     QString text;
     QItemSelectionModel *selectionModel = m_history_list_view->selectionModel ();
     QModelIndexList rows = selectionModel->selectedRows ();
-    QModelIndexList::iterator it;
     bool prev_valid_row = false;
-    for (it = rows.begin (); it != rows.end (); it++)
+    for (auto it = rows.begin (); it != rows.end (); it++)
       {
         if ((*it).isValid ())
           {
             if (prev_valid_row)
               text += '\n';
             text += (*it).data ().toString ();
             prev_valid_row = true;
           }
       }
     QApplication::clipboard ()->setText (text);
   }
 
   void history_dock_widget::handle_contextmenu_evaluate (bool)
   {
     QItemSelectionModel *selectionModel = m_history_list_view->selectionModel ();
     QModelIndexList rows = selectionModel->selectedRows ();
-    QModelIndexList::iterator it;
-    for (it = rows.begin () ; it != rows.end (); it++)
+    for (auto it = rows.begin () ; it != rows.end (); it++)
       {
         if ((*it).isValid ())
           emit command_double_clicked ((*it).data ().toString ());
       }
   }
 
   void history_dock_widget::handle_contextmenu_create_script (bool)
   {
     QString text;
     QItemSelectionModel *selectionModel = m_history_list_view->selectionModel ();
     QModelIndexList rows = selectionModel->selectedRows ();
 
     bool prev_valid_row = false;
-    for (QModelIndexList::iterator it = rows.begin (); it != rows.end (); it++)
+    for (auto it = rows.begin (); it != rows.end (); it++)
       {
         if ((*it).isValid ())
           {
             if (prev_valid_row)
               text += '\n';
             text += (*it).data ().toString ();
             prev_valid_row = true;
           }
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -316,17 +316,17 @@ namespace octave
     if (fet)
       m_tab_widget->setCurrentWidget (fet);
   }
 
   // function enabling/disabling the menu accelerators depending on the
   // focus of the editor
   void file_editor::enable_menu_shortcuts (bool enable)
   {
-    QHash<QMenu*, QStringList>::const_iterator i = m_hash_menu_text.constBegin ();
+    auto i = m_hash_menu_text.constBegin ();
 
     while (i != m_hash_menu_text.constEnd ())
       {
         i.key ()->setTitle (i.value ().at (! enable));
         ++i;
       }
 
     // when editor loses focus, enable the actions, which are always active
@@ -372,18 +372,17 @@ namespace octave
 
     // save filenames (even if last session will not be restored next time)
     // together with encoding and the tab index
     QStringList fetFileNames;
     QStringList fet_encodings;
     QStringList fet_index;
 
     // save all open tabs before they are definitely closed
-    for (editor_tab_map_const_iterator p = m_editor_tab_map.begin ();
-         p != m_editor_tab_map.end (); p++)
+    for (auto p = m_editor_tab_map.begin (); p != m_editor_tab_map.end (); p++)
       {
         QString file_name = p->first;   // get file name of tab
         if (! file_name.isEmpty ())      // do not append unnamed files
           {
             fetFileNames.append (file_name);
             fet_encodings.append (m_editor_tab_map[file_name].encoding);
             QString index;
             fet_index.append (index.setNum
@@ -944,17 +943,17 @@ namespace octave
         m_tmp_closed_files << old_name;  // for reloading if error removing
 
         if (! new_name.isEmpty ())
           m_tmp_closed_files << new_name;  // store new name
         else
           m_tmp_closed_files << ""; // no new name, just removing this file
 
         // Get and store the related encoding
-        for (editor_tab_map_const_iterator p = m_editor_tab_map.begin ();
+        for (auto p = m_editor_tab_map.begin ();
              p != m_editor_tab_map.end (); p++)
           {
             if (editor_tab == p->second.fet_ID)
               {
                 m_tmp_closed_files << p->second.encoding;
                 break;
               }
           }
@@ -2311,17 +2310,17 @@ namespace octave
   {
     QDir old_dir (old_name);
 
     // Have all file editor tabs signal what their filenames are.
     m_editor_tab_map.clear ();
     emit fetab_file_name_query (nullptr);
 
     // Loop over all open files and pick those within old_dir
-    for (editor_tab_map_const_iterator p = m_editor_tab_map.begin ();
+    for (auto p = m_editor_tab_map.begin ();
          p != m_editor_tab_map.end (); p++)
       {
         QString rel_path_to_file = old_dir.relativeFilePath (p->first);
         if (rel_path_to_file.left (3) != QString ("../"))
           {
             // We directly go down from old_dir to reach our file: Our
             // file is included in the removed/renamed diectory.
             // Thus delete it.
@@ -2362,17 +2361,17 @@ namespace octave
   {
     // Have all file editor tabs signal what their filenames are.
     m_editor_tab_map.clear ();
     emit fetab_file_name_query (nullptr);
 
     // Check all tabs for the given file name
     QWidget *retval = nullptr;
 
-    for (editor_tab_map_const_iterator p = m_editor_tab_map.begin ();
+    for (auto p = m_editor_tab_map.begin ();
          p != m_editor_tab_map.end (); p++)
       {
         QString tab_file = p->first;
         if (same_file (file.toStdString (), tab_file.toStdString ())
             || file == tab_file)     // needed as same_file ("","") is false.
           {
             retval = p->second.fet_ID;
             break;
diff --git a/libgui/src/octave-qt-link.cc b/libgui/src/octave-qt-link.cc
--- a/libgui/src/octave-qt-link.cc
+++ b/libgui/src/octave-qt-link.cc
@@ -190,37 +190,33 @@ namespace octave
     return answer;
   }
 
   static QStringList
   make_qstring_list (const std::list<std::string>& lst)
   {
     QStringList retval;
 
-    for (std::list<std::string>::const_iterator it = lst.begin ();
-         it != lst.end (); it++)
-      {
-        retval.append (QString::fromStdString (*it));
-      }
+    for (auto it = lst.begin (); it != lst.end (); it++)
+      retval.append (QString::fromStdString (*it));
 
     return retval;
   }
 
   static QStringList
   make_filter_list (const octave_link::filter_list& lst)
   {
     QStringList retval;
 
     // We have pairs of data, first being the list of extensions
     // exta;exb;extc etc second the name to use as filter name
     // (optional).  Qt wants a list of filters in the format of
     // 'FilterName (space separated exts)'.
 
-    for (octave_link::filter_list::const_iterator it = lst.begin ();
-         it != lst.end (); it++)
+    for (auto it = lst.begin (); it != lst.end (); it++)
       {
         QString ext = QString::fromStdString (it->first);
         QString name = QString::fromStdString (it->second);
 
         // Strip out extensions from name and replace ';' with spaces in
         // list.
 
         name.replace (QRegExp ("\\(.*\\)"), "");
@@ -295,21 +291,18 @@ namespace octave
     uiwidget_creator.wait ();
 
     // The GUI has sent a signal and the thread has been awakened.
 
     const QStringList *inputLine = uiwidget_creator.get_string_list ();
 
     uiwidget_creator.unlock ();
 
-    for (QStringList::const_iterator it = inputLine->begin ();
-         it != inputLine->end (); it++)
-      {
-        retval.push_back (it->toStdString ());
-      }
+    for (auto it = inputLine->begin (); it != inputLine->end (); it++)
+      retval.push_back (it->toStdString ());
 
     return retval;
   }
 
   std::list<std::string>
   octave_qt_link::do_file_dialog (const filter_list& filter,
                                   const std::string& title,
                                   const std::string& filename,
@@ -330,23 +323,21 @@ namespace octave
     // Wait while the user is responding to dialog.
     uiwidget_creator.wait ();
 
     // The GUI has sent a signal and the thread has been awakened.
 
     // Add all the file dialog results to a string list.
     const QStringList *inputLine = uiwidget_creator.get_string_list ();
 
-    for (QStringList::const_iterator it = inputLine->begin ();
-         it != inputLine->end (); it++)
+    for (auto it = inputLine->begin (); it != inputLine->end (); it++)
       retval.push_back (it->toStdString ());
 
     retval.push_back (uiwidget_creator.get_dialog_path ()->toStdString ());
-    retval.push_back ((QString ("%1").arg (
-                                           uiwidget_creator.get_dialog_result ())).toStdString ());
+    retval.push_back ((QString ("%1").arg (uiwidget_creator.get_dialog_result ())).toStdString ());
 
     uiwidget_creator.unlock ();
 
     return retval;
   }
 
   // Prompt to allow file to be run by setting cwd (or if addpath_option==true,
   // alternatively setting the path).
diff --git a/libinterp/corefcn/call-stack.cc b/libinterp/corefcn/call-stack.cc
--- a/libinterp/corefcn/call-stack.cc
+++ b/libinterp/corefcn/call-stack.cc
@@ -132,17 +132,17 @@ namespace octave
 
     // Look for the caller of dbstack.
     size_t xframe = cs[curr_frame].m_prev;
 
     bool found = false;
 
     size_t k = cs.size ();
 
-    for (const_reverse_iterator p = cs.rbegin (); p != cs.rend (); p++)
+    for (auto p = cs.rbegin (); p != cs.rend (); p++)
       {
         octave_function *f = (*p).m_fcn;
 
         if (--k == xframe)
           found = true;
 
         if (f && f->is_user_code ())
           {
@@ -160,17 +160,17 @@ namespace octave
     return retval;
   }
 
   octave_user_code *
   call_stack::caller_user_code (size_t nskip) const
   {
     octave_user_code *retval = nullptr;
 
-    const_iterator p = cs.end ();
+    auto p = cs.end ();
 
     while (p != cs.begin ())
       {
         const stack_frame& elt = *(--p);
 
         octave_function *f = elt.m_fcn;
 
         if (f && f->is_user_code ())
@@ -188,17 +188,17 @@ namespace octave
     return retval;
   }
 
   int
   call_stack::caller_user_code_line (void) const
   {
     int retval = -1;
 
-    const_iterator p = cs.end ();
+    auto p = cs.end ();
 
     while (p != cs.begin ())
       {
         const stack_frame& elt = *(--p);
 
         octave_function *f = elt.m_fcn;
 
         if (f && f->is_user_code ())
@@ -214,17 +214,17 @@ namespace octave
     return retval;
   }
 
   int
   call_stack::caller_user_code_column (void) const
   {
     int retval = -1;
 
-    const_iterator p = cs.end ();
+    auto p = cs.end ();
 
     while (p != cs.begin ())
       {
         const stack_frame& elt = *(--p);
 
         octave_function *f = elt.m_fcn;
 
         if (f && f->is_user_code ())
@@ -330,17 +330,17 @@ namespace octave
     return retval;
   }
 
   bool
   call_stack::all_scripts (void) const
   {
     bool retval = true;
 
-    const_iterator p = cs.end ();
+    auto p = cs.end ();
 
     while (p != cs.begin ())
       {
         const stack_frame& elt = *(--p);
 
         octave_function *f = elt.m_fcn;
 
         if (f && ! f->is_user_script ())
@@ -545,17 +545,17 @@ namespace octave
 
     size_t nframes = (nskip <= user_code_frames ? user_code_frames - nskip : 0);
 
     // Our list is reversed.
     curr_user_frame = nframes - curr_user_frame - 1;
 
     if (nframes > 0)
       {
-        for (const_reverse_iterator p = cs.rbegin (); p != cs.rend (); p++)
+        for (auto p = cs.rbegin (); p != cs.rend (); p++)
           {
             const stack_frame& elt = *p;
 
             octave_function *f = elt.m_fcn;
 
             if (f && f->is_user_code ())
               {
                 if (nskip > 0)
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -61,17 +61,17 @@ static octave_value
 intmap_to_ov (const octave::bp_table::intmap& line)
 {
   int idx = 0;
 
   NDArray retval (dim_vector (1, line.size ()));
 
   for (size_t i = 0; i < line.size (); i++)
     {
-      octave::bp_table::const_intmap_iterator p = line.find (i);
+      auto p = line.find (i);
 
       if (p != line.end ())
         {
           int lineno = p->second;
           retval(idx++) = lineno;
         }
     }
 
@@ -499,17 +499,17 @@ The @qcode{"warn"} field is set similarl
       if (ew.isempty ())
         {
           retval = octave_value (retmap);
         }
       else
         {
           octave_map outer (dim_vector (3,1));
           outer.assign ("bkpt", Cell (retmap));
-          for (octave_map::const_iterator f = ew.begin (); f != ew.end (); f++)
+          for (auto f = ew.begin (); f != ew.end (); f++)
             outer.setfield (f->first, ew.contents (f));
 
           retval = octave_value (outer);
         }
 
       return retval;
     }
 }
diff --git a/libinterp/corefcn/dynamic-ld.cc b/libinterp/corefcn/dynamic-ld.cc
--- a/libinterp/corefcn/dynamic-ld.cc
+++ b/libinterp/corefcn/dynamic-ld.cc
@@ -55,17 +55,17 @@ namespace octave
     m_lib_list.push_back (shl);
   }
 
   std::list<std::string>
   dynamic_loader::shlibs_list::remove (dynamic_library& shl)
   {
     std::list<std::string> removed_fcns;
 
-    for (iterator p = m_lib_list.begin (); p != m_lib_list.end (); p++)
+    for (auto p = m_lib_list.begin (); p != m_lib_list.end (); p++)
       {
         if (*p == shl)
           {
             m_lib_list.erase (p);
 
             removed_fcns = shl.close ();
 
             break;
diff --git a/libinterp/corefcn/fcn-info.cc b/libinterp/corefcn/fcn-info.cc
--- a/libinterp/corefcn/fcn-info.cc
+++ b/libinterp/corefcn/fcn-info.cc
@@ -191,17 +191,17 @@ namespace octave
                 // Search parent classes
 
                 symbol_table& symtab
                   = __get_symbol_table__ ("fcn_info::fcn_info_rep::load_class_method");
 
                 const std::list<std::string>& plist =
                   symtab.parent_classes (dispatch_type);
 
-                std::list<std::string>::const_iterator it = plist.begin ();
+                auto it = plist.begin ();
 
                 while (it != plist.end ())
                   {
                     retval = find_method (*it);
 
                     if (retval.is_defined ())
                       {
                         class_methods[dispatch_type] = retval;
@@ -393,17 +393,17 @@ namespace octave
                     && curr_scope.parent_scope ()
                     && curr_scope.parent_scope ()->function () != nullptr)
                   fcn_file
                     = curr_scope.parent_scope ()->function ()->fcn_file_name();
               }
 
             if (! fcn_file.empty ())
               {
-                str_val_iterator r = local_functions.find (fcn_file);
+                auto r = local_functions.find (fcn_file);
 
                 if (r != local_functions.end ())
                   {
                     // We shouldn't need an out-of-date check here since
                     // local functions may ultimately be called only from
                     // a primary function or method defined in the same
                     // file.
 
@@ -415,17 +415,17 @@ namespace octave
         // Private function.
 
         if (current_fcn)
           {
             std::string dir_name = current_fcn->dir_name ();
 
             if (! dir_name.empty ())
               {
-                str_val_iterator q = private_functions.find (dir_name);
+                auto q = private_functions.find (dir_name);
 
                 if (q == private_functions.end ())
                   {
                     octave_value val = load_private_function (dir_name);
 
                     if (val.is_defined ())
                       return val;
                   }
@@ -459,17 +459,17 @@ namespace octave
         octave_value fcn = find_method (dispatch_type);
 
         if (fcn.is_defined ())
           return fcn;
       }
 
     // Class constructors.  The class name and function name are the same.
 
-    str_val_iterator q = class_constructors.find (name);
+    auto q = class_constructors.find (name);
 
     if (q == class_constructors.end ())
       {
         octave_value val = load_class_constructor ();
 
         if (val.is_defined ())
           return val;
       }
@@ -596,17 +596,17 @@ namespace octave
                                                    : nullptr;
 
     if (current_fcn)
       {
         std::string dir_name = current_fcn->dir_name ();
 
         if (! dir_name.empty ())
           {
-            str_val_iterator q = private_functions.find (dir_name);
+            auto q = private_functions.find (dir_name);
 
             if (q == private_functions.end ())
               {
                 octave_value val = load_private_function (dir_name);
 
                 if (val.is_defined ())
                   return val;
               }
@@ -633,17 +633,17 @@ namespace octave
     // Local function.
 
     if (current_fcn)
       {
         std::string fcn_file = current_fcn->fcn_file_name ();
 
         if (! fcn_file.empty ())
           {
-            str_val_iterator r = local_functions.find (fcn_file);
+            auto r = local_functions.find (fcn_file);
 
             if (r != local_functions.end ())
               {
                 // We shouldn't need an out-of-date check here since local
                 // functions may ultimately be called only from a primary
                 // function or method defined in the same file.
 
                 return r->second;
@@ -666,17 +666,17 @@ namespace octave
     return octave_value ();
   }
 
   octave_value
   fcn_info::fcn_info_rep::find_method (const std::string& dispatch_type)
   {
     octave_value retval;
 
-    str_val_iterator q = class_methods.find (dispatch_type);
+    auto q = class_methods.find (dispatch_type);
 
     if (q == class_methods.end ())
       {
         octave_value val = load_class_method (dispatch_type);
 
         if (val.is_defined ())
           return val;
       }
diff --git a/libinterp/corefcn/fcn-info.h b/libinterp/corefcn/fcn-info.h
--- a/libinterp/corefcn/fcn-info.h
+++ b/libinterp/corefcn/fcn-info.h
@@ -126,17 +126,17 @@ namespace octave
       }
 
       void install_built_in_dispatch (const std::string& klass);
 
       template <typename T>
       void
       clear_map (std::map<T, octave_value>& map, bool force = false)
       {
-        typename std::map<T, octave_value>::iterator p = map.begin ();
+        auto p = map.begin ();
 
         while (p != map.end ())
           {
             if (force || ! p->second.islocked ())
               map.erase (p++);
             else
               p++;
           }
diff --git a/libinterp/corefcn/genprops.awk b/libinterp/corefcn/genprops.awk
--- a/libinterp/corefcn/genprops.awk
+++ b/libinterp/corefcn/genprops.awk
@@ -672,17 +672,17 @@ function emit_source ()
     ## all_property_names
     printf ("std::set<std::string>\n");
     if (base)
         printf ("base_properties");
     else
       printf ("%s::properties", class_name);
     printf ("::all_property_names (void) const\n{\n  static std::set<std::string> all_pnames = core_property_names ();\n\n");
     if (base)
-      printf ("  std::set<std::string> retval = all_pnames;\n  std::set<std::string> dyn_props = dynamic_property_names ();\n  retval.insert (dyn_props.begin (), dyn_props.end ());\n  for (std::map<caseless_str, property, cmp_caseless_str>::const_iterator p = all_props.begin ();\n       p != all_props.end (); p++)\n    retval.insert (p->first);\n\n  return retval;\n}\n\n");
+      printf ("  std::set<std::string> retval = all_pnames;\n  std::set<std::string> dyn_props = dynamic_property_names ();\n  retval.insert (dyn_props.begin (), dyn_props.end ());\n  for (auto p = all_props.begin ();\n       p != all_props.end (); p++)\n    retval.insert (p->first);\n\n  return retval;\n}\n\n");
     else
       printf ("  std::set<std::string> retval = all_pnames;\n  std::set<std::string> base_props = base_properties::all_property_names ();\n  retval.insert (base_props.begin (), base_props.end ());\n\n  return retval;\n}\n\n");
 
     if (! base)
       printf ("bool\n%s::properties::has_property (const caseless_str& pname) const\n{\n  std::set<std::string> pnames = all_property_names ();\n\n  return pnames.find (pname) != pnames.end ();\n}\n\n", class_name);
   }
 }
 
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -1910,18 +1910,17 @@ property::create (const std::string& nam
       caseless_str go_name, go_rest;
 
       if (! lookup_object_name (type, go_name, go_rest))
         error ("addproperty: unsupported type for dynamic property (= %s)",
                type.c_str ());
 
       graphics_object go;
 
-      std::map<caseless_str, graphics_object>::const_iterator it =
-        dprop_obj_map.find (go_name);
+      auto it = dprop_obj_map.find (go_name);
 
       if (it == dprop_obj_map.end ())
         {
           base_graphics_object *bgo =
             make_graphics_object_from_type (go_name);
 
           if (bgo)
             {
@@ -2200,17 +2199,17 @@ property_list::set (const caseless_str& 
 
               remove = (sval == "remove");
             }
 
           pval_map_type& pval_map = plist_map[pfx];
 
           if (remove)
             {
-              pval_map_iterator p = pval_map.find (pname);
+              auto p = pval_map.find (pname);
 
               if (p != pval_map.end ())
                 pval_map.erase (p);
             }
           else
             pval_map[pname] = val;
         }
     }
@@ -2291,39 +2290,39 @@ property_list::lookup (const caseless_st
       if (offset > 0)
         {
           std::string pname = name.substr (offset);
 
           std::transform (pfx.begin (), pfx.end (), pfx.begin (), tolower);
           std::transform (pname.begin (), pname.end (), pname.begin (),
                           tolower);
 
-          plist_map_const_iterator p = find (pfx);
+          auto p = find (pfx);
 
           if (p != end ())
             {
               const pval_map_type& pval_map = p->second;
 
-              pval_map_const_iterator q = pval_map.find (pname);
+              auto q = pval_map.find (pname);
 
               if (q != pval_map.end ())
                 retval = q->second;
             }
         }
     }
 
   return retval;
 }
 
 octave_scalar_map
 property_list::as_struct (const std::string& prefix_arg) const
 {
   octave_scalar_map m;
 
-  for (plist_map_const_iterator p = begin (); p != end (); p++)
+  for (auto p = begin (); p != end (); p++)
     {
       std::string prefix = prefix_arg + p->first;
 
       for (const auto& prop_val : p->second)
         m.assign (prefix + prop_val.first, prop_val.second);
     }
 
   return m;
@@ -2617,17 +2616,17 @@ gh_manager::do_get_handle (bool integer_
         retval++;
     }
   else
     {
       // Other graphics handles are negative integers plus some random
       // fractional part.  To avoid running out of integers, we recycle the
       // integer part but tack on a new random part each time.
 
-      free_list_iterator p = handle_free_list.begin ();
+      auto p = handle_free_list.begin ();
 
       if (p != handle_free_list.end ())
         {
           retval = *p;
           handle_free_list.erase (p);
         }
       else
         {
@@ -2643,17 +2642,17 @@ gh_manager::do_get_handle (bool integer_
 void
 gh_manager::do_free (const graphics_handle& h)
 {
   if (h.ok ())
     {
       if (h.value () == 0)
         error ("graphics_handle::free: can't delete root figure");
 
-      iterator p = handle_map.find (h);
+      auto p = handle_map.find (h);
 
       if (p == handle_map.end ())
         error ("graphics_handle::free: invalid object %g", h.value ());
 
       base_properties& bp = p->second.get_properties ();
 
       bp.set_beingdeleted (true);
 
@@ -2682,17 +2681,17 @@ gh_manager::do_free (const graphics_hand
           (std::ceil (h.value ()) - make_handle_fraction ());
     }
 }
 
 void
 gh_manager::do_renumber_figure (const graphics_handle& old_gh,
                                 const graphics_handle& new_gh)
 {
-  iterator p = handle_map.find (old_gh);
+  auto p = handle_map.find (old_gh);
 
   if (p == handle_map.end ())
     error ("graphics_handle::free: invalid object %g", old_gh.value ());
 
   graphics_object go = p->second;
 
   handle_map.erase (p);
 
@@ -3045,17 +3044,17 @@ xreset_default_properties (graphics_hand
 // ---------------------------------------------------------------------
 
 void
 base_properties::set_from_list (base_graphics_object& bgo,
                                 property_list& defaults)
 {
   std::string go_name = graphics_object_name ();
 
-  property_list::plist_map_const_iterator plist = defaults.find (go_name);
+  auto plist = defaults.find (go_name);
 
   if (plist != defaults.end ())
     {
       const property_list::pval_map_type pval_map = plist->second;
 
       for (const auto& prop_val : pval_map)
         {
           std::string pname = prop_val.first;
@@ -3086,32 +3085,30 @@ base_properties::set_from_list (base_gra
 %!   set(0, "defaultfigureunits", "remove");
 %!   set(0, "defaultfigureposition", "remove");
 %! end_unwind_protect
 */
 
 octave_value
 base_properties::get_dynamic (const caseless_str& pname) const
 {
-  std::map<caseless_str, property, cmp_caseless_str>::const_iterator it =
-    all_props.find (pname);
+  auto it = all_props.find (pname);
 
   if (it == all_props.end ())
     error (R"(get: unknown property "%s")", pname.c_str ());
 
   return it->second.get ();
 }
 
 octave_value
 base_properties::get_dynamic (bool all) const
 {
   octave_scalar_map m;
 
-  for (std::map<caseless_str, property, cmp_caseless_str>::const_iterator
-       it = all_props.begin (); it != all_props.end (); ++it)
+  for (auto it = all_props.begin (); it != all_props.end (); ++it)
     if (all || ! it->second.is_hidden ())
       m.assign (it->second.get_name (), it->second.get ());
 
   return m;
 }
 
 std::set<std::string>
 base_properties::dynamic_property_names (void) const
@@ -3129,34 +3126,32 @@ base_properties::has_dynamic_property (c
   else
     return all_props.find (pname) != all_props.end ();
 }
 
 void
 base_properties::set_dynamic (const caseless_str& pname,
                               const octave_value& val)
 {
-  std::map<caseless_str, property, cmp_caseless_str>::iterator it =
-    all_props.find (pname);
+  auto it = all_props.find (pname);
 
   if (it == all_props.end ())
     error (R"(set: unknown property "%s")", pname.c_str ());
 
   it->second.set (val);
 
   dynamic_properties.insert (pname);
 
   mark_modified ();
 }
 
 property
 base_properties::get_property_dynamic (const caseless_str& pname)
 {
-  std::map<caseless_str, property, cmp_caseless_str>::const_iterator it =
-    all_props.find (pname);
+  auto it = all_props.find (pname);
 
   if (it == all_props.end ())
     error (R"(get_property: unknown property "%s")", pname.c_str ());
 
   return it->second;
 }
 
 void
diff --git a/libinterp/corefcn/gtk-manager.cc b/libinterp/corefcn/gtk-manager.cc
--- a/libinterp/corefcn/gtk-manager.cc
+++ b/libinterp/corefcn/gtk-manager.cc
@@ -35,21 +35,21 @@ namespace octave
   graphics_toolkit
   gtk_manager::get_toolkit (void) const
   {
     graphics_toolkit retval;
 
     if (dtk.empty ())
       error ("no graphics toolkits are available!");
 
-    const_loaded_toolkits_iterator pl = loaded_toolkits.find (dtk);
+    auto pl = loaded_toolkits.find (dtk);
 
     if (pl == loaded_toolkits.end ())
       {
-        const_available_toolkits_iterator pa = available_toolkits.find (dtk);
+        auto pa = available_toolkits.find (dtk);
 
         if (pa == available_toolkits.end ())
           error ("default graphics toolkit '%s' is not available!",
                  dtk.c_str ());
 
         octave_value_list args;
         args(0) = dtk;
         feval ("graphics_toolkit", args);
@@ -84,17 +84,17 @@ namespace octave
     available_toolkits.erase (name);
 
     if (dtk == name)
       {
         if (available_toolkits.empty ())
           dtk.clear ();
         else
           {
-            const_available_toolkits_iterator pa = available_toolkits.begin ();
+            auto pa = available_toolkits.begin ();
 
             dtk = *pa++;
 
             while (pa != available_toolkits.end ())
               {
                 std::string tk_name = *pa++;
 
                 if (tk_name == "qt"
diff --git a/libinterp/corefcn/gtk-manager.h b/libinterp/corefcn/gtk-manager.h
--- a/libinterp/corefcn/gtk-manager.h
+++ b/libinterp/corefcn/gtk-manager.h
@@ -58,17 +58,17 @@ namespace octave
 
     void unload_toolkit (const std::string& name)
     {
       loaded_toolkits.erase (name);
     }
 
     graphics_toolkit find_toolkit (const std::string& name) const
     {
-      const_loaded_toolkits_iterator p = loaded_toolkits.find (name);
+      auto p = loaded_toolkits.find (name);
 
       if (p != loaded_toolkits.end ())
         return p->second;
       else
         return graphics_toolkit ();
     }
 
     Cell available_toolkits_list (void) const
@@ -92,17 +92,17 @@ namespace octave
 
       return m;
     }
 
     void unload_all_toolkits (void)
     {
       while (! loaded_toolkits.empty ())
         {
-          loaded_toolkits_iterator p = loaded_toolkits.begin ();
+          auto p = loaded_toolkits.begin ();
 
           std::string name = p->first;
 
           p->second.close ();
 
           // The toolkit may have unloaded itself.  If not, we'll do it here.
           if (loaded_toolkits.find (name) != loaded_toolkits.end ())
             unload_toolkit (name);
diff --git a/libinterp/corefcn/hook-fcn.h b/libinterp/corefcn/hook-fcn.h
--- a/libinterp/corefcn/hook-fcn.h
+++ b/libinterp/corefcn/hook-fcn.h
@@ -235,24 +235,24 @@ public:
   iterator end (void) { return fcn_map.end (); }
 
   const_iterator end (void) const { return fcn_map.end (); }
 
   void erase (iterator p) { fcn_map.erase (p); }
 
   void run (const octave_value_list& initial_args = octave_value_list ())
   {
-    iterator p = fcn_map.begin ();
+    auto p = fcn_map.begin ();
 
     while (p != fcn_map.end ())
       {
         std::string hook_fcn_id = p->first;
         hook_function hook_fcn = p->second;
 
-        iterator q = p++;
+        auto q = p++;
 
         if (hook_fcn.is_valid ())
           hook_fcn.eval (initial_args);
         else
           fcn_map.erase (q);
       }
   }
 
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -333,17 +333,17 @@ namespace octave
             retval = true;
           }
         else
           {
             std::string dir = sys::file_ops::tilde_expand (dir_arg);
 
             dir = strip_trailing_separators (dir);
 
-            dir_info_list_iterator i = find_dir_info (dir);
+            auto i = find_dir_info (dir);
 
             if (i != dir_info_list.end ())
               {
                 retval = true;
 
                 if (remove_hook)
                   remove_hook (dir);
 
@@ -742,17 +742,17 @@ namespace octave
     return retval;
   }
 
   string_vector
   load_path::files (const std::string& dir, bool omit_exts) const
   {
     string_vector retval;
 
-    const_dir_info_list_iterator p = find_dir_info (dir);
+    auto p = find_dir_info (dir);
 
     if (p != dir_info_list.end ())
       retval = p->fcn_files;
 
     if (omit_exts)
       {
         octave_idx_type len = retval.numel ();
 
@@ -847,17 +847,17 @@ namespace octave
 
   // FIXME: maybe we should also maintain a map to speed up this method of access.
 
   load_path::const_dir_info_list_iterator
   load_path::find_dir_info (const std::string& dir_arg) const
   {
     std::string dir = sys::file_ops::tilde_expand (dir_arg);
 
-    const_dir_info_list_iterator retval = dir_info_list.begin ();
+    auto retval = dir_info_list.begin ();
 
     while (retval != dir_info_list.end ())
       {
         if (retval->dir_name == dir)
           break;
 
         retval++;
       }
@@ -865,17 +865,17 @@ namespace octave
     return retval;
   }
 
   load_path::dir_info_list_iterator
   load_path::find_dir_info (const std::string& dir_arg)
   {
     std::string dir = sys::file_ops::tilde_expand (dir_arg);
 
-    dir_info_list_iterator retval = dir_info_list.begin ();
+    auto retval = dir_info_list.begin ();
 
     while (retval != dir_info_list.end ())
       {
         if (retval->dir_name == dir)
           break;
 
         retval++;
       }
@@ -935,17 +935,17 @@ namespace octave
     if (len > 1 && dir_arg.substr (len-2) == "//")
       warning_with_id ("Octave:recursive-path-search",
                        "trailing '//' is no longer special in search path elements");
 
     std::string dir = sys::file_ops::tilde_expand (dir_arg);
 
     dir = strip_trailing_separators (dir);
 
-    dir_info_list_iterator i = find_dir_info (dir);
+    auto i = find_dir_info (dir);
 
     if (i != dir_info_list.end ())
       move (i, at_end);
     else
       {
         sys::file_stat fs (dir);
 
         if (fs)
@@ -1126,17 +1126,17 @@ namespace octave
     else
       {
         if (is_relative)
           {
             try
               {
                 std::string abs_name = sys::env::make_absolute (dir_name);
 
-                const_abs_dir_cache_iterator p = abs_dir_cache.find (abs_name);
+                auto p = abs_dir_cache.find (abs_name);
 
                 if (p != abs_dir_cache.end ())
                   {
                     // The directory is in the cache of all directories we have
                     // visited (indexed by absolute name).  If it is out of date,
                     // initialize it.  Otherwise, copy the info from the cache.
                     // By doing that, we avoid unnecessary calls to stat that can
                     // slow things down tremendously for large directories.
@@ -1185,17 +1185,17 @@ namespace octave
 
     if (pos == std::string::npos)
       return package_dir_map.find (name) != package_dir_map.end ();
     else
       {
         std::string name_head = name.substr (0, pos);
         std::string name_tail = name.substr (pos + 1);
 
-        const_package_dir_map_iterator it = package_dir_map.find (name_head);
+        auto it = package_dir_map.find (name_head);
 
         if (it != package_dir_map.end ())
           return it->second.is_package (name_tail);
         else
           return false;
       }
   }
 
@@ -1338,18 +1338,17 @@ namespace octave
     package_dir_map[package_name] = dir_info (d);
   }
 
   void
   load_path::package_info::move (const dir_info& di, bool at_end)
   {
     std::string dir_name = di.dir_name;
 
-    std::list<std::string>::iterator s =
-      std::find (dir_list.begin (), dir_list.end (), dir_name);
+    auto s = std::find (dir_list.begin (), dir_list.end (), dir_name);
 
     if (s != dir_list.end ())
       {
         dir_list.erase (s);
 
         if (at_end)
           dir_list.push_back (dir_name);
         else
@@ -1467,17 +1466,17 @@ namespace octave
           }
         else
           retval = "";
       }
     else
       {
         dir_name = "";
 
-        const_fcn_map_iterator p = fcn_map.find (fcn);
+        auto p = fcn_map.find (fcn);
 
         if (p != fcn_map.end ())
           {
             const file_info_list_type& file_info_list = p->second;
 
             for (const auto& fi : file_info_list)
               {
                 retval = sys::file_ops::concat (fi.dir_name, fcn);
@@ -1501,23 +1500,23 @@ namespace octave
   load_path::package_info::find_private_fcn (const std::string& dir,
                                              const std::string& fcn,
                                              int type) const
   {
     std::string retval;
 
     //  update ();
 
-    const_private_fcn_map_iterator q = private_fcn_map.find (dir);
+    auto q = private_fcn_map.find (dir);
 
     if (q != private_fcn_map.end ())
       {
         const dir_info::fcn_file_map_type& m = q->second;
 
-        dir_info::const_fcn_file_map_iterator p = m.find (fcn);
+        auto p = m.find (fcn);
 
         if (p != m.end ())
           {
             std::string fname
               = sys::file_ops::concat (sys::file_ops::concat (dir, "private"), fcn);
 
             if (check_file_type (fname, type, p->second, fcn,
                                  "load_path::find_private_fcn"))
@@ -1535,23 +1534,23 @@ namespace octave
                                         int type) const
   {
     std::string retval;
 
     //  update ();
 
     dir_name = "";
 
-    const_method_map_iterator q = method_map.find (class_name);
+    auto q = method_map.find (class_name);
 
     if (q != method_map.end ())
       {
         const fcn_map_type& m = q->second;
 
-        const_fcn_map_iterator p = m.find (meth);
+        auto p = m.find (meth);
 
         if (p != m.end ())
           {
             const file_info_list_type& file_info_list = p->second;
 
             for (const auto& fi : file_info_list)
               {
                 retval = sys::file_ops::concat (fi.dir_name, meth);
@@ -1575,17 +1574,17 @@ namespace octave
 
   std::list<std::string>
   load_path::package_info::methods (const std::string& class_name) const
   {
     std::list<std::string> retval;
 
     //  update ();
 
-    const_method_map_iterator mtd_map_it = method_map.find (class_name);
+    auto mtd_map_it = method_map.find (class_name);
 
     if (mtd_map_it != method_map.end ())
       {
         for (const auto& nm_filst : mtd_map_it->second)
           retval.push_back (nm_filst.first);
       }
 
     if (! retval.empty ())
@@ -1651,17 +1650,17 @@ namespace octave
         if (pos != std::string::npos)
           {
             base = fname.substr (0, pos);
             ext = fname.substr (pos);
           }
 
         file_info_list_type& file_info_list = fcn_map[base];
 
-        file_info_list_iterator p = file_info_list.begin ();
+        auto p = file_info_list.begin ();
 
         while (p != file_info_list.end ())
           {
             if (p->dir_name == dir_name)
               break;
 
             p++;
           }
@@ -1768,17 +1767,17 @@ namespace octave
 
         for (const auto& nm_typ : m)
           {
             std::string base = nm_typ.first;
             int types = nm_typ.second;
 
             file_info_list_type& file_info_list = fm[base];
 
-            file_info_list_iterator p2 = file_info_list.begin ();
+            auto p2 = file_info_list.begin ();
             while (p2 != file_info_list.end ())
               {
                 if (p2->dir_name == full_dir_name)
                   break;
 
                 p2++;
               }
 
@@ -1938,17 +1937,17 @@ namespace octave
               }
           }
       }
   }
 
   void
   load_path::package_info::remove_private_fcn_map (const std::string& dir)
   {
-    private_fcn_map_iterator p = private_fcn_map.find (dir);
+    auto p = private_fcn_map.find (dir);
 
     if (p != private_fcn_map.end ())
       private_fcn_map.erase (p);
   }
 
   void
   load_path::package_info::remove_method_map (const std::string& dir)
   {
@@ -2417,17 +2416,17 @@ For each directory that is added, and th
       std::list<std::string> dir_elts = split_path (arg);
 
       if (! append)
         std::reverse (dir_elts.begin (), dir_elts.end ());
 
       for (auto dir : dir_elts)
         {
           // Remove duplicate directory separators
-          std::string::iterator it_start = dir.begin ();
+          auto it_start = dir.begin ();
 #if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM)
           // In Windows, start check at second character (for UNC paths).
           it_start++;
 #endif
           dir.erase (std::unique (it_start, dir.end (),
                                   [](char l, char r)
                                   {
                                     return l == r &&
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -988,17 +988,17 @@ static size_t
 save_fields (std::ostream& os, const octave_scalar_map& m,
              const std::string& pattern,
              load_save_format fmt, bool save_as_floats)
 {
   glob_match pat (pattern);
 
   size_t saved = 0;
 
-  for (octave_scalar_map::const_iterator it = m.begin (); it != m.end (); it++)
+  for (auto it = m.begin (); it != m.end (); it++)
     {
       std::string empty_str;
 
       if (pat.match (m.key (it)))
         {
           do_save (os, m.contents (it), m.key (it), empty_str,
                    0, fmt, save_as_floats);
 
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -984,18 +984,17 @@ read_mat5_binary_element (std::istream& 
               = octave::__get_call_stack__ ("read_mat5_binary_element");
             cs.push (local_scope, 0);
             frame.add_method (cs, &octave::call_stack::pop);
 
             if (m2.nfields () > 0)
               {
                 octave_value tmp;
 
-                for (octave_map::iterator p0 = m2.begin () ;
-                     p0 != m2.end (); p0++)
+                for (auto p0 = m2.begin (); p0 != m2.end (); p0++)
                   {
                     std::string key = m2.key (p0);
                     octave_value val = m2.contents (p0);
 
                     local_scope.assign (key, val, 0);
                   }
               }
 
@@ -2173,25 +2172,25 @@ save_mat5_element_length (const octave_v
         ret += 8 + PAD (6 > max_namelen ? max_namelen : 6);
       else if (tc.isobject ())
         {
           size_t classlen = tc.class_name ().length ();
 
           ret += 8 + PAD (classlen > max_namelen ? max_namelen : classlen);
         }
 
-      for (octave_map::const_iterator i = m.begin (); i != m.end (); i++)
+      for (auto i = m.begin (); i != m.end (); i++)
         fieldcnt++;
 
       ret += 16 + fieldcnt * (max_namelen + 1);
 
       for (octave_idx_type j = 0; j < nel; j++)
         {
 
-          for (octave_map::const_iterator i = m.begin (); i != m.end (); i++)
+          for (auto i = m.begin (); i != m.end (); i++)
             {
               const Cell elts = m.contents (i);
 
               ret += 8 + save_mat5_element_length (elts(j), "", save_as_floats,
                                                    mat7_format);
             }
         }
     }
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -2123,25 +2123,25 @@ public:
 
   mex& operator = (const mex&) = delete;
 
   ~mex (void)
   {
     // We can't use mex::free here because it modifies memlist.
     while (! memlist.empty ())
       {
-        std::set<void *>::iterator p = memlist.begin ();
+        auto p = memlist.begin ();
         xfree (*p);
         memlist.erase (p);
       }
 
     // We can't use mex::free_value here because it modifies arraylist.
     while (! arraylist.empty ())
       {
-        std::set<mxArray *>::iterator p = arraylist.begin ();
+        auto p = arraylist.begin ();
         delete *p;
         arraylist.erase (p);
       }
 
     if (! (memlist.empty () && arraylist.empty ()))
       error ("mex: %s: cleanup failed", function_name ());
 
     mxFree (fname);
@@ -2221,17 +2221,17 @@ public:
   void * realloc (void *ptr, size_t n)
   {
     void *v;
 
     if (ptr)
       {
         v = std::realloc (ptr, n);
 
-        std::set<void *>::iterator p = memlist.find (ptr);
+        auto p = memlist.find (ptr);
 
         if (v && p != memlist.end ())
           {
             memlist.erase (p);
             memlist.insert (v);
           }
 
         p = global_memlist.find (ptr);
@@ -2250,17 +2250,17 @@ public:
 
   // Free a pointer obtained from malloc or calloc.
   void free (void *ptr)
   {
     if (ptr)
       {
         unmark (ptr);
 
-        std::set<void *>::iterator p = global_memlist.find (ptr);
+        auto p = global_memlist.find (ptr);
 
         if (p != global_memlist.end ())
           {
             global_memlist.erase (p);
 
             xfree (ptr);
           }
         else
@@ -2287,17 +2287,17 @@ public:
 
     memlist.insert (ptr);
   }
 
   // Unmark a pointer to be freed on exit, either because it was
   // made persistent, or because it was already freed.
   void unmark (void *ptr)
   {
-    std::set<void *>::iterator p = memlist.find (ptr);
+    auto p = memlist.find (ptr);
 
     if (p != memlist.end ())
       memlist.erase (p);
 #if defined (DEBUG)
     else
       warning ("%s: value not marked", function_name ());
 #endif
   }
@@ -2305,17 +2305,17 @@ public:
   mxArray * mark_array (mxArray *ptr)
   {
     arraylist.insert (ptr);
     return ptr;
   }
 
   void unmark_array (mxArray *ptr)
   {
-    std::set<mxArray *>::iterator p = arraylist.find (ptr);
+    auto p = arraylist.find (ptr);
 
     if (p != arraylist.end ())
       arraylist.erase (p);
   }
 
   // Mark a pointer as one we allocated.
   void mark_foreign (void *ptr)
   {
@@ -2325,17 +2325,17 @@ public:
 #endif
 
     foreign_memlist.insert (ptr);
   }
 
   // Unmark a pointer as one we allocated.
   void unmark_foreign (void *ptr)
   {
-    std::set<void *>::iterator p = foreign_memlist.find (ptr);
+    auto p = foreign_memlist.find (ptr);
 
     if (p != foreign_memlist.end ())
       foreign_memlist.erase (p);
 #if defined (DEBUG)
     else
       warning ("%s: value not marked", function_name ());
 #endif
 
@@ -2348,17 +2348,17 @@ public:
     return mark_array (new mxArray (ov));
   }
 
   // Free an array and its contents.
   bool free_value (mxArray *ptr)
   {
     bool inlist = false;
 
-    std::set<mxArray *>::iterator p = arraylist.find (ptr);
+    auto p = arraylist.find (ptr);
 
     if (p != arraylist.end ())
       {
         inlist = true;
         arraylist.erase (p);
         delete ptr;
       }
 #if defined (DEBUG)
@@ -2407,17 +2407,17 @@ private:
 #endif
 
     global_memlist.insert (ptr);
   }
 
   // Unmark a pointer as one we allocated.
   void global_unmark (void *ptr)
   {
-    std::set<void *>::iterator p = global_memlist.find (ptr);
+    auto p = global_memlist.find (ptr);
 
     if (p != global_memlist.end ())
       global_memlist.erase (p);
 #if defined (DEBUG)
     else
       warning ("%s: value not marked", function_name ());
 #endif
 
@@ -3653,17 +3653,17 @@ mexSet (double handle, const char *prope
 
 void
 mexUnlock (void)
 {
   if (mex_context)
     {
       const char *fname = mexFunctionName ();
 
-      std::map<std::string,int>::iterator p = mex_lock_count.find (fname);
+      auto p = mex_lock_count.find (fname);
 
       if (p != mex_lock_count.end ())
         {
           int count = --mex_lock_count[fname];
 
           if (count == 0)
             {
               octave::interpreter& interp
diff --git a/libinterp/corefcn/oct-map.cc b/libinterp/corefcn/oct-map.cc
--- a/libinterp/corefcn/oct-map.cc
+++ b/libinterp/corefcn/oct-map.cc
@@ -60,38 +60,38 @@ bool
 octave_fields::isfield (const std::string& field) const
 {
   return rep->find (field) != rep->end ();
 }
 
 octave_idx_type
 octave_fields::getfield (const std::string& field) const
 {
-  fields_rep::iterator p = rep->find (field);
+  auto p = rep->find (field);
   return (p != rep->end ()) ? p->second : -1;
 }
 
 octave_idx_type
 octave_fields::getfield (const std::string& field)
 {
-  fields_rep::iterator p = rep->find (field);
+  auto p = rep->find (field);
   if (p != rep->end ())
     return p->second;
   else
     {
       make_unique ();
       octave_idx_type n = rep->size ();
       return (*rep)[field] = n;
     }
 }
 
 octave_idx_type
 octave_fields::rmfield (const std::string& field)
 {
-  fields_rep::iterator p = rep->find (field);
+  auto p = rep->find (field);
   if (p == rep->end ())
     return -1;
   else
     {
       octave_idx_type n = p->second;
       make_unique ();
       rep->erase (field);
       for (auto& fld_idx : *rep)
@@ -121,18 +121,18 @@ octave_fields::orderfields (Array<octave
 }
 
 bool
 octave_fields::equal_up_to_order (const octave_fields& other,
                                   octave_idx_type *perm) const
 {
   bool retval = true;
 
-  iterator p = begin ();
-  iterator q = other.begin ();
+  auto p = begin ();
+  auto q = other.begin ();
   for (; p != end () && q != other.end (); p++, q++)
     {
       if (p->first == q->first)
         perm[p->second] = q->second;
       else
         {
           retval = false;
           break;
@@ -1188,17 +1188,17 @@ octave_map::assign (const octave_value_l
     }
 }
 
 void
 octave_map::assign (const octave_value_list& idx, const std::string& k,
                     const Cell& rhs)
 {
   Cell tmp;
-  iterator p = seek (k);
+  auto p = seek (k);
   Cell& ref = (p != end () ? contents (p) : tmp);
 
   if (&ref == &tmp)
     ref = Cell (dimensions);
 
   ref.assign (idx, rhs);
 
   if (ref.dims () != dimensions)
@@ -1317,19 +1317,19 @@ octave_map::delete_elements (const octav
 %! assert (fieldnames (x([1, 2], [2:5])), {"d"; "a"; "f"});
 */
 
 octave_map
 octave_map::concat (const octave_map& rb, const Array<octave_idx_type>& ra_idx)
 {
   if (nfields () == rb.nfields ())
     {
-      for (const_iterator pa = begin (); pa != end (); pa++)
+      for (auto pa = begin (); pa != end (); pa++)
         {
-          const_iterator pb = rb.seek (key (pa));
+          auto pb = rb.seek (key (pa));
 
           if (pb == rb.end ())
             error ("field name mismatch in structure concatenation");
 
           contents(pa).insert (rb.contents (pb), ra_idx);
         }
     }
   else
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -3386,17 +3386,17 @@ namespace octave
 
   int
   textscan::read_format_once (delimited_stream& is,
                               textscan_format_list& fmt_list,
                               std::list<octave_value>& retval,
                               Array<octave_idx_type> row, int& done_after)
   {
     const textscan_format_elt *elem = fmt_list.first ();
-    std::list<octave_value>::iterator out = retval.begin ();
+    auto out = retval.begin ();
     bool no_conversions = true;
     bool done = false;
     bool conversion_failed = false;       // Record for ReturnOnError
     bool nothing_worked = true;
 
     octave_quit ();
 
     for (size_t i = 0; i < fmt_list.numel (); i++)
@@ -6307,18 +6307,17 @@ namespace octave
     typedef typename DST_T::element_type dst_elt_type;
 
     DST_T conv (dim_vector (nr, nc));
 
     dst_elt_type *conv_data = conv.fortran_vec ();
 
     octave_idx_type j = 0;
 
-    for (std::list<void *>::const_iterator it = input_buf_list.begin ();
-         it != input_buf_list.end (); it++)
+    for (auto it = input_buf_list.begin (); it != input_buf_list.end (); it++)
       {
         SRC_T *data = static_cast<SRC_T *> (*it);
 
         if (swap || do_float_fmt_conv)
           {
             if (do_NA_conv)
               {
                 for (octave_idx_type i = 0; i < input_buf_elts && j < elts_read;
@@ -7353,17 +7352,17 @@ namespace octave
 
     if (fid < 0)
       err_invalid_file_id (fid, who);
 
     if (lookup_cache != list.end () && lookup_cache->first == fid)
       retval = lookup_cache->second;
     else
       {
-        ostrl_map::const_iterator iter = list.find (fid);
+        auto iter = list.find (fid);
 
         if (iter == list.end ())
           err_invalid_file_id (fid, who);
 
         retval = iter->second;
         lookup_cache = iter;
       }
 
@@ -7379,17 +7378,17 @@ namespace octave
   }
 
   int stream_list::remove (int fid, const std::string& who)
   {
     // Can't remove stdin (std::cin), stdout (std::cout), or stderr (std::cerr).
     if (fid < 3)
       err_invalid_file_id (fid, who);
 
-    ostrl_map::iterator iter = list.find (fid);
+    auto iter = list.find (fid);
 
     if (iter == list.end ())
       err_invalid_file_id (fid, who);
 
     stream os = iter->second;
     list.erase (iter);
     lookup_cache = list.end ();
 
@@ -7426,17 +7425,17 @@ namespace octave
   {
     if (flush)
       {
         // Flush stdout and stderr.
         list[1].flush ();
         list[2].flush ();
       }
 
-    for (ostrl_map::iterator iter = list.begin (); iter != list.end (); )
+    for (auto iter = list.begin (); iter != list.end (); )
       {
         int fid = iter->first;
         if (fid < 3)  // Don't delete stdin, stdout, stderr
           {
             iter++;
             continue;
           }
 
@@ -7470,17 +7469,17 @@ namespace octave
     if (fid < 0)
       return retval;
 
     stream os;
     if (lookup_cache != list.end () && lookup_cache->first == fid)
       os = lookup_cache->second;
     else
       {
-        ostrl_map::const_iterator iter = list.find (fid);
+        auto iter = list.find (fid);
 
         if (iter == list.end ())
           return retval;
 
         os = iter->second;
         lookup_cache = iter;
       }
 
diff --git a/libinterp/corefcn/octave-link.cc b/libinterp/corefcn/octave-link.cc
--- a/libinterp/corefcn/octave-link.cc
+++ b/libinterp/corefcn/octave-link.cc
@@ -252,17 +252,17 @@ Undocumented internal function.
         }
     }
   else
     {
       // Multiple files.
       nel -= 2;
       Cell items (dim_vector (1, nel));
 
-      std::list<std::string>::iterator it = items_lst.begin ();
+      auto it = items_lst.begin ();
 
       for (int idx = 0; idx < nel; idx++, it++)
         items.xelem (idx) = *it;
 
       retval = ovl (items, *it++, atoi (it->c_str ()));
     }
 
   return retval;
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -403,17 +403,17 @@ octregexp (const octave_value_list& args
 
           nmap.assign (named_pats(j), ctmp);
         }
     }
   retval(5) = nmap;
 
   if (options.once ())
     {
-      octave::regexp::match_data::const_iterator p = rx_lst.begin ();
+      auto p = rx_lst.begin ();
 
       retval(4) = (sz ? p->tokens () : Cell ());
       retval(3) = (sz ? p->match_string () : "");
       retval(2) = (sz ? p->token_extents () : Matrix ());
 
       if (sz)
         {
           double start = p->start ();
diff --git a/libinterp/corefcn/symscope.h b/libinterp/corefcn/symscope.h
--- a/libinterp/corefcn/symscope.h
+++ b/libinterp/corefcn/symscope.h
@@ -116,17 +116,17 @@ namespace octave
 
     symbol_record::context_id current_context (void) const
     {
       return m_context;
     }
 
     symbol_record find_symbol (const std::string& name)
     {
-      table_iterator p = m_symbols.find (name);
+      auto p = m_symbols.find (name);
 
       if (p == m_symbols.end ())
         return insert (name);
       else
         return p->second;
     }
 
     void inherit_internal
@@ -174,34 +174,34 @@ namespace octave
     find (const std::string& name, const octave_value_list& args,
           bool skip_variables, bool local_funcs);
 
     symbol_record&
     insert (const std::string& name, bool force_add = false);
 
     void rename (const std::string& old_name, const std::string& new_name)
     {
-      table_iterator p = m_symbols.find (old_name);
+      auto p = m_symbols.find (old_name);
 
       if (p != m_symbols.end ())
         {
           symbol_record sr = p->second;
 
           sr.rename (new_name);
 
           m_symbols.erase (p);
 
           m_symbols[new_name] = sr;
         }
     }
 
     void assign (const std::string& name, const octave_value& value,
                  bool force_add)
     {
-      table_iterator p = m_symbols.find (name);
+      auto p = m_symbols.find (name);
 
       if (p == m_symbols.end ())
         {
           symbol_record& sr = insert (name, force_add);
 
           sr.assign (value, m_context);
         }
       else
@@ -211,41 +211,41 @@ namespace octave
     void assign (const std::string& name,
                  const octave_value& value = octave_value ())
     {
       assign (name, value, false);
     }
 
     void force_assign (const std::string& name, const octave_value& value)
     {
-      table_iterator p = m_symbols.find (name);
+      auto p = m_symbols.find (name);
 
       if (p == m_symbols.end ())
         {
           symbol_record& sr = insert (name, true);
 
           sr.assign (value, m_context);
         }
       else
         p->second.assign (value, m_context);
     }
 
     octave_value varval (const std::string& name) const
     {
-      table_const_iterator p = m_symbols.find (name);
+      auto p = m_symbols.find (name);
 
       return (p != m_symbols.end ()
               ? p->second.varval (m_context) : octave_value ());
     }
 
     bool is_variable (const std::string& name) const
     {
       bool retval = false;
 
-      table_const_iterator p = m_symbols.find (name);
+      auto p = m_symbols.find (name);
 
       if (p != m_symbols.end ())
         {
           const symbol_record& sr = p->second;
 
           retval = sr.is_variable (m_context);
         }
 
@@ -255,17 +255,17 @@ namespace octave
     void push_context (void)
     {
       for (auto& nm_sr : m_symbols)
         nm_sr.second.push_context ();
     }
 
     void pop_context (void)
     {
-      table_iterator tbl_it = m_symbols.begin ();
+      auto tbl_it = m_symbols.begin ();
 
       while (tbl_it != m_symbols.end ())
         {
           if (tbl_it->second.pop_context () == 0)
             m_symbols.erase (tbl_it++);
           else
             tbl_it++;
         }
@@ -298,17 +298,17 @@ namespace octave
           octave_value val = sr.varval (m_context);
           if (val.isobject ())
             nm_sr.second.clear (m_context);
         }
     }
 
     void clear_variable (const std::string& name)
     {
-      table_iterator p = m_symbols.find (name);
+      auto p = m_symbols.find (name);
 
       if (p != m_symbols.end ())
         p->second.clear (m_context);
       else if (m_is_nested)
         {
           std::shared_ptr<symbol_scope_rep> psr = parent_scope_rep ();
 
           if (psr)
@@ -457,26 +457,26 @@ namespace octave
 
       retval.sort ();
 
       return retval;
     }
 
     bool is_local_variable (const std::string& name) const
     {
-      table_const_iterator p = m_symbols.find (name);
+      auto p = m_symbols.find (name);
 
       return (p != m_symbols.end ()
               && ! p->second.is_global ()
               && p->second.is_defined (m_context));
     }
 
     bool is_global (const std::string& name) const
     {
-      table_const_iterator p = m_symbols.find (name);
+      auto p = m_symbols.find (name);
 
       return p != m_symbols.end () && p->second.is_global ();
     }
 
     void install_subfunction (const std::string& name,
                               const octave_value& fval)
     {
       m_subfunctions[name] = fval;
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -194,17 +194,17 @@ namespace octave
       octave_value val = find_built_in_function (name);
 
       return val.is_defined ();
     }
 
     octave_value
     find_method (const std::string& name, const std::string& dispatch_type)
     {
-      fcn_table_const_iterator p = m_fcn_table.find (name);
+      auto p = m_fcn_table.find (name);
 
       if (p != m_fcn_table.end ())
         {
           octave_value fcn = p->second.find_method (dispatch_type);
 
           if (! fcn.is_defined ())
             fcn = find_submethod (name, dispatch_type);
 
@@ -227,26 +227,26 @@ namespace octave
     }
 
     octave_value
     find_submethod (const std::string& name, const std::string& dispatch_type);
 
     octave_value
     find_built_in_function (const std::string& name)
     {
-      fcn_table_const_iterator p = m_fcn_table.find (name);
+      auto p = m_fcn_table.find (name);
 
       return (p != m_fcn_table.end ()
               ? p->second.find_built_in_function () : octave_value ());
     }
 
     octave_value
     find_autoload (const std::string& name)
     {
-      fcn_table_iterator p = m_fcn_table.find (name);
+      auto p = m_fcn_table.find (name);
 
       return (p != m_fcn_table.end ()
               ? p->second.find_autoload () : octave_value ());
     }
 
     octave_value builtin_find (const std::string& name);
 
     octave_value
@@ -256,34 +256,34 @@ namespace octave
 
     octave_value
     find_function (const std::string& name,
                    const octave_value_list& args = octave_value_list (),
                    bool local_funcs = true);
 
     octave_value find_user_function (const std::string& name)
     {
-      fcn_table_iterator p = m_fcn_table.find (name);
+      auto p = m_fcn_table.find (name);
 
       return (p != m_fcn_table.end ()
               ? p->second.find_user_function () : octave_value ());
     }
 
     octave_value find_cmdline_function (const std::string& name)
     {
-      fcn_table_iterator p = m_fcn_table.find (name);
+      auto p = m_fcn_table.find (name);
 
       return (p != m_fcn_table.end ()
               ? p->second.find_cmdline_function () : octave_value ());
     }
 
     void install_cmdline_function (const std::string& name,
                                    const octave_value& fcn)
     {
-      fcn_table_iterator p = m_fcn_table.find (name);
+      auto p = m_fcn_table.find (name);
 
       if (p != m_fcn_table.end ())
         {
           fcn_info& finfo = p->second;
 
           finfo.install_cmdline_function (fcn);
         }
       else
@@ -298,17 +298,17 @@ namespace octave
 
     // Install local function FCN named NAME.  FILE_NAME is the name of
     // the file containing the local function.
 
     void install_local_function (const std::string& name,
                                  const octave_value& fcn,
                                  const std::string& file_name)
     {
-      fcn_table_iterator p = m_fcn_table.find (name);
+      auto p = m_fcn_table.find (name);
 
       if (p != m_fcn_table.end ())
         {
           fcn_info& finfo = p->second;
 
           finfo.install_local_function (fcn, file_name);
         }
       else
@@ -319,17 +319,17 @@ namespace octave
 
           m_fcn_table[name] = finfo;
         }
     }
 
     void install_user_function (const std::string& name,
                                 const octave_value& fcn)
     {
-      fcn_table_iterator p = m_fcn_table.find (name);
+      auto p = m_fcn_table.find (name);
 
       if (p != m_fcn_table.end ())
         {
           fcn_info& finfo = p->second;
 
           finfo.install_user_function (fcn);
         }
       else
@@ -342,17 +342,17 @@ namespace octave
         }
     }
 
     // FIXME: should we ensure that FCN really is a built-in function
     // object?
     void install_built_in_function (const std::string& name,
                                     const octave_value& fcn)
     {
-      fcn_table_iterator p = m_fcn_table.find (name);
+      auto p = m_fcn_table.find (name);
 
       if (p != m_fcn_table.end ())
         {
           fcn_info& finfo = p->second;
 
           finfo.install_built_in_function (fcn);
         }
       else
@@ -378,17 +378,17 @@ namespace octave
     void clear_global_pattern (const std::string& pattern);
 
     // This is written as two separate functions instead of a single
     // function with default values so that it will work properly with
     // unwind_protect.
 
     void clear_functions (bool force = false)
     {
-      fcn_table_iterator p = m_fcn_table.begin ();
+      auto p = m_fcn_table.begin ();
 
       while (p != m_fcn_table.end ())
         (p++)->second.clear (force);
     }
 
     void clear_function (const std::string& name)
     {
       clear_user_function (name);
@@ -403,17 +403,17 @@ namespace octave
 
       clear_function (name);
     }
 
     void clear_function_pattern (const std::string& pat)
     {
       glob_match pattern (pat);
 
-      fcn_table_iterator p = m_fcn_table.begin ();
+      auto p = m_fcn_table.begin ();
 
       while (p != m_fcn_table.end ())
         {
           if (pattern.match (p->first))
             (p++)->second.clear_user_function ();
           else
             p++;
         }
@@ -426,46 +426,46 @@ namespace octave
       if (m_current_scope)
         m_current_scope.clear_variable_pattern (pat);
 
       clear_function_pattern (pat);
     }
 
     void clear_user_function (const std::string& name)
     {
-      fcn_table_iterator p = m_fcn_table.find (name);
+      auto p = m_fcn_table.find (name);
 
       if (p != m_fcn_table.end ())
         {
           fcn_info& finfo = p->second;
 
           finfo.clear_user_function ();
         }
       // FIXME: is this necessary, or even useful?
       // else
       //   error ("clear: no such function '%s'", name.c_str ());
     }
 
     // This clears oct and mex files, including autoloads.
     void clear_dld_function (const std::string& name)
     {
-      fcn_table_iterator p = m_fcn_table.find (name);
+      auto p = m_fcn_table.find (name);
 
       if (p != m_fcn_table.end ())
         {
           fcn_info& finfo = p->second;
 
           finfo.clear_autoload_function ();
           finfo.clear_user_function ();
         }
     }
 
     void clear_mex_functions (void)
     {
-      fcn_table_iterator p = m_fcn_table.begin ();
+      auto p = m_fcn_table.begin ();
 
       while (p != m_fcn_table.end ())
         (p++)->second.clear_mex_function ();
     }
 
     bool set_class_relationship (const std::string& sup_class,
                                  const std::string& inf_class);
 
@@ -486,17 +486,17 @@ namespace octave
         }
       else
         panic ("alias: '%s' is undefined", name.c_str ());
     }
 
     void install_built_in_dispatch (const std::string& name,
                                     const std::string& klass)
     {
-      fcn_table_iterator p = m_fcn_table.find (name);
+      auto p = m_fcn_table.find (name);
 
       if (p != m_fcn_table.end ())
         {
           fcn_info& finfo = p->second;
 
           finfo.install_built_in_dispatch (klass);
         }
       else
@@ -635,17 +635,17 @@ namespace octave
       m_parent_map[classname] = parent_list;
     }
 
     std::list<std::string>
     parent_classes (const std::string& dispatch_type)
     {
       std::list<std::string> retval;
 
-      const_parent_map_iterator it = m_parent_map.find (dispatch_type);
+      auto it = m_parent_map.find (dispatch_type);
 
       if (it != m_parent_map.end ())
         retval = it->second;
 
       for (const auto& nm : retval)
         {
           // Search for parents of parents and append them to the list.
 
@@ -664,17 +664,17 @@ namespace octave
     {
       return m_current_scope ? m_current_scope.function () : nullptr;
     }
 
     void cleanup (void);
 
     fcn_info * get_fcn_info (const std::string& name)
     {
-      fcn_table_iterator p = m_fcn_table.find (name);
+      auto p = m_fcn_table.find (name);
       return p != m_fcn_table.end () ? &p->second : nullptr;
     }
 
   private:
 
     typedef std::map<std::string, octave_value>::const_iterator
       global_symbols_const_iterator;
     typedef std::map<std::string, octave_value>::iterator
diff --git a/libinterp/corefcn/txt-eng.h b/libinterp/corefcn/txt-eng.h
--- a/libinterp/corefcn/txt-eng.h
+++ b/libinterp/corefcn/txt-eng.h
@@ -117,17 +117,17 @@ public:
   text_element_list (text_element *e)
     : text_element (), octave::base_list<text_element*> ()
   { push_back (e); }
 
   ~text_element_list (void)
   {
     while (! empty ())
       {
-        iterator it = begin ();
+        auto it = begin ();
         delete (*it);
         erase (it);
       }
   }
 
   void accept (text_processor& p);
 };
 
diff --git a/libinterp/corefcn/url-handle-manager.cc b/libinterp/corefcn/url-handle-manager.cc
--- a/libinterp/corefcn/url-handle-manager.cc
+++ b/libinterp/corefcn/url-handle-manager.cc
@@ -43,17 +43,17 @@ namespace octave
   url_handle url_handle_manager::get_handle (void)
   {
     url_handle retval;
 
     // Curl handles are negative integers plus some random fractional
     // part.  To avoid running out of integers, we recycle the integer
     // part but tack on a new random part each time.
 
-    free_list_iterator p = handle_free_list.begin ();
+    auto p = handle_free_list.begin ();
 
     if (p != handle_free_list.end ())
       {
         retval = *p;
         handle_free_list.erase (p);
       }
     else
       {
@@ -64,17 +64,17 @@ namespace octave
 
     return retval;
   }
 
   void url_handle_manager::free (const url_handle& h)
   {
     if (h.ok ())
       {
-        iterator p = handle_map.find (h);
+        auto p = handle_map.find (h);
 
         if (p == handle_map.end ())
           error ("url_handle_manager::free: invalid object %g", h.value ());
 
         // Curl handles are negative integers plus some random
         // fractional part.  To avoid running out of integers, we
         // recycle the integer part but tack on a new random part
         // each time.
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -1008,17 +1008,17 @@ whos_parameter
   std::string text;
   std::string line;
 };
 
 static void
 print_descriptor (std::ostream& os, std::list<whos_parameter> params)
 {
   // This method prints a line of information on a given symbol
-  std::list<whos_parameter>::iterator i = params.begin ();
+  auto i = params.begin ();
   std::ostringstream param_buf;
 
   octave::preserve_stream_state stream_state (os);
 
   while (i != params.end ())
     {
       whos_parameter param = *i;
 
@@ -1149,17 +1149,17 @@ private:
       is_complex = varval.iscomplex ();
     }
 
     void display_line (std::ostream& os,
                        const std::list<whos_parameter>& params) const
     {
       std::string dims_str = get_dims_str (varval);
 
-      std::list<whos_parameter>::const_iterator i = params.begin ();
+      auto i = params.begin ();
 
       octave::preserve_stream_state stream_state (os);
 
       while (i != params.end ())
         {
           whos_parameter param = *i;
 
           if (param.command != '\0')
@@ -1325,17 +1325,17 @@ public:
     Cell bytes_info (len, 1);
     Cell class_info (len, 1);
     Cell global_info (len, 1);
     Cell sparse_info (len, 1);
     Cell complex_info (len, 1);
     Cell nesting_info (len, 1);
     Cell persistent_info (len, 1);
 
-    std::list<symbol_info>::const_iterator p = lst.begin ();
+    auto p = lst.begin ();
 
     for (size_t j = 0; j < len; j++)
       {
         const symbol_info& si = *p++;
 
         octave_scalar_map ni;
 
         ni.assign ("function", caller_function_name);
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -1405,17 +1405,17 @@ make_idx_args (const std::string& type,
   size_t len = type.length ();
 
   if (len != idx.size ())
     error ("invalid index for %s", who.c_str ());
 
   Cell type_field (1, len);
   Cell subs_field (1, len);
 
-  std::list<octave_value_list>::const_iterator p = idx.begin ();
+  auto p = idx.begin ();
 
   for (size_t i = 0; i < len; i++)
     {
       char t = type[i];
 
       switch (t)
         {
         case '(':
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -277,17 +277,17 @@ octave_class::dotref (const octave_value
 
   if (obvp == nullptr)
     error ("malformed class");
 
   octave_map my_map = (obvp != this) ? obvp->map_value () : map;
 
   std::string nm = idx(0).xstring_value ("invalid index for class");
 
-  octave_map::const_iterator p = my_map.seek (nm);
+  auto p = my_map.seek (nm);
 
   if (p == my_map.end ())
     error ("class has no member '%s'", nm.c_str ());
 
   return my_map.contents (p);
 }
 
 Matrix
@@ -382,17 +382,17 @@ octave_class::subsref (const std::string
       int skip = 1;
 
       switch (type[0])
         {
         case '(':
           {
             if (type.length () > 1 && type[1] == '.')
               {
-                std::list<octave_value_list>::const_iterator p = idx.begin ();
+                auto p = idx.begin ();
                 octave_value_list key_idx = *++p;
 
                 Cell tmp = dotref (key_idx);
 
                 Cell t = tmp.index (idx.front ());
 
                 retval(0) = (t.numel () == 1 ? t(0)
                                              : octave_value (t, true));
@@ -630,17 +630,17 @@ octave_class::subsasgn_common (const oct
   if (n > 1 && ! (type.length () == 2 && type[0] == '(' && type[1] == '.'))
     {
       switch (type[0])
         {
         case '(':
           {
             if (type.length () > 1 && type[1] == '.')
               {
-                std::list<octave_value_list>::const_iterator p = idx.begin ();
+                auto p = idx.begin ();
                 octave_value_list t_idx = *p;
 
                 octave_value_list key_idx = *++p;
 
                 assert (key_idx.length () == 1);
 
                 std::string key = key_idx(0).xstring_value ("invalid index for class assignment");
 
@@ -684,17 +684,17 @@ octave_class::subsasgn_common (const oct
 
             std::list<octave_value_list> next_idx (idx);
 
             next_idx.erase (next_idx.begin ());
 
             std::string next_type = type.substr (1);
 
             Cell tmpc (1, 1);
-            octave_map::iterator pkey = map.seek (key);
+            auto pkey = map.seek (key);
             if (pkey != map.end ())
               {
                 map.contents (pkey).make_unique ();
                 tmpc = map.contents (pkey);
               }
 
             // FIXME: better code reuse?
             if (tmpc.numel () != 1)
@@ -725,17 +725,17 @@ octave_class::subsasgn_common (const oct
     }
 
   switch (type[0])
     {
     case '(':
       {
         if (n > 1 && type[1] == '.')
           {
-            std::list<octave_value_list>::const_iterator p = idx.begin ();
+            auto p = idx.begin ();
             octave_value_list key_idx = *++p;
 
             assert (key_idx.length () == 1);
 
             std::string key = key_idx(0).xstring_value ("assignment to class element failed");
 
             map.assign (idx.front (), key, t_rhs);
 
@@ -841,17 +841,17 @@ octave_class::index_vector (bool require
 
 size_t
 octave_class::byte_size (void) const
 {
   // Neglect the size of the fieldnames.
 
   size_t retval = 0;
 
-  for (octave_map::const_iterator it = map.begin (); it != map.end (); it++)
+  for (auto it = map.begin (); it != map.end (); it++)
     {
       std::string key = map.key (it);
 
       octave_value val = octave_value (map.contents (it));
 
       retval += val.byte_size ();
     }
 
@@ -891,17 +891,17 @@ octave_class::find_parent_class (const s
   octave_base_value *retval = nullptr;
 
   if (parent_class_name == class_name ())
     retval = this;
   else
     {
       for (auto& par : parent_list)
         {
-          octave_map::const_iterator smap = map.seek (par);
+          auto smap = map.seek (par);
 
           const Cell& tmp = map.contents (smap);
 
           octave_value vtmp = tmp(0);
 
           octave_base_value *obvp = vtmp.internal_rep ();
 
           retval = obvp->find_parent_class (parent_class_name);
@@ -920,17 +920,17 @@ octave_class::unique_parent_class (const
   octave_base_value *retval = nullptr;
 
   if (parent_class_name == class_name ())
     retval = this;
   else
     {
       for (auto& par : parent_list)
         {
-          octave_map::iterator smap = map.seek (par);
+          auto smap = map.seek (par);
 
           Cell& tmp = map.contents (smap);
 
           octave_value& vtmp = tmp(0);
 
           octave_base_value *obvp = vtmp.internal_rep ();
 
           // Use find_parent_class first to avoid uniquifying if not necessary.
@@ -956,17 +956,17 @@ octave_class::is_instance_of (const std:
   bool retval = false;
 
   if (cls_name == class_name ())
     retval = true;
   else
     {
       for (auto& par : parent_list)
         {
-          octave_map::const_iterator smap = map.seek (par);
+          auto smap = map.seek (par);
 
           const Cell& tmp = map.contents (smap);
 
           const octave_value& vtmp = tmp(0);
 
           retval = vtmp.is_instance_of (cls_name);
 
           if (retval)
@@ -1038,18 +1038,17 @@ octave_class::print_with_name (std::ostr
 // Loading a class properly requires an exemplar map entry for success.
 // If we don't have one, we attempt to create one by calling the constructor
 // with no arguments.
 bool
 octave_class::reconstruct_exemplar (void)
 {
   bool retval = false;
 
-  octave_class::exemplar_const_iterator it
-    = octave_class::exemplar_map.find (c_name);
+  auto it = octave_class::exemplar_map.find (c_name);
 
   if (it != octave_class::exemplar_map.end ())
     retval = true;
   else
     {
       octave::symbol_table& symtab
         = octave::__get_symbol_table__ ("octave_class::reconstruct_exemplar");
 
@@ -1119,17 +1118,17 @@ octave_class::clear_exemplar_map (void)
 bool
 octave_class::reconstruct_parents (void)
 {
   bool retval = true;
   bool might_have_inheritance = false;
   std::string dbgstr = "dork";
 
   // First, check to see if there might be an issue with inheritance.
-  for (octave_map::const_iterator it = map.begin (); it != map.end (); it++)
+  for (auto it = map.begin (); it != map.end (); it++)
     {
       std::string key = map.key (it);
       Cell        val = map.contents (it);
       if (val(0).isobject ())
         {
           dbgstr = "blork";
           if (key == val(0).class_name ())
             {
@@ -1137,18 +1136,17 @@ octave_class::reconstruct_parents (void)
               dbgstr = "cork";
               break;
             }
         }
     }
 
   if (might_have_inheritance)
     {
-      octave_class::exemplar_const_iterator it
-        = octave_class::exemplar_map.find (c_name);
+      auto it = octave_class::exemplar_map.find (c_name);
 
       if (it == octave_class::exemplar_map.end ())
         retval = false;
       else
         {
           octave_class::exemplar_info exmplr = it->second;
           parent_list = exmplr.parents ();
           for (auto& par : parent_list)
@@ -1182,17 +1180,17 @@ octave_class::save_ascii (std::ostream& 
 
       m = tmp(0).map_value ();
     }
   else
     m = map_value ();
 
   os << "# length: " << m.nfields () << "\n";
 
-  octave_map::iterator i = m.begin ();
+  auto i = m.begin ();
   while (i != m.end ())
     {
       octave_value val = map.contents (i);
 
       bool b = save_text_data (os, val, m.key (i), false, 0);
 
       if (! b)
         return ! os.fail ();
@@ -1288,17 +1286,17 @@ octave_class::save_binary (std::ostream&
       m = tmp(0).map_value ();
     }
   else
     m = map_value ();
 
   int32_t len = m.nfields ();
   os.write (reinterpret_cast<char *> (&len), 4);
 
-  octave_map::iterator i = m.begin ();
+  auto i = m.begin ();
   while (i != m.end ())
     {
       octave_value val = map.contents (i);
 
       bool b = save_binary_data (os, val, m.key (i), "", 0, save_as_floats);
 
       if (! b)
         return ! os.fail ();
@@ -1704,18 +1702,18 @@ octave_class::exemplar_info::compare (co
 
   if (nparents () != obj.nparents ())
     error ("mismatch in number of parent classes");
 
   std::list<std::string> obj_parents
     = obj.parent_class_name_list ();
   std::list<std::string> pnames = parents ();
 
-  std::list<std::string>::const_iterator p = obj_parents.begin ();
-  std::list<std::string>::const_iterator q = pnames.begin ();
+  auto p = obj_parents.begin ();
+  auto q = pnames.begin ();
 
   while (p != obj_parents.end ())
     {
       if (*p++ != *q++)
         error ("mismatch in parent classes");
     }
 
   return true;
@@ -1767,18 +1765,17 @@ is derived.
           = octave_value (new octave_class (m, id, std::list<std::string> ()));
       else
         {
           octave_value_list parents = args.slice (2, nargin-2);
 
           retval = octave_value (new octave_class (m, id, parents));
         }
 
-      octave_class::exemplar_const_iterator it
-        = octave_class::exemplar_map.find (id);
+      auto it = octave_class::exemplar_map.find (id);
 
       if (it == octave_class::exemplar_map.end ())
         octave_class::exemplar_map[id] = octave_class::exemplar_info (retval);
       else if (! it->second.compare (retval))
         error ("class: object of class '%s' does not match previously constructed objects",
                id.c_str ());
     }
 
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -1325,17 +1325,17 @@ cdef_object_scalar::subsref (const std::
             int _nargout = (type.length () > 2 ? 1 : nargout);
 
             octave_value_list args;
 
             skip = 1;
 
             if (type.length () > 1 && type[1] == '(')
               {
-                std::list<octave_value_list>::const_iterator it = idx.begin ();
+                auto it = idx.begin ();
 
                 args = *++it;
 
                 skip++;
               }
 
             if (meth.is_static ())
               retval = meth.execute (args, _nargout, true, "subsref");
@@ -1875,17 +1875,17 @@ cdef_class::cdef_class_rep::cdef_class_r
 {
   put ("SuperClasses", to_ov (superclasses));
   implicit_ctor_list = superclasses;
 }
 
 cdef_method
 cdef_class::cdef_class_rep::find_method (const std::string& nm, bool local)
 {
-  method_iterator it = method_map.find (nm);
+  auto it = method_map.find (nm);
 
   if (it == method_map.end ())
     {
       // FIXME: look into class directory
     }
   else
     {
       cdef_method& meth = it->second;
@@ -2149,17 +2149,17 @@ cdef_class::cdef_class_rep::find_methods
 
       cls.get_rep ()->find_methods (meths, true);
     }
 }
 
 cdef_property
 cdef_class::cdef_class_rep::find_property (const std::string& nm)
 {
-  property_iterator it = property_map.find (nm);
+  auto it = property_map.find (nm);
 
   if (it != property_map.end ())
     {
       cdef_property& prop = it->second;
 
       if (prop.ok ())
         return prop;
     }
@@ -2320,17 +2320,17 @@ cdef_class::cdef_class_rep::get_names (v
   string_vector v (names);
 
   return v.sort (true);
 }
 
 void
 cdef_class::cdef_class_rep::delete_object (cdef_object obj)
 {
-  method_iterator it = method_map.find ("delete");
+  auto it = method_map.find ("delete");
 
   if (it != method_map.end ())
     {
       cdef_class cls = obj.get_class ();
 
       obj.set_class (wrap ());
 
       it->second.execute (obj, octave_value_list (), 0, false);
@@ -2896,28 +2896,26 @@ cdef_class::make_meta_class (octave::int
                   for (auto& attrnm_val : amap)
                     prop.put (attrnm_val.first, attrnm_val.second);
 
                   // Install property access methods, if any.  Remove the
                   // accessor methods from the temporary storage map, so we can
                   // detect which ones are invalid and do not correspond to a
                   // defined property.
 
-                  std::map<std::string, octave_value>::iterator git =
-                    get_methods.find (prop_name);
+                  auto git = get_methods.find (prop_name);
 
                   if (git != get_methods.end ())
                     {
                       make_function_of_class (retval, git->second);
                       prop.put ("GetMethod", git->second);
                       get_methods.erase (git);
                     }
 
-                  std::map<std::string, octave_value>::iterator sit =
-                    set_methods.find (prop_name);
+                  auto sit = set_methods.find (prop_name);
 
                   if (sit != set_methods.end ())
                     {
                       make_function_of_class (retval, sit->second);
                       prop.put ("SetMethod", sit->second);
                       set_methods.erase (sit);
                     }
 
@@ -3335,18 +3333,17 @@ cdef_package::cdef_package_rep::install_
 
 template <typename T1, typename T2>
 Cell
 map2Cell (const std::map<T1, T2>& m)
 {
   Cell retval (1, m.size ());
   int i = 0;
 
-  for (typename std::map<T1, T2>::const_iterator it = m.begin ();
-       it != m.end (); ++it, ++i)
+  for (auto it = m.begin (); it != m.end (); ++it, ++i)
     {
       retval(i) = to_ov (it->second);
     }
 
   return retval;
 }
 
 Cell
@@ -3761,17 +3758,17 @@ cdef_manager::cdef_manager (octave::inte
 //    ("meta.dynproperty",
 //     octave_value (tmp_meta_dynproperty.get_constructor_function ()));
 }
 
 cdef_class
 cdef_manager::find_class (const std::string& name, bool error_if_not_found,
                           bool load_if_not_found)
 {
-  std::map<std::string, cdef_class>::iterator it = m_all_classes.find (name);
+  auto it = m_all_classes.find (name);
 
   if (it == m_all_classes.end ())
     {
       if (load_if_not_found)
         {
           octave_value ov_cls;
 
           size_t pos = name.rfind ('.');
@@ -3839,18 +3836,17 @@ cdef_manager::find_method_symbol (const 
 }
 
 cdef_package
 cdef_manager::find_package (const std::string& name, bool error_if_not_found,
                             bool load_if_not_found)
 {
   cdef_package retval;
 
-  std::map<std::string, cdef_package>::const_iterator it
-    = m_all_packages.find (name);
+  auto it = m_all_packages.find (name);
 
   if (it != m_all_packages.end ())
     {
       retval = it->second;
 
       if (! retval.ok ())
         error ("invalid package `%s'", name.c_str ());
     }
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -155,29 +155,29 @@ octave_fcn_handle::call (int nargout, co
       // Retrieve overload.
       if (btyp != btyp_unknown)
         {
           octave::out_of_date_check (builtin_overloads[btyp], dispatch_type, false);
           ov_fcn = builtin_overloads[btyp];
         }
       else
         {
-          str_ov_map::iterator it = overloads.find (dispatch_type);
+          auto it = overloads.find (dispatch_type);
 
           if (it == overloads.end ())
             {
               // Try parent classes too.
 
               octave::symbol_table& symtab
                 = octave::__get_symbol_table__ ("octave_fcn_handle::call");
 
               std::list<std::string> plist
                 = symtab.parent_classes (dispatch_type);
 
-              std::list<std::string>::const_iterator pit = plist.begin ();
+              auto pit = plist.begin ();
 
               while (pit != plist.end ())
                 {
                   std::string pname = *pit;
 
                   std::string fnm = fcn_name ();
 
                   octave_value ftmp = symtab.find_method (fnm, pname);
@@ -235,18 +235,18 @@ octave_fcn_handle::is_equal_to (const oc
   bool retval = fcn.is_copy_of (h.fcn) && (has_overloads == h.has_overloads);
   retval = retval && (overloads.size () == h.overloads.size ());
 
   if (retval && has_overloads)
     {
       for (int i = 0; i < btyp_num_types && retval; i++)
         retval = builtin_overloads[i].is_copy_of (h.builtin_overloads[i]);
 
-      str_ov_map::const_iterator iter = overloads.begin ();
-      str_ov_map::const_iterator hiter = h.overloads.begin ();
+      auto iter = overloads.begin ();
+      auto hiter = h.overloads.begin ();
       for (; iter != overloads.end () && retval; iter++, hiter++)
         retval = (iter->first == hiter->first)
                  && (iter->second.is_copy_of (hiter->second));
     }
 
   return retval;
 }
 
@@ -2006,17 +2006,17 @@ octave_fcn_binder::maybe_binder (const o
               bool bad = false;
               int nargs = arg_list->length ();
               octave_value_list arg_template (nargs);
               std::vector<int> arg_mask (nargs);
 
               // Verify that each argument is either a named param, a constant,
               // or a defined identifier.
               int iarg = 0;
-              for (octave::tree_argument_list::iterator it = arg_list->begin ();
+              for (auto it = arg_list->begin ();
                    it != arg_list->end (); ++it, ++iarg)
                 {
                   octave::tree_expression *elt = *it;
                   if (elt && elt->is_constant ())
                     {
                       arg_template(iarg) = tw->evaluate (elt);
                       arg_mask[iarg] = -1;
                     }
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -1426,17 +1426,17 @@ box (JNIEnv *jni_env, void *jobj_arg, vo
             }
         }
 
       cls = find_octave_class (jni_env, "org/octave/OctaveReference");
       if (jni_env->IsInstanceOf (jobj, cls))
         {
           jmethodID mID = jni_env->GetMethodID (cls, "getID", "()I");
           int ID = jni_env->CallIntMethod (jobj, mID);
-          std::map<int,octave_value>::iterator it = octave_ref_map.find (ID);
+          auto it = octave_ref_map.find (ID);
 
           if (it != octave_ref_map.end ())
             retval = it->second;
           break;
         }
 
       // No suitable class found.  Return a generic octave_java object.
       retval = octave_value (new octave_java (jobj, jcls));
@@ -1916,17 +1916,17 @@ Java_org_octave_OctaveReference_doFinali
 {
   octave_ref_map.erase (ID);
 }
 
 JNIEXPORT void JNICALL
 Java_org_octave_Octave_doInvoke (JNIEnv *env, jclass, jint ID,
                                  jobjectArray args)
 {
-  std::map<int,octave_value>::iterator it = octave_ref_map.find (ID);
+  auto it = octave_ref_map.find (ID);
 
   if (it != octave_ref_map.end ())
     {
       octave_value val = it->second;
       int len = env->GetArrayLength (args);
       octave_value_list oct_args;
 
       for (int i = 0; i < len; i++)
@@ -2062,17 +2062,17 @@ octave_java::subsref (const std::string&
     {
     case '.':
       if (type.length () > 1 && type[1] == '(')
         {
           octave_value_list ovl;
           count++;
           ovl(1) = octave_value (this);
           ovl(0) = (idx.front ())(0);
-          std::list<octave_value_list>::const_iterator it = idx.begin ();
+          auto it = idx.begin ();
           ovl.append (*++it);
           retval = FjavaMethod (ovl, 1);
           skip++;
         }
       else
         {
           octave_value_list ovl;
           count++;
@@ -2137,17 +2137,17 @@ octave_java::subsasgn (const std::string
           F__java_set__ (ovl);
 
           count++;
           retval = octave_value (this);
         }
       else if (type.length () > 2 && type[1] == '(')
         {
           std::list<octave_value_list> new_idx;
-          std::list<octave_value_list>::const_iterator it = idx.begin ();
+          auto it = idx.begin ();
           new_idx.push_back (*it++);
           new_idx.push_back (*it++);
           octave_value_list u = subsref (type.substr (0, 2), new_idx, 1);
 
           std::list<octave_value_list> next_idx (idx);
           next_idx.erase (next_idx.begin ());
           next_idx.erase (next_idx.begin ());
           u(0).subsasgn (type.substr (2), next_idx, rhs);
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -74,17 +74,17 @@ Cell
 octave_struct::dotref (const octave_value_list& idx, bool auto_add)
 {
   Cell retval;
 
   assert (idx.length () == 1);
 
   std::string nm = idx(0).string_value ();
 
-  octave_map::const_iterator p = map.seek (nm);
+  auto p = map.seek (nm);
 
   if (p != map.end ())
     retval = map.contents (p);
   else if (auto_add)
     retval = (isempty ()) ? Cell (dim_vector (1, 1)) : Cell (dims ());
   else
     error_with_id ("Octave:invalid-indexing",
                    "structure has no member '%s'", nm.c_str ());
@@ -130,17 +130,17 @@ octave_struct::subsref (const std::strin
   int skip = 1;
 
   switch (type[0])
     {
     case '(':
       {
         if (type.length () > 1 && type[1] == '.')
           {
-            std::list<octave_value_list>::const_iterator p = idx.begin ();
+            auto p = idx.begin ();
             octave_value_list key_idx = *++p;
 
             const Cell tmp = dotref (key_idx);
 
             const Cell t = tmp.index (idx.front ());
 
             retval(0) = (t.numel () == 1) ? t(0) : octave_value (t, true);
 
@@ -193,17 +193,17 @@ octave_struct::subsref (const std::strin
   int skip = 1;
 
   switch (type[0])
     {
     case '(':
       {
         if (type.length () > 1 && type[1] == '.')
           {
-            std::list<octave_value_list>::const_iterator p = idx.begin ();
+            auto p = idx.begin ();
             octave_value_list key_idx = *++p;
 
             const Cell tmp = dotref (key_idx, auto_add);
 
             const Cell t = tmp.index (idx.front (), auto_add);
 
             retval = (t.numel () == 1) ? t(0) : octave_value (t, true);
 
@@ -286,17 +286,17 @@ octave_struct::subsasgn (const std::stri
   if (n > 1 && ! (type.length () == 2 && type[0] == '(' && type[1] == '.'))
     {
       switch (type[0])
         {
         case '(':
           {
             if (type.length () > 1 && type[1] == '.')
               {
-                std::list<octave_value_list>::const_iterator p = idx.begin ();
+                auto p = idx.begin ();
                 octave_value_list t_idx = *p;
 
                 octave_value_list key_idx = *++p;
 
                 assert (key_idx.length () == 1);
 
                 std::string key = key_idx(0).string_value ();
 
@@ -308,17 +308,17 @@ octave_struct::subsasgn (const std::stri
                 // needs to skip both of them.
 
                 next_idx.erase (next_idx.begin ());
                 next_idx.erase (next_idx.begin ());
 
                 std::string next_type = type.substr (2);
 
                 Cell tmpc (1, 1);
-                octave_map::iterator pkey = map.seek (key);
+                auto pkey = map.seek (key);
                 if (pkey != map.end ())
                   {
                     map.contents (pkey).make_unique ();
                     tmpc = map.contents (pkey).index (idx.front (), true);
                   }
 
                 // FIXME: better code reuse?
                 //        cf. octave_cell::subsasgn and the case below.
@@ -360,17 +360,17 @@ octave_struct::subsasgn (const std::stri
 
             std::list<octave_value_list> next_idx (idx);
 
             next_idx.erase (next_idx.begin ());
 
             std::string next_type = type.substr (1);
 
             Cell tmpc (1, 1);
-            octave_map::iterator pkey = map.seek (key);
+            auto pkey = map.seek (key);
             if (pkey != map.end ())
               {
                 map.contents (pkey).make_unique ();
                 tmpc = map.contents (pkey);
               }
 
             // FIXME: better code reuse?
 
@@ -409,17 +409,17 @@ octave_struct::subsasgn (const std::stri
     }
 
   switch (type[0])
     {
     case '(':
       {
         if (n > 1 && type[1] == '.')
           {
-            std::list<octave_value_list>::const_iterator p = idx.begin ();
+            auto p = idx.begin ();
             octave_value_list key_idx = *++p;
             octave_value_list idxf = idx.front ();
 
             assert (key_idx.length () == 1);
 
             std::string key = key_idx(0).string_value ();
 
             maybe_warn_invalid_field_name (key, "subsasgn");
@@ -545,17 +545,17 @@ octave_struct::do_index_op (const octave
 
 size_t
 octave_struct::byte_size (void) const
 {
   // Neglect the size of the fieldnames.
 
   size_t retval = 0;
 
-  for (octave_map::const_iterator p = map.begin (); p != map.end (); p++)
+  for (auto p = map.begin (); p != map.end (); p++)
     {
       std::string key = map.key (p);
 
       octave_value val = octave_value (map.contents (p));
 
       retval += val.byte_size ();
     }
 
@@ -1207,17 +1207,17 @@ octave_scalar_struct::subsasgn (const st
         {
           std::list<octave_value_list> next_idx (idx);
 
           next_idx.erase (next_idx.begin ());
 
           std::string next_type = type.substr (1);
 
           octave_value tmp;
-          octave_map::iterator pkey = map.seek (key);
+          auto pkey = map.seek (key);
           if (pkey != map.end ())
             {
               map.contents (pkey).make_unique ();
               tmp = map.contents (pkey);
             }
 
           bool orig_undefined = tmp.is_undefined ();
 
@@ -1259,17 +1259,17 @@ octave_scalar_struct::do_index_op (const
 
 size_t
 octave_scalar_struct::byte_size (void) const
 {
   // Neglect the size of the fieldnames.
 
   size_t retval = 0;
 
-  for (octave_map::const_iterator p = map.begin (); p != map.end (); p++)
+  for (auto p = map.begin (); p != map.end (); p++)
     {
       std::string key = map.key (p);
 
       octave_value val = octave_value (map.contents (p));
 
       retval += val.byte_size ();
     }
 
diff --git a/libinterp/parse-tree/bp-table.cc b/libinterp/parse-tree/bp-table.cc
--- a/libinterp/parse-tree/bp-table.cc
+++ b/libinterp/parse-tree/bp-table.cc
@@ -567,17 +567,17 @@ namespace octave
     condition_valid (condition);  // Throw error if condition not valid.
 
     intmap retval;
 
     octave_idx_type len = line.size ();
 
     for (int i = 0; i < len; i++)
       {
-        const_intmap_iterator m = line.find (i);
+        auto m = line.find (i);
 
         if (m != line.end ())
           {
             int lineno = m->second;
 
             octave_user_code *dbg_fcn = find_fcn_by_line (main_fcn, lineno);
 
             // We've found the right (sub)function.  Now insert the breakpoint.
@@ -612,32 +612,32 @@ namespace octave
         octave_value_list results = cmds->list_breakpoints ();
 
         if (results.length () > 0)
           {
             octave_idx_type len = line.size ();
 
             for (int i = 0; i < len; i++)
               {
-                const_intmap_iterator p = line.find (i);
+                auto p = line.find (i);
 
                 if (p != line.end ())
                   {
                     int lineno = p->second;
 
                     cmds->delete_breakpoint (lineno);
 
                     if (! file.empty ())
                       octave_link::update_breakpoint (false, file, lineno);
                   }
               }
 
             results = cmds->list_breakpoints ();
 
-            bp_set_iterator it = m_bp_set.find (fname);
+            auto it = m_bp_set.find (fname);
             if (results.empty () && it != m_bp_set.end ())
               m_bp_set.erase (it);
           }
 
         retval = results.length ();
       }
 
     return retval;
@@ -706,36 +706,35 @@ namespace octave
         std::string file = dbg_fcn->fcn_file_name ();
 
         tree_statement_list *cmds = dbg_fcn->body ();
 
         if (cmds)
           {
             retval = cmds->remove_all_breakpoints (file);
 
-            bp_set_iterator it = m_bp_set.find (fname);
+            auto it = m_bp_set.find (fname);
             if (it != m_bp_set.end ())
               m_bp_set.erase (it);
           }
       }
     else if (! silent)
       error ("remove_all_breakpoint_in_file: "
              "unable to find function %s\n", fname.c_str ());
 
     tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
 
     return retval;
   }
 
   void bp_table::remove_all_breakpoints (void)
   {
     // Odd loop structure required because delete will invalidate m_bp_set iterators
-    for (const_bp_set_iterator it = m_bp_set.begin (), it_next = it;
-         it != m_bp_set.end ();
-         it = it_next)
+    for (auto it = m_bp_set.begin (), it_next = it;
+         it != m_bp_set.end (); it = it_next)
       {
         ++it_next;
         remove_all_breakpoints_in_file (*it);
       }
 
     tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
   }
 
diff --git a/libinterp/parse-tree/jit-ir.cc b/libinterp/parse-tree/jit-ir.cc
--- a/libinterp/parse-tree/jit-ir.cc
+++ b/libinterp/parse-tree/jit-ir.cc
@@ -45,17 +45,17 @@ along with Octave; see the file COPYING.
 #include "error.h"
 
 namespace octave
 {
 
   // -------------------- jit_factory --------------------
   jit_factory::~jit_factory (void)
   {
-    for (value_list::iterator iter = m_all_values.begin ();
+    for (auto iter = m_all_values.begin ();
          iter != m_all_values.end (); ++iter)
       delete *iter;
   }
 
   void
   jit_factory::track_value (jit_value *value)
   {
     if (value->type ())
@@ -106,39 +106,38 @@ namespace octave
     os << "-------------------- " << header << " --------------------\n";
     return os << *this;
   }
 
   std::ostream&
   jit_block_list::print_dom (std::ostream& os) const
   {
     os << "-------------------- dom info --------------------\n";
-    for (const_iterator iter = begin (); iter != end (); ++iter)
+    for (auto iter = begin (); iter != end (); ++iter)
       {
         assert (*iter);
         (*iter)->print_dom (os);
       }
     os << std::endl;
 
     return os;
   }
 
   void
   jit_block_list::push_back (jit_block *b)
   {
     m_list.push_back (b);
-    iterator iter = m_list.end ();
+    auto iter = m_list.end ();
     b->stash_location (--iter);
   }
 
   std::ostream&
   operator<<(std::ostream& os, const jit_block_list& blocks)
   {
-    for (jit_block_list::const_iterator iter = blocks.begin ();
-         iter != blocks.end (); ++iter)
+    for (auto iter = blocks.begin (); iter != blocks.end (); ++iter)
       {
         assert (*iter);
         (*iter)->print (os, 0);
       }
     return os << std::endl;
   }
 
   // -------------------- jit_use --------------------
@@ -285,29 +284,29 @@ namespace octave
   jit_block::merge (jit_block& block)
   {
     // the merge block will contain a new terminator
     jit_terminator *old_term = terminator ();
     if (old_term)
       old_term->remove ();
 
     bool was_empty = end () == begin ();
-    iterator merge_begin = end ();
+    auto merge_begin = end ();
     if (! was_empty)
       --merge_begin;
 
     m_instructions.splice (end (), block.m_instructions);
     if (was_empty)
       merge_begin = begin ();
     else
       ++merge_begin;
 
     // now merge_begin points to the start of the new instructions, we must
     // update their parent information
-    for (iterator iter = merge_begin; iter != end (); ++iter)
+    for (auto iter = merge_begin; iter != end (); ++iter)
       {
         jit_instruction *instr = *iter;
         instr->stash_parent (this, iter);
       }
 
     block.replace_with (this);
   }
 
@@ -318,17 +317,17 @@ namespace octave
     instr->stash_parent (this, m_instructions.begin ());
     return instr;
   }
 
   jit_instruction *
   jit_block::prepend_after_phi (jit_instruction *instr)
   {
     // FIXME: Make this O(1)
-    for (iterator iter = begin (); iter != end (); ++iter)
+    for (auto iter = begin (); iter != end (); ++iter)
       {
         jit_instruction *temp = *iter;
         if (! isa<jit_phi> (temp))
           {
             insert_before (iter, instr);
             return instr;
           }
       }
@@ -341,26 +340,26 @@ namespace octave
   {
     m_instructions.push_back (instr);
     instr->stash_parent (this, --m_instructions.end ());
   }
 
   jit_instruction *
   jit_block::insert_before (iterator loc, jit_instruction *instr)
   {
-    iterator iloc = m_instructions.insert (loc, instr);
+    auto iloc = m_instructions.insert (loc, instr);
     instr->stash_parent (this, iloc);
     return instr;
   }
 
   jit_instruction *
   jit_block::insert_after (iterator loc, jit_instruction *instr)
   {
     ++loc;
-    iterator iloc = m_instructions.insert (loc, instr);
+    auto iloc = m_instructions.insert (loc, instr);
     instr->stash_parent (this, iloc);
     return instr;
   }
 
   jit_terminator *
   jit_block::terminator (void) const
   {
     if (m_instructions.empty ())
@@ -414,17 +413,17 @@ namespace octave
 
     os << "  m_idom: ";
     if (m_idom)
       os << *m_idom;
     else
       os << "NULL";
     os << std::endl;
     os << "  df: ";
-    for (df_iterator iter = df_begin (); iter != df_end (); ++iter)
+    for (auto iter = df_begin (); iter != df_end (); ++iter)
       os << **iter << ' ';
     os << std::endl;
 
     os << "  m_dom_succ: ";
     for (size_t i = 0; i < m_dom_succ.size (); ++i)
       os << *m_dom_succ[i] << ' ';
 
     return os << std::endl;
@@ -500,17 +499,17 @@ namespace octave
       }
 
     m_id = number++;
   }
 
   void
   jit_block::pop_all (void)
   {
-    for (iterator iter = begin (); iter != end (); ++iter)
+    for (auto iter = begin (); iter != end (); ++iter)
       {
         jit_instruction *instr = *iter;
         instr->pop_variable ();
       }
   }
 
   std::ostream&
   jit_block::print (std::ostream& os, size_t indent) const
@@ -521,17 +520,17 @@ namespace octave
       {
         jit_block *pred = use->user_parent ();
         os << *pred;
         if (use->next ())
           os << ", ";
       }
     os << std::endl;
 
-    for (const_iterator iter = begin (); iter != end (); ++iter)
+    for (auto iter = begin (); iter != end (); ++iter)
       {
         jit_instruction *instr = *iter;
         instr->print (os, indent + 1) << std::endl;
       }
     return os;
   }
 
   jit_block *
@@ -787,18 +786,18 @@ namespace octave
   { }
 
   jit_magic_end::jit_magic_end (const std::vector<context>& full_context)
     : m_contexts (full_context)
   {
     resize_arguments (m_contexts.size ());
 
     size_t i;
-    std::vector<context>::const_iterator iter;
-    for (iter = m_contexts.begin (), i = 0; iter != m_contexts.end (); ++iter, ++i)
+    for (auto iter = m_contexts.begin (), i = 0;
+         iter != m_contexts.end (); ++iter, ++i)
       stash_argument (i, iter->m_value);
   }
 
   jit_magic_end::context
   jit_magic_end::resolve_context (void) const
   {
     size_t idx;
     for (idx = 0; idx < m_contexts.size (); ++idx)
diff --git a/libinterp/parse-tree/jit-typeinfo.cc b/libinterp/parse-tree/jit-typeinfo.cc
--- a/libinterp/parse-tree/jit-typeinfo.cc
+++ b/libinterp/parse-tree/jit-typeinfo.cc
@@ -581,18 +581,17 @@ namespace octave
         rtype = m_result->packed_type (m_call_conv);
         if (sret ())
           {
             llvm_args.push_back (rtype->getPointerTo ());
             rtype = llvm::Type::getVoidTy (context);
           }
       }
 
-    for (std::vector<jit_type *>::const_iterator iter = m_args.begin ();
-         iter != m_args.end (); ++iter)
+    for (auto iter = m_args.begin (); iter != m_args.end (); ++iter)
       {
         jit_type *ty = *iter;
         assert (ty);
         llvm::Type *argty = ty->packed_type (m_call_conv);
         if (ty->pointer_arg (m_call_conv))
           argty = argty->getPointerTo ();
 
         llvm_args.push_back (argty);
@@ -746,17 +745,17 @@ namespace octave
   llvm::Value *
   jit_function::argument (llvm::IRBuilderD& builder, size_t idx) const
   {
     assert (idx < m_args.size ());
 
     // FIXME: We should be treating arguments like a list, not a vector.
     // Shouldn't matter much for now, as the number of arguments shouldn't
     // be much bigger than 4
-    llvm::Function::arg_iterator iter = m_llvm_function->arg_begin ();
+    auto iter = m_llvm_function->arg_begin ();
     if (sret ())
       ++iter;
 
     for (size_t i = 0; i < idx; ++i, ++iter);
 
     if (m_args[idx]->pointer_arg (m_call_conv))
       return builder.CreateLoad (&*iter);
 
@@ -799,18 +798,17 @@ namespace octave
     lfn->print (llvm_out);
     llvm_out.flush ();
     return os;
   }
 
   // -------------------- jit_operation --------------------
   jit_operation::~jit_operation (void)
   {
-    for (generated_map::iterator iter = m_generated.begin ();
-         iter != m_generated.end (); ++iter)
+    for (auto iter = m_generated.begin (); iter != m_generated.end (); ++iter)
       {
         delete iter->first;
         delete iter->second;
       }
   }
 
   void
   jit_operation::add_overload (const jit_function& func,
@@ -896,17 +894,17 @@ namespace octave
 
     return idx;
   }
 
   const jit_function&
   jit_operation::do_generate (const signature_vec& types) const
   {
     static jit_function null_overload;
-    generated_map::const_iterator find = m_generated.find (&types);
+    auto find = m_generated.find (&types);
     if (find != m_generated.end ())
       {
         if (find->second)
           return *find->second;
         else
           return null_overload;
       }
 
@@ -1970,17 +1968,17 @@ namespace octave
     jit_function grab_any = create_external (JIT_FN (octave_jit_grab_any),
                                              m_any, m_any);
 
     jit_function release_any = m_release_fn.overload (m_any);
 
     std::vector<jit_type *> args;
     args.resize (1);
 
-    for (std::map<std::string, jit_type *>::iterator iter = m_builtins.begin ();
+    for (auto iter = m_builtins.begin ();
          iter != m_builtins.end (); ++iter)
       {
         jit_type *btype = iter->second;
         args[0] = btype;
 
         m_grab_fn.add_overload (jit_function (grab_any, btype, args));
         m_release_fn.add_overload (jit_function (release_any, 0, args));
         m_casts[m_any->type_id ()].add_overload (jit_function (any_id, m_any,
@@ -2030,17 +2028,17 @@ namespace octave
     m_identities.push_back (jit_function ());
 
     return ret;
   }
 
   jit_type*
   jit_typeinfo::do_get_intN (size_t nbits) const
   {
-    std::map<size_t, jit_type *>::const_iterator iter = m_ints.find (nbits);
+    auto iter = m_ints.find (nbits);
     if (iter != m_ints.end ())
       return iter->second;
 
     throw jit_fail_exception ("No such integer type");
   }
 
   const jit_function&
   jit_typeinfo::do_end (jit_value *value, jit_value *idx, jit_value *count)
diff --git a/libinterp/parse-tree/pt-arg-list.cc b/libinterp/parse-tree/pt-arg-list.cc
--- a/libinterp/parse-tree/pt-arg-list.cc
+++ b/libinterp/parse-tree/pt-arg-list.cc
@@ -48,17 +48,17 @@ along with Octave; see the file COPYING.
 namespace octave
 {
   // Argument lists.
 
   tree_argument_list::~tree_argument_list (void)
   {
     while (! empty ())
       {
-        iterator p = begin ();
+        auto p = begin ();
         delete *p;
         erase (p);
       }
   }
 
   bool
   tree_argument_list::has_magic_end (void) const
   {
@@ -226,17 +226,17 @@ namespace octave
 
         indexed_object = object;
       }
 
     int len = length ();
 
     std::list<octave_value_list> args;
 
-    iterator p = begin ();
+    auto p = begin ();
     for (int k = 0; k < len; k++)
       {
         if (stash_object)
           {
             frame.protect_var (index_position);
             frame.protect_var (num_indices);
 
             index_position = k;
diff --git a/libinterp/parse-tree/pt-arg-list.h b/libinterp/parse-tree/pt-arg-list.h
--- a/libinterp/parse-tree/pt-arg-list.h
+++ b/libinterp/parse-tree/pt-arg-list.h
@@ -69,17 +69,17 @@ namespace octave
 
     bool has_magic_end (void) const;
 
     bool has_magic_tilde (void) const
     { return m_list_includes_magic_tilde; }
 
     tree_expression * remove_front (void)
     {
-      iterator p = begin ();
+      auto p = begin ();
       tree_expression *retval = *p;
       erase (p);
       return retval;
     }
 
     void append (const element_type& s);
 
     void mark_as_simple_assign_lhs (void) { m_simple_assign_lhs = true; }
diff --git a/libinterp/parse-tree/pt-array-list.cc b/libinterp/parse-tree/pt-array-list.cc
--- a/libinterp/parse-tree/pt-array-list.cc
+++ b/libinterp/parse-tree/pt-array-list.cc
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include "pt-array-list.h"
 
 namespace octave
 {
   tree_array_list::~tree_array_list (void)
   {
     while (! empty ())
       {
-        iterator p = begin ();
+        auto p = begin ();
         delete *p;
         erase (p);
       }
   }
 
   bool
   tree_array_list::all_elements_are_constant (void) const
   {
diff --git a/libinterp/parse-tree/pt-check.cc b/libinterp/parse-tree/pt-check.cc
--- a/libinterp/parse-tree/pt-check.cc
+++ b/libinterp/parse-tree/pt-check.cc
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 #include "ov-usr-fcn.h"
 #include "pt-all.h"
 
 namespace octave
 {
   void
   tree_checker::visit_argument_list (tree_argument_list& lst)
   {
-    tree_argument_list::iterator p = lst.begin ();
+    auto p = lst.begin ();
 
     while (p != lst.end ())
       {
         tree_expression *elt = *p++;
 
         if (elt)
           {
             if (m_do_lvalue_check && ! elt->lvalue_ok ())
@@ -96,17 +96,17 @@ namespace octave
 
     if (init_list)
       init_list->accept (*this);
   }
 
   void
   tree_checker::visit_decl_init_list (tree_decl_init_list& lst)
   {
-    tree_decl_init_list::iterator p = lst.begin ();
+    auto p = lst.begin ();
 
     while (p != lst.end ())
       {
         tree_decl_elt *elt = *p++;
 
         if (elt)
           elt->accept (*this);
       }
@@ -238,17 +238,17 @@ namespace octave
 
     if (list)
       list->accept (*this);
   }
 
   void
   tree_checker::visit_if_command_list (tree_if_command_list& lst)
   {
-    tree_if_command_list::iterator p = lst.begin ();
+    auto p = lst.begin ();
 
     while (p != lst.end ())
       {
         tree_if_clause *elt = *p++;
 
         if (elt)
           elt->accept (*this);
       }
@@ -259,45 +259,45 @@ namespace octave
   {
     tree_expression *e = expr.expression ();
 
     if (e)
       e->accept (*this);
 
     std::list<tree_argument_list *> lst = expr.arg_lists ();
 
-    std::list<tree_argument_list *>::iterator p = lst.begin ();
+    auto p = lst.begin ();
 
     while (p != lst.end ())
       {
         tree_argument_list *elt = *p++;
 
         if (elt)
           elt->accept (*this);
       }
   }
 
   void
   tree_checker::visit_matrix (tree_matrix& lst)
   {
-    tree_matrix::iterator p = lst.begin ();
+    auto p = lst.begin ();
 
     while (p != lst.end ())
       {
         tree_argument_list *elt = *p++;
 
         if (elt)
           elt->accept (*this);
       }
   }
 
   void
   tree_checker::visit_cell (tree_cell& lst)
   {
-    tree_matrix::iterator p = lst.begin ();
+    auto p = lst.begin ();
 
     while (p != lst.end ())
       {
         tree_argument_list *elt = *p++;
 
         if (elt)
           elt->accept (*this);
       }
@@ -341,17 +341,17 @@ namespace octave
 
   void
   tree_checker::visit_funcall (tree_funcall& /* fc */)
   { }
 
   void
   tree_checker::visit_parameter_list (tree_parameter_list& lst)
   {
-    tree_parameter_list::iterator p = lst.begin ();
+    auto p = lst.begin ();
 
     while (p != lst.end ())
       {
         tree_decl_elt *elt = *p++;
 
         if (elt)
           elt->accept (*this);
       }
@@ -377,17 +377,17 @@ namespace octave
 
   void
   tree_checker::visit_return_command (tree_return_command&)
   { }
 
   void
   tree_checker::visit_return_list (tree_return_list& lst)
   {
-    tree_return_list::iterator p = lst.begin ();
+    auto p = lst.begin ();
 
     while (p != lst.end ())
       {
         tree_index_expression *elt = *p++;
 
         if (elt)
           elt->accept (*this);
       }
@@ -448,17 +448,17 @@ namespace octave
 
     if (list)
       list->accept (*this);
   }
 
   void
   tree_checker::visit_switch_case_list (tree_switch_case_list& lst)
   {
-    tree_switch_case_list::iterator p = lst.begin ();
+    auto p = lst.begin ();
 
     while (p != lst.end ())
       {
         tree_switch_case *elt = *p++;
 
         if (elt)
           elt->accept (*this);
       }
diff --git a/libinterp/parse-tree/pt-classdef.cc b/libinterp/parse-tree/pt-classdef.cc
--- a/libinterp/parse-tree/pt-classdef.cc
+++ b/libinterp/parse-tree/pt-classdef.cc
@@ -32,45 +32,45 @@ namespace octave
   // Classdef attribute
 
   // Classdef attribute_list
 
   tree_classdef_attribute_list::~tree_classdef_attribute_list (void)
   {
     while (! empty ())
       {
-        iterator p = begin ();
+        auto p = begin ();
         delete *p;
         erase (p);
       }
   }
 
   // Classdef superclass
 
   // Classdef superclass_list
 
   tree_classdef_superclass_list::~tree_classdef_superclass_list (void)
   {
     while (! empty ())
       {
-        iterator p = begin ();
+        auto p = begin ();
         delete *p;
         erase (p);
       }
   }
 
   // Classdef property
 
   // Classdef property_list
 
   tree_classdef_property_list::~tree_classdef_property_list (void)
   {
     while (! empty ())
       {
-        iterator p = begin ();
+        auto p = begin ();
         delete *p;
         erase (p);
       }
   }
 
   // Classdef properties_block
 
   // Classdef methods_list
@@ -80,68 +80,68 @@ namespace octave
   // Classdef event
 
   // Classdef events_list
 
   tree_classdef_events_list::~tree_classdef_events_list (void)
   {
     while (! empty ())
       {
-        iterator p = begin ();
+        auto p = begin ();
         delete *p;
         erase (p);
       }
   }
 
   // Classdef events_block
 
   // Classdef enum
 
   // Classdef enum_list
 
   tree_classdef_enum_list::~tree_classdef_enum_list (void)
   {
     while (! empty ())
       {
-        iterator p = begin ();
+        auto p = begin ();
         delete *p;
         erase (p);
       }
   }
 
   // Classdef enum_block
 
   // Classdef body
 
   tree_classdef_body::~tree_classdef_body (void)
   {
     while (! m_properties_lst.empty ())
       {
-        properties_list_iterator p = m_properties_lst.begin ();
+        auto p = m_properties_lst.begin ();
         delete *p;
         m_properties_lst.erase (p);
       }
 
     while (! m_methods_lst.empty ())
       {
-        methods_list_iterator p = m_methods_lst.begin ();
+        auto p = m_methods_lst.begin ();
         delete *p;
         m_methods_lst.erase (p);
       }
 
     while (! m_events_lst.empty ())
       {
-        events_list_iterator p = m_events_lst.begin ();
+        auto p = m_events_lst.begin ();
         delete *p;
         m_events_lst.erase (p);
       }
 
     while (! m_enum_lst.empty ())
       {
-        enum_list_iterator p = m_enum_lst.begin ();
+        auto p = m_enum_lst.begin ();
         delete *p;
         m_enum_lst.erase (p);
       }
   }
 
   // Classdef
 
   octave_function*
diff --git a/libinterp/parse-tree/pt-decl.h b/libinterp/parse-tree/pt-decl.h
--- a/libinterp/parse-tree/pt-decl.h
+++ b/libinterp/parse-tree/pt-decl.h
@@ -132,17 +132,17 @@ namespace octave
     tree_decl_init_list (const tree_decl_init_list&) = delete;
 
     tree_decl_init_list& operator = (const tree_decl_init_list&) = delete;
 
     ~tree_decl_init_list (void)
     {
       while (! empty ())
         {
-          iterator p = begin ();
+          auto p = begin ();
           delete *p;
           erase (p);
         }
     }
 
     void mark_global (void)
     {
       for (tree_decl_elt *elt : *this)
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -946,17 +946,17 @@ namespace octave
       error ("in statement 'for [X, Y] = VAL', VAL must be a structure");
 
     // Cycle through structure elements.  First element of id_list
     // is set to value and the second is set to the name of the
     // structure element.
 
     tree_argument_list *lhs = cmd.left_hand_side ();
 
-    tree_argument_list::iterator p = lhs->begin ();
+    auto p = lhs->begin ();
 
     tree_expression *elt = *p++;
 
     octave_lvalue val_ref = elt->lvalue (this);
 
     elt = *p;
 
     octave_lvalue key_ref = elt->lvalue (this);
@@ -1274,19 +1274,19 @@ namespace octave
 
     std::string type = idx_expr.type_tags ();
     std::list<tree_argument_list *> args = idx_expr.arg_lists ();
     std::list<string_vector> arg_nm = idx_expr.arg_names ();
     std::list<tree_expression *> dyn_field = idx_expr.dyn_fields ();
 
     assert (! args.empty ());
 
-    std::list<tree_argument_list *>::iterator p_args = args.begin ();
-    std::list<string_vector>::iterator p_arg_nm = arg_nm.begin ();
-    std::list<tree_expression *>::iterator p_dyn_field = dyn_field.begin ();
+    auto p_args = args.begin ();
+    auto p_arg_nm = arg_nm.begin ();
+    auto p_dyn_field = dyn_field.begin ();
 
     int n = args.size ();
     int beg = 0;
 
     octave_value base_expr_val;
 
     tree_expression *expr = idx_expr.expression ();
 
@@ -1844,17 +1844,17 @@ namespace octave
         octave_idx_type k = 0;
 
         octave_idx_type n = rhs_val.length ();
 
         // To avoid copying per elements and possible optimizations, we
         // postpone joining the final values.
         std::list<octave_value_list> retval_list;
 
-        tree_argument_list::iterator q = lhs->begin ();
+        auto q = lhs->begin ();
 
         for (octave_lvalue ult : lvalue_list)
           {
             tree_expression *lhs_elt = *q++;
 
             octave_idx_type nel = ult.numel ();
 
             if (nel != 1)
@@ -2339,17 +2339,17 @@ namespace octave
   }
 
   void
   tree_evaluator::visit_statement_list (tree_statement_list& lst)
   {
     // FIXME: commented out along with else clause below.
     // static octave_value_list empty_list;
 
-    tree_statement_list::iterator p = lst.begin ();
+    auto p = lst.begin ();
 
     if (p != lst.end ())
       {
         while (true)
           {
             tree_statement *elt = *p++;
 
             if (! elt)
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -105,24 +105,24 @@ namespace octave
   }
 
   tree_index_expression::~tree_index_expression (void)
   {
     delete m_expr;
 
     while (! m_args.empty ())
       {
-        std::list<tree_argument_list *>::iterator p = m_args.begin ();
+        auto p = m_args.begin ();
         delete *p;
         m_args.erase (p);
       }
 
     while (! m_dyn_field.empty ())
       {
-        std::list<tree_expression *>::iterator p = m_dyn_field.begin ();
+        auto p = m_dyn_field.begin ();
         delete *p;
         m_dyn_field.erase (p);
       }
   }
 
   bool
   tree_index_expression::has_magic_end (void) const
   {
@@ -235,19 +235,19 @@ namespace octave
   {
     octave_lvalue retval;
 
     std::list<octave_value_list> idx;
     std::string tmp_type;
 
     int n = m_args.size ();
 
-    std::list<tree_argument_list *>::iterator p_args = m_args.begin ();
-    std::list<string_vector>::iterator p_arg_nm = m_arg_nm.begin ();
-    std::list<tree_expression *>::iterator p_dyn_field = m_dyn_field.begin ();
+    auto p_args = m_args.begin ();
+    auto p_arg_nm = m_arg_nm.begin ();
+    auto p_dyn_field = m_dyn_field.begin ();
 
     retval = m_expr->lvalue (tw);
 
     octave_value tmp = retval.value ();
 
     octave_idx_type tmpi = 0;
     std::list<octave_value_list> tmpidx;
 
diff --git a/libinterp/parse-tree/pt-jit.cc b/libinterp/parse-tree/pt-jit.cc
--- a/libinterp/parse-tree/pt-jit.cc
+++ b/libinterp/parse-tree/pt-jit.cc
@@ -151,18 +151,17 @@ namespace octave
 
     // breaks must have been handled by the top level loop
     assert (m_breaks.empty ());
     assert (m_continues.empty ());
 
     m_block->append (m_factory.create<jit_branch> (m_final_block));
     m_blocks.push_back (m_final_block);
 
-    for (variable_map::iterator iter = m_vmap.begin (); iter != m_vmap.end ();
-         ++iter)
+    for (auto iter = m_vmap.begin (); iter != m_vmap.end (); ++iter)
       {
         jit_variable *var = iter->second;
         const std::string& name = var->name ();
         if (name.size () && name[0] != '#')
           m_final_block->append (m_factory.create<jit_store_argument> (var));
       }
 
     m_final_block->append (m_factory.create<jit_return> ());
@@ -179,17 +178,17 @@ namespace octave
     if (plist && plist->takes_varargs ())
       throw jit_fail_exception ("varags not supported");
 
     if (rlist && (rlist->size () > 1 || rlist->takes_varargs ()))
       throw jit_fail_exception ("multiple returns not supported");
 
     if (plist)
       {
-        tree_parameter_list::iterator piter = plist->begin ();
+        auto piter = plist->begin ();
         for (size_t i = 0; i < args.size (); ++i, ++piter)
           {
             if (piter == plist->end ())
               throw jit_fail_exception ("Too many parameter to function");
 
             tree_decl_elt *elt = *piter;
             std::string name = elt->name ();
             create_variable (name, args[i]);
@@ -245,17 +244,17 @@ namespace octave
     if (! return_value && rlist && rlist->size () == 1)
       {
         tree_decl_elt *elt = rlist->front ();
         return_value = get_variable (elt->name ());
       }
 
     // FIXME: We should use live range analysis to delete variables where
     // needed.  For now we just delete everything at the end of the function.
-    for (variable_map::iterator iter = m_vmap.begin ();
+    for (auto iter = m_vmap.begin ();
          iter != m_vmap.end ();
          ++iter)
       {
         if (iter->second != return_value)
           {
             jit_call *call;
             call = m_factory.create<jit_call> (&jit_typeinfo::destroy,
                                                iter->second);
@@ -570,17 +569,17 @@ namespace octave
 
     // entry_blocks represents the block you need to enter in order to execute
     // the condition check for the ith clause.  For the else, it is simple the
     // else body.  If there is no else body, then it is padded with the tail.
     std::vector<jit_block *> entry_blocks (lst.size () + 1 - last_else);
     entry_blocks[0] = m_block;
 
     // Need to construct blocks first, because they have jumps to each other.
-    tree_if_command_list::iterator iter = lst.begin ();
+    auto iter = lst.begin ();
     ++iter;
     for (size_t i = 1; iter != lst.end (); ++iter, ++i)
       {
         tree_if_clause *tic = *iter;
         if (tic->is_else_clause ())
           entry_blocks[i] = m_factory.create<jit_block> ("else");
         else
           entry_blocks[i] = m_factory.create<jit_block> ("ifelse_cond");
@@ -827,18 +826,17 @@ namespace octave
                                                          expr_result));
           }
       }
   }
 
   void
   jit_convert::visit_statement_list (tree_statement_list& lst)
   {
-    for (tree_statement_list::iterator iter = lst.begin (); iter != lst.end();
-         ++iter)
+    for (auto iter = lst.begin (); iter != lst.end(); ++iter)
       {
         tree_statement *elt = *iter;
         // jwe: Can this ever be null?
         assert (elt);
         elt->accept (*this);
       }
   }
 
@@ -894,17 +892,17 @@ namespace octave
     // each branch in the case statement will have different breaks/continues
     block_list current_breaks = m_breaks;
     block_list current_continues = m_continues;
     m_breaks.clear ();
     m_continues.clear ();
 
     size_t num_incoming = 0; // number of incoming blocks to our tail
 
-    tree_switch_case_list::iterator iter = lst->begin ();
+    auto iter = lst->begin ();
     for (size_t i = 0; i < case_blocks_num; ++iter, ++i)
       {
         tree_switch_case *twc = *iter;
         m_block = entry_blocks[i]; // case_cond
         assert (m_block);
 
         if (i)
           m_blocks.push_back (entry_blocks[i]);  // first block already pushed
@@ -1229,17 +1227,17 @@ namespace octave
         if (! id)
           throw jit_fail_exception ("expected identifier");
         object = get_variable (id->name ());
       }
     else
       object = visit (tree_object);
 
     size_t narg = arg_list->size ();
-    tree_argument_list::iterator iter = arg_list->begin ();
+    auto iter = arg_list->begin ();
     bool have_extra = extra_arg;
     std::vector<jit_value *> call_args (narg + 1 + have_extra);
     call_args[0] = object;
 
     for (size_t idx = 0; iter != arg_list->end (); ++idx, ++iter)
       {
         unwind_protect frame;
         frame.add_method (&m_end_context,
@@ -1310,18 +1308,17 @@ namespace octave
 
     tee.accept (*this);
     return m_result;
   }
 
   void
   jit_convert::finish_breaks (jit_block *dest, const block_list& lst)
   {
-    for (block_list::const_iterator iter = lst.begin (); iter != lst.end ();
-         ++iter)
+    for (auto iter = lst.begin (); iter != lst.end (); ++iter)
       {
         jit_block *b = *iter;
         b->append (m_factory.create<jit_branch> (dest));
       }
   }
 
   // -------------------- jit_convert_llvm --------------------
   llvm::Function *
@@ -1330,19 +1327,18 @@ namespace octave
                                   const std::list<jit_value *>& constants,
                                   const std::string& llvm_function_name)
   {
     m_converting_function = false;
 
     // for now just init arguments from entry, later we will have to do
     // something more interesting
     jit_block *m_entry_block = blocks.front ();
-    for (jit_block::iterator iter = m_entry_block->begin ();
-         iter != m_entry_block->end ();
-         ++iter)
+    for (auto iter = m_entry_block->begin ();
+         iter != m_entry_block->end (); ++iter)
       if (jit_extract_argument *extract
           = dynamic_cast<jit_extract_argument *> (*iter))
         m_argument_vec.push_back (std::make_pair (extract->name (), true));
 
     jit_type *any = jit_typeinfo::get_any ();
 
     // argument is an array of octave_base_value*, or octave_base_value**
     llvm::Type *arg_type = any->to_llvm (); // this is octave_base_value*
@@ -1401,18 +1397,18 @@ namespace octave
     try
       {
         m_prelude = m_creating.new_block ("prelude");
         builder.SetInsertPoint (m_prelude);
 
         tree_parameter_list *plist = fcn.parameter_list ();
         if (plist)
           {
-            tree_parameter_list::iterator piter = plist->begin ();
-            tree_parameter_list::iterator pend = plist->end ();
+            auto piter = plist->begin ();
+            auto pend = plist->end ();
             for (size_t i = 0; i < args.size () && piter != pend; ++i, ++piter)
               {
                 tree_decl_elt *elt = *piter;
                 std::string arg_name = elt->name ();
                 m_arguments[arg_name] = m_creating.argument (builder, i);
               }
           }
 
@@ -1440,30 +1436,29 @@ namespace octave
                                                             m_function);
         jblock->stash_llvm (m_block);
       }
 
     jit_block *first = *blocks.begin ();
     builder.CreateBr (first->to_llvm ());
 
     // constants aren't in the IR, we visit those first
-    for (std::list<jit_value *>::const_iterator iter = constants.begin ();
-         iter != constants.end (); ++iter)
+    for (auto iter = constants.begin (); iter != constants.end (); ++iter)
       if (! isa<jit_instruction> (*iter))
         visit (*iter);
 
     // convert all instructions
     for (biter = blocks.begin (); biter != blocks.end (); ++biter)
       visit (*biter);
 
     // now finish phi nodes
     for (biter = blocks.begin (); biter != blocks.end (); ++biter)
       {
         jit_block& m_block = **biter;
-        for (jit_block::iterator piter = m_block.begin ();
+        for (auto piter = m_block.begin ();
              piter != m_block.end () && isa<jit_phi> (*piter); ++piter)
           {
             jit_instruction *phi = *piter;
             finish_phi (static_cast<jit_phi *> (phi));
           }
       }
   }
 
@@ -1531,17 +1526,17 @@ namespace octave
     cr.stash_llvm (as_llvm);
   }
 
   void
   jit_convert_llvm::visit (jit_block& b)
   {
     llvm::BasicBlock *m_block = b.to_llvm ();
     builder.SetInsertPoint (m_block);
-    for (jit_block::iterator iter = b.begin (); iter != b.end (); ++iter)
+    for (auto iter = b.begin (); iter != b.end (); ++iter)
       visit (*iter);
   }
 
   void
   jit_convert_llvm::visit (jit_branch& b)
   {
     b.stash_llvm (builder.CreateBr (b.successor_llvm ()));
   }
@@ -1690,18 +1685,17 @@ namespace octave
 
   void
   jit_infer::infer (void)
   {
     construct_ssa ();
 
     // initialize the worklist to instructions derived from constants
     const std::list<jit_value *>& constants = m_factory.constants ();
-    for (std::list<jit_value *>::const_iterator iter = constants.begin ();
-         iter != constants.end (); ++iter)
+    for (auto iter = constants.begin (); iter != constants.end (); ++iter)
       append_users (*iter);
 
     // the entry block terminator may be a regular branch statement
     if (entry_block ().terminator ())
       push_worklist (entry_block ().terminator ());
 
     // FIXME: Describe algorithm here
     while (m_worklist.size ())
@@ -1736,17 +1730,17 @@ namespace octave
   void
   jit_infer::append_users_term (jit_terminator *term)
   {
     for (size_t i = 0; i < term->successor_count (); ++i)
       {
         if (term->alive (i))
           {
             jit_block *succ = term->successor (i);
-            for (jit_block::iterator iter = succ->begin ();
+            for (auto iter = succ->begin ();
                  iter != succ->end () && isa<jit_phi> (*iter); ++iter)
               push_worklist (*iter);
 
             jit_terminator *sterm = succ->terminator ();
             if (sterm)
               push_worklist (sterm);
           }
       }
@@ -1756,33 +1750,30 @@ namespace octave
   jit_infer::construct_ssa (void)
   {
     m_blocks.label ();
     final_block ().compute_idom (entry_block ());
     entry_block ().compute_df ();
     entry_block ().create_dom_tree ();
 
     // insert phi nodes where needed, this is done on a per variable basis
-    for (variable_map::const_iterator iter = m_vmap.begin ();
-         iter != m_vmap.end ();
-         ++iter)
+    for (auto  iter = m_vmap.begin (); iter != m_vmap.end (); ++iter)
       {
         jit_block::df_set visited, added_phi;
         std::list<jit_block *> ssa_worklist;
         iter->second->use_blocks (visited);
         ssa_worklist.insert (ssa_worklist.begin (), visited.begin (),
                              visited.end ());
 
         while (ssa_worklist.size ())
           {
             jit_block *b = ssa_worklist.front ();
             ssa_worklist.pop_front ();
 
-            for (jit_block::df_iterator diter = b->df_begin ();
-                 diter != b->df_end (); ++diter)
+            for (auto diter = b->df_begin (); diter != b->df_end (); ++diter)
               {
                 jit_block *dblock = *diter;
                 if (! added_phi.count (dblock))
                   {
                     jit_phi *phi = m_factory.create<jit_phi> (iter->second,
                                                           dblock->use_count ());
                     dblock->prepend (phi);
                     added_phi.insert (dblock);
@@ -1802,31 +1793,29 @@ namespace octave
 
   void
   jit_infer::do_construct_ssa (jit_block& ablock, size_t avisit_count)
   {
     if (ablock.visited (avisit_count))
       return;
 
     // replace variables with their current SSA value
-    for (jit_block::iterator iter = ablock.begin ();
-         iter != ablock.end ();
-         ++iter)
+    for (auto iter = ablock.begin (); iter != ablock.end (); ++iter)
       {
         jit_instruction *instr = *iter;
         instr->construct_ssa ();
         instr->push_variable ();
       }
 
     // finish phi nodes of successors
     for (size_t i = 0; i < ablock.successor_count (); ++i)
       {
         jit_block *finish = ablock.successor (i);
 
-        for (jit_block::iterator iter = finish->begin ();
+        for (auto  iter = finish->begin ();
              iter != finish->end () && isa<jit_phi> (*iter);)
           {
             jit_phi *phi = static_cast<jit_phi *> (*iter);
             jit_variable *var = phi->dest ();
             ++iter;
 
             if (var->has_top ())
               phi->add_incoming (&ablock, var->top ());
@@ -1846,19 +1835,17 @@ namespace octave
 
     ablock.pop_all ();
   }
 
   void
   jit_infer::place_releases (void)
   {
     std::set<jit_value *> temporaries;
-    for (jit_block_list::iterator iter = m_blocks.begin ();
-         iter != m_blocks.end ();
-         ++iter)
+    for (auto iter = m_blocks.begin (); iter != m_blocks.end (); ++iter)
       {
         jit_block& ablock = **iter;
         if (ablock.id () != jit_block::NO_ID)
           {
             release_temp (ablock, temporaries);
             release_dead_phi (ablock);
           }
       }
@@ -1878,17 +1865,17 @@ namespace octave
   jit_infer::remove_dead ()
   {
     jit_block_list::iterator biter;
     for (biter = m_blocks.begin (); biter != m_blocks.end (); ++biter)
       {
         jit_block *b = *biter;
         if (b->alive ())
           {
-            for (jit_block::iterator iter = b->begin ();
+            for (auto iter = b->begin ();
                  iter != b->end () && isa<jit_phi> (*iter);)
               {
                 jit_phi *phi = static_cast<jit_phi *> (*iter);
                 if (phi->prune ())
                   iter = b->remove (iter);
                 else
                   ++iter;
               }
@@ -1922,17 +1909,17 @@ namespace octave
             biter = m_blocks.erase (biter);
           }
       }
   }
 
   void
   jit_infer::release_dead_phi (jit_block& ablock)
   {
-    jit_block::iterator iter = ablock.begin ();
+    auto iter = ablock.begin ();
     while (iter != ablock.end () && isa<jit_phi> (*iter))
       {
         jit_phi *phi = static_cast<jit_phi *> (*iter);
         ++iter;
 
         jit_use *use = phi->first_use ();
         if (phi->use_count () == 1 && isa<jit_assign> (use->user ()))
           {
@@ -1958,19 +1945,17 @@ namespace octave
             phi->remove ();
           }
       }
   }
 
   void
   jit_infer::release_temp (jit_block& ablock, std::set<jit_value *>& temp)
   {
-    for (jit_block::iterator iter = ablock.begin ();
-         iter != ablock.end ();
-         ++iter)
+    for (auto iter = ablock.begin (); iter != ablock.end (); ++iter)
       {
         jit_instruction *instr = *iter;
 
         // check for temporaries that require release and live across
         // multiple blocks
         if (instr->needs_release ())
           {
             jit_block *fu_block = instr->first_use_block ();
@@ -2000,37 +1985,33 @@ namespace octave
     if (! temp.size () || ! isa<jit_error_check> (ablock.terminator ()))
       return;
 
     // FIXME: If we support try/catch or unwind_protect final_block
     //        may not be the destination
     jit_block *split = ablock.maybe_split (m_factory, m_blocks,
                                            final_block ());
     jit_terminator *term = split->terminator ();
-    for (std::set<jit_value *>::const_iterator iter = temp.begin ();
-         iter != temp.end ();
-         ++iter)
+    for (auto iter = temp.begin (); iter != temp.end (); ++iter)
       {
         jit_value *value = *iter;
         jit_call *release
           = m_factory.create<jit_call> (&jit_typeinfo::release, value);
         split->insert_before (term, release);
         release->infer ();
       }
   }
 
   void
   jit_infer::simplify_phi (void)
   {
-    for (jit_block_list::iterator biter = m_blocks.begin ();
-         biter != m_blocks.end ();
-         ++biter)
+    for (auto biter = m_blocks.begin (); biter != m_blocks.end (); ++biter)
       {
         jit_block &ablock = **biter;
-        for (jit_block::iterator iter = ablock.begin ();
+        for (auto iter = ablock.begin ();
              iter != ablock.end () && isa<jit_phi> (*iter); ++iter)
           simplify_phi (*static_cast<jit_phi *> (*iter));
       }
   }
 
   void
   jit_infer::simplify_phi (jit_phi& phi)
   {
@@ -2836,17 +2817,17 @@ namespace octave
             m_function = reinterpret_cast<jited_function> (void_fn);
           }
       }
   }
 
   octave_value
   jit_info::find (const vmap& extra_vars, const std::string& vname) const
   {
-    vmap::const_iterator iter = extra_vars.find (vname);
+    auto iter = extra_vars.find (vname);
 
     if (iter == extra_vars.end ())
       {
         symbol_scope scope = __require_current_scope__ ("jit_convert::find");
 
         return scope.varval (vname);
       }
     else
diff --git a/libinterp/parse-tree/pt-misc.cc b/libinterp/parse-tree/pt-misc.cc
--- a/libinterp/parse-tree/pt-misc.cc
+++ b/libinterp/parse-tree/pt-misc.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 namespace octave
 {
   // Parameter lists.
 
   tree_parameter_list::~tree_parameter_list (void)
   {
     while (! empty ())
       {
-        iterator p = begin ();
+        auto p = begin ();
         delete *p;
         erase (p);
       }
   }
 
   void
   tree_parameter_list::mark_as_formal_parameters (void)
   {
@@ -91,14 +91,14 @@ namespace octave
   }
 
   // Return lists.
 
   tree_return_list::~tree_return_list (void)
   {
     while (! empty ())
       {
-        iterator p = begin ();
+        auto p = begin ();
         delete *p;
         erase (p);
       }
   }
 }
diff --git a/libinterp/parse-tree/pt-pr-code.cc b/libinterp/parse-tree/pt-pr-code.cc
--- a/libinterp/parse-tree/pt-pr-code.cc
+++ b/libinterp/parse-tree/pt-pr-code.cc
@@ -55,17 +55,17 @@ namespace octave
     print_fcn_handle_body (afh.expression ());
 
     print_parens (afh, ")");
   }
 
   void
   tree_print_code::visit_argument_list (tree_argument_list& lst)
   {
-    tree_argument_list::iterator p = lst.begin ();
+    auto p = lst.begin ();
 
     while (p != lst.end ())
       {
         tree_expression *elt = *p++;
 
         if (elt)
           {
             elt->accept (*this);
@@ -158,17 +158,17 @@ namespace octave
 
     if (init_list)
       init_list->accept (*this);
   }
 
   void
   tree_print_code::visit_decl_init_list (tree_decl_init_list& lst)
   {
-    tree_decl_init_list::iterator p = lst.begin ();
+    auto p = lst.begin ();
 
     while (p != lst.end ())
       {
         tree_decl_elt *elt = *p++;
 
         if (elt)
           {
             elt->accept (*this);
@@ -490,17 +490,17 @@ namespace octave
     indent ();
 
     m_os << "endif";
   }
 
   void
   tree_print_code::visit_if_command_list (tree_if_command_list& lst)
   {
-    tree_if_command_list::iterator p = lst.begin ();
+    auto p = lst.begin ();
 
     bool first_elt = true;
 
     while (p != lst.end ())
       {
         tree_if_clause *elt = *p++;
 
         if (elt)
@@ -537,18 +537,18 @@ namespace octave
       e->accept (*this);
 
     std::list<tree_argument_list *> arg_lists = expr.arg_lists ();
     std::string type_tags = expr.type_tags ();
     std::list<string_vector> arg_names = expr.arg_names ();
 
     int n = type_tags.length ();
 
-    std::list<tree_argument_list *>::iterator p_arg_lists = arg_lists.begin ();
-    std::list<string_vector>::iterator p_arg_names = arg_names.begin ();
+    auto p_arg_lists = arg_lists.begin ();
+    auto p_arg_names = arg_names.begin ();
 
     for (int i = 0; i < n; i++)
       {
         switch (type_tags[i])
           {
           case '(':
             {
               char nc = m_nesting.top ();
@@ -611,17 +611,17 @@ namespace octave
   {
     indent ();
 
     print_parens (lst, "(");
 
     m_os << '[';
     m_nesting.push ('[');
 
-    tree_matrix::iterator p = lst.begin ();
+    auto p = lst.begin ();
 
     while (p != lst.end ())
       {
         tree_argument_list *elt = *p++;
 
         if (elt)
           {
             elt->accept (*this);
@@ -642,17 +642,17 @@ namespace octave
   {
     indent ();
 
     print_parens (lst, "(");
 
     m_os << '{';
     m_nesting.push ('{');
 
-    tree_cell::iterator p = lst.begin ();
+    auto p = lst.begin ();
 
     while (p != lst.end ())
       {
         tree_argument_list *elt = *p++;
 
         if (elt)
           {
             elt->accept (*this);
@@ -751,17 +751,17 @@ namespace octave
     fc.print_raw (m_os, true, m_print_original_text);
 
     print_parens (fc, ")");
   }
 
   void
   tree_print_code::visit_parameter_list (tree_parameter_list& lst)
   {
-    tree_parameter_list::iterator p = lst.begin ();
+    auto p = lst.begin ();
 
     while (p != lst.end ())
       {
         tree_decl_elt *elt = *p++;
 
         if (elt)
           {
             elt->accept (*this);
@@ -812,17 +812,17 @@ namespace octave
     indent ();
 
     m_os << "return";
   }
 
   void
   tree_print_code::visit_return_list (tree_return_list& lst)
   {
-    tree_return_list::iterator p = lst.begin ();
+    auto p = lst.begin ();
 
     while (p != lst.end ())
       {
         tree_index_expression *elt = *p++;
 
         if (elt)
           {
             elt->accept (*this);
@@ -928,17 +928,17 @@ namespace octave
 
         decrement_indent_level ();
       }
   }
 
   void
   tree_print_code::visit_switch_case_list (tree_switch_case_list& lst)
   {
-    tree_switch_case_list::iterator p = lst.begin ();
+    auto p = lst.begin ();
 
     while (p != lst.end ())
       {
         tree_switch_case *elt = *p++;
 
         if (elt)
           elt->accept (*this);
       }
@@ -1277,17 +1277,17 @@ namespace octave
       newline ();
   }
 
   void
   tree_print_code::print_comment_list (comment_list *comment_list)
   {
     if (comment_list)
       {
-        comment_list::iterator p = comment_list->begin ();
+        auto p = comment_list->begin ();
 
         while (p != comment_list->end ())
           {
             comment_elt elt = *p++;
 
             print_comment_elt (elt);
 
             if (p != comment_list->end ())
diff --git a/libinterp/parse-tree/pt-select.h b/libinterp/parse-tree/pt-select.h
--- a/libinterp/parse-tree/pt-select.h
+++ b/libinterp/parse-tree/pt-select.h
@@ -99,17 +99,17 @@ namespace octave
     tree_if_command_list (const tree_if_command_list&) = delete;
 
     tree_if_command_list& operator = (const tree_if_command_list&) = delete;
 
     ~tree_if_command_list (void)
     {
       while (! empty ())
         {
-          iterator p = begin ();
+          auto p = begin ();
           delete *p;
           erase (p);
         }
     }
 
     void accept (tree_walker& tw)
     {
       tw.visit_if_command_list (*this);
@@ -224,17 +224,17 @@ namespace octave
     tree_switch_case_list (const tree_switch_case_list&) = delete;
 
     tree_switch_case_list& operator = (const tree_switch_case_list&) = delete;
 
     ~tree_switch_case_list (void)
     {
       while (! empty ())
         {
-          iterator p = begin ();
+          auto p = begin ();
           delete *p;
           erase (p);
         }
     }
 
     void accept (tree_walker& tw)
     {
       tw.visit_switch_case_list (*this);
diff --git a/libinterp/parse-tree/pt-stmt.h b/libinterp/parse-tree/pt-stmt.h
--- a/libinterp/parse-tree/pt-stmt.h
+++ b/libinterp/parse-tree/pt-stmt.h
@@ -148,17 +148,17 @@ namespace octave
     tree_statement_list (const tree_statement_list&) = delete;
 
     tree_statement_list& operator = (const tree_statement_list&) = delete;
 
     ~tree_statement_list (void)
     {
       while (! empty ())
         {
-          iterator p = begin ();
+          auto p = begin ();
           delete *p;
           erase (p);
         }
     }
 
     void mark_as_function_body (void) { m_function_body = true; }
 
     void mark_as_anon_function_body (void) { m_anon_function_body = true; }
diff --git a/liboctave/util/caseless-str.h b/liboctave/util/caseless-str.h
--- a/liboctave/util/caseless-str.h
+++ b/liboctave/util/caseless-str.h
@@ -44,18 +44,18 @@ public:
   caseless_str& operator = (const caseless_str& pname)
   {
     std::string::operator = (pname);
     return *this;
   }
 
   bool operator < (const std::string& s) const
   {
-    const_iterator p1 = begin ();
-    const_iterator p2 = s.begin ();
+    auto p1 = begin ();
+    auto p2 = s.begin ();
 
     while (p1 != end () && p2 != s.end ())
       {
         char lp1 = std::tolower (*p1);
         char lp2 = std::tolower (*p2);
 
         if (lp1 > lp2)
           return false;
@@ -70,18 +70,18 @@ public:
       return false;
     else
       return true;
   }
 
   // Case-insensitive comparison.
   bool compare (const std::string& s, size_t limit = std::string::npos) const
   {
-    const_iterator p1 = begin ();
-    const_iterator p2 = s.begin ();
+    auto p1 = begin ();
+    auto p2 = s.begin ();
 
     size_t k = 0;
 
     while (p1 != end () && p2 != s.end () && k++ < limit)
       {
         if (std::tolower (*p1) != std::tolower (*p2))
           return false;
 
diff --git a/liboctave/util/lo-regexp.cc b/liboctave/util/lo-regexp.cc
--- a/liboctave/util/lo-regexp.cc
+++ b/liboctave/util/lo-regexp.cc
@@ -513,17 +513,17 @@ namespace octave
     std::string rep;
     int num_tokens = tokens.size ();
 
     if (num_tokens > 0)
       {
         // Determine replacement length
         const size_t replen = repstr.size () - 2*num_tokens;
         int delta = 0;
-        regexp::match_data::const_iterator p = rx_lst.begin ();
+        auto p = rx_lst.begin ();
         for (size_t i = 0; i < num_matches; i++)
           {
             octave_quit ();
 
             double start = p->start ();
             double end = p->end ();
 
             const Matrix pairs (p->token_extents ());
@@ -590,17 +590,17 @@ namespace octave
           }
         rep.append (&buffer[from], buffer.size () - from);
       }
     else
       {
         // Determine repstr length
         const size_t replen = repstr.size ();
         int delta = 0;
-        regexp::match_data::const_iterator p = rx_lst.begin ();
+        auto p = rx_lst.begin ();
         for (size_t i = 0; i < num_matches; i++)
           {
             octave_quit ();
 
             delta += static_cast<int> (replen)
                      - static_cast<int> (p->end () - p->start () + 1);
             p++;
           }
