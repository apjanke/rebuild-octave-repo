# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1270235741 14400
#      Fri Apr 02 15:15:41 2010 -0400
# Node ID 942386d6d1a5006807b30742550a07326eade2b0
# Parent  4e64fbbd5c5869109b5c9bce5fafd0a2315752be
style fixes

diff --git a/liboctave/Array-util.cc b/liboctave/Array-util.cc
--- a/liboctave/Array-util.cc
+++ b/liboctave/Array-util.cc
@@ -481,22 +481,25 @@ zero_dims_inquire (const idx_vector& i, 
 
   return rdv;
 }
 
 // A helper class.
 struct sub2ind_helper
 {
   octave_idx_type *ind, n;
+
   sub2ind_helper (octave_idx_type *_ind, octave_idx_type _n)
     : ind(_ind), n(_n) { }
+
   void operator ()(octave_idx_type k) { (*ind++ *= n) += k; }
 };
 
-idx_vector sub2ind (const dim_vector& dv, const Array<idx_vector>& idxa)
+idx_vector
+sub2ind (const dim_vector& dv, const Array<idx_vector>& idxa)
 {
   idx_vector retval;
   octave_idx_type len = idxa.length ();
 
   if (len >= 1)
     {
       const dim_vector dvx = dv.redim (len);
       bool all_ranges = true;
@@ -556,17 +559,18 @@ idx_vector sub2ind (const dim_vector& dv
         }
     }
   else
     current_liboctave_error_handler ("sub2ind: needs at least 2 indices");
 
   return retval;
 }
 
-Array<idx_vector> ind2sub (const dim_vector& dv, const idx_vector& idx)
+Array<idx_vector>
+ind2sub (const dim_vector& dv, const idx_vector& idx)
 {
   octave_idx_type len = idx.length (0), n = dv.length ();
   Array<idx_vector> retval(n, 1);
   octave_idx_type numel = dv.numel ();
 
   if (idx.extent (numel) > numel)
     current_liboctave_error_handler ("ind2sub: index out of range");
   else
@@ -628,78 +632,88 @@ gripe_nan_to_logical_conversion (void)
 {
   (*current_liboctave_error_handler) ("invalid conversion of NaN to logical");
 }
 
 void
 gripe_nonconformant (const char *op, int op1_len, int op2_len)
 {
   const char *err_id = error_id_nonconformant_args;
+
   (*current_liboctave_error_with_id_handler)
     (err_id, "%s: nonconformant arguments (op1 len: %d, op2 len: %d)",
      op, op1_len, op2_len);
 }
 
 void
 gripe_nonconformant (const char *op, int op1_nr, int op1_nc,
                      int op2_nr, int op2_nc)
 {
   const char *err_id = error_id_nonconformant_args;
+
   (*current_liboctave_error_with_id_handler)
     (err_id, "%s: nonconformant arguments (op1 is %dx%d, op2 is %dx%d)",
      op, op1_nr, op1_nc, op2_nr, op2_nc);
 }
 
 void
 gripe_nonconformant (const char *op, const dim_vector& op1_dims,
                      const dim_vector& op2_dims)
 {
   const char *err_id = error_id_nonconformant_args;
+
   std::string op1_dims_str = op1_dims.str ();
   std::string op2_dims_str = op2_dims.str ();
 
   (*current_liboctave_error_with_id_handler)
     (err_id, "%s: nonconformant arguments (op1 is %s, op2 is %s)",
      op, op1_dims_str.c_str (), op2_dims_str.c_str ());
 }
 
-void gripe_index_out_of_range (int nd, int dim, 
-                               octave_idx_type idx, octave_idx_type ext)
+void
+gripe_index_out_of_range (int nd, int dim, octave_idx_type idx,
+                          octave_idx_type ext)
 {
   const char *err_id = error_id_index_out_of_bounds;
+
   switch (nd)
     {
     case 1:
       (*current_liboctave_error_with_id_handler)
         (err_id, "A(I): index out of bounds; value %d out of bound %d",
          idx, ext);
       break;
+
     case 2:
       (*current_liboctave_error_with_id_handler)
         (err_id, "A(I,J): %s index out of bounds; value %d out of bound %d",
          (dim == 1) ? "row" : "column", idx, ext);
       break;
+
     default:
       (*current_liboctave_error_with_id_handler)
         (err_id, "A(I,J,...): index to dimension %d out of bounds; value %d out of bound %d",
          dim, idx, ext);
       break;
     }
 }
 
-void gripe_del_index_out_of_range (bool is1d, octave_idx_type idx, 
-                                   octave_idx_type ext)
+void
+gripe_del_index_out_of_range (bool is1d, octave_idx_type idx,
+                              octave_idx_type ext)
 {
   const char *err_id = error_id_index_out_of_bounds;
+
   (*current_liboctave_error_with_id_handler)
     (err_id, "A(%s) = []: index out of bounds; value %d out of bound %d",
      is1d ? "I" : "..,I,..", idx, ext);
 }
 
-void gripe_invalid_index (bool err)
+void
+gripe_invalid_index (bool err)
 {
   const char *err_id = error_id_invalid_index;
 
   if (err)
     (*current_liboctave_error_with_id_handler)
       (err_id, "subscript indices must be either positive integers or logicals");
   else
     (*current_liboctave_warning_with_id_handler)
@@ -707,15 +721,17 @@ void gripe_invalid_index (bool err)
 }
 
 // FIXME -- the following is a common error message to resize,
 // regardless of whether it's called from assign or elsewhere.  It
 // seems OK to me, but eventually the gripe can be specialized.
 // Anyway, propagating various error messages into procedure is, IMHO,
 // a nonsense.  If anything, we should change error handling here (and
 // throughout liboctave) to allow custom handling of errors
-void gripe_invalid_resize (void)
+
+void
+gripe_invalid_resize (void)
 {
   (*current_liboctave_error_with_id_handler)
     ("Octave:invalid-resize", 
      "Invalid resizing operation or ambiguous assignment to an out-of-bounds array element.");
 }
 
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,12 @@
+2010-04-02  John W. Eaton  <jwe@octave.org>
+
+	* Array-util.cc, idx-vector.cc, idx-vector.h: Style fixes.
+
 2010-04-02  John W. Eaton  <jwe@octave.org>
 
 	* idx-vector.cc (idx_vector::idx_vector (const Range&)):
 	Move here from idx-vector.h.  Allow non-integer values in ranges,
 	but warn by default (for Matlab compatibility).
 	* Array-util.h, Array-util.cc (gripe_invalid_index): New arg, ERR.
 	If ERR is false, generate warning instead of error.
 
diff --git a/liboctave/idx-vector.cc b/liboctave/idx-vector.cc
--- a/liboctave/idx-vector.cc
+++ b/liboctave/idx-vector.cc
@@ -221,24 +221,28 @@ idx_vector::idx_range_rep::as_array (voi
 }
 
 inline octave_idx_type
 convert_index (octave_idx_type i, bool& conv_error, 
                octave_idx_type& ext)
 {
   if (i <= 0) 
     conv_error = true;
-  if (ext < i) ext = i;
+
+  if (ext < i)
+    ext = i;
+
   return i - 1;
 }
 
 inline octave_idx_type
 convert_index (double x, bool& conv_error, octave_idx_type& ext)
 {
   octave_idx_type i = static_cast<octave_idx_type> (x);
+
   if (static_cast<double> (i) != x)
     conv_error = true;
 
   return convert_index (i, conv_error, ext);
 }
 
 inline octave_idx_type
 convert_index (float x, bool& conv_error, octave_idx_type& ext)
@@ -247,43 +251,49 @@ convert_index (float x, bool& conv_error
 }
 
 template <class T>
 inline octave_idx_type
 convert_index (octave_int<T> x, bool& conv_error, 
                octave_idx_type& ext)
 {
   octave_idx_type i = octave_int<octave_idx_type> (x).value ();
+
   return convert_index (i, conv_error, ext);
 }
 
 DEFINE_OCTAVE_ALLOCATOR(idx_vector::idx_scalar_rep);
 
 template <class T>
 idx_vector::idx_scalar_rep::idx_scalar_rep (T x)
 {
   octave_idx_type dummy = 0;
+
   data = convert_index (x, err, dummy);
-  if (err) gripe_invalid_index ();
+
+  if (err)
+    gripe_invalid_index ();
 }
 
 idx_vector::idx_scalar_rep::idx_scalar_rep (octave_idx_type i) 
   : data (i)
 {
   if (data < 0) 
     {
       gripe_invalid_index ();
       err = true;
     }
 }
 
 octave_idx_type
 idx_vector::idx_scalar_rep::checkelem (octave_idx_type i) const
 {
-  if (i != 0) gripe_index_out_of_range ();
+  if (i != 0)
+    gripe_index_out_of_range ();
+
   return data;
 }
 
 idx_vector::idx_base_rep *
 idx_vector::idx_scalar_rep::sort_idx (Array<octave_idx_type>& idx)
 {
   idx.clear (1, 1);
   idx.fill (0);
@@ -316,17 +326,18 @@ idx_vector::idx_vector_rep::idx_vector_r
 {
   if (len != 0)
     {
       octave_idx_type *d = new octave_idx_type[len];
       for (octave_idx_type i = 0; i < len; i++)
         d[i] = convert_index (nda.xelem (i), err, ext);
       data = d;
 
-      if (err) gripe_invalid_index ();
+      if (err)
+        gripe_invalid_index ();
     }
 }
 
 // Note that this makes a shallow copy of the index array.
 
 idx_vector::idx_vector_rep::idx_vector_rep (const Array<octave_idx_type>& inda)
   : data (inda.data ()), len (inda.numel ()), ext (0), 
   aowner (new Array<octave_idx_type> (inda)), orig_dims (inda.dims ())
@@ -340,24 +351,25 @@ idx_vector::idx_vector_rep::idx_vector_r
           if (k < 0) 
             err = true;
           else if (k > max) 
             max = k;
         }
 
       ext = max + 1;
 
-      if (err) gripe_invalid_index ();
+      if (err)
+        gripe_invalid_index ();
     }
 }
 
 idx_vector::idx_vector_rep::idx_vector_rep (const Array<octave_idx_type>& inda,
                                             octave_idx_type _ext, direct)
   : data (inda.data ()), len (inda.numel ()), ext (_ext), 
-  aowner (new Array<octave_idx_type> (inda)), orig_dims (inda.dims ())
+    aowner (new Array<octave_idx_type> (inda)), orig_dims (inda.dims ())
 {
   // No checking.
   if (ext < 0)
     {
       octave_idx_type max = -1;
       for (octave_idx_type i = 0; i < len; i++)
         if (data[i] > max)
           max = data[i];
@@ -394,17 +406,18 @@ idx_vector::idx_vector_rep::idx_vector_r
   if (len != 0)
     {
       octave_idx_type *d = new octave_idx_type [len];
 
       octave_idx_type ntot = bnda.length ();
 
       octave_idx_type k = 0;
       for (octave_idx_type i = 0; i < ntot; i++)
-        if (bnda.xelem (i)) d[k++] = i;
+        if (bnda.xelem (i))
+          d[k++] = i;
 
       data = d;
 
       ext = d[k-1] + 1;
     }
 }
 
 idx_vector::idx_vector_rep::idx_vector_rep (const Sparse<bool>& bnda)
@@ -590,19 +603,22 @@ idx_vector::idx_vector_rep::sort_idx (Ar
 
   return new_rep.release ();
 }
 
 std::ostream& 
 idx_vector::idx_vector_rep::print (std::ostream& os) const
 {
   os << '[';
+
   for (octave_idx_type ii = 0; ii < len - 1; ii++)
     os << data[ii] << ',' << ' ';
-  if (len > 0) os << data[len-1]; os << ']';
+
+  if (len > 0)
+    os << data[len-1]; os << ']';
 
   return os;
 }
 
 Array<double>
 idx_vector::idx_vector_rep::unconvert (void) const
 {
   Array<double> retval (orig_dims);
@@ -703,19 +719,22 @@ idx_vector::idx_mask_rep::checkelem (oct
 
   return xelem (n);
 }
 
 std::ostream& 
 idx_vector::idx_mask_rep::print (std::ostream& os) const
 {
   os << '[';
+
   for (octave_idx_type ii = 0; ii < ext - 1; ii++)
     os << data[ii] << ',' << ' ';
-  if (ext > 0) os << data[ext-1]; os << ']';
+
+  if (ext > 0)
+    os << data[ext-1]; os << ']';
 
   return os;
 }
 
 Array<bool>
 idx_vector::idx_mask_rep::unconvert (void) const
 {
   if (aowner)
@@ -782,18 +801,19 @@ idx_vector::idx_vector (const Range& r)
       rep = new idx_vector_rep (m.map (xround));
     }
   else
     rep = new idx_range_rep (r);
 
   chkerr ();
 }
 
-bool idx_vector::maybe_reduce (octave_idx_type n, const idx_vector& j,
-                               octave_idx_type nj)
+bool
+idx_vector::maybe_reduce (octave_idx_type n, const idx_vector& j,
+                          octave_idx_type nj)
 {
   bool reduced = false;
 
   // Empty index always reduces.
   if (rep->length (n) == 0)
     {
       *this = idx_vector ();
       return true;
@@ -813,257 +833,286 @@ bool idx_vector::maybe_reduce (octave_id
     {
     case class_colon:
       switch (rep->idx_class ())
         {
         case class_colon:
           // (:,:) reduces to (:)
           reduced = true;
           break;
+
         case class_scalar:
           {
             // (i,:) reduces to a range.
             idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
             octave_idx_type k = r->get_data ();
             *this = new idx_range_rep (k, nj, n, DIRECT);
             reduced = true;
-            break;
           }
+          break;
+
         case class_range:
           {
             // (i:k:end,:) reduces to a range if i <= k and k divides n.
             idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
             octave_idx_type s = r->get_start (), l = r->length (n);
             octave_idx_type t = r->get_step ();
             if (l*t == n)
               {
                 *this = new idx_range_rep (s, l * nj, t, DIRECT);
                 reduced = true;
               }
-            break;
           }
+          break;
+
         default:
           break;
         }
       break;
+
     case class_range:
       switch (rep->idx_class ())
         {
         case class_colon:
           {
             // (:,i:j) reduces to a range (the step must be 1)
             idx_range_rep * rj = dynamic_cast<idx_range_rep *> (j.rep);
             if (rj->get_step () == 1)
               {
                 octave_idx_type sj = rj->get_start (), lj = rj->length (nj);
                 *this = new idx_range_rep (sj * n, lj * n, 1, DIRECT);
                 reduced = true;
               }
-            break;
           }
+          break;
+
         case class_scalar:
           {
             // (k,i:d:j) reduces to a range.
             idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
             idx_range_rep * rj = dynamic_cast<idx_range_rep *> (j.rep);
             octave_idx_type k = r->get_data ();
             octave_idx_type sj = rj->get_start (), lj = rj->length (nj);
             octave_idx_type tj = rj->get_step ();
             *this = new idx_range_rep (n * sj + k, lj, n * tj, DIRECT);
             reduced = true;
-            break;
           }
+          break;
+
         case class_range:
           {
             // (i:k:end,p:q) reduces to a range if i <= k and k divides n.
             // (ones (1, m), ones (1, n)) reduces to (ones (1, m*n))
             idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
             octave_idx_type s = r->get_start (), l = r->length (n);
             octave_idx_type t = r->get_step ();
             idx_range_rep * rj = dynamic_cast<idx_range_rep *> (j.rep);
             octave_idx_type sj = rj->get_start (), lj = rj->length (nj);
             octave_idx_type tj = rj->get_step ();
             if ((l*t == n && tj == 1) || (t == 0 && tj == 0))
               {
                 *this = new idx_range_rep (s + n * sj, l * lj, t, DIRECT);
                 reduced = true;
               }
-            break;
           }
+          break;
+
         default:
           break;
         }
       break;
+
     case class_scalar:
       switch (rep->idx_class ())
         {
         case class_scalar:
           {
             // (i,j) reduces to a single index.
             idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
             idx_scalar_rep * rj = dynamic_cast<idx_scalar_rep *> (j.rep);
             octave_idx_type k = r->get_data () + n * rj->get_data ();
             *this = new idx_scalar_rep (k, DIRECT);
             reduced = true;
-            break;
           }
+          break;
+
         case class_range:
           {
             // (i:d:j,k) reduces to a range.
             idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
             idx_scalar_rep * rj = dynamic_cast<idx_scalar_rep *> (j.rep);
             octave_idx_type s = r->get_start (), l = r->length (nj);
             octave_idx_type t = r->get_step ();
             octave_idx_type k = rj->get_data ();
             *this = new idx_range_rep (n * k + s, l, t, DIRECT);
             reduced = true;
-            break;
           }
+          break;
+
         case class_colon:
           {
             // (:,k) reduces to a range.
             idx_scalar_rep * rj = dynamic_cast<idx_scalar_rep *> (j.rep);
             octave_idx_type k = rj->get_data ();
             *this = new idx_range_rep (n * k, n, 1, DIRECT);
             reduced = true;
-            break;
           }
+          break;
+
         default:
           break;
         }
       break;
+
     default:
       break;
     }
 
   return reduced;
 }
 
 bool
 idx_vector::is_cont_range (octave_idx_type n,
                            octave_idx_type& l, octave_idx_type& u) const
 {
   bool res = false;
+
   switch (rep->idx_class ())
     {
     case class_colon:
       l = 0; u = n;
       res = true;
       break;
+
     case class_range:
       {
         idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
         if (r->get_step () == 1)
           {
             l = r->get_start ();
             u = l + r->length (n);
             res = true;
           }
       }
       break;
+
     case class_scalar:
       {
         idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
         l = r->get_data ();
         u = l + 1;
         res = true;
       }
       break;
+
     case class_mask:
       {
         idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
         octave_idx_type ext = r->extent (0), len = r->length (0);
         if (ext == len)
           {
             l = 0;
             u = len;
             res = true;
           }
       }
+
     default:
       break;
     }
 
   return res;
 }
 
 octave_idx_type
 idx_vector::increment (void) const
 {
   octave_idx_type retval = 0;
+
   switch (rep->idx_class ())
     {
     case class_colon:
       retval = 1;
+      // fall through...
+
     case class_range:
       retval = dynamic_cast<idx_range_rep *> (rep) -> get_step ();
       break;
+
     case class_vector:
       {
         if (length (0) > 1)
           retval = elem (1) - elem (0);
       }
+      break;
+
     default:
       break;
     }
+
   return retval;
 }
 
 const octave_idx_type *
 idx_vector::raw (void)
 {
   if (rep->idx_class () != class_vector)
     *this = idx_vector (as_array (), extent (0));
 
   idx_vector_rep * r = dynamic_cast<idx_vector_rep *> (rep);
+
   assert (r != 0);
+
   return r->get_data ();
 }
 
 void
 idx_vector::copy_data (octave_idx_type *data) const
 {
   octave_idx_type len = rep->length (0);
 
   switch (rep->idx_class ())
     {
     case class_colon:
       current_liboctave_error_handler ("colon not allowed");
       break;
+
     case class_range:
-        {
-          idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
-          octave_idx_type start = r->get_start (), step = r->get_step ();
-          octave_idx_type i, j;
-          if (step == 1)
-            for (i = start, j = start + len; i < j; i++) *data++ = i;
-          else if (step == -1)
-            for (i = start, j = start - len; i > j; i--) *data++ = i;
-          else
-            for (i = 0, j = start; i < len; i++, j += step) *data++ = j;
-        }
+      {
+        idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
+        octave_idx_type start = r->get_start (), step = r->get_step ();
+        octave_idx_type i, j;
+        if (step == 1)
+          for (i = start, j = start + len; i < j; i++) *data++ = i;
+        else if (step == -1)
+          for (i = start, j = start - len; i > j; i--) *data++ = i;
+        else
+          for (i = 0, j = start; i < len; i++, j += step) *data++ = j;
+      }
       break;
+
     case class_scalar:
-        {
-          idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
-          *data = r->get_data ();
-        }
+      {
+        idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
+        *data = r->get_data ();
+      }
       break;
+
     case class_vector:
-        {
-          idx_vector_rep * r = dynamic_cast<idx_vector_rep *> (rep);
-          const octave_idx_type *rdata = r->get_data ();
-          copy_or_memcpy (len, rdata, data);
-        }
+      {
+        idx_vector_rep * r = dynamic_cast<idx_vector_rep *> (rep);
+        const octave_idx_type *rdata = r->get_data ();
+        copy_or_memcpy (len, rdata, data);
+      }
       break;
+
     default:
       assert (false);
       break;
     }
-
 }
 
 idx_vector
 idx_vector::complement (octave_idx_type n) const
 {
   OCTAVE_LOCAL_BUFFER_INIT (bool, left, n, true);
 
   octave_idx_type cnt = n;
@@ -1074,18 +1123,20 @@ idx_vector::complement (octave_idx_type 
       if (k < n && left[k])
         {
           left[k] = false;
           cnt--;
         }
     }
 
   octave_idx_type len = cnt, *data = new octave_idx_type[len];
+
   for (octave_idx_type i = 0, j = 0; i < n; i++)
-    if (left[i]) data[j++] = i;
+    if (left[i])
+      data[j++] = i;
 
   return new idx_vector_rep (data, len, 
                              len ? data[len-1]+1 : 0, 
                              dim_vector (1, len), DIRECT);
 }
 
 bool
 idx_vector::is_permutation (octave_idx_type n) const
@@ -1106,74 +1157,82 @@ idx_vector::is_permutation (octave_idx_t
           if (left[k])
               left[k] = false;
           else
             {
               retval = false;
               break;
             }
         }
-
     }
 
   return retval;
 }
 
 idx_vector
 idx_vector::unmask (void) const
 {
   if (idx_class () == class_mask)
     {
       idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
       const bool *data = r->get_data ();
       octave_idx_type ext = r->extent (0), len = r->length (0);
       octave_idx_type *idata = new octave_idx_type [len];
+
       for (octave_idx_type i = 0, j = 0; i < ext; i++)
         if (data[i]) 
           idata[j++] = i;
+
       ext = len > 0 ? idata[len - 1] : 0;
-      return new idx_vector_rep (idata, len, ext, r->orig_dimensions (), DIRECT);
+
+      return new idx_vector_rep (idata, len, ext, r->orig_dimensions (),
+                                 DIRECT);
     }
   else
     return *this;
 }
 
 void idx_vector::unconvert (idx_class_type& iclass,
                             double& scalar, Range& range, 
                             Array<double>& array, Array<bool>& mask) const
 {
   iclass = idx_class ();
   switch (iclass)
     {
     case class_colon:
       break;
+
     case class_range:
-        {
-          idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
-          range = r->unconvert ();
-        }
+      {
+        idx_range_rep *r = dynamic_cast<idx_range_rep *> (rep);
+        range = r->unconvert ();
+      }
       break;
+
     case class_scalar:
-        {
-          idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
-          scalar = r->unconvert ();
-        }
+      {
+        idx_scalar_rep *r = dynamic_cast<idx_scalar_rep *> (rep);
+        scalar = r->unconvert ();
+      }
       break;
+
     case class_vector:
-        {
-          idx_vector_rep * r = dynamic_cast<idx_vector_rep *> (rep);
-          array = r->unconvert ();
-        }
+      {
+        idx_vector_rep *r = dynamic_cast<idx_vector_rep *> (rep);
+        array = r->unconvert ();
+      }
       break;
+
     case class_mask:
-        {
-          idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
-          mask = r->unconvert ();
-        }
+      {
+        idx_mask_rep *r = dynamic_cast<idx_mask_rep *> (rep);
+        mask = r->unconvert ();
+      }
       break;
+
     default:
       assert (false);
       break;
     }
 }
 
 Array<octave_idx_type> 
 idx_vector::as_array (void) const
@@ -1194,21 +1253,26 @@ idx_vector::freeze (octave_idx_type z_le
 
   return length (z_len);
 }
 
 octave_idx_type 
 idx_vector::ones_count () const
 {
   octave_idx_type n = 0;
+
   if (is_colon ())
     n = 1;
   else
-    for (octave_idx_type i = 0; i < length (1); i++)
-      if (xelem (i) == 0) n++;
+    {
+      for (octave_idx_type i = 0; i < length (1); i++)
+        if (xelem (i) == 0)
+          n++;
+    }
+
   return n;
 }
 
 // Instantiate the octave_int constructors we want.
 #define INSTANTIATE_SCALAR_VECTOR_REP_CONST(T) \
   template OCTAVE_API idx_vector::idx_scalar_rep::idx_scalar_rep (T); \
   template OCTAVE_API idx_vector::idx_vector_rep::idx_vector_rep (const Array<T>&);
 
diff --git a/liboctave/idx-vector.h b/liboctave/idx-vector.h
--- a/liboctave/idx-vector.h
+++ b/liboctave/idx-vector.h
@@ -88,22 +88,20 @@ private:
     virtual idx_class_type idx_class (void) const { return class_invalid; }
 
     // Sorts, maybe uniqifies, and returns a clone object pointer.
     virtual idx_base_rep *sort_uniq_clone (bool uniq = false) = 0;
     // Sorts, and returns a sorting permutation (aka Array::sort).
     virtual idx_base_rep *sort_idx (Array<octave_idx_type>&) = 0;
 
     // Checks whether the index is colon or a range equivalent to colon.
-    virtual bool is_colon_equiv (octave_idx_type) const
-      { return false; }
+    virtual bool is_colon_equiv (octave_idx_type) const { return false; }
 
     // The original dimensions of this object (used when subscribing by matrices).
-    virtual dim_vector orig_dimensions (void) const
-      { return dim_vector (); }
+    virtual dim_vector orig_dimensions (void) const { return dim_vector (); }
 
     // i/o
     virtual std::ostream& print (std::ostream& os) const = 0;
 
     virtual Array<octave_idx_type> as_array (void);
 
     int count;
 
@@ -118,36 +116,32 @@ private:
   // The magic colon index.
   class OCTAVE_API idx_colon_rep : public idx_base_rep
   {
   public:
     idx_colon_rep (void) { }
 
     idx_colon_rep (char c);
 
-    octave_idx_type xelem (octave_idx_type i) const
-      { return i; }
+    octave_idx_type xelem (octave_idx_type i) const { return i; }
 
     octave_idx_type checkelem (octave_idx_type i) const;
 
-    octave_idx_type length (octave_idx_type n) const
-      { return n; }
+    octave_idx_type length (octave_idx_type n) const { return n; }
 
-    octave_idx_type extent (octave_idx_type n) const
-      { return n; }
+    octave_idx_type extent (octave_idx_type n) const { return n; }
 
     idx_class_type idx_class (void) const { return class_colon; }
 
-    idx_base_rep *sort_uniq_clone (bool = false) 
+    idx_base_rep *sort_uniq_clone (bool = false)
       { count++; return this; }
 
     idx_base_rep *sort_idx (Array<octave_idx_type>&);
 
-    bool is_colon_equiv (octave_idx_type) const
-      { return true; }
+    bool is_colon_equiv (octave_idx_type) const { return true; }
 
     std::ostream& print (std::ostream& os) const;
 
   private:
 
     DECLARE_OCTAVE_ALLOCATOR
 
     // No copying!
@@ -174,18 +168,17 @@ private:
 
     idx_range_rep (const Range&);
 
     octave_idx_type xelem (octave_idx_type i) const
       { return start + i * step; }
 
     octave_idx_type checkelem (octave_idx_type i) const;
 
-    octave_idx_type length (octave_idx_type) const
-      { return len; }
+    octave_idx_type length (octave_idx_type) const { return len; }
 
     octave_idx_type extent (octave_idx_type n) const
       { return len ? std::max (n, (start + 1 + (step < 0 ? 0 : step * (len - 1)))) : n; }
 
     idx_class_type idx_class (void) const { return class_range; }
 
     idx_base_rep *sort_uniq_clone (bool uniq = false);
 
@@ -229,39 +222,36 @@ private:
       : data (0) { }
 
     // Zero-based constructor.
     idx_scalar_rep (octave_idx_type i);
 
     template <class T>
     idx_scalar_rep (T x);
 
-    octave_idx_type xelem (octave_idx_type) const
-      { return data; }
+    octave_idx_type xelem (octave_idx_type) const { return data; }
 
     octave_idx_type checkelem (octave_idx_type i) const;
 
-    octave_idx_type length (octave_idx_type) const
-      { return 1; }
+    octave_idx_type length (octave_idx_type) const { return 1; }
 
     octave_idx_type extent (octave_idx_type n) const
       { return std::max (n, data + 1); }
 
     idx_class_type idx_class (void) const { return class_scalar; }
 
     idx_base_rep *sort_uniq_clone (bool = false)
       { count++; return this; }
 
     idx_base_rep *sort_idx (Array<octave_idx_type>&);
 
     bool is_colon_equiv (octave_idx_type n) const
       { return n == 1 && data == 0; }
 
-    dim_vector orig_dimensions (void) const
-      { return dim_vector (1, 1); }
+    dim_vector orig_dimensions (void) const { return dim_vector (1, 1); }
 
     octave_idx_type get_data (void) const { return data; }
 
     std::ostream& print (std::ostream& os) const;
 
     double unconvert (void) const;
 
     Array<octave_idx_type> as_array (void);
@@ -302,35 +292,32 @@ private:
     idx_vector_rep (bool);
 
     idx_vector_rep (const Array<bool>&, octave_idx_type = -1);
 
     idx_vector_rep (const Sparse<bool>&);
 
     ~idx_vector_rep (void);
 
-    octave_idx_type xelem (octave_idx_type i) const
-      { return data[i]; }
+    octave_idx_type xelem (octave_idx_type i) const { return data[i]; }
 
     octave_idx_type checkelem (octave_idx_type i) const;
 
-    octave_idx_type length (octave_idx_type) const
-      { return len; }
+    octave_idx_type length (octave_idx_type) const { return len; }
 
     octave_idx_type extent (octave_idx_type n) const
       { return std::max (n, ext); }
 
     idx_class_type idx_class (void) const { return class_vector; }
 
     idx_base_rep *sort_uniq_clone (bool uniq = false);
 
     idx_base_rep *sort_idx (Array<octave_idx_type>&);
 
-    dim_vector orig_dimensions (void) const
-      { return orig_dims; }
+    dim_vector orig_dimensions (void) const { return orig_dims; }
 
     const octave_idx_type *get_data (void) const { return data; }
 
     std::ostream& print (std::ostream& os) const;
 
     Array<double> unconvert (void) const;
 
     Array<octave_idx_type> as_array (void);
@@ -340,21 +327,22 @@ private:
     DECLARE_OCTAVE_ALLOCATOR
 
     // No copying!
     idx_vector_rep (const idx_vector_rep& idx);
 
     const octave_idx_type *data;
     octave_idx_type len, ext;
 
-    // This is a trick to allow user-given zero-based arrays to be used as indices
-    // without copying. If the following pointer is nonzero, we do not own the data,
-    // but rather have an Array<octave_idx_type> object that provides us the data.
-    // Note that we need a pointer because we deferred the Array<T> declaration and
-    // we do not want it yet to be defined.
+    // This is a trick to allow user-given zero-based arrays to be used
+    // as indices without copying.  If the following pointer is nonzero,
+    // we do not own the data, but rather have an Array<octave_idx_type>
+    // object that provides us the data.  Note that we need a pointer
+    // because we deferred the Array<T> declaration and we do not want
+    // it yet to be defined.
     
     Array<octave_idx_type> *aowner;
 
     dim_vector orig_dims;
   };
 
   // The logical mask index.
   class OCTAVE_API idx_mask_rep : public idx_base_rep
@@ -374,31 +362,29 @@ private:
     idx_mask_rep (const Array<bool>&, octave_idx_type = -1);
 
     ~idx_mask_rep (void);
 
     octave_idx_type xelem (octave_idx_type i) const;
 
     octave_idx_type checkelem (octave_idx_type i) const;
 
-    octave_idx_type length (octave_idx_type) const
-      { return len; }
+    octave_idx_type length (octave_idx_type) const { return len; }
 
     octave_idx_type extent (octave_idx_type n) const
       { return std::max (n, ext); }
 
     idx_class_type idx_class (void) const { return class_mask; }
 
     idx_base_rep *sort_uniq_clone (bool = false) 
       { count++; return this; }
 
     idx_base_rep *sort_idx (Array<octave_idx_type>&);
 
-    dim_vector orig_dimensions (void) const
-      { return orig_dims; }
+    dim_vector orig_dimensions (void) const { return orig_dims; }
 
     bool is_colon_equiv (octave_idx_type n) const
       { return len == n && ext == n; }
 
     const bool *get_data (void) const { return data; }
 
     std::ostream& print (std::ostream& os) const;
 
@@ -411,50 +397,52 @@ private:
     DECLARE_OCTAVE_ALLOCATOR
 
     // No copying!
     idx_mask_rep (const idx_mask_rep& idx);
 
     const bool *data;
     octave_idx_type len, ext;
 
-    // FIXME: I'm not sure if this is a good design. Maybe it would be better to
-    // employ some sort of generalized iteration scheme.
+    // FIXME: I'm not sure if this is a good design. Maybe it would be
+    // better to employ some sort of generalized iteration scheme.
     mutable octave_idx_type lsti, lste;
 
-    // This is a trick to allow user-given mask arrays to be used as indices
-    // without copying. If the following pointer is nonzero, we do not own the data,
-    // but rather have an Array<bool> object that provides us the data.
-    // Note that we need a pointer because we deferred the Array<T> declaration and
-    // we do not want it yet to be defined.
+    // This is a trick to allow user-given mask arrays to be used as
+    // indices without copying.  If the following pointer is nonzero, we
+    // do not own the data, but rather have an Array<bool> object that
+    // provides us the data.  Note that we need a pointer because we
+    // deferred the Array<T> declaration and we do not want it yet to be
+    // defined.
     
     Array<bool> *aowner;
 
     dim_vector orig_dims;
   };
 
   idx_vector (idx_base_rep *r) : rep (r) { }
 
-  // The shared empty vector representation (for fast default constructor)
+  // The shared empty vector representation (for fast default
+  // constructor).
   static idx_vector_rep *nil_rep (void)
     {
       static idx_vector_rep ivr;
       return &ivr;
     }
 
   // The shared empty vector representation with the error flag set.
   static idx_vector_rep *err_rep (void)
     {
       static idx_vector_rep ivr;
       ivr.err = true;
       return &ivr;
     }
 
-  // If there was an error in constructing the rep, replace it with empty vector
-  // for safety.
+  // If there was an error in constructing the rep, replace it with
+  // empty vector for safety.
   void chkerr (void)
     {
       if (rep->err)
         {
           if (--rep->count == 0)
             delete rep;
           rep = err_rep ();
           rep->count++;
@@ -617,21 +605,23 @@ public:
   //   dest[i] = src[idx(i)];
   // return i;
   //
   template <class T>
   octave_idx_type
   index (const T *src, octave_idx_type n, T *dest) const
     {
       octave_idx_type len = rep->length (n);
+
       switch (rep->idx_class ())
         {
         case class_colon:
           copy_or_memcpy (len, src, dest);
           break;
+
         case class_range:
           {
             idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
             octave_idx_type start = r->get_start (), step = r->get_step ();
             const T *ssrc = src + start;
             if (step == 1)
               copy_or_memcpy (len, ssrc, dest);
             else if (step == -1)
@@ -640,39 +630,43 @@ public:
               std::fill_n (dest, len, *ssrc);
             else
               {
                 for (octave_idx_type i = 0, j = 0; i < len; i++, j += step)
                   dest[i] = ssrc[j];
               }
           }
           break;
+
         case class_scalar:
           {
             idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
             dest[0] = src[r->get_data ()];
           }
           break;
+
         case class_vector:
           {
             idx_vector_rep * r = dynamic_cast<idx_vector_rep *> (rep);
             const octave_idx_type *data = r->get_data ();
             for (octave_idx_type i = 0; i < len; i++)
               dest[i] = src[data[i]];
           }
           break;
+
         case class_mask:
           {
             idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
             const bool *data = r->get_data ();
             octave_idx_type ext = r->extent (0);
             for (octave_idx_type i = 0; i < ext; i++)
               if (data[i]) *dest++ = src[i];
           }
           break;
+
         default:
           assert (false);
           break;
         }
 
       return len;
     }
 
@@ -684,60 +678,66 @@ public:
   //   dest[idx(i)] = src[i];
   // return i;
   //
   template <class T>
   octave_idx_type
   assign (const T *src, octave_idx_type n, T *dest) const
     {
       octave_idx_type len = rep->length (n);
+
       switch (rep->idx_class ())
         {
         case class_colon:
           copy_or_memcpy (len, src, dest);
           break;
+
         case class_range:
           {
             idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
             octave_idx_type start = r->get_start (), step = r->get_step ();
             T *sdest = dest + start;
             if (step == 1)
               copy_or_memcpy (len, src, sdest);
             else if (step == -1)
               std::reverse_copy (src, src + len, sdest - len + 1);
             else
               {
                 for (octave_idx_type i = 0, j = 0; i < len; i++, j += step)
                   sdest[j] = src[i];
               }
           }
           break;
+
         case class_scalar:
           {
             idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
             dest[r->get_data ()] = src[0];
           }
           break;
+
         case class_vector:
           {
             idx_vector_rep * r = dynamic_cast<idx_vector_rep *> (rep);
             const octave_idx_type *data = r->get_data ();
             for (octave_idx_type i = 0; i < len; i++)
               dest[data[i]] = src[i];
           }
           break;
+
         case class_mask:
           {
             idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
             const bool *data = r->get_data ();
             octave_idx_type ext = r->extent (0);
             for (octave_idx_type i = 0; i < ext; i++)
               if (data[i]) dest[i] = *src++;
           }
           break;
+
         default:
           assert (false);
           break;
         }
 
       return len;
     }
 
@@ -749,181 +749,195 @@ public:
   //   dest[idx(i)] = val;
   // return i;
   //
   template <class T>
   octave_idx_type
   fill (const T& val, octave_idx_type n, T *dest) const
     {
       octave_idx_type len = rep->length (n);
+
       switch (rep->idx_class ())
         {
         case class_colon:
           std::fill (dest, dest + len, val);
           break;
+
         case class_range:
           {
             idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
             octave_idx_type start = r->get_start (), step = r->get_step ();
             T *sdest = dest + start;
             if (step == 1)
               std::fill (sdest, sdest + len, val);
             else if (step == -1)
               std::fill (sdest - len + 1, sdest + 1, val);
             else
               {
                 for (octave_idx_type i = 0, j = 0; i < len; i++, j += step)
                   sdest[j] = val;
               }
           }
           break;
+
         case class_scalar:
           {
             idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
             dest[r->get_data ()] = val;
           }
           break;
+
         case class_vector:
           {
             idx_vector_rep * r = dynamic_cast<idx_vector_rep *> (rep);
             const octave_idx_type *data = r->get_data ();
             for (octave_idx_type i = 0; i < len; i++)
               dest[data[i]] = val;
           }
           break;
+
         case class_mask:
           {
             idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
             const bool *data = r->get_data ();
             octave_idx_type ext = r->extent (0);
             for (octave_idx_type i = 0; i < ext; i++)
               if (data[i]) dest[i] = val;
           }
           break;
+
         default:
           assert (false);
           break;
         }
 
       return len;
     }
 
-  // Generic non-breakable indexed loop. The loop body should be encapsulated in a
-  // single functor body. 
-  // This is equivalent to the following loop (but faster, at least for simple
-  // inlined bodies):
+  // Generic non-breakable indexed loop. The loop body should be
+  // encapsulated in a single functor body.  This is equivalent to the
+  // following loop (but faster, at least for simple inlined bodies):
   //
   // for (octave_idx_type i = 0; i < idx->length (n); i++) body (idx(i));
-  // 
 
   template <class Functor>
   void
   loop (octave_idx_type n, Functor body) const
     {
       octave_idx_type len = rep->length (n);
+
       switch (rep->idx_class ())
         {
         case class_colon:
           for (octave_idx_type i = 0; i < len; i++) body (i);
           break;
+
         case class_range:
           {
             idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
             octave_idx_type start = r->get_start (), step = r->get_step ();
             octave_idx_type i, j;
             if (step == 1)
               for (i = start, j = start + len; i < j; i++) body (i);
             else if (step == -1)
               for (i = start, j = start - len; i > j; i--) body (i);
             else
               for (i = 0, j = start; i < len; i++, j += step) body (j);
           }
           break;
+
         case class_scalar:
           {
             idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
             body (r->get_data ());
           }
           break;
+
         case class_vector:
           {
             idx_vector_rep * r = dynamic_cast<idx_vector_rep *> (rep);
             const octave_idx_type *data = r->get_data ();
             for (octave_idx_type i = 0; i < len; i++) body (data[i]);
           }
           break;
+
         case class_mask:
           {
             idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
             const bool *data = r->get_data ();
             octave_idx_type ext = r->extent (0);
             for (octave_idx_type i = 0; i < ext; i++)
               if (data[i]) body (i);
           }
           break;
+
         default:
           assert (false);
           break;
         }
 
     }
 
-  // Generic breakable indexed loop. The loop body should be encapsulated in a
-  // single functor body. 
-  // This is equivalent to the following loop (but faster, at least for simple
-  // inlined bodies):
+  // Generic breakable indexed loop. The loop body should be
+  // encapsulated in a single functor body.  This is equivalent to the
+  // following loop (but faster, at least for simple inlined bodies):
   //
   // for (octave_idx_type i = 0; i < idx->length (n); i++)
   //   if (body (idx(i))) break;
   // return i;
   // 
 
   template <class Functor>
   octave_idx_type
   bloop (octave_idx_type n, Functor body) const
     {
       octave_idx_type len = rep->length (n), ret;
+
       switch (rep->idx_class ())
         {
         case class_colon:
           {
             octave_idx_type i;
             for (i = 0; i < len && body (i); i++) ;
             ret = i;
           }
           break;
+
         case class_range:
           {
             idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
             octave_idx_type start = r->get_start (), step = r->get_step ();
             octave_idx_type i, j;
             if (step == 1)
               for (i = start, j = start + len; i < j && body (i); i++) ;
             else if (step == -1)
               for (i = start, j = start - len; i > j && body (i); i--) ;
             else
               for (i = 0, j = start; i < len && body (j); i++, j += step) ;
             ret = i;
           }
           break;
+
         case class_scalar:
           {
             idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
             ret = body (r->get_data ()) ? 1 : 0;
           }
           break;
+
         case class_vector:
           {
             idx_vector_rep * r = dynamic_cast<idx_vector_rep *> (rep);
             const octave_idx_type *data = r->get_data ();
             octave_idx_type i;
             for (i = 0; i < len && body (data[i]); i++) ;
             ret = i;
           }
           break;
+
         case class_mask:
           {
             idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
             const bool *data = r->get_data ();
             octave_idx_type ext = r->extent (0), j = 0;
             for (octave_idx_type i = 0; i < ext; i++)
               {
                 if (data[i])
@@ -933,29 +947,30 @@ public:
                     else
                       j++;
                   }
               }
 
             ret = j;
           }
           break;
+
         default:
           assert (false);
           break;
         }
 
       return ret;
     }
 
   // Rationale: 
   // This method is the key to "smart indexing". When indexing cartesian
-  // arrays, sometimes consecutive index vectors can be reduced into a single
-  // index. If rows (A) = k and i.maybe_reduce (j) gives k, then A(i,j)(:) is
-  // equal to A(k)(:).
+  // arrays, sometimes consecutive index vectors can be reduced into a
+  // single index.  If rows (A) = k and i.maybe_reduce (j) gives k, then
+  // A(i,j)(:) is equal to A(k)(:).
 
   // If the next index can be reduced, returns true and updates this.
   bool maybe_reduce (octave_idx_type n, const idx_vector& j,
                      octave_idx_type nj);
 
   bool is_cont_range (octave_idx_type n,
                       octave_idx_type& l, octave_idx_type& u) const;
 
@@ -976,18 +991,18 @@ public:
 
   // Unconverts the index to a scalar, Range, double array or a mask.
   void unconvert (idx_class_type& iclass,
                   double& scalar, Range& range, 
                   Array<double>& array, Array<bool>& mask) const;
 
   Array<octave_idx_type> as_array (void) const;
 
-  // Raw pointer to index array.  This is non-const because it may be necessary
-  // to mutate the index.
+  // Raw pointer to index array.  This is non-const because it may be
+  // necessary to mutate the index.
   const octave_idx_type *raw (void);
     
   // FIXME -- these are here for compatibility.  They should be removed
   // when no longer in use.
 
   octave_idx_type elem (octave_idx_type n) const 
     { return (*this) (n); }
 
