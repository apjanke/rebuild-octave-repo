# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1527109977 14400
#      Wed May 23 17:12:57 2018 -0400
# Node ID ab10403a0b501d5e8316f86a31e8e5f650932b4a
# Parent  358cfc60b8e10e623ff96e29825bf65e843f7bfe
new input_system class to manage user input for the interpreter

Encapsulate many command-line input functions and data within a new
class that is a member of the interpreter object.

* input.h, input.cc (input_system): New class.  Include data members
for former static variables VPS1, VPS2, Vcompletion_append_char,
last_debugging_command, Vgud_mode, input_event_hook_functions, and
Vmfile_encoding.  Change all uses.

(is_variable, generate_struct_completions, looks_like_struct):
Move here from variables.cc and make static.

(set_default_prompts, octave_yes_or_no, do_keyboard,
remove_input_event_hook_functions, get_input_from_stdin): Deprecate.

(Fadd_input_event_hook, Fremove_input_event_hook, FPS1, FPS2,
Fcompletion_append_char, F__request_drawnow__, F__gud_mode__,
F__mfile_encoding__, Finput, Fyes_or_no): Define with DEFMETHOD.
Change all uses.

(input_system::have_input_event_hooks,
input_system::add_input_event_hook,
input_system::remove_input_event_hook,
input_system::clear_input_event_hooks,
input_system::run_input_event_hooks):
New functions to manage input event hooks.

(input_system::yes_or_no, input_system::interactive_input,
input_system::get_user_input, input_system::keyboard,
input_system::gnu_readline, input_system::get_debug_input):
New functions adapted from former file-scope static and global
functions.

* interpreter.h, interpreter.cc (interpreter::m_input_system):
New data member.
(interpreter::get_input_system): New function.
(interpreter::intepreter): Don't call set_default_prompts.  Call
input_system::initialize.
(interpreter::maximum_braindamage): Call input_system::PS1 and
input_system::PS2 directly here.

* variables.h, variables.cc (get_struct_elts): Deprecate.

* main-window.cc (octave_interpreter::m_app_context): Now pointer to
gui_application, not application.
(octave_interpreter::octave_interpreter): Arg is now
gui_application, not application.  Set default prompt strings directly
here.

* qt-link.h, qt-link.cc (octave_qt_link::do_set_default_prompts):
Delete.
* octave-link.h, octave-link.cc (octave_link::set_default_prompts,
octave_link::do_set_default_prompts): Delete.

* hook-fcn.h, hook-fcn.cc (named_hook_function::eval,
fcn_handle_hook_function::eval): Move code from .h to .cc file.
Make id and is_valid methods const.

* interpreter-private.h, interpreter-private.cc
(__get_input_system__): New function.

diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -82,17 +82,17 @@ create_default_editor (QWidget *p)
   octave_unused_parameter (p);
 
   return 0;
 #endif
 }
 
 namespace octave
 {
-  octave_interpreter::octave_interpreter (application *app_context)
+  octave_interpreter::octave_interpreter (gui_application *app_context)
     : QObject (), m_app_context (app_context)
   { }
 
   void octave_interpreter::execute (void)
   {
     // The application context owns the interpreter.
 
     interpreter& interp = m_app_context->create_interpreter ();
@@ -100,16 +100,28 @@ namespace octave
     int exit_status = 0;
 
     try
       {
         // Final initialization.
 
         interp.initialize ();
 
+        if (m_app_context->start_gui_p ())
+          {
+            input_system& input_sys = interp.get_input_system ();
+
+            input_sys.PS1 (">> ");
+            input_sys.PS2 ("");
+
+            tree_evaluator& tw = interp.get_evaluator ();
+
+            tw.PS4 ("");
+          }
+
         if (interp.initialized ())
           {
             // The interpreter should be completely ready at this point so let
             // the GUI know.
 
             emit octave_ready_signal ();
 
             // Start executing commands in the command window.
diff --git a/libgui/src/main-window.h b/libgui/src/main-window.h
--- a/libgui/src/main-window.h
+++ b/libgui/src/main-window.h
@@ -66,34 +66,34 @@ class octave_value;
 namespace octave
 {
   class octave_interpreter : public QObject
   {
     Q_OBJECT
 
   public:
 
-    octave_interpreter (application *app_context);
+    octave_interpreter (gui_application *app_context);
 
     ~octave_interpreter (void) = default;
 
   signals:
 
     void octave_ready_signal (void);
     void octave_finished_signal (int);
 
   public slots:
 
     //! Initialize and execute the octave interpreter.
 
     void execute (void);
 
   private:
 
-    application *m_app_context;
+    gui_application *m_app_context;
   };
 
   //! Represents the main window.
 
   class main_window : public QMainWindow
   {
     Q_OBJECT
 
diff --git a/libgui/src/octave-qt-link.cc b/libgui/src/octave-qt-link.cc
--- a/libgui/src/octave-qt-link.cc
+++ b/libgui/src/octave-qt-link.cc
@@ -478,28 +478,16 @@ namespace octave
                                              const std::string& file,
                                              int line,
                                              const std::string& cond)
   {
     emit update_breakpoint_marker_signal (insert, QString::fromStdString (file),
                                           line, QString::fromStdString (cond));
   }
 
-  void octave_qt_link::do_set_default_prompts (std::string& ps1,
-                                               std::string& ps2,
-                                               std::string& ps4)
-  {
-    if (m_app_context->start_gui_p ())
-      {
-        ps1 = ">> ";
-        ps2 = "";
-        ps4 = "";
-      }
-  }
-
   bool octave_qt_link::file_in_path (const std::string& file,
                                      const std::string& dir)
   {
 
     bool ok = false;
     bool addpath_option = true;
 
     std::string curr_dir = sys::env::get_current_directory ();
diff --git a/libgui/src/octave-qt-link.h b/libgui/src/octave-qt-link.h
--- a/libgui/src/octave-qt-link.h
+++ b/libgui/src/octave-qt-link.h
@@ -129,19 +129,16 @@ namespace octave
 
     void do_enter_debugger_event (const std::string& file, int line);
     void do_execute_in_debugger_event (const std::string& file, int line);
     void do_exit_debugger_event (void);
 
     void do_update_breakpoint (bool insert, const std::string& file, int line,
                                const std::string& cond);
 
-    void do_set_default_prompts (std::string& ps1, std::string& ps2,
-                                 std::string& ps4);
-
     static bool file_in_path (const std::string& file, const std::string& dir);
 
     void do_show_preferences (void);
 
     void do_show_doc (const std::string& file);
     void do_register_doc (const std::string& file);
     void do_unregister_doc (const std::string& file);
 
diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -245,18 +245,18 @@ Internal function called by mkdir.m.
 
       if (status < 0)
         return ovl (false, msg, "mkdir");
       else
         return ovl (true, "", "");
     }
 }
 
-DEFUNX ("rmdir", Frmdir, args, ,
-        doc: /* -*- texinfo -*-
+DEFMETHODX ("rmdir", Frmdir, interp, args, ,
+            doc: /* -*- texinfo -*-
 @deftypefn  {} {} rmdir @var{dir}
 @deftypefnx {} {} rmdir (@var{dir}, "s")
 @deftypefnx {} {[@var{status}, @var{msg}, @var{msgid}] =} rmdir (@dots{})
 Remove the directory named @var{dir}.
 
 If the optional second parameter is supplied with value @qcode{"s"},
 recursively remove all subdirectories as well.
 
@@ -285,19 +285,21 @@ identifier.
         error (R"(rmdir: second argument must be "s" for recursive removal)");
 
       bool doit = true;
 
       if (octave::application::interactive ()
           && ! octave::application::forced_interactive ()
           && Vconfirm_recursive_rmdir)
         {
+          octave::input_system& input_sys = interp.get_input_system ();
+
           std::string prompt = "remove entire contents of " + fulldir + "? ";
 
-          doit = octave_yes_or_no (prompt);
+          doit = input_sys.yes_or_no (prompt);
         }
 
       if (doit)
         status = octave::sys::recursive_rmdir (fulldir, msg);
     }
   else
     status = octave::sys::rmdir (fulldir, msg);
 
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -381,17 +381,20 @@ maybe_enter_debugger (octave::execution_
           if (! stack_trace.empty ())
             {
               std::cerr << stack_trace;
 
               e.set_stack_trace ();
             }
         }
 
-      do_keyboard (octave_value_list ());
+      octave::input_system& input_sys
+        = octave::__get_input_system__ ("maybe_enter_debugger");
+
+      input_sys.keyboard ();
     }
 }
 
 // Warning messages are never buffered.
 
 static void
 vwarning (const char *name, const char *id, const char *fmt, va_list args)
 {
@@ -765,22 +768,25 @@ warning_1 (const char *id, const char *f
            || octave::application::forced_interactive ())
           && Vdebug_on_warning && in_user_code && bptab.debug_on_warn (id))
         {
           octave::unwind_protect frame;
           frame.protect_var (Vdebug_on_warning);
           Vdebug_on_warning = false;
 
           octave::tree_evaluator& tw
-            = octave::__get_evaluator__ ("maybe_enter_debugger");
+            = octave::__get_evaluator__ ("warning_1");
 
           tw.debug_mode (true);
           tw.current_frame (cs.current_frame ());
 
-          do_keyboard (octave_value_list ());
+          octave::input_system& input_sys
+            = octave::__get_input_system__ ("warning_1");
+
+          input_sys.keyboard ();
         }
     }
 }
 
 void
 vwarning (const char *fmt, va_list args)
 {
   warning_1 ("", fmt, args);
diff --git a/libinterp/corefcn/hook-fcn.cc b/libinterp/corefcn/hook-fcn.cc
--- a/libinterp/corefcn/hook-fcn.cc
+++ b/libinterp/corefcn/hook-fcn.cc
@@ -20,24 +20,46 @@ along with Octave; see the file COPYING.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "hook-fcn.h"
+#include "parse.h"
 
 hook_function::hook_function (const octave_value& f, const octave_value& d)
 {
   if (f.is_string ())
     {
       std::string name = f.string_value ();
 
       rep = new named_hook_function (name, d);
     }
   else if (f.is_function_handle ())
     {
       rep = new fcn_handle_hook_function (f, d);
     }
   else
     error ("invalid hook function");
 }
+
+void named_hook_function::eval (const octave_value_list& initial_args)
+{
+  octave_value_list args = initial_args;
+
+  if (data.is_defined ())
+    args.append (data);
+
+  octave::feval (name, args, 0);
+}
+
+void fcn_handle_hook_function::eval (const octave_value_list& initial_args)
+{
+  octave_value_list args = initial_args;
+
+  if (data.is_defined ())
+    args.append (data);
+
+  octave::feval (fcn_handle, args, 0);
+}
+
diff --git a/libinterp/corefcn/hook-fcn.h b/libinterp/corefcn/hook-fcn.h
--- a/libinterp/corefcn/hook-fcn.h
+++ b/libinterp/corefcn/hook-fcn.h
@@ -25,35 +25,34 @@ along with Octave; see the file COPYING.
 
 #include "octave-config.h"
 
 #include <string>
 
 #include "ovl.h"
 #include "ov.h"
 #include "ov-fcn-handle.h"
-#include "parse.h"
 #include "variables.h"
 
 class
 base_hook_function
 {
 public:
 
   friend class hook_function;
 
   base_hook_function (void) : count (1) { }
 
   base_hook_function (const base_hook_function&) : count (1) { }
 
   virtual ~base_hook_function (void) = default;
 
-  virtual std::string id (void) { return ""; }
+  virtual std::string id (void) const { return ""; }
 
-  virtual bool is_valid (void) { return false; }
+  virtual bool is_valid (void) const { return false; }
 
   virtual void eval (const octave_value_list&) { }
 
 protected:
 
   size_t count;
 };
 
@@ -93,19 +92,19 @@ public:
 
         rep = hf.rep;
         rep->count++;
       }
 
     return *this;
   }
 
-  std::string id (void) { return rep->id (); }
+  std::string id (void) const { return rep->id (); }
 
-  bool is_valid (void) { return rep->is_valid (); }
+  bool is_valid (void) const { return rep->is_valid (); }
 
   void eval (const octave_value_list& initial_args)
   {
     rep->eval (initial_args);
   }
 
 private:
 
@@ -116,29 +115,21 @@ class
 named_hook_function : public base_hook_function
 {
 public:
 
   named_hook_function (const std::string& n, const octave_value& d)
     : name (n), data (d)
   { }
 
-  void eval (const octave_value_list& initial_args)
-  {
-    octave_value_list args = initial_args;
-
-    if (data.is_defined ())
-      args.append (data);
+  void eval (const octave_value_list& initial_args);
 
-    octave::feval (name, args, 0);
-  }
+  std::string id (void) const { return name; }
 
-  std::string id (void) { return name; }
-
-  bool is_valid (void) { return is_valid_function (name); }
+  bool is_valid (void) const { return is_valid_function (name); }
 
 private:
 
   std::string name;
 
   octave_value data;
 };
 
@@ -157,29 +148,21 @@ public:
         valid = true;
 
         std::ostringstream buf;
         buf << fh;
         ident = fh->fcn_name () + ':' + buf.str ();
       }
   }
 
-  void eval (const octave_value_list& initial_args)
-  {
-    octave_value_list args = initial_args;
-
-    if (data.is_defined ())
-      args.append (data);
+  void eval (const octave_value_list& initial_args);
 
-    octave::feval (fcn_handle, args, 0);
-  }
+  std::string id (void) const { return ident; }
 
-  std::string id (void) { return ident; }
-
-  bool is_valid (void) { return valid; }
+  bool is_valid (void) const { return valid; }
 
 private:
 
   std::string ident;
 
   bool valid;
 
   octave_value fcn_handle;
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -71,319 +71,210 @@ along with Octave; see the file COPYING.
 #include "pt-stmt.h"
 #include "sighandlers.h"
 #include "sysdep.h"
 #include "interpreter.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
-// Primary prompt string.
-static std::string VPS1;
-
-// Secondary prompt string.
-static std::string VPS2;
-
 // The time we last printed a prompt.
 octave::sys::time Vlast_prompt_time = 0.0;
 
-// Character to append after successful command-line completion attempts.
-static char Vcompletion_append_char = ' ';
-
 // TRUE after a call to completion_matches.
 bool octave_completion_matches_called = false;
 
 // TRUE if the plotting system has requested a call to drawnow at
 // the next user prompt.
 bool Vdrawnow_requested = false;
 
 // TRUE if we are in debugging mode.
 bool Vdebugging = false;
 
 // TRUE if we are recording line numbers in a source file.
 // Always true except when debugging and taking input directly from
 // the terminal.
 bool Vtrack_line_num = true;
 
-// If we are in debugging mode, this is the last command entered, so
-// that we can repeat the previous command if the user just types RET.
-static std::string last_debugging_command = "\n";
-
-// TRUE if we are running in the Emacs GUD mode.
-static bool Vgud_mode = false;
-
-static hook_function_list input_event_hook_functions;
-
-// Codepage which is used to read .m files
-#if defined (OCTAVE_USE_WINDOWS_API)
-static std::string Vmfile_encoding = "system";
-#else
-static std::string Vmfile_encoding = "utf-8";
-#endif
-
-// For octave_quit.
-void
-remove_input_event_hook_functions (void)
+static std::string
+quoting_filename (const std::string& text, int, char quote)
 {
-  input_event_hook_functions.clear ();
+  if (quote)
+    return text;
+  else
+    return ("'" + text);
 }
 
-void
-set_default_prompts (void)
+// Try to parse a partial command line in reverse, excluding trailing TEXT.
+// If it appears a variable has been indexed by () or {},
+// return that expression,
+// to allow autocomplete of field names of arrays of structures.
+static std::string
+find_indexed_expression (const std::string& text)
 {
-  // Use literal "octave" instead of "\\s" to avoid setting the prompt
-  // to "octave.exe" or "octave-gui", etc.
+  std::string line = octave::command_editor::get_line_buffer ();
+
+  int pos = line.length () - text.length ();
+  int curly_count = 0;
+  int paren_count = 0;
+
+  int last = --pos;
+
+  while (pos >= 0 && (line[pos] == ')' || line[pos] == '}'))
+    {
+      if (line[pos] == ')')
+        paren_count++;
+      else if (line[pos] == '}')
+        curly_count++;
 
-  VPS1 = R"(octave:\#> )";
-  VPS2 = "> ";
-  std::string VPS4 = "+ ";
+      while (curly_count + paren_count > 0 && --pos >= 0)
+        {
+          if (line[pos] == ')')
+            paren_count++;
+          else if (line[pos] == '(')
+            paren_count--;
+          else if (line[pos] == '}')
+            curly_count++;
+          else if (line[pos] == '{')
+            curly_count--;
+        }
 
-  octave_link::set_default_prompts (VPS1, VPS2, VPS4);
+      while (--pos >= 0 && line[pos] == ' ')
+        ;
+    }
+
+  while (pos >= 0 && (isalnum (line[pos]) || line[pos] == '_'))
+    pos--;
+
+  if (++pos >= 0)
+    return (line.substr (pos, last + 1 - pos));
+  else
+    return std::string ();
 }
 
-static std::string
-gnu_readline (const std::string& s, bool& eof)
+static inline bool
+is_variable (octave::symbol_table& symtab, const std::string& name)
 {
-  octave_quit ();
+  bool retval = false;
 
-  eof = false;
+  if (! name.empty ())
+    {
+      octave::symbol_scope scope = symtab.current_scope ();
 
-  std::string retval = octave::command_editor::readline (s, eof);
+      octave_value val = scope ? scope.varval (name) : octave_value ();
 
-  if (! eof && retval.empty ())
-    retval = "\n";
+      retval = val.is_defined ();
+    }
 
   return retval;
 }
 
-static inline std::string
-interactive_input (const std::string& s, bool& eof)
+static string_vector
+generate_struct_completions (const std::string& text,
+                             std::string& prefix, std::string& hint)
 {
-  Vlast_prompt_time.stamp ();
+  string_vector names;
+
+  size_t pos = text.rfind ('.');
+  bool array = false;
 
-  if (Vdrawnow_requested && octave::application::interactive ())
+  if (pos != std::string::npos)
     {
-      bool eval_error = false;
+      if (pos == text.length ())
+        hint = "";
+      else
+        hint = text.substr (pos+1);
 
-      try
+      prefix = text.substr (0, pos);
+
+      if (prefix == "")
         {
-          Fdrawnow ();
-        }
-      catch (const octave::execution_exception& e)
-        {
-          eval_error = true;
-
-          std::string stack_trace = e.info ();
-
-          if (! stack_trace.empty ())
-            std::cerr << stack_trace;
-
-          if (octave::application::interactive ())
-            octave::interpreter::recover_from_exception ();
+          array = true;
+          prefix = find_indexed_expression (text);
         }
 
-      octave::flush_stdout ();
+      std::string base_name = prefix;
+
+      pos = base_name.find_first_of ("{(. ");
+
+      if (pos != std::string::npos)
+        base_name = base_name.substr (0, pos);
 
-      // We set Vdrawnow_requested to false even if there is an error in
-      // drawnow so that the error doesn't reappear at every prompt.
+      octave::symbol_table& symtab
+        = octave::__get_symbol_table__ ("generate_struct_completions");
+
+      if (is_variable (symtab, base_name))
+        {
+          int parse_status;
+
+          octave::unwind_protect frame;
+
+          frame.protect_var (discard_error_messages);
+          frame.protect_var (discard_warning_messages);
 
-      Vdrawnow_requested = false;
+          discard_error_messages = true;
+          discard_warning_messages = true;
+
+          try
+            {
+              octave_value tmp = octave::eval_string (prefix, true, parse_status);
+
+              frame.run ();
 
-      if (eval_error)
-        return "\n";
+              if (tmp.is_defined ()
+                  && (tmp.isstruct () || tmp.isjava () || tmp.is_classdef_object ()))
+                names = tmp.map_keys ();
+            }
+          catch (const octave::execution_exception&)
+            {
+              octave::interpreter::recover_from_exception ();
+            }
+        }
     }
 
-  return gnu_readline (s, eof);
+  // Undo look-back that found the array expression,
+  // but insert an extra "." to distinguish from the non-struct case.
+  if (array)
+    prefix = ".";
+
+  return names;
 }
 
-namespace octave
+// FIXME: this will have to be much smarter to work "correctly".
+static bool
+looks_like_struct (const std::string& text, char prev_char)
 {
-  std::string base_reader::octave_gets (bool& eof)
-  {
-    octave_quit ();
-
-    eof = false;
-
-    std::string retval;
-
-    // Process pre input event hook function prior to flushing output and
-    // printing the prompt.
-
-    if (application::interactive ())
-      {
-        if (! Vdebugging)
-          octave_link::exit_debugger_event ();
-
-        octave_link::pre_input_event ();
-
-        octave_link::set_workspace ();
-      }
-
-    bool history_skip_auto_repeated_debugging_command = false;
-
-    std::string ps = (m_pflag > 0) ? VPS1 : VPS2;
-
-    std::string prompt = command_editor::decode_prompt_string (ps);
-
-    pipe_handler_error_count = 0;
-
-    flush_stdout ();
-
-    pager_stream::reset ();
-    diary_stream::reset ();
-
-    octave_diary << prompt;
-
-    retval = interactive_input (prompt, eof);
+  bool retval = (! text.empty ()
+                 && (text != "." || prev_char == ')' || prev_char == '}')
+                 && text.find_first_of (octave::sys::file_ops::dir_sep_chars ()) == std::string::npos
+                 && text.find ("..") == std::string::npos
+                 && text.rfind ('.') != std::string::npos);
 
-    // There is no need to update the load_path cache if there is no
-    // user input.
-    if (retval != "\n"
-        && retval.find_first_not_of (" \t\n\r") != std::string::npos)
-      {
-        load_path& lp = __get_load_path__ ("base_reader::octave_gets");
-
-        lp.update ();
-
-        if (Vdebugging)
-          last_debugging_command = retval;
-        else
-          last_debugging_command = "\n";
-      }
-    else if (Vdebugging)
-      {
-        retval = last_debugging_command;
-        history_skip_auto_repeated_debugging_command = true;
-      }
-
-    if (retval != "\n")
-      {
-        if (! history_skip_auto_repeated_debugging_command)
-          {
-            if (command_history::add (retval))
-              octave_link::append_history (retval);
-          }
-
-        octave_diary << retval;
-
-        if (retval.back () != '\n')
-          octave_diary << "\n";
-      }
-    else
-      octave_diary << "\n";
-
-    // Process post input event hook function after the internal history
-    // list has been updated.
-
-    if (application::interactive ())
-      octave_link::post_input_event ();
-
-    return retval;
-  }
-
-  bool base_reader::reading_fcn_file (void) const
-  {
-    return m_lexer ? m_lexer->m_reading_fcn_file : false;
-  }
+#if 0
+  symbol_record *sr = curr_sym_tab->lookup (text);
 
-  bool base_reader::reading_classdef_file (void) const
-  {
-    return m_lexer ? m_lexer->m_reading_classdef_file : false;
-  }
-
-  bool base_reader::reading_script_file (void) const
-  {
-    return m_lexer ? m_lexer->m_reading_script_file : false;
-  }
-
-  class
-  terminal_reader : public base_reader
-  {
-  public:
-
-    terminal_reader (base_lexer *lxr = nullptr)
-      : base_reader (lxr)
-    { }
-
-    std::string get_input (bool& eof);
-
-    std::string input_source (void) const { return s_in_src; }
+  if (sr && ! sr->is_function ())
+    {
+      int parse_status;
 
-    bool input_from_terminal (void) const { return true; }
-
-  private:
-
-    static const std::string s_in_src;
-  };
-
-  class
-  file_reader : public base_reader
-  {
-  public:
+      octave::unwind_protect frame;
 
-    file_reader (FILE *f_arg, base_lexer *lxr = nullptr)
-      : base_reader (lxr), m_file (f_arg) { }
-
-    std::string get_input (bool& eof);
+      frame.protect_var (discard_error_messages);
 
-    std::string input_source (void) const { return s_in_src; }
-
-    bool input_from_file (void) const { return true; }
-
-  private:
-
-    FILE *m_file;
+      discard_error_messages = true;
 
-    static const std::string s_in_src;
-  };
-
-  class
-  eval_string_reader : public base_reader
-  {
-  public:
+      octave_value tmp = eval_string (text, true, parse_status);
 
-    eval_string_reader (const std::string& str, base_lexer *lxr = nullptr)
-      : base_reader (lxr), m_eval_string (str)
-    { }
-
-    std::string get_input (bool& eof);
-
-    std::string input_source (void) const { return s_in_src; }
-
-    bool input_from_eval_string (void) const { return true; }
-
-  private:
-
-    std::string m_eval_string;
+      frame.run ();
 
-    static const std::string s_in_src;
-  };
-
-  input_reader::input_reader (base_lexer *lxr)
-    : m_rep (new terminal_reader (lxr))
-  { }
-
-  input_reader::input_reader (FILE *file, base_lexer *lxr)
-    : m_rep (new file_reader (file, lxr))
-  { }
+      retval = (tmp.is_defined () && tmp.isstruct ());
+    }
+#endif
 
-  input_reader::input_reader (const std::string& str, base_lexer *lxr)
-    : m_rep (new eval_string_reader (str, lxr))
-  { }
-}
-
-// Fix things up so that input can come from the standard input.  This
-// may need to become much more complicated, which is why it's in a
-// separate function.
-
-FILE *
-get_input_from_stdin (void)
-{
-  octave::command_editor::set_input_stream (stdin);
-  return octave::command_editor::get_input_stream ();
+  return retval;
 }
 
 // FIXME: make this generate filenames when appropriate.
 
 static string_vector
 generate_possible_completions (const std::string& text, std::string& prefix,
                                std::string& hint, bool& deemed_struct)
 {
@@ -513,260 +404,690 @@ generate_completion (const std::string& 
               if (matches == 1 && looks_like_struct (retval, prev_char))
                 {
                   // Don't append anything, since we don't know
                   // whether it should be '(' or '.'.
 
                   octave::command_editor::set_completion_append_character ('\0');
                 }
               else
-                octave::command_editor::set_completion_append_character
-                  (Vcompletion_append_char);
+                {
+                  octave::input_system& input_sys
+                    = octave::__get_input_system__ ("generate_completion");
+
+                  octave::command_editor::set_completion_append_character
+                    (input_sys.completion_append_char ());
+                }
 
               break;
             }
         }
     }
 
   return retval;
 }
 
-static std::string
-quoting_filename (const std::string& text, int, char quote)
+namespace octave
 {
-  if (quote)
-    return text;
-  else
-    return ("'" + text);
-}
-
-// Try to parse a partial command line in reverse, excluding trailing TEXT.
-// If it appears a variable has been indexed by () or {},
-// return that expression,
-// to allow autocomplete of field names of arrays of structures.
-std::string
-find_indexed_expression (const std::string& text)
-{
-  std::string line = octave::command_editor::get_line_buffer ();
+  // Use literal "octave" in default setting for PS1 instead of
+  // "\\s" to avoid setting the prompt to "octave.exe" or
+  // "octave-gui", etc.
 
-  int pos = line.length () - text.length ();
-  int curly_count = 0;
-  int paren_count = 0;
+  input_system::input_system (interpreter& interp)
+    : m_interpreter (interp), m_PS1 (R"(octave:\#> )"), m_PS2 ("> "),
+      m_completion_append_char (' '), m_gud_mode (false),
+      m_mfile_encoding ("utf-8"), m_last_debugging_command ("\n"),
+      m_input_event_hook_functions ()
+  {
+#if defined (OCTAVE_USE_WINDOWS_API)
+    m_mfile_encoding = "system";
+#endif
+  }
 
-  int last = --pos;
-
-  while (pos >= 0 && (line[pos] == ')' || line[pos] == '}'))
+    void input_system::initialize (bool line_editing)
     {
-      if (line[pos] == ')')
-        paren_count++;
-      else if (line[pos] == '}')
-        curly_count++;
-
-      while (curly_count + paren_count > 0 && --pos >= 0)
+// Force default line editor if we don't want readline editing.
+      if (! line_editing)
         {
-          if (line[pos] == ')')
-            paren_count++;
-          else if (line[pos] == '(')
-            paren_count--;
-          else if (line[pos] == '}')
-            curly_count++;
-          else if (line[pos] == '{')
-            curly_count--;
+          command_editor::force_default_editor ();
+          return;
         }
 
-      while (--pos >= 0 && line[pos] == ' ')
-        ;
-    }
+      // If we are using readline, this allows conditional parsing of the
+      // .inputrc file.
+
+      octave::command_editor::set_name ("Octave");
+
+      // FIXME: this needs to include a comma too, but that
+      // causes trouble for the new struct element completion code.
+
+      static const char *s = "\t\n !\"\'*+-/:;<=>(){}[\\]^`~";
+
+      octave::command_editor::set_basic_word_break_characters (s);
+
+      octave::command_editor::set_completer_word_break_characters (s);
 
-  while (pos >= 0 && (isalnum (line[pos]) || line[pos] == '_'))
-    pos--;
+      octave::command_editor::set_basic_quote_characters (R"(")");
+
+      octave::command_editor::set_filename_quote_characters (" \t\n\\\"'@<>=;|&()#$`?*[!:{");
+
+      octave::command_editor::set_completer_quote_characters (R"('")");
+
+      octave::command_editor::set_completion_function (generate_completion);
+
+      octave::command_editor::set_quoting_function (quoting_filename);
+  }
+
+  octave_value
+  input_system::PS1 (const octave_value_list& args, int nargout)
+  {
+    return set_internal_variable (m_PS1, args, nargout, "PS1");
+  }
 
-  if (++pos >= 0)
-    return (line.substr (pos, last + 1 - pos));
-  else
-    return std::string ();
-}
+  octave_value
+  input_system::PS2 (const octave_value_list& args, int nargout)
+  {
+    return set_internal_variable (m_PS2, args, nargout, "PS2");
+  }
+
+  octave_value
+  input_system::completion_append_char (const octave_value_list& args,
+                                        int nargout)
+  {
+    return set_internal_variable (m_completion_append_char, args, nargout,
+                                  "completion_append_char");
+  }
 
-void
-initialize_command_input (void)
-{
-  // If we are using readline, this allows conditional parsing of the
-  // .inputrc file.
+  octave_value
+  input_system::gud_mode (const octave_value_list& args, int nargout)
+  {
+    return set_internal_variable (m_gud_mode, args, nargout, "__gud_mode__");
+  }
 
-  octave::command_editor::set_name ("Octave");
+  octave_value
+  input_system::mfile_encoding (const octave_value_list& args, int nargout)
+  {
+    // Save current value in case there is an error in the additional
+    // validation below.
+
+    std::string saved_encoding = m_mfile_encoding;
+
+    // We must pass the actual variable to change here for temporary
+    // "local" settings to work properly.
+
+    octave_value retval
+      = set_internal_variable (m_mfile_encoding, args, nargout,
+                               "__mfile_encoding__");
+
+    // Additional validation if the encoding has changed.
 
-  // FIXME: this needs to include a comma too, but that
-  // causes trouble for the new struct element completion code.
+    if (m_mfile_encoding != saved_encoding)
+      {
+        if (m_mfile_encoding.empty ())
+          {
+#if defined (OCTAVE_USE_WINDOWS_API)
+            m_mfile_encoding = "system";
+#else
+            m_mfile_encoding = "utf-8";
+#endif
+          }
+        else
+          {
+            std::transform (m_mfile_encoding.begin (),
+                            m_mfile_encoding.end (),
+                            m_mfile_encoding.begin (), ::tolower);
 
-  static const char *s = "\t\n !\"\'*+-/:;<=>(){}[\\]^`~";
+            std::string codepage = (m_mfile_encoding.compare ("system") == 0)
+              ? octave_locale_charset_wrapper () : m_mfile_encoding;
 
-  octave::command_editor::set_basic_word_break_characters (s);
+            // Check for valid codepage.
+            void *codec
+              = octave_iconv_open_wrapper (codepage.c_str (), "utf-8");
+
+            if (errno == EINVAL)
+              {
+                m_mfile_encoding = saved_encoding;
 
-  octave::command_editor::set_completer_word_break_characters (s);
+                error ("__mfile_encoding__: conversion from codepage '%s' not supported",
+                       codepage.c_str ());
+              }
 
-  octave::command_editor::set_basic_quote_characters (R"(")");
+            octave_iconv_close_wrapper (codec);
+          }
+      }
+
+    return retval;
+  }
+
+  bool input_system::yes_or_no (const std::string& prompt)
+  {
+    std::string prompt_string = prompt + "(yes or no) ";
 
-  octave::command_editor::set_filename_quote_characters (" \t\n\\\"'@<>=;|&()#$`?*[!:{");
-  octave::command_editor::set_completer_quote_characters (R"('")");
+    while (1)
+      {
+        bool eof = false;
+
+        std::string input_buf = interactive_input (prompt_string, eof);
 
-  octave::command_editor::set_completion_function (generate_completion);
+        if (input_buf == "yes")
+          return true;
+        else if (input_buf == "no")
+          return false;
+        else
+          message (nullptr, "Please answer yes or no.");
+      }
+  }
+
+  std::string input_system::interactive_input (const std::string& s, bool& eof)
+  {
+    Vlast_prompt_time.stamp ();
+
+    if (Vdrawnow_requested && octave::application::interactive ())
+      {
+        bool eval_error = false;
 
-  octave::command_editor::set_quoting_function (quoting_filename);
-}
+        try
+          {
+            Fdrawnow ();
+          }
+        catch (const octave::execution_exception& e)
+          {
+            eval_error = true;
+
+            std::string stack_trace = e.info ();
 
-static void
-execute_in_debugger_handler (const std::pair<std::string, int>& arg)
-{
-  octave_link::execute_in_debugger_event (arg.first, arg.second);
-}
+            if (! stack_trace.empty ())
+              std::cerr << stack_trace;
+
+            if (octave::application::interactive ())
+              octave::interpreter::recover_from_exception ();
+          }
+
+        octave::flush_stdout ();
+
+        // We set Vdrawnow_requested to false even if there is an error in
+        // drawnow so that the error doesn't reappear at every prompt.
+
+        Vdrawnow_requested = false;
 
-static void
-get_debug_input (octave::interpreter& interp, const std::string& prompt)
-{
-  octave::unwind_protect frame;
+        if (eval_error)
+          return "\n";
+      }
+
+    return gnu_readline (s, eof);
+  }
+
+  // If the user simply hits return, this will produce an empty matrix.
+
+  octave_value_list
+  input_system::get_user_input (const octave_value_list& args, int nargout)
+  {
+    octave_value_list retval;
+
+    int read_as_string = 0;
+
+    if (args.length () == 2)
+      read_as_string++;
 
-  octave::tree_evaluator& tw = interp.get_evaluator ();
+    std::string prompt = args(0).xstring_value ("input: unrecognized argument");
+
+    octave::flush_stdout ();
+
+    octave::pager_stream::reset ();
+    octave::diary_stream::reset ();
+
+    octave_diary << prompt;
 
-  bool silent = tw.quiet_breakpoint_flag (false);
+    bool eof = false;
+
+    std::string input_buf = interactive_input (prompt.c_str (), eof);
 
-  octave::call_stack& cs = interp.get_call_stack ();
+    if (input_buf.empty ())
+      error ("input: reading user-input failed!");
+
+    size_t len = input_buf.length ();
+
+    octave_diary << input_buf;
 
-  octave_user_code *caller = cs.caller_user_code ();
-  std::string nm;
-  int curr_debug_line;
+    if (input_buf[len - 1] != '\n')
+      octave_diary << "\n";
+
+    if (len < 1)
+      return read_as_string ? octave_value ("") : octave_value (Matrix ());
+
+    if (read_as_string)
+      {
+        // FIXME: fix gnu_readline and octave_gets instead!
+        if (input_buf.length () == 1 && input_buf[0] == '\n')
+          retval(0) = "";
+        else
+          retval(0) = input_buf;
+      }
+    else
+      {
+        int parse_status = 0;
+
+        retval = octave::eval_string (input_buf, true, parse_status, nargout);
 
-  if (caller)
-    {
-      nm = caller->fcn_file_name ();
+        if (! Vdebugging && retval.empty ())
+          retval(0) = Matrix ();
+      }
+
+    return retval;
+  }
 
-      if (nm.empty ())
-        nm = caller->name ();
+  octave_value input_system::keyboard (const octave_value_list& args)
+  {
+    octave_value retval;
+
+    int nargin = args.length ();
+
+    assert (nargin == 0 || nargin == 1);
+
+    octave::unwind_protect frame;
+
+    frame.add_fcn (octave::command_history::ignore_entries,
+                   octave::command_history::ignoring_entries ());
 
-      curr_debug_line = cs.caller_user_code_line ();
-    }
-  else
-    curr_debug_line = cs.current_line ();
+    octave::command_history::ignore_entries (false);
+
+    frame.protect_var (Vdebugging);
+
+    octave::call_stack& cs = m_interpreter.get_call_stack ();
+
+    frame.add_method (cs, &octave::call_stack::restore_frame,
+                      cs.current_frame ());
+
+    // FIXME: probably we just want to print one line, not the
+    // entire statement, which might span many lines...
+    //
+    // tree_print_code tpc (octave_stdout);
+    // stmt.accept (tpc);
+
+    Vdebugging = true;
+    Vtrack_line_num = false;
 
-  std::ostringstream buf;
+    std::string prompt = "debug> ";
+    if (nargin > 0)
+      prompt = args(0).string_value ();
+
+    get_debug_input (prompt);
+
+    return retval;
+  }
+
+  bool input_system::have_input_event_hooks (void) const
+  {
+    return ! m_input_event_hook_functions.empty ();
+  }
+
+  void input_system::add_input_event_hook (const hook_function& hook_fcn)
+  {
+    m_input_event_hook_functions.insert (hook_fcn.id (), hook_fcn);
+  }
 
-  if (! nm.empty ())
-    {
-      if (Vgud_mode)
-        {
-          static char ctrl_z = 'Z' & 0x1f;
+  bool input_system::remove_input_event_hook (const std::string& hook_fcn_id)
+  {
+    hook_function_list::iterator p
+      = m_input_event_hook_functions.find (hook_fcn_id);
+
+    if (p == m_input_event_hook_functions.end ())
+      return false;
+
+    m_input_event_hook_functions.erase (p);
+    return true;
+  }
+
+  void input_system::clear_input_event_hooks (void)
+  {
+    m_input_event_hook_functions.clear ();
+  }
 
-          buf << ctrl_z << ctrl_z << nm << ':' << curr_debug_line;
-        }
-      else
-        {
-          // FIXME: we should come up with a clean way to detect
-          // that we are stopped on the no-op command that marks the
-          // end of a function or script.
+  void input_system::run_input_event_hooks (void)
+  {
+    m_input_event_hook_functions.run ();
+  }
+
+  std::string
+  input_system::gnu_readline (const std::string& s, bool& eof) const
+  {
+    octave_quit ();
+
+    eof = false;
 
-          if (! silent)
-            {
-              buf << "stopped in " << nm;
+    std::string retval = octave::command_editor::readline (s, eof);
+
+    if (! eof && retval.empty ())
+      retval = "\n";
+
+    return retval;
+  }
+
+  static void
+  execute_in_debugger_handler (const std::pair<std::string, int>& arg)
+  {
+    octave_link::execute_in_debugger_event (arg.first, arg.second);
+  }
 
-              if (curr_debug_line > 0)
-                buf << " at line " << curr_debug_line;
-            }
+  void input_system::get_debug_input (const std::string& prompt)
+  {
+    octave::unwind_protect frame;
+
+    octave::tree_evaluator& tw = m_interpreter.get_evaluator ();
+
+    bool silent = tw.quiet_breakpoint_flag (false);
+
+    octave::call_stack& cs = m_interpreter.get_call_stack ();
+
+    octave_user_code *caller = cs.caller_user_code ();
+    std::string nm;
+    int curr_debug_line;
 
-          octave_link::enter_debugger_event (nm, curr_debug_line);
+    if (caller)
+      {
+        nm = caller->fcn_file_name ();
+
+        if (nm.empty ())
+          nm = caller->name ();
 
-          octave_link::set_workspace ();
+        curr_debug_line = cs.caller_user_code_line ();
+      }
+    else
+      curr_debug_line = cs.current_line ();
 
-          frame.add_fcn (execute_in_debugger_handler,
-                         std::pair<std::string, int> (nm, curr_debug_line));
+    std::ostringstream buf;
+
+    if (! nm.empty ())
+      {
+        if (m_gud_mode)
+          {
+            static char ctrl_z = 'Z' & 0x1f;
 
-          if (! silent)
-            {
-              std::string line_buf;
+            buf << ctrl_z << ctrl_z << nm << ':' << curr_debug_line;
+          }
+        else
+          {
+            // FIXME: we should come up with a clean way to detect
+            // that we are stopped on the no-op command that marks the
+            // end of a function or script.
+
+            if (! silent)
+              {
+                buf << "stopped in " << nm;
+
+                if (curr_debug_line > 0)
+                  buf << " at line " << curr_debug_line;
+              }
+
+            octave_link::enter_debugger_event (nm, curr_debug_line);
+
+            octave_link::set_workspace ();
 
-              if (caller)
-                line_buf = caller->get_code_line (curr_debug_line);
+            frame.add_fcn (execute_in_debugger_handler,
+                           std::pair<std::string, int> (nm, curr_debug_line));
+
+            if (! silent)
+              {
+                std::string line_buf;
+
+                if (caller)
+                  line_buf = caller->get_code_line (curr_debug_line);
 
-              if (! line_buf.empty ())
-                buf << "\n" << curr_debug_line << ": " << line_buf;
-            }
-        }
-    }
+                if (! line_buf.empty ())
+                  buf << "\n" << curr_debug_line << ": " << line_buf;
+              }
+          }
+      }
+
+    if (silent)
+      octave::command_editor::erase_empty_line (true);
+
+    std::string msg = buf.str ();
+
+    if (! msg.empty ())
+      std::cerr << msg << std::endl;
 
-  if (silent)
-    octave::command_editor::erase_empty_line (true);
+    frame.add_method (*this, &octave::input_system::set_PS1, m_PS1);
+    m_PS1 = prompt;
+
+    // FIXME: should debugging be possible in an embedded interpreter?
+
+    octave::application *app = octave::application::app ();
 
-  std::string msg = buf.str ();
+    if (! app->interactive ())
+      {
+
+        frame.add_method (app, &octave::application::interactive,
+                          app->interactive ());
+
+        frame.add_method (app, &octave::application::forced_interactive,
+                          app->forced_interactive ());
 
-  if (! msg.empty ())
-    std::cerr << msg << std::endl;
+        app->interactive (true);
+
+        app->forced_interactive (true);
+      }
+
+    octave::parser curr_parser;
 
-  frame.protect_var (VPS1);
-  VPS1 = prompt;
+    while (Vdebugging)
+      {
+        try
+          {
+            Vtrack_line_num = false;
+
+            reset_error_handler ();
+
+            curr_parser.reset ();
+
+            int retval = curr_parser.run ();
 
-  // FIXME: should debugging be possible in an embedded interpreter?
+            if (octave::command_editor::interrupt (false))
+              break;
+            else
+              {
+                if (retval == 0 && curr_parser.m_stmt_list)
+                  {
+                    curr_parser.m_stmt_list->accept (tw);
 
-  octave::application *app = octave::application::app ();
+                    if (octave_completion_matches_called)
+                      octave_completion_matches_called = false;
+                  }
+
+                octave_quit ();
+              }
+          }
+        catch (const octave::execution_exception& e)
+          {
+            std::string stack_trace = e.info ();
+
+            if (! stack_trace.empty ())
+              std::cerr << stack_trace;
 
-  if (! app->interactive ())
-    {
+            // Ignore errors when in debugging mode;
+            octave::interpreter::recover_from_exception ();
+          }
+      }
+  }
+
+  std::string base_reader::octave_gets (bool& eof)
+  {
+    octave_quit ();
 
-      frame.add_method (app, &octave::application::interactive,
-                        app->interactive ());
+    eof = false;
+
+    std::string retval;
 
-      frame.add_method (app, &octave::application::forced_interactive,
-                        app->forced_interactive ());
+    // Process pre input event hook function prior to flushing output and
+    // printing the prompt.
+
+    if (application::interactive ())
+      {
+        if (! Vdebugging)
+          octave_link::exit_debugger_event ();
 
-      app->interactive (true);
+        octave_link::pre_input_event ();
+
+        octave_link::set_workspace ();
+      }
+
+    bool history_skip_auto_repeated_debugging_command = false;
+
+    input_system& input_sys = __get_input_system__ ("base_reader::octave_gets");
+
+    std::string ps = (m_pflag > 0) ? input_sys.PS1 () : input_sys.PS2 ();
+
+    std::string prompt = command_editor::decode_prompt_string (ps);
+
+    pipe_handler_error_count = 0;
 
-      app->forced_interactive (true);
-    }
+    flush_stdout ();
+
+    pager_stream::reset ();
+    diary_stream::reset ();
+
+    octave_diary << prompt;
+
+    retval = input_sys.interactive_input (prompt, eof);
 
-  octave::parser curr_parser;
+    // There is no need to update the load_path cache if there is no
+    // user input.
+    if (retval != "\n"
+        && retval.find_first_not_of (" \t\n\r") != std::string::npos)
+      {
+        load_path& lp = __get_load_path__ ("base_reader::octave_gets");
+
+        lp.update ();
 
-  while (Vdebugging)
-    {
-      try
-        {
-          Vtrack_line_num = false;
+        if (Vdebugging)
+          input_sys.last_debugging_command (retval);
+        else
+          input_sys.last_debugging_command ("\n");
+      }
+    else if (Vdebugging)
+      {
+        retval = input_sys.last_debugging_command ();
+        history_skip_auto_repeated_debugging_command = true;
+      }
+
+    if (retval != "\n")
+      {
+        if (! history_skip_auto_repeated_debugging_command)
+          {
+            if (command_history::add (retval))
+              octave_link::append_history (retval);
+          }
+
+        octave_diary << retval;
 
-          reset_error_handler ();
+        if (retval.back () != '\n')
+          octave_diary << "\n";
+      }
+    else
+      octave_diary << "\n";
+
+    // Process post input event hook function after the internal history
+    // list has been updated.
+
+    if (application::interactive ())
+      octave_link::post_input_event ();
 
-          curr_parser.reset ();
+    return retval;
+  }
 
-          int retval = curr_parser.run ();
+  bool base_reader::reading_fcn_file (void) const
+  {
+    return m_lexer ? m_lexer->m_reading_fcn_file : false;
+  }
+
+  bool base_reader::reading_classdef_file (void) const
+  {
+    return m_lexer ? m_lexer->m_reading_classdef_file : false;
+  }
 
-          if (octave::command_editor::interrupt (false))
-            break;
-          else
-            {
-              if (retval == 0 && curr_parser.m_stmt_list)
-                {
-                  curr_parser.m_stmt_list->accept (tw);
+  bool base_reader::reading_script_file (void) const
+  {
+    return m_lexer ? m_lexer->m_reading_script_file : false;
+  }
+
+  class
+  terminal_reader : public base_reader
+  {
+  public:
+
+    terminal_reader (base_lexer *lxr = nullptr)
+      : base_reader (lxr)
+    { }
+
+    std::string get_input (bool& eof);
+
+    std::string input_source (void) const { return s_in_src; }
 
-                  if (octave_completion_matches_called)
-                    octave_completion_matches_called = false;
-                }
+    bool input_from_terminal (void) const { return true; }
+
+  private:
+
+    static const std::string s_in_src;
+  };
+
+  class
+  file_reader : public base_reader
+  {
+  public:
+
+    file_reader (FILE *f_arg, base_lexer *lxr = nullptr)
+      : base_reader (lxr), m_file (f_arg) { }
+
+    std::string get_input (bool& eof);
+
+    std::string input_source (void) const { return s_in_src; }
+
+    bool input_from_file (void) const { return true; }
 
-              octave_quit ();
-            }
-        }
-      catch (const octave::execution_exception& e)
-        {
-          std::string stack_trace = e.info ();
+  private:
+
+    FILE *m_file;
+
+    static const std::string s_in_src;
+  };
+
+  class
+  eval_string_reader : public base_reader
+  {
+  public:
+
+    eval_string_reader (const std::string& str, base_lexer *lxr = nullptr)
+      : base_reader (lxr), m_eval_string (str)
+    { }
+
+    std::string get_input (bool& eof);
+
+    std::string input_source (void) const { return s_in_src; }
 
-          if (! stack_trace.empty ())
-            std::cerr << stack_trace;
+    bool input_from_eval_string (void) const { return true; }
+
+  private:
+
+    std::string m_eval_string;
+
+    static const std::string s_in_src;
+  };
 
-          // Ignore errors when in debugging mode;
-          octave::interpreter::recover_from_exception ();
-        }
-    }
-}
+  input_reader::input_reader (base_lexer *lxr)
+    : m_rep (new terminal_reader (lxr))
+  { }
 
-namespace octave
-{
+  input_reader::input_reader (FILE *file, base_lexer *lxr)
+    : m_rep (new file_reader (file, lxr))
+  { }
+
+  input_reader::input_reader (const std::string& str, base_lexer *lxr)
+    : m_rep (new eval_string_reader (str, lxr))
+  { }
+
   const std::string base_reader::s_in_src ("invalid");
 
   const std::string terminal_reader::s_in_src ("terminal");
 
   std::string
   terminal_reader::get_input (bool& eof)
   {
     octave_quit ();
@@ -781,19 +1102,25 @@ namespace octave
   std::string
   file_reader::get_input (bool& eof)
   {
     octave_quit ();
 
     eof = false;
 
     std::string src_str = octave_fgets (m_file, eof);
-    std::string encoding = Vmfile_encoding.compare ("system") == 0
-                           ? octave_locale_charset_wrapper ()
-                           : Vmfile_encoding;
+
+    octave::input_system& input_sys
+      = octave::__get_input_system__ ("get_input");
+
+    std::string mfile_encoding = input_sys.mfile_encoding ();
+
+    std::string encoding
+      = (mfile_encoding.compare ("system") == 0
+         ? octave_locale_charset_wrapper () : mfile_encoding);
 
     if (encoding.compare ("utf-8") != 0)
     {
       // convert encoding to UTF-8 before returning string
       const char *src = src_str.c_str ();
       size_t srclen = src_str.length ();
 
       size_t length;
@@ -834,77 +1161,18 @@ namespace octave
 
     if (retval.empty ())
       eof = true;
 
     return retval;
   }
 }
 
-// If the user simply hits return, this will produce an empty matrix.
-
-static octave_value_list
-get_user_input (const octave_value_list& args, int nargout)
-{
-  octave_value_list retval;
-
-  int read_as_string = 0;
-
-  if (args.length () == 2)
-    read_as_string++;
-
-  std::string prompt = args(0).xstring_value ("input: unrecognized argument");
-
-  octave::flush_stdout ();
-
-  octave::pager_stream::reset ();
-  octave::diary_stream::reset ();
-
-  octave_diary << prompt;
-
-  bool eof = false;
-
-  std::string input_buf = interactive_input (prompt.c_str (), eof);
-
-  if (input_buf.empty ())
-    error ("input: reading user-input failed!");
-
-  size_t len = input_buf.length ();
-
-  octave_diary << input_buf;
-
-  if (input_buf[len - 1] != '\n')
-    octave_diary << "\n";
-
-  if (len < 1)
-    return read_as_string ? octave_value ("") : octave_value (Matrix ());
-
-  if (read_as_string)
-    {
-      // FIXME: fix gnu_readline and octave_gets instead!
-      if (input_buf.length () == 1 && input_buf[0] == '\n')
-        retval(0) = "";
-      else
-        retval(0) = input_buf;
-    }
-  else
-    {
-      int parse_status = 0;
-
-      retval = octave::eval_string (input_buf, true, parse_status, nargout);
-
-      if (! Vdebugging && retval.empty ())
-        retval(0) = Matrix ();
-    }
-
-  return retval;
-}
-
-DEFUN (input, args, nargout,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (input, interp, args, nargout,
+           doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{ans} =} input (@var{prompt})
 @deftypefnx {} {@var{ans} =} input (@var{prompt}, "s")
 Print @var{prompt} and wait for user input.
 
 For example,
 
 @example
 input ("Pick a number, any number! ")
@@ -937,41 +1205,23 @@ your prompt.
 @seealso{yes_or_no, kbhit, pause, menu, listdlg}
 @end deftypefn */)
 {
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
-  return get_user_input (args, std::max (nargout, 1));
+  octave::input_system& input_sys = interp.get_input_system ();
+
+  return input_sys.get_user_input (args, std::max (nargout, 1));
 }
 
-bool
-octave_yes_or_no (const std::string& prompt)
-{
-  std::string prompt_string = prompt + "(yes or no) ";
-
-  while (1)
-    {
-      bool eof = false;
-
-      std::string input_buf = interactive_input (prompt_string, eof);
-
-      if (input_buf == "yes")
-        return true;
-      else if (input_buf == "no")
-        return false;
-      else
-        message (nullptr, "Please answer yes or no.");
-    }
-}
-
-DEFUN (yes_or_no, args, ,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (yes_or_no, interp, args, ,
+           doc: /* -*- texinfo -*-
 @deftypefn {} {@var{ans} =} yes_or_no ("@var{prompt}")
 Ask the user a yes-or-no question.
 
 Return logical true if the answer is yes or false if the answer is no.
 
 Takes one argument, @var{prompt}, which is the string to display when asking
 the question.  @var{prompt} should end in a space; @code{yes-or-no} adds the
 string @samp{(yes or no) } to it.  The user must confirm the answer with
@@ -979,71 +1229,24 @@ string @samp{(yes or no) } to it.  The u
 @seealso{input}
 @end deftypefn */)
 {
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
+  octave::input_system& input_sys = interp.get_input_system ();
+
   std::string prompt;
 
   if (nargin == 1)
     prompt = args(0).xstring_value ("yes_or_no: PROMPT must be a string");
 
-  return ovl (octave_yes_or_no (prompt));
-}
-
-octave_value
-do_keyboard (octave::interpreter& interp, const octave_value_list& args)
-{
-  octave_value retval;
-
-  int nargin = args.length ();
-
-  assert (nargin == 0 || nargin == 1);
-
-  octave::unwind_protect frame;
-
-  frame.add_fcn (octave::command_history::ignore_entries,
-                 octave::command_history::ignoring_entries ());
-
-  octave::command_history::ignore_entries (false);
-
-  frame.protect_var (Vdebugging);
-
-  octave::call_stack& cs = interp.get_call_stack ();
-
-  frame.add_method (cs, &octave::call_stack::restore_frame,
-                    cs.current_frame ());
-
-  // FIXME: probably we just want to print one line, not the
-  // entire statement, which might span many lines...
-  //
-  // tree_print_code tpc (octave_stdout);
-  // stmt.accept (tpc);
-
-  Vdebugging = true;
-  Vtrack_line_num = false;
-
-  std::string prompt = "debug> ";
-  if (nargin > 0)
-    prompt = args(0).string_value ();
-
-  get_debug_input (interp, prompt);
-
-  return retval;
-}
-
-octave_value
-do_keyboard (const octave_value_list& args)
-{
-  octave::interpreter& interp = octave::__get_interpreter__ ("do_keyboard");
-
-  return do_keyboard (interp, args);
+  return ovl (input_sys.yes_or_no (prompt));
 }
 
 DEFMETHOD (keyboard, interp, args, ,
            doc: /* -*- texinfo -*-
 @deftypefn  {} {} keyboard ()
 @deftypefnx {} {} keyboard ("@var{prompt}")
 Stop m-file execution and enter debug mode.
 
@@ -1073,17 +1276,19 @@ If @code{keyboard} is invoked without ar
   cs.goto_frame_relative (0);
 
   octave::tree_evaluator& tw = interp.get_evaluator ();
 
   tw.debug_mode (true);
   tw.quiet_breakpoint_flag (false);
   tw.current_frame (cs.current_frame ());
 
-  do_keyboard (interp, args);
+  octave::input_system& input_sys = interp.get_input_system ();
+
+  input_sys.keyboard (args);
 
   return ovl ();
 }
 
 DEFUN (completion_matches, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} completion_matches (@var{hint})
 Generate possible completions given @var{hint}.
@@ -1213,26 +1418,29 @@ for details.
   octave::command_editor::re_read_init_file ();
 
   return ovl ();
 }
 
 static int
 internal_input_event_hook_fcn (void)
 {
-  input_event_hook_functions.run ();
+  octave::input_system& input_sys
+    = octave::__get_input_system__ ("internal_input_event_hook_fcn");
 
-  if (input_event_hook_functions.empty ())
+  input_sys.run_input_event_hooks ();
+
+  if (! input_sys.have_input_event_hooks ())
     octave::command_editor::remove_event_hook (internal_input_event_hook_fcn);
 
   return 0;
 }
 
-DEFUN (add_input_event_hook, args, ,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (add_input_event_hook, interp, args, ,
+           doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{id} =} add_input_event_hook (@var{fcn})
 @deftypefnx {} {@var{id} =} add_input_event_hook (@var{fcn}, @var{data})
 Add the named function or function handle @var{fcn} to the list of functions
 to call periodically when Octave is waiting for input.
 
 The function should have the form
 
 @example
@@ -1251,28 +1459,30 @@ list of input hook functions.
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   octave_value user_data;
 
   if (nargin == 2)
     user_data = args(1);
 
+  octave::input_system& input_sys = interp.get_input_system ();
+
   hook_function hook_fcn (args(0), user_data);
 
-  if (input_event_hook_functions.empty ())
+  if (! input_sys.have_input_event_hooks ())
     octave::command_editor::add_event_hook (internal_input_event_hook_fcn);
 
-  input_event_hook_functions.insert (hook_fcn.id (), hook_fcn);
+  input_sys.add_input_event_hook (hook_fcn);
 
   return ovl (hook_fcn.id ());
 }
 
-DEFUN (remove_input_event_hook, args, ,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (remove_input_event_hook, interp, args, ,
+           doc: /* -*- texinfo -*-
 @deftypefn  {} {} remove_input_event_hook (@var{name})
 @deftypefnx {} {} remove_input_event_hook (@var{fcn_id})
 Remove the named function or function handle with the given identifier
 from the list of functions to call periodically when Octave is waiting
 for input.
 @seealso{add_input_event_hook}
 @end deftypefn */)
 {
@@ -1280,33 +1490,30 @@ for input.
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   std::string hook_fcn_id = args(0).string_value ("remove_input_event_hook: argument not valid as a hook function name or id");
 
   bool warn = (nargin < 2);
 
-  hook_function_list::iterator p
-    = input_event_hook_functions.find (hook_fcn_id);
+  octave::input_system& input_sys = interp.get_input_system ();
 
-  if (p != input_event_hook_functions.end ())
-    input_event_hook_functions.erase (p);
-  else if (warn)
+  if (! input_sys.remove_input_event_hook (hook_fcn_id) && warn)
     warning ("remove_input_event_hook: %s not found in list",
              hook_fcn_id.c_str ());
 
-  if (input_event_hook_functions.empty ())
+  if (! input_sys.have_input_event_hooks ())
     octave::command_editor::remove_event_hook (internal_input_event_hook_fcn);
 
   return ovl ();
 }
 
-DEFUN (PS1, args, nargout,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (PS1, interp, args, nargout,
+           doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{val} =} PS1 ()
 @deftypefnx {} {@var{old_val} =} PS1 (@var{new_val})
 @deftypefnx {} {} PS1 (@var{new_val}, "local")
 Query or set the primary prompt string.
 
 When executing interactively, Octave displays the primary prompt when it is
 ready to read a command.
 
@@ -1334,21 +1541,23 @@ PS1 ('\[\033[01;31m\]\s:\#> \[\033[0m\]'
 will give the default Octave prompt a red coloring.
 
 When called from inside a function with the @qcode{"local"} option, the
 variable is changed locally for the function and any subroutines it calls.
 The original variable value is restored when exiting the function.
 @seealso{PS2, PS4}
 @end deftypefn */)
 {
-  return SET_INTERNAL_VARIABLE (PS1);
+  octave::input_system& input_sys = interp.get_input_system ();
+
+  return input_sys.PS1 (args, nargout);
 }
 
-DEFUN (PS2, args, nargout,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (PS2, interp, args, nargout,
+           doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{val} =} PS2 ()
 @deftypefnx {} {@var{old_val} =} PS2 (@var{new_val})
 @deftypefnx {} {} PS2 (@var{new_val}, "local")
 Query or set the secondary prompt string.
 
 The secondary prompt is printed when Octave is expecting additional input to
 complete a command.  For example, if you are typing a @code{for} loop that
 spans several lines, Octave will print the secondary prompt at the beginning
@@ -1356,39 +1565,43 @@ of each line after the first.  The defau
 string is @qcode{"> "}.
 
 When called from inside a function with the @qcode{"local"} option, the
 variable is changed locally for the function and any subroutines it calls.
 The original variable value is restored when exiting the function.
 @seealso{PS1, PS4}
 @end deftypefn */)
 {
-  return SET_INTERNAL_VARIABLE (PS2);
+  octave::input_system& input_sys = interp.get_input_system ();
+
+  return input_sys.PS2 (args, nargout);
 }
 
-DEFUN (completion_append_char, args, nargout,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (completion_append_char, interp, args, nargout,
+           doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{val} =} completion_append_char ()
 @deftypefnx {} {@var{old_val} =} completion_append_char (@var{new_val})
 @deftypefnx {} {} completion_append_char (@var{new_val}, "local")
 Query or set the internal character variable that is appended to
 successful command-line completion attempts.
 
 The default value is @qcode{" "} (a single space).
 
 When called from inside a function with the @qcode{"local"} option, the
 variable is changed locally for the function and any subroutines it calls.
 The original variable value is restored when exiting the function.
 @end deftypefn */)
 {
-  return SET_INTERNAL_VARIABLE (completion_append_char);
+  octave::input_system& input_sys = interp.get_input_system ();
+
+  return input_sys.completion_append_char (args, nargout);
 }
 
-DEFUN (__request_drawnow__, args, ,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (__request_drawnow__, , args, ,
+           doc: /* -*- texinfo -*-
 @deftypefn  {} {} __request_drawnow__ ()
 @deftypefnx {} {} __request_drawnow__ (@var{flag})
 Undocumented internal function.
 @end deftypefn */)
 {
   int nargin = args.length ();
 
   if (nargin > 1)
@@ -1397,72 +1610,80 @@ Undocumented internal function.
   if (nargin == 0)
     Vdrawnow_requested = true;
   else
     Vdrawnow_requested = args(0).bool_value ();
 
   return ovl ();
 }
 
-DEFUN (__gud_mode__, args, ,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (__gud_mode__, interp, args, nargout,
+           doc: /* -*- texinfo -*-
 @deftypefn {} {} __gud_mode__ ()
 Undocumented internal function.
 @end deftypefn */)
 {
-  int nargin = args.length ();
-
-  if (nargin > 1)
-    print_usage ();
-
-  octave_value_list retval;
+  octave::input_system& input_sys = interp.get_input_system ();
 
-  if (nargin == 0)
-    retval = ovl (Vgud_mode);
-  else
-    Vgud_mode = args(0).bool_value ();
-
-  return retval;
+  return input_sys.gud_mode (args, nargout);
 }
 
-DEFUN (__mfile_encoding__, args, ,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (__mfile_encoding__, interp, args, nargout,
+           doc: /* -*- texinfo -*-
 @deftypefn {} {@var{current_encoding} =} __mfile_encoding__ (@var{new_encoding})
 Set and query the codepage that is used for reading .m files.
 @end deftypefn */)
 {
-  int nargin = args.length ();
+  octave::input_system& input_sys = interp.get_input_system ();
+
+  return input_sys.mfile_encoding (args, nargout);
+}
+
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  if (nargin > 1)
-    print_usage ();
+void
+set_default_prompts (void)
+{
+  octave::input_system& input_sys
+    = octave::__get_input_system__ ("set_default_prompts");
+
+  input_sys.set_default_prompts ();
+}
+
+bool
+octave_yes_or_no (const std::string& prompt)
+{
+  octave::input_system& input_sys
+    = octave::__get_input_system__ ("set_default_prompts");
+
+  input_sys.yes_or_no (prompt);
+}
 
-  std::string old_mfile_encoding = Vmfile_encoding;
-  if (nargin > 0)
-    {
-      std::string str = args(0).xstring_value (
-        "__mfile_encoding__: NEW_ENCODING must be a string designating a valid codepage.");
-      if (str.empty ())
-#if defined (OCTAVE_USE_WINDOWS_API)
-        Vmfile_encoding = "system";
-#else
-        Vmfile_encoding = "utf-8";
+octave_value
+do_keyboard (const octave_value_list& args)
+{
+  octave::input_system& input_sys
+    = octave::__get_input_system__ ("do_keyboard");
+
+  return input_sys.keyboard (args);
+}
+
+void
+remove_input_event_hook_functions (void)
+{
+  octave::input_system& input_sys
+    = octave::__get_input_system__ ("remove_input_event_hook_functions");
+
+  input_sys.clear_input_event_hooks ();
+}
+
+// Fix things up so that input can come from the standard input.  This
+// may need to become much more complicated, which is why it's in a
+// separate function.
+
+FILE *
+get_input_from_stdin (void)
+{
+  octave::command_editor::set_input_stream (stdin);
+  return octave::command_editor::get_input_stream ();
+}
+
 #endif
-      else
-        {
-          std::transform (str.begin (), str.end (), str.begin (), ::tolower);
-
-          std::string codepage = (str.compare ("system") == 0)
-                                 ? octave_locale_charset_wrapper () : str;
-
-          // check if valid codepage
-          void *codec = octave_iconv_open_wrapper (codepage.c_str (), "utf-8");
-
-          if (errno == EINVAL)
-            error ("__mfile_encoding__: Conversion from codepage '%s' not supported", 
-                   codepage.c_str ());
-
-          octave_iconv_close_wrapper (codec);
-
-          Vmfile_encoding = str;
-        }
-    }
-    return ovl (old_mfile_encoding);
-}
diff --git a/libinterp/corefcn/input.h b/libinterp/corefcn/input.h
--- a/libinterp/corefcn/input.h
+++ b/libinterp/corefcn/input.h
@@ -26,61 +26,186 @@ along with Octave; see the file COPYING.
 #define octave_input_h 1
 
 #include "octave-config.h"
 
 #include <cstdio>
 
 #include <string>
 
+#include "hook-fcn.h"
 #include "oct-refcount.h"
 #include "oct-time.h"
 #include "ovl.h"
 #include "pager.h"
 
-class octave_value;
-namespace octave
-{
-  class base_lexer;
-}
-
-extern OCTINTERP_API FILE * get_input_from_stdin (void);
-
 // TRUE after a call to completion_matches.
 extern bool octave_completion_matches_called;
 
 // TRUE if the plotting system has requested a call to drawnow at
 // the next user prompt.
 extern OCTINTERP_API bool Vdrawnow_requested;
 
 // TRUE if we are in debugging mode.
 extern OCTINTERP_API bool Vdebugging;
 
 // TRUE if we are not executing a command direct from debug> prompt.
 extern OCTINTERP_API bool Vtrack_line_num;
 
-extern std::string find_indexed_expression (const std::string& text);
-
-extern void initialize_command_input (void);
-
-extern bool octave_yes_or_no (const std::string& prompt);
+extern octave::sys::time Vlast_prompt_time;
 
-extern octave_value do_keyboard (const octave_value_list& args
-                                 = octave_value_list ());
-
-extern void remove_input_event_hook_functions (void);
-
-extern void set_default_prompts (void);
-
-extern octave::sys::time Vlast_prompt_time;
+class octave_value;
 
 namespace octave
 {
-  class
-  base_reader
+  class interpreter;
+  class base_lexer;
+
+  class input_system
+  {
+  public:
+
+    input_system (interpreter& interp);
+
+    void initialize (bool line_editing);
+
+    octave_value PS1 (const octave_value_list& args, int nargout);
+
+    std::string PS1 (void) const { return m_PS1; }
+
+    std::string PS1 (const std::string& s)
+    {
+      std::string val = m_PS1;
+      m_PS1 = s;
+      return val;
+    }
+
+    void set_PS1 (const std::string& s) { m_PS1 = s; }
+
+    octave_value PS2 (const octave_value_list& args, int nargout);
+
+    std::string PS2 (void) const { return m_PS2; }
+
+    std::string PS2 (const std::string& s)
+    {
+      std::string val = m_PS2;
+      m_PS2 = s;
+      return val;
+    }
+
+    void set_PS2 (const std::string& s) { m_PS2 = s; }
+
+    std::string last_debugging_command (void) const
+    {
+      return m_last_debugging_command;
+    }
+
+    std::string last_debugging_command (const std::string& s)
+    {
+      std::string val = m_last_debugging_command;
+      m_last_debugging_command = s;
+      return val;
+    }
+
+    octave_value
+    completion_append_char (const octave_value_list& args, int nargout);
+
+    char completion_append_char (void) const
+    {
+      return m_completion_append_char;
+    }
+
+    char completion_append_char (char c)
+    {
+      char val = m_completion_append_char;
+      m_completion_append_char = c;
+      return val;
+    }
+
+    void set_completion_append_char (char c) { m_completion_append_char = c; }
+
+    octave_value gud_mode (const octave_value_list& args, int nargout);
+
+    bool gud_mode (void) const { return m_gud_mode; }
+
+    bool gud_mode (bool flag)
+    {
+      bool val = m_gud_mode;
+      m_gud_mode = flag;
+      return val;
+    }
+
+    void set_gud_mode (bool flag) { m_gud_mode = flag; }
+
+    octave_value mfile_encoding (const octave_value_list& args, int nargout);
+
+    std::string mfile_encoding (void) const { return m_mfile_encoding; }
+
+    std::string mfile_encoding (const std::string& s)
+    {
+      std::string val = m_mfile_encoding;
+      m_mfile_encoding = s;
+      return val;
+    }
+
+    void set_mfile_encoding (const std::string& s) { m_mfile_encoding = s; }
+
+    bool yes_or_no (const std::string& prompt);
+
+    std::string interactive_input (const std::string& s, bool& eof);
+
+    octave_value_list
+    get_user_input (const octave_value_list& args, int nargout);
+
+    octave_value
+    keyboard (const octave_value_list& args = octave_value_list ());
+
+    bool have_input_event_hooks (void) const;
+
+    void add_input_event_hook (const hook_function& hook_fcn);
+
+    bool remove_input_event_hook (const std::string& hook_fcn_id);
+
+    void clear_input_event_hooks (void);
+
+    void run_input_event_hooks (void);
+
+  private:
+
+    interpreter& m_interpreter;
+
+    // Primary prompt string.
+    std::string m_PS1;
+
+    // Secondary prompt string.
+    std::string m_PS2;
+
+    // Character to append after successful command-line completion
+    // attempts.
+    char m_completion_append_char;
+
+    // TRUE if we are running in the Emacs GUD mode.
+    bool m_gud_mode;
+
+    // Codepage which is used to read .m files
+    std::string m_mfile_encoding;
+
+    // If we are in debugging mode, this is the last command entered,
+    // so that we can repeat the previous command if the user just
+    // types RET.
+    std::string m_last_debugging_command;
+
+    hook_function_list m_input_event_hook_functions;
+
+    std::string gnu_readline (const std::string& s, bool& eof) const;
+
+    void get_debug_input (const std::string& prompt);
+  };
+
+  class base_reader
   {
   public:
 
     friend class input_reader;
 
     base_reader (base_lexer *lxr)
       : m_count (1), m_pflag (0), m_lexer (lxr)
     { }
@@ -130,18 +255,17 @@ namespace octave
 
     int m_pflag;
 
     base_lexer *m_lexer;
 
     static const std::string s_in_src;
   };
 
-  class
-  input_reader
+  class input_reader
   {
   public:
 
     input_reader (base_lexer *lxr = nullptr);
 
     input_reader (FILE *file, base_lexer *lxr = nullptr);
 
     input_reader (const std::string& str, base_lexer *lxr = nullptr);
@@ -205,9 +329,29 @@ namespace octave
     }
 
   private:
 
     base_reader *m_rep;
   };
 }
 
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
+
+OCTAVE_DEPRECATED (5, "use 'octave::input_system::set_default_prompts' instead")
+extern void set_default_prompts (void);
+
+OCTAVE_DEPRECATED (5, "use 'octave::input_system::yes_or_no' instead")
+extern bool octave_yes_or_no (const std::string& prompt);
+
+OCTAVE_DEPRECATED (5, "use 'octave::input_system::keyboard' instead")
+extern octave_value do_keyboard (const octave_value_list& args
+                                 = octave_value_list ());
+
+OCTAVE_DEPRECATED (5, "use 'octave::input_system::clear_input_event_hooks' instead")
+extern void remove_input_event_hook_functions (void);
+
+OCTAVE_DEPRECATED (5, "this function will be removed in a future version of Octave")
+extern OCTINTERP_API FILE * get_input_from_stdin (void);
+
 #endif
+
+#endif
diff --git a/libinterp/corefcn/interpreter-private.cc b/libinterp/corefcn/interpreter-private.cc
--- a/libinterp/corefcn/interpreter-private.cc
+++ b/libinterp/corefcn/interpreter-private.cc
@@ -27,16 +27,17 @@ along with Octave; see the file COPYING.
 #include <string>
 
 #include "bp-table.h"
 #include "call-stack.h"
 #include "child-list.h"
 #include "error.h"
 #include "gtk-manager.h"
 #include "help.h"
+#include "input.h"
 #include "interpreter-private.h"
 #include "interpreter.h"
 #include "load-path.h"
 #include "ov-classdef.h"
 #include "symtab.h"
 
 namespace octave
 {
@@ -62,16 +63,23 @@ namespace octave
 
   help_system& __get_help_system__ (const std::string& who)
   {
     interpreter& interp = __get_interpreter__ (who);
 
     return interp.get_help_system ();
   }
 
+  input_system& __get_input_system__ (const std::string& who)
+  {
+    interpreter& interp = __get_interpreter__ (who);
+
+    return interp.get_input_system ();
+  }
+
   load_path& __get_load_path__ (const std::string& who)
   {
     interpreter& interp = __get_interpreter__ (who);
 
     return interp.get_load_path ();
   }
 
   type_info& __get_type_info__ (const std::string& who)
diff --git a/libinterp/corefcn/interpreter-private.h b/libinterp/corefcn/interpreter-private.h
--- a/libinterp/corefcn/interpreter-private.h
+++ b/libinterp/corefcn/interpreter-private.h
@@ -34,27 +34,30 @@ class cdef_manager;
 namespace octave
 {
   class bp_table;
   class call_stack;
   class child_list;
   class dynamic_loader;
   class gtk_manager;
   class help_system;
+  class input_system;
   class interpreter;
   class load_path;
   class tree_evaluator;
   class type_info;
 
   extern interpreter& __get_interpreter__ (const std::string& who);
 
   extern dynamic_loader& __get_dynamic_loader__ (const std::string& who);
 
   extern help_system& __get_help_system__ (const std::string& who);
 
+  extern input_system& __get_input_system__ (const std::string& who);
+
   extern load_path& __get_load_path__ (const std::string& who);
 
   extern type_info& __get_type_info__ (const std::string& who);
 
   extern symbol_table& __get_symbol_table__ (const std::string& who);
 
   extern symbol_scope __get_current_scope__ (const std::string& who);
 
diff --git a/libinterp/corefcn/interpreter.cc b/libinterp/corefcn/interpreter.cc
--- a/libinterp/corefcn/interpreter.cc
+++ b/libinterp/corefcn/interpreter.cc
@@ -43,16 +43,17 @@ along with Octave; see the file COPYING.
 #include "Cell.h"
 #include "call-stack.h"
 #include "defun.h"
 #include "display.h"
 #include "error.h"
 #include "file-io.h"
 #include "graphics.h"
 #include "help.h"
+#include "input.h"
 #include "interpreter-private.h"
 #include "interpreter.h"
 #include "load-path.h"
 #include "load-save.h"
 #include "octave-link.h"
 #include "octave.h"
 #include "oct-hist.h"
 #include "oct-map.h"
@@ -320,16 +321,17 @@ namespace octave
   // Create an interpreter object and perform initialization up to the
   // point of setting reading command history and setting the load
   // path.
 
   interpreter::interpreter (application *app_context)
     : m_app_context (app_context),
       m_environment (),
       m_help_system (*this),
+      m_input_system (*this),
       m_dynamic_loader (*this),
       m_load_path (),
       m_type_info (),
       m_symbol_table (),
       m_evaluator (*this),
       m_stream_list (*this),
       m_child_list (),
       m_url_handle_manager (),
@@ -361,18 +363,16 @@ namespace octave
     sys::env::putenv ("LC_NUMERIC", "C");
     sys::env::putenv ("LC_TIME", "C");
 
     // Initialize the default floating point unit control state.
     octave_set_default_fpucw ();
 
     thread::init ();
 
-    set_default_prompts ();
-
     // Initialize default warning state before --traditional option
     // that may reset them.
 
     initialize_default_warning_state ();
 
     octave_ieee_init ();
 
     octave_prepare_hdf5 ();
@@ -479,21 +479,17 @@ namespace octave
         if (options.jit_compiler ())
           Fjit_enable (octave_value (true));
 
         std::string texi_macros_file = options.texi_macros_file ();
         if (! texi_macros_file.empty ())
           Ftexi_macros_file (*this, octave_value (texi_macros_file));
       }
 
-    // Force default line editor if we don't want readline editing.
-    if (line_editing)
-      initialize_command_input ();
-    else
-      command_editor::force_default_editor ();
+    m_input_system.initialize (line_editing);
 
     // These can come after command line args since none of them set any
     // defaults that might be changed by command line options.
 
     initialize_version_info ();
 
     // This should be done before initializing the load path because
     // some PKG_ADD files might need --traditional behavior.
@@ -963,17 +959,17 @@ namespace octave
   void interpreter::cleanup (void)
   {
     // If we are attached to a GUI, process pending events and
     // disconnect the link.
 
     octave_link::process_events (true);
     octave_link::disconnect_link ();
 
-    OCTAVE_SAFE_CALL (remove_input_event_hook_functions, ());
+    OCTAVE_SAFE_CALL (m_input_system.clear_input_event_hooks, ());
 
     while (! atexit_functions.empty ())
       {
         std::string fcn = atexit_functions.front ();
 
         atexit_functions.pop_front ();
 
         OCTAVE_SAFE_CALL (reset_error_handler, ());
@@ -1145,18 +1141,18 @@ namespace octave
 
     return found;
   }
 
   // What internal options get configured by --traditional.
 
   void interpreter::maximum_braindamage (void)
   {
-    FPS1 (octave_value (">> "));
-    FPS2 (octave_value (""));
+    m_input_system.PS1 (">> ");
+    m_input_system.PS2 ("");
 
     m_evaluator.PS4 ("");
 
     Fbeep_on_error (octave_value (true));
     Fconfirm_recursive_rmdir (octave_value (false));
     Fcrash_dumps_octave_core (octave_value (false));
     Fdisable_diagonal_matrix (octave_value (true));
     Fdisable_permutation_matrix (octave_value (true));
diff --git a/libinterp/corefcn/interpreter.h b/libinterp/corefcn/interpreter.h
--- a/libinterp/corefcn/interpreter.h
+++ b/libinterp/corefcn/interpreter.h
@@ -30,16 +30,17 @@ along with Octave; see the file COPYING.
 #include "child-list.h"
 #include "quit.h"
 #include "str-vec.h"
 
 #include "dynamic-ld.h"
 #include "environment.h"
 #include "gtk-manager.h"
 #include "help.h"
+#include "input.h"
 #include "load-path.h"
 #include "oct-stream.h"
 #include "ov-classdef.h"
 #include "ov-typeinfo.h"
 #include "pt-eval.h"
 #include "symtab.h"
 #include "url-handle-manager.h"
 
@@ -149,16 +150,21 @@ namespace octave
       return m_environment;
     }
 
     help_system& get_help_system (void)
     {
       return m_help_system;
     }
 
+    input_system& get_input_system (void)
+    {
+      return m_input_system;
+    }
+
     dynamic_loader& get_dynamic_loader (void)
     {
       return m_dynamic_loader;
     }
 
     load_path& get_load_path (void)
     {
       return m_load_path;
@@ -243,16 +249,18 @@ namespace octave
     void cleanup (void);
 
     application *m_app_context;
 
     environment m_environment;
 
     help_system m_help_system;
 
+    input_system m_input_system;
+
     dynamic_loader m_dynamic_loader;
 
     load_path m_load_path;
 
     type_info m_type_info;
 
     symbol_table m_symbol_table;
 
diff --git a/libinterp/corefcn/octave-link.h b/libinterp/corefcn/octave-link.h
--- a/libinterp/corefcn/octave-link.h
+++ b/libinterp/corefcn/octave-link.h
@@ -363,23 +363,16 @@ public:
     else
       {
         octave_link *retval = instance;
         instance = nullptr;
         return retval;
       }
   }
 
-  static void set_default_prompts (std::string& ps1, std::string& ps2,
-                                   std::string& ps4)
-  {
-    if (enabled ())
-      instance->do_set_default_prompts (ps1, ps2, ps4);
-  }
-
   static bool enable (void)
   {
     return instance_ok () ? instance->do_enable () : false;
   }
 
   static bool disable (void)
   {
     return instance_ok () ? instance->do_disable () : false;
@@ -614,19 +607,16 @@ protected:
   do_execute_in_debugger_event (const std::string& file, int line) = 0;
 
   virtual void do_exit_debugger_event (void) = 0;
 
   virtual void do_update_breakpoint (bool insert,
                                      const std::string& file, int line,
                                      const std::string& cond) = 0;
 
-  virtual void do_set_default_prompts (std::string& ps1, std::string& ps2,
-                                       std::string& ps4) = 0;
-
   virtual void do_show_preferences (void) = 0;
 
   virtual void do_show_doc (const std::string& file) = 0;
 
   virtual void do_register_doc (const std::string& file) = 0;
 
   virtual void do_unregister_doc (const std::string& file) = 0;
 
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -155,175 +155,16 @@ extract_function (const octave_value& ar
 
       warning ("%s: passing function body as a string is obsolete; please use anonymous functions",
                warn_for.c_str ());
     }
 
   return retval;
 }
 
-string_vector
-get_struct_elts (const std::string& text)
-{
-  int n = 1;
-
-  size_t pos = 0;
-
-  size_t len = text.length ();
-
-  while ((pos = text.find ('.', pos)) != std::string::npos)
-    {
-      if (++pos == len)
-        break;
-
-      n++;
-    }
-
-  string_vector retval (n);
-
-  pos = 0;
-
-  for (int i = 0; i < n; i++)
-    {
-      len = text.find ('.', pos);
-
-      if (len != std::string::npos)
-        len -= pos;
-
-      retval[i] = text.substr (pos, len);
-
-      if (len != std::string::npos)
-        pos += len + 1;
-    }
-
-  return retval;
-}
-
-static inline bool
-is_variable (octave::symbol_table& symtab, const std::string& name)
-{
-  bool retval = false;
-
-  if (! name.empty ())
-    {
-      octave::symbol_scope scope = symtab.current_scope ();
-
-      octave_value val = scope ? scope.varval (name) : octave_value ();
-
-      retval = val.is_defined ();
-    }
-
-  return retval;
-}
-
-string_vector
-generate_struct_completions (const std::string& text,
-                             std::string& prefix, std::string& hint)
-{
-  string_vector names;
-
-  size_t pos = text.rfind ('.');
-  bool array = false;
-
-  if (pos != std::string::npos)
-    {
-      if (pos == text.length ())
-        hint = "";
-      else
-        hint = text.substr (pos+1);
-
-      prefix = text.substr (0, pos);
-
-      if (prefix == "")
-        {
-          array = true;
-          prefix = find_indexed_expression (text);
-        }
-
-      std::string base_name = prefix;
-
-      pos = base_name.find_first_of ("{(. ");
-
-      if (pos != std::string::npos)
-        base_name = base_name.substr (0, pos);
-
-      octave::symbol_table& symtab
-        = octave::__get_symbol_table__ ("generate_struct_completions");
-
-      if (is_variable (symtab, base_name))
-        {
-          int parse_status;
-
-          octave::unwind_protect frame;
-
-          frame.protect_var (discard_error_messages);
-          frame.protect_var (discard_warning_messages);
-
-          discard_error_messages = true;
-          discard_warning_messages = true;
-
-          try
-            {
-              octave_value tmp = octave::eval_string (prefix, true, parse_status);
-
-              frame.run ();
-
-              if (tmp.is_defined ()
-                  && (tmp.isstruct () || tmp.isjava () || tmp.is_classdef_object ()))
-                names = tmp.map_keys ();
-            }
-          catch (const octave::execution_exception&)
-            {
-              octave::interpreter::recover_from_exception ();
-            }
-        }
-    }
-
-  // Undo look-back that found the array expression,
-  // but insert an extra "." to distinguish from the non-struct case.
-  if (array)
-    prefix = ".";
-
-  return names;
-}
-
-// FIXME: this will have to be much smarter to work "correctly".
-bool
-looks_like_struct (const std::string& text, char prev_char)
-{
-  bool retval = (! text.empty ()
-                 && (text != "." || prev_char == ')' || prev_char == '}')
-                 && text.find_first_of (octave::sys::file_ops::dir_sep_chars ()) == std::string::npos
-                 && text.find ("..") == std::string::npos
-                 && text.rfind ('.') != std::string::npos);
-
-#if 0
-  symbol_record *sr = curr_sym_tab->lookup (text);
-
-  if (sr && ! sr->is_function ())
-    {
-      int parse_status;
-
-      octave::unwind_protect frame;
-
-      frame.protect_var (discard_error_messages);
-
-      discard_error_messages = true;
-
-      octave_value tmp = eval_string (text, true, parse_status);
-
-      frame.run ();
-
-      retval = (tmp.is_defined () && tmp.isstruct ());
-    }
-#endif
-
-  return retval;
-}
-
 static octave_value
 do_isglobal (octave::symbol_table& symtab, const octave_value_list& args)
 {
   if (args.length () != 1)
     print_usage ();
 
   if (! args(0).is_string ())
     error ("isglobal: NAME must be a string");
@@ -2785,8 +2626,45 @@ get_top_level_value (const std::string& 
 void
 set_top_level_value (const std::string& nm, const octave_value& val)
 {
   octave::symbol_table& symtab =
     octave::__get_symbol_table__ ("set_top_level_value");
 
   symtab.top_level_assign (nm, val);
 }
+
+string_vector
+get_struct_elts (const std::string& text)
+{
+  int n = 1;
+
+  size_t pos = 0;
+
+  size_t len = text.length ();
+
+  while ((pos = text.find ('.', pos)) != std::string::npos)
+    {
+      if (++pos == len)
+        break;
+
+      n++;
+    }
+
+  string_vector retval (n);
+
+  pos = 0;
+
+  for (int i = 0; i < n; i++)
+    {
+      len = text.find ('.', pos);
+
+      if (len != std::string::npos)
+        len -= pos;
+
+      retval[i] = text.substr (pos, len);
+
+      if (len != std::string::npos)
+        pos += len + 1;
+    }
+
+  return retval;
+}
diff --git a/libinterp/corefcn/variables.h b/libinterp/corefcn/variables.h
--- a/libinterp/corefcn/variables.h
+++ b/libinterp/corefcn/variables.h
@@ -53,26 +53,16 @@ extern OCTINTERP_API octave_function *
 is_valid_function (const std::string&, const std::string& = "",
                    bool warn = false);
 
 extern OCTINTERP_API octave_function *
 extract_function (const octave_value& arg, const std::string& warn_for,
                   const std::string& fname, const std::string& header,
                   const std::string& trailer);
 
-extern OCTINTERP_API string_vector
-get_struct_elts (const std::string& text);
-
-extern OCTINTERP_API string_vector
-generate_struct_completions (const std::string& text, std::string& prefix,
-                             std::string& hint);
-
-extern OCTINTERP_API bool
-looks_like_struct (const std::string& text, char prev_char);
-
 extern OCTINTERP_API int
 symbol_exist (const std::string& name, const std::string& type = "any");
 
 extern OCTINTERP_API std::string
 unique_symbol_name (const std::string& basename);
 
 extern OCTINTERP_API octave_value
 set_internal_variable (bool& var, const octave_value_list& args,
@@ -160,9 +150,13 @@ set_global_value (const std::string& nm,
 OCTAVE_DEPRECATED (4.4, "use 'symbol_table::top_level_varval' instead")
 extern OCTINTERP_API octave_value
 get_top_level_value (const std::string& nm, bool silent = false);
 
 OCTAVE_DEPRECATED (4.4, "use 'symbol_table::top_level_assign' instead")
 extern OCTINTERP_API void
 set_top_level_value (const std::string& nm, const octave_value& val);
 
+OCTAVE_DEPRECATED (5, "this function will be removed in a future version of Octave")
+extern OCTINTERP_API string_vector
+get_struct_elts (const std::string& text);
+
 #endif
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -2436,17 +2436,17 @@ public:
   void close (void)
   {
     if (toolkit_loaded)
       {
         m_interpreter.munlock ("__init_fltk__");
 
         octave_value_list args = input_event_hook_fcn_id;
         args.append (false);
-        Fremove_input_event_hook (args, 0);
+        Fremove_input_event_hook (m_interpreter, args, 0);
         input_event_hook_fcn_id = octave_value_list ();
 
         figure_manager::close_all ();
       }
   }
 
   void set_input_event_hook_id (const octave_value_list& id)
   {
@@ -2499,17 +2499,17 @@ Undocumented internal function.
 
       fltk_graphics_toolkit *fltk = new fltk_graphics_toolkit (interp);
       graphics_toolkit tk (fltk);
       gtk_mgr.load_toolkit (tk);
       toolkit_loaded = true;
 
       octave_value fcn (new octave_builtin (F__fltk_check__));
       octave_value fcn_handle (new octave_fcn_handle (fcn, "@__fltk_check__"));
-      octave_value_list id = Fadd_input_event_hook (fcn_handle, 1);
+      octave_value_list id = Fadd_input_event_hook (interp, fcn_handle, 1);
 
       fltk->set_input_event_hook_id (id);
     }
 
   return octave_value_list ();
 
 #else
   octave_unused_parameter (interp);
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -3157,28 +3157,33 @@ namespace octave
         // that frame.
 
         if (is_end_of_fcn_or_script
             && m_call_stack.current_frame () == m_current_frame)
           m_dbstep_flag = -1;
       }
 
     if (break_on_this_statement)
-      do_keyboard ();
-
+      {
+        input_system& input_sys = m_interpreter.get_input_system ();
+
+        input_sys.keyboard ();
+      }
   }
 
   // ARGS is currently unused, but since the do_keyboard function in
   // input.cc accepts an argument list, we preserve it here so that the
   // interface won't have to change if we decide to use it in the future.
 
   octave_value
   tree_evaluator::do_keyboard (const octave_value_list& args) const
   {
-    return ::do_keyboard (args);
+    input_system& input_sys = m_interpreter.get_input_system ();
+
+    return input_sys.keyboard (args);
   }
 
   bool
   tree_evaluator::is_logically_true (tree_expression *expr,
                                      const char *warn_for)
   {
     bool expr_value = false;
 
