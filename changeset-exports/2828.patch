# HG changeset patch
# User jwe
# Date 859333808 0
#      Tue Mar 25 23:50:08 1997 +0000
# Node ID 92826d6e8bd9fbedfb77c284e577ea901da5d218
# Parent  2387b8694c757493c9421cce855507125b762673
[project @ 1997-03-25 23:41:41 by jwe]

diff --git a/liboctave/CDiagMatrix.h b/liboctave/CDiagMatrix.h
--- a/liboctave/CDiagMatrix.h
+++ b/liboctave/CDiagMatrix.h
@@ -120,36 +120,22 @@ public:
 
   friend ComplexDiagMatrix operator * (const Complex& s, const DiagMatrix& a);
 
   // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
   friend ComplexDiagMatrix operator * (const ComplexDiagMatrix& a,
 				       const ComplexDiagMatrix& b);
 
-  friend ComplexDiagMatrix operator + (const ComplexDiagMatrix& a,
-				       const DiagMatrix& b);
-  friend ComplexDiagMatrix operator - (const ComplexDiagMatrix& a,
-				       const DiagMatrix& b);
   friend ComplexDiagMatrix operator * (const ComplexDiagMatrix& a,
 				       const DiagMatrix& b);
 
-  friend ComplexDiagMatrix operator + (const DiagMatrix& a,
-				       const ComplexDiagMatrix& b);
-  friend ComplexDiagMatrix operator - (const DiagMatrix& a,
-				       const ComplexDiagMatrix& b);
   friend ComplexDiagMatrix operator * (const DiagMatrix& a,
 				       const ComplexDiagMatrix& b);
 
-  friend ComplexDiagMatrix product (const ComplexDiagMatrix& a,
-				    const DiagMatrix& b); 
-
-  friend ComplexDiagMatrix product (const DiagMatrix& a,
-				    const ComplexDiagMatrix& b);
-
   // other operations
 
   ComplexColumnVector diag (void) const;
   ComplexColumnVector diag (int k) const;
 
   // i/o
 
   friend ostream& operator << (ostream& os, const ComplexDiagMatrix& a);
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -33,26 +33,29 @@ Software Foundation, 59 Temple Place - S
 
 #include <iostream.h>
 
 // XXX FIXME XXX
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 
+#include "CMatrix.h"
 #include "CmplxAEPBAL.h"
 #include "CmplxDET.h"
 #include "CmplxSCHUR.h"
 #include "CmplxSVD.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "lo-utils.h"
 #include "mx-base.h"
+#include "mx-cm-dm.h"
+#include "mx-cm-s.h"
 #include "mx-inlines.cc"
 #include "oct-cmplx.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
   int F77_FCN (zgemm, ZGEMM) (const char*, const char*, const int&,
@@ -154,16 +157,23 @@ ComplexMatrix::ComplexMatrix (const Comp
 {
   for (int i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
 // XXX FIXME XXX -- could we use a templated mixed-type copy function
 // here?
 
+ComplexMatrix::ComplexMatrix (const boolMatrix& a)
+{
+  for (int i = 0; i < a.cols (); i++)
+    for (int j = 0; j < a.rows (); j++)
+      elem (i, j) = a.elem (i, j);
+}
+
 ComplexMatrix::ComplexMatrix (const charMatrix& a)
 {
   for (int i = 0; i < a.cols (); i++)
     for (int j = 0; j < a.rows (); j++)
       elem (i, j) = a.elem (i, j);
 }
 
 bool
@@ -1707,104 +1717,16 @@ operator * (const ComplexColumnVector& v
 	    (*current_liboctave_error_handler)
 	      ("unrecoverable error in zgemm");
 	}
     }
 
   return retval;
 }
 
-// diagonal matrix by scalar -> matrix operations
-
-ComplexMatrix
-operator + (const DiagMatrix& a, const Complex& s)
-{
-  ComplexMatrix tmp (a.rows (), a.cols (), s);
-  return a + tmp;
-}
-
-ComplexMatrix
-operator - (const DiagMatrix& a, const Complex& s)
-{
-  ComplexMatrix tmp (a.rows (), a.cols (), -s);
-  return a + tmp;
-}
-
-ComplexMatrix
-operator + (const ComplexDiagMatrix& a, double s)
-{
-  ComplexMatrix tmp (a.rows (), a.cols (), s);
-  return a + tmp;
-}
-
-ComplexMatrix
-operator - (const ComplexDiagMatrix& a, double s)
-{
-  ComplexMatrix tmp (a.rows (), a.cols (), -s);
-  return a + tmp;
-}
-
-ComplexMatrix
-operator + (const ComplexDiagMatrix& a, const Complex& s)
-{
-  ComplexMatrix tmp (a.rows (), a.cols (), s);
-  return a + tmp;
-}
-
-ComplexMatrix
-operator - (const ComplexDiagMatrix& a, const Complex& s)
-{
-  ComplexMatrix tmp (a.rows (), a.cols (), -s);
-  return a + tmp;
-}
-
-// scalar by diagonal matrix -> matrix operations
-
-ComplexMatrix
-operator + (const Complex& s, const DiagMatrix& a)
-{
-  ComplexMatrix tmp (a.rows (), a.cols (), s);
-  return tmp + a;
-}
-
-ComplexMatrix
-operator - (const Complex& s, const DiagMatrix& a)
-{
-  ComplexMatrix tmp (a.rows (), a.cols (), s);
-  return tmp - a;
-}
-
-ComplexMatrix
-operator + (double s, const ComplexDiagMatrix& a)
-{
-  ComplexMatrix tmp (a.rows (), a.cols (), s);
-  return tmp + a;
-}
-
-ComplexMatrix
-operator - (double s, const ComplexDiagMatrix& a)
-{
-  ComplexMatrix tmp (a.rows (), a.cols (), s);
-  return tmp - a;
-}
-
-ComplexMatrix
-operator + (const Complex& s, const ComplexDiagMatrix& a)
-{
-  ComplexMatrix tmp (a.rows (), a.cols (), s);
-  return tmp + a;
-}
-
-ComplexMatrix
-operator - (const Complex& s, const ComplexDiagMatrix& a)
-{
-  ComplexMatrix tmp (a.rows (), a.cols (), s);
-  return tmp - a;
-}
-
 // matrix by diagonal matrix -> matrix operations
 
 ComplexMatrix&
 ComplexMatrix::operator += (const DiagMatrix& a)
 {
   int nr = rows ();
   int nc = cols ();
 
@@ -1881,421 +1803,16 @@ ComplexMatrix::operator -= (const Comple
     }
 
   for (int i = 0; i < a.length (); i++)
     elem (i, i) -= a.elem (i, i);
 
   return *this;
 }
 
-ComplexMatrix
-operator + (const Matrix& m, const ComplexDiagMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nr != a_nr || nc != a_nc)
-    {
-      gripe_nonconformant ("operator +", nr, nc, a_nr, a_nc);
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  ComplexMatrix result (m);
-  for (int i = 0; i < a.length (); i++)
-    result.elem (i, i) += a.elem (i, i);
-
-  return result;
-}
-
-ComplexMatrix
-operator - (const Matrix& m, const ComplexDiagMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nr != a_nr || nc != a_nc)
-    {
-      gripe_nonconformant ("operator -", nr, nc, a_nr, a_nc);
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  ComplexMatrix result (m);
-  for (int i = 0; i < a.length (); i++)
-    result.elem (i, i) -= a.elem (i, i);
-
-  return result;
-}
-
-ComplexMatrix
-operator * (const Matrix& m, const ComplexDiagMatrix& a)
-{
-  ComplexMatrix retval;
-
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nc != a_nr)
-    gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc);
-  else
-    {
-      if (nr == 0 || nc == 0 || a_nc == 0)
-	retval.resize (nr, a_nc, 0.0);
-      else
-	{
-	  retval.resize (nr, a_nc);
-	  Complex *c = retval.fortran_vec ();
-
-	  Complex *ctmp = 0;
-
-	  for (int j = 0; j < a.length (); j++)
-	    {
-	      int idx = j * nr;
-	      ctmp = c + idx;
-	      if (a.elem (j, j) == 1.0)
-		{
-		  for (int i = 0; i < nr; i++)
-		    ctmp[i] = m.elem (i, j);
-		}
-	      else if (a.elem (j, j) == 0.0)
-		{
-		  for (int i = 0; i < nr; i++)
-		    ctmp[i] = 0.0;
-		}
-	      else
-		{
-		  for (int i = 0; i < nr; i++)
-		    ctmp[i] = a.elem (j, j) * m.elem (i, j);
-		}
-	    }
-
-	  if (a_nr < a_nc)
-	    {
-	      for (int i = nr * nc; i < nr * a_nc; i++)
-		ctmp[i] = 0.0;
-	    }
-	}
-    }
-
-  return retval;
-}
-
-// diagonal matrix by matrix -> matrix operations
-
-ComplexMatrix
-operator + (const DiagMatrix& m, const ComplexMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nr != a_nr || nc != a_nc)
-    {
-      gripe_nonconformant ("operator +", nr, nc, a_nr, a_nc);
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  ComplexMatrix result (a);
-  for (int i = 0; i < m.length (); i++)
-    result.elem (i, i) += m.elem (i, i);
-
-  return result;
-}
-
-ComplexMatrix
-operator - (const DiagMatrix& m, const ComplexMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nr != a_nr || nc != a_nc)
-    {
-      gripe_nonconformant ("operator -", nr, nc, a_nr, a_nc);
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  ComplexMatrix result (-a);
-  for (int i = 0; i < m.length (); i++)
-    result.elem (i, i) += m.elem (i, i);
-
-  return result;
-}
-
-ComplexMatrix
-operator * (const DiagMatrix& m, const ComplexMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nc != a_nr)
-    {
-      gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc);
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0 || a_nc == 0)
-    return ComplexMatrix (nr, nc, 0.0);
-
-  ComplexMatrix c (nr, a_nc);
-
-  for (int i = 0; i < m.length (); i++)
-    {
-      if (m.elem (i, i) == 1.0)
-	{
-	  for (int j = 0; j < a_nc; j++)
-	    c.elem (i, j) = a.elem (i, j);
-	}
-      else if (m.elem (i, i) == 0.0)
-	{
-	  for (int j = 0; j < a_nc; j++)
-	    c.elem (i, j) = 0.0;
-	}
-      else
-	{
-	  for (int j = 0; j < a_nc; j++)
-	    c.elem (i, j) = m.elem (i, i) * a.elem (i, j);
-	}
-    }
-
-  if (nr > nc)
-    {
-      for (int j = 0; j < a_nc; j++)
-	for (int i = a_nr; i < nr; i++)
-	  c.elem (i, j) = 0.0;
-    }
-
-  return c;
-}
-
-ComplexMatrix
-operator + (const ComplexDiagMatrix& m, const Matrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nr != a_nr || nc != a_nc)
-    {
-      gripe_nonconformant ("operator +", nr, nc, a_nr, a_nc);
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  ComplexMatrix result (a);
-  for (int i = 0; i < m.length (); i++)
-    result.elem (i, i) += m.elem (i, i);
-
-  return result;
-}
-
-ComplexMatrix
-operator - (const ComplexDiagMatrix& m, const Matrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nr != a_nr || nc != a_nc)
-    {
-      gripe_nonconformant ("operator -", nr, nc, a_nr, a_nc);
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  ComplexMatrix result (-a);
-  for (int i = 0; i < m.length (); i++)
-    result.elem (i, i) += m.elem (i, i);
-
-  return result;
-}
-
-ComplexMatrix
-operator * (const ComplexDiagMatrix& m, const Matrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nc != a_nr)
-    {
-      gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc);
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0 || a_nc == 0)
-    return ComplexMatrix (nr, a_nc, 0.0);
-
-  ComplexMatrix c (nr, a_nc);
-
-  for (int i = 0; i < m.length (); i++)
-    {
-      if (m.elem (i, i) == 1.0)
-	{
-	  for (int j = 0; j < a_nc; j++)
-	    c.elem (i, j) = a.elem (i, j);
-	}
-      else if (m.elem (i, i) == 0.0)
-	{
-	  for (int j = 0; j < a_nc; j++)
-	    c.elem (i, j) = 0.0;
-	}
-      else
-	{
-	  for (int j = 0; j < a_nc; j++)
-	    c.elem (i, j) = m.elem (i, i) * a.elem (i, j);
-	}
-    }
-
-  if (nr > nc)
-    {
-      for (int j = 0; j < a_nc; j++)
-	for (int i = a_nr; i < nr; i++)
-	  c.elem (i, j) = 0.0;
-    }
-
-  return c;
-}
-
-ComplexMatrix
-operator + (const ComplexDiagMatrix& m, const ComplexMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nr != a_nr || nc != a_nc)
-    {
-      gripe_nonconformant ("operator +", nr, nc, a_nr, a_nc);
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  ComplexMatrix result (a);
-  for (int i = 0; i < m.length (); i++)
-    result.elem (i, i) += m.elem (i, i);
-
-  return result;
-}
-
-ComplexMatrix
-operator - (const ComplexDiagMatrix& m, const ComplexMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nr != a_nr || nc != a_nc)
-    {
-      gripe_nonconformant ("operator -", nr, nc, a_nr, a_nc);
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  ComplexMatrix result (-a);
-  for (int i = 0; i < m.length (); i++)
-    result.elem (i, i) += m.elem (i, i);
-
-  return result;
-}
-
-ComplexMatrix
-operator * (const ComplexDiagMatrix& m, const ComplexMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nc != a_nr)
-    {
-      gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc);
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0 || a_nc == 0)
-    return ComplexMatrix (nr, a_nc, 0.0);
-
-  ComplexMatrix c (nr, a_nc);
-
-  for (int i = 0; i < m.length (); i++)
-    {
-      if (m.elem (i, i) == 1.0)
-	{
-	  for (int j = 0; j < a_nc; j++)
-	    c.elem (i, j) = a.elem (i, j);
-	}
-      else if (m.elem (i, i) == 0.0)
-	{
-	  for (int j = 0; j < a_nc; j++)
-	    c.elem (i, j) = 0.0;
-	}
-      else
-	{
-	  for (int j = 0; j < a_nc; j++)
-	    c.elem (i, j) = m.elem (i, i) * a.elem (i, j);
-	}
-    }
-
-  if (nr > nc)
-    {
-      for (int j = 0; j < a_nc; j++)
-	for (int i = a_nr; i < nr; i++)
-	  c.elem (i, j) = 0.0;
-    }
-
-  return c;
-}
-
 // matrix by matrix -> matrix operations
 
 ComplexMatrix&
 ComplexMatrix::operator += (const Matrix& a)
 {
   int nr = rows ();
   int nc = cols ();
 
@@ -2392,563 +1909,16 @@ ComplexMatrix::operator -= (const Comple
 // unary operations
 
 Matrix
 ComplexMatrix::operator ! (void) const
 {
   return Matrix (not (data (), length ()), rows (), cols ());
 }
 
-// matrix by scalar -> matrix operations
-
-ComplexMatrix
-operator + (const Matrix& a, const Complex& s)
-{
-  return ComplexMatrix (add (a.data (), a.length (), s),
-			a.rows (), a.cols ());
-}
-
-ComplexMatrix
-operator - (const Matrix& a, const Complex& s)
-{
-  return ComplexMatrix (subtract (a.data (), a.length (), s),
-			a.rows (), a.cols ());
-}
-
-ComplexMatrix
-operator * (const Matrix& a, const Complex& s)
-{
-  return ComplexMatrix (multiply (a.data (), a.length (), s),
-			a.rows (), a.cols ());
-}
-
-ComplexMatrix
-operator / (const Matrix& a, const Complex& s)
-{
-  return ComplexMatrix (divide (a.data (), a.length (), s),
-			a.rows (), a.cols ());
-}
-
-ComplexMatrix
-operator + (const ComplexMatrix& a, double s)
-{
-  return ComplexMatrix (add (a.data (), a.length (), s),
-			a.rows (), a.cols ());
-}
-
-ComplexMatrix
-operator - (const ComplexMatrix& a, double s)
-{
-  return ComplexMatrix (subtract (a.data (), a.length (), s),
-			a.rows (), a.cols ());
-}
-
-ComplexMatrix
-operator * (const ComplexMatrix& a, double s)
-{
-  return ComplexMatrix (multiply (a.data (), a.length (), s),
-			a.rows (), a.cols ());
-}
-
-ComplexMatrix
-operator / (const ComplexMatrix& a, double s)
-{
-  return ComplexMatrix (divide (a.data (), a.length (), s),
-			a.rows (), a.cols ());
-}
-
-// scalar by matrix -> matrix operations
-
-ComplexMatrix
-operator + (double s, const ComplexMatrix& a)
-{
-  return ComplexMatrix (add (a.data (), a.length (), s), a.rows (),
-			a.cols ());
-}
-
-ComplexMatrix
-operator - (double s, const ComplexMatrix& a)
-{
-  return ComplexMatrix (subtract (s, a.data (), a.length ()),
-			a.rows (), a.cols ());
-}
-
-ComplexMatrix
-operator * (double s, const ComplexMatrix& a)
-{
-  return ComplexMatrix (multiply (a.data (), a.length (), s),
-			a.rows (), a.cols ());
-}
-
-ComplexMatrix
-operator / (double s, const ComplexMatrix& a)
-{
-  return ComplexMatrix (divide (s, a.data (), a.length ()),
-			a.rows (), a.cols ());
-}
-
-ComplexMatrix
-operator + (const Complex& s, const Matrix& a)
-{
-  return ComplexMatrix (add (s, a.data (), a.length ()),
-			a.rows (), a.cols ());
-}
-
-ComplexMatrix
-operator - (const Complex& s, const Matrix& a)
-{
-  return ComplexMatrix (subtract (s, a.data (), a.length ()),
-			a.rows (), a.cols ());
-}
-
-ComplexMatrix
-operator * (const Complex& s, const Matrix& a)
-{
-  return ComplexMatrix (multiply (a.data (), a.length (), s),
-			a.rows (), a.cols ());
-}
-
-ComplexMatrix
-operator / (const Complex& s, const Matrix& a)
-{
-  return ComplexMatrix (divide (s, a.data (), a.length ()),
-			a.rows (), a.cols ());
-}
-
-// matrix by diagonal matrix -> matrix operations
-
-ComplexMatrix
-operator + (const ComplexMatrix& m, const DiagMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nr != a_nr || nc != a_nc)
-    {
-      gripe_nonconformant ("operator +", nr, nc, a_nr, a_nc);
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  ComplexMatrix result (m);
-  for (int i = 0; i < a.length (); i++)
-    result.elem (i, i) += a.elem (i, i);
-
-  return result;
-}
-
-ComplexMatrix
-operator - (const ComplexMatrix& m, const DiagMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nr != a_nr || nc != a_nc)
-    {
-      gripe_nonconformant ("operator -", nr, nc, a_nr, a_nc);
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  ComplexMatrix result (m);
-  for (int i = 0; i < a.length (); i++)
-    result.elem (i, i) -= a.elem (i, i);
-
-  return result;
-}
-
-ComplexMatrix
-operator * (const ComplexMatrix& m, const DiagMatrix& a)
-{
-  ComplexMatrix retval;
-
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nc != a_nr)
-    gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc);
-  else
-    {
-      if (nr == 0 || nc == 0 || a_nc == 0)
-	retval.resize (nr, nc, 0.0);
-      else
-	{
-	  retval.resize (nr, a_nc);
-	  Complex *c = retval.fortran_vec ();
-	  Complex *ctmp = 0;
-
-	  for (int j = 0; j < a.length (); j++)
-	    {
-	      int idx = j * nr;
-	      ctmp = c + idx;
-	      if (a.elem (j, j) == 1.0)
-		{
-		  for (int i = 0; i < nr; i++)
-		    ctmp[i] = m.elem (i, j);
-		}
-	      else if (a.elem (j, j) == 0.0)
-		{
-		  for (int i = 0; i < nr; i++)
-		    ctmp[i] = 0.0;
-		}
-	      else
-		{
-		  for (int i = 0; i < nr; i++)
-		    ctmp[i] = a.elem (j, j) * m.elem (i, j);
-		}
-	    }
-
-	  if (a.rows () < a_nc)
-	    {
-	      for (int i = nr * nc; i < nr * a_nc; i++)
-		ctmp[i] = 0.0;
-	    }
-	}
-    }
-
-  return retval;
-}
-
-ComplexMatrix
-operator + (const ComplexMatrix& m, const ComplexDiagMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nr != a_nr || nc != a_nc)
-    {
-      gripe_nonconformant ("operator +", nr, nc, a_nr, a_nc);
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  ComplexMatrix result (m);
-  for (int i = 0; i < a.length (); i++)
-    result.elem (i, i) += a.elem (i, i);
-
-  return result;
-}
-
-ComplexMatrix
-operator - (const ComplexMatrix& m, const ComplexDiagMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nr != a_nr || nc != a_nc)
-    {
-      gripe_nonconformant ("operator -", nr, nc, a_nr, a_nc);
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  ComplexMatrix result (m);
-  for (int i = 0; i < a.length (); i++)
-    result.elem (i, i) -= a.elem (i, i);
-
-  return result;
-}
-
-ComplexMatrix
-operator * (const ComplexMatrix& m, const ComplexDiagMatrix& a)
-{
-  ComplexMatrix retval;
-
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nc != a_nr)
-    gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc);
-  else
-    {
-      if (nr == 0 || nc == 0 || a_nc == 0)
-	retval.resize (nr, nc, 0.0);
-      else
-	{
-	  retval.resize (nr, nc);
-	  Complex *c = retval.fortran_vec ();
-	  Complex *ctmp = 0;
-
-	  for (int j = 0; j < a.length (); j++)
-	    {
-	      int idx = j * nr;
-	      ctmp = c + idx;
-	      if (a.elem (j, j) == 1.0)
-		{
-		  for (int i = 0; i < nr; i++)
-		    ctmp[i] = m.elem (i, j);
-		}
-	      else if (a.elem (j, j) == 0.0)
-		{
-		  for (int i = 0; i < nr; i++)
-		    ctmp[i] = 0.0;
-		}
-	      else
-		{
-		  for (int i = 0; i < nr; i++)
-		    ctmp[i] = a.elem (j, j) * m.elem (i, j);
-		}
-	    }
-
-	  if (a.rows () < a_nc)
-	    {
-	      for (int i = nr * nc; i < nr * a_nc; i++)
-		ctmp[i] = 0.0;
-	    }
-	}
-    }
-
-  return retval;
-}
-
-// matrix by matrix -> matrix operations
-
-ComplexMatrix
-operator + (const ComplexMatrix& m, const Matrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nr != a_nr || nc != a_nc)
-    {
-      gripe_nonconformant ("operator +", nr, nc, a_nr, a_nc);
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  return ComplexMatrix (add (m.data (), a.data (), m.length ()), nr, nc);
-}
-
-ComplexMatrix
-operator - (const ComplexMatrix& m, const Matrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nr != a_nr || nc != a_nc)
-    {
-      gripe_nonconformant ("operator -", nr, nc, a_nr, a_nc);
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  return ComplexMatrix (subtract (m.data (), a.data (), m.length ()), nr, nc);
-}
-
-ComplexMatrix
-operator + (const Matrix& m, const ComplexMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nr != a_nr || nc != a_nc)
-    {
-      gripe_nonconformant ("operator +", nr, nc, a_nr, a_nc);
-      return ComplexMatrix ();
-    }
-
-  return ComplexMatrix (add (m.data (), a.data (), m.length ()), nr, nc);
-}
-
-ComplexMatrix
-operator - (const Matrix& m, const ComplexMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nr != a_nr || nc != a_nc)
-    {
-      gripe_nonconformant ("operator -", nr, nc, a_nr, a_nc);
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  return ComplexMatrix (subtract (m.data (), a.data (), m.length ()), nr, nc);
-}
-
-ComplexMatrix
-operator * (const ComplexMatrix& m, const Matrix& a)
-{
-  ComplexMatrix tmp (a);
-  return m * tmp;
-}
-
-ComplexMatrix
-operator * (const Matrix& m, const ComplexMatrix& a)
-{
-  ComplexMatrix tmp (m);
-  return tmp * a;
-}
-
-ComplexMatrix
-operator * (const ComplexMatrix& m, const ComplexMatrix& a)
-{
-  ComplexMatrix retval;
-
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nc != a_nr)
-    gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc);
-  else
-    {
-      if (nr == 0 || nc == 0 || a_nc == 0)
-	retval.resize (nr, nc, 0.0);
-      else
-	{
-	  int ld  = nr;
-	  int lda = a.rows ();
-
-	  retval.resize (nr, a_nc);
-	  Complex *c = retval.fortran_vec ();
-
-	  F77_XFCN (zgemm, ZGEMM, ("N", "N", nr, a_nc, nc, 1.0,
-				   m.data (), ld, a.data (), lda, 0.0,
-				   c, nr, 1L, 1L));
-
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler)
-	      ("unrecoverable error in zgemm");
-	}
-    }
-
-  return retval;
-}
-
-ComplexMatrix
-product (const ComplexMatrix& m, const Matrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nr != a_nr || nc != a_nc)
-    {
-      gripe_nonconformant ("product", nr, nc, a_nr, a_nc);
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  return ComplexMatrix (multiply (m.data (), a.data (), m.length ()), nr, nc);
-}
-
-ComplexMatrix
-quotient (const ComplexMatrix& m, const Matrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nr != a_nr || nc != a_nc)
-    {
-      gripe_nonconformant ("quotient", nr, nc, a_nr, a_nc);
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  return ComplexMatrix (divide (m.data (), a.data (), m.length ()), nr, nc);
-}
-
-ComplexMatrix
-product (const Matrix& m, const ComplexMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nr != a_nr || nc != a_nc)
-    {
-      gripe_nonconformant ("product", nr, nc, a_nr, a_nc);
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  return ComplexMatrix (multiply (m.data (), a.data (), m.length ()), nr, nc);
-}
-
-ComplexMatrix
-quotient (const Matrix& m, const ComplexMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nr != a_nr || nc != a_nc)
-    {
-      gripe_nonconformant ("quotient", nr, nc, a_nr, a_nc);
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  return ComplexMatrix (divide (m.data (), a.data (), m.length ()), nr, nc);
-}
-
 // other operations
 
 ComplexMatrix
 ComplexMatrix::map (c_c_Mapper f) const
 {
   ComplexMatrix b (*this);
   return b.apply (f);
 }
@@ -3851,13 +2821,65 @@ Sylvester (const ComplexMatrix& a, const
       // XXX FIXME XXX -- check info?
 
       retval = -ua * cx * ub.hermitian ();
     }
 
   return retval;
 }
 
+ComplexMatrix
+operator * (const ComplexMatrix& m, const Matrix& a)
+{
+  ComplexMatrix tmp (a);
+  return m * tmp;
+}
+
+ComplexMatrix
+operator * (const Matrix& m, const ComplexMatrix& a)
+{
+  ComplexMatrix tmp (m);
+  return tmp * a;
+}
+
+ComplexMatrix
+operator * (const ComplexMatrix& m, const ComplexMatrix& a)
+{
+  ComplexMatrix retval;
+
+  int nr = m.rows ();
+  int nc = m.cols ();
+
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+
+  if (nc != a_nr)
+    gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc);
+  else
+    {
+      if (nr == 0 || nc == 0 || a_nc == 0)
+	retval.resize (nr, nc, 0.0);
+      else
+	{
+	  int ld  = nr;
+	  int lda = a.rows ();
+
+	  retval.resize (nr, a_nc);
+	  Complex *c = retval.fortran_vec ();
+
+	  F77_XFCN (zgemm, ZGEMM, ("N", "N", nr, a_nc, nc, 1.0,
+				   m.data (), ld, a.data (), lda, 0.0,
+				   c, nr, 1L, 1L));
+
+	  if (f77_exception_encountered)
+	    (*current_liboctave_error_handler)
+	      ("unrecoverable error in zgemm");
+	}
+    }
+
+  return retval;
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -56,16 +56,17 @@ public:
   ComplexMatrix (const RowVector& rv);
   ComplexMatrix (const ColumnVector& cv);
   ComplexMatrix (const DiagMatrix& a);
   //  ComplexMatrix (const MDiagArray2<Complex>& a) : MArray2<Complex> (a) { }
   ComplexMatrix (const ComplexRowVector& rv);
   ComplexMatrix (const ComplexColumnVector& cv);
   ComplexMatrix (const ComplexDiagMatrix& a);
 
+  ComplexMatrix (const boolMatrix& a);
   ComplexMatrix (const charMatrix& a);
 
   ComplexMatrix& operator = (const ComplexMatrix& a)
     {
       MArray2<Complex>::operator = (a);
       return *this;
     }
 
@@ -175,153 +176,36 @@ public:
 				   const ComplexRowVector& b);
 
   friend ComplexMatrix operator * (const ComplexColumnVector& a,
 				   const RowVector& b);
 
   friend ComplexMatrix operator * (const ComplexColumnVector& a,
 				   const ComplexRowVector& b);
 
-  // diagonal matrix by scalar -> matrix operations
-
-  friend ComplexMatrix operator + (const DiagMatrix& a, const Complex& s);
-  friend ComplexMatrix operator - (const DiagMatrix& a, const Complex& s);
-
-  friend ComplexMatrix operator + (const ComplexDiagMatrix& a, double s);
-  friend ComplexMatrix operator - (const ComplexDiagMatrix& a, double s);
-
-  friend ComplexMatrix operator + (const ComplexDiagMatrix& a,
-				   const Complex& s);
-  friend ComplexMatrix operator - (const ComplexDiagMatrix& a,
-				   const Complex& s);
-
-  // scalar by diagonal matrix -> matrix operations
-
-  friend ComplexMatrix operator + (const Complex& s, const DiagMatrix& a);
-  friend ComplexMatrix operator - (const Complex& s, const DiagMatrix& a);
-
-  friend ComplexMatrix operator + (double s, const ComplexDiagMatrix& a);
-  friend ComplexMatrix operator - (double s, const ComplexDiagMatrix& a);
-
-  friend ComplexMatrix operator + (const Complex& s,
-				   const ComplexDiagMatrix& a);
-  friend ComplexMatrix operator - (const Complex& s,
-				   const ComplexDiagMatrix& a);
-
   // matrix by diagonal matrix -> matrix operations
 
   ComplexMatrix& operator += (const DiagMatrix& a);
   ComplexMatrix& operator -= (const DiagMatrix& a);
 
   ComplexMatrix& operator += (const ComplexDiagMatrix& a);
   ComplexMatrix& operator -= (const ComplexDiagMatrix& a);
 
-  friend ComplexMatrix operator + (const Matrix& a,
-				   const ComplexDiagMatrix& b); 
-  friend ComplexMatrix operator - (const Matrix& a,
-				   const ComplexDiagMatrix& b);
-  friend ComplexMatrix operator * (const Matrix& a,
-				   const ComplexDiagMatrix& b);
-
-  // diagonal matrix by matrix -> matrix operations
-
-  friend ComplexMatrix operator + (const DiagMatrix& a,
-				   const ComplexMatrix& b);
-  friend ComplexMatrix operator - (const DiagMatrix& a,
-				   const ComplexMatrix& b);
-  friend ComplexMatrix operator * (const DiagMatrix& a,
-				   const ComplexMatrix& b);
-
-  friend ComplexMatrix operator + (const ComplexDiagMatrix& a,
-				   const Matrix& b); 
-  friend ComplexMatrix operator - (const ComplexDiagMatrix& a,
-				   const Matrix& b);
-  friend ComplexMatrix operator * (const ComplexDiagMatrix& a,
-				   const Matrix& b);
-
-  friend ComplexMatrix operator + (const ComplexDiagMatrix& a,
-				   const ComplexMatrix& b);
-  friend ComplexMatrix operator - (const ComplexDiagMatrix& a,
-				   const ComplexMatrix& b);
-  friend ComplexMatrix operator * (const ComplexDiagMatrix& a,
-				   const ComplexMatrix& b);
-
   // matrix by matrix -> matrix operations
 
   ComplexMatrix& operator += (const Matrix& a);
   ComplexMatrix& operator -= (const Matrix& a);
 
   ComplexMatrix& operator += (const ComplexMatrix& a);
   ComplexMatrix& operator -= (const ComplexMatrix& a);
 
   // unary operations
 
   Matrix operator ! (void) const;
 
-  // matrix by scalar -> matrix operations
-
-  friend ComplexMatrix operator + (const Matrix& a, const Complex& s);
-  friend ComplexMatrix operator - (const Matrix& a, const Complex& s);
-  friend ComplexMatrix operator * (const Matrix& a, const Complex& s);
-  friend ComplexMatrix operator / (const Matrix& a, const Complex& s);
-
-  friend ComplexMatrix operator + (const ComplexMatrix& a, double s);
-  friend ComplexMatrix operator - (const ComplexMatrix& a, double s);
-  friend ComplexMatrix operator * (const ComplexMatrix& a, double s);
-  friend ComplexMatrix operator / (const ComplexMatrix& a, double s);
-
-  // scalar by matrix -> matrix operations
-
-  friend ComplexMatrix operator + (double s, const ComplexMatrix& a);
-  friend ComplexMatrix operator - (double s, const ComplexMatrix& a);
-  friend ComplexMatrix operator * (double s, const ComplexMatrix& a);
-  friend ComplexMatrix operator / (double s, const ComplexMatrix& a);
-
-  friend ComplexMatrix operator + (const Complex& s, const Matrix& a);
-  friend ComplexMatrix operator - (const Complex& s, const Matrix& a);
-  friend ComplexMatrix operator * (const Complex& s, const Matrix& a);
-  friend ComplexMatrix operator / (const Complex& s, const Matrix& a);
-
-  // matrix by diagonal matrix -> matrix operations
-
-  friend ComplexMatrix operator + (const ComplexMatrix& a,
-				   const DiagMatrix& b);
-  friend ComplexMatrix operator - (const ComplexMatrix& a,
-				   const DiagMatrix& b);
-  friend ComplexMatrix operator * (const ComplexMatrix& a,
-				   const DiagMatrix& b);
-
-  friend ComplexMatrix operator + (const ComplexMatrix& a,
-				   const ComplexDiagMatrix& b);
-  friend ComplexMatrix operator - (const ComplexMatrix& a,
-				   const ComplexDiagMatrix& b);
-  friend ComplexMatrix operator * (const ComplexMatrix& a,
-				   const ComplexDiagMatrix& b);
-
-  // matrix by matrix -> matrix operations
-
-  friend ComplexMatrix operator + (const ComplexMatrix& a, const Matrix& b);
-  friend ComplexMatrix operator - (const ComplexMatrix& a, const Matrix& b);
-
-  friend ComplexMatrix operator + (const Matrix& a, const ComplexMatrix& b);
-  friend ComplexMatrix operator - (const Matrix& a, const ComplexMatrix& b);
-
-  friend ComplexMatrix operator * (const ComplexMatrix& a, const Matrix& b);
-
-  friend ComplexMatrix operator * (const Matrix& a, const ComplexMatrix& b);
-
-  friend ComplexMatrix operator * (const ComplexMatrix& a,
-				   const ComplexMatrix& b);
-
-  friend ComplexMatrix product (const ComplexMatrix& a, const Matrix& b);
-  friend ComplexMatrix quotient (const ComplexMatrix& a, const Matrix& b);
-
-  friend ComplexMatrix product (const Matrix& a, const ComplexMatrix& b);
-  friend ComplexMatrix quotient (const Matrix& a, const ComplexMatrix& b);
-
   // other operations
 
   ComplexMatrix map (c_c_Mapper f) const;
   Matrix map (d_c_Mapper f) const;
 
   ComplexMatrix& apply (c_c_Mapper f);
 
   bool any_element_is_inf_or_nan (void) const;
@@ -366,15 +250,19 @@ private:
   ComplexMatrix (Complex *d, int r, int c) : MArray2<Complex> (d, r, c) { }
 };
 
 ComplexMatrix Givens (const Complex&, const Complex&);
 
 ComplexMatrix Sylvester (const ComplexMatrix&, const ComplexMatrix&,
 			 const ComplexMatrix&);
 
+extern ComplexMatrix operator * (const Matrix&,        const ComplexMatrix&);
+extern ComplexMatrix operator * (const ComplexMatrix&, const Matrix&);
+extern ComplexMatrix operator * (const ComplexMatrix&, const ComplexMatrix&);
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/boolMatrix.cc b/liboctave/boolMatrix.cc
new file mode 100644
--- /dev/null
+++ b/liboctave/boolMatrix.cc
@@ -0,0 +1,82 @@
+// Matrix manipulations.
+/*
+
+Copyright (C) 1996 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <iostream.h>
+
+#include "lo-error.h"
+#include "str-vec.h"
+#include "mx-base.h"
+#include "mx-inlines.cc"
+
+// boolMatrix class.
+
+bool
+boolMatrix::operator == (const boolMatrix& a) const
+{
+  if (rows () != a.rows () || cols () != a.cols ())
+    return 0;
+
+  return equal (data (), a.data (), length ());
+}
+
+bool
+boolMatrix::operator != (const boolMatrix& a) const
+{
+  return !(*this == a);
+}
+
+boolMatrix&
+boolMatrix::insert (const boolMatrix& a, int r, int c)
+{
+  Array2<bool>::insert (a, r, c);
+  return *this;
+}
+
+boolMatrix
+boolMatrix::transpose (void) const
+{
+  int nr = rows ();
+  int nc = cols ();
+  boolMatrix result (nc, nr);
+  if (length () > 0)
+    {
+      for (int j = 0; j < nc; j++)
+	for (int i = 0; i < nr; i++)
+	  result.elem (j, i) = elem (i, j);
+    }
+  return result;
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/boolMatrix.h b/liboctave/boolMatrix.h
new file mode 100644
--- /dev/null
+++ b/liboctave/boolMatrix.h
@@ -0,0 +1,78 @@
+/*
+
+Copyright (C) 1996 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if !defined (octave_boolMatrix_int_h)
+#define octave_boolMatrix_int_h 1
+
+#if defined (__GNUG__)
+#pragma interface
+#endif
+
+#include "MArray2.h"
+
+#include "mx-defs.h"
+
+class
+boolMatrix : public MArray2<bool>
+{
+public:
+
+  boolMatrix (void) : MArray2<bool> () { }
+  boolMatrix (int r, int c) : MArray2<bool> (r, c) { }
+  boolMatrix (int r, int c, bool val) : MArray2<bool> (r, c, val) { }
+  boolMatrix (const MArray2<bool>& a) : MArray2<bool> (a) { }
+  boolMatrix (const boolMatrix& a) : MArray2<bool> (a) { }
+
+  boolMatrix& operator = (const boolMatrix& a)
+    {
+      MArray2<bool>::operator = (a);
+      return *this;
+    }
+
+  bool operator == (const boolMatrix& a) const;
+  bool operator != (const boolMatrix& a) const;
+
+  // destructive insert/delete/reorder operations
+
+  boolMatrix& insert (const boolMatrix& a, int r, int c);
+
+  boolMatrix transpose (void) const;
+
+#if 0
+  // i/o
+
+  friend ostream& operator << (ostream& os, const Matrix& a);
+  friend istream& operator >> (istream& is, Matrix& a);
+#endif
+
+private:
+
+  boolMatrix (bool *b, int r, int c) : MArray2<bool> (b, r, c) { }
+};
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/chMatrix.cc b/liboctave/chMatrix.cc
--- a/liboctave/chMatrix.cc
+++ b/liboctave/chMatrix.cc
@@ -24,25 +24,20 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <cstdio>
-#include <cstring>
-
 #include <string>
 
 #include <iostream.h>
 
-// #include <sys/types.h>  // XXX FIXME XXX
-
 #include "lo-error.h"
 #include "str-vec.h"
 #include "mx-base.h"
 #include "mx-inlines.cc"
 
 // charMatrix class.
 
 charMatrix::charMatrix (const char *s)
diff --git a/liboctave/chMatrix.h b/liboctave/chMatrix.h
--- a/liboctave/chMatrix.h
+++ b/liboctave/chMatrix.h
@@ -22,19 +22,16 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_chMatrix_int_h)
 #define octave_chMatrix_int_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
-// For FILE...
-#include <cstdio>
-
 #include <string>
 
 #include "MArray2.h"
 
 #include "mx-defs.h"
 #include "str-vec.h"
 
 class
@@ -64,182 +61,23 @@ public:
 
   // destructive insert/delete/reorder operations
 
   charMatrix& insert (const char *s, int r, int c);
   charMatrix& insert (const charMatrix& a, int r, int c);
 
   string row_as_string (int r, bool strip_trailing_whitespace = false) const;
 
-#if 0
-  Matrix& insert (const RowVector& a, int r, int c);
-  Matrix& insert (const ColumnVector& a, int r, int c);
-  Matrix& insert (const DiagMatrix& a, int r, int c);
-
-  Matrix& fill (char val);
-  Matrix& fill (char val, int r1, int c1, int r2, int c2);
-
-  Matrix append (const Matrix& a) const;
-  Matrix append (const RowVector& a) const;
-  Matrix append (const ColumnVector& a) const;
-  Matrix append (const DiagMatrix& a) const;
-
-  Matrix stack (const Matrix& a) const;
-  Matrix stack (const RowVector& a) const;
-  Matrix stack (const ColumnVector& a) const;
-  Matrix stack (const DiagMatrix& a) const;
-#endif
-
   charMatrix transpose (void) const;
 
 #if 0
-  friend Matrix real (const ComplexMatrix& a);
-  friend Matrix imag (const ComplexMatrix& a);
-
-  // resize is the destructive equivalent for this one
-
-  Matrix extract (int r1, int c1, int r2, int c2) const;
-
-  // extract row or column i.
-
-  RowVector row (int i) const;
-  RowVector row (char *s) const;
-
-  ColumnVector column (int i) const;
-  ColumnVector column (char *s) const;
-
-  Matrix inverse (void) const;
-  Matrix inverse (int& info) const;
-  Matrix inverse (int& info, double& rcond) const;
-
-  Matrix pseudo_inverse (double tol = 0.0);
-
-  ComplexMatrix fourier (void) const;
-  ComplexMatrix ifourier (void) const;
-
-  ComplexMatrix fourier2d (void) const;
-  ComplexMatrix ifourier2d (void) const;
-
-  DET determinant (void) const;
-  DET determinant (int& info) const;
-  DET determinant (int& info, double& rcond) const;
-
-  Matrix solve (const Matrix& b) const;
-  Matrix solve (const Matrix& b, int& info) const;
-  Matrix solve (const Matrix& b, int& info, double& rcond) const;
-
-  ComplexMatrix solve (const ComplexMatrix& b) const;
-  ComplexMatrix solve (const ComplexMatrix& b, int& info) const;
-  ComplexMatrix solve (const ComplexMatrix& b, int& info, double& rcond) const;
-
-  ColumnVector solve (const ColumnVector& b) const;
-  ColumnVector solve (const ColumnVector& b, int& info) const;
-  ColumnVector solve (const ColumnVector& b, int& info, double& rcond) const;
-
-  ComplexColumnVector solve (const ComplexColumnVector& b) const;
-  ComplexColumnVector solve (const ComplexColumnVector& b, int& info) const;
-  ComplexColumnVector solve (const ComplexColumnVector& b, int& info,
-			     double& rcond) const;
-
-  Matrix lssolve (const Matrix& b) const;
-  Matrix lssolve (const Matrix& b, int& info) const;
-  Matrix lssolve (const Matrix& b, int& info, int& rank) const;
-
-  ComplexMatrix lssolve (const ComplexMatrix& b) const;
-  ComplexMatrix lssolve (const ComplexMatrix& b, int& info) const;
-  ComplexMatrix lssolve (const ComplexMatrix& b, int& info,
-			 int& rank) const;
-
-  ColumnVector lssolve (const ColumnVector& b) const;
-  ColumnVector lssolve (const ColumnVector& b, int& info) const;
-  ColumnVector lssolve (const ColumnVector& b, int& info, int& rank) const;
-
-  ComplexColumnVector lssolve (const ComplexColumnVector& b) const;
-  ComplexColumnVector lssolve (const ComplexColumnVector& b, int& info) const;
-  ComplexColumnVector lssolve (const ComplexColumnVector& b, int& info,
-			       int& rank) const;
-
-  Matrix& operator += (const Matrix& a);
-  Matrix& operator -= (const Matrix& a);
-
-  Matrix& operator += (const DiagMatrix& a);
-  Matrix& operator -= (const DiagMatrix& a);
-
-  // unary operations
-
-  Matrix operator ! (void) const;
-
-  // column vector by row vector -> matrix operations
-
-  friend Matrix operator * (const ColumnVector& a, const RowVector& a);
-
-  // diagonal matrix by scalar -> matrix operations
-
-  friend Matrix operator + (const DiagMatrix& a, double s);
-  friend Matrix operator - (const DiagMatrix& a, double s);
-
-  // scalar by diagonal matrix -> matrix operations
-
-  friend Matrix operator + (double s, const DiagMatrix& a);
-  friend Matrix operator - (double s, const DiagMatrix& a);
-
-  // matrix by diagonal matrix -> matrix operations
-
-  friend Matrix operator + (const Matrix& a, const DiagMatrix& b);
-  friend Matrix operator - (const Matrix& a, const DiagMatrix& b);
-  friend Matrix operator * (const Matrix& a, const DiagMatrix& b);
-
-  // diagonal matrix by matrix -> matrix operations
-
-  friend Matrix operator + (const DiagMatrix& a, const Matrix& b);
-  friend Matrix operator - (const DiagMatrix& a, const Matrix& b);
-  friend Matrix operator * (const DiagMatrix& a, const Matrix& b);
-
-  // matrix by matrix -> matrix operations
-
-  friend Matrix operator * (const Matrix& a, const Matrix& b);
-
-  // other operations
-
-  friend Matrix map (d_d_Mapper f, const Matrix& a);
-  friend Matrix map (d_c_Mapper f, const ComplexMatrix& a);
-
-  void map (d_d_Mapper f);
-
-  Matrix all (void) const;
-  Matrix any (void) const;
-
-  Matrix cumprod (void) const;
-  Matrix cumsum (void) const;
-  Matrix prod (void) const;
-  Matrix sum (void) const;
-  Matrix sumsq (void) const;
-
-  ColumnVector diag (void) const;
-  ColumnVector diag (int k) const;
-
-  ColumnVector row_min (void) const;
-  ColumnVector row_min_loc (void) const;
-
-  ColumnVector row_max (void) const;
-  ColumnVector row_max_loc (void) const;
-
-  RowVector column_min (void) const;
-  RowVector column_min_loc (void) const;
-
-  RowVector column_max (void) const;
-  RowVector column_max_loc (void) const;
-
   // i/o
 
   friend ostream& operator << (ostream& os, const Matrix& a);
   friend istream& operator >> (istream& is, Matrix& a);
-
-  int read (FILE *fptr, const char *type);
-  int write (FILE *fptr, const char *type);
 #endif
 
 private:
 
   charMatrix (char *ch, int r, int c) : MArray2<char> (ch, r, c) { }
 };
 
 #endif
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -29,26 +29,28 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include <cfloat>
 
 #include <iostream.h>
 
 #include "byte-swap.h"
+#include "dMatrix.h"
 #include "dbleAEPBAL.h"
 #include "dbleDET.h"
 #include "dbleSCHUR.h"
 #include "dbleSVD.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "lo-utils.h"
 #include "mx-base.h"
+#include "mx-m-dm.h"
 #include "mx-inlines.cc"
 #include "oct-cmplx.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
   int F77_FCN (dgemm, DGEMM) (const char*, const char*, const int&,
@@ -130,16 +132,24 @@ Matrix::Matrix (const DiagMatrix& a)
 {
   for (int i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
 // XXX FIXME XXX -- could we use a templated mixed-type copy function
 // here?
 
+Matrix::Matrix (const boolMatrix& a)
+  : MArray2<double> (a.rows (), a.cols ())
+{
+  for (int i = 0; i < a.rows (); i++)
+    for (int j = 0; j < a.cols (); j++)
+      elem (i, j) = a.elem (i, j);
+}
+
 Matrix::Matrix (const charMatrix& a)
   : MArray2<double> (a.rows (), a.cols ())
 {
   for (int i = 0; i < a.rows (); i++)
     for (int j = 0; j < a.cols (); j++)
       elem (i, j) = a.elem (i, j);
 }
 
@@ -1549,300 +1559,16 @@ operator * (const ColumnVector& v, const
 	    (*current_liboctave_error_handler)
 	      ("unrecoverable error in dgemm");
 	}
     }
 
   return retval;
 }
 
-// diagonal matrix by scalar -> matrix operations
-
-Matrix
-operator + (const DiagMatrix& a, double s)
-{
-  Matrix tmp (a.rows (), a.cols (), s);
-  return a + tmp;
-}
-
-Matrix
-operator - (const DiagMatrix& a, double s)
-{
-  Matrix tmp (a.rows (), a.cols (), -s);
-  return a + tmp;
-}
-
-// scalar by diagonal matrix -> matrix operations
-
-Matrix
-operator + (double s, const DiagMatrix& a)
-{
-  Matrix tmp (a.rows (), a.cols (), s);
-  return tmp + a;
-}
-
-Matrix
-operator - (double s, const DiagMatrix& a)
-{
-  Matrix tmp (a.rows (), a.cols (), s);
-  return tmp - a;
-}
-
-// matrix by diagonal matrix -> matrix operations
-
-Matrix
-operator + (const Matrix& m, const DiagMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nr != a_nr || nc != a_nc)
-    {
-      gripe_nonconformant ("operator +", nr, nc, a_nr, a_nc);
-      return Matrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return Matrix (nr, nc);
-
-  Matrix result (m);
-  int a_len = a.length ();
-  for (int i = 0; i < a_len; i++)
-    result.elem (i, i) += a.elem (i, i);
-
-  return result;
-}
-
-Matrix
-operator - (const Matrix& m, const DiagMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nr != a_nr || nc != a_nc)
-    {
-      gripe_nonconformant ("operator -", nr, nc, a_nr, a_nc);
-      return Matrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return Matrix (nr, nc);
-
-  Matrix result (m);
-  int a_len = a.length ();
-  for (int i = 0; i < a_len; i++)
-    result.elem (i, i) -= a.elem (i, i);
-
-  return result;
-}
-
-Matrix
-operator * (const Matrix& m, const DiagMatrix& a)
-{
-  Matrix retval;
-
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nc != a_nr)
-    gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc);
-  else
-    {
-      if (nr == 0 || nc == 0 || a_nc == 0)
-	retval.resize (nr, a_nc, 0.0);
-      else
-	{
-	  retval.resize (nr, a_nc);
-	  double *c = retval.fortran_vec ();
-
-	  double *ctmp = 0;
-
-	  int a_len = a.length ();
-
-	  for (int j = 0; j < a_len; j++)
-	    {
-	      int idx = j * nr;
-	      ctmp = c + idx;
-
-	      if (a.elem (j, j) == 1.0)
-		{
-		  for (int i = 0; i < nr; i++)
-		    ctmp[i] = m.elem (i, j);
-		}
-	      else if (a.elem (j, j) == 0.0)
-		{
-		  for (int i = 0; i < nr; i++)
-		    ctmp[i] = 0.0;
-		}
-	      else
-		{
-		  for (int i = 0; i < nr; i++)
-		    ctmp[i] = a.elem (j, j) * m.elem (i, j);
-		}
-	    }
-
-	  if (a_nr < a_nc)
-	    {
-	      for (int i = nr * nc; i < nr * a_nc; i++)
-		ctmp[i] = 0.0;
-	    }
-	}
-    }
-
-  return retval;
-}
-
-// diagonal matrix by matrix -> matrix operations
-
-Matrix
-operator + (const DiagMatrix& m, const Matrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nr != a_nr || nc != a_nc)
-    {
-      gripe_nonconformant ("operator +", nr, nc, a_nr, a_nc);
-      return Matrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return Matrix (nr, nc);
-
-  Matrix result (a);
-  for (int i = 0; i < m.length (); i++)
-    result.elem (i, i) += m.elem (i, i);
-
-  return result;
-}
-
-Matrix
-operator - (const DiagMatrix& m, const Matrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nr != a_nr || nc != a_nc)
-    {
-      gripe_nonconformant ("operator -", nr, nc, a_nr, a_nc);
-      return Matrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return Matrix (nr, nc);
-
-  Matrix result (-a);
-  for (int i = 0; i < m.length (); i++)
-    result.elem (i, i) += m.elem (i, i);
-
-  return result;
-}
-
-Matrix
-operator * (const DiagMatrix& m, const Matrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-  if (nc != a_nr)
-    {
-      gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc);
-      return Matrix ();
-    }
-
-  if (nr == 0 || nc == 0 || a_nc == 0)
-    return Matrix (nr, a_nc, 0.0);
-
-  Matrix c (nr, a_nc);
-
-  for (int i = 0; i < m.length (); i++)
-    {
-      if (m.elem (i, i) == 1.0)
-	{
-	  for (int j = 0; j < a_nc; j++)
-	    c.elem (i, j) = a.elem (i, j);
-	}
-      else if (m.elem (i, i) == 0.0)
-	{
-	  for (int j = 0; j < a_nc; j++)
-	    c.elem (i, j) = 0.0;
-	}
-      else
-	{
-	  for (int j = 0; j < a_nc; j++)
-	    c.elem (i, j) = m.elem (i, i) * a.elem (i, j);
-	}
-    }
-
-  if (nr > nc)
-    {
-      for (int j = 0; j < a_nc; j++)
-	for (int i = a_nr; i < nr; i++)
-	  c.elem (i, j) = 0.0;
-    }
-
-  return c;
-}
-
-// matrix by matrix -> matrix operations
-
-Matrix
-operator * (const Matrix& m, const Matrix& a)
-{
-  Matrix retval;
-
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-
-  if (nc != a_nr)
-    gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc);
-  else
-    {
-      if (nr == 0 || nc == 0 || a_nc == 0)
-	retval.resize (nr, a_nc, 0.0);
-      else
-	{
-	  int ld  = nr;
-	  int lda = a_nr;
-
-	  retval.resize (nr, a_nc);
-	  double *c = retval.fortran_vec ();
-
-	  F77_XFCN (dgemm, DGEMM, ("N", "N", nr, a_nc, nc, 1.0,
-				   m.data (), ld, a.data (), lda, 0.0,
-				   c, nr, 1L, 1L));
-
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler)
-	      ("unrecoverable error in dgemm");
-	}
-    }
-
-  return retval;
-}
-
 // other operations.
 
 Matrix
 Matrix::map (d_d_Mapper f) const
 {
   Matrix b (*this);
   return b.apply (f);
 }
@@ -3278,13 +3004,53 @@ Qzval (const Matrix& a, const Matrix& b)
 	gripe_nonconformant ("qzval", a_nr, a_nc, b_nr, b_nc);
     }
   else
     (*current_liboctave_error_handler) ("qzval: square matrices required");
 
   return retval;
 }
 
+// matrix by matrix -> matrix operations
+
+Matrix
+operator * (const Matrix& m, const Matrix& a)
+{
+  Matrix retval;
+
+  int nr = m.rows ();
+  int nc = m.cols ();
+
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+
+  if (nc != a_nr)
+    gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc);
+  else
+    {
+      if (nr == 0 || nc == 0 || a_nc == 0)
+	retval.resize (nr, a_nc, 0.0);
+      else
+	{
+	  int ld  = nr;
+	  int lda = a_nr;
+
+	  retval.resize (nr, a_nc);
+	  double *c = retval.fortran_vec ();
+
+	  F77_XFCN (dgemm, DGEMM, ("N", "N", nr, a_nc, nc, 1.0,
+				   m.data (), ld, a.data (), lda, 0.0,
+				   c, nr, 1L, 1L));
+
+	  if (f77_exception_encountered)
+	    (*current_liboctave_error_handler)
+	      ("unrecoverable error in dgemm");
+	}
+    }
+
+  return retval;
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -55,16 +55,17 @@ public:
   Matrix (int r, int c, double val) : MArray2<double> (r, c, val) { }
   Matrix (const MArray2<double>& a) : MArray2<double> (a) { }
   Matrix (const Matrix& a) : MArray2<double> (a) { }
   Matrix (const RowVector& rv);
   Matrix (const ColumnVector& cv);
   //  Matrix (const MDiagArray2<double>& a) : MArray2<double> (a) { }
   Matrix (const DiagMatrix& a);
 
+  Matrix (const boolMatrix& a);
   Matrix (const charMatrix& a);
 
   Matrix& operator = (const Matrix& a)
     {
       MArray2<double>::operator = (a);
       return *this;
     }
 
@@ -170,42 +171,16 @@ public:
   // unary operations
 
   Matrix operator ! (void) const;
 
   // column vector by row vector -> matrix operations
 
   friend Matrix operator * (const ColumnVector& a, const RowVector& b);
 
-  // diagonal matrix by scalar -> matrix operations
-
-  friend Matrix operator + (const DiagMatrix& a, double s);
-  friend Matrix operator - (const DiagMatrix& a, double s);
-
-  // scalar by diagonal matrix -> matrix operations
-
-  friend Matrix operator + (double s, const DiagMatrix& a);
-  friend Matrix operator - (double s, const DiagMatrix& a);
-
-  // matrix by diagonal matrix -> matrix operations
-
-  friend Matrix operator + (const Matrix& a, const DiagMatrix& b);
-  friend Matrix operator - (const Matrix& a, const DiagMatrix& b);
-  friend Matrix operator * (const Matrix& a, const DiagMatrix& b);
-
-  // diagonal matrix by matrix -> matrix operations
-
-  friend Matrix operator + (const DiagMatrix& a, const Matrix& b);
-  friend Matrix operator - (const DiagMatrix& a, const Matrix& b);
-  friend Matrix operator * (const DiagMatrix& a, const Matrix& b);
-
-  // matrix by matrix -> matrix operations
-
-  friend Matrix operator * (const Matrix& a, const Matrix& b);
-
   // other operations
 
   Matrix map (d_d_Mapper f) const;
 
   Matrix& apply (d_d_Mapper f);
 
   bool any_element_is_negative (void) const;
   bool any_element_is_inf_or_nan (void) const;
@@ -255,15 +230,17 @@ private:
 };
 
 extern Matrix Givens (double, double);
 
 extern Matrix Sylvester (const Matrix&, const Matrix&, const Matrix&);
 
 extern ComplexColumnVector Qzval (const Matrix& a, const Matrix& b);
 
+extern Matrix operator * (const Matrix& a, const Matrix& b);
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/idx-vector.cc b/liboctave/idx-vector.cc
--- a/liboctave/idx-vector.cc
+++ b/liboctave/idx-vector.cc
@@ -28,16 +28,17 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include <cstdlib>
 
 #include <iostream.h>
 
 #include "Range.h"
+#include "boolMatrix.h"
 #include "dColVector.h"
 #include "dMatrix.h"
 
 #include "idx-vector.h"
 #include "lo-error.h"
 #include "lo-mappers.h"
 
 #define IDX_VEC_REP idx_vector::idx_vector_rep
@@ -99,27 +100,27 @@ idx_is_inf_or_nan (double x)
 IDX_VEC_REP::idx_vector_rep (const ColumnVector& v)
 {
   data = 0;
   initialized = 0;
   frozen = 0;
   colon_equiv_checked = 0;
   colon_equiv = 0;
   colon = 0;
+  one_zero = 0;
 
   len = v.length ();
 
   orig_nr = len;
   orig_nc = 1;
 
   if (len == 0)
     {
       num_zeros = 0;
       num_ones = 0;
-      one_zero = 0;
       max_val = 0;
       min_val = 0;
       initialized = 1;
       return;
     }
   else
     {
       data = new int [len];
@@ -141,27 +142,27 @@ IDX_VEC_REP::idx_vector_rep (const Colum
 IDX_VEC_REP::idx_vector_rep (const Matrix& m)
 {
   data = 0;
   initialized = 0;
   frozen = 0;
   colon_equiv_checked = 0;
   colon_equiv = 0;
   colon = 0;
+  one_zero = 0;
 
   orig_nr = m.rows ();
   orig_nc = m.columns ();
 
   len = orig_nr * orig_nc;
 
   if (len == 0)
     {
       num_zeros = 0;
       num_ones = 0;
-      one_zero = 0;
       max_val = 0;
       min_val = 0;
       initialized = 1;
       return;
     }
   else
     {
       int k = 0;
@@ -185,16 +186,17 @@ IDX_VEC_REP::idx_vector_rep (const Matri
 IDX_VEC_REP::idx_vector_rep (double d)
 {
   data = 0;
   initialized = 0;
   frozen = 0;
   colon_equiv_checked = 0;
   colon_equiv = 0;
   colon = 0;
+  one_zero = 0;
 
   len = 1;
 
   orig_nr = 1;
   orig_nc = 1;
 
   if (idx_is_inf_or_nan (d))
     return;
@@ -211,32 +213,32 @@ IDX_VEC_REP::idx_vector_rep (double d)
 IDX_VEC_REP::idx_vector_rep (const Range& r)
 {
   data = 0;
   initialized = 0;
   frozen = 0;
   colon_equiv_checked = 0;
   colon_equiv = 0;
   colon = 0;
+  one_zero = 0;
 
   len = r.nelem ();
 
   orig_nr = 1;
   orig_nc = len;
 
   if (len < 0)
     {
       (*current_liboctave_error_handler) ("invalid range used as index");
       return;
     }
   else if (len == 0)
     {
       num_zeros = 0;
       num_ones = 0;
-      one_zero = 0;
       max_val = 0;
       min_val = 0;
       initialized = 1;
       return;
     }
 
   double b = r.base ();
   double step = r.inc ();
@@ -269,16 +271,76 @@ IDX_VEC_REP::idx_vector_rep (char c)
   frozen = 0;
   colon_equiv_checked = 0;
   colon_equiv = 0;
   data = 0;
 
   init_state ();
 }
 
+IDX_VEC_REP::idx_vector_rep (bool b)
+{
+  data = 0;
+  initialized = 0;
+  frozen = 0;
+  colon_equiv_checked = 0;
+  colon_equiv = 0;
+  colon = 0;
+  one_zero = 1;
+
+  len = 1;
+
+  orig_nr = 1;
+  orig_nc = 1;
+
+  data = new int [len];
+
+  data[0] = tree_to_mat_idx (b);
+
+  init_state ();
+}
+
+IDX_VEC_REP::idx_vector_rep (const boolMatrix& bm)
+{
+  data = 0;
+  initialized = 0;
+  frozen = 0;
+  colon_equiv_checked = 0;
+  colon_equiv = 0;
+  colon = 0;
+  one_zero = 1;
+
+  orig_nr = bm.rows ();
+  orig_nc = bm.columns ();
+
+  len = orig_nr * orig_nc;
+
+  if (len == 0)
+    {
+      num_zeros = 0;
+      num_ones = 0;
+      one_zero = 0;
+      max_val = 0;
+      min_val = 0;
+      initialized = 1;
+      return;
+    }
+  else
+    {
+      int k = 0;
+      data = new int [len];
+
+      for (int j = 0; j < orig_nc; j++)
+	for (int i = 0; i < orig_nr; i++)
+	  data[k++] = tree_to_mat_idx (bm.elem (i, j));
+    }
+
+  init_state ();
+}
+
 IDX_VEC_REP&
 IDX_VEC_REP::operator = (const IDX_VEC_REP& a)
 {
   if (this != &a)
     {
       initialized = a.initialized;
       frozen = a.frozen;
       colon_equiv_checked = a.colon_equiv_checked;
@@ -308,53 +370,47 @@ IDX_VEC_REP::operator = (const IDX_VEC_R
 void
 IDX_VEC_REP::init_state (void)
 {
   num_zeros = 0;
   num_ones = 0;
 
   if (colon)
     {
-      one_zero = 0;
-      min_val = max_val = 0;
+      min_val = 0;
+      max_val = 0;
     }
   else
     {
-      one_zero = 1;
-
       min_val = max_val = data[0];
 
       int i = 0;
       do
 	{
 	  if (data[i] == -1)
 	    num_zeros++;
 	  else if (data[i] == 0)
 	    num_ones++;
 
-	  if (one_zero && data[i] != -1 && data[i] != 0)
-	    one_zero = 0;
-
 	  if (data[i] > max_val)
 	    max_val = data[i];
 
 	  if (data[i] < min_val)
 	    min_val = data[i];
 	}
       while (++i < len);
     }
 
   initialized = 1;
 }
 
 void
-IDX_VEC_REP::maybe_convert_one_zero_to_idx (int z_len, int prefer_zero_one)
+IDX_VEC_REP::maybe_convert_one_zero_to_idx (int z_len)
 {
-  if (one_zero && z_len == len
-      && (num_ones != len || prefer_zero_one))
+  if (one_zero && z_len == len)
     {
       if (num_ones == 0)
 	{
 	  len = 0;
 	  max_val = 0;
 	  min_val = 0;
 	  delete [] data;
 	  data = 0;
@@ -510,17 +566,17 @@ IDX_VEC_REP::freeze (int z_len, const ch
   if (colon)
     frozen_len = z_len;
   else
     {
       if (len == 0)
 	frozen_len = 0;
       else
 	{
-	  maybe_convert_one_zero_to_idx (z_len, prefer_zero_one);
+	  maybe_convert_one_zero_to_idx (z_len);
 
 	  max_val = max ();
 	  min_val = min ();
 
 	  if (min_val < 0)
 	    {
 	      if (tag)
 		(*current_liboctave_error_handler)
diff --git a/liboctave/idx-vector.h b/liboctave/idx-vector.h
--- a/liboctave/idx-vector.h
+++ b/liboctave/idx-vector.h
@@ -24,16 +24,17 @@ Software Foundation, 59 Temple Place - S
 #define octave_idx_vector_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 class ostream;
 class ColumnVector;
+class boolMatrix;
 class Matrix;
 class Range;
 
 class
 idx_vector
 {
 private:
 
@@ -63,16 +64,20 @@ private:
     idx_vector_rep (const Matrix& m);
 
     idx_vector_rep (const Range& r);
 
     idx_vector_rep (double d);
 
     idx_vector_rep (char c);
 
+    idx_vector_rep (bool b);
+
+    idx_vector_rep (const boolMatrix& bm);
+
     idx_vector_rep (const idx_vector_rep& a);
 
     ~idx_vector_rep (void) { delete [] data; }
 
     idx_vector_rep& operator = (const idx_vector_rep& a);
 
     int ok (void) { return initialized; }
 
@@ -123,17 +128,17 @@ private:
     unsigned int one_zero : 1;
     unsigned int initialized : 1;
     unsigned int frozen : 1;
     unsigned int colon_equiv_checked : 1;
     unsigned int colon_equiv : 1;
 
     void init_state (void);
 
-    void maybe_convert_one_zero_to_idx (int z_len, int prefer_zero_one);
+    void maybe_convert_one_zero_to_idx (int z_len);
   };
 
 public:
 
   idx_vector (void)
     {
       rep = new idx_vector_rep ();
       rep->count = 1;
@@ -164,16 +169,28 @@ public:
     }
 
   idx_vector (char c)
     {
       rep = new idx_vector_rep (c);
       rep->count = 1;
     }
 
+  idx_vector (bool b)
+    {
+      rep = new idx_vector_rep (b);
+      rep->count = 1;
+    }
+
+  idx_vector (const boolMatrix& bm)
+    {
+      rep = new idx_vector_rep (bm);
+      rep->count = 1;
+    }
+
   idx_vector (const idx_vector& a)
     {
       rep = a.rep;
       rep->count++;
     }
 
   ~idx_vector (void)
     {
@@ -233,18 +250,18 @@ public:
 	      int resize_ok = 0)
     { return rep->freeze (z_len, tag, prefer_zero_one, resize_ok); }
 
   ostream& print (ostream& os) const { return rep->print (os); }
 
   friend ostream& operator << (ostream& os, const idx_vector& a)
     { return a.print (os); }
 
-  void maybe_convert_one_zero_to_idx (int z_len, int prefer_zero_one = 0)
-    { rep->maybe_convert_one_zero_to_idx (z_len, prefer_zero_one); }
+  void maybe_convert_one_zero_to_idx (int z_len)
+    { rep->maybe_convert_one_zero_to_idx (z_len); }
 
 private:
 
   idx_vector_rep *rep;
 
   void init_state (void) { rep->init_state (); }
 };
 
diff --git a/liboctave/mx-base.h b/liboctave/mx-base.h
--- a/liboctave/mx-base.h
+++ b/liboctave/mx-base.h
@@ -20,16 +20,17 @@ Software Foundation, 59 Temple Place - S
 
 */
 
 #if !defined (octave_mx_base_h)
 #define octave_mx_base_h 1
 
 // Matrix classes.
 
+#include "boolMatrix.h"
 #include "chMatrix.h"
 #include "dMatrix.h"
 #include "CMatrix.h"
 
 // Column Vector classes.
 
 #include "dColVector.h"
 #include "CColVector.h"
diff --git a/liboctave/mx-defs.h b/liboctave/mx-defs.h
--- a/liboctave/mx-defs.h
+++ b/liboctave/mx-defs.h
@@ -22,16 +22,17 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_mx_defs_h)
 #define octave_mx_defs_h 1
 
 // Classes we declare.
 
 class Matrix;
 class ComplexMatrix;
+class boolMatrix;
 class charMatrix;
 
 class ColumnVector;
 class ComplexColumnVector;
 
 class RowVector;
 class ComplexRowVector;
 
diff --git a/liboctave/mx-inlines.cc b/liboctave/mx-inlines.cc
--- a/liboctave/mx-inlines.cc
+++ b/liboctave/mx-inlines.cc
@@ -15,18 +15,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
-#if !defined (octave_mx_ops_h)
-#define octave_mx_ops 1
+#if !defined (octave_mx_inlines_h)
+#define octave_mx_inlines_h 1
 
 #include <cstddef>
 
 #include "oct-cmplx.h"
 
 #define VS_OP_FCN(F, OP) \
   template <class R, class V, class S> \
   static inline void \
@@ -189,16 +189,17 @@ VV_OP2S (Complex, Complex)
   equal (const T1 *x, const T2 *y, size_t n) \
   { \
     for (size_t i = 0; i < n; i++) \
       if (x[i] != y[i]) \
 	return false; \
     return true; \
   }
 
+OP_EQ_FCN (bool,    bool)
 OP_EQ_FCN (char,    char)
 OP_EQ_FCN (double,  double)
 OP_EQ_FCN (Complex, Complex)
 
 #define OP_DUP_FCN(OP, F, R, T) \
   static inline R * \
   F (const T *x, size_t n) \
   { \
