# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1295477756 18000
#      Wed Jan 19 17:55:56 2011 -0500
# Node ID 57632dea2446ecbd972af818297739c49c2c1e5d
# Parent  7e9a111cae20a22c94a62b2ac1600df325e27a4d
attempt better backward compatibility for Array constructors

diff --git a/liboctave/Array-util.cc b/liboctave/Array-util.cc
--- a/liboctave/Array-util.cc
+++ b/liboctave/Array-util.cc
@@ -239,17 +239,17 @@ conv_to_int_array (const Array<idx_vecto
     retval (i) = a(i).elem (0);
 
   return retval;
 }
 
 Array<idx_vector>
 conv_to_array (const idx_vector *tmp, const octave_idx_type len)
 {
-  Array<idx_vector> retval (len, 1);
+  Array<idx_vector> retval (dim_vector (len, 1));
 
   for (octave_idx_type i = 0; i < len; i++)
       retval (i) = tmp[i];
 
   return retval;
 }
 
 dim_vector
@@ -373,17 +373,17 @@ all_ones (const Array<octave_idx_type>& 
 }
 
 Array<octave_idx_type>
 get_elt_idx (const Array<idx_vector>& ra_idx,
              const Array<octave_idx_type>& result_idx)
 {
   octave_idx_type n = ra_idx.length ();
 
-  Array<octave_idx_type> retval (n, 1);
+  Array<octave_idx_type> retval (dim_vector (n, 1));
 
   for (octave_idx_type i = 0; i < n; i++)
     retval(i) = ra_idx(i).elem (result_idx(i));
 
   return retval;
 }
 
 Array<octave_idx_type>
@@ -594,17 +594,17 @@ sub2ind (const dim_vector& dv, const Arr
 
   return retval;
 }
 
 Array<idx_vector>
 ind2sub (const dim_vector& dv, const idx_vector& idx)
 {
   octave_idx_type len = idx.length (0), n = dv.length ();
-  Array<idx_vector> retval(n, 1);
+  Array<idx_vector> retval (dim_vector (n, 1));
   octave_idx_type numel = dv.numel ();
 
   if (idx.extent (numel) > numel)
     current_liboctave_error_handler ("ind2sub: index out of range");
   else
     {
       if (idx.is_scalar ())
         {
diff --git a/liboctave/Array-voidp.cc b/liboctave/Array-voidp.cc
--- a/liboctave/Array-voidp.cc
+++ b/liboctave/Array-voidp.cc
@@ -29,12 +29,8 @@ along with Octave; see the file COPYING.
 // Instantiate Arrays of void *.
 
 #include "Array.h"
 #include "Array.cc"
 
 NO_INSTANTIATE_ARRAY_SORT (void *);
 
 INSTANTIATE_ARRAY (void *, OCTAVE_API);
-
-#include "Array3.h"
-
-template class OCTAVE_API Array3<void *>;
diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -62,37 +62,16 @@ Array<T>::Array (const Array<T>& a, cons
 
   // This goes here because if an exception is thrown by the above,
   // destructor will be never called.
   rep->count++;
   dimensions.chop_trailing_singletons ();
 }
 
 template <class T>
-Array<T>::Array (const Array<T>& a, octave_idx_type nr, octave_idx_type nc)
-  : dimensions (nr, nc), rep (a.rep),
-    slice_data (a.slice_data), slice_len (a.slice_len)
-{
-  if (dimensions.safe_numel () != a.numel ())
-    {
-      std::string dimensions_str = a.dimensions.str ();
-      std::string new_dims_str = dimensions.str ();
-
-      (*current_liboctave_error_handler)
-        ("reshape: can't reshape %s array to %s array",
-         dimensions_str.c_str (), new_dims_str.c_str ());
-    }
-
-  // This goes here because if an exception is thrown by the above,
-  // destructor will be never called.
-  rep->count++;
-  dimensions.chop_trailing_singletons ();
-}
-
-template <class T>
 void
 Array<T>::fill (const T& val)
 {
   if (rep->count > 1)
     {
       --rep->count;
       rep = new ArrayRep (length (), val);
       slice_data = rep->data;
@@ -936,17 +915,17 @@ Array<T>::resize1 (octave_idx_type n, co
                 {
                   slice_data[slice_len++] = rfv;
                   dimensions = dv;
                 }
               else
                 {
                   static const octave_idx_type max_stack_chunk = 1024;
                   octave_idx_type nn = n + std::min (nx, max_stack_chunk);
-                  Array<T> tmp (Array<T> (nn, 1), dv, 0, n);
+                  Array<T> tmp (Array<T> (dim_vector (nn, 1)), dv, 0, n);
                   T *dest = tmp.fortran_vec ();
 
                   copy_or_memcpy (nx, data (), dest);
                   dest[nx] = rfv;
 
                   *this = tmp;
                 }
             }
@@ -1039,17 +1018,17 @@ Array<T>::index (const idx_vector& i, bo
 {
   Array<T> tmp = *this;
   if (resize_ok)
     {
       octave_idx_type n = numel (), nx = i.extent (n);
       if (n != nx)
         {
           if (i.is_scalar ())
-            return Array<T> (1, 1, rfv);
+            return Array<T> (dim_vector (1, 1), rfv);
           else
             tmp.resize1 (nx, rfv);
         }
 
       if (tmp.numel () != nx)
         return Array<T> ();
     }
 
@@ -1065,17 +1044,17 @@ Array<T>::index (const idx_vector& i, co
   if (resize_ok)
     {
       dim_vector dv = dimensions.redim (2);
       octave_idx_type r = dv(0), c = dv(1);
       octave_idx_type rx = i.extent (r), cx = j.extent (c);
       if (r != rx || c != cx)
         {
           if (i.is_scalar () && j.is_scalar ())
-            return Array<T> (1, 1, rfv);
+            return Array<T> (dim_vector (1, 1), rfv);
           else
             tmp.resize (rx, cx, rfv);
         }
 
       if (tmp.rows () != rx || tmp.columns () != cx)
         return Array<T> ();
     }
 
@@ -1095,17 +1074,17 @@ Array<T>::index (const Array<idx_vector>
       dim_vector dvx = dim_vector::alloc (ial);
       for (int i = 0; i < ial; i++) dvx(i) = ia(i).extent (dv (i));
       if (! (dvx == dv))
         {
           bool all_scalars = true;
           for (int i = 0; i < ial; i++) 
             all_scalars = all_scalars && ia(i).is_scalar ();
           if (all_scalars)
-            return Array<T> (1, 1, rfv);
+            return Array<T> (dim_vector (1, 1), rfv);
           else
             tmp.resize (dvx, rfv);
         }
 
       if (tmp.dimensions != dvx)
         return Array<T> ();
     }
 
@@ -1438,17 +1417,17 @@ Array<T>::delete_elements (int dim, cons
               src += n;
             }
 
           *this = tmp;
         }
       else
         {
           // Use index.
-          Array<idx_vector> ia (ndims (), 1, idx_vector::colon);
+          Array<idx_vector> ia (dim_vector (ndims (), 1), idx_vector::colon);
           ia (dim) = i.complement (n);
           *this = index (ia);
         }
     }
 }
 
 template <class T>
 void 
@@ -1493,33 +1472,33 @@ Array<T>&
 Array<T>::insert (const Array<T>& a, octave_idx_type r, octave_idx_type c)
 {
   idx_vector i (r, r + a.rows ());
   idx_vector j (c, c + a.columns ());
   if (ndims () == 2 && a.ndims () == 2)
     assign (i, j, a);
   else
     {
-      Array<idx_vector> idx (a.ndims (), 1);
+      Array<idx_vector> idx (dim_vector (a.ndims (), 1));
       idx(0) = i;
       idx(1) = j;
       for (int k = 0; k < a.ndims (); k++)
         idx(k) = idx_vector (0, a.dimensions(k));
       assign (idx, a);
     }
 
   return *this;
 }
 
 template <class T>
 Array<T>&
 Array<T>::insert (const Array<T>& a, const Array<octave_idx_type>& ra_idx)
 {
   octave_idx_type n = ra_idx.length ();
-  Array<idx_vector> idx (n, 1);
+  Array<idx_vector> idx (dim_vector (n, 1));
   const dim_vector dva = a.dims ().redim (n);
   for (octave_idx_type k = 0; k < n; k++)
     idx(k) = idx_vector (ra_idx (k), ra_idx (k) + dva(k));
 
   assign (idx, a);
 
   return *this;
 }
@@ -2005,17 +1984,17 @@ Array<octave_idx_type>
 Array<T>::sort_rows_idx (sortmode mode) const
 {
   Array<octave_idx_type> idx;
 
   octave_sort<T> lsort (safe_comparator (mode, *this, true));
 
   octave_idx_type r = rows (), c = cols ();
 
-  idx = Array<octave_idx_type> (r, 1);
+  idx = Array<octave_idx_type> (dim_vector (r, 1));
 
   lsort.sort_rows (data (), idx.fortran_vec (), r, c);
 
   return idx;
 }
 
 
 template <class T>
@@ -2589,17 +2568,17 @@ Array<T>::cat (int dim, octave_idx_type 
         ("cat: dimension mismatch");
 
   Array<T> retval (dv);
 
   if (retval.is_empty ())
     return retval;
 
   int nidx = std::max (dv.length (), dim + 1);
-  Array<idx_vector> idxa (nidx, 1, idx_vector::colon);
+  Array<idx_vector> idxa (dim_vector (nidx, 1), idx_vector::colon);
   octave_idx_type l = 0;
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       // NOTE: This takes some thinking, but no matter what the above rules
       // are, an empty array can always be skipped at this point, because
       // the result dimensions are already determined, and there is no way
       // an empty array may contribute a nonzero piece along the dimension
@@ -2681,17 +2660,17 @@ operator << (std::ostream& os, const Arr
     os << " (" << a_dims.str () << ")";
 
   os <<"\n\n";
 
   if (n_dims)
     {
       os << "data:";
 
-      Array<octave_idx_type> ra_idx (n_dims, 1, 0);
+      Array<octave_idx_type> ra_idx (dim_vector (n_dims, 1), 0);
 
       // Number of times the first 2d-array is to be displayed.
 
       octave_idx_type m = 1;
       for (int i = 2; i < n_dims; i++)
         m *= a_dims(i);
 
       if (m == 1)
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -169,29 +169,21 @@ public:
     }
 
   // Obsolete 1D ctor (there are no 1D arrays).
   explicit Array (octave_idx_type n) GCC_ATTR_DEPRECATED
     : dimensions (n, 1), rep (new typename Array<T>::ArrayRep (n)),
       slice_data (rep->data), slice_len (rep->len)
     { }
 
-  // 2D uninitialized ctor.
-  explicit Array (octave_idx_type m, octave_idx_type n)
-    : dimensions (m, n),
-      rep (new typename Array<T>::ArrayRep (dimensions.safe_numel ())), 
+  // Obsolete initialized 1D ctor (there are no 1D arrays).
+  explicit Array (octave_idx_type n, const T& val) GCC_ATTR_DEPRECATED
+    : dimensions (n, 1), rep (new typename Array<T>::ArrayRep (n)),
       slice_data (rep->data), slice_len (rep->len)
-    { }
-
-  // 2D initialized ctor.
-  explicit Array (octave_idx_type m, octave_idx_type n, const T& val)
-    : dimensions (m, n),
-      rep (new typename Array<T>::ArrayRep (dimensions.safe_numel ())),
-      slice_data (rep->data), slice_len (rep->len)
-    { 
+    {
       fill (val);
     }
 
   // nD uninitialized ctor.
   explicit Array (const dim_vector& dv)
     : dimensions (dv),
       rep (new typename Array<T>::ArrayRep (dv.safe_numel ())),
       slice_data (rep->data), slice_len (rep->len)
@@ -207,18 +199,16 @@ public:
     {
       fill (val);
       dimensions.chop_trailing_singletons ();
     }
 
   // Reshape constructor.
   Array (const Array<T>& a, const dim_vector& dv);
 
-  Array (const Array<T>& a, octave_idx_type nr, octave_idx_type nc);
-
   // Type conversion case.
   template <class U>
   Array (const Array<U>& a)
     : dimensions (a.dims ()),
       rep (new typename Array<T>::ArrayRep (a.data (), a.length ())),
       slice_data (rep->data), slice_len (rep->len)
     { }
 
@@ -412,17 +402,17 @@ public:
   // Extract page: A(:,:,k+1).
   Array<T> page (octave_idx_type k) const;
 
   // Extract a slice from this array as a column vector: A(:)(lo+1:up).
   // Must be 0 <= lo && up <= numel. May be up < lo.
   Array<T> linear_slice (octave_idx_type lo, octave_idx_type up) const;
 
   Array<T> reshape (octave_idx_type nr, octave_idx_type nc) const
-    { return Array<T> (*this, nr, nc); }
+    { return Array<T> (*this, dim_vector (nr, nc)); }
 
   Array<T> reshape (const dim_vector& new_dims) const
     { return Array<T> (*this, new_dims); }
 
   Array<T> permute (const Array<octave_idx_type>& vec, bool inv = false) const;
   Array<T> ipermute (const Array<octave_idx_type>& vec) const
     { return permute (vec, true); }
 
diff --git a/liboctave/Array3.h b/liboctave/Array3.h
--- a/liboctave/Array3.h
+++ b/liboctave/Array3.h
@@ -78,9 +78,14 @@ public:
   Array3<T> sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
                  sortmode mode = ASCENDING) const
     {
       Array<T> tmp = Array<T>::sort (sidx, dim, mode);
       return Array3<T> (tmp, tmp.rows (), tmp.columns (), tmp.pages ());
     }
 };
 
+// If we're with GNU C++, issue a warning.
+#ifdef __GNUC__
+#warning Using Array3<T> is deprecated. Use Array<T> directly.
 #endif
+
+#endif
diff --git a/liboctave/CColVector.h b/liboctave/CColVector.h
--- a/liboctave/CColVector.h
+++ b/liboctave/CColVector.h
@@ -32,30 +32,34 @@ class
 OCTAVE_API
 ComplexColumnVector : public MArray<Complex>
 {
 friend class ComplexMatrix;
 friend class ComplexRowVector;
 
 public:
 
-  ComplexColumnVector (void) : MArray<Complex> (0, 1) { }
+  ComplexColumnVector (void) : MArray<Complex> (dim_vector (0, 1)) { }
 
-  explicit ComplexColumnVector (octave_idx_type n) : MArray<Complex> (n, 1) { }
+  explicit ComplexColumnVector (octave_idx_type n)
+    : MArray<Complex> (dim_vector (n, 1)) { }
 
   explicit ComplexColumnVector (const dim_vector& dv) 
     : MArray<Complex> (dv.as_column ()) { }
 
   ComplexColumnVector (octave_idx_type n, const Complex& val)
-    : MArray<Complex> (n, 1, val) { }
+    : MArray<Complex> (dim_vector (n, 1), val) { }
 
   ComplexColumnVector (const ComplexColumnVector& a) : MArray<Complex> (a) { }
 
-  ComplexColumnVector (const MArray<Complex>& a) : MArray<Complex> (a.as_column ()) { }
-  ComplexColumnVector (const Array<Complex>& a) : MArray<Complex> (a.as_column ()) { }
+  ComplexColumnVector (const MArray<Complex>& a)
+    : MArray<Complex> (a.as_column ()) { }
+
+  ComplexColumnVector (const Array<Complex>& a)
+    : MArray<Complex> (a.as_column ()) { }
 
   explicit ComplexColumnVector (const ColumnVector& a);
 
   ComplexColumnVector& operator = (const ComplexColumnVector& a)
     {
       MArray<Complex>::operator = (a);
       return *this;
     }
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -272,57 +272,57 @@ ComplexMatrix::ComplexMatrix (const RowV
 }
 
 ComplexMatrix::ComplexMatrix (const ColumnVector& cv)
   : MArray<Complex> (cv)
 {
 }
 
 ComplexMatrix::ComplexMatrix (const DiagMatrix& a)
-  : MArray<Complex> (a.rows (), a.cols (), 0.0)
+  : MArray<Complex> (a.dims (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
 ComplexMatrix::ComplexMatrix (const ComplexRowVector& rv)
   : MArray<Complex> (rv)
 {
 }
 
 ComplexMatrix::ComplexMatrix (const ComplexColumnVector& cv)
   : MArray<Complex> (cv)
 {
 }
 
 ComplexMatrix::ComplexMatrix (const ComplexDiagMatrix& a)
-  : MArray<Complex> (a.rows (), a.cols (), 0.0)
+  : MArray<Complex> (a.dims (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
 // FIXME -- could we use a templated mixed-type copy function
 // here?
 
 ComplexMatrix::ComplexMatrix (const boolMatrix& a)
   : MArray<Complex> (a)
 {
 }
 
 ComplexMatrix::ComplexMatrix (const charMatrix& a)
-  : MArray<Complex> (a.rows (), a.cols (), 0.0)
+  : MArray<Complex> (a.dims (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     for (octave_idx_type j = 0; j < a.cols (); j++)
       elem (i, j) = static_cast<unsigned char> (a.elem (i, j));
 }
 
 ComplexMatrix::ComplexMatrix (const Matrix& re, const Matrix& im)
-  : MArray<Complex> (re.rows (), re.cols ())
+  : MArray<Complex> (re.dims ())
 {
   if (im.rows () != rows () || im.cols () != cols ())
     (*current_liboctave_error_handler) ("complex: internal error");
 
   octave_idx_type nel = numel ();
   for (octave_idx_type i = 0; i < nel; i++)
     xelem (i) = Complex (re(i), im(i));
 }
@@ -1060,23 +1060,23 @@ ComplexMatrix::finverse (MatrixType &mat
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
   else
     {
-      Array<octave_idx_type> ipvt (nr, 1);
+      Array<octave_idx_type> ipvt (dim_vector (nr, 1));
       octave_idx_type *pipvt = ipvt.fortran_vec ();
 
       retval = *this;
       Complex *tmp_data = retval.fortran_vec ();
 
-      Array<Complex> z(1, 1);
+      Array<Complex> z (dim_vector (1, 1));
       octave_idx_type lwork = -1;
 
       // Query the optimum work array size.
 
       F77_XFCN (zgetri, ZGETRI, (nc, tmp_data, nr, pipvt, 
                                  z.fortran_vec (), lwork, info));
 
       lwork = static_cast<octave_idx_type> (std::real(z(0)));
@@ -1097,17 +1097,17 @@ ComplexMatrix::finverse (MatrixType &mat
       rcon = 0.0;
       if (info != 0) 
         info = -1;
       else if (calc_cond) 
         {
           // Now calculate the condition number for non-singular matrix.
           octave_idx_type zgecon_info = 0;
           char job = '1';
-          Array<double> rz (2 * nc, 1);
+          Array<double> rz (dim_vector (2 * nc, 1));
           double *prz = rz.fortran_vec ();
           F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nc, tmp_data, nr, anorm, 
                                      rcon, pz, prz, zgecon_info
                                      F77_CHAR_ARG_LEN (1)));
 
           if (zgecon_info != 0) 
             info = -1;
@@ -1612,19 +1612,19 @@ ComplexMatrix::determinant (MatrixType& 
           if (info != 0) 
             {
               rcon = 0.0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else 
             {
-              Array<Complex> z (2 * nc, 1);
+              Array<Complex> z (dim_vector (2 * nc, 1));
               Complex *pz = z.fortran_vec ();
-              Array<double> rz (nc, 1);
+              Array<double> rz (dim_vector (nc, 1));
               double *prz = rz.fortran_vec ();
 
               F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                          nr, tmp_data, nr, anorm,
                                          rcon, pz, prz, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0) 
@@ -1636,17 +1636,17 @@ ComplexMatrix::determinant (MatrixType& 
               retval = retval.square ();
             }
         }
       else if (typ != MatrixType::Full)
         (*current_liboctave_error_handler) ("det: invalid dense matrix type");
 
       if (typ == MatrixType::Full)
         {
-          Array<octave_idx_type> ipvt (nr, 1);
+          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           ComplexMatrix atmp = *this;
           Complex *tmp_data = atmp.fortran_vec ();
 
           info = 0;
 
           // Calculate the norm of the matrix, for later use.
@@ -1663,19 +1663,19 @@ ComplexMatrix::determinant (MatrixType& 
               retval = ComplexDET ();
             } 
           else 
             {
               if (calc_cond) 
                 {
                   // Now calc the condition number for non-singular matrix.
                   char job = '1';
-                  Array<Complex> z (2 * nc, 1);
+                  Array<Complex> z (dim_vector (2 * nc, 1));
                   Complex *pz = z.fortran_vec ();
-                  Array<double> rz (2 * nc, 1);
+                  Array<double> rz (dim_vector (2 * nc, 1));
                   double *prz = rz.fortran_vec ();
 
                   F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nc, tmp_data, nr, anorm, 
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
                 }
 
@@ -1728,19 +1728,19 @@ ComplexMatrix::rcond (MatrixType &mattyp
       if (typ == MatrixType::Upper)
         {
           const Complex *tmp_data = fortran_vec ();
           octave_idx_type info = 0;
           char norm = '1';
           char uplo = 'U';
           char dia = 'N';
 
-          Array<Complex> z (2 * nc, 1);
+          Array<Complex> z (dim_vector (2 * nc, 1));
           Complex *pz = z.fortran_vec ();
-          Array<double> rz (nc, 1);
+          Array<double> rz (dim_vector (nc, 1));
           double *prz = rz.fortran_vec ();
 
           F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                      F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                      F77_CONST_CHAR_ARG2 (&dia, 1), 
                                      nr, tmp_data, nr, rcon,
                                      pz, prz, info
                                      F77_CHAR_ARG_LEN (1)
@@ -1756,19 +1756,19 @@ ComplexMatrix::rcond (MatrixType &mattyp
       else if (typ == MatrixType::Lower)
         {
           const Complex *tmp_data = fortran_vec ();
           octave_idx_type info = 0;
           char norm = '1';
           char uplo = 'L';
           char dia = 'N';
 
-          Array<Complex> z (2 * nc, 1);
+          Array<Complex> z (dim_vector (2 * nc, 1));
           Complex *pz = z.fortran_vec ();
-          Array<double> rz (nc, 1);
+          Array<double> rz (dim_vector (nc, 1));
           double *prz = rz.fortran_vec ();
 
           F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                      F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                      F77_CONST_CHAR_ARG2 (&dia, 1), 
                                      nr, tmp_data, nr, rcon,
                                      pz, prz, info
                                      F77_CHAR_ARG_LEN (1)
@@ -1802,19 +1802,19 @@ ComplexMatrix::rcond (MatrixType &mattyp
                 {
                   rcon = 0.0;
 
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
               else 
                 {
-                  Array<Complex> z (2 * nc, 1);
+                  Array<Complex> z (dim_vector (2 * nc, 1));
                   Complex *pz = z.fortran_vec ();
-                  Array<double> rz (nc, 1);
+                  Array<double> rz (dim_vector (nc, 1));
                   double *prz = rz.fortran_vec ();
 
                   F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0) 
@@ -1822,26 +1822,26 @@ ComplexMatrix::rcond (MatrixType &mattyp
                 }
             }
 
 
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
-              Array<octave_idx_type> ipvt (nr, 1);
+              Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
               if(anorm < 0.)
                 anorm = atmp.abs().sum().
                   row(static_cast<octave_idx_type>(0)).max();
 
-              Array<Complex> z (2 * nc, 1);
+              Array<Complex> z (dim_vector (2 * nc, 1));
               Complex *pz = z.fortran_vec ();
-              Array<double> rz (2 * nc, 1);
+              Array<double> rz (dim_vector (2 * nc, 1));
               double *prz = rz.fortran_vec ();
 
               F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
               if (info != 0) 
                 { 
                   rcon = 0.0;
                   mattype.mark_as_rectangular ();
@@ -1903,19 +1903,19 @@ ComplexMatrix::utsolve (MatrixType &matt
               const Complex *tmp_data = fortran_vec ();
 
               if (calc_cond)
                 {
                   char norm = '1';
                   char uplo = 'U';
                   char dia = 'N';
 
-                  Array<Complex> z (2 * nc, 1);
+                  Array<Complex> z (dim_vector (2 * nc, 1));
                   Complex *pz = z.fortran_vec ();
-                  Array<double> rz (nc, 1);
+                  Array<double> rz (dim_vector (nc, 1));
                   double *prz = rz.fortran_vec ();
 
                   F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                              F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                              F77_CONST_CHAR_ARG2 (&dia, 1), 
                                              nr, tmp_data, nr, rcon,
                                              pz, prz, info
                                              F77_CHAR_ARG_LEN (1)
@@ -2004,19 +2004,19 @@ ComplexMatrix::ltsolve (MatrixType &matt
               const Complex *tmp_data = fortran_vec ();
 
               if (calc_cond)
                 {
                   char norm = '1';
                   char uplo = 'L';
                   char dia = 'N';
 
-                  Array<Complex> z (2 * nc, 1);
+                  Array<Complex> z (dim_vector (2 * nc, 1));
                   Complex *pz = z.fortran_vec ();
-                  Array<double> rz (nc, 1);
+                  Array<double> rz (dim_vector (nc, 1));
                   double *prz = rz.fortran_vec ();
 
                   F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                              F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                              F77_CONST_CHAR_ARG2 (&dia, 1), 
                                              nr, tmp_data, nr, rcon,
                                              pz, prz, info
                                              F77_CHAR_ARG_LEN (1)
@@ -2112,19 +2112,19 @@ ComplexMatrix::fsolve (MatrixType &matty
 
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else 
             {
               if (calc_cond)
                 {
-                  Array<Complex> z (2 * nc, 1);
+                  Array<Complex> z (dim_vector (2 * nc, 1));
                   Complex *pz = z.fortran_vec ();
-                  Array<double> rz (nc, 1);
+                  Array<double> rz (dim_vector (nc, 1));
                   double *prz = rz.fortran_vec ();
 
                   F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0) 
@@ -2164,25 +2164,25 @@ ComplexMatrix::fsolve (MatrixType &matty
                 }
             }
         }
 
       if (typ == MatrixType::Full)
         {
           info = 0;
 
-          Array<octave_idx_type> ipvt (nr, 1);
+          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           ComplexMatrix atmp = *this;
           Complex *tmp_data = atmp.fortran_vec ();
 
-          Array<Complex> z (2 * nc, 1);
+          Array<Complex> z (dim_vector (2 * nc, 1));
           Complex *pz = z.fortran_vec ();
-          Array<double> rz (2 * nc, 1);
+          Array<double> rz (dim_vector (2 * nc, 1));
           double *prz = rz.fortran_vec ();
 
           // Calculate the norm of the matrix, for later use.
           if (anorm < 0.)
             anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
           F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
@@ -2619,23 +2619,23 @@ ComplexMatrix::lssolve (const ComplexMat
         }
       else
         retval = b;
 
       ComplexMatrix atmp = *this;
       Complex *tmp_data = atmp.fortran_vec ();
 
       Complex *pretval = retval.fortran_vec ();
-      Array<double> s (minmn, 1);
+      Array<double> s (dim_vector (minmn, 1));
       double *ps = s.fortran_vec ();
 
       // Ask ZGELSD what the dimension of WORK should be.
       octave_idx_type lwork = -1;
 
-      Array<Complex> work (1, 1);
+      Array<Complex> work (dim_vector (1, 1));
 
       octave_idx_type smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("ZGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
@@ -2660,23 +2660,23 @@ ComplexMatrix::lssolve (const ComplexMat
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
         + 3*smlsiz*nrhs + std::max ((smlsiz+1)*(smlsiz+1),
                                     n*(1+nrhs) + 2*nrhs);
       if (lrwork < 1)
         lrwork = 1;
-      Array<double> rwork (lrwork, 1);
+      Array<double> rwork (dim_vector (lrwork, 1));
       double *prwork = rwork.fortran_vec ();
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
-      Array<octave_idx_type> iwork (liwork, 1);
+      Array<octave_idx_type> iwork (dim_vector (liwork, 1));
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
                                  ps, rcon, rank, work.fortran_vec (),
                                  lwork, prwork, piwork, info));
 
       // The workspace query is broken in at least LAPACK 3.0.0
       // through 3.1.1 when n >= mnthr.  The obtuse formula below
@@ -2816,23 +2816,23 @@ ComplexMatrix::lssolve (const ComplexCol
         }
       else
         retval = b;
 
       ComplexMatrix atmp = *this;
       Complex *tmp_data = atmp.fortran_vec ();
 
       Complex *pretval = retval.fortran_vec ();
-      Array<double> s (minmn, 1);
+      Array<double> s (dim_vector (minmn, 1));
       double *ps = s.fortran_vec ();
 
       // Ask ZGELSD what the dimension of WORK should be.
       octave_idx_type lwork = -1;
 
-      Array<Complex> work (1, 1);
+      Array<Complex> work (dim_vector (1, 1));
 
       octave_idx_type smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("ZGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
@@ -2849,23 +2849,23 @@ ComplexMatrix::lssolve (const ComplexCol
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
         + 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
       if (lrwork < 1)
         lrwork = 1;
-      Array<double> rwork (lrwork, 1);
+      Array<double> rwork (dim_vector (lrwork, 1));
       double *prwork = rwork.fortran_vec ();
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
-      Array<octave_idx_type> iwork (liwork, 1);
+      Array<octave_idx_type> iwork (dim_vector (liwork, 1));
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
                                  ps, rcon, rank, work.fortran_vec (),
                                  lwork, prwork, piwork, info));
 
       lwork = static_cast<octave_idx_type> (std::real (work(0)));
       work.resize (lwork, 1);
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -40,20 +40,21 @@ public:
  
   typedef ComplexColumnVector column_vector_type;
   typedef ComplexRowVector row_vector_type;
 
   typedef void (*solve_singularity_handler) (double rcon);
 
   ComplexMatrix (void) : MArray<Complex> () { }
 
-  ComplexMatrix (octave_idx_type r, octave_idx_type c) : MArray<Complex> (r, c) { }
+  ComplexMatrix (octave_idx_type r, octave_idx_type c)
+    : MArray<Complex> (dim_vector (r, c)) { }
 
   ComplexMatrix (octave_idx_type r, octave_idx_type c, const Complex& val)
-    : MArray<Complex> (r, c, val) { }
+    : MArray<Complex> (dim_vector (r, c), val) { }
 
   ComplexMatrix (const dim_vector& dv) : MArray<Complex> (dv.redim (2)) { }
 
   ComplexMatrix (const dim_vector& dv, const Complex& val) 
     : MArray<Complex> (dv.redim (2), val) { }
 
   ComplexMatrix (const ComplexMatrix& a) : MArray<Complex> (a) { }
 
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -211,17 +211,17 @@ ComplexNDArray::fourier (int dim) const
   dim_vector dv = dims ();
 
   if (dim > dv.length () || dim < 0)
     return ComplexNDArray ();
 
   ComplexNDArray retval (dv);
   octave_idx_type npts = dv(dim);
   octave_idx_type nn = 4*npts+15;
-  Array<Complex> wsave (nn, 1);
+  Array<Complex> wsave (dim_vector (nn, 1));
   Complex *pwsave = wsave.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (Complex, tmp, npts);
 
   octave_idx_type stride = 1;
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
@@ -258,17 +258,17 @@ ComplexNDArray::ifourier (int dim) const
   dim_vector dv = dims ();
 
   if (dim > dv.length () || dim < 0)
     return ComplexNDArray ();
 
   ComplexNDArray retval (dv);
   octave_idx_type npts = dv(dim);
   octave_idx_type nn = 4*npts+15;
-  Array<Complex> wsave (nn, 1);
+  Array<Complex> wsave (dim_vector (nn, 1));
   Complex *pwsave = wsave.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (Complex, tmp, npts);
 
   octave_idx_type stride = 1;
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
@@ -308,19 +308,19 @@ ComplexNDArray::fourier2d (void) const
   int rank = 2;
   ComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv2(i);
       octave_idx_type nn = 4*npts+15;
-      Array<Complex> wsave (nn, 1);
+      Array<Complex> wsave (dim_vector (nn, 1));
       Complex *pwsave = wsave.fortran_vec ();
-      Array<Complex> row (npts, 1);
+      Array<Complex> row (dim_vector (npts, 1));
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
@@ -356,19 +356,19 @@ ComplexNDArray::ifourier2d (void) const
   int rank = 2;
   ComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv2(i);
       octave_idx_type nn = 4*npts+15;
-      Array<Complex> wsave (nn, 1);
+      Array<Complex> wsave (dim_vector (nn, 1));
       Complex *pwsave = wsave.fortran_vec ();
-      Array<Complex> row (npts, 1);
+      Array<Complex> row (dim_vector (npts, 1));
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
@@ -404,19 +404,19 @@ ComplexNDArray::fourierNd (void) const
   int rank = dv.length ();
   ComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
-      Array<Complex> wsave (nn, 1);
+      Array<Complex> wsave (dim_vector (nn, 1));
       Complex *pwsave = wsave.fortran_vec ();
-      Array<Complex> row (npts, 1);
+      Array<Complex> row (dim_vector (npts, 1));
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
@@ -451,19 +451,19 @@ ComplexNDArray::ifourierNd (void) const
   int rank = dv.length ();
   ComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
-      Array<Complex> wsave (nn, 1);
+      Array<Complex> wsave (dim_vector (nn, 1));
       Complex *pwsave = wsave.fortran_vec ();
-      Array<Complex> row (npts, 1);
+      Array<Complex> row (dim_vector (npts, 1));
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
@@ -767,17 +767,17 @@ ComplexNDArray&
 ComplexNDArray::insert (const NDArray& a, octave_idx_type r, octave_idx_type c)
 {
   dim_vector a_dv = a.dims ();
   
   int n = a_dv.length ();
   
   if (n == dimensions.length ())
     {
-      Array<octave_idx_type> a_ra_idx (a_dv.length (), 1, 0);
+      Array<octave_idx_type> a_ra_idx (dim_vector (a_dv.length (), 1), 0);
       
       a_ra_idx.elem (0) = r;
       a_ra_idx.elem (1) = c;
       
       for (int i = 0; i < n; i++)
         {
           if (a_ra_idx (i) < 0 || (a_ra_idx (i) + a_dv (i)) > dimensions (i))
             {
diff --git a/liboctave/CRowVector.h b/liboctave/CRowVector.h
--- a/liboctave/CRowVector.h
+++ b/liboctave/CRowVector.h
@@ -31,28 +31,33 @@ along with Octave; see the file COPYING.
 class
 OCTAVE_API
 ComplexRowVector : public MArray<Complex>
 {
 friend class ComplexColumnVector;
 
 public:
 
-  ComplexRowVector (void) : MArray<Complex> (1, 0) { }
+ ComplexRowVector (void) : MArray<Complex> (dim_vector (1, 0)) { }
 
-  explicit ComplexRowVector (octave_idx_type n) : MArray<Complex> (1, n) { }
+  explicit ComplexRowVector (octave_idx_type n)
+    : MArray<Complex> (dim_vector (1, n)) { }
 
   explicit ComplexRowVector (const dim_vector& dv) : MArray<Complex> (dv) { }
 
-  ComplexRowVector (octave_idx_type n, const Complex& val) : MArray<Complex> (1, n, val) { }
+  ComplexRowVector (octave_idx_type n, const Complex& val)
+    : MArray<Complex> (dim_vector (1, n), val) { }
 
   ComplexRowVector (const ComplexRowVector& a) : MArray<Complex> (a) { }
 
-  ComplexRowVector (const MArray<Complex>& a) : MArray<Complex> (a.as_row ()) { }
-  ComplexRowVector (const Array<Complex>& a) : MArray<Complex> (a.as_row ()) { }
+  ComplexRowVector (const MArray<Complex>& a)
+    : MArray<Complex> (a.as_row ()) { }
+
+  ComplexRowVector (const Array<Complex>& a)
+    : MArray<Complex> (a.as_row ()) { }
 
   explicit ComplexRowVector (const RowVector& a) : MArray<Complex> (a) { }
 
   ComplexRowVector& operator = (const ComplexRowVector& a)
     {
       MArray<Complex>::operator = (a);
       return *this;
     }
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -3914,17 +3914,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == MatrixType::Tridiagonal ||
           typ == MatrixType::Tridiagonal_Hermitian)
         {
           OCTAVE_LOCAL_BUFFER (Complex, DU2, nr - 2);
           OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
           OCTAVE_LOCAL_BUFFER (Complex, D, nr);
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
-          Array<octave_idx_type> ipvt (nr, 1);
+          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
@@ -4214,17 +4214,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == MatrixType::Tridiagonal ||
           typ == MatrixType::Tridiagonal_Hermitian)
         {
           OCTAVE_LOCAL_BUFFER (Complex, DU2, nr - 2);
           OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
           OCTAVE_LOCAL_BUFFER (Complex, D, nr);
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
-          Array<octave_idx_type> ipvt (nr, 1);
+          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
@@ -4408,19 +4408,19 @@ SparseComplexMatrix::bsolve (MatrixType 
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Banded;
               err = 0;
             } 
           else 
             {
               if (calc_cond)
                 {
-                  Array<Complex> z (2 * nr, 1);
+                  Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
-                  Array<double> iz (nr, 1);
+                  Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zpbcon, ZPBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nr, n_lower, tmp_data, ldm,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -4502,17 +4502,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   double atmp = 0.;
                   for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
                     atmp += std::abs(data(i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          Array<octave_idx_type> ipvt (nr, 1);
+          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           F77_XFCN (zgbtrf, ZGBTRF, (nr, nc, n_lower, n_upper, tmp_data, 
                                      ldm, pipvt, err));
             
           // Throw-away extra info LAPACK gives so as to not 
           // change output.
           if (err != 0) 
@@ -4529,19 +4529,19 @@ SparseComplexMatrix::bsolve (MatrixType 
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
             } 
           else 
             {
               if (calc_cond)
                 {
                   char job = '1';
-                  Array<Complex> z (2 * nr, 1);
+                  Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
-                  Array<double> iz (nr, 1);
+                  Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zgbcon, ZGBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nc, n_lower, n_upper, tmp_data, ldm, pipvt,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -4655,19 +4655,19 @@ SparseComplexMatrix::bsolve (MatrixType 
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Banded;
               err = 0;
             } 
           else 
             {
               if (calc_cond)
                 {
-                  Array<Complex> z (2 * nr, 1);
+                  Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
-                  Array<double> iz (nr, 1);
+                  Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zpbcon, ZPBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nr, n_lower, tmp_data, ldm,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -4784,17 +4784,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   double atmp = 0.;
                   for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
                     atmp += std::abs(data(i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          Array<octave_idx_type> ipvt (nr, 1);
+          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
                                      ldm, pipvt, err));
             
           if (err != 0) 
             {
               rcond = 0.0;
@@ -4810,19 +4810,19 @@ SparseComplexMatrix::bsolve (MatrixType 
                   ("matrix singular to machine precision");
 
             } 
           else 
             {
               if (calc_cond)
                 {
                   char job = '1';
-                  Array<Complex> z (2 * nr, 1);
+                  Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
-                  Array<double> iz (nr, 1);
+                  Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zgbcon, ZGBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nc, n_lower, n_upper, tmp_data, ldm, pipvt,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -4975,19 +4975,19 @@ SparseComplexMatrix::bsolve (MatrixType 
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Banded;
               err = 0;
             } 
           else 
             {
               if (calc_cond)
                 {
-                  Array<Complex> z (2 * nr, 1);
+                  Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
-                  Array<double> iz (nr, 1);
+                  Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zpbcon, ZPBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nr, n_lower, tmp_data, ldm,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -5069,17 +5069,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   double atmp = 0.;
                   for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
                     atmp += std::abs(data(i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          Array<octave_idx_type> ipvt (nr, 1);
+          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
                                      ldm, pipvt, err));
             
           if (err != 0) 
             {
               err = -2;
@@ -5094,19 +5094,19 @@ SparseComplexMatrix::bsolve (MatrixType 
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
             } 
           else 
             {
               if (calc_cond)
                 {
                   char job = '1';
-                  Array<Complex> z (2 * nr, 1);
+                  Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
-                  Array<double> iz (nr, 1);
+                  Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zgbcon, ZGBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nc, n_lower, n_upper, tmp_data, ldm, pipvt,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -5222,19 +5222,19 @@ SparseComplexMatrix::bsolve (MatrixType 
 
               rcond = 0.0;
               err = 0;
             } 
           else 
             {
               if (calc_cond)
                 {
-                  Array<Complex> z (2 * nr, 1);
+                  Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
-                  Array<double> iz (nr, 1);
+                  Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zpbcon, ZPBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nr, n_lower, tmp_data, ldm,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -5356,17 +5356,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   double atmp = 0.;
                   for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
                     atmp += std::abs(data(i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          Array<octave_idx_type> ipvt (nr, 1);
+          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
                                      ldm, pipvt, err));
             
           if (err != 0) 
             {
               err = -2;
@@ -5382,19 +5382,19 @@ SparseComplexMatrix::bsolve (MatrixType 
                   ("matrix singular to machine precision");
 
             }
           else 
             {
               if (calc_cond)
                 {
                   char job = '1';
-                  Array<Complex> z (2 * nr, 1);
+                  Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
-                  Array<double> iz (nr, 1);
+                  Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zgbcon, ZGBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nc, n_lower, n_upper, tmp_data, ldm, pipvt,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,17 @@
+2011-01-19  John W. Eaton  <jwe@octave.org>
+
+	* Array.h (explicit Array (octave_idx_type, const T&)):
+	Restore constructor, but mark as deprecated.
+	(explicit Array (octave_idx_type, octave_idx_type)): Delete.
+	(Array (const Array<T>&, octave_idx_type, octave_idx_type)): Delete.
+	Fix all uses in Octave.
+	* Array3.h: Deprecate header file.  Remove all uses from Octave.
+
 2011-01-19  John W. Eaton  <jwe@octave.org>
 
 	* file-stat.cc (mode_as_string): Declare buffer as an array of
 	12 characters, not 11.  Don't set buf[10] to '\0'; strmode
 	NUL-terminates the array.
 
 2011-01-14  David Grundberg  <individ@acc.umu.se>
 
diff --git a/liboctave/CmplxCHOL.cc b/liboctave/CmplxCHOL.cc
--- a/liboctave/CmplxCHOL.cc
+++ b/liboctave/CmplxCHOL.cc
@@ -122,19 +122,19 @@ ComplexCHOL::init (const ComplexMatrix& 
   xrcond = 0.0;
   if (info > 0)
     chol_mat.resize (info - 1, info - 1);
   else if (calc_cond) 
     {
       octave_idx_type zpocon_info = 0;
 
       // Now calculate the condition number for non-singular matrix.
-      Array<Complex> z (2*n, 1);
+      Array<Complex> z (dim_vector (2*n, 1));
       Complex *pz = z.fortran_vec ();
-      Array<double> rz (n, 1);
+      Array<double> rz (dim_vector (n, 1));
       double *prz = rz.fortran_vec ();
       F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
                                  n, anorm, xrcond, pz, prz, zpocon_info
                                  F77_CHAR_ARG_LEN (1)));
 
       if (zpocon_info != 0) 
         info = -1;
     }
@@ -414,17 +414,17 @@ ComplexCHOL::shift_sym (octave_idx_type 
 
   octave_idx_type n = chol_mat.rows ();
   
   if (i < 0 || i > n-1 || j < 0 || j > n-1) 
     (*current_liboctave_error_handler) ("cholshift: index out of range");
   else
     {
       ComplexMatrix a = chol_mat.hermitian () * chol_mat;
-      Array<octave_idx_type> p (n, 1);
+      Array<octave_idx_type> p (dim_vector (n, 1));
       for (octave_idx_type k = 0; k < n; k++) p(k) = k;
       if (i < j)
         {
           for (octave_idx_type k = i; k < j; k++) p(k) = k+1;
           p(j) = i;
         }
       else if (j < i)
         {
diff --git a/liboctave/CmplxHESS.cc b/liboctave/CmplxHESS.cc
--- a/liboctave/CmplxHESS.cc
+++ b/liboctave/CmplxHESS.cc
@@ -80,27 +80,27 @@ ComplexHESS::init (const ComplexMatrix& 
   octave_idx_type lwork = 32 * n;
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
 
   hess_mat = a;
   Complex *h = hess_mat.fortran_vec ();
 
-  Array<double> scale (n, 1);
+  Array<double> scale (dim_vector (n, 1));
   double *pscale = scale.fortran_vec ();
 
   F77_XFCN (zgebal, ZGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
                              n, h, n, ilo, ihi, pscale, info
                              F77_CHAR_ARG_LEN (1)));
 
-  Array<Complex> tau (n-1, 1);
+  Array<Complex> tau (dim_vector (n-1, 1));
   Complex *ptau = tau.fortran_vec ();
 
-  Array<Complex> work (lwork, 1);
+  Array<Complex> work (dim_vector (lwork, 1));
   Complex *pwork = work.fortran_vec ();
 
   F77_XFCN (zgehrd, ZGEHRD, (n, ilo, ihi, h, n, ptau, pwork, lwork, info));
 
   unitary_hess_mat = hess_mat;
   Complex *z = unitary_hess_mat.fortran_vec ();
 
   F77_XFCN (zunghr, ZUNGHR, (n, ilo, ihi, z, n, ptau, pwork,
diff --git a/liboctave/CmplxQRP.cc b/liboctave/CmplxQRP.cc
--- a/liboctave/CmplxQRP.cc
+++ b/liboctave/CmplxQRP.cc
@@ -62,17 +62,17 @@ ComplexQRP::init (const ComplexMatrix& a
   OCTAVE_LOCAL_BUFFER (Complex, tau, min_mn);
 
   octave_idx_type info = 0;
 
   ComplexMatrix afact = a;
   if (m > n && qr_type == qr_type_std)
     afact.resize (m, m);
 
-  MArray<octave_idx_type> jpvt (n, 1, 0);
+  MArray<octave_idx_type> jpvt (dim_vector (n, 1), 0);
 
   if (m > 0)
     {
       OCTAVE_LOCAL_BUFFER (double, rwork, 2*n);
 
       // workspace query.
       Complex clwork;
       F77_XFCN (zgeqp3, ZGEQP3, (m, n, afact.fortran_vec (), m, jpvt.fortran_vec (),
diff --git a/liboctave/CmplxSCHUR.cc b/liboctave/CmplxSCHUR.cc
--- a/liboctave/CmplxSCHUR.cc
+++ b/liboctave/CmplxSCHUR.cc
@@ -116,27 +116,28 @@ ComplexSCHUR::init (const ComplexMatrix&
 
   schur_mat = a;
   if (calc_unitary)
     unitary_mat.clear (n, n);
 
   Complex *s = schur_mat.fortran_vec ();
   Complex *q = unitary_mat.fortran_vec ();
 
-  Array<double> rwork (n, 1);
+  Array<double> rwork (dim_vector (n, 1));
   double *prwork = rwork.fortran_vec ();
 
-  Array<Complex> w (n, 1);
+  Array<Complex> w (dim_vector (n, 1));
   Complex *pw = w.fortran_vec ();
 
-  Array<Complex> work (lwork, 1);
+  Array<Complex> work (dim_vector (lwork, 1));
   Complex *pwork = work.fortran_vec ();
 
   // BWORK is not referenced for non-ordered Schur.
-  Array<octave_idx_type> bwork ((ord_char == 'N' || ord_char == 'n') ? 0 : n, 1);
+  octave_idx_type ntmp = (ord_char == 'N' || ord_char == 'n') ? 0 : n;
+  Array<octave_idx_type> bwork (dim_vector (ntmp, 1));
   octave_idx_type *pbwork = bwork.fortran_vec ();
 
   F77_XFCN (zgeesx, ZGEESX, (F77_CONST_CHAR_ARG2 (&jobvs, 1),
                              F77_CONST_CHAR_ARG2 (&sort, 1),
                              selector,
                              F77_CONST_CHAR_ARG2 (&sense, 1),
                              n, s, n, sdim, pw, q, n, rconde, rcondv,
                              pwork, lwork, prwork, pbwork, info
diff --git a/liboctave/CmplxSVD.cc b/liboctave/CmplxSVD.cc
--- a/liboctave/CmplxSVD.cc
+++ b/liboctave/CmplxSVD.cc
@@ -139,23 +139,23 @@ ComplexSVD::init (const ComplexMatrix& a
 
   if (! (jobv == 'N' || jobv == 'O'))
     right_sm.resize (nrow_vt, n);
 
   Complex *vt = right_sm.fortran_vec ();
 
   octave_idx_type lrwork = 5*max_mn;
 
-  Array<double> rwork (lrwork, 1);
+  Array<double> rwork (dim_vector (lrwork, 1));
 
   // Ask ZGESVD what the dimension of WORK should be.
 
   octave_idx_type lwork = -1;
 
-  Array<Complex> work (1, 1);
+  Array<Complex> work (dim_vector (1, 1));
 
   octave_idx_type one = 1;
   octave_idx_type m1 = std::max (m, one), nrow_vt1 = std::max (nrow_vt, one);
 
   if (svd_driver == SVD::GESVD)
     {
       F77_XFCN (zgesvd, ZGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                                  F77_CONST_CHAR_ARG2 (&jobv, 1),
diff --git a/liboctave/CollocWt.cc b/liboctave/CollocWt.cc
--- a/liboctave/CollocWt.cc
+++ b/liboctave/CollocWt.cc
@@ -423,26 +423,26 @@ CollocWt::init (void)
   if (nt < 0)
     {
       error ("total number of collocation points less than zero");
       return;
     }
   else if (nt == 0)
     return;
 
-  Array<double> dif1 (nt, 1);
+  Array<double> dif1 (dim_vector (nt, 1));
   double *pdif1 = dif1.fortran_vec ();
 
-  Array<double> dif2 (nt, 1);
+  Array<double> dif2 (dim_vector (nt, 1));
   double *pdif2 = dif2.fortran_vec ();
 
-  Array<double> dif3 (nt, 1);
+  Array<double> dif3 (dim_vector (nt, 1));
   double *pdif3 = dif3.fortran_vec ();
 
-  Array<double> vect (nt, 1);
+  Array<double> vect (dim_vector (nt, 1));
   double *pvect = vect.fortran_vec ();
 
   r.resize (nt, 1);
   q.resize (nt, 1);
   A.resize (nt, nt);
   B.resize (nt, nt);
 
   double *pr = r.fortran_vec ();
diff --git a/liboctave/DiagArray2.cc b/liboctave/DiagArray2.cc
--- a/liboctave/DiagArray2.cc
+++ b/liboctave/DiagArray2.cc
@@ -50,19 +50,19 @@ Array<T>
 DiagArray2<T>::diag (octave_idx_type k) const
 {
   Array<T> d;
 
   if (k == 0)
     // The main diagonal is shallow-copied.
     d = *this;
   else if (k > 0 && k < cols ())
-    d = Array<T> (std::min (cols () - k, rows ()), 1, T ());
+    d = Array<T> (dim_vector (std::min (cols () - k, rows ()), 1), T ());
   else if (k < 0 && -k < rows ())
-    d = Array<T> (std::min (rows () + k, cols ()), 1, T ());
+    d = Array<T> (dim_vector (std::min (rows () + k, cols ()), 1), T ());
   else
     (*current_liboctave_error_handler)
       ("diag: requested diagonal out of range");
 
   return d;
 }
 
 template <class T>
@@ -107,16 +107,18 @@ DiagArray2<T>::resize (octave_idx_type r
   if (r != dim1 () || c != dim2 ())
     {
       Array<T>::resize (std::min (r, c), 1, rfv);
       d1 = r; d2 = c;
     }
 }
 
 template <class T>
-Array<T> DiagArray2<T>::array_value (void) const
+Array<T>
+DiagArray2<T>::array_value (void) const
 {
-  Array<T> result (dim1 (), dim2 ());
+  Array<T> result (dims (), T (0));
+
   for (octave_idx_type i = 0, len = length (); i < len; i++)
     result.xelem (i, i) = dgelem (i);
 
   return result;
 }
diff --git a/liboctave/DiagArray2.h b/liboctave/DiagArray2.h
--- a/liboctave/DiagArray2.h
+++ b/liboctave/DiagArray2.h
@@ -44,32 +44,32 @@ protected:
 public:
 
   using Array<T>::element_type;
 
   DiagArray2 (void) 
     : Array<T> (), d1 (0), d2 (0) { }
 
   DiagArray2 (octave_idx_type r, octave_idx_type c) 
-    : Array<T> (std::min (r, c), 1), d1 (r), d2 (c) { }
+    : Array<T> (dim_vector (std::min (r, c), 1)), d1 (r), d2 (c) { }
 
   DiagArray2 (octave_idx_type r, octave_idx_type c, const T& val) 
-    : Array<T> (std::min (r, c), 1, val), d1 (r), d2 (c) { }
+    : Array<T> (dim_vector (std::min (r, c), 1), val), d1 (r), d2 (c) { }
 
   explicit DiagArray2 (const Array<T>& a) 
     : Array<T> (a.as_column ()), d1 (a.numel ()), d2 (a.numel ()) { }
 
   DiagArray2 (const Array<T>& a, octave_idx_type r, octave_idx_type c);
 
   DiagArray2 (const DiagArray2<T>& a) 
     : Array<T> (a), d1 (a.d1), d2 (a.d2) { }
 
   template <class U>
   DiagArray2 (const DiagArray2<U>& a) 
-  : Array<T> (a.diag ()), d1 (a.dim1 ()), d2 (a.dim2 ()) { }
+    : Array<T> (a.diag ()), d1 (a.dim1 ()), d2 (a.dim2 ()) { }
 
   ~DiagArray2 (void) { }
 
   DiagArray2<T>& operator = (const DiagArray2<T>& a)
     {
       if (this != &a)
         {
           Array<T>::operator = (a);
diff --git a/liboctave/EIG.cc b/liboctave/EIG.cc
--- a/liboctave/EIG.cc
+++ b/liboctave/EIG.cc
@@ -157,20 +157,20 @@ EIG::init (const Matrix& a, bool calc_ev
       return -1;
     }
 
   octave_idx_type info = 0;
 
   Matrix atmp = a;
   double *tmp_data = atmp.fortran_vec ();
 
-  Array<double> wr (n, 1);
+  Array<double> wr (dim_vector (n, 1));
   double *pwr = wr.fortran_vec ();
 
-  Array<double> wi (n, 1);
+  Array<double> wi (dim_vector (n, 1));
   double *pwi = wi.fortran_vec ();
 
   octave_idx_type tnvr = calc_ev ? n : 0;
   Matrix vr (tnvr, tnvr);
   double *pvr = vr.fortran_vec ();
 
   octave_idx_type lwork = -1;
   double dummy_work;
@@ -183,17 +183,17 @@ EIG::init (const Matrix& a, bool calc_ev
                            n, tmp_data, n, pwr, pwi, dummy,
                            idummy, pvr, n, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
-      Array<double> work (lwork, 1);
+      Array<double> work (dim_vector (lwork, 1));
       double *pwork = work.fortran_vec ();
 
       F77_XFCN (dgeev, DGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                n, tmp_data, n, pwr, pwi, dummy,
                                idummy, pvr, n, pwork, lwork, info
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
@@ -276,17 +276,17 @@ EIG::symmetric_init (const Matrix& a, bo
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, tmp_data, n, pwr, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
-      Array<double> work (lwork, 1);
+      Array<double> work (dim_vector (lwork, 1));
       double *pwork = work.fortran_vec ();
 
       F77_XFCN (dsyev, DSYEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                F77_CONST_CHAR_ARG2 ("U", 1),
                                n, tmp_data, n, pwr, pwork, lwork, info
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
 
@@ -343,33 +343,33 @@ EIG::init (const ComplexMatrix& a, bool 
   octave_idx_type nvr = calc_ev ? n : 0;
   ComplexMatrix vtmp (nvr, nvr);
   Complex *pv = vtmp.fortran_vec ();
 
   octave_idx_type lwork = -1;
   Complex dummy_work;
 
   octave_idx_type lrwork = 2*n;
-  Array<double> rwork (lrwork, 1);
+  Array<double> rwork (dim_vector (lrwork, 1));
   double *prwork = rwork.fortran_vec ();
 
   Complex *dummy = 0;
   octave_idx_type idummy = 1;
 
   F77_XFCN (zgeev, ZGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            n, tmp_data, n, pw, dummy, idummy,
                            pv, n, &dummy_work, lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
-      Array<Complex> work (lwork, 1);
+      Array<Complex> work (dim_vector (lwork, 1));
       Complex *pwork = work.fortran_vec ();
 
       F77_XFCN (zgeev, ZGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                n, tmp_data, n, pw, dummy, idummy,
                                pv, n, pwork, lwork, prwork, info
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
@@ -413,30 +413,30 @@ EIG::hermitian_init (const ComplexMatrix
 
   ColumnVector wr (n);
   double *pwr = wr.fortran_vec ();
 
   octave_idx_type lwork = -1;
   Complex dummy_work;
 
   octave_idx_type lrwork = 3*n;
-  Array<double> rwork (lrwork, 1);
+  Array<double> rwork (dim_vector (lrwork, 1));
   double *prwork = rwork.fortran_vec ();
 
   F77_XFCN (zheev, ZHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, tmp_data, n, pwr, &dummy_work, lwork,
                            prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
-      Array<Complex> work (lwork, 1);
+      Array<Complex> work (dim_vector (lwork, 1));
       Complex *pwork = work.fortran_vec ();
 
       F77_XFCN (zheev, ZHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                F77_CONST_CHAR_ARG2 ("U", 1),
                                n, tmp_data, n, pwr, pwork, lwork, prwork, info
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
 
@@ -501,23 +501,23 @@ EIG::init (const Matrix& a, const Matrix
     return symmetric_init (a, b, calc_ev);
 
   Matrix atmp = a;
   double *atmp_data = atmp.fortran_vec ();
 
   Matrix btmp = b;
   double *btmp_data = btmp.fortran_vec ();
 
-  Array<double> ar (n, 1);
+  Array<double> ar (dim_vector (n, 1));
   double *par = ar.fortran_vec ();
 
-  Array<double> ai (n, 1);
+  Array<double> ai (dim_vector (n, 1));
   double *pai = ai.fortran_vec ();
 
-  Array<double> beta (n, 1);
+  Array<double> beta (dim_vector (n, 1));
   double *pbeta = beta.fortran_vec ();
 
   octave_idx_type tnvr = calc_ev ? n : 0;
   Matrix vr (tnvr, tnvr);
   double *pvr = vr.fortran_vec ();
 
   octave_idx_type lwork = -1;
   double dummy_work;
@@ -532,17 +532,17 @@ EIG::init (const Matrix& a, const Matrix
                            dummy, idummy, pvr, n,
                            &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
-      Array<double> work (lwork, 1);
+      Array<double> work (dim_vector (lwork, 1));
       double *pwork = work.fortran_vec ();
 
       F77_XFCN (dggev, DGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                n, atmp_data, n, btmp_data, n, 
                                par, pai, pbeta,
                                dummy, idummy, pvr, n,
                                pwork, lwork, info
@@ -641,17 +641,17 @@ EIG::symmetric_init (const Matrix& a, co
                            btmp_data, n, 
                            pwr, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
-      Array<double> work (lwork, 1);
+      Array<double> work (dim_vector (lwork, 1));
       double *pwork = work.fortran_vec ();
 
       F77_XFCN (dsygv, DSYGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                F77_CONST_CHAR_ARG2 ("U", 1),
                                n, atmp_data, n, 
                                btmp_data, n, 
                                pwr, pwork, lwork, info
                                F77_CHAR_ARG_LEN (1)
@@ -732,34 +732,34 @@ EIG::init (const ComplexMatrix& a, const
   octave_idx_type nvr = calc_ev ? n : 0;
   ComplexMatrix vtmp (nvr, nvr);
   Complex *pv = vtmp.fortran_vec ();
 
   octave_idx_type lwork = -1;
   Complex dummy_work;
 
   octave_idx_type lrwork = 8*n;
-  Array<double> rwork (lrwork, 1);
+  Array<double> rwork (dim_vector (lrwork, 1));
   double *prwork = rwork.fortran_vec ();
 
   Complex *dummy = 0;
   octave_idx_type idummy = 1;
 
   F77_XFCN (zggev, ZGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            n, atmp_data, n, btmp_data, n, 
                            palpha, pbeta, dummy, idummy,
                            pv, n, &dummy_work, lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
-      Array<Complex> work (lwork, 1);
+      Array<Complex> work (dim_vector (lwork, 1));
       Complex *pwork = work.fortran_vec ();
 
       F77_XFCN (zggev, ZGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                n, atmp_data, n, btmp_data, n, 
                                palpha, pbeta, dummy, idummy,
                                pv, n, pwork, lwork, prwork, info
                                F77_CHAR_ARG_LEN (1)
@@ -818,32 +818,32 @@ EIG::hermitian_init (const ComplexMatrix
 
   ColumnVector wr (n);
   double *pwr = wr.fortran_vec ();
 
   octave_idx_type lwork = -1;
   Complex dummy_work;
 
   octave_idx_type lrwork = 3*n;
-  Array<double> rwork (lrwork, 1);
+  Array<double> rwork (dim_vector (lrwork, 1));
   double *prwork = rwork.fortran_vec ();
 
   F77_XFCN (zhegv, ZHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, atmp_data, n, 
                            btmp_data, n,
                            pwr, &dummy_work, lwork,
                            prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
-      Array<Complex> work (lwork, 1);
+      Array<Complex> work (dim_vector (lwork, 1));
       Complex *pwork = work.fortran_vec ();
 
       F77_XFCN (zhegv, ZHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                F77_CONST_CHAR_ARG2 ("U", 1),
                                n, atmp_data, n, 
                                btmp_data, n, 
                                pwr, pwork, lwork, prwork, info
                                F77_CHAR_ARG_LEN (1)
diff --git a/liboctave/MArray.h b/liboctave/MArray.h
--- a/liboctave/MArray.h
+++ b/liboctave/MArray.h
@@ -38,21 +38,21 @@ MARRAY_OPS_FORWARD_DECLS (MArray, )
 template <class T>
 class
 MArray : public Array<T>
 {
 public:
   
   MArray (void) : Array<T> () {}
   
-  explicit MArray (octave_idx_type m, octave_idx_type n) 
-    : Array<T> (m, n) { }
+  explicit MArray (octave_idx_type n) GCC_ATTR_DEPRECATED
+    : Array<T> (dim_vector (n, 1)) { }
 
-  explicit MArray (octave_idx_type m, octave_idx_type n, const T& val) 
-    : Array<T> (m, n, val) { }
+  MArray (octave_idx_type n, const T& val) GCC_ATTR_DEPRECATED
+    : Array<T> (dim_vector (n, 1), val) { }
 
   explicit MArray (const dim_vector& dv) 
     : Array<T> (dv) { }
   
   explicit MArray (const dim_vector& dv, const T& val) 
     : Array<T> (dv, val) { }
 
   MArray (const MArray<T>& a) : Array<T> (a) { }
diff --git a/liboctave/MSparse.cc b/liboctave/MSparse.cc
--- a/liboctave/MSparse.cc
+++ b/liboctave/MSparse.cc
@@ -188,17 +188,17 @@ operator -= (MSparse<T>& a, const MSpars
 #define SPARSE_A2S_OP_1(OP) \
   template <class T> \
   MArray<T> \
   operator OP (const MSparse<T>& a, const T& s) \
   { \
     octave_idx_type nr = a.rows (); \
     octave_idx_type nc = a.cols (); \
  \
-    MArray<T> r (nr, nc, (0.0 OP s));  \
+    MArray<T> r (dim_vector (nr, nc), (0.0 OP s));      \
  \
     for (octave_idx_type j = 0; j < nc; j++) \
       for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++) \
         r.elem (a.ridx (i), j) = a.data (i) OP s;       \
     return r; \
   }
 
 #define SPARSE_A2S_OP_2(OP) \
@@ -234,17 +234,17 @@ SPARSE_A2S_OP_2 (/)
 #define SPARSE_SA2_OP_1(OP) \
   template <class T> \
   MArray<T> \
   operator OP (const T& s, const MSparse<T>& a) \
   { \
     octave_idx_type nr = a.rows (); \
     octave_idx_type nc = a.cols (); \
  \
-    MArray<T> r (nr, nc, (s OP 0.0));  \
+    MArray<T> r (dim_vector (nr, nc), (s OP 0.0));      \
  \
     for (octave_idx_type j = 0; j < nc; j++) \
       for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++) \
         r.elem (a.ridx (i), j) = s OP a.data (i);       \
     return r; \
   }
 
 #define SPARSE_SA2_OP_2(OP) \
diff --git a/liboctave/PermMatrix.cc b/liboctave/PermMatrix.cc
--- a/liboctave/PermMatrix.cc
+++ b/liboctave/PermMatrix.cc
@@ -52,24 +52,24 @@ PermMatrix::PermMatrix (const Array<octa
 PermMatrix::PermMatrix (const idx_vector& idx, bool colp, octave_idx_type n)
   : Array<octave_idx_type> (), _colp(colp)
 {
   octave_idx_type len = idx.length (n);
   if (! idx.is_permutation (len))
     gripe_invalid_permutation ();
   else
     {
-      Array<octave_idx_type> idxa (len, 1);
+      Array<octave_idx_type> idxa (dim_vector (len, 1));
       for (octave_idx_type i = 0; i < len; i++) idxa(i) = idx(i);
       Array<octave_idx_type>::operator = (idxa);
     }
 }
 
 PermMatrix::PermMatrix (octave_idx_type n)
-  : Array<octave_idx_type> (n, 1), _colp (false)
+  : Array<octave_idx_type> (dim_vector (n, 1)), _colp (false)
 {
   for (octave_idx_type i = 0; i < n; i++) xelem (i) = i;
 }
 
 octave_idx_type 
 PermMatrix::checkelem (octave_idx_type i, octave_idx_type j) const
 {
   octave_idx_type len = Array<octave_idx_type>::length ();
@@ -140,17 +140,17 @@ PermMatrix::power (octave_idx_type m) co
     {
       res_colp = ! res_colp;
       m = -m;
     }
   else if (m == 0)
     return PermMatrix (n);
 
   const octave_idx_type *p = data ();
-  Array<octave_idx_type> res_pvec (n, 1, -1);
+  Array<octave_idx_type> res_pvec (dim_vector (n, 1), -1);
   octave_idx_type *q = res_pvec.fortran_vec ();
 
   for (octave_idx_type ics = 0; ics < n; ics++)
     {
       if (q[ics] > 0)
         continue;
 
       // go forward m steps or until a cycle is found.
@@ -176,17 +176,17 @@ PermMatrix::power (octave_idx_type m) co
     }
 
   return PermMatrix (res_pvec, res_colp, false);
 }
 
 PermMatrix
 PermMatrix::eye (octave_idx_type n)
 {
-  Array<octave_idx_type> p(n, 1);
+  Array<octave_idx_type> p (dim_vector (n, 1));
   for (octave_idx_type i = 0; i < n; i++)
     p(i) = i;
 
   return PermMatrix (p, false, false);
 }
 
 PermMatrix 
 operator *(const PermMatrix& a, const PermMatrix& b)
@@ -199,17 +199,17 @@ operator *(const PermMatrix& a, const Pe
   else if (a._colp == b._colp)
     {
       r = PermMatrix ((a._colp 
                        ? ia.index (idx_vector (ib)) 
                        : ib.index (idx_vector (ia))), a._colp, false);
     }
   else
     {
-      Array<octave_idx_type> ra (n, 1);
+      Array<octave_idx_type> ra (dim_vector (n, 1));
       if (a._colp)
         ra.assign (idx_vector (ib), ia);
       else
         ra.assign (idx_vector (ia), ib);
       r = PermMatrix (ra, a._colp, false);
     }
 
   return r;
diff --git a/liboctave/Quad.cc b/liboctave/Quad.cc
--- a/liboctave/Quad.cc
+++ b/liboctave/Quad.cc
@@ -126,21 +126,21 @@ float_user_function (float *x, int& ierr
 double
 DefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval, double& abserr)
 {
   octave_idx_type npts = singularities.capacity () + 2;
   double *points = singularities.fortran_vec ();
   double result = 0.0;
 
   octave_idx_type leniw = 183*npts - 122;
-  Array<octave_idx_type> iwork (leniw, 1);
+  Array<octave_idx_type> iwork (dim_vector (leniw, 1));
   octave_idx_type *piwork = iwork.fortran_vec ();
 
   octave_idx_type lenw = 2*leniw - npts;
-  Array<double> work (lenw, 1);
+  Array<double> work (dim_vector (lenw, 1));
   double *pwork = work.fortran_vec ();
 
   user_fcn = f;
   octave_idx_type last;
 
   double abs_tol = absolute_tolerance ();
   double rel_tol = relative_tolerance ();
 
@@ -160,21 +160,21 @@ DefQuad::do_integrate (octave_idx_type&,
 }
 
 double
 IndefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval, double& abserr)
 {
   double result = 0.0;
 
   octave_idx_type leniw = 128;
-  Array<octave_idx_type> iwork (leniw, 1);
+  Array<octave_idx_type> iwork (dim_vector (leniw, 1));
   octave_idx_type *piwork = iwork.fortran_vec ();
 
   octave_idx_type lenw = 8*leniw;
-  Array<double> work (lenw, 1);
+  Array<double> work (dim_vector (lenw, 1));
   double *pwork = work.fortran_vec ();
 
   user_fcn = f;
   octave_idx_type last;
 
   octave_idx_type inf;
   switch (type)
     {
@@ -222,21 +222,21 @@ FloatDefQuad::do_integrate (octave_idx_t
 float
 FloatDefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval, float& abserr)
 {
   octave_idx_type npts = singularities.capacity () + 2;
   float *points = singularities.fortran_vec ();
   float result = 0.0;
 
   octave_idx_type leniw = 183*npts - 122;
-  Array<octave_idx_type> iwork (leniw, 1);
+  Array<octave_idx_type> iwork (dim_vector (leniw, 1));
   octave_idx_type *piwork = iwork.fortran_vec ();
 
   octave_idx_type lenw = 2*leniw - npts;
-  Array<float> work (lenw, 1);
+  Array<float> work (dim_vector (lenw, 1));
   float *pwork = work.fortran_vec ();
 
   float_user_fcn = ff;
   octave_idx_type last;
 
   float abs_tol = single_precision_absolute_tolerance ();
   float rel_tol = single_precision_relative_tolerance ();
 
@@ -256,21 +256,21 @@ FloatIndefQuad::do_integrate (octave_idx
 }
 
 float
 FloatIndefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval, float& abserr)
 {
   float result = 0.0;
 
   octave_idx_type leniw = 128;
-  Array<octave_idx_type> iwork (leniw, 1);
+  Array<octave_idx_type> iwork (dim_vector (leniw, 1));
   octave_idx_type *piwork = iwork.fortran_vec ();
 
   octave_idx_type lenw = 8*leniw;
-  Array<float> work (lenw, 1);
+  Array<float> work (dim_vector (lenw, 1));
   float *pwork = work.fortran_vec ();
 
   float_user_fcn = ff;
   octave_idx_type last;
 
   octave_idx_type inf;
   switch (type)
     {
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -1388,17 +1388,17 @@ Sparse<T>::index (const idx_vector& idx,
           const Array<octave_idx_type> idxa = (idx_dims(0) == 1 
                                                ? idx.as_array ().transpose ()
                                                : idx.as_array ());
 
           octave_idx_type new_nr = idxa.rows (), new_nc = idxa.cols ();
 
           // Lookup.
           // FIXME: Could specialize for sorted idx?
-          NoAlias< Array<octave_idx_type> > lidx (new_nr, new_nc);
+          NoAlias< Array<octave_idx_type> > lidx (dim_vector (new_nr, new_nc));
           for (octave_idx_type i = 0; i < new_nr*new_nc; i++)
             lidx(i) = lblookup (ridx (), nz, idxa(i));
 
           // Count matches.
           retval = Sparse<T> (idxa.rows (), idxa.cols ());
           for (octave_idx_type j = 0; j < new_nc; j++)
             {
               octave_idx_type nzj = 0;
@@ -1798,18 +1798,18 @@ Sparse<T>::assign (const idx_vector& idx
 
               maybe_compress (true);
             }
           else
             {
               const Sparse<T> tmp = *this;
               octave_idx_type new_nz = nz + rhl;
               // Disassembly our matrix...
-              Array<octave_idx_type> new_ri (new_nz, 1);
-              Array<T> new_data (new_nz, 1);
+              Array<octave_idx_type> new_ri (dim_vector (new_nz, 1));
+              Array<T> new_data (dim_vector (new_nz, 1));
               copy_or_memcpy (nz, tmp.ridx (), new_ri.fortran_vec ());
               copy_or_memcpy (nz, tmp.data (), new_data.fortran_vec ());
               // ... insert new data (densified) ...
               idx.copy_data (new_ri.fortran_vec () + nz);
               new_data.assign (idx_vector (nz, new_nz), rhs.array_value ());
               // ... reassembly.
               *this = Sparse<T> (new_data, new_ri,
                                  static_cast<octave_idx_type> (0),
diff --git a/liboctave/base-lu.cc b/liboctave/base-lu.cc
--- a/liboctave/base-lu.cc
+++ b/liboctave/base-lu.cc
@@ -118,17 +118,17 @@ base_lu <lu_type> :: Y (void) const
 template <class lu_type>
 Array<octave_idx_type>
 base_lu <lu_type> :: getp (void) const
 {
   if (packed ())
     {
       octave_idx_type a_nr = a_fact.rows ();
 
-      Array<octave_idx_type> pvt (a_nr, 1);
+      Array<octave_idx_type> pvt (dim_vector (a_nr, 1));
 
       for (octave_idx_type i = 0; i < a_nr; i++)
         pvt.xelem (i) = i;
 
       for (octave_idx_type i = 0; i < ipvt.length(); i++)
         {
           octave_idx_type k = ipvt.xelem (i);
 
diff --git a/liboctave/boolMatrix.h b/liboctave/boolMatrix.h
--- a/liboctave/boolMatrix.h
+++ b/liboctave/boolMatrix.h
@@ -31,21 +31,29 @@ along with Octave; see the file COPYING.
 
 class
 OCTAVE_API
 boolMatrix : public Array<bool>
 {
 public:
 
   boolMatrix (void) : Array<bool> () { }
-  boolMatrix (octave_idx_type r, octave_idx_type c) : Array<bool> (r, c) { }
-  boolMatrix (octave_idx_type r, octave_idx_type c, bool val) : Array<bool> (r, c, val) { }
+
+  boolMatrix (octave_idx_type r, octave_idx_type c)
+    : Array<bool> (dim_vector (r, c)) { }
+
+  boolMatrix (octave_idx_type r, octave_idx_type c, bool val)
+    : Array<bool> (dim_vector (r, c), val) { }
+
   boolMatrix (const dim_vector& dv) : Array<bool> (dv) { }
+
   boolMatrix (const dim_vector& dv, bool val) : Array<bool> (dv, val) { }
+
   boolMatrix (const Array<bool>& a) : Array<bool> (a.as_matrix ()) { }
+
   boolMatrix (const boolMatrix& a) : Array<bool> (a) { }
 
   boolMatrix& operator = (const boolMatrix& a)
     {
       Array<bool>::operator = (a);
       return *this;
     }
 
diff --git a/liboctave/boolSparse.cc b/liboctave/boolSparse.cc
--- a/liboctave/boolSparse.cc
+++ b/liboctave/boolSparse.cc
@@ -158,26 +158,26 @@ SparseBoolMatrix::any (int dim) const
       fill_or_memset (new_nz, true, retval.data ());
     }
   else if (dim == 1)
     {
       // Result is a column vector.
       if (nz > nr/4)
         {
           // We can use O(nr) memory.
-          Array<bool> tmp (nr, 1, false);
+          Array<bool> tmp (dim_vector (nr, 1), false);
           for (octave_idx_type i = 0; i < nz; i++)
             tmp.xelem(ridx(i)) = true;
           retval = tmp;
         }
       else
         {
-          Array<octave_idx_type> tmp (nz, 1);
+          Array<octave_idx_type> tmp (dim_vector (nz, 1));
           copy_or_memcpy (nz, ridx (), tmp.fortran_vec ());
-          retval = Sparse<bool> (Array<bool> (1, 1, true),
+          retval = Sparse<bool> (Array<bool> (dim_vector (1, 1), true),
                                  idx_vector (tmp),
                                  idx_vector (static_cast<octave_idx_type> (0)),
                                  nr, 1, false);
         }
     }
 
   return retval;
 }
@@ -207,26 +207,26 @@ SparseBoolMatrix::sum (int dim) const
         }
     }
   else if (dim == 1)
     {
       // Result is a column vector.
       if (nz > nr)
         {
           // We can use O(nr) memory.
-          Array<double> tmp (nr, 1, 0);
+          Array<double> tmp (dim_vector (nr, 1), 0);
           for (octave_idx_type i = 0; i < nz; i++)
             tmp.xelem(ridx(i)) += 1.0;
           retval = tmp;
         }
       else
         {
-          Array<octave_idx_type> tmp (nz, 1);
+          Array<octave_idx_type> tmp (dim_vector (nz, 1));
           copy_or_memcpy (nz, ridx (), tmp.fortran_vec ());
-          retval = Sparse<double> (Array<double> (1, 1, 1.0),
+          retval = Sparse<double> (Array<double> (dim_vector (1, 1), 1.0),
                                    idx_vector (tmp),
                                    idx_vector (static_cast<octave_idx_type> (0)),
                                    nr, 1);
         }
     }
 
   return retval;
 }
diff --git a/liboctave/chMatrix.cc b/liboctave/chMatrix.cc
--- a/liboctave/chMatrix.cc
+++ b/liboctave/chMatrix.cc
@@ -70,17 +70,17 @@ charMatrix::charMatrix (const std::strin
 
   resize (nr, nc);
 
   for (octave_idx_type i = 0; i < nc; i++)
     elem (0, i) = s[i];
 }
 
 charMatrix::charMatrix (const string_vector& s)
-  : Array<char> (s.length (), s.max_length (), 0)
+  : Array<char> (dim_vector (s.length (), s.max_length ()), 0)
 {
   octave_idx_type nr = rows ();
 
   for (octave_idx_type i = 0; i < nr; i++)
     {
       const std::string si = s(i);
       octave_idx_type nc = si.length ();
       for (octave_idx_type j = 0; j < nc; j++)
diff --git a/liboctave/chMatrix.h b/liboctave/chMatrix.h
--- a/liboctave/chMatrix.h
+++ b/liboctave/chMatrix.h
@@ -36,25 +36,37 @@ class
 OCTAVE_API
 charMatrix : public Array<char>
 {
 friend class ComplexMatrix;
 
 public:
 
   charMatrix (void) : Array<char> () { }
-  charMatrix (octave_idx_type r, octave_idx_type c) : Array<char> (r, c) { }
-  charMatrix (octave_idx_type r, octave_idx_type c, char val) : Array<char> (r, c, val) { }
+
+  charMatrix (octave_idx_type r, octave_idx_type c)
+    : Array<char> (dim_vector (r, c)) { }
+
+  charMatrix (octave_idx_type r, octave_idx_type c, char val)
+    : Array<char> (dim_vector (r, c), val) { }
+
   charMatrix (const dim_vector& dv) : Array<char> (dv) { }
+
   charMatrix (const dim_vector& dv, char val) : Array<char> (dv, val) { }
+
   charMatrix (const Array<char>& a) : Array<char> (a.as_matrix ()) { }
+
   charMatrix (const charMatrix& a) : Array<char> (a) { }
+
   charMatrix (char c);
+
   charMatrix (const char *s);
+
   charMatrix (const std::string& s);
+
   charMatrix (const string_vector& s);
 
   charMatrix& operator = (const charMatrix& a)
     {
       Array<char>::operator = (a);
       return *this;
     }
 
diff --git a/liboctave/dColVector.h b/liboctave/dColVector.h
--- a/liboctave/dColVector.h
+++ b/liboctave/dColVector.h
@@ -29,24 +29,26 @@ along with Octave; see the file COPYING.
 #include "mx-defs.h"
 
 class
 OCTAVE_API
 ColumnVector : public MArray<double>
 {
 public:
 
-  ColumnVector (void) : MArray<double> (0, 1) { }
+  ColumnVector (void) : MArray<double> (dim_vector (0, 1)) { }
 
-  explicit ColumnVector (octave_idx_type n) : MArray<double> (n, 1) { }
+  explicit ColumnVector (octave_idx_type n)
+    : MArray<double> (dim_vector (n, 1)) { }
 
   explicit ColumnVector (const dim_vector& dv) 
     : MArray<double> (dv.as_column ()) { }
 
-  ColumnVector (octave_idx_type n, double val) : MArray<double> (n, 1, val) { }
+  ColumnVector (octave_idx_type n, double val)
+    : MArray<double> (dim_vector (n, 1), val) { }
 
   ColumnVector (const ColumnVector& a) : MArray<double> (a) { }
 
   ColumnVector (const MArray<double>& a) : MArray<double> (a.as_column ()) { }
   ColumnVector (const Array<double>& a) : MArray<double> (a.as_column ()) { }
 
   ColumnVector& operator = (const ColumnVector& a)
     {
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -245,24 +245,24 @@ Matrix::Matrix (const RowVector& rv)
 }
 
 Matrix::Matrix (const ColumnVector& cv)
   : MArray<double> (cv)
 {
 }
 
 Matrix::Matrix (const DiagMatrix& a)
-  : MArray<double> (a.rows (), a.cols (), 0.0)
+  : MArray<double> (a.dims (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
 Matrix::Matrix (const PermMatrix& a)
-  : MArray<double> (a.rows (), a.cols (), 0.0)
+  : MArray<double> (a.dims (), 0.0)
 {
   const Array<octave_idx_type> ia (a.pvec ());
   octave_idx_type len = a.rows ();
   if (a.is_col_perm ())
     for (octave_idx_type i = 0; i < len; i++)
       elem (ia(i), i) = 1.0;
   else
     for (octave_idx_type i = 0; i < len; i++)
@@ -273,17 +273,17 @@ Matrix::Matrix (const PermMatrix& a)
 // here?
 
 Matrix::Matrix (const boolMatrix& a)
   : MArray<double> (a)
 {
 }
 
 Matrix::Matrix (const charMatrix& a)
-  : MArray<double> (a.rows (), a.cols ())
+  : MArray<double> (a.dims ())
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     for (octave_idx_type j = 0; j < a.cols (); j++)
       elem (i, j) = static_cast<unsigned char> (a.elem (i, j));
 }
 
 bool
 Matrix::operator == (const Matrix& a) const
@@ -735,23 +735,23 @@ Matrix::finverse (MatrixType &mattype, o
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
   else
     {
-      Array<octave_idx_type> ipvt (nr, 1);
+      Array<octave_idx_type> ipvt (dim_vector (nr, 1));
       octave_idx_type *pipvt = ipvt.fortran_vec ();
 
       retval = *this;
       double *tmp_data = retval.fortran_vec ();
 
-      Array<double> z(1, 1);
+      Array<double> z (dim_vector (1, 1));
       octave_idx_type lwork = -1;
 
       // Query the optimum work array size.
       F77_XFCN (dgetri, DGETRI, (nc, tmp_data, nr, pipvt, 
                                  z.fortran_vec (), lwork, info));
 
       lwork = static_cast<octave_idx_type> (z(0));
       lwork = (lwork < 2 *nc ? 2*nc : lwork);
@@ -772,17 +772,17 @@ Matrix::finverse (MatrixType &mattype, o
       if (info != 0) 
         info = -1;
       else if (calc_cond) 
         {
           octave_idx_type dgecon_info = 0;
 
           // Now calculate the condition number for non-singular matrix.
           char job = '1';
-          Array<octave_idx_type> iz (nc, 1);
+          Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
           F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nc, tmp_data, nr, anorm, 
                                      rcon, pz, piz, dgecon_info
                                      F77_CHAR_ARG_LEN (1)));
 
           if (dgecon_info != 0) 
             info = -1;
@@ -1007,17 +1007,17 @@ Matrix::fourier (void) const
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<Complex> wsave (nn, 1);
+  Array<Complex> wsave (dim_vector (nn, 1));
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = ComplexMatrix (*this);
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1048,17 +1048,17 @@ Matrix::ifourier (void) const
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<Complex> wsave (nn, 1);
+  Array<Complex> wsave (dim_vector (nn, 1));
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = ComplexMatrix (*this);
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1092,17 +1092,17 @@ Matrix::fourier2d (void) const
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<Complex> wsave (nn, 1);
+  Array<Complex> wsave (dim_vector (nn, 1));
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = ComplexMatrix (*this);
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1114,17 +1114,17 @@ Matrix::fourier2d (void) const
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
   wsave.resize (nn, 1);
   pwsave = wsave.fortran_vec ();
 
-  Array<Complex> tmp (npts, 1);
+  Array<Complex> tmp (dim_vector (npts, 1));
   Complex *prow = tmp.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
@@ -1158,17 +1158,17 @@ Matrix::ifourier2d (void) const
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<Complex> wsave (nn, 1);
+  Array<Complex> wsave (dim_vector (nn, 1));
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = ComplexMatrix (*this);
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1183,17 +1183,17 @@ Matrix::ifourier2d (void) const
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
   wsave.resize (nn, 1);
   pwsave = wsave.fortran_vec ();
 
-  Array<Complex> tmp (npts, 1);
+  Array<Complex> tmp (dim_vector (npts, 1));
   Complex *prow = tmp.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
@@ -1280,19 +1280,19 @@ Matrix::determinant (MatrixType& mattype
           if (info != 0) 
             {
               rcon = 0.0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else 
             {
-              Array<double> z (3 * nc, 1);
+              Array<double> z (dim_vector (3 * nc, 1));
               double *pz = z.fortran_vec ();
-              Array<octave_idx_type> iz (nc, 1);
+              Array<octave_idx_type> iz (dim_vector (nc, 1));
               octave_idx_type *piz = iz.fortran_vec ();
 
               F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                          nr, tmp_data, nr, anorm,
                                          rcon, pz, piz, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0) 
@@ -1304,17 +1304,17 @@ Matrix::determinant (MatrixType& mattype
               retval = retval.square ();
             }
         }
       else if (typ != MatrixType::Full)
         (*current_liboctave_error_handler) ("det: invalid dense matrix type");
 
       if (typ == MatrixType::Full)
         {
-          Array<octave_idx_type> ipvt (nr, 1);
+          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           Matrix atmp = *this;
           double *tmp_data = atmp.fortran_vec ();
 
           info = 0;
 
           // Calculate the norm of the matrix, for later use.
@@ -1331,19 +1331,19 @@ Matrix::determinant (MatrixType& mattype
               retval = DET ();
             } 
           else 
             {
               if (calc_cond) 
                 {
                   // Now calc the condition number for non-singular matrix.
                   char job = '1';
-                  Array<double> z (4 * nc, 1);
+                  Array<double> z (dim_vector (4 * nc, 1));
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nc, 1);
+                  Array<octave_idx_type> iz (dim_vector (nc, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nc, tmp_data, nr, anorm, 
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
                 }
 
@@ -1396,19 +1396,19 @@ Matrix::rcond (MatrixType &mattype) cons
       if (typ == MatrixType::Upper)
         {
           const double *tmp_data = fortran_vec ();
           octave_idx_type info = 0;
           char norm = '1';
           char uplo = 'U';
           char dia = 'N';
 
-          Array<double> z (3 * nc, 1);
+          Array<double> z (dim_vector (3 * nc, 1));
           double *pz = z.fortran_vec ();
-          Array<octave_idx_type> iz (nc, 1);
+          Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
 
           F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                      F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                      F77_CONST_CHAR_ARG2 (&dia, 1), 
                                      nr, tmp_data, nr, rcon,
                                      pz, piz, info
                                      F77_CHAR_ARG_LEN (1)
@@ -1424,19 +1424,19 @@ Matrix::rcond (MatrixType &mattype) cons
       else if (typ == MatrixType::Lower)
         {
           const double *tmp_data = fortran_vec ();
           octave_idx_type info = 0;
           char norm = '1';
           char uplo = 'L';
           char dia = 'N';
 
-          Array<double> z (3 * nc, 1);
+          Array<double> z (dim_vector (3 * nc, 1));
           double *pz = z.fortran_vec ();
-          Array<octave_idx_type> iz (nc, 1);
+          Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
 
           F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                      F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                      F77_CONST_CHAR_ARG2 (&dia, 1), 
                                      nr, tmp_data, nr, rcon,
                                      pz, piz, info
                                      F77_CHAR_ARG_LEN (1)
@@ -1469,45 +1469,45 @@ Matrix::rcond (MatrixType &mattype) cons
               if (info != 0) 
                 {
                   rcon = 0.0;
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
               else 
                 {
-                  Array<double> z (3 * nc, 1);
+                  Array<double> z (dim_vector (3 * nc, 1));
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nc, 1);
+                  Array<octave_idx_type> iz (dim_vector (nc, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0) 
                     rcon = 0.0;
                 }
             }
 
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
-              Array<octave_idx_type> ipvt (nr, 1);
+              Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
               if(anorm < 0.)
                 anorm = atmp.abs().sum().
                   row(static_cast<octave_idx_type>(0)).max();
 
-              Array<double> z (4 * nc, 1);
+              Array<double> z (dim_vector (4 * nc, 1));
               double *pz = z.fortran_vec ();
-              Array<octave_idx_type> iz (nc, 1);
+              Array<octave_idx_type> iz (dim_vector (nc, 1));
               octave_idx_type *piz = iz.fortran_vec ();
 
               F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
               if (info != 0) 
                 {
                   rcon = 0.0;
                   mattype.mark_as_rectangular ();
@@ -1568,19 +1568,19 @@ Matrix::utsolve (MatrixType &mattype, co
               const double *tmp_data = fortran_vec ();
 
               if (calc_cond)
                 {
                   char norm = '1';
                   char uplo = 'U';
                   char dia = 'N';
 
-                  Array<double> z (3 * nc, 1);
+                  Array<double> z (dim_vector (3 * nc, 1));
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nc, 1);
+                  Array<octave_idx_type> iz (dim_vector (nc, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                              F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                              F77_CONST_CHAR_ARG2 (&dia, 1), 
                                              nr, tmp_data, nr, rcon,
                                              pz, piz, info
                                              F77_CHAR_ARG_LEN (1)
@@ -1668,19 +1668,19 @@ Matrix::ltsolve (MatrixType &mattype, co
               const double *tmp_data = fortran_vec ();
 
               if (calc_cond)
                 {
                   char norm = '1';
                   char uplo = 'L';
                   char dia = 'N';
 
-                  Array<double> z (3 * nc, 1);
+                  Array<double> z (dim_vector (3 * nc, 1));
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nc, 1);
+                  Array<octave_idx_type> iz (dim_vector (nc, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                              F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                              F77_CONST_CHAR_ARG2 (&dia, 1), 
                                              nr, tmp_data, nr, rcon,
                                              pz, piz, info
                                              F77_CHAR_ARG_LEN (1)
@@ -1774,19 +1774,19 @@ Matrix::fsolve (MatrixType &mattype, con
 
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else 
             {
               if (calc_cond)
                 {
-                  Array<double> z (3 * nc, 1);
+                  Array<double> z (dim_vector (3 * nc, 1));
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nc, 1);
+                  Array<octave_idx_type> iz (dim_vector (nc, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0) 
@@ -1826,27 +1826,27 @@ Matrix::fsolve (MatrixType &mattype, con
                 }                   
             }
         }
 
       if (typ == MatrixType::Full)
         {
           info = 0;
 
-          Array<octave_idx_type> ipvt (nr, 1);
+          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           Matrix atmp = *this;
           double *tmp_data = atmp.fortran_vec ();
           if(anorm < 0.)
             anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
-          Array<double> z (4 * nc, 1);
+          Array<double> z (dim_vector (4 * nc, 1));
           double *pz = z.fortran_vec ();
-          Array<octave_idx_type> iz (nc, 1);
+          Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
 
           F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0) 
             {
@@ -2266,23 +2266,23 @@ Matrix::lssolve (const Matrix& b, octave
         }
       else
         retval = b;
 
       Matrix atmp = *this;
       double *tmp_data = atmp.fortran_vec ();
 
       double *pretval = retval.fortran_vec ();
-      Array<double> s (minmn, 1);
+      Array<double> s (dim_vector (minmn, 1));
       double *ps = s.fortran_vec ();
 
       // Ask DGELSD what the dimension of WORK should be.
       octave_idx_type lwork = -1;
 
-      Array<double> work (1, 1);
+      Array<double> work (dim_vector (1, 1));
 
       octave_idx_type smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("DGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
@@ -2304,17 +2304,17 @@ Matrix::lssolve (const Matrix& b, octave
 #endif
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
-      Array<octave_idx_type> iwork (liwork, 1);
+      Array<octave_idx_type> iwork (dim_vector (liwork, 1));
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
                                  ps, rcon, rank, work.fortran_vec (),
                                  lwork, piwork, info));
 
       // The workspace query is broken in at least LAPACK 3.0.0
       // through 3.1.1 when n >= mnthr.  The obtuse formula below
@@ -2464,23 +2464,23 @@ Matrix::lssolve (const ColumnVector& b, 
         }
       else
         retval = b;
 
       Matrix atmp = *this;
       double *tmp_data = atmp.fortran_vec ();
 
       double *pretval = retval.fortran_vec ();
-      Array<double> s (minmn, 1);
+      Array<double> s (dim_vector (minmn, 1));
       double *ps = s.fortran_vec ();
 
       // Ask DGELSD what the dimension of WORK should be.
       octave_idx_type lwork = -1;
 
-      Array<double> work (1, 1);
+      Array<double> work (dim_vector (1, 1));
 
       octave_idx_type smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("DGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
@@ -2495,17 +2495,17 @@ Matrix::lssolve (const ColumnVector& b, 
 #endif
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
-      Array<octave_idx_type> iwork (liwork, 1);
+      Array<octave_idx_type> iwork (dim_vector (liwork, 1));
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
                                  ps, rcon, rank, work.fortran_vec (),
                                  lwork, piwork, info));
 
       lwork = static_cast<octave_idx_type> (work(0));
       work.resize (lwork, 1);
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -39,23 +39,26 @@ public:
 
   typedef ColumnVector column_vector_type;
   typedef RowVector row_vector_type;
 
   typedef void (*solve_singularity_handler) (double rcon);
 
   Matrix (void) : MArray<double> () { }
 
-  Matrix (octave_idx_type r, octave_idx_type c) : MArray<double> (r, c) { }
+  Matrix (octave_idx_type r, octave_idx_type c)
+    : MArray<double> (dim_vector (r, c)) { }
 
-  Matrix (octave_idx_type r, octave_idx_type c, double val) : MArray<double> (r, c, val) { }
+  Matrix (octave_idx_type r, octave_idx_type c, double val)
+    : MArray<double> (dim_vector (r, c), val) { }
 
   Matrix (const dim_vector& dv) : MArray<double> (dv.redim (2)) { }
 
-  Matrix (const dim_vector& dv, double val) : MArray<double> (dv.redim (2), val) { }
+  Matrix (const dim_vector& dv, double val)
+    : MArray<double> (dv.redim (2), val) { }
 
   Matrix (const Matrix& a) : MArray<double> (a) { }
 
   template <class U>
   Matrix (const MArray<U>& a) : MArray<double> (a.as_matrix ()) { }
 
   template <class U>
   Matrix (const Array<U>& a) : MArray<double> (a.as_matrix ()) { }
diff --git a/liboctave/dRowVector.h b/liboctave/dRowVector.h
--- a/liboctave/dRowVector.h
+++ b/liboctave/dRowVector.h
@@ -28,27 +28,30 @@ along with Octave; see the file COPYING.
 #include "mx-defs.h"
 
 class
 OCTAVE_API
 RowVector : public MArray<double>
 {
 public:
 
-  RowVector (void) : MArray<double> (1, 0) { }
+  RowVector (void) : MArray<double> (dim_vector (1, 0)) { }
 
-  explicit RowVector (octave_idx_type n) : MArray<double> (1, n) { }
+  explicit RowVector (octave_idx_type n)
+    : MArray<double> (dim_vector (1, n)) { }
 
   explicit RowVector (const dim_vector& dv) : MArray<double> (dv.as_row ()) { }
 
-  RowVector (octave_idx_type n, double val) : MArray<double> (1, n, val) { }
+  RowVector (octave_idx_type n, double val)
+    : MArray<double> (dim_vector (1, n), val) { }
 
   RowVector (const RowVector& a) : MArray<double> (a) { }
 
   RowVector (const MArray<double>& a) : MArray<double> (a.as_row ()) { }
+
   RowVector (const Array<double>& a) : MArray<double> (a.as_row ()) { }
 
   RowVector& operator = (const RowVector& a)
     {
       MArray<double>::operator = (a);
       return *this;
     }
 
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -4030,17 +4030,17 @@ SparseMatrix::trisolve (MatrixType &matt
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == MatrixType::Tridiagonal ||
           typ == MatrixType::Tridiagonal_Hermitian)
         {
           OCTAVE_LOCAL_BUFFER (double, DU2, nr - 2);
           OCTAVE_LOCAL_BUFFER (double, DU, nr - 1);
           OCTAVE_LOCAL_BUFFER (double, D, nr);
           OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
-          Array<octave_idx_type> ipvt (nr, 1);
+          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
@@ -4329,17 +4329,17 @@ SparseMatrix::trisolve (MatrixType &matt
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == MatrixType::Tridiagonal ||
           typ == MatrixType::Tridiagonal_Hermitian)
         {
           OCTAVE_LOCAL_BUFFER (double, DU2, nr - 2);
           OCTAVE_LOCAL_BUFFER (double, DU, nr - 1);
           OCTAVE_LOCAL_BUFFER (double, D, nr);
           OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
-          Array<octave_idx_type> ipvt (nr, 1);
+          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
@@ -4544,19 +4544,19 @@ SparseMatrix::bsolve (MatrixType &mattyp
               typ = MatrixType::Banded;
               rcond = 0.0;
               err = 0;
             } 
           else 
             {
               if (calc_cond)
                 {
-                  Array<double> z (3 * nr, 1);
+                  Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nr, 1);
+                  Array<octave_idx_type> iz (dim_vector (nr, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dpbcon, DPBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nr, n_lower, tmp_data, ldm,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -4638,17 +4638,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   double atmp = 0.;
                   for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
                     atmp += fabs(data(i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          Array<octave_idx_type> ipvt (nr, 1);
+          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
                                      ldm, pipvt, err));
             
           // Throw-away extra info LAPACK gives so as to not 
           // change output.
           if (err != 0) 
@@ -4666,19 +4666,19 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   ("matrix singular to machine precision");
 
             } 
           else 
             {
               if (calc_cond)
                 {
                   char job = '1';
-                  Array<double> z (3 * nr, 1);
+                  Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nr, 1);
+                  Array<octave_idx_type> iz (dim_vector (nr, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dgbcon, DGBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nc, n_lower, n_upper, tmp_data, ldm, pipvt,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -4792,19 +4792,19 @@ SparseMatrix::bsolve (MatrixType &mattyp
               typ = MatrixType::Banded;
               rcond = 0.0;
               err = 0;
             } 
           else 
             {
               if (calc_cond)
                 {
-                  Array<double> z (3 * nr, 1);
+                  Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nr, 1);
+                  Array<octave_idx_type> iz (dim_vector (nr, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dpbcon, DPBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nr, n_lower, tmp_data, ldm,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -4921,17 +4921,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   double atmp = 0.;
                   for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
                     atmp += fabs(data(i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          Array<octave_idx_type> ipvt (nr, 1);
+          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
                                      ldm, pipvt, err));
             
           if (err != 0) 
             {
               err = -2;
@@ -4947,19 +4947,19 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   ("matrix singular to machine precision");
 
             } 
           else 
             {
               if (calc_cond)
                 {
                   char job = '1';
-                  Array<double> z (3 * nr, 1);
+                  Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nr, 1);
+                  Array<octave_idx_type> iz (dim_vector (nr, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dgbcon, DGBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nc, n_lower, n_upper, tmp_data, ldm, pipvt,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -5112,19 +5112,19 @@ SparseMatrix::bsolve (MatrixType &mattyp
               typ = MatrixType::Banded;
               rcond = 0.0;
               err = 0;
             } 
           else 
             {
               if (calc_cond)
                 {
-                  Array<double> z (3 * nr, 1);
+                  Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nr, 1);
+                  Array<octave_idx_type> iz (dim_vector (nr, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dpbcon, DPBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nr, n_lower, tmp_data, ldm,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -5237,17 +5237,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   double atmp = 0.;
                   for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
                     atmp += fabs(data(i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          Array<octave_idx_type> ipvt (nr, 1);
+          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
                                      ldm, pipvt, err));
             
           if (err != 0) 
             {
               err = -2;
@@ -5263,19 +5263,19 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   ("matrix singular to machine precision");
 
             } 
           else 
             {
               if (calc_cond)
                 {
                   char job = '1';
-                  Array<double> z (3 * nr, 1);
+                  Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nr, 1);
+                  Array<octave_idx_type> iz (dim_vector (nr, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dpbcon, DPBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nr, n_lower, tmp_data, ldm,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -5412,19 +5412,19 @@ SparseMatrix::bsolve (MatrixType &mattyp
 
               rcond = 0.0;
               err = 0;
             } 
           else 
             {
               if (calc_cond)
                 {
-                  Array<double> z (3 * nr, 1);
+                  Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nr, 1);
+                  Array<octave_idx_type> iz (dim_vector (nr, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dpbcon, DPBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nr, n_lower, tmp_data, ldm,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -5567,17 +5567,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   double atmp = 0.;
                   for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
                     atmp += fabs(data(i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          Array<octave_idx_type> ipvt (nr, 1);
+          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
                                      ldm, pipvt, err));
             
           if (err != 0) 
             {
               err = -2;
@@ -5593,19 +5593,19 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   ("matrix singular to machine precision");
 
             } 
           else 
             {
               if (calc_cond)
                 {
                   char job = '1';
-                  Array<double> z (3 * nr, 1);
+                  Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nr, 1);
+                  Array<octave_idx_type> iz (dim_vector (nr, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dgbcon, DGBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nc, n_lower, n_upper, tmp_data, ldm, pipvt,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
diff --git a/liboctave/dbleCHOL.cc b/liboctave/dbleCHOL.cc
--- a/liboctave/dbleCHOL.cc
+++ b/liboctave/dbleCHOL.cc
@@ -123,19 +123,19 @@ CHOL::init (const Matrix& a, bool calc_c
   xrcond = 0.0;
   if (info > 0)
     chol_mat.resize (info - 1, info - 1);
   else if (calc_cond) 
     {
       octave_idx_type dpocon_info = 0;
 
       // Now calculate the condition number for non-singular matrix.
-      Array<double> z (3*n, 1);
+      Array<double> z (dim_vector (3*n, 1));
       double *pz = z.fortran_vec ();
-      Array<octave_idx_type> iz (n, 1);
+      Array<octave_idx_type> iz (dim_vector (n, 1));
       octave_idx_type *piz = iz.fortran_vec ();
       F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
                                  n, anorm, xrcond, pz, piz, dpocon_info
                                  F77_CHAR_ARG_LEN (1)));
 
       if (dpocon_info != 0) 
         info = -1;
     }
@@ -416,17 +416,17 @@ CHOL::shift_sym (octave_idx_type i, octa
 
   octave_idx_type n = chol_mat.rows ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1) 
     (*current_liboctave_error_handler) ("cholshift: index out of range");
   else
     {
       Matrix a = chol_mat.transpose () * chol_mat;
-      Array<octave_idx_type> p (n, 1);
+      Array<octave_idx_type> p (dim_vector (n, 1));
       for (octave_idx_type k = 0; k < n; k++) p(k) = k;
       if (i < j)
         {
           for (octave_idx_type k = i; k < j; k++) p(k) = k+1;
           p(j) = i;
         }
       else if (j < i)
         {
diff --git a/liboctave/dbleHESS.cc b/liboctave/dbleHESS.cc
--- a/liboctave/dbleHESS.cc
+++ b/liboctave/dbleHESS.cc
@@ -79,27 +79,27 @@ HESS::init (const Matrix& a)
   octave_idx_type lwork = 32 * n;
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
 
   hess_mat = a;
   double *h = hess_mat.fortran_vec ();
 
-  Array<double> scale (n, 1);
+  Array<double> scale (dim_vector (n, 1));
   double *pscale = scale.fortran_vec ();
 
   F77_XFCN (dgebal, DGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
                              n, h, n, ilo, ihi, pscale, info
                              F77_CHAR_ARG_LEN (1)));
 
-  Array<double> tau (n-1, 1);
+  Array<double> tau (dim_vector (n-1, 1));
   double *ptau = tau.fortran_vec ();
 
-  Array<double> work (lwork, 1);
+  Array<double> work (dim_vector (lwork, 1));
   double *pwork = work.fortran_vec ();
 
   F77_XFCN (dgehrd, DGEHRD, (n, ilo, ihi, h, n, ptau, pwork,
                              lwork, info));
 
   unitary_hess_mat = hess_mat;
   double *z = unitary_hess_mat.fortran_vec ();
 
diff --git a/liboctave/dbleQRP.cc b/liboctave/dbleQRP.cc
--- a/liboctave/dbleQRP.cc
+++ b/liboctave/dbleQRP.cc
@@ -61,17 +61,17 @@ QRP::init (const Matrix& a, qr_type_t qr
   OCTAVE_LOCAL_BUFFER (double, tau, min_mn);
 
   octave_idx_type info = 0;
 
   Matrix afact = a;
   if (m > n && qr_type == qr_type_std)
     afact.resize (m, m);
 
-  MArray<octave_idx_type> jpvt (n, 1, 0);
+  MArray<octave_idx_type> jpvt (dim_vector (n, 1), 0);
 
   if (m > 0)
     {
       // workspace query.
       double rlwork;
       F77_XFCN (dgeqp3, DGEQP3, (m, n, afact.fortran_vec (), m, jpvt.fortran_vec (),
                                  tau, &rlwork, -1, info));
 
diff --git a/liboctave/dbleSCHUR.cc b/liboctave/dbleSCHUR.cc
--- a/liboctave/dbleSCHUR.cc
+++ b/liboctave/dbleSCHUR.cc
@@ -113,30 +113,31 @@ SCHUR::init (const Matrix& a, const std:
   schur_mat = a;
 
   if (calc_unitary)
     unitary_mat.clear (n, n);
 
   double *s = schur_mat.fortran_vec ();
   double *q = unitary_mat.fortran_vec ();
 
-  Array<double> wr (n, 1);
+  Array<double> wr (dim_vector (n, 1));
   double *pwr = wr.fortran_vec ();
 
-  Array<double> wi (n, 1);
+  Array<double> wi (dim_vector (n, 1));
   double *pwi = wi.fortran_vec ();
 
-  Array<double> work (lwork, 1);
+  Array<double> work (dim_vector (lwork, 1));
   double *pwork = work.fortran_vec ();
 
   // BWORK is not referenced for the non-ordered Schur routine.
-  Array<octave_idx_type> bwork ((ord_char == 'N' || ord_char == 'n') ? 0 : n, 1);
+  octave_idx_type ntmp = (ord_char == 'N' || ord_char == 'n') ? 0 : n;
+  Array<octave_idx_type> bwork (dim_vector (ntmp, 1));
   octave_idx_type *pbwork = bwork.fortran_vec ();
 
-  Array<octave_idx_type> iwork (liwork, 1);
+  Array<octave_idx_type> iwork (dim_vector (liwork, 1));
   octave_idx_type *piwork = iwork.fortran_vec ();
 
   F77_XFCN (dgeesx, DGEESX, (F77_CONST_CHAR_ARG2 (&jobvs, 1),
                              F77_CONST_CHAR_ARG2 (&sort, 1),
                              selector,
                              F77_CONST_CHAR_ARG2 (&sense, 1),
                              n, s, n, sdim, pwr, pwi, q, n, rconde, rcondv,
                              pwork, lwork, piwork, liwork, pbwork, info
diff --git a/liboctave/dbleSVD.cc b/liboctave/dbleSVD.cc
--- a/liboctave/dbleSVD.cc
+++ b/liboctave/dbleSVD.cc
@@ -141,17 +141,17 @@ SVD::init (const Matrix& a, SVD::type sv
     right_sm.resize (nrow_vt, n);
 
   double *vt = right_sm.fortran_vec ();
 
   // Ask DGESVD what the dimension of WORK should be.
 
   octave_idx_type lwork = -1;
 
-  Array<double> work (1, 1);
+  Array<double> work (dim_vector (1, 1));
 
   octave_idx_type one = 1;
   octave_idx_type m1 = std::max (m, one), nrow_vt1 = std::max (nrow_vt, one);
 
   if (svd_driver == SVD::GESVD)
     {
       F77_XFCN (dgesvd, DGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                                  F77_CONST_CHAR_ARG2 (&jobv, 1),
diff --git a/liboctave/eigs-base.cc b/liboctave/eigs-base.cc
--- a/liboctave/eigs-base.cc
+++ b/liboctave/eigs-base.cc
@@ -844,17 +844,17 @@ EigsRealSymmetricMatrix (const M& m, con
       if (permB.length() != n)
         {
           (*current_liboctave_error_handler) 
             ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
-          Array<bool> checked(n, 1, false);
+          Array<bool> checked (dim_vector (n, 1), false);
           for (octave_idx_type i = 0; i < n; i++)
             {
               octave_idx_type bidx = 
                 static_cast<octave_idx_type> (permB(i));
               if (checked(bidx) || bidx < 0 ||
                   bidx >= n || D_NINT (bidx) != bidx)
                 {
                   (*current_liboctave_error_handler) 
@@ -902,33 +902,33 @@ EigsRealSymmetricMatrix (const M& m, con
             {
               (*current_liboctave_error_handler) 
                 ("eigs: The matrix B is not positive definite");
               return -1;
             }
         }
     }
 
-  Array<octave_idx_type> ip (11, 1);
+  Array<octave_idx_type> ip (dim_vector (11, 1));
   octave_idx_type *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
   ip(3) = 1; // NB blocksize in recurrence
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
  
-  Array<octave_idx_type> iptr (14, 1);
+  Array<octave_idx_type> iptr (dim_vector (14, 1));
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   octave_idx_type lwork = p * (p + 8);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * p);
   OCTAVE_LOCAL_BUFFER (double, workl, lwork);
@@ -1005,17 +1005,17 @@ EigsRealSymmetricMatrix (const M& m, con
 
   // We have a problem in that the size of the C++ bool 
   // type relative to the fortran logical type. It appears 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
   // per bool, though this might be system dependent. As 
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to 
   // avoid problems.
-  Array<octave_idx_type> s (p, 1);
+  Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
 
   eig_vec.resize (n, k);
   double *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k);
   double *d = eig_val.fortran_vec ();
 
@@ -1167,17 +1167,17 @@ EigsRealSymmetricMatrixShift (const M& m
       // Check the we really have a permutation vector
       if (permB.length() != n)
         {
           (*current_liboctave_error_handler) ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
-          Array<bool> checked (n, 1, false);
+          Array<bool> checked (dim_vector (n, 1), false);
           for (octave_idx_type i = 0; i < n; i++)
             {
               octave_idx_type bidx = 
                 static_cast<octave_idx_type> (permB(i));
               if (checked(bidx) || bidx < 0 ||
                   bidx >= n || D_NINT (bidx) != bidx)
                 {
                   (*current_liboctave_error_handler) 
@@ -1187,33 +1187,33 @@ EigsRealSymmetricMatrixShift (const M& m
             }
         }
     }
 
   char bmat = 'I';
   if (have_b)
     bmat = 'G';
 
-  Array<octave_idx_type> ip (11, 1);
+  Array<octave_idx_type> ip (dim_vector (11, 1));
   octave_idx_type *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
   ip(3) = 1; // NB blocksize in recurrence
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
 
-  Array<octave_idx_type> iptr (14, 1);
+  Array<octave_idx_type> iptr (dim_vector (14, 1));
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   M L, U;
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows() : m.rows()));
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols() : m.cols()));
@@ -1342,17 +1342,17 @@ EigsRealSymmetricMatrixShift (const M& m
 
   // We have a problem in that the size of the C++ bool 
   // type relative to the fortran logical type. It appears 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
   // per bool, though this might be system dependent. As 
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to 
   // avoid problems.
-  Array<octave_idx_type> s (p, 1);
+  Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
                         
   eig_vec.resize (n, k);
   double *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k);
   double *d = eig_val.fortran_vec ();
 
@@ -1496,33 +1496,33 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
   else if (! std::abs (sigma))
     typ = "SM";
   else
     {
       typ = "LM";
       mode = 3;
     }
 
-  Array<octave_idx_type> ip (11, 1);
+  Array<octave_idx_type> ip (dim_vector (11, 1));
   octave_idx_type *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
   ip(3) = 1; // NB blocksize in recurrence
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
  
-  Array<octave_idx_type> iptr (14, 1);
+  Array<octave_idx_type> iptr (dim_vector (14, 1));
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   octave_idx_type lwork = p * (p + 8);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * p);
   OCTAVE_LOCAL_BUFFER (double, workl, lwork);
@@ -1600,17 +1600,17 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
 
   // We have a problem in that the size of the C++ bool 
   // type relative to the fortran logical type. It appears 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
   // per bool, though this might be system dependent. As 
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to 
   // avoid problems.
-  Array<octave_idx_type> s (p, 1);
+  Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
                         
   eig_vec.resize (n, k);
   double *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k);
   double *d = eig_val.fortran_vec ();
 
@@ -1758,17 +1758,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
       if (permB.length() != n)
         {
           (*current_liboctave_error_handler) 
             ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
-          Array<bool> checked (n, 1, false);
+          Array<bool> checked (dim_vector (n, 1), false);
           for (octave_idx_type i = 0; i < n; i++)
             {
               octave_idx_type bidx = 
                 static_cast<octave_idx_type> (permB(i));
               if (checked(bidx) || bidx < 0 ||
                   bidx >= n || D_NINT (bidx) != bidx)
                 {
                   (*current_liboctave_error_handler) 
@@ -1816,33 +1816,33 @@ EigsRealNonSymmetricMatrix (const M& m, 
             {
               (*current_liboctave_error_handler) 
                 ("eigs: The matrix B is not positive definite");
               return -1;
             }
         }
     }
 
-  Array<octave_idx_type> ip (11, 1);
+  Array<octave_idx_type> ip (dim_vector (11, 1));
   octave_idx_type *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
   ip(3) = 1; // NB blocksize in recurrence
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
  
-  Array<octave_idx_type> iptr (14, 1);
+  Array<octave_idx_type> iptr (dim_vector (14, 1));
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   octave_idx_type lwork = 3 * p * (p + 2);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * (p + 1));
   OCTAVE_LOCAL_BUFFER (double, workl, lwork + 1);
@@ -1919,17 +1919,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
 
   // We have a problem in that the size of the C++ bool 
   // type relative to the fortran logical type. It appears 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
   // per bool, though this might be system dependent. As 
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to 
   // avoid problems.
-  Array<octave_idx_type> s (p, 1);
+  Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
 
   Matrix eig_vec2 (n, k + 1);
   double *z = eig_vec2.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (double, dr, k + 1);
   OCTAVE_LOCAL_BUFFER (double, di, k + 1);
   OCTAVE_LOCAL_BUFFER (double, workev, 3 * p);
@@ -2123,17 +2123,17 @@ EigsRealNonSymmetricMatrixShift (const M
       // Check that we really have a permutation vector
       if (permB.length() != n)
         {
           (*current_liboctave_error_handler) ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
-          Array<bool> checked (n, 1, false);
+          Array<bool> checked (dim_vector (n, 1), false);
           for (octave_idx_type i = 0; i < n; i++)
             {
               octave_idx_type bidx = 
                 static_cast<octave_idx_type> (permB(i));
               if (checked(bidx) || bidx < 0 ||
                   bidx >= n || D_NINT (bidx) != bidx)
                 {
                   (*current_liboctave_error_handler) 
@@ -2143,33 +2143,33 @@ EigsRealNonSymmetricMatrixShift (const M
             }
         }
     }
 
   char bmat = 'I';
   if (have_b)
     bmat = 'G';
 
-  Array<octave_idx_type> ip (11, 1);
+  Array<octave_idx_type> ip (dim_vector (11, 1));
   octave_idx_type *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
   ip(3) = 1; // NB blocksize in recurrence
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
 
-  Array<octave_idx_type> iptr (14, 1);
+  Array<octave_idx_type> iptr (dim_vector (14, 1));
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   M L, U;
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows() : m.rows()));
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols() : m.cols()));
@@ -2298,17 +2298,17 @@ EigsRealNonSymmetricMatrixShift (const M
 
   // We have a problem in that the size of the C++ bool 
   // type relative to the fortran logical type. It appears 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
   // per bool, though this might be system dependent. As 
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to 
   // avoid problems.
-  Array<octave_idx_type> s (p, 1);
+  Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
                         
   Matrix eig_vec2 (n, k + 1);
   double *z = eig_vec2.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (double, dr, k + 1);
   OCTAVE_LOCAL_BUFFER (double, di, k + 1);
   OCTAVE_LOCAL_BUFFER (double, workev, 3 * p);
@@ -2500,33 +2500,33 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
   else if (! std::abs (sigmar))
     typ = "SM";
   else
     {
       typ = "LM";
       mode = 3;
     }
 
-  Array<octave_idx_type> ip (11, 1);
+  Array<octave_idx_type> ip (dim_vector (11, 1));
   octave_idx_type *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
   ip(3) = 1; // NB blocksize in recurrence
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
  
-  Array<octave_idx_type> iptr (14, 1);
+  Array<octave_idx_type> iptr (dim_vector (14, 1));
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   octave_idx_type lwork = 3 * p * (p + 2);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * (p + 1));
   OCTAVE_LOCAL_BUFFER (double, workl, lwork + 1);
@@ -2603,17 +2603,17 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
 
   // We have a problem in that the size of the C++ bool 
   // type relative to the fortran logical type. It appears 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
   // per bool, though this might be system dependent. As 
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to 
   // avoid problems.
-  Array<octave_idx_type> s (p, 1);
+  Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
 
   Matrix eig_vec2 (n, k + 1);
   double *z = eig_vec2.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (double, dr, k + 1);
   OCTAVE_LOCAL_BUFFER (double, di, k + 1);
   OCTAVE_LOCAL_BUFFER (double, workev, 3 * p);
@@ -2805,17 +2805,17 @@ EigsComplexNonSymmetricMatrix (const M& 
       if (permB.length() != n)
         {
           (*current_liboctave_error_handler) 
             ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
-          Array<bool> checked (n, 1, false);
+          Array<bool> checked (dim_vector (n, 1), false);
           for (octave_idx_type i = 0; i < n; i++)
             {
               octave_idx_type bidx = 
                 static_cast<octave_idx_type> (permB(i));
               if (checked(bidx) || bidx < 0 ||
                   bidx >= n || D_NINT (bidx) != bidx)
                 {
                   (*current_liboctave_error_handler) 
@@ -2863,33 +2863,33 @@ EigsComplexNonSymmetricMatrix (const M& 
             {
               (*current_liboctave_error_handler) 
                 ("eigs: The matrix B is not positive definite");
               return -1;
             }
         }
     }
 
-  Array<octave_idx_type> ip (11, 1);
+  Array<octave_idx_type> ip (dim_vector (11, 1));
   octave_idx_type *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
   ip(3) = 1; // NB blocksize in recurrence
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
  
-  Array<octave_idx_type> iptr (14, 1);
+  Array<octave_idx_type> iptr (dim_vector (14, 1));
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   octave_idx_type lwork = p * (3 * p + 5);
               
   OCTAVE_LOCAL_BUFFER (Complex, v, n * p);
   OCTAVE_LOCAL_BUFFER (Complex, workl, lwork);
@@ -2966,17 +2966,17 @@ EigsComplexNonSymmetricMatrix (const M& 
 
   // We have a problem in that the size of the C++ bool 
   // type relative to the fortran logical type. It appears 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
   // per bool, though this might be system dependent. As 
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to 
   // avoid problems.
-  Array<octave_idx_type> s (p, 1);
+  Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
 
   eig_vec.resize (n, k);
   Complex *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k+1);
   Complex *d = eig_val.fortran_vec ();
 
@@ -3129,17 +3129,17 @@ EigsComplexNonSymmetricMatrixShift (cons
       // Check that we really have a permutation vector
       if (permB.length() != n)
         {
           (*current_liboctave_error_handler) ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
-          Array<bool> checked (n, 1, false);
+          Array<bool> checked (dim_vector (n, 1), false);
           for (octave_idx_type i = 0; i < n; i++)
             {
               octave_idx_type bidx = 
                 static_cast<octave_idx_type> (permB(i));
               if (checked(bidx) || bidx < 0 ||
                   bidx >= n || D_NINT (bidx) != bidx)
                 {
                   (*current_liboctave_error_handler) 
@@ -3149,33 +3149,33 @@ EigsComplexNonSymmetricMatrixShift (cons
             }
         }
     }
 
   char bmat = 'I';
   if (have_b)
     bmat = 'G';
 
-  Array<octave_idx_type> ip (11, 1);
+  Array<octave_idx_type> ip (dim_vector (11, 1));
   octave_idx_type *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
   ip(3) = 1; // NB blocksize in recurrence
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
 
-  Array<octave_idx_type> iptr (14, 1);
+  Array<octave_idx_type> iptr (dim_vector (14, 1));
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   M L, U;
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows() : m.rows()));
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols() : m.cols()));
@@ -3306,17 +3306,17 @@ EigsComplexNonSymmetricMatrixShift (cons
 
   // We have a problem in that the size of the C++ bool 
   // type relative to the fortran logical type. It appears 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
   // per bool, though this might be system dependent. As 
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to 
   // avoid problems.
-  Array<octave_idx_type> s (p, 1);
+  Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
 
   eig_vec.resize (n, k);
   Complex *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k+1);
   Complex *d = eig_val.fortran_vec ();
 
@@ -3466,33 +3466,33 @@ EigsComplexNonSymmetricFunc (EigsComplex
   else if (! std::abs (sigma))
     typ = "SM";
   else
     {
       typ = "LM";
       mode = 3;
     }
 
-  Array<octave_idx_type> ip (11, 1);
+  Array<octave_idx_type> ip (dim_vector (11, 1));
   octave_idx_type *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
   ip(3) = 1; // NB blocksize in recurrence
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
  
-  Array<octave_idx_type> iptr (14, 1);
+  Array<octave_idx_type> iptr (dim_vector (14, 1));
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   octave_idx_type lwork = p * (3 * p + 5);
               
   OCTAVE_LOCAL_BUFFER (Complex, v, n * p);
   OCTAVE_LOCAL_BUFFER (Complex, workl, lwork);
@@ -3570,17 +3570,17 @@ EigsComplexNonSymmetricFunc (EigsComplex
 
   // We have a problem in that the size of the C++ bool 
   // type relative to the fortran logical type. It appears 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
   // per bool, though this might be system dependent. As 
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to 
   // avoid problems.
-  Array<octave_idx_type> s (p, 1);
+  Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
 
   eig_vec.resize (n, k);
   Complex *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k+1);
   Complex *d = eig_val.fortran_vec ();
 
diff --git a/liboctave/fCColVector.h b/liboctave/fCColVector.h
--- a/liboctave/fCColVector.h
+++ b/liboctave/fCColVector.h
@@ -32,30 +32,36 @@ class
 OCTAVE_API
 FloatComplexColumnVector : public MArray<FloatComplex>
 {
 friend class FloatComplexMatrix;
 friend class FloatComplexRowVector;
 
 public:
 
-  FloatComplexColumnVector (void) : MArray<FloatComplex> (0, 1) { }
+ FloatComplexColumnVector (void)
+   : MArray<FloatComplex> (dim_vector (0, 1)) { }
 
-  explicit FloatComplexColumnVector (octave_idx_type n) : MArray<FloatComplex> (n, 1) { }
+  explicit FloatComplexColumnVector (octave_idx_type n)
+    : MArray<FloatComplex> (dim_vector (n, 1)) { }
 
   explicit FloatComplexColumnVector (const dim_vector& dv) 
     : MArray<FloatComplex> (dv.as_column ()) { }
 
   FloatComplexColumnVector (octave_idx_type n, const FloatComplex& val)
-    : MArray<FloatComplex> (n, 1, val) { }
+    : MArray<FloatComplex> (dim_vector (n, 1), val) { }
+
+  FloatComplexColumnVector (const FloatComplexColumnVector& a)
+    : MArray<FloatComplex> (a) { }
 
-  FloatComplexColumnVector (const FloatComplexColumnVector& a) : MArray<FloatComplex> (a) { }
+  FloatComplexColumnVector (const MArray<FloatComplex>& a)
+    : MArray<FloatComplex> (a.as_column ()) { }
 
-  FloatComplexColumnVector (const MArray<FloatComplex>& a) : MArray<FloatComplex> (a.as_column ()) { }
-  FloatComplexColumnVector (const Array<FloatComplex>& a) : MArray<FloatComplex> (a.as_column ()) { }
+  FloatComplexColumnVector (const Array<FloatComplex>& a)
+    : MArray<FloatComplex> (a.as_column ()) { }
 
   explicit FloatComplexColumnVector (const FloatColumnVector& a);
 
   FloatComplexColumnVector& operator = (const FloatComplexColumnVector& a)
     {
       MArray<FloatComplex>::operator = (a);
       return *this;
     }
diff --git a/liboctave/fCMatrix.cc b/liboctave/fCMatrix.cc
--- a/liboctave/fCMatrix.cc
+++ b/liboctave/fCMatrix.cc
@@ -273,57 +273,58 @@ FloatComplexMatrix::FloatComplexMatrix (
 }
 
 FloatComplexMatrix::FloatComplexMatrix (const FloatColumnVector& cv)
   : MArray<FloatComplex> (cv)
 {
 }
 
 FloatComplexMatrix::FloatComplexMatrix (const FloatDiagMatrix& a)
-  : MArray<FloatComplex> (a.rows (), a.cols (), 0.0)
+  : MArray<FloatComplex> (a.dims (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
 FloatComplexMatrix::FloatComplexMatrix (const FloatComplexRowVector& rv)
   : MArray<FloatComplex> (rv)
 {
 }
 
 FloatComplexMatrix::FloatComplexMatrix (const FloatComplexColumnVector& cv)
   : MArray<FloatComplex> (cv)
 {
 }
 
 FloatComplexMatrix::FloatComplexMatrix (const FloatComplexDiagMatrix& a)
-  : MArray<FloatComplex> (a.rows (), a.cols (), 0.0)
+  : MArray<FloatComplex> (a.dims (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
 // FIXME -- could we use a templated mixed-type copy function
 // here?
 
 FloatComplexMatrix::FloatComplexMatrix (const boolMatrix& a)
   : MArray<FloatComplex> (a)
 {
 }
 
 FloatComplexMatrix::FloatComplexMatrix (const charMatrix& a)
-  : MArray<FloatComplex> (a.rows (), a.cols (), 0.0)
+  : MArray<FloatComplex> (a.dims (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     for (octave_idx_type j = 0; j < a.cols (); j++)
       elem (i, j) = static_cast<unsigned char> (a.elem (i, j));
 }
 
-FloatComplexMatrix::FloatComplexMatrix (const FloatMatrix& re, const FloatMatrix& im)
-  : MArray<FloatComplex> (re.rows (), re.cols ())
+FloatComplexMatrix::FloatComplexMatrix (const FloatMatrix& re,
+                                        const FloatMatrix& im)
+  : MArray<FloatComplex> (re.dims ())
 {
   if (im.rows () != rows () || im.cols () != cols ())
     (*current_liboctave_error_handler) ("complex: internal error");
 
   octave_idx_type nel = numel ();
   for (octave_idx_type i = 0; i < nel; i++)
     xelem (i) = FloatComplex (re(i), im(i));
 }
@@ -1061,23 +1062,23 @@ FloatComplexMatrix::finverse (MatrixType
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
   else
     {
-      Array<octave_idx_type> ipvt (nr, 1);
+      Array<octave_idx_type> ipvt (dim_vector (nr, 1));
       octave_idx_type *pipvt = ipvt.fortran_vec ();
 
       retval = *this;
       FloatComplex *tmp_data = retval.fortran_vec ();
 
-      Array<FloatComplex> z(1, 1);
+      Array<FloatComplex> z (dim_vector (1, 1));
       octave_idx_type lwork = -1;
 
       // Query the optimum work array size.
 
       F77_XFCN (cgetri, CGETRI, (nc, tmp_data, nr, pipvt, 
                                  z.fortran_vec (), lwork, info));
 
       lwork = static_cast<octave_idx_type> (std::real(z(0)));
@@ -1098,17 +1099,17 @@ FloatComplexMatrix::finverse (MatrixType
       rcon = 0.0;
       if (info != 0) 
         info = -1;
       else if (calc_cond) 
         {
           // Now calculate the condition number for non-singular matrix.
           octave_idx_type zgecon_info = 0;
           char job = '1';
-          Array<float> rz (2 * nc, 1);
+          Array<float> rz (dim_vector (2 * nc, 1));
           float *prz = rz.fortran_vec ();
           F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nc, tmp_data, nr, anorm, 
                                      rcon, pz, prz, zgecon_info
                                      F77_CHAR_ARG_LEN (1)));
 
           if (zgecon_info != 0) 
             info = -1;
@@ -1334,17 +1335,17 @@ FloatComplexMatrix::fourier (void) const
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<FloatComplex> wsave (nn, 1);
+  Array<FloatComplex> wsave (dim_vector (nn, 1));
   FloatComplex *pwsave = wsave.fortran_vec ();
 
   retval = *this;
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1375,17 +1376,17 @@ FloatComplexMatrix::ifourier (void) cons
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<FloatComplex> wsave (nn, 1);
+  Array<FloatComplex> wsave (dim_vector (nn, 1));
   FloatComplex *pwsave = wsave.fortran_vec ();
 
   retval = *this;
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1419,17 +1420,17 @@ FloatComplexMatrix::fourier2d (void) con
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<FloatComplex> wsave (nn, 1);
+  Array<FloatComplex> wsave (dim_vector (nn, 1));
   FloatComplex *pwsave = wsave.fortran_vec ();
 
   retval = *this;
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1441,17 +1442,17 @@ FloatComplexMatrix::fourier2d (void) con
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
   wsave.resize (nn, 1);
   pwsave = wsave.fortran_vec ();
 
-  Array<FloatComplex> tmp (npts, 1);
+  Array<FloatComplex> tmp (dim_vector (npts, 1));
   FloatComplex *prow = tmp.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
@@ -1485,17 +1486,17 @@ FloatComplexMatrix::ifourier2d (void) co
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<FloatComplex> wsave (nn, 1);
+  Array<FloatComplex> wsave (dim_vector (nn, 1));
   FloatComplex *pwsave = wsave.fortran_vec ();
 
   retval = *this;
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1510,17 +1511,17 @@ FloatComplexMatrix::ifourier2d (void) co
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
   wsave.resize (nn, 1);
   pwsave = wsave.fortran_vec ();
 
-  Array<FloatComplex> tmp (npts, 1);
+  Array<FloatComplex> tmp (dim_vector (npts, 1));
   FloatComplex *prow = tmp.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
@@ -1607,19 +1608,19 @@ FloatComplexMatrix::determinant (MatrixT
           if (info != 0) 
             {
               rcon = 0.0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else 
             {
-              Array<FloatComplex> z (2 * nc, 1);
+              Array<FloatComplex> z (dim_vector (2 * nc, 1));
               FloatComplex *pz = z.fortran_vec ();
-              Array<float> rz (nc, 1);
+              Array<float> rz (dim_vector (nc, 1));
               float *prz = rz.fortran_vec ();
 
               F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                          nr, tmp_data, nr, anorm,
                                          rcon, pz, prz, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0) 
@@ -1631,17 +1632,17 @@ FloatComplexMatrix::determinant (MatrixT
               retval = retval.square ();
             }
         }
       else if (typ != MatrixType::Full)
         (*current_liboctave_error_handler) ("det: invalid dense matrix type");
 
       if (typ == MatrixType::Full)
         {
-          Array<octave_idx_type> ipvt (nr, 1);
+          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           FloatComplexMatrix atmp = *this;
           FloatComplex *tmp_data = atmp.fortran_vec ();
 
           info = 0;
 
           // Calculate the norm of the matrix, for later use.
@@ -1658,19 +1659,19 @@ FloatComplexMatrix::determinant (MatrixT
               retval = FloatComplexDET ();
             } 
           else 
             {
               if (calc_cond) 
                 {
                   // Now calc the condition number for non-singular matrix.
                   char job = '1';
-                  Array<FloatComplex> z (2 * nc, 1);
+                  Array<FloatComplex> z (dim_vector (2 * nc, 1));
                   FloatComplex *pz = z.fortran_vec ();
-                  Array<float> rz (2 * nc, 1);
+                  Array<float> rz (dim_vector (2 * nc, 1));
                   float *prz = rz.fortran_vec ();
 
                   F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nc, tmp_data, nr, anorm, 
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
                 }
 
@@ -1723,19 +1724,19 @@ FloatComplexMatrix::rcond (MatrixType &m
       if (typ == MatrixType::Upper)
         {
           const FloatComplex *tmp_data = fortran_vec ();
           octave_idx_type info = 0;
           char norm = '1';
           char uplo = 'U';
           char dia = 'N';
 
-          Array<FloatComplex> z (2 * nc, 1);
+          Array<FloatComplex> z (dim_vector (2 * nc, 1));
           FloatComplex *pz = z.fortran_vec ();
-          Array<float> rz (nc, 1);
+          Array<float> rz (dim_vector (nc, 1));
           float *prz = rz.fortran_vec ();
 
           F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                      F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                      F77_CONST_CHAR_ARG2 (&dia, 1), 
                                      nr, tmp_data, nr, rcon,
                                      pz, prz, info
                                      F77_CHAR_ARG_LEN (1)
@@ -1751,19 +1752,19 @@ FloatComplexMatrix::rcond (MatrixType &m
       else if (typ == MatrixType::Lower)
         {
           const FloatComplex *tmp_data = fortran_vec ();
           octave_idx_type info = 0;
           char norm = '1';
           char uplo = 'L';
           char dia = 'N';
 
-          Array<FloatComplex> z (2 * nc, 1);
+          Array<FloatComplex> z (dim_vector (2 * nc, 1));
           FloatComplex *pz = z.fortran_vec ();
-          Array<float> rz (nc, 1);
+          Array<float> rz (dim_vector (nc, 1));
           float *prz = rz.fortran_vec ();
 
           F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                      F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                      F77_CONST_CHAR_ARG2 (&dia, 1), 
                                      nr, tmp_data, nr, rcon,
                                      pz, prz, info
                                      F77_CHAR_ARG_LEN (1)
@@ -1797,19 +1798,19 @@ FloatComplexMatrix::rcond (MatrixType &m
                 {
                   rcon = 0.0;
 
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
               else 
                 {
-                  Array<FloatComplex> z (2 * nc, 1);
+                  Array<FloatComplex> z (dim_vector (2 * nc, 1));
                   FloatComplex *pz = z.fortran_vec ();
-                  Array<float> rz (nc, 1);
+                  Array<float> rz (dim_vector (nc, 1));
                   float *prz = rz.fortran_vec ();
 
                   F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0) 
@@ -1817,26 +1818,26 @@ FloatComplexMatrix::rcond (MatrixType &m
                 }
             }
 
 
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
-              Array<octave_idx_type> ipvt (nr, 1);
+              Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
               if(anorm < 0.)
                 anorm = atmp.abs().sum().
                   row(static_cast<octave_idx_type>(0)).max();
 
-              Array<FloatComplex> z (2 * nc, 1);
+              Array<FloatComplex> z (dim_vector (2 * nc, 1));
               FloatComplex *pz = z.fortran_vec ();
-              Array<float> rz (2 * nc, 1);
+              Array<float> rz (dim_vector (2 * nc, 1));
               float *prz = rz.fortran_vec ();
 
               F77_XFCN (cgetrf, CGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
               if (info != 0) 
                 { 
                   rcon = 0.0;
                   mattype.mark_as_rectangular ();
@@ -1898,19 +1899,19 @@ FloatComplexMatrix::utsolve (MatrixType 
               const FloatComplex *tmp_data = fortran_vec ();
 
               if (calc_cond)
                 {
                   char norm = '1';
                   char uplo = 'U';
                   char dia = 'N';
 
-                  Array<FloatComplex> z (2 * nc, 1);
+                  Array<FloatComplex> z (dim_vector (2 * nc, 1));
                   FloatComplex *pz = z.fortran_vec ();
-                  Array<float> rz (nc, 1);
+                  Array<float> rz (dim_vector (nc, 1));
                   float *prz = rz.fortran_vec ();
 
                   F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                              F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                              F77_CONST_CHAR_ARG2 (&dia, 1), 
                                              nr, tmp_data, nr, rcon,
                                              pz, prz, info
                                              F77_CHAR_ARG_LEN (1)
@@ -1999,19 +2000,19 @@ FloatComplexMatrix::ltsolve (MatrixType 
               const FloatComplex *tmp_data = fortran_vec ();
 
               if (calc_cond)
                 {
                   char norm = '1';
                   char uplo = 'L';
                   char dia = 'N';
 
-                  Array<FloatComplex> z (2 * nc, 1);
+                  Array<FloatComplex> z (dim_vector (2 * nc, 1));
                   FloatComplex *pz = z.fortran_vec ();
-                  Array<float> rz (nc, 1);
+                  Array<float> rz (dim_vector (nc, 1));
                   float *prz = rz.fortran_vec ();
 
                   F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                              F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                              F77_CONST_CHAR_ARG2 (&dia, 1), 
                                              nr, tmp_data, nr, rcon,
                                              pz, prz, info
                                              F77_CHAR_ARG_LEN (1)
@@ -2107,19 +2108,19 @@ FloatComplexMatrix::fsolve (MatrixType &
 
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else 
             {
               if (calc_cond)
                 {
-                  Array<FloatComplex> z (2 * nc, 1);
+                  Array<FloatComplex> z (dim_vector (2 * nc, 1));
                   FloatComplex *pz = z.fortran_vec ();
-                  Array<float> rz (nc, 1);
+                  Array<float> rz (dim_vector (nc, 1));
                   float *prz = rz.fortran_vec ();
 
                   F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0) 
@@ -2159,25 +2160,25 @@ FloatComplexMatrix::fsolve (MatrixType &
                 }
             }
         }
 
       if (typ == MatrixType::Full)
         {
           info = 0;
 
-          Array<octave_idx_type> ipvt (nr, 1);
+          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           FloatComplexMatrix atmp = *this;
           FloatComplex *tmp_data = atmp.fortran_vec ();
 
-          Array<FloatComplex> z (2 * nc, 1);
+          Array<FloatComplex> z (dim_vector (2 * nc, 1));
           FloatComplex *pz = z.fortran_vec ();
-          Array<float> rz (2 * nc, 1);
+          Array<float> rz (dim_vector (2 * nc, 1));
           float *prz = rz.fortran_vec ();
 
           // Calculate the norm of the matrix, for later use.
           if (anorm < 0.)
             anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
           F77_XFCN (cgetrf, CGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
@@ -2614,23 +2615,23 @@ FloatComplexMatrix::lssolve (const Float
         }
       else
         retval = b;
 
       FloatComplexMatrix atmp = *this;
       FloatComplex *tmp_data = atmp.fortran_vec ();
 
       FloatComplex *pretval = retval.fortran_vec ();
-      Array<float> s (minmn, 1);
+      Array<float> s (dim_vector (minmn, 1));
       float *ps = s.fortran_vec ();
 
       // Ask ZGELSD what the dimension of WORK should be.
       octave_idx_type lwork = -1;
 
-      Array<FloatComplex> work (1, 1);
+      Array<FloatComplex> work (dim_vector (1, 1));
 
       octave_idx_type smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("CGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
@@ -2655,23 +2656,23 @@ FloatComplexMatrix::lssolve (const Float
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
         + 3*smlsiz*nrhs + std::max ((smlsiz+1)*(smlsiz+1),
                                     n*(1+nrhs) + 2*nrhs);
       if (lrwork < 1)
         lrwork = 1;
-      Array<float> rwork (lrwork, 1);
+      Array<float> rwork (dim_vector (lrwork, 1));
       float *prwork = rwork.fortran_vec ();
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
-      Array<octave_idx_type> iwork (liwork, 1);
+      Array<octave_idx_type> iwork (dim_vector (liwork, 1));
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
                                  ps, rcon, rank, work.fortran_vec (),
                                  lwork, prwork, piwork, info));
 
       // The workspace query is broken in at least LAPACK 3.0.0
       // through 3.1.1 when n >= mnthr.  The obtuse formula below
@@ -2811,23 +2812,23 @@ FloatComplexMatrix::lssolve (const Float
         }
       else
         retval = b;
 
       FloatComplexMatrix atmp = *this;
       FloatComplex *tmp_data = atmp.fortran_vec ();
 
       FloatComplex *pretval = retval.fortran_vec ();
-      Array<float> s (minmn, 1);
+      Array<float> s (dim_vector (minmn, 1));
       float *ps = s.fortran_vec ();
 
       // Ask ZGELSD what the dimension of WORK should be.
       octave_idx_type lwork = -1;
 
-      Array<FloatComplex> work (1, 1);
+      Array<FloatComplex> work (dim_vector (1, 1));
 
       octave_idx_type smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("CGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
@@ -2844,23 +2845,23 @@ FloatComplexMatrix::lssolve (const Float
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
         + 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
       if (lrwork < 1)
         lrwork = 1;
-      Array<float> rwork (lrwork, 1);
+      Array<float> rwork (dim_vector (lrwork, 1));
       float *prwork = rwork.fortran_vec ();
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
-      Array<octave_idx_type> iwork (liwork, 1);
+      Array<octave_idx_type> iwork (dim_vector (liwork, 1));
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
                                  ps, rcon, rank, work.fortran_vec (),
                                  lwork, prwork, piwork, info));
 
       lwork = static_cast<octave_idx_type> (std::real (work(0)));
       work.resize (lwork, 1);
diff --git a/liboctave/fCMatrix.h b/liboctave/fCMatrix.h
--- a/liboctave/fCMatrix.h
+++ b/liboctave/fCMatrix.h
@@ -40,33 +40,39 @@ public:
  
   typedef FloatComplexColumnVector column_vector_type;
   typedef FloatComplexRowVector row_vector_type;
 
   typedef void (*solve_singularity_handler) (float rcon);
 
   FloatComplexMatrix (void) : MArray<FloatComplex> () { }
 
-  FloatComplexMatrix (octave_idx_type r, octave_idx_type c) : MArray<FloatComplex> (r, c) { }
+  FloatComplexMatrix (octave_idx_type r, octave_idx_type c)
+    : MArray<FloatComplex> (dim_vector (r, c)) { }
 
-  FloatComplexMatrix (octave_idx_type r, octave_idx_type c, const FloatComplex& val)
-    : MArray<FloatComplex> (r, c, val) { }
+  FloatComplexMatrix (octave_idx_type r, octave_idx_type c,
+                      const FloatComplex& val)
+    : MArray<FloatComplex> (dim_vector (r, c), val) { }
 
-  FloatComplexMatrix (const dim_vector& dv) : MArray<FloatComplex> (dv.redim (2)) { }
+  FloatComplexMatrix (const dim_vector& dv)
+    : MArray<FloatComplex> (dv.redim (2)) { }
 
   FloatComplexMatrix (const dim_vector& dv, const FloatComplex& val) 
     : MArray<FloatComplex> (dv.redim (2), val) { }
 
-  FloatComplexMatrix (const FloatComplexMatrix& a) : MArray<FloatComplex> (a) { }
+  FloatComplexMatrix (const FloatComplexMatrix& a)
+    : MArray<FloatComplex> (a) { }
 
   template <class U>
-  FloatComplexMatrix (const MArray<U>& a) : MArray<FloatComplex> (a.as_matrix ()) { }
+  FloatComplexMatrix (const MArray<U>& a)
+    : MArray<FloatComplex> (a.as_matrix ()) { }
 
   template <class U>
-  FloatComplexMatrix (const Array<U>& a) : MArray<FloatComplex> (a.as_matrix ()) { }
+  FloatComplexMatrix (const Array<U>& a)
+    : MArray<FloatComplex> (a.as_matrix ()) { }
 
   explicit FloatComplexMatrix (const FloatMatrix& a);
 
   explicit FloatComplexMatrix (const FloatRowVector& rv);
 
   explicit FloatComplexMatrix (const FloatColumnVector& cv);
 
   explicit FloatComplexMatrix (const FloatDiagMatrix& a);
diff --git a/liboctave/fCNDArray.cc b/liboctave/fCNDArray.cc
--- a/liboctave/fCNDArray.cc
+++ b/liboctave/fCNDArray.cc
@@ -764,17 +764,17 @@ FloatComplexNDArray&
 FloatComplexNDArray::insert (const NDArray& a, octave_idx_type r, octave_idx_type c)
 {
   dim_vector a_dv = a.dims ();
   
   int n = a_dv.length ();
   
   if (n == dimensions.length ())
     {
-      Array<octave_idx_type> a_ra_idx (a_dv.length (), 1, 0);
+      Array<octave_idx_type> a_ra_idx (dim_vector (a_dv.length (), 1), 0);
       
       a_ra_idx.elem (0) = r;
       a_ra_idx.elem (1) = c;
       
       for (int i = 0; i < n; i++)
         {
           if (a_ra_idx (i) < 0 || (a_ra_idx (i) + a_dv (i)) > dimensions (i))
             {
diff --git a/liboctave/fCRowVector.h b/liboctave/fCRowVector.h
--- a/liboctave/fCRowVector.h
+++ b/liboctave/fCRowVector.h
@@ -31,31 +31,39 @@ along with Octave; see the file COPYING.
 class
 OCTAVE_API
 FloatComplexRowVector : public MArray<FloatComplex>
 {
 friend class FloatComplexColumnVector;
 
 public:
 
-  FloatComplexRowVector (void) : MArray<FloatComplex> (1, 0) { }
+  FloatComplexRowVector (void)
+    : MArray<FloatComplex> (dim_vector (1, 0)) { }
 
-  explicit FloatComplexRowVector (octave_idx_type n) : MArray<FloatComplex> (1, n) { }
+  explicit FloatComplexRowVector (octave_idx_type n)
+    : MArray<FloatComplex> (dim_vector (1, n)) { }
 
-  explicit FloatComplexRowVector (const dim_vector& dv) : MArray<FloatComplex> (dv.as_row ()) { }
+  explicit FloatComplexRowVector (const dim_vector& dv)
+    : MArray<FloatComplex> (dv.as_row ()) { }
 
   FloatComplexRowVector (octave_idx_type n, const FloatComplex& val) 
-    : MArray<FloatComplex> (1, n, val) { }
+    : MArray<FloatComplex> (dim_vector (1, n), val) { }
 
-  FloatComplexRowVector (const FloatComplexRowVector& a) : MArray<FloatComplex> (a) { }
+  FloatComplexRowVector (const FloatComplexRowVector& a)
+    : MArray<FloatComplex> (a) { }
 
-  FloatComplexRowVector (const MArray<FloatComplex>& a) : MArray<FloatComplex> (a.as_row ()) { }
-  FloatComplexRowVector (const Array<FloatComplex>& a) : MArray<FloatComplex> (a.as_row ()) { }
+  FloatComplexRowVector (const MArray<FloatComplex>& a)
+    : MArray<FloatComplex> (a.as_row ()) { }
 
-  explicit FloatComplexRowVector (const FloatRowVector& a) : MArray<FloatComplex> (a) { }
+  FloatComplexRowVector (const Array<FloatComplex>& a)
+    : MArray<FloatComplex> (a.as_row ()) { }
+
+  explicit FloatComplexRowVector (const FloatRowVector& a)
+    : MArray<FloatComplex> (a) { }
 
   FloatComplexRowVector& operator = (const FloatComplexRowVector& a)
     {
       MArray<FloatComplex>::operator = (a);
       return *this;
     }
 
   bool operator == (const FloatComplexRowVector& a) const;
diff --git a/liboctave/fCmplxCHOL.cc b/liboctave/fCmplxCHOL.cc
--- a/liboctave/fCmplxCHOL.cc
+++ b/liboctave/fCmplxCHOL.cc
@@ -122,19 +122,19 @@ FloatComplexCHOL::init (const FloatCompl
   xrcond = 0.0;
   if (info > 0)
     chol_mat.resize (info - 1, info - 1);
   else if (calc_cond) 
     {
       octave_idx_type cpocon_info = 0;
 
       // Now calculate the condition number for non-singular matrix.
-      Array<FloatComplex> z (2*n, 1);
+      Array<FloatComplex> z (dim_vector (2*n, 1));
       FloatComplex *pz = z.fortran_vec ();
-      Array<float> rz (n, 1);
+      Array<float> rz (dim_vector (n, 1));
       float *prz = rz.fortran_vec ();
       F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
                                  n, anorm, xrcond, pz, prz, cpocon_info
                                  F77_CHAR_ARG_LEN (1)));
 
       if (cpocon_info != 0) 
         info = -1;
     }
@@ -414,17 +414,17 @@ FloatComplexCHOL::shift_sym (octave_idx_
 
   octave_idx_type n = chol_mat.rows ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1) 
     (*current_liboctave_error_handler) ("cholshift: index out of range");
   else
     {
       FloatComplexMatrix a = chol_mat.hermitian () * chol_mat;
-      Array<octave_idx_type> p (n, 1);
+      Array<octave_idx_type> p (dim_vector (n, 1));
       for (octave_idx_type k = 0; k < n; k++) p(k) = k;
       if (i < j)
         {
           for (octave_idx_type k = i; k < j; k++) p(k) = k+1;
           p(j) = i;
         }
       else if (j < i)
         {
diff --git a/liboctave/fCmplxHESS.cc b/liboctave/fCmplxHESS.cc
--- a/liboctave/fCmplxHESS.cc
+++ b/liboctave/fCmplxHESS.cc
@@ -82,27 +82,27 @@ FloatComplexHESS::init (const FloatCompl
   octave_idx_type lwork = 32 * n;
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
 
   hess_mat = a;
   FloatComplex *h = hess_mat.fortran_vec ();
 
-  Array<float> scale (n, 1);
+  Array<float> scale (dim_vector (n, 1));
   float *pscale = scale.fortran_vec ();
 
   F77_XFCN (cgebal, CGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
                              n, h, n, ilo, ihi, pscale, info
                              F77_CHAR_ARG_LEN (1)));
 
-  Array<FloatComplex> tau (n-1, 1);
+  Array<FloatComplex> tau (dim_vector (n-1, 1));
   FloatComplex *ptau = tau.fortran_vec ();
 
-  Array<FloatComplex> work (lwork, 1);
+  Array<FloatComplex> work (dim_vector (lwork, 1));
   FloatComplex *pwork = work.fortran_vec ();
 
   F77_XFCN (cgehrd, CGEHRD, (n, ilo, ihi, h, n, ptau, pwork, lwork, info));
 
   unitary_hess_mat = hess_mat;
   FloatComplex *z = unitary_hess_mat.fortran_vec ();
 
   F77_XFCN (cunghr, CUNGHR, (n, ilo, ihi, z, n, ptau, pwork,
diff --git a/liboctave/fCmplxQRP.cc b/liboctave/fCmplxQRP.cc
--- a/liboctave/fCmplxQRP.cc
+++ b/liboctave/fCmplxQRP.cc
@@ -61,17 +61,17 @@ FloatComplexQRP::init (const FloatComple
   OCTAVE_LOCAL_BUFFER (FloatComplex, tau, min_mn);
 
   octave_idx_type info = 0;
 
   FloatComplexMatrix afact = a;
   if (m > n && qr_type == qr_type_std)
     afact.resize (m, m);
 
-  MArray<octave_idx_type> jpvt (n, 1, 0);
+  MArray<octave_idx_type> jpvt (dim_vector (n, 1), 0);
 
   if (m > 0)
     {
       OCTAVE_LOCAL_BUFFER (float, rwork, 2*n);
 
       // workspace query.
       FloatComplex clwork;
       F77_XFCN (cgeqp3, CGEQP3, (m, n, afact.fortran_vec (), m, jpvt.fortran_vec (),
diff --git a/liboctave/fCmplxSCHUR.cc b/liboctave/fCmplxSCHUR.cc
--- a/liboctave/fCmplxSCHUR.cc
+++ b/liboctave/fCmplxSCHUR.cc
@@ -115,27 +115,28 @@ FloatComplexSCHUR::init (const FloatComp
 
   schur_mat = a;
   if (calc_unitary)
     unitary_mat.clear (n, n);
 
   FloatComplex *s = schur_mat.fortran_vec ();
   FloatComplex *q = unitary_mat.fortran_vec ();
 
-  Array<float> rwork (n, 1);
+  Array<float> rwork (dim_vector (n, 1));
   float *prwork = rwork.fortran_vec ();
 
-  Array<FloatComplex> w (n, 1);
+  Array<FloatComplex> w (dim_vector (n, 1));
   FloatComplex *pw = w.fortran_vec ();
 
-  Array<FloatComplex> work (lwork, 1);
+  Array<FloatComplex> work (dim_vector (lwork, 1));
   FloatComplex *pwork = work.fortran_vec ();
 
   // BWORK is not referenced for non-ordered Schur.
-  Array<octave_idx_type> bwork ((ord_char == 'N' || ord_char == 'n') ? 0 : n, 1);
+  octave_idx_type ntmp = (ord_char == 'N' || ord_char == 'n') ? 0 : n;
+  Array<octave_idx_type> bwork (dim_vector (ntmp, 1));
   octave_idx_type *pbwork = bwork.fortran_vec ();
 
   F77_XFCN (cgeesx, CGEESX, (F77_CONST_CHAR_ARG2 (&jobvs, 1),
                              F77_CONST_CHAR_ARG2 (&sort, 1),
                              selector,
                              F77_CONST_CHAR_ARG2 (&sense, 1),
                              n, s, n, sdim, pw, q, n, rconde, rcondv,
                              pwork, lwork, prwork, pbwork, info
diff --git a/liboctave/fCmplxSVD.cc b/liboctave/fCmplxSVD.cc
--- a/liboctave/fCmplxSVD.cc
+++ b/liboctave/fCmplxSVD.cc
@@ -141,23 +141,23 @@ FloatComplexSVD::init (const FloatComple
 
   if (! (jobv == 'N' || jobv == 'O'))
     right_sm.resize (nrow_vt, n);
 
   FloatComplex *vt = right_sm.fortran_vec ();
 
   octave_idx_type lrwork = 5*max_mn;
 
-  Array<float> rwork (lrwork, 1);
+  Array<float> rwork (dim_vector (lrwork, 1));
 
   // Ask ZGESVD what the dimension of WORK should be.
 
   octave_idx_type lwork = -1;
 
-  Array<FloatComplex> work (1, 1);
+  Array<FloatComplex> work (dim_vector (1, 1));
 
   octave_idx_type one = 1;
   octave_idx_type m1 = std::max (m, one), nrow_vt1 = std::max (nrow_vt, one);
 
   if (svd_driver == SVD::GESVD)
     {
       F77_XFCN (cgesvd, CGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                                  F77_CONST_CHAR_ARG2 (&jobv, 1),
diff --git a/liboctave/fColVector.h b/liboctave/fColVector.h
--- a/liboctave/fColVector.h
+++ b/liboctave/fColVector.h
@@ -29,29 +29,34 @@ along with Octave; see the file COPYING.
 #include "mx-defs.h"
 
 class
 OCTAVE_API
 FloatColumnVector : public MArray<float>
 {
 public:
 
-  FloatColumnVector (void) : MArray<float> (0, 1) { }
+  FloatColumnVector (void) : MArray<float> (dim_vector (0, 1)) { }
 
-  explicit FloatColumnVector (octave_idx_type n) : MArray<float> (n, 1) { }
+  explicit FloatColumnVector (octave_idx_type n)
+    : MArray<float> (dim_vector (n, 1)) { }
 
   explicit FloatColumnVector (const dim_vector& dv) 
     : MArray<float> (dv.as_column ()) { }
 
-  FloatColumnVector (octave_idx_type n, float val) : MArray<float> (n, 1, val) { }
+  FloatColumnVector (octave_idx_type n, float val)
+    : MArray<float> (dim_vector (n, 1), val) { }
 
   FloatColumnVector (const FloatColumnVector& a) : MArray<float> (a) { }
 
-  FloatColumnVector (const MArray<float>& a) : MArray<float> (a.as_column ()) { }
-  FloatColumnVector (const Array<float>& a) : MArray<float> (a.as_column ()) { }
+  FloatColumnVector (const MArray<float>& a)
+    : MArray<float> (a.as_column ()) { }
+
+  FloatColumnVector (const Array<float>& a)
+    : MArray<float> (a.as_column ()) { }
 
   FloatColumnVector& operator = (const FloatColumnVector& a)
     {
       MArray<float>::operator = (a);
       return *this;
     }
 
   bool operator == (const FloatColumnVector& a) const;
diff --git a/liboctave/fEIG.cc b/liboctave/fEIG.cc
--- a/liboctave/fEIG.cc
+++ b/liboctave/fEIG.cc
@@ -154,20 +154,20 @@ FloatEIG::init (const FloatMatrix& a, bo
       return -1;
     }
 
   octave_idx_type info = 0;
 
   FloatMatrix atmp = a;
   float *tmp_data = atmp.fortran_vec ();
 
-  Array<float> wr (n, 1);
+  Array<float> wr (dim_vector (n, 1));
   float *pwr = wr.fortran_vec ();
 
-  Array<float> wi (n, 1);
+  Array<float> wi (dim_vector (n, 1));
   float *pwi = wi.fortran_vec ();
 
   volatile octave_idx_type nvr = calc_ev ? n : 0;
   FloatMatrix vr (nvr, nvr);
   float *pvr = vr.fortran_vec ();
 
   octave_idx_type lwork = -1;
   float dummy_work;
@@ -180,17 +180,17 @@ FloatEIG::init (const FloatMatrix& a, bo
                            n, tmp_data, n, pwr, pwi, dummy,
                            idummy, pvr, n, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
-      Array<float> work (lwork, 1);
+      Array<float> work (dim_vector (lwork, 1));
       float *pwork = work.fortran_vec ();
 
       F77_XFCN (sgeev, SGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                n, tmp_data, n, pwr, pwi, dummy,
                                idummy, pvr, n, pwork, lwork, info
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
@@ -272,17 +272,17 @@ FloatEIG::symmetric_init (const FloatMat
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, tmp_data, n, pwr, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
-      Array<float> work (lwork, 1);
+      Array<float> work (dim_vector (lwork, 1));
       float *pwork = work.fortran_vec ();
 
       F77_XFCN (ssyev, SSYEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                F77_CONST_CHAR_ARG2 ("U", 1),
                                n, tmp_data, n, pwr, pwork, lwork, info
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
 
@@ -339,33 +339,33 @@ FloatEIG::init (const FloatComplexMatrix
   octave_idx_type nvr = calc_ev ? n : 0;
   FloatComplexMatrix vtmp (nvr, nvr);
   FloatComplex *pv = vtmp.fortran_vec ();
 
   octave_idx_type lwork = -1;
   FloatComplex dummy_work;
 
   octave_idx_type lrwork = 2*n;
-  Array<float> rwork (lrwork, 1);
+  Array<float> rwork (dim_vector (lrwork, 1));
   float *prwork = rwork.fortran_vec ();
 
   FloatComplex *dummy = 0;
   octave_idx_type idummy = 1;
 
   F77_XFCN (cgeev, CGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            n, tmp_data, n, pw, dummy, idummy,
                            pv, n, &dummy_work, lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
-      Array<FloatComplex> work (lwork, 1);
+      Array<FloatComplex> work (dim_vector (lwork, 1));
       FloatComplex *pwork = work.fortran_vec ();
 
       F77_XFCN (cgeev, CGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                n, tmp_data, n, pw, dummy, idummy,
                                pv, n, pwork, lwork, prwork, info
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
@@ -409,30 +409,30 @@ FloatEIG::hermitian_init (const FloatCom
 
   FloatColumnVector wr (n);
   float *pwr = wr.fortran_vec ();
 
   octave_idx_type lwork = -1;
   FloatComplex dummy_work;
 
   octave_idx_type lrwork = 3*n;
-  Array<float> rwork (lrwork, 1);
+  Array<float> rwork (dim_vector (lrwork, 1));
   float *prwork = rwork.fortran_vec ();
 
   F77_XFCN (cheev, CHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, tmp_data, n, pwr, &dummy_work, lwork,
                            prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
-      Array<FloatComplex> work (lwork, 1);
+      Array<FloatComplex> work (dim_vector (lwork, 1));
       FloatComplex *pwork = work.fortran_vec ();
 
       F77_XFCN (cheev, CHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                F77_CONST_CHAR_ARG2 ("U", 1),
                                n, tmp_data, n, pwr, pwork, lwork, prwork, info
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
 
@@ -497,23 +497,23 @@ FloatEIG::init (const FloatMatrix& a, co
     return symmetric_init (a, b, calc_ev);
 
   FloatMatrix atmp = a;
   float *atmp_data = atmp.fortran_vec ();
 
   FloatMatrix btmp = b;
   float *btmp_data = btmp.fortran_vec ();
 
-  Array<float> ar (n, 1);
+  Array<float> ar (dim_vector (n, 1));
   float *par = ar.fortran_vec ();
 
-  Array<float> ai (n, 1);
+  Array<float> ai (dim_vector (n, 1));
   float *pai = ai.fortran_vec ();
 
-  Array<float> beta (n, 1);
+  Array<float> beta (dim_vector (n, 1));
   float *pbeta = beta.fortran_vec ();
 
   volatile octave_idx_type nvr = calc_ev ? n : 0;
   FloatMatrix vr (nvr, nvr);
   float *pvr = vr.fortran_vec ();
 
   octave_idx_type lwork = -1;
   float dummy_work;
@@ -528,17 +528,17 @@ FloatEIG::init (const FloatMatrix& a, co
                            dummy, idummy, pvr, n,
                            &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
-      Array<float> work (lwork, 1);
+      Array<float> work (dim_vector (lwork, 1));
       float *pwork = work.fortran_vec ();
 
       F77_XFCN (sggev, SGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                n, atmp_data, n, btmp_data, n, 
                                par, pai, pbeta,
                                dummy, idummy, pvr, n,
                                pwork, lwork, info
@@ -636,17 +636,17 @@ FloatEIG::symmetric_init (const FloatMat
                            btmp_data, n, 
                            pwr, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
-      Array<float> work (lwork, 1);
+      Array<float> work (dim_vector (lwork, 1));
       float *pwork = work.fortran_vec ();
 
       F77_XFCN (ssygv, SSYGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                F77_CONST_CHAR_ARG2 ("U", 1),
                                n, atmp_data, n, 
                                btmp_data, n, 
                                pwr, pwork, lwork, info
                                F77_CHAR_ARG_LEN (1)
@@ -727,34 +727,34 @@ FloatEIG::init (const FloatComplexMatrix
   octave_idx_type nvr = calc_ev ? n : 0;
   FloatComplexMatrix vtmp (nvr, nvr);
   FloatComplex *pv = vtmp.fortran_vec ();
 
   octave_idx_type lwork = -1;
   FloatComplex dummy_work;
 
   octave_idx_type lrwork = 8*n;
-  Array<float> rwork (lrwork, 1);
+  Array<float> rwork (dim_vector (lrwork, 1));
   float *prwork = rwork.fortran_vec ();
 
   FloatComplex *dummy = 0;
   octave_idx_type idummy = 1;
 
   F77_XFCN (cggev, CGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            n, atmp_data, n, btmp_data, n, 
                            palpha, pbeta, dummy, idummy,
                            pv, n, &dummy_work, lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
-      Array<FloatComplex> work (lwork, 1);
+      Array<FloatComplex> work (dim_vector (lwork, 1));
       FloatComplex *pwork = work.fortran_vec ();
 
       F77_XFCN (cggev, CGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                n, atmp_data, n, btmp_data, n, 
                                palpha, pbeta, dummy, idummy,
                                pv, n, pwork, lwork, prwork, info
                                F77_CHAR_ARG_LEN (1)
@@ -813,32 +813,32 @@ FloatEIG::hermitian_init (const FloatCom
 
   FloatColumnVector wr (n);
   float *pwr = wr.fortran_vec ();
 
   octave_idx_type lwork = -1;
   FloatComplex dummy_work;
 
   octave_idx_type lrwork = 3*n;
-  Array<float> rwork (lrwork, 1);
+  Array<float> rwork (dim_vector (lrwork, 1));
   float *prwork = rwork.fortran_vec ();
 
   F77_XFCN (chegv, CHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, atmp_data, n, 
                            btmp_data, n,
                            pwr, &dummy_work, lwork,
                            prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
-      Array<FloatComplex> work (lwork, 1);
+      Array<FloatComplex> work (dim_vector (lwork, 1));
       FloatComplex *pwork = work.fortran_vec ();
 
       F77_XFCN (chegv, CHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                F77_CONST_CHAR_ARG2 ("U", 1),
                                n, atmp_data, n, 
                                btmp_data, n, 
                                pwr, pwork, lwork, prwork, info
                                F77_CHAR_ARG_LEN (1)
diff --git a/liboctave/fMatrix.cc b/liboctave/fMatrix.cc
--- a/liboctave/fMatrix.cc
+++ b/liboctave/fMatrix.cc
@@ -245,24 +245,24 @@ FloatMatrix::FloatMatrix (const FloatRow
 }
 
 FloatMatrix::FloatMatrix (const FloatColumnVector& cv)
   : MArray<float> (cv)
 {
 }
 
 FloatMatrix::FloatMatrix (const FloatDiagMatrix& a)
-  : MArray<float> (a.rows (), a.cols (), 0.0)
+  : MArray<float> (a.dims (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
 FloatMatrix::FloatMatrix (const PermMatrix& a)
-  : MArray<float> (a.rows (), a.cols (), 0.0)
+  : MArray<float> (a.dims (), 0.0)
 {
   const Array<octave_idx_type> ia (a.pvec ());
   octave_idx_type len = a.rows ();
   if (a.is_col_perm ())
     for (octave_idx_type i = 0; i < len; i++)
       elem (ia(i), i) = 1.0;
   else
     for (octave_idx_type i = 0; i < len; i++)
@@ -273,17 +273,17 @@ FloatMatrix::FloatMatrix (const PermMatr
 // here?
 
 FloatMatrix::FloatMatrix (const boolMatrix& a)
   : MArray<float> (a)
 {
 }
 
 FloatMatrix::FloatMatrix (const charMatrix& a)
-  : MArray<float> (a.rows (), a.cols ())
+  : MArray<float> (a.dims ())
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     for (octave_idx_type j = 0; j < a.cols (); j++)
       elem (i, j) = static_cast<unsigned char> (a.elem (i, j));
 }
 
 bool
 FloatMatrix::operator == (const FloatMatrix& a) const
@@ -735,23 +735,23 @@ FloatMatrix::finverse (MatrixType &matty
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
   else
     {
-      Array<octave_idx_type> ipvt (nr, 1);
+      Array<octave_idx_type> ipvt (dim_vector (nr, 1));
       octave_idx_type *pipvt = ipvt.fortran_vec ();
 
       retval = *this;
       float *tmp_data = retval.fortran_vec ();
 
-      Array<float> z(1, 1);
+      Array<float> z(dim_vector (1, 1));
       octave_idx_type lwork = -1;
 
       // Query the optimum work array size.
       F77_XFCN (sgetri, SGETRI, (nc, tmp_data, nr, pipvt, 
                                  z.fortran_vec (), lwork, info));
 
       lwork = static_cast<octave_idx_type> (z(0));
       lwork = (lwork < 2 *nc ? 2*nc : lwork);
@@ -772,17 +772,17 @@ FloatMatrix::finverse (MatrixType &matty
       if (info != 0) 
         info = -1;
       else if (calc_cond) 
         {
           octave_idx_type dgecon_info = 0;
 
           // Now calculate the condition number for non-singular matrix.
           char job = '1';
-          Array<octave_idx_type> iz (nc, 1);
+          Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
           F77_XFCN (sgecon, SGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nc, tmp_data, nr, anorm, 
                                      rcon, pz, piz, dgecon_info
                                      F77_CHAR_ARG_LEN (1)));
 
           if (dgecon_info != 0) 
             info = -1;
@@ -1007,17 +1007,17 @@ FloatMatrix::fourier (void) const
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<FloatComplex> wsave (nn, 1);
+  Array<FloatComplex> wsave (dim_vector (nn, 1));
   FloatComplex *pwsave = wsave.fortran_vec ();
 
   retval = FloatComplexMatrix (*this);
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1048,17 +1048,17 @@ FloatMatrix::ifourier (void) const
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<FloatComplex> wsave (nn, 1);
+  Array<FloatComplex> wsave (dim_vector (nn, 1));
   FloatComplex *pwsave = wsave.fortran_vec ();
 
   retval = FloatComplexMatrix (*this);
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1092,17 +1092,17 @@ FloatMatrix::fourier2d (void) const
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<FloatComplex> wsave (nn, 1);
+  Array<FloatComplex> wsave (dim_vector (nn, 1));
   FloatComplex *pwsave = wsave.fortran_vec ();
 
   retval = FloatComplexMatrix (*this);
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1114,17 +1114,17 @@ FloatMatrix::fourier2d (void) const
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
   wsave.resize (nn, 1);
   pwsave = wsave.fortran_vec ();
 
-  Array<FloatComplex> tmp (npts, 1);
+  Array<FloatComplex> tmp (dim_vector (npts, 1));
   FloatComplex *prow = tmp.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
@@ -1158,17 +1158,17 @@ FloatMatrix::ifourier2d (void) const
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<FloatComplex> wsave (nn, 1);
+  Array<FloatComplex> wsave (dim_vector (nn, 1));
   FloatComplex *pwsave = wsave.fortran_vec ();
 
   retval = FloatComplexMatrix (*this);
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1183,17 +1183,17 @@ FloatMatrix::ifourier2d (void) const
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
   wsave.resize (nn, 1);
   pwsave = wsave.fortran_vec ();
 
-  Array<FloatComplex> tmp (npts, 1);
+  Array<FloatComplex> tmp (dim_vector (npts, 1));
   FloatComplex *prow = tmp.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
@@ -1280,19 +1280,19 @@ FloatMatrix::determinant (MatrixType& ma
           if (info != 0) 
             {
               rcon = 0.0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else 
             {
-              Array<float> z (3 * nc, 1);
+              Array<float> z (dim_vector (3 * nc, 1));
               float *pz = z.fortran_vec ();
-              Array<octave_idx_type> iz (nc, 1);
+              Array<octave_idx_type> iz (dim_vector (nc, 1));
               octave_idx_type *piz = iz.fortran_vec ();
 
               F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                          nr, tmp_data, nr, anorm,
                                          rcon, pz, piz, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0) 
@@ -1304,17 +1304,17 @@ FloatMatrix::determinant (MatrixType& ma
               retval = retval.square ();
             }
         }
       else if (typ != MatrixType::Full)
         (*current_liboctave_error_handler) ("det: invalid dense matrix type");
 
       if (typ == MatrixType::Full)
         {
-          Array<octave_idx_type> ipvt (nr, 1);
+          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           FloatMatrix atmp = *this;
           float *tmp_data = atmp.fortran_vec ();
 
           info = 0;
 
           // Calculate the norm of the matrix, for later use.
@@ -1331,19 +1331,19 @@ FloatMatrix::determinant (MatrixType& ma
               retval = FloatDET ();
             } 
           else 
             {
               if (calc_cond) 
                 {
                   // Now calc the condition number for non-singular matrix.
                   char job = '1';
-                  Array<float> z (4 * nc, 1);
+                  Array<float> z (dim_vector (4 * nc, 1));
                   float *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nc, 1);
+                  Array<octave_idx_type> iz (dim_vector (nc, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (sgecon, SGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nc, tmp_data, nr, anorm, 
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
                 }
 
@@ -1396,19 +1396,19 @@ FloatMatrix::rcond (MatrixType &mattype)
       if (typ == MatrixType::Upper)
         {
           const float *tmp_data = fortran_vec ();
           octave_idx_type info = 0;
           char norm = '1';
           char uplo = 'U';
           char dia = 'N';
 
-          Array<float> z (3 * nc, 1);
+          Array<float> z (dim_vector (3 * nc, 1));
           float *pz = z.fortran_vec ();
-          Array<octave_idx_type> iz (nc, 1);
+          Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
 
           F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                      F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                      F77_CONST_CHAR_ARG2 (&dia, 1), 
                                      nr, tmp_data, nr, rcon,
                                      pz, piz, info
                                      F77_CHAR_ARG_LEN (1)
@@ -1424,19 +1424,19 @@ FloatMatrix::rcond (MatrixType &mattype)
       else if (typ == MatrixType::Lower)
         {
           const float *tmp_data = fortran_vec ();
           octave_idx_type info = 0;
           char norm = '1';
           char uplo = 'L';
           char dia = 'N';
 
-          Array<float> z (3 * nc, 1);
+          Array<float> z (dim_vector (3 * nc, 1));
           float *pz = z.fortran_vec ();
-          Array<octave_idx_type> iz (nc, 1);
+          Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
 
           F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                      F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                      F77_CONST_CHAR_ARG2 (&dia, 1), 
                                      nr, tmp_data, nr, rcon,
                                      pz, piz, info
                                      F77_CHAR_ARG_LEN (1)
@@ -1469,45 +1469,45 @@ FloatMatrix::rcond (MatrixType &mattype)
               if (info != 0) 
                 {
                   rcon = 0.0;
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
               else 
                 {
-                  Array<float> z (3 * nc, 1);
+                  Array<float> z (dim_vector (3 * nc, 1));
                   float *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nc, 1);
+                  Array<octave_idx_type> iz (dim_vector (nc, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0) 
                     rcon = 0.0;
                 }
             }
 
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
-              Array<octave_idx_type> ipvt (nr, 1);
+              Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
               if(anorm < 0.)
                 anorm = atmp.abs().sum().
                   row(static_cast<octave_idx_type>(0)).max();
 
-              Array<float> z (4 * nc, 1);
+              Array<float> z (dim_vector (4 * nc, 1));
               float *pz = z.fortran_vec ();
-              Array<octave_idx_type> iz (nc, 1);
+              Array<octave_idx_type> iz (dim_vector (nc, 1));
               octave_idx_type *piz = iz.fortran_vec ();
 
               F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
               if (info != 0) 
                 {
                   rcon = 0.0;
                   mattype.mark_as_rectangular ();
@@ -1568,19 +1568,19 @@ FloatMatrix::utsolve (MatrixType &mattyp
               const float *tmp_data = fortran_vec ();
 
               if (calc_cond)
                 {
                   char norm = '1';
                   char uplo = 'U';
                   char dia = 'N';
 
-                  Array<float> z (3 * nc, 1);
+                  Array<float> z (dim_vector (3 * nc, 1));
                   float *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nc, 1);
+                  Array<octave_idx_type> iz (dim_vector (nc, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                              F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                              F77_CONST_CHAR_ARG2 (&dia, 1), 
                                              nr, tmp_data, nr, rcon,
                                              pz, piz, info
                                              F77_CHAR_ARG_LEN (1)
@@ -1668,19 +1668,19 @@ FloatMatrix::ltsolve (MatrixType &mattyp
               const float *tmp_data = fortran_vec ();
 
               if (calc_cond)
                 {
                   char norm = '1';
                   char uplo = 'L';
                   char dia = 'N';
 
-                  Array<float> z (3 * nc, 1);
+                  Array<float> z (dim_vector (3 * nc, 1));
                   float *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nc, 1);
+                  Array<octave_idx_type> iz (dim_vector (nc, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                              F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                              F77_CONST_CHAR_ARG2 (&dia, 1), 
                                              nr, tmp_data, nr, rcon,
                                              pz, piz, info
                                              F77_CHAR_ARG_LEN (1)
@@ -1774,19 +1774,19 @@ FloatMatrix::fsolve (MatrixType &mattype
 
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else 
             {
               if (calc_cond)
                 {
-                  Array<float> z (3 * nc, 1);
+                  Array<float> z (dim_vector (3 * nc, 1));
                   float *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nc, 1);
+                  Array<octave_idx_type> iz (dim_vector (nc, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0) 
@@ -1826,27 +1826,27 @@ FloatMatrix::fsolve (MatrixType &mattype
                 }                   
             }
         }
 
       if (typ == MatrixType::Full)
         {
           info = 0;
 
-          Array<octave_idx_type> ipvt (nr, 1);
+          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           FloatMatrix atmp = *this;
           float *tmp_data = atmp.fortran_vec ();
           if(anorm < 0.)
             anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
-          Array<float> z (4 * nc, 1);
+          Array<float> z (dim_vector (4 * nc, 1));
           float *pz = z.fortran_vec ();
-          Array<octave_idx_type> iz (nc, 1);
+          Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
 
           F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0) 
             {
@@ -2266,23 +2266,23 @@ FloatMatrix::lssolve (const FloatMatrix&
         }
       else
         retval = b;
 
       FloatMatrix atmp = *this;
       float *tmp_data = atmp.fortran_vec ();
 
       float *pretval = retval.fortran_vec ();
-      Array<float> s (minmn, 1);
+      Array<float> s (dim_vector (minmn, 1));
       float *ps = s.fortran_vec ();
 
       // Ask DGELSD what the dimension of WORK should be.
       octave_idx_type lwork = -1;
 
-      Array<float> work (1, 1);
+      Array<float> work (dim_vector (1, 1));
 
       octave_idx_type smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("SGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
@@ -2304,17 +2304,17 @@ FloatMatrix::lssolve (const FloatMatrix&
 #endif
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
-      Array<octave_idx_type> iwork (liwork, 1);
+      Array<octave_idx_type> iwork (dim_vector (liwork, 1));
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (sgelsd, SGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
                                  ps, rcon, rank, work.fortran_vec (),
                                  lwork, piwork, info));
 
       // The workspace query is broken in at least LAPACK 3.0.0
       // through 3.1.1 when n >= mnthr.  The obtuse formula below
@@ -2464,23 +2464,23 @@ FloatMatrix::lssolve (const FloatColumnV
         }
       else
         retval = b;
 
       FloatMatrix atmp = *this;
       float *tmp_data = atmp.fortran_vec ();
 
       float *pretval = retval.fortran_vec ();
-      Array<float> s (minmn, 1);
+      Array<float> s (dim_vector (minmn, 1));
       float *ps = s.fortran_vec ();
 
       // Ask DGELSD what the dimension of WORK should be.
       octave_idx_type lwork = -1;
 
-      Array<float> work (1, 1);
+      Array<float> work (dim_vector (1, 1));
 
       octave_idx_type smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("SGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
@@ -2495,17 +2495,17 @@ FloatMatrix::lssolve (const FloatColumnV
 #endif
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
-      Array<octave_idx_type> iwork (liwork, 1);
+      Array<octave_idx_type> iwork (dim_vector (liwork, 1));
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (sgelsd, SGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
                                  ps, rcon, rank, work.fortran_vec (),
                                  lwork, piwork, info));
 
       lwork = static_cast<octave_idx_type> (work(0));
       work.resize (lwork, 1);
diff --git a/liboctave/fMatrix.h b/liboctave/fMatrix.h
--- a/liboctave/fMatrix.h
+++ b/liboctave/fMatrix.h
@@ -39,23 +39,26 @@ public:
 
   typedef FloatColumnVector column_vector_type;
   typedef FloatRowVector row_vector_type;
 
   typedef void (*solve_singularity_handler) (float rcon);
 
   FloatMatrix (void) : MArray<float> () { }
 
-  FloatMatrix (octave_idx_type r, octave_idx_type c) : MArray<float> (r, c) { }
+  FloatMatrix (octave_idx_type r, octave_idx_type c)
+    : MArray<float> (dim_vector (r, c)) { }
 
-  FloatMatrix (octave_idx_type r, octave_idx_type c, float val) : MArray<float> (r, c, val) { }
+  FloatMatrix (octave_idx_type r, octave_idx_type c, float val)
+    : MArray<float> (dim_vector (r, c), val) { }
 
   FloatMatrix (const dim_vector& dv) : MArray<float> (dv.redim (2)) { }
 
-  FloatMatrix (const dim_vector& dv, float val) : MArray<float> (dv.redim (2), val) { }
+  FloatMatrix (const dim_vector& dv, float val)
+    : MArray<float> (dv.redim (2), val) { }
 
   FloatMatrix (const FloatMatrix& a) : MArray<float> (a) { }
 
   template <class U>
   FloatMatrix (const MArray<U>& a) : MArray<float> (a.as_matrix ()) { }
 
   template <class U>
   FloatMatrix (const Array<U>& a) : MArray<float> (a.as_matrix ()) { }
diff --git a/liboctave/fRowVector.h b/liboctave/fRowVector.h
--- a/liboctave/fRowVector.h
+++ b/liboctave/fRowVector.h
@@ -28,27 +28,31 @@ along with Octave; see the file COPYING.
 #include "mx-defs.h"
 
 class
 OCTAVE_API
 FloatRowVector : public MArray<float>
 {
 public:
 
-  FloatRowVector (void) : MArray<float> (1, 0) { }
+  FloatRowVector (void) : MArray<float> (dim_vector (1, 0)) { }
 
-  explicit FloatRowVector (octave_idx_type n) : MArray<float> (1, n) { }
+  explicit FloatRowVector (octave_idx_type n)
+    : MArray<float> (dim_vector (1, n)) { }
 
-  explicit FloatRowVector (const dim_vector& dv) : MArray<float> (dv.as_row ()) { }
+  explicit FloatRowVector (const dim_vector& dv)
+    : MArray<float> (dv.as_row ()) { }
 
-  FloatRowVector (octave_idx_type n, float val) : MArray<float> (1, n, val) { }
+  FloatRowVector (octave_idx_type n, float val)
+    : MArray<float> (dim_vector (1, n), val) { }
 
   FloatRowVector (const FloatRowVector& a) : MArray<float> (a) { }
 
   FloatRowVector (const MArray<float>& a) : MArray<float> (a.as_row ()) { }
+
   FloatRowVector (const Array<float>& a) : MArray<float> (a.as_row ()) { }
 
   FloatRowVector& operator = (const FloatRowVector& a)
     {
       MArray<float>::operator = (a);
       return *this;
     }
 
diff --git a/liboctave/floatCHOL.cc b/liboctave/floatCHOL.cc
--- a/liboctave/floatCHOL.cc
+++ b/liboctave/floatCHOL.cc
@@ -123,19 +123,19 @@ FloatCHOL::init (const FloatMatrix& a, b
   xrcond = 0.0;
   if (info > 0)
     chol_mat.resize (info - 1, info - 1);
   else if (calc_cond) 
     {
       octave_idx_type spocon_info = 0;
 
       // Now calculate the condition number for non-singular matrix.
-      Array<float> z (3*n, 1);
+      Array<float> z (dim_vector (3*n, 1));
       float *pz = z.fortran_vec ();
-      Array<octave_idx_type> iz (n, 1);
+      Array<octave_idx_type> iz (dim_vector (n, 1));
       octave_idx_type *piz = iz.fortran_vec ();
       F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
                                  n, anorm, xrcond, pz, piz, spocon_info
                                  F77_CHAR_ARG_LEN (1)));
 
       if (spocon_info != 0) 
         info = -1;
     }
@@ -416,17 +416,17 @@ FloatCHOL::shift_sym (octave_idx_type i,
 
   octave_idx_type n = chol_mat.rows ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1) 
     (*current_liboctave_error_handler) ("cholshift: index out of range");
   else
     {
       FloatMatrix a = chol_mat.transpose () * chol_mat;
-      Array<octave_idx_type> p (n, 1);
+      Array<octave_idx_type> p (dim_vector (n, 1));
       for (octave_idx_type k = 0; k < n; k++) p(k) = k;
       if (i < j)
         {
           for (octave_idx_type k = i; k < j; k++) p(k) = k+1;
           p(j) = i;
         }
       else if (j < i)
         {
diff --git a/liboctave/floatHESS.cc b/liboctave/floatHESS.cc
--- a/liboctave/floatHESS.cc
+++ b/liboctave/floatHESS.cc
@@ -79,27 +79,27 @@ FloatHESS::init (const FloatMatrix& a)
   octave_idx_type lwork = 32 * n;
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
 
   hess_mat = a;
   float *h = hess_mat.fortran_vec ();
 
-  Array<float> scale (n, 1);
+  Array<float> scale (dim_vector (n, 1));
   float *pscale = scale.fortran_vec ();
 
   F77_XFCN (sgebal, SGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
                              n, h, n, ilo, ihi, pscale, info
                              F77_CHAR_ARG_LEN (1)));
 
-  Array<float> tau (n-1, 1);
+  Array<float> tau (dim_vector (n-1, 1));
   float *ptau = tau.fortran_vec ();
 
-  Array<float> work (lwork, 1);
+  Array<float> work (dim_vector (lwork, 1));
   float *pwork = work.fortran_vec ();
 
   F77_XFCN (sgehrd, SGEHRD, (n, ilo, ihi, h, n, ptau, pwork,
                              lwork, info));
 
   unitary_hess_mat = hess_mat;
   float *z = unitary_hess_mat.fortran_vec ();
 
diff --git a/liboctave/floatQRP.cc b/liboctave/floatQRP.cc
--- a/liboctave/floatQRP.cc
+++ b/liboctave/floatQRP.cc
@@ -61,17 +61,17 @@ FloatQRP::init (const FloatMatrix& a, qr
   OCTAVE_LOCAL_BUFFER (float, tau, min_mn);
 
   octave_idx_type info = 0;
 
   FloatMatrix afact = a;
   if (m > n && qr_type == qr_type_std)
     afact.resize (m, m);
 
-  MArray<octave_idx_type> jpvt (n, 1, 0);
+  MArray<octave_idx_type> jpvt (dim_vector (n, 1), 0);
 
   if (m > 0)
     {
       // workspace query.
       float rlwork;
       F77_XFCN (sgeqp3, SGEQP3, (m, n, afact.fortran_vec (), m, jpvt.fortran_vec (),
                                  tau, &rlwork, -1, info));
 
diff --git a/liboctave/floatSCHUR.cc b/liboctave/floatSCHUR.cc
--- a/liboctave/floatSCHUR.cc
+++ b/liboctave/floatSCHUR.cc
@@ -113,30 +113,31 @@ FloatSCHUR::init (const FloatMatrix& a, 
   schur_mat = a;
 
   if (calc_unitary)
     unitary_mat.clear (n, n);
 
   float *s = schur_mat.fortran_vec ();
   float *q = unitary_mat.fortran_vec ();
 
-  Array<float> wr (n, 1);
+  Array<float> wr (dim_vector (n, 1));
   float *pwr = wr.fortran_vec ();
 
-  Array<float> wi (n, 1);
+  Array<float> wi (dim_vector (n, 1));
   float *pwi = wi.fortran_vec ();
 
-  Array<float> work (lwork, 1);
+  Array<float> work (dim_vector (lwork, 1));
   float *pwork = work.fortran_vec ();
 
   // BWORK is not referenced for the non-ordered Schur routine.
-  Array<octave_idx_type> bwork ((ord_char == 'N' || ord_char == 'n') ? 0 : n, 1);
+  octave_idx_type ntmp = (ord_char == 'N' || ord_char == 'n') ? 0 : n;
+  Array<octave_idx_type> bwork (dim_vector (ntmp, 1));
   octave_idx_type *pbwork = bwork.fortran_vec ();
 
-  Array<octave_idx_type> iwork (liwork, 1);
+  Array<octave_idx_type> iwork (dim_vector (liwork, 1));
   octave_idx_type *piwork = iwork.fortran_vec ();
 
   F77_XFCN (sgeesx, SGEESX, (F77_CONST_CHAR_ARG2 (&jobvs, 1),
                              F77_CONST_CHAR_ARG2 (&sort, 1),
                              selector,
                              F77_CONST_CHAR_ARG2 (&sense, 1),
                              n, s, n, sdim, pwr, pwi, q, n, rconde, rcondv,
                              pwork, lwork, piwork, liwork, pbwork, info
diff --git a/liboctave/floatSVD.cc b/liboctave/floatSVD.cc
--- a/liboctave/floatSVD.cc
+++ b/liboctave/floatSVD.cc
@@ -141,17 +141,17 @@ FloatSVD::init (const FloatMatrix& a, SV
     right_sm.resize (nrow_vt, n);
 
   float *vt = right_sm.fortran_vec ();
 
   // Ask DGESVD what the dimension of WORK should be.
 
   octave_idx_type lwork = -1;
 
-  Array<float> work (1, 1);
+  Array<float> work (dim_vector (1, 1));
 
   octave_idx_type one = 1;
   octave_idx_type m1 = std::max (m, one), nrow_vt1 = std::max (nrow_vt, one);
 
   if (svd_driver == SVD::GESVD)
     {
       F77_XFCN (sgesvd, SGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                                  F77_CONST_CHAR_ARG2 (&jobv, 1),
diff --git a/liboctave/glob-match.h b/liboctave/glob-match.h
--- a/liboctave/glob-match.h
+++ b/liboctave/glob-match.h
@@ -69,17 +69,17 @@ public:
   void set_pattern (const string_vector& p) { pat = p; }
 
   bool match (const std::string& str) const;
 
   Array<bool> match (const string_vector& str) const
   {
     int n = str.length ();
 
-    Array<bool> retval (n, 1);
+    Array<bool> retval (dim_vector (n, 1));
 
     for (int i = 0; i < n; i++)
       retval(i) = match (str[i]);
 
     return retval;
   }
 
   // We forward to glob_internal here to avoid problems with gnulib's
diff --git a/liboctave/idx-vector.cc b/liboctave/idx-vector.cc
--- a/liboctave/idx-vector.cc
+++ b/liboctave/idx-vector.cc
@@ -736,17 +736,17 @@ idx_vector::idx_mask_rep::print (std::os
 
 Array<bool>
 idx_vector::idx_mask_rep::unconvert (void) const
 {
   if (aowner)
     return *aowner;
   else
     {
-      Array<bool> retval (ext, 1);
+      Array<bool> retval (dim_vector (ext, 1));
       for (octave_idx_type i = 0; i < ext; i++)
         retval.xelem (i) = data[i];
       return retval;
     }
 }
 
 Array<octave_idx_type>
 idx_vector::idx_mask_rep::as_array (void)
@@ -1112,28 +1112,28 @@ idx_vector::complement (octave_idx_type 
   if (extent (n) > n)
     (*current_liboctave_error_handler)
       ("internal error: out of range complement index requested");
 
   if (idx_class () == class_mask)
     {
       idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
       octave_idx_type nz = r->length (0), ext = r->extent (0);
-      Array<bool> mask (n, 1);
+      Array<bool> mask (dim_vector (n, 1));
       const bool *data = r->get_data ();
       bool *ndata = mask.fortran_vec ();
       for (octave_idx_type i = 0; i < ext; i++)
         ndata[i] = ! data[i];
       for (octave_idx_type i = ext; i < n; i++)
         ndata[i] = true;
       retval = new idx_mask_rep (mask, n - nz);
     }
   else
     {
-      Array<bool> mask (n, 1, true);
+      Array<bool> mask (dim_vector (n, 1), true);
       fill (false, length (n), mask.fortran_vec ());
       retval = idx_vector (mask);
     }
 
   return retval;
 }
 
 bool
diff --git a/liboctave/oct-convn.cc b/liboctave/oct-convn.cc
--- a/liboctave/oct-convn.cc
+++ b/liboctave/oct-convn.cc
@@ -129,17 +129,17 @@ convolve (const MArray<T>& a, const MArr
 
   convolve_nd<T, R> (a.fortran_vec (), adims, adims.cumulative (),
                      b.fortran_vec (), bdims, bdims.cumulative (),
                      c.fortran_vec (), cdims.cumulative (), nd, ct == convn_valid);
 
   if (ct == convn_same)
     {
       // Pick the relevant part.
-      Array<idx_vector> sidx (nd, 1);
+      Array<idx_vector> sidx (dim_vector (nd, 1));
 
       for (int i = 0; i < nd; i++)
         sidx(i) = idx_vector::make_range ((bdims(i)-1)/2, 1, adims(i));
       c = c.index (sidx);
     }
 
   return c;
 }
diff --git a/liboctave/oct-norm.cc b/liboctave/oct-norm.cc
--- a/liboctave/oct-norm.cc
+++ b/liboctave/oct-norm.cc
@@ -221,61 +221,61 @@ inline void vector_norm (const Array<T>&
 
   res = acc;
 }
 
 // dense versions
 template <class T, class R, class ACC>
 void column_norms (const MArray<T>& m, MArray<R>& res, ACC acc)
 {
-  res = MArray<R> (1, m.columns ());
+  res = MArray<R> (dim_vector (1, m.columns ()));
   for (octave_idx_type j = 0; j < m.columns (); j++)
     {
       ACC accj = acc;
       for (octave_idx_type i = 0; i < m.rows (); i++)
         accj.accum (m(i, j));
 
       res.xelem (j) = accj;
     }
 }
 
 template <class T, class R, class ACC>
 void row_norms (const MArray<T>& m, MArray<R>& res, ACC acc)
 {
-  res = MArray<R> (m.rows (), 1);
+  res = MArray<R> (dim_vector (m.rows (), 1));
   std::vector<ACC> acci (m.rows (), acc); 
   for (octave_idx_type j = 0; j < m.columns (); j++)
     {
       for (octave_idx_type i = 0; i < m.rows (); i++)
         acci[i].accum (m(i, j));
     }
 
   for (octave_idx_type i = 0; i < m.rows (); i++)
     res.xelem (i) = acci[i];
 }
 
 // sparse versions
 template <class T, class R, class ACC>
 void column_norms (const MSparse<T>& m, MArray<R>& res, ACC acc)
 {
-  res = MArray<R> (1, m.columns ());
+  res = MArray<R> (dim_vector (1, m.columns ()));
   for (octave_idx_type j = 0; j < m.columns (); j++)
     {
       ACC accj = acc;
       for (octave_idx_type k = m.cidx (j); k < m.cidx (j+1); k++)
         accj.accum (m.data (k));
 
       res.xelem (j) = accj;
     }
 }
 
 template <class T, class R, class ACC>
 void row_norms (const MSparse<T>& m, MArray<R>& res, ACC acc)
 {
-  res = MArray<R> (m.rows (), 1);
+  res = MArray<R> (dim_vector (m.rows (), 1));
   std::vector<ACC> acci (m.rows (), acc); 
   for (octave_idx_type j = 0; j < m.columns (); j++)
     {
       for (octave_idx_type k = m.cidx (j); k < m.cidx (j+1); k++)
         acci[m.ridx (k)].accum (m.data (k));
     }
 
   for (octave_idx_type i = 0; i < m.rows (); i++)
diff --git a/liboctave/regex-match.cc b/liboctave/regex-match.cc
--- a/liboctave/regex-match.cc
+++ b/liboctave/regex-match.cc
@@ -135,15 +135,15 @@ regex_match::match (const std::string& s
   return false;
 }
 
 Array<bool>
 regex_match::match (const string_vector& s)
 {
   int n = s.length ();
 
-  Array<bool> retval (n, 1);
+  Array<bool> retval (dim_vector (n, 1));
 
   for (int i = 0; i < n; i++)
     retval(i) = match (s[i]);
 
   return retval;
 }
diff --git a/liboctave/sparse-dmsolve.cc b/liboctave/sparse-dmsolve.cc
--- a/liboctave/sparse-dmsolve.cc
+++ b/liboctave/sparse-dmsolve.cc
@@ -125,17 +125,17 @@ dmsolve_extract (const MArray<T> &m, con
   r2 -= 1;
   c2 -= 1;
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
   octave_idx_type new_r = r2 - r1 + 1;
   octave_idx_type new_c = c2 - c1 + 1;
 
-  MArray<T> result (new_r, new_c);
+  MArray<T> result (dim_vector (new_r, new_c));
 
   for (octave_idx_type j = 0; j < new_c; j++)
     for (octave_idx_type i = 0; i < new_r; i++)
       result.xelem (i, j) = m.elem (r1+i, c1+j);
 
   return result;
 }
 
diff --git a/liboctave/str-vec.cc b/liboctave/str-vec.cc
--- a/liboctave/str-vec.cc
+++ b/liboctave/str-vec.cc
@@ -92,17 +92,17 @@ string_vector::string_vector (const char
   for (octave_idx_type i = 0; i < n; i++)
     elem (i) = s[i];
 }
 
 // Create a string vector from up to N C strings.  Assumes that N is
 // nonnegative.
 
 string_vector::string_vector (const char * const *s, octave_idx_type n)
-  : Array<std::string> (n, 1)
+  : Array<std::string> (dim_vector (n, 1))
 {
   for (octave_idx_type i = 0; i < n; i++)
     elem (i) = s[i];
 }
 
 string_vector&
 string_vector::sort (bool make_uniq)
 {
diff --git a/liboctave/str-vec.h b/liboctave/str-vec.h
--- a/liboctave/str-vec.h
+++ b/liboctave/str-vec.h
@@ -33,21 +33,24 @@ along with Octave; see the file COPYING.
 class
 OCTAVE_API
 string_vector : public Array<std::string>
 {
 public:
 
   string_vector (void) : Array<std::string> () { }
 
-  explicit string_vector (octave_idx_type n) : Array<std::string> (n, 1) { }
+  explicit string_vector (octave_idx_type n)
+    : Array<std::string> (dim_vector (n, 1)) { }
 
-  string_vector (const char *s) : Array<std::string> (1, 1, s) { }
+  string_vector (const char *s)
+    : Array<std::string> (dim_vector (1, 1), s) { }
 
-  string_vector (const std::string& s) : Array<std::string> (1, 1, s) { }
+  string_vector (const std::string& s)
+    : Array<std::string> (dim_vector (1, 1), s) { }
 
   string_vector (const string_vector& s) : Array<std::string> (s) { }
 
   string_vector (const std::list<std::string>& lst);
 
   string_vector (const std::set<std::string>& lst);
 
   string_vector (const Array<std::string>& s)
diff --git a/src/Cell.cc b/src/Cell.cc
--- a/src/Cell.cc
+++ b/src/Cell.cc
@@ -168,17 +168,18 @@ Cell::index (const octave_value_list& id
       retval = *this;
       break;
 
     case 1:
       {
         idx_vector i = idx_arg(0).index_vector ();
 
         if (! error_state)
-          retval = Array<octave_value>::index (i, resize_ok, resize_fill_value ());
+          retval = Array<octave_value>::index (i, resize_ok,
+                                               resize_fill_value ());
       }
       break;
 
     case 2:
       {
         idx_vector i = idx_arg(0).index_vector ();
 
         if (! error_state)
@@ -189,17 +190,17 @@ Cell::index (const octave_value_list& id
               retval = Array<octave_value>::index (i, j, resize_ok,
                                                     resize_fill_value ());
           }
       }
       break;
 
     default:
       {
-        Array<idx_vector> iv (n, 1);
+        Array<idx_vector> iv (dim_vector (n, 1));
 
         for (octave_idx_type i = 0; i < n; i++)
           {
             iv(i) = idx_arg(i).index_vector ();
 
             if (error_state)
               break;
           }
@@ -216,31 +217,31 @@ Cell::index (const octave_value_list& id
 
 void
 Cell::assign (const octave_value_list& idx_arg, const Cell& rhs,
               const octave_value& fill_val)
 
 {
   octave_idx_type len = idx_arg.length ();
 
-  Array<idx_vector> ra_idx (len, 1);
+  Array<idx_vector> ra_idx (dim_vector (len, 1));
 
   for (octave_idx_type i = 0; i < len; i++)
     ra_idx(i) = idx_arg(i).index_vector ();
 
   Array<octave_value>::assign (ra_idx, rhs, fill_val);
 }
 
 void
 Cell::delete_elements (const octave_value_list& idx_arg)
 
 {
   octave_idx_type len = idx_arg.length ();
 
-  Array<idx_vector> ra_idx (len, 1);
+  Array<idx_vector> ra_idx (dim_vector (len, 1));
 
   for (octave_idx_type i = 0; i < len; i++)
     ra_idx.xelem (i) = idx_arg(i).index_vector ();
 
   Array<octave_value>::delete_elements (ra_idx);
 }
 
 octave_idx_type
diff --git a/src/DLD-FUNCTIONS/__glpk__.cc b/src/DLD-FUNCTIONS/__glpk__.cc
--- a/src/DLD-FUNCTIONS/__glpk__.cc
+++ b/src/DLD-FUNCTIONS/__glpk__.cc
@@ -590,17 +590,17 @@ Undocumented internal function.\n\
     {
       error ("__glpk__: invalid value of LB");
       return retval;
     }
 
   double *lb = LB.fortran_vec ();
 
   //-- LB argument, default: Free
-  Array<int> freeLB (mrowsc, 1);
+  Array<int> freeLB (dim_vector (mrowsc, 1));
   for (int i = 0; i < mrowsc; i++)
      {
        if (xisinf (lb[i]))
          {
            freeLB(i) = 1;
            lb[i] = -octave_Inf;
          }
        else
@@ -614,17 +614,17 @@ Undocumented internal function.\n\
   if (error_state || UB.length () < mrowsc)
     {
       error ("__glpk__: invalid value of UB");
       return retval;
     }
 
   double *ub = UB.fortran_vec ();
 
-  Array<int> freeUB (mrowsc, 1);
+  Array<int> freeUB (dim_vector (mrowsc, 1));
   for (int i = 0; i < mrowsc; i++)
     {
       if (xisinf (ub[i]))
         {
           freeUB(i) = 1;
           ub[i] = octave_Inf;
         }
       else
@@ -647,17 +647,17 @@ Undocumented internal function.\n\
   charMatrix VTYPE (args(6).char_matrix_value ());
 
   if (error_state)
     {
       error ("__glpk__: invalid value of VARTYPE");
       return retval;
     }
 
-  Array<int> vartype (mrowsc, 1);
+  Array<int> vartype (dim_vector (mrowsc, 1));
   volatile int isMIP = 0;
   for (int i = 0; i < mrowsc ; i++)
     {
       if (VTYPE(i,0) == 'I')
         {
           isMIP = 1;
           vartype(i) = LPX_IV;
         }
diff --git a/src/DLD-FUNCTIONS/__magick_read__.cc b/src/DLD-FUNCTIONS/__magick_read__.cc
--- a/src/DLD-FUNCTIONS/__magick_read__.cc
+++ b/src/DLD-FUNCTIONS/__magick_read__.cc
@@ -433,17 +433,17 @@ function.  Instead use @code{imread}.\n\
     {
       if (args(2).is_string () && args(2).string_value() == "all")
         all_frames = true;
       else if (args(2).is_real_type ())
         frameidx = args(2).int_vector_value();
     }
   else
     {
-      frameidx = Array<int> (1, 1);
+      frameidx = Array<int> (dim_vector (1, 1));
       frameidx(0) = 1;
     }
 
   std::vector<Magick::Image> imvec;
 
   try
     {
       // Read a file into vector of image objects
@@ -461,17 +461,17 @@ function.  Instead use @code{imread}.\n\
     {
       error ("Magick++ exception: %s", e.what ());
       return output;
     }
 
   int nframes = imvec.size ();
   if (all_frames)
     {
-      frameidx = Array<int> (1, nframes);
+      frameidx = Array<int> (dim_vector (1, nframes));
       for (int i = 0; i < frameidx.length (); i++)
         frameidx(i) = i;
     }
   else
     {
       for (int i = 0; i < frameidx.length (); i++)
         {
           frameidx(i) = frameidx(i) - 1;
@@ -587,17 +587,17 @@ encode_bool_image (std::vector<Magick::I
 {
   unsigned int nframes = 1;
   boolNDArray m = img.bool_array_value ();
 
   dim_vector dsizes = m.dims ();
   if (dsizes.length () == 4)
     nframes = dsizes(3);
 
-  Array<octave_idx_type> idx (dsizes.length (), 1);
+  Array<octave_idx_type> idx (dim_vector (dsizes.length (), 1));
 
   octave_idx_type rows = m.rows ();
   octave_idx_type columns = m.columns ();
 
   for (unsigned int ii = 0; ii < nframes; ii++)
     {
       Magick::Image im(Magick::Geometry (columns, rows), "black");
       im.classType (Magick::DirectClass);
@@ -655,17 +655,17 @@ encode_uint_image (std::vector<Magick::I
   dim_vector dsizes = m.dims ();
   unsigned int nframes = 1;
   if (dsizes.length () == 4)
     nframes = dsizes(3);
 
   bool is_color = ((dsizes.length () > 2) && (dsizes(2) > 2));
   bool has_alpha = (dsizes.length () > 2 && (dsizes(2) == 2 || dsizes(2) == 4));
 
-  Array<octave_idx_type> idx (dsizes.length (), 1);
+  Array<octave_idx_type> idx (dim_vector (dsizes.length (), 1));
   octave_idx_type rows = m.rows ();
   octave_idx_type columns = m.columns ();
 
   // FIXME -- maybe simply using bit shifting would be better?
   unsigned int div_factor = pow (2.0, static_cast<int> (bitdepth)) - 1;
 
   for (unsigned int ii = 0; ii < nframes; ii++)
     {
diff --git a/src/DLD-FUNCTIONS/bsxfun.cc b/src/DLD-FUNCTIONS/bsxfun.cc
--- a/src/DLD-FUNCTIONS/bsxfun.cc
+++ b/src/DLD-FUNCTIONS/bsxfun.cc
@@ -433,17 +433,17 @@ dimensionality as the other matrix.\n\
                   BSXDEF(uint64NDArray);
 
                   octave_value Ac ;
                   octave_value_list idxA;
                   octave_value Bc;
                   octave_value_list idxB;
                   octave_value C;
                   octave_value_list inputs;
-                  Array<int> ra_idx (dvc.length(), 1, 0);
+                  Array<int> ra_idx (dim_vector (dvc.length(), 1), 0);
 
 
                   for (octave_idx_type i = 0; i < ncount; i++)
                     {
                       if (maybe_update_column (Ac, A, dva, dvc, i, idxA))
                         inputs (0) = Ac;
 
                       if (maybe_update_column (Bc, B, dvb, dvc, i, idxB))
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -1183,18 +1183,18 @@ do_mat2cell_nd (const ArrayND& a, const 
   for (int i = 0; i < nd; i++)
     {
       idx[i] = xidx + idxtot;
       prepare_idx (idx[i], i, nd, d);
       idxtot += nidx[i];
     }
 
   OCTAVE_LOCAL_BUFFER_INIT (octave_idx_type, ridx, nd, 0);
-  NoAlias< Array<idx_vector> > ra_idx (1, std::max (nd, a.ndims ()),
-                                       idx_vector::colon);
+  NoAlias< Array<idx_vector> > ra_idx
+    (dim_vector (1, std::max (nd, a.ndims ())), idx_vector::colon);
 
   for (octave_idx_type j = 0; j < retval.numel (); j++)
     {
       octave_quit ();
 
       for (int i = 0; i < nd; i++)
         ra_idx(i) = idx[i][ridx[i]];
 
@@ -1427,17 +1427,17 @@ do_cellslices_nda (const NDA& array,
   else
     {
       const dim_vector dv = array.dims ();
       int ndims = dv.length ();
       if (dim < 0)
         dim = dv.first_non_singleton ();
       ndims = std::max (ndims, dim + 1);
 
-      Array<idx_vector> idx (ndims, 1, idx_vector::colon);
+      Array<idx_vector> idx (dim_vector (ndims, 1), idx_vector::colon);
 
       for (octave_idx_type i = 0; i < n && ! error_state; i++)
         {
           idx(dim) = idx_vector (lb(i) - 1, ub(i));
           retval(i) = array.index (idx);
         }
     }
 
diff --git a/src/DLD-FUNCTIONS/kron.cc b/src/DLD-FUNCTIONS/kron.cc
--- a/src/DLD-FUNCTIONS/kron.cc
+++ b/src/DLD-FUNCTIONS/kron.cc
@@ -53,17 +53,17 @@ static MArray<T>
 kron (const MArray<R>& a, const MArray<T>& b)
 {
   assert (a.ndims () == 2);
   assert (b.ndims () == 2);
 
   octave_idx_type nra = a.rows (), nrb = b.rows ();
   octave_idx_type nca = a.cols (), ncb = b.cols ();
 
-  MArray<T> c (nra*nrb, nca*ncb);
+  MArray<T> c (dim_vector (nra*nrb, nca*ncb));
   T *cv = c.fortran_vec ();
 
   for (octave_idx_type ja = 0; ja < nca; ja++)
     for (octave_idx_type jb = 0; jb < ncb; jb++)
       for (octave_idx_type ia = 0; ia < nra; ia++)
         {
           octave_quit ();
           mx_inline_mul (nrb, cv, a(ia, ja), b.data () + nrb*jb);
@@ -77,17 +77,17 @@ template <class R, class T>
 static MArray<T>
 kron (const MDiagArray2<R>& a, const MArray<T>& b)
 {
   assert (b.ndims () == 2);
 
   octave_idx_type nra = a.rows (), nrb = b.rows (), dla = a.diag_length ();
   octave_idx_type nca = a.cols (), ncb = b.cols ();
 
-  MArray<T> c (nra*nrb, nca*ncb, T());
+  MArray<T> c (dim_vector (nra*nrb, nca*ncb), T());
 
   for (octave_idx_type ja = 0; ja < dla; ja++)
     for (octave_idx_type jb = 0; jb < ncb; jb++)
       {
         octave_quit ();
         mx_inline_mul (nrb, &c.xelem(ja*nrb, ja*ncb + jb), a.dgelem (ja), b.data () + nrb*jb);
       }
 
diff --git a/src/DLD-FUNCTIONS/lookup.cc b/src/DLD-FUNCTIONS/lookup.cc
--- a/src/DLD-FUNCTIONS/lookup.cc
+++ b/src/DLD-FUNCTIONS/lookup.cc
@@ -320,17 +320,17 @@ at most n-1).\n\
                                     y.array_value (),
                                     left_inf, right_inf,
                                     match_idx, match_bool);
 
     }
   else if (str_case)
     {
       Array<std::string> str_table = table.cellstr_value ();
-      Array<std::string> str_y (1, 1);
+      Array<std::string> str_y (dim_vector (1, 1));
 
       if (y.is_cellstr ())
         str_y = y.cellstr_value ();
       else
         str_y(0) = y.string_value ();
 
       Array<octave_idx_type> idx = str_table.lookup (str_y);
       octave_idx_type nval = str_y.numel ();
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -862,17 +862,17 @@ compatibility with @sc{matlab}.\n\
           octave_print_internal (std::cout, (Matrix) alphar, 0);
           std::cout << std::endl << "alphai = " << std::endl;
           octave_print_internal (std::cout, (Matrix) alphai, 0);
           std::cout << std::endl << "beta = " << std::endl;
           octave_print_internal (std::cout, (Matrix) betar, 0);
           std::cout << std::endl;
 #endif
 
-          Array<octave_idx_type> ind (nn, 1);
+          Array<octave_idx_type> ind (dim_vector (nn, 1));
 
           F77_XFCN (dsubsp, DSUBSP,
                     (nn, nn, aa.fortran_vec (), bb.fortran_vec (),
                      ZZ.fortran_vec (), sort_test, eps, ndim, fail,
                      ind.fortran_vec ()));
 
 #ifdef DEBUG
           std::cout << "qz: back from dsubsp: aa=" << std::endl;
diff --git a/src/DLD-FUNCTIONS/sub2ind.cc b/src/DLD-FUNCTIONS/sub2ind.cc
--- a/src/DLD-FUNCTIONS/sub2ind.cc
+++ b/src/DLD-FUNCTIONS/sub2ind.cc
@@ -84,17 +84,17 @@ linear_index = sub2ind ([3, 3], 2, 3)\n\
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin < 2)
     print_usage ();
   else
     {
       dim_vector dv = get_dim_vector (args(0), "sub2ind");
-      Array<idx_vector> idxa (nargin - 1, 1);
+      Array<idx_vector> idxa (dim_vector (nargin-1, 1));
 
       if (! error_state)
         {
           dv = dv.redim (nargin - 1);
           for (int j = 0; j < nargin - 1; j++)
             {
               if (args(j+1).is_numeric_type ())
                 {
diff --git a/src/DLD-FUNCTIONS/tril.cc b/src/DLD-FUNCTIONS/tril.cc
--- a/src/DLD-FUNCTIONS/tril.cc
+++ b/src/DLD-FUNCTIONS/tril.cc
@@ -46,17 +46,17 @@ do_tril (const Array<T>& a, octave_idx_t
   const T *avec = a.fortran_vec ();
   octave_idx_type zero = 0;
 
   if (pack)
     {
       octave_idx_type j1 = std::min (std::max (zero, k), nc); 
       octave_idx_type j2 = std::min (std::max (zero, nr + k), nc);
       octave_idx_type n = j1 * nr + ((j2 - j1) * (nr-(j1-k) + nr-(j2-1-k))) / 2;
-      Array<T> r (n, 1);
+      Array<T> r (dim_vector (n, 1));
       T *rvec = r.fortran_vec ();
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_idx_type ii = std::min (std::max (zero, j - k), nr);
           rvec = std::copy (avec + ii, avec + nr, rvec);
           avec += nr;
         }
 
@@ -87,17 +87,17 @@ do_triu (const Array<T>& a, octave_idx_t
   const T *avec = a.fortran_vec ();
   octave_idx_type zero = 0;
 
   if (pack)
     {
       octave_idx_type j1 = std::min (std::max (zero, k), nc); 
       octave_idx_type j2 = std::min (std::max (zero, nr + k), nc);
       octave_idx_type n = ((j2 - j1) * ((j1+1-k) + (j2-k))) / 2 + (nc - j2) * nr;
-      Array<T> r (n, 1);
+      Array<T> r (dim_vector (n, 1));
       T *rvec = r.fortran_vec ();
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_idx_type ii = std::min (std::max (zero, j + 1 - k), nr);
           rvec = std::copy (avec, avec + ii, rvec);
           avec += nr;
         }
 
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -1630,17 +1630,17 @@ do_cat (const octave_value_list& args, i
 
           octave_value tmp = args (0);
           tmp = tmp.resize (dim_vector (0,0)).resize (dv);
 
           if (error_state)
             return retval;
 
           int dv_len = dv.length ();
-          Array<octave_idx_type> ra_idx (dv_len, 1, 0);
+          Array<octave_idx_type> ra_idx (dim_vector (dv_len, 1), 0);
 
           for (int j = 0; j < n_args; j++)
             {
               // Can't fast return here to skip empty matrices as something
               // like cat(1,[],single([])) must return an empty matrix of
               // the right type.
               tmp = do_cat_op (tmp, args (j), ra_idx);
 
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -1142,17 +1142,17 @@ complete description of the syntax of th
           if (! error_state)
             {
               if (args(1).is_string ())
                 {
                   octave_idx_type count = 0;
 
                   Array<double> size = (nargin == 3)
                     ? args(2).vector_value ()
-                    : Array<double> (1, 1, lo_ieee_inf_value ());
+                    : Array<double> (dim_vector (1, 1), lo_ieee_inf_value ());
 
                   if (! error_state)
                     {
                       octave_value tmp = os.scanf (args(1), size, count, who);
 
                       if (! error_state)
                         {
                           retval(1) = count;
@@ -1227,17 +1227,18 @@ string is treated as an end-of-file cond
               if (os.is_valid ())
                 {
                   if (args(1).is_string ())
                     {
                       octave_idx_type count = 0;
 
                       Array<double> size = (nargin == 3)
                         ? args(2).vector_value ()
-                        : Array<double> (1, 1, lo_ieee_inf_value ());
+                        : Array<double> (dim_vector (1, 1),
+                                         lo_ieee_inf_value ());
 
                       octave_value tmp = os.scanf (args(1), size, count, who);
 
                       if (! error_state)
                         {
                           // FIXME -- is this the right thing to do?
                           // Extract error message first, because getting
                           // position will clear it.
diff --git a/src/gl-render.cc b/src/gl-render.cc
--- a/src/gl-render.cc
+++ b/src/gl-render.cc
@@ -2549,17 +2549,17 @@ opengl_renderer::draw_patch (const patch
   if (has_z)
     for (int i = 0; i < nv; i++)
       clip(i) = is_nan_or_inf (v(i,0), v(i,1), v(i,2));
   else
     for (int i = 0; i < nv; i++)
       clip(i) = is_nan_or_inf (v(i,0), v(i,1), 0);
 
   boolMatrix clip_f (1, nf, false);
-  Array<int> count_f (nf, 1, 0);
+  Array<int> count_f (dim_vector (nf, 1), 0);
 
   for (int i = 0; i < nf; i++)
     {
       bool fclip = false;
       int count = 0;
 
       for (int j = 0; j < fcmax && ! xisnan (f(i,j)); j++, count++)
         fclip = (fclip || clip(int (f(i,j) - 1)));
diff --git a/src/oct-map.cc b/src/oct-map.cc
--- a/src/oct-map.cc
+++ b/src/oct-map.cc
@@ -635,17 +635,17 @@ void permute_to_correct_order1 (const oc
 template <class map>
 static void
 permute_to_correct_order (octave_idx_type n, octave_idx_type nf,
                           octave_idx_type idx, const map *map_list, 
                           map *new_map_list)
 {
   new_map_list[idx] = map_list[idx];
 
-  Array<octave_idx_type> perm (1, nf);
+  Array<octave_idx_type> perm (dim_vector (1, nf));
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       if (i == idx)
          continue;
 
       permute_to_correct_order1 (map_list[idx], map_list[i], new_map_list[i], perm);
 
@@ -883,17 +883,17 @@ octave_map::index (const octave_value_li
 
             retval = index (i, j, resize_ok);
           }
       }
       break;
 
     default:
       {
-        Array<idx_vector> ia (n_idx, 1);
+        Array<idx_vector> ia (dim_vector (n_idx, 1));
 
         for (octave_idx_type i = 0; i < n_idx; i++)
           {
             ia(i) = idx(i).index_vector ();
 
             if (error_state)
               break;
           }
@@ -912,17 +912,17 @@ octave_map
 octave_map::column (octave_idx_type k) const
 {
   return index (idx_vector::colon, k);
 }
 
 octave_map 
 octave_map::page (octave_idx_type k) const
 {
-  static Array<idx_vector> ia (3, 1, idx_vector::colon);
+  static Array<idx_vector> ia (dim_vector (3, 1), idx_vector::colon);
 
   ia(2) = k;
   return index (ia);
 }
 
 void
 octave_map::assign (const idx_vector& i, const octave_map& rhs)
 {
@@ -1077,17 +1077,17 @@ octave_map::assign (const octave_value_l
 
             assign (i, j, rhs);
           }
       }
       break;
 
     default:
       {
-        Array<idx_vector> ia (n_idx, 1);
+        Array<idx_vector> ia (dim_vector (n_idx, 1));
 
         for (octave_idx_type i = 0; i < n_idx; i++)
           {
             ia(i) = idx(i).index_vector ();
 
             if (error_state)
               break;
           }
@@ -1190,17 +1190,17 @@ octave_map::delete_elements (const Array
   optimize_dimensions ();
 }
 
 void
 octave_map::delete_elements (const octave_value_list& idx)
 {
   octave_idx_type n_idx = idx.length ();
 
-  Array<idx_vector> ia (n_idx, 1);
+  Array<idx_vector> ia (dim_vector (n_idx, 1));
 
   for (octave_idx_type i = 0; i < n_idx; i++)
     {
       ia(i) = idx(i).index_vector ();
 
       if (error_state)
         break;
     }
@@ -1693,17 +1693,17 @@ Octave_map
 Octave_map::index (const octave_value_list& idx, bool resize_ok) const
 {
   Octave_map retval;
 
   octave_idx_type n_idx = idx.length ();
 
   if (n_idx > 0)
     {
-      Array<idx_vector> ra_idx (n_idx, 1);
+      Array<idx_vector> ra_idx (dim_vector (n_idx, 1));
 
       for (octave_idx_type i = 0; i < n_idx; i++)
         {
           ra_idx(i) = idx(i).index_vector ();
           if (error_state)
             break;
         }
 
diff --git a/src/oct-obj.h b/src/oct-obj.h
--- a/src/oct-obj.h
+++ b/src/oct-obj.h
@@ -45,17 +45,17 @@ public:
 
   explicit octave_value_list (octave_idx_type n)
     : data (dim_vector (1, n)) { }
 
   octave_value_list (octave_idx_type n, const octave_value& val)
     : data (dim_vector (1, n), val) { }
 
   octave_value_list (const octave_value& tc)
-    : data (1, 1, tc) { }
+    : data (dim_vector (1, 1), tc) { }
 
   octave_value_list (const Array<octave_value>& d)
     : data (d.as_row ()) { }
 
   octave_value_list (const Cell& tc)
     : data (tc.as_row ()) { }
 
   octave_value_list (const octave_value_list& obj)
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -149,17 +149,17 @@ get_size (const Array<double>& size, oct
       nr = get_size (dnr, who);
 
       if (! error_state && dnc >= 0.0)
         nc = get_size (dnc, who);
     }
 }
 
 scanf_format_list::scanf_format_list (const std::string& s)
-  : nconv (0), curr_idx (0), list (16, 1), buf (0)
+  : nconv (0), curr_idx (0), list (dim_vector (16, 1)), buf (0)
 {
   octave_idx_type num_elts = 0;
 
   size_t n = s.length ();
 
   size_t i = 0;
 
   int width = 0;
@@ -569,17 +569,17 @@ scanf_format_list::all_numeric_conversio
     }
   else
     return false;
 }
 
 // Ugh again.
 
 printf_format_list::printf_format_list (const std::string& s)
-  : nconv (0), curr_idx (0), list (16, 1), buf (0)
+  : nconv (0), curr_idx (0), list (dim_vector (16, 1)), buf (0)
 {
   octave_idx_type num_elts = 0;
 
   size_t n = s.length ();
 
   size_t i = 0;
 
   int args = 0;
diff --git a/src/oct-stream.h b/src/oct-stream.h
--- a/src/oct-stream.h
+++ b/src/oct-stream.h
@@ -153,16 +153,17 @@ private:
 
   // Number of conversions specified by this format string, or -1 if
   // invalid conversions have been found.
   octave_idx_type nconv;
 
   // Index to current element;
   octave_idx_type curr_idx;
 
+  // FIXME -- maybe LIST should be a std::list object?
   // List of format elements.
   Array<scanf_format_elt*> list;
 
   // Temporary buffer.
   std::ostringstream *buf;
 
   void add_elt_to_list (int width, bool discard, char type, char modifier,
                         octave_idx_type& num_elts,
@@ -286,16 +287,17 @@ private:
 
   // Number of conversions specified by this format string, or -1 if
   // invalid conversions have been found.
   octave_idx_type nconv;
 
   // Index to current element;
   octave_idx_type curr_idx;
 
+  // FIXME -- maybe LIST should be a std::list object?
   // List of format elements.
   Array<printf_format_elt*> list;
 
   // Temporary buffer.
   std::ostringstream *buf;
 
   void add_elt_to_list (int args, const std::string& flags, int fw,
                         int prec, char type, char modifier,
diff --git a/src/ov-base-mat.cc b/src/ov-base-mat.cc
--- a/src/ov-base-mat.cc
+++ b/src/ov-base-mat.cc
@@ -176,17 +176,17 @@ octave_base_matrix<MT>::do_index_op (con
                   retval = MT (matrix.index (i, j, resize_ok));
               }
           }
       }
       break;
 
     default:
       {
-        Array<idx_vector> idx_vec (n_idx, 1);
+        Array<idx_vector> idx_vec (dim_vector (n_idx, 1));
         bool scalar_opt = n_idx == nd && ! resize_ok;
         const dim_vector dv = matrix.dims ();
 
         for (octave_idx_type i = 0; i < n_idx; i++)
           {
             idx_vec(i) = idx(i).index_vector ();
 
             if (error_state)
@@ -241,17 +241,17 @@ octave_base_matrix<MT>::assign (const oc
             if (! error_state)
               matrix.assign (i, j, rhs);
           }
       }
       break;
 
     default:
       {
-        Array<idx_vector> idx_vec (n_idx, 1);
+        Array<idx_vector> idx_vec (dim_vector (n_idx, 1));
 
         for (octave_idx_type i = 0; i < n_idx; i++)
           {
             idx_vec(i) = idx(i).index_vector ();
 
             if (error_state)
               break;
           }
@@ -325,17 +325,17 @@ octave_base_matrix<MT>::assign (const oc
                   matrix.assign (i, j, mrhs);
               }
           }
       }
       break;
 
     default:
       {
-        Array<idx_vector> idx_vec (n_idx, 1);
+        Array<idx_vector> idx_vec (dim_vector (n_idx, 1));
         bool scalar_opt = n_idx == nd;
         const dim_vector dv = matrix.dims ().redim (n_idx);
 
         for (octave_idx_type i = 0; i < n_idx; i++)
           {
             idx_vec(i) = idx(i).index_vector ();
 
             if (error_state)
@@ -371,17 +371,17 @@ octave_base_matrix<MT>::assign (const oc
 }
 
 template <class MT>
 void
 octave_base_matrix<MT>::delete_elements (const octave_value_list& idx)
 {
   octave_idx_type len = idx.length ();
 
-  Array<idx_vector> ra_idx (len, 1);
+  Array<idx_vector> ra_idx (dim_vector (len, 1));
 
   for (octave_idx_type i = 0; i < len; i++)
     ra_idx(i) = idx(i).index_vector ();
 
   matrix.delete_elements (ra_idx);
 
   // Clear cache.
   clear_cached_info ();
diff --git a/src/ov-base-scalar.cc b/src/ov-base-scalar.cc
--- a/src/ov-base-scalar.cc
+++ b/src/ov-base-scalar.cc
@@ -98,31 +98,31 @@ octave_base_scalar<ST>::subsasgn (const 
 
   return retval;
 }
 
 template <class ST>
 octave_value
 octave_base_scalar<ST>::permute (const Array<int>& vec, bool inv) const
 {
-  return Array<ST> (1, 1, scalar).permute (vec, inv);
+  return Array<ST> (dim_vector (1, 1), scalar).permute (vec, inv);
 }
 
 template <class ST>
 octave_value
 octave_base_scalar<ST>::reshape (const dim_vector& new_dims) const
 {
-  return Array<ST> (1, 1, scalar).reshape (new_dims);
+  return Array<ST> (dim_vector (1, 1), scalar).reshape (new_dims);
 }
 
 template <class ST>
 octave_value
 octave_base_scalar<ST>::diag (octave_idx_type k) const
 {
-  return Array<ST> (1, 1, scalar).diag (k);
+  return Array<ST> (dim_vector (1, 1), scalar).diag (k);
 }
 
 template <class ST>
 bool
 octave_base_scalar<ST>::is_true (void) const
 {
   bool retval = false;
 
diff --git a/src/ov-base-scalar.h b/src/ov-base-scalar.h
--- a/src/ov-base-scalar.h
+++ b/src/ov-base-scalar.h
@@ -104,17 +104,17 @@ public:
       sidx(0) = 0; 
       return octave_value (scalar); 
     }
 
   sortmode is_sorted (sortmode mode = UNSORTED) const
     { return mode ? mode : ASCENDING; }
 
   Array<octave_idx_type> sort_rows_idx (sortmode) const
-    { return Array<octave_idx_type> (1, 0); }
+    { return Array<octave_idx_type> (dim_vector (1, 0)); }
 
   sortmode is_sorted_rows (sortmode mode = UNSORTED) const
     { return mode ? mode : ASCENDING; }
 
   MatrixType matrix_type (void) const { return MatrixType::Diagonal; }
   MatrixType matrix_type (const MatrixType&) const
     { return matrix_type (); }
 
diff --git a/src/ov-perm.cc b/src/ov-perm.cc
--- a/src/ov-perm.cc
+++ b/src/ov-perm.cc
@@ -281,17 +281,17 @@ octave_perm_matrix::load_ascii (std::ist
       is >> tmp;
       if (!is) 
         {
           error ("load: failed to load permutation matrix constant");
           success = false;
         }
       else
         {
-          Array<octave_idx_type> pvec (n, 1);
+          Array<octave_idx_type> pvec (dim_vector (n, 1));
           for (octave_idx_type i = 0; i < n; i++) pvec(i) = tmp(i) - 1;
           matrix = PermMatrix (pvec, colp);
 
           // Invalidate cache. Probably not necessary, but safe.
           dense_cache = octave_value ();
         }
     }
   else
@@ -321,17 +321,17 @@ octave_perm_matrix::load_binary (std::is
                                  oct_mach_info::float_format )
 {
   int32_t sz;
   bool colp;
   if (! (is.read (reinterpret_cast<char *> (&sz), 4)
          && is.read (reinterpret_cast<char *> (&colp), 1)))
     return false;
 
-  MArray<octave_idx_type> m (sz, 1);
+  MArray<octave_idx_type> m (dim_vector (sz, 1));
 
   if (! is.read (reinterpret_cast<char *> (m.fortran_vec ()), m.byte_size ()))
     return false;
 
   if (swap)
     {
       int nel = m.numel ();
       for (int i = 0; i < nel; i++) 
diff --git a/src/ov-range.h b/src/ov-range.h
--- a/src/ov-range.h
+++ b/src/ov-range.h
@@ -145,17 +145,17 @@ public:
   octave_value sort (Array<octave_idx_type>& sidx, octave_idx_type dim = 0,
                      sortmode mode = ASCENDING) const
     { return range.sort (sidx, dim, mode); }
 
   sortmode is_sorted (sortmode mode = UNSORTED) const
     { return range.is_sorted (mode); }
 
   Array<octave_idx_type> sort_rows_idx (sortmode) const
-    { return Array<octave_idx_type> (1, 0); }
+    { return Array<octave_idx_type> (dim_vector (1, 0)); }
 
   sortmode is_sorted_rows (sortmode mode = UNSORTED) const
     { return mode ? mode : ASCENDING; }
 
   builtin_type_t builtin_type (void) const { return btyp_double; }
 
   bool is_real_type (void) const { return true; }
 
diff --git a/src/ov-str-mat.cc b/src/ov-str-mat.cc
--- a/src/ov-str-mat.cc
+++ b/src/ov-str-mat.cc
@@ -118,17 +118,17 @@ octave_char_matrix_str::do_index_op_inte
         if (! error_state)
           retval = octave_value (charNDArray (matrix.index (i, j, resize_ok)),
                                  type);
       }
       break;
 
     default:
       {
-        Array<idx_vector> idx_vec (len, 1);
+        Array<idx_vector> idx_vec (dim_vector (len, 1));
 
         for (octave_idx_type i = 0; i < len; i++)
           idx_vec(i) = idx(i).index_vector ();
 
         if (! error_state)
           retval = octave_value (charNDArray (matrix.index (idx_vec, resize_ok)),
                                  type);
       }
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -2076,17 +2076,17 @@ A(1)\n\
                 {
                   for (int i =  dim + 1; i < nd; i++)
                     rdv(i-1) = rdv(i);
 
                   rdv.resize (nd-1);
                 }
 
               octave_map map (rdv);
-              Array<idx_vector> ia (nd, 1, idx_vector::colon);
+              Array<idx_vector> ia (dim_vector (nd, 1), idx_vector::colon);
 
               for (octave_idx_type i = 0; i < ext; i++)
                 {
                   ia(dim) = i;
                   map.setfield (fields(i), vals.index (ia).reshape (rdv));
                 }
 
               retval = map;
diff --git a/src/ov-typeinfo.cc b/src/ov-typeinfo.cc
--- a/src/ov-typeinfo.cc
+++ b/src/ov-typeinfo.cc
@@ -31,17 +31,16 @@ along with Octave; see the file COPYING.
 
 const int
 octave_value_typeinfo::init_tab_sz (16);
 
 octave_value_typeinfo *
 octave_value_typeinfo::instance (0);
 
 #include <Array.h>
-#include <Array3.h>
 
 bool
 octave_value_typeinfo::instance_ok (void)
 {
   bool retval = true;
   if (! instance)
     instance = new octave_value_typeinfo ();
 
@@ -186,42 +185,44 @@ octave_value_typeinfo::do_register_type 
       return i;
 
   int len = types.length ();
 
   if (i == len)
     {
       len *= 2;
 
-      types.resize (len, 1, std::string ());
+      types.resize (dim_vector (len, 1), std::string ());
 
-      vals.resize (len, 1, octave_value ());
+      vals.resize (dim_vector (len, 1), octave_value ());
 
-      unary_ops.resize (static_cast<int> (octave_value::num_unary_ops), len, 0);
+      unary_ops.resize (dim_vector (octave_value::num_unary_ops, len), 0);
 
       non_const_unary_ops.resize
-        (static_cast<int> (octave_value::num_unary_ops), len, 0);
+        (dim_vector (octave_value::num_unary_ops, len), 0);
 
-      binary_ops.resize (static_cast<int> (octave_value::num_binary_ops),
-                         len, len, 0);
+      binary_ops.resize
+        (dim_vector (octave_value::num_binary_ops, len, len), 0);
 
-      compound_binary_ops.resize (static_cast<int> (octave_value::num_compound_binary_ops),
-                                  len, len, 0);
+      compound_binary_ops.resize
+        (dim_vector (octave_value::num_compound_binary_ops, len, len), 0);
 
-      cat_ops.resize (len, len, 0);
+      cat_ops.resize (dim_vector (len, len), 0);
 
-      assign_ops.resize (static_cast<int> (octave_value::num_assign_ops), len, len, 0);
+      assign_ops.resize
+        (dim_vector (octave_value::num_assign_ops, len, len), 0);
 
-      assignany_ops.resize (static_cast<int> (octave_value::num_assign_ops), len, 0);
+      assignany_ops.resize
+        (dim_vector (octave_value::num_assign_ops, len), 0);
 
-      pref_assign_conv.resize (len, len, -1);
+      pref_assign_conv.resize (dim_vector (len, len), -1);
 
-      type_conv_ops.resize (len, len, 0);
+      type_conv_ops.resize (dim_vector (len, len), 0);
 
-      widening_ops.resize (len, len, 0);
+      widening_ops.resize (dim_vector (len, len), 0);
     }
 
   types (i) = t_name;
 
   vals (i) = val;
 
   num_types++;
 
diff --git a/src/ov-typeinfo.h b/src/ov-typeinfo.h
--- a/src/ov-typeinfo.h
+++ b/src/ov-typeinfo.h
@@ -21,17 +21,16 @@ along with Octave; see the file COPYING.
 */
 
 #if !defined (octave_value_typeinfo_h)
 #define octave_value_typeinfo_h 1
 
 #include <string>
 
 #include "Array.h"
-#include "Array3.h"
 
 #include "ov.h"
 
 class string_vector;
 
 class
 OCTINTERP_API
 octave_value_typeinfo
@@ -46,17 +45,18 @@ public:
 
   typedef octave_value (*binary_class_op_fcn)
     (const octave_value&, const octave_value&);
 
   typedef octave_value (*binary_op_fcn)
     (const octave_base_value&, const octave_base_value&);
 
   typedef octave_value (*cat_op_fcn)
-    (octave_base_value&, const octave_base_value&, const Array<octave_idx_type>& ra_idx);
+    (octave_base_value&, const octave_base_value&,
+     const Array<octave_idx_type>& ra_idx);
 
   typedef octave_value (*assign_op_fcn)
     (octave_base_value&, const octave_value_list&, const octave_base_value&);
 
   typedef octave_value (*assignany_op_fcn)
     (octave_base_value&, const octave_value_list&, const octave_value&);
 
   static bool instance_ok (void);
@@ -187,31 +187,31 @@ public:
   static string_vector installed_type_names (void)
   {
     return instance->do_installed_type_names ();
   }
 
 protected:
 
   octave_value_typeinfo (void)
-    : num_types (0), types (init_tab_sz, 1, std::string ()),
-      vals (init_tab_sz, 1),
-      unary_class_ops (octave_value::num_unary_ops, 1, 0),
-      unary_ops (octave_value::num_unary_ops, init_tab_sz, 0),
-      non_const_unary_ops (octave_value::num_unary_ops, init_tab_sz, 0),
-      binary_class_ops (octave_value::num_binary_ops, 1, 0),
-      binary_ops (octave_value::num_binary_ops, init_tab_sz, init_tab_sz, 0),
-      compound_binary_class_ops (octave_value::num_compound_binary_ops, 1, 0),
-      compound_binary_ops (octave_value::num_compound_binary_ops, init_tab_sz, init_tab_sz, 0),
-      cat_ops (init_tab_sz, init_tab_sz, 0),
-      assign_ops (octave_value::num_assign_ops, init_tab_sz, init_tab_sz, 0),
-      assignany_ops (octave_value::num_assign_ops, init_tab_sz, 0),
-      pref_assign_conv (init_tab_sz, init_tab_sz, -1),
-      type_conv_ops (init_tab_sz, init_tab_sz, 0),
-      widening_ops (init_tab_sz, init_tab_sz, 0)  { }
+    : num_types (0), types (dim_vector (init_tab_sz, 1), std::string ()),
+      vals (dim_vector (init_tab_sz, 1)),
+      unary_class_ops (dim_vector (octave_value::num_unary_ops, 1), 0),
+      unary_ops (dim_vector (octave_value::num_unary_ops, init_tab_sz), 0),
+      non_const_unary_ops (dim_vector (octave_value::num_unary_ops, init_tab_sz), 0),
+      binary_class_ops (dim_vector (octave_value::num_binary_ops, 1), 0),
+      binary_ops (dim_vector (octave_value::num_binary_ops, init_tab_sz, init_tab_sz), 0),
+      compound_binary_class_ops (dim_vector (octave_value::num_compound_binary_ops, 1), 0),
+      compound_binary_ops (dim_vector (octave_value::num_compound_binary_ops, init_tab_sz, init_tab_sz), 0),
+      cat_ops (dim_vector (init_tab_sz, init_tab_sz), 0),
+      assign_ops (dim_vector (octave_value::num_assign_ops, init_tab_sz, init_tab_sz), 0),
+      assignany_ops (dim_vector (octave_value::num_assign_ops, init_tab_sz), 0),
+      pref_assign_conv (dim_vector (init_tab_sz, init_tab_sz), -1),
+      type_conv_ops (dim_vector (init_tab_sz, init_tab_sz), 0),
+      widening_ops (dim_vector (init_tab_sz, init_tab_sz), 0)  { }
 
 private:
 
   static const int init_tab_sz;
 
   static octave_value_typeinfo *instance;
 
   int num_types;
@@ -223,25 +223,25 @@ private:
   Array<void *> unary_class_ops;
 
   Array<void *> unary_ops;
 
   Array<void *> non_const_unary_ops;
 
   Array<void *> binary_class_ops;
 
-  Array3<void *> binary_ops;
+  Array<void *> binary_ops;
 
   Array<void *> compound_binary_class_ops;
 
-  Array3<void *> compound_binary_ops;
+  Array<void *> compound_binary_ops;
 
   Array<void *> cat_ops;
 
-  Array3<void *> assign_ops;
+  Array<void *> assign_ops;
 
   Array<void *> assignany_ops;
 
   Array<int> pref_assign_conv;
 
   Array<void *> type_conv_ops;
 
   Array<void *> widening_ops;
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -2006,17 +2006,17 @@ octave_print_internal (std::ostream& os,
         print_empty_nd_array (os, nda.dims (), pr_as_read_syntax); \
       else \
         { \
  \
           int ndims = nda.ndims (); \
  \
           dim_vector dims = nda.dims (); \
  \
-          Array<octave_idx_type> ra_idx (ndims, 1, 0); \
+          Array<octave_idx_type> ra_idx (dim_vector (ndims, 1), 0);\
  \
           octave_idx_type m = 1; \
  \
           for (int i = 2; i < ndims; i++) \
             m *= dims(i); \
  \
           octave_idx_type nr = dims(0); \
           octave_idx_type nc = dims(1); \
@@ -2041,26 +2041,26 @@ octave_print_internal (std::ostream& os,
                         buf << ","; \
                       else \
                         buf << ")"; \
                     } \
  \
                   nm += buf.str (); \
                 } \
  \
-              Array<idx_vector> idx (ndims, 1); \
+              Array<idx_vector> idx (dim_vector (ndims, 1)); \
  \
               idx(0) = idx_vector (':'); \
               idx(1) = idx_vector (':'); \
  \
               for (int k = 2; k < ndims; k++) \
                 idx(k) = idx_vector (ra_idx(k)); \
  \
               octave_value page \
-                = MAT_T (Array<ELT_T> (nda.index (idx), nr, nc)); \
+                = MAT_T (Array<ELT_T> (nda.index (idx), dim_vector (nr, nc))); \
  \
               if (i != m - 1) \
                 { \
                   page.print_with_name (os, nm); \
                 } \
               else \
                 { \
                   page.print_name_tag (os, nm); \
@@ -2850,17 +2850,17 @@ octave_print_internal (std::ostream& os,
       os << nda(0);
     }
   else
     {
       int ndims = nda.ndims ();
 
       dim_vector dims = nda.dims ();
 
-      Array<octave_idx_type> ra_idx (ndims, 1, 0);
+      Array<octave_idx_type> ra_idx (dim_vector (ndims, 1), 0);
 
       octave_idx_type m = 1;
 
       for (int i = 2; i < ndims; i++)
         m *= dims(i);
 
       octave_idx_type nr = dims(0);
       octave_idx_type nc = dims(1);
@@ -2883,25 +2883,25 @@ octave_print_internal (std::ostream& os,
                     buf << ",";
                   else
                     buf << ")";
                 }
 
               nm += buf.str ();
             }
 
-          Array<idx_vector> idx (ndims, 1);
+          Array<idx_vector> idx (dim_vector (ndims, 1));
 
           idx(0) = idx_vector (':');
           idx(1) = idx_vector (':');
 
           for (int k = 2; k < ndims; k++)
             idx(k) = idx_vector (ra_idx(k));
 
-          Array<std::string> page (nda.index (idx), nr, nc);
+          Array<std::string> page (nda.index (idx), dim_vector (nr, nc));
 
           // FIXME -- need to do some more work to put these
           // in neatly aligned columns...
 
           octave_idx_type n_rows = page.rows ();
           octave_idx_type n_cols = page.cols ();
 
           os << nm << " =\n\n";
@@ -3115,17 +3115,17 @@ octave_print_internal_template (std::ost
   if (nda.is_empty ())
     print_empty_nd_array (os, nda.dims (), pr_as_read_syntax);
   else if (nda.length () == 1)
     octave_print_internal_template (os, nda(0), pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
       int ndims = nda.ndims ();
 
-      Array<octave_idx_type> ra_idx (ndims, 1, 0);
+      Array<octave_idx_type> ra_idx (dim_vector (ndims, 1), 0);
 
       dim_vector dims = nda.dims ();
 
       octave_idx_type m = 1;
 
       for (int i = 2; i < ndims; i++)
         m *= dims(i);
 
@@ -3150,25 +3150,25 @@ octave_print_internal_template (std::ost
                     buf << ")";
                 }
 
               nm += buf.str ();
 
               os << nm << " =\n\n";
             }
 
-          Array<idx_vector> idx (ndims, 1);
+          Array<idx_vector> idx (dim_vector (ndims, 1));
 
           idx(0) = idx_vector (':');
           idx(1) = idx_vector (':');
 
           for (int k = 2; k < ndims; k++)
             idx(k) = idx_vector (ra_idx(k));
 
-          Array<T> page (nda.index (idx), nr, nc);
+          Array<T> page (nda.index (idx), dim_vector (nr, nc));
 
           for (octave_idx_type ii = 0; ii < nr; ii++)
             {
               for (octave_idx_type jj = 0; jj < nc; jj++)
                 {
                   octave_quit ();
 
                   pr_plus_format (os, page(ii,jj));
@@ -3186,17 +3186,17 @@ octave_print_internal_template (std::ost
         }
     }
   else
     {
       int ndims = nda.ndims ();
 
       dim_vector dims = nda.dims ();
 
-      Array<octave_idx_type> ra_idx (ndims, 1, 0);
+      Array<octave_idx_type> ra_idx (dim_vector (ndims, 1), 0);
 
       octave_idx_type m = 1;
 
       for (int i = 2; i < ndims; i++)
         m *= dims(i);
 
       octave_idx_type nr = dims(0);
       octave_idx_type nc = dims(1);
@@ -3255,25 +3255,25 @@ octave_print_internal_template (std::ost
                     buf << ")";
                 }
 
               nm += buf.str ();
 
               os << nm << " =\n\n";
             }
 
-          Array<idx_vector> idx (ndims, 1);
+          Array<idx_vector> idx (dim_vector (ndims, 1));
 
           idx(0) = idx_vector (':');
           idx(1) = idx_vector (':');
 
           for (int k = 2; k < ndims; k++)
             idx(k) = idx_vector (ra_idx(k));
 
-          Array<T> page (nda.index (idx), nr, nc);
+          Array<T> page (nda.index (idx), dim_vector (nr, nc));
 
           if (free_format)
             {
               if (pr_as_read_syntax)
                 os << "[\n";
 
               for (octave_idx_type ii = 0; ii < nr; ii++)
                 {
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -1052,17 +1052,18 @@ tree_matrix::rvalue1 (int)
             }
 
           if (! error_state)
             {
               // Now, extract the values from the individual elements and
               // insert them in the result matrix.
 
               int dv_len = dv.length ();
-              Array<octave_idx_type> ra_idx (dv_len > 1 ? dv_len : 2, 1, 0);
+              octave_idx_type ntmp = dv_len > 1 ? dv_len : 2;
+              Array<octave_idx_type> ra_idx (dim_vector (ntmp, 1), 0);
 
               for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
                 {
                   octave_quit ();
 
                   tm_row_const row = *p;
 
                   for (tm_row_const::iterator q = row.begin ();
diff --git a/src/txt-eng-ft.cc b/src/txt-eng-ft.cc
--- a/src/txt-eng-ft.cc
+++ b/src/txt-eng-ft.cc
@@ -391,47 +391,47 @@ ft_render::render (text_element* elt, Ma
       elt->accept (*this);
 
       switch (rotation)
         {
         case ROTATION_0:
           break;
         case ROTATION_90:
             {
-              Array<octave_idx_type> perm (3, 1);
+              Array<octave_idx_type> perm (dim_vector (3, 1));
               perm(0) = 0;
               perm(1) = 2;
               perm(2) = 1;
               pixels = pixels.permute (perm);
 
-              Array<idx_vector> idx (3, 1);
+              Array<idx_vector> idx (dim_vector (3, 1));
               idx(0) = idx_vector (':');
               idx(1) = idx_vector (pixels.dim2()-1, -1, -1);
               idx(2) = idx_vector (':');
               pixels = uint8NDArray (pixels.index (idx));
             }
           break;
         case ROTATION_180:
             {
-              Array<idx_vector> idx (3, 1);
+              Array<idx_vector> idx (dim_vector (3, 1));
               idx(0) = idx_vector (':');
               idx(1) = idx_vector (pixels.dim2()-1, -1, -1);
               idx(2)=  idx_vector (pixels.dim3()-1, -1, -1);
               pixels = uint8NDArray (pixels.index (idx));
             }
           break;
         case ROTATION_270:
             {
-              Array<octave_idx_type> perm (3, 1);
+              Array<octave_idx_type> perm (dim_vector (3, 1));
               perm(0) = 0;
               perm(1) = 2;
               perm(2) = 1;
               pixels = pixels.permute (perm);
 
-              Array<idx_vector> idx (3, 1);
+              Array<idx_vector> idx (dim_vector (3, 1));
               idx(0) = idx_vector (':');
               idx(1) = idx_vector (':');
               idx(2) = idx_vector (pixels.dim3()-1, -1, -1);
               pixels = uint8NDArray (pixels.index (idx));
             }
           break;
         }
     }
