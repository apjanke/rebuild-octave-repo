# HG changeset patch
# User jwe
# Date 941233171 0
#      Fri Oct 29 21:39:31 1999 +0000
# Node ID 2efa28a91e7acae1df0ee4c3b9dbd3f056d59bc8
# Parent  b3c323c439796481d46eb809733e9dc4bb94977f
[project @ 1999-10-29 21:39:20 by jwe]

diff --git a/libcruft/ChangeLog b/libcruft/ChangeLog
--- a/libcruft/ChangeLog
+++ b/libcruft/ChangeLog
@@ -1,8 +1,15 @@
+1999-10-29  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* misc/lo-error.cc (current_liboctave_warning_handler): Define	here.
+	(set_liboctave_warning_handler): New function.
+	(liboctave_warning): Ditto.
+	* misc/lo-error.h: Provide declararations for them here.
+
 1999-10-19  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Makefile.in (dist): Use `$(MAKE) -C dir' instead of `cd dir;
 	$(MAKE); cd ..'.
 
 1999-10-01  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* dassl/dpotrf.f, dassl/dpotf2.f: Move to lapack subdirectory.
diff --git a/libcruft/Makerules.in b/libcruft/Makerules.in
--- a/libcruft/Makerules.in
+++ b/libcruft/Makerules.in
@@ -9,23 +9,27 @@
 # jwe@bevo.che.wisc.edu
 # University of Wisconsin-Madison
 # Department of Chemical Engineering
 
 SOURCES = *.f
 
 DISTFILES = Makefile.in $(SOURCES) $(SPECIAL)
 
-CRUFT_FSRC = $(wildcard $(srcdir)/*.f)
-CRUFT_BASE = $(notdir $(CRUFT_FSRC))
-CRUFT_OBJ = $(patsubst %.f, %.o, $(CRUFT_BASE))
+CRUFT_FSRC = $(wildcard $(srcdir)/*.f) \
+             $(wildcard $(srcdir)/*.c) \
+             $(wildcard $(srcdir)/*.cc)
+CRUFT_BASE = $(basename $(notdir $(CRUFT_SRC)) )
+CRUFT_OBJ = $(addsuffix .o, $(CRUFT_BASE) )
 
 ifeq ($(SHARED_LIBS), true)
   ifdef FPICFLAG
     CRUFT_PICOBJ := $(addprefix pic/, $(CRUFT_OBJ))
+  else
+    CRUFT_PICOBJ := $(CRUFT_OBJ)
   endif
 endif
 
 CWD = $(shell pwd)
 THISDIR = $(notdir $(CWD))
 
 LIBCRUFT := ../libcruft.$(LIBEXT)
 
diff --git a/libcruft/misc/lo-error.c b/libcruft/misc/lo-error.c
--- a/libcruft/misc/lo-error.c
+++ b/libcruft/misc/lo-error.c
@@ -29,17 +29,22 @@ Software Foundation, 59 Temple Place - S
 #include <stdlib.h>
 
 #include "lo-error.h"
 
 /* Having this file in this directory is a kluge to avoid unresolved
    symbol errors when creating shared versions of libcruft. */
 
 /* Pointer to the current error handling function. */
-liboctave_error_handler current_liboctave_error_handler = liboctave_fatal;
+liboctave_error_handler current_liboctave_error_handler
+  = liboctave_fatal;
+
+/* Pointer to the current warning handler. */
+liboctave_warning_handler current_liboctave_warning_handler
+  = liboctave_warning; 
 
 static void
 verror (const char *name, const char *fmt, va_list args)
 {
   if (name)
     fprintf (stderr, "%s: ", name);
 
   vfprintf (stderr, fmt, args);
@@ -52,24 +57,42 @@ set_liboctave_error_handler (liboctave_e
 {
   if (f)
     current_liboctave_error_handler = f;
   else
     current_liboctave_error_handler = liboctave_fatal;
 }
 
 void
+set_liboctave_warning_handler (liboctave_warning_handler f)
+{
+  if (f)
+    current_liboctave_warning_handler = f;
+  else
+    current_liboctave_warning_handler = liboctave_warning;
+}
+
+void
 liboctave_fatal (const char *fmt, ...)
 {
   va_list args;
   va_start (args, fmt);
   verror ("fatal", fmt, args);
   va_end (args);
 
   exit (1);
 }
 
+void
+liboctave_warning (const char *fmt, ...)
+{
+  va_list args;
+  va_start (args, fmt);
+  verror ("warning", fmt, args);
+  va_end (args);
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/libcruft/misc/lo-error.h b/libcruft/misc/lo-error.h
--- a/libcruft/misc/lo-error.h
+++ b/libcruft/misc/lo-error.h
@@ -24,24 +24,32 @@ Software Foundation, 59 Temple Place - S
 #define octave_liboctave_error_h 1
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 extern void liboctave_fatal (const char *fmt, ...) GCC_ATTR_NORETURN;
 
+extern void liboctave_warning (const char *fmt, ...);
+
 typedef void (*liboctave_error_handler) (const char *, ...);
 
-/* Would be nice to make this private, but we want to share it among
-   all the liboctave classes. */
+typedef void (*liboctave_warning_handler) (const char *, ...);
+
+/* Would be nice to make these pointers private, but we want to share
+   them among all the liboctave classes. */
 extern liboctave_error_handler current_liboctave_error_handler;
 
+extern liboctave_warning_handler current_liboctave_warning_handler;
+
 extern void set_liboctave_error_handler (liboctave_error_handler f);
 
+extern void set_liboctave_warning_handler (liboctave_warning_handler f);
+
 #ifdef __cplusplus
 }
 #endif
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,13 @@
+1999-10-29  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* oct-shlib.cc, oct-shlib.h: New files.
+	* Makefile.in (INCLUDES, SOURCES): Add them to the lists.
+
 1999-10-26  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* CRowVector.cc (linspace): Allow npoints == 1 if x1 == x2.
 	* dRowVector.cc (linspace): Ditto.
 
 	* oct-time.cc (Fstrftime): Don't save or delete tm_zone.
 	(octave_time::octave_time (const octave_base_tm&)): Likewise.
 
diff --git a/liboctave/Makefile.in b/liboctave/Makefile.in
--- a/liboctave/Makefile.in
+++ b/liboctave/Makefile.in
@@ -42,18 +42,18 @@ MX_OP_INC := mx-cdm-cm.h mx-cdm-cs.h mx-
 
 INCLUDES := Bounds.h CollocWt.h DAE.h DAEFunc.h DASSL.h FEGrid.h \
 	LinConst.h LP.h LPsolve.h LSODE.h NLConst.h NLEqn.h NLFunc.h \
 	NLP.h ODE.h ODEFunc.h Objective.h QP.h Quad.h Range.h base-de.h \
 	base-min.h byte-swap.h cmd-edit.h cmd-hist.h data-conv.h \
 	dir-ops.h file-ops.h file-stat.h getopt.h glob-match.h \
 	idx-vector.h lo-ieee.h lo-mappers.h lo-specfun.h lo-sysdep.h \
 	lo-utils.h mach-info.h oct-alloc.h oct-cmplx.h oct-env.h \
-	oct-group.h oct-passwd.h oct-syscalls.h oct-time.h pathlen.h \
-	pathsearch.h prog-args.h statdefs.h str-vec.h sun-utils.h \
+	oct-group.h oct-passwd.h oct-shlib.h oct-syscalls.h oct-time.h \
+	pathlen.h pathsearch.h prog-args.h statdefs.h str-vec.h sun-utils.h \
 	sysdir.h systime.h syswait.h \
 	$(MATRIX_INC) \
 	$(MX_OP_INC)
 
 TEMPLATE_SRC := Array.cc Array2.cc Array3.cc DiagArray2.cc \
 	MArray.cc MArray2.cc MDiagArray2.cc base-lu.cc
 
 TI_SRC := Array-C.cc Array-b.cc Array-ch.cc Array-i.cc Array-d.cc \
@@ -75,17 +75,17 @@ MX_OP_SRC := mx-cdm-cm.cc mx-cdm-cs.cc m
 	mx-m-cs.cc mx-m-dm.cc mx-s-cdm.cc mx-s-cm.cc mx-s-dm.cc
 
 SOURCES := Bounds.cc CollocWt.cc DAE.cc DASSL.cc FEGrid.cc LinConst.cc \
 	LPsolve.cc LSODE.cc NLEqn.cc Quad.cc Range.cc cmd-edit.cc \
 	cmd-hist.cc data-conv.cc dir-ops.cc f2c-main.c file-ops.cc \
 	file-stat.cc filemode.c getopt.c getopt1.c glob-match.cc \
 	idx-vector.cc lo-ieee.cc lo-mappers.cc lo-specfun.cc \
 	lo-sysdep.cc lo-utils.cc mach-info.cc mkdir.c oct-alloc.cc \
-	oct-env.cc oct-group.cc oct-passwd.cc oct-syscalls.cc \
+	oct-env.cc oct-group.cc oct-passwd.cc oct-shlib.cc oct-syscalls.cc \
 	oct-time.cc pathsearch.cc prog-args.cc rename.c rmdir.c \
 	strftime.c str-vec.cc tempname.c tempnam.c \
 	$(TEMPLATE_SRC) \
 	$(TI_SRC) \
 	$(MATRIX_SRC) \
 	$(MX_OP_SRC)
 
 EXTRAS := mx-inlines.cc
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,10 +1,77 @@
+1999-10-29  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* defun-dld.h (INSTALL_DLD_FCNS, INSTALL_DLD_FCN): Delete definitions.
+	* DLD-FUNCTIONS/dassl.cc: Don't use INSTALL_DLD_FCN or
+	INSTALL_DLD_FCNS macros.  They are not necessary with the new code
+	in dynamic-ld.cc.
+	* DLD-FUNCTIONS/lsode.cc: Ditto.
+	* DLD-FUNCTIONS/fsolve.cc: Ditto.
+	* DLD-FUNCTIONS/quad.cc: Ditto.
+	* DLD-FUNCTIONS/time.cc: Ditto.
+	* DLD-FUNCTIONS/besselj.cc: Ditto.
+	* DLD-FUNCTIONS/getgrent.cc: Ditto.
+	* DLD-FUNCTIONS/getpwent.cc: Ditto.
+	* DLD-FUNCTIONS/inv.cc: Ditto.
+	* DLD-FUNCTIONS/log.cc: Ditto.
+	* DLD-FUNCTIONS/minmax.cc: Ditto.
+	* DLD-FUNCTIONS/rand.cc: Ditto.
+
+	* dynamic-ld.cc, dynamic-ld.h: Major rewrite to allow reloading of
+	dynamically linked functions.
+
+	* symtab.cc (symbol_record::replace_all_defs): Don't allow top
+	definition to be NULL.
+	(symbol_table::clear): Allow dynamically linked functions to be
+	cleared.
+
+	* symtab.h (TYPE): New enum value, DLD_FUCTION.
+	(symbol_type): Now 8 bits wide.
+	(SYMTAB_ALL_TYPES): Include DLD_FUNCTION.
+	(symbol_record::symbol_def::is_function): Also recognize dld functions.
+	(symbol_record::symbol_def::is_dld_function): New function.
+	(symbol_record::is_dld_function): Ditto.
+
+	* defun.cc (install_dld_function): New function.
+	* defun-int.h: Provide declaration here.
+	(octave_dld_fcn_installer): New typedef.
+	(DEFINE_FUN_INSTALLER_FUN): Installer function now takes an
+	oct_shlib object as an arg.  Allow installation of a function to
+	happen more than once.
+
+	* octave.cc (initialize_error_handlers): Call
+	set_liboctave_warning_handler here too.
+
+	* ov-builtin.h (is_builtin_function): Return true.
+	Data member is now protected, not private.
+
+	* ov-fcn.h (is_dynamically_loaded_function): New predicate.
+	(unload): New function.
+	Data members are now protected, not private.
+
+	* ov.h (is_builtin_function, is_dld_function): New predicates.
+	* ov-base.h (is_builtin_function, is_dld_function): Ditto.
+
+	* parse.y (Vwarn_reload_forces_clear): New static flag.
+	(warn_reload_forces_clear): New function.
+	(symbols_of_parse): DEFVAR warn_reload_forces_clear.
+
+	* variables.cc (Fclear): Look for dld functions too.
+
+	* ov-dld-fcn.cc, src/ov-dld-fcn.h: New files.
+	* Makefile.in (OV_INCLUDES, OV_SRC): Add them to the lists.
+
+	* Makefile.in (DEFVAR_PATTERN): Also match DEFCONSTX.
+
 1999-10-26  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* DLList.h, DLList.cc: New files.
+	* Makefile.in (INCLUDES, DIST_SRC): Add them to the lists.
+
 	* DLD-FUNCTIONS/lsode.cc (Flsode): Be sure to call
 	unwind_protect::run_frame before returning.
 	* DLD-FUNCTIONS/quad.cc (Fquad): Likewise.
 	* DLD-FUNCTIONS/fsolve.cc (Ffsolve): Likewise.
 	* DLD-FUNCTIONS/dassl.cc (Fdassl): Likewise.
 
 	* load-save.cc (read_mat_ascii_data): When reading from
 	tmp_stream, check its state, not the state of is.
diff --git a/src/DLD-FUNCTIONS/besselj.cc b/src/DLD-FUNCTIONS/besselj.cc
--- a/src/DLD-FUNCTIONS/besselj.cc
+++ b/src/DLD-FUNCTIONS/besselj.cc
@@ -506,20 +506,13 @@ the same size as the result.\n\
 	}
     }
   else
     print_usage ("airy");
 
   return retval;
 }
 
-INSTALL_DLD_FCNS (INSTALL_DLD_FCN (besselj);
-		  INSTALL_DLD_FCN (bessely);
-		  INSTALL_DLD_FCN (besseli);
-		  INSTALL_DLD_FCN (besselk);
-		  INSTALL_DLD_FCN (besselh);
-		  INSTALL_DLD_FCN (airy);)
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/dassl.cc b/src/DLD-FUNCTIONS/dassl.cc
--- a/src/DLD-FUNCTIONS/dassl.cc
+++ b/src/DLD-FUNCTIONS/dassl.cc
@@ -386,16 +386,13 @@ to the shortest match.")
 	}
     }
 
   print_usage ("dassl_options");
 
   return retval;
 }
 
-INSTALL_DLD_FCNS (INSTALL_DLD_FCN (dassl);
-		  INSTALL_DLD_FCN (dassl_options);)
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/fsolve.cc b/src/DLD-FUNCTIONS/fsolve.cc
--- a/src/DLD-FUNCTIONS/fsolve.cc
+++ b/src/DLD-FUNCTIONS/fsolve.cc
@@ -357,16 +357,13 @@ to the shortest match.")
 	}
     }
 
   print_usage ("fsolve_options");
 
   return retval;
 }
 
-INSTALL_DLD_FCNS (INSTALL_DLD_FCN (fsolve);
-		  INSTALL_DLD_FCN (fsolve_options);)
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/getgrent.cc b/src/DLD-FUNCTIONS/getgrent.cc
--- a/src/DLD-FUNCTIONS/getgrent.cc
+++ b/src/DLD-FUNCTIONS/getgrent.cc
@@ -211,19 +211,13 @@ Close the group database.\n\
       retval(1) = msg;
     }
   else
     print_usage ("endgrent");
 
   return retval;
 }
 
-INSTALL_DLD_FCNS (INSTALL_DLD_FCN (getgrent);
-		  INSTALL_DLD_FCN (getgrgid);
-		  INSTALL_DLD_FCN (getgrnam);
-		  INSTALL_DLD_FCN (setgrent);
-		  INSTALL_DLD_FCN (endgrent);)
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/getpwent.cc b/src/DLD-FUNCTIONS/getpwent.cc
--- a/src/DLD-FUNCTIONS/getpwent.cc
+++ b/src/DLD-FUNCTIONS/getpwent.cc
@@ -215,19 +215,13 @@ Close the password database.\n\
       retval(1) = msg;
     }
   else
     print_usage ("endpwent");
 
   return retval;
 }
 
-INSTALL_DLD_FCNS (INSTALL_DLD_FCN (getpwent);
-		  INSTALL_DLD_FCN (getpwuid);
-		  INSTALL_DLD_FCN (getpwnam);
-		  INSTALL_DLD_FCN (setpwent);
-		  INSTALL_DLD_FCN (endpwent);)
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/inv.cc b/src/DLD-FUNCTIONS/inv.cc
--- a/src/DLD-FUNCTIONS/inv.cc
+++ b/src/DLD-FUNCTIONS/inv.cc
@@ -106,16 +106,13 @@ DEFUN_DLD (inv, args, ,
 // dynamic linking.
 
 DEFUN_DLD (inverse, args, nargout,
   "inverse (X): inverse of a square matrix")
 {
   return Finv (args, nargout);
 }
 
-INSTALL_DLD_FCNS (INSTALL_DLD_FCN (inv);
-		  INSTALL_DLD_FCN (inverse);)
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/log.cc b/src/DLD-FUNCTIONS/log.cc
--- a/src/DLD-FUNCTIONS/log.cc
+++ b/src/DLD-FUNCTIONS/log.cc
@@ -254,16 +254,13 @@ DEFUN_DLD (sqrtm, args, ,
   else
     {
       gripe_wrong_type_arg ("sqrtm", arg);
     }
 
   return retval;
 }
 
-INSTALL_DLD_FCNS (INSTALL_DLD_FCN (logm);
-		  INSTALL_DLD_FCN (sqrtm);)
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/lsode.cc b/src/DLD-FUNCTIONS/lsode.cc
--- a/src/DLD-FUNCTIONS/lsode.cc
+++ b/src/DLD-FUNCTIONS/lsode.cc
@@ -487,16 +487,13 @@ to the shortest match.")
 	}
     }
 
   print_usage ("lsode_options");
 
   return retval;
 }
 
-INSTALL_DLD_FCNS (INSTALL_DLD_FCN (lsode);
-		  INSTALL_DLD_FCN (lsode_options);)
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/minmax.cc b/src/DLD-FUNCTIONS/minmax.cc
--- a/src/DLD-FUNCTIONS/minmax.cc
+++ b/src/DLD-FUNCTIONS/minmax.cc
@@ -696,16 +696,13 @@ DEFUN_DLD (max, args, nargout,
 	}
     }
   else
     panic_impossible ();
 
   return retval;
 }
 
-INSTALL_DLD_FCNS (INSTALL_DLD_FCN (min);
-		  INSTALL_DLD_FCN (max);)
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/quad.cc b/src/DLD-FUNCTIONS/quad.cc
--- a/src/DLD-FUNCTIONS/quad.cc
+++ b/src/DLD-FUNCTIONS/quad.cc
@@ -414,16 +414,13 @@ to the shortest match.")
 	}
     }
 
   print_usage ("quad_options");
 
   return retval;
 }
 
-INSTALL_DLD_FCNS (INSTALL_DLD_FCN (quad);
-		  INSTALL_DLD_FCN (quad_options);)
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -403,16 +403,13 @@ See also: rand")
       retval = do_rand (args, nargin);
 
       unwind_protect::run_frame ("randn");
     }
 
   return retval;
 }
 
-INSTALL_DLD_FCNS (INSTALL_DLD_FCN (rand);
-		  INSTALL_DLD_FCN (randn);)
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/time.cc b/src/DLD-FUNCTIONS/time.cc
--- a/src/DLD-FUNCTIONS/time.cc
+++ b/src/DLD-FUNCTIONS/time.cc
@@ -391,19 +391,13 @@ Year (1970-).\n\
 	error ("strftime: expecting format string as first argument");
     }
   else
     print_usage ("strftime");
 
   return retval;
 }
 
-INSTALL_DLD_FCNS (INSTALL_DLD_FCN (time);
-		  INSTALL_DLD_FCN (gmtime);
-		  INSTALL_DLD_FCN (localtime);
-		  INSTALL_DLD_FCN (mktime);
-		  INSTALL_DLD_FCN (strftime);)
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -69,25 +69,26 @@ ifeq ($(OCTAVE_LITE), true)
 else
   DLD_STATIC_OBJ := $(DLD_OBJ)
 endif
 
 OV_INCLUDES := ov-re-mat.h ov-cx-mat.h ov-ch-mat.h ov-list.h \
 	ov-struct.h ov-scalar.h ov-range.h ov-complex.h ov-va-args.h \
 	ov-colon.h ov-base.h ov-base-mat.h ov-base-scalar.h \
 	ov-str-mat.h ov-bool-mat.h ov-bool.h ov-file.h ov.h \
-	ov-fcn.h ov-builtin.h ov-mapper.h ov-usr-fcn.h ov-typeinfo.h
+	ov-fcn.h ov-builtin.h ov-dld-fcn.h ov-mapper.h ov-usr-fcn.h \
+	ov-typeinfo.h
 
 PT_INCLUDES := pt.h pt-all.h pt-arg-list.h pt-assign.h pt-binop.h \
 	pt-check.h pt-cmd.h pt-colon.h pt-const.h pt-decl.h \
 	pt-except.h pt-exp.h pt-id.h pt-idx.h pt-indir.h \
 	pt-jump.h pt-loop.h pt-mat.h pt-misc.h pt-plot.h \
 	pt-pr-code.h pt-select.h pt-stmt.h pt-unop.h pt-walk.h
 
-INCLUDES := BaseSLList.h Map.h Pix.h SLList.h SLStack.h Stack.h \
+INCLUDES := BaseSLList.h DLList.h Map.h Pix.h SLList.h SLStack.h Stack.h \
 	defun-dld.h defun-int.h defun.h dirfns.h dynamic-ld.h error.h \
 	file-io.h fn-cache.h gripes.h help.h input.h lex.h load-save.h \
 	oct-fstrm.h oct-hist.h oct-iostrm.h oct-map.h oct-obj.h \
 	oct-prcstrm.h oct-procbuf.h oct-stdstrm.h oct-stream.h \
 	oct-strstrm.h oct-lvalue.h oct.h ops.h pager.h parse.h \
 	pr-output.h procstream.h sighandlers.h symtab.h sysdep.h \
 	token.h toplev.h unwind-prot.h utils.h \
 	variables.h version.h xdiv.h xpow.h $(OV_INCLUDES) $(PT_INCLUDES)
@@ -109,25 +110,26 @@ OP_XSRC := op-b-b.cc op-bm-bm.cc op-chm.
 	op-s-s.cc op-str-str.cc
 
 OP_SRC := $(addprefix OPERATORS/, $(OP_XSRC))
 
 OV_SRC := ov-base.cc ov-base-mat.cc ov-base-scalar.cc ov-ch-mat.cc \
 	ov-list.cc ov-re-mat.cc ov-cx-mat.cc ov-range.cc ov-scalar.cc \
 	ov-complex.cc ov-str-mat.cc ov-struct.cc ov-va-args.cc \
 	ov-colon.cc ov-bool-mat.cc ov-bool.cc ov-file.cc ov.cc ov-fcn.cc \
-	ov-builtin.cc ov-mapper.cc ov-usr-fcn.cc ov-typeinfo.cc
+	ov-builtin.cc ov-dld-fcn.cc ov-mapper.cc ov-usr-fcn.cc \
+	ov-typeinfo.cc
 
 PT_SRC := pt.cc pt-arg-list.cc pt-assign.cc pt-binop.cc pt-check.cc \
 	pt-cmd.cc pt-colon.cc pt-const.cc pt-decl.cc pt-except.cc \
 	pt-exp.cc pt-id.cc pt-idx.cc pt-indir.cc pt-jump.cc \
 	pt-loop.cc pt-mat.cc pt-misc.cc pt-plot.cc pt-pr-code.cc \
 	pt-select.cc pt-stmt.cc pt-unop.cc
 
-DIST_SRC := BaseSLList.cc Map.cc SLList.cc SLStack.cc Stack.cc \
+DIST_SRC := BaseSLList.cc DLList.cc Map.cc SLList.cc SLStack.cc Stack.cc \
 	cutils.c data.cc defaults.cc defun.cc dirfns.cc dynamic-ld.cc \
 	error.cc file-io.cc fn-cache.cc gripes.cc help.cc input.cc \
 	lex.l load-save.cc mappers.cc matherr.c oct-fstrm.cc \
 	oct-hist.cc oct-iostrm.cc oct-map.cc oct-obj.cc oct-prcstrm.cc \
 	oct-procbuf.cc oct-stdstrm.cc oct-stream.cc oct-strstrm.cc \
 	oct-lvalue.cc pager.cc parse.y pr-output.cc procstream.cc \
 	sighandlers.cc strcasecmp.c strncase.c strfns.cc \
 	symtab.cc syscalls.cc sysdep.cc system.c token.cc \
@@ -167,17 +169,17 @@ DEFUN_PATTERN = "^[ \t]*DEFU(N|N_DLD|N_T
 
 DEF_5 := $(SOURCES) $(DLD_SRC)
 DEF_4 := $(addprefix $(srcdir)/, $(DEF_5))
 DEF_3 := $(notdir $(shell egrep -l $(DEFUN_PATTERN) $(DEF_4)))
 DEF_2 := $(patsubst %.y, %.df, $(DEF_3))
 DEF_1 := $(patsubst %.l, %.df, $(DEF_2))
 DEF_FILES := $(patsubst %.cc, %.df, $(DEF_1))
 
-DEFVAR_PATTERN = "^[ \t]*DEF(VAR|CONST)[ \t]*\\("
+DEFVAR_PATTERN = "^[ \t]*DEF(VAR|CONS(T|TX))[ \t]*\\("
 
 VAR_5 := $(SOURCES) $(DLD_SRC)
 VAR_4 := $(addprefix $(srcdir)/, $(VAR_5))
 VAR_3 := $(notdir $(shell egrep -l $(DEFVAR_PATTERN) $(VAR_4)))
 VAR_2 := $(patsubst %.y, %, $(VAR_3))
 VAR_1 := $(patsubst %.l, %, $(VAR_2))
 VAR_FILES := $(patsubst %.cc, %, $(VAR_1))
 
diff --git a/src/defun-dld.h b/src/defun-dld.h
--- a/src/defun-dld.h
+++ b/src/defun-dld.h
@@ -50,36 +50,16 @@ Software Foundation, 59 Temple Place - S
 
 #else
 
 #define DEFUN_DLD(name, args_name, nargout_name, doc) \
   DECLARE_FUN (name, args_name, nargout_name); \
   DEFINE_FUN_INSTALLER_FUN (name, doc) \
   DECLARE_FUN (name, args_name, nargout_name)
 
-#if (defined (OCTAVE_LITE) && defined (WITH_DYNAMIC_LINKING))
-
-#define INSTALL_DLD_FCNS(body) \
-  bool \
-  FSoctave_install_dld_functions (void) \
-  { \
-    body \
-    return true; \
-  }
-
-#else
-
-#define INSTALL_DLD_FCNS(body)
-
-#endif
-
-#define INSTALL_DLD_FCN(name) \
-  if (! FS ## name ()) \
-    return false
-
 #endif
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/defun-int.h b/src/defun-int.h
--- a/src/defun-int.h
+++ b/src/defun-int.h
@@ -21,16 +21,17 @@ Software Foundation, 59 Temple Place - S
 */
 
 #if !defined (octave_defun_int_h)
 #define octave_defun_int_h 1
 
 #include <string>
 
 #include "ov-builtin.h"
+#include "ov-dld-fcn.h"
 #include "ov-mapper.h"
 #include "symtab.h"
 #include "version.h"
 
 class octave_value;
 
 extern void print_usage (const string& nm, bool just_usage = false);
 
@@ -49,39 +50,42 @@ install_builtin_variable (const string& 
 			  symbol_record::change_function chg_fcn,
 			  const string& h);
 
 extern void
 install_builtin_constant (const string& n, const octave_value& v,
 			  bool p, const string& h);
 
 extern void
-alias_builtin (const string& alias, const string& name);
-
-// Define the code that will be used to insert the new function into
-// the symbol table.
+install_dld_function (octave_dld_function::fcn f, const string& name,
+		      const octave_shlib& shl,
+		      const string& doc, bool is_text_fcn = false);
 
-#define DEFINE_FUN_INSTALLER_FUN(name, doc) \
-  bool \
-  FS ## name (void) \
-  { \
-    static bool installed = false; \
-    if (! installed) \
-      { \
-	check_version (OCTAVE_VERSION, #name); \
-	install_builtin_function (F ## name, #name, doc); \
-	installed = true; \
-      } \
-    return installed; \
-  }
+extern void
+alias_builtin (const string& alias, const string& name);
 
 #define DECLARE_FUN(name, args_name, nargout_name) \
   octave_value_list \
   F ## name (const octave_value_list& args_name, int nargout_name)
 
+// Define the code that will be used to insert the new function into
+// the symbol table.  We look for this name instead of the actual
+// function so that we can easily install the doc string too.
+
+typedef bool (*octave_dld_fcn_installer) (const octave_shlib&);
+
+#define DEFINE_FUN_INSTALLER_FUN(name, doc) \
+  bool \
+  FS ## name (const octave_shlib& shl) \
+  { \
+    check_version (OCTAVE_VERSION, #name); \
+    install_dld_function (F ## name, #name, shl, doc); \
+    return error_state ? false : true; \
+  }
+
 // MAKE_BUILTINS is defined to extract function names and related
 // information and create the *.df files that are eventually used to
 // create the builtins.cc file.
 
 #if defined (MAKE_BUILTINS)
 
 // Generate code to install name in the symbol table.  The script
 // mkdefs will create a .def file for every .cc file that uses DEFUN,
diff --git a/src/defun.cc b/src/defun.cc
--- a/src/defun.cc
+++ b/src/defun.cc
@@ -21,21 +21,25 @@ Software Foundation, 59 Temple Place - S
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <string>
 
+#include <iostream.h>
+
 #include "defun-int.h"
+#include "dynamic-ld.h"
 #include "error.h"
 #include "help.h"
 #include "ov.h"
 #include "ov-builtin.h"
+#include "ov-dld-fcn.h"
 #include "ov-mapper.h"
 #include "pager.h"
 #include "symtab.h"
 #include "variables.h"
 
 void
 print_usage (const string& nm, bool just_usage)
 {
@@ -113,16 +117,35 @@ install_builtin_variable (const string& 
 			  bool protect, bool eternal,
 			  symbol_record::change_function chg_fcn,
 			  const string& doc)
 {
   bind_builtin_variable (name, value, protect, eternal, chg_fcn, doc);
 }
 
 void
+install_dld_function (octave_dld_function::fcn f, const string& name,
+		      const octave_shlib& shl,
+		      const string& doc, bool is_text_fcn)
+{
+  symbol_record *sym_rec = global_sym_tab->lookup (name, true);
+
+  unsigned int t = symbol_record::DLD_FUNCTION;
+
+  if (is_text_fcn)
+    t |= symbol_record::TEXT_FUNCTION;
+
+  sym_rec->unprotect ();
+  sym_rec->define (new octave_dld_function (f, shl, name, doc), t);
+  sym_rec->document (doc);
+  sym_rec->make_eternal ();
+  sym_rec->protect ();
+}
+
+void
 alias_builtin (const string& alias, const string& name)
 {
   symbol_record *sr_name = global_sym_tab->lookup (name);
 
   if (! sr_name)
     panic ("can't alias to undefined name!");
 
   symbol_record *sr_alias = global_sym_tab->lookup (alias, true);
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -19,281 +19,325 @@ along with Octave; see the file COPYING.
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#if defined (WITH_SHL)
-#include <cerrno>
-#include <cstring>
-#endif
-
-#include <strstream.h>
+#include "oct-time.h"
+#include "file-stat.h"
 
-extern "C"
-{
-#if defined (WITH_DL)
-#if defined (HAVE_DLFCN_H)
-#include <dlfcn.h>
-#else
-extern void *dlopen (const char *, int);
-extern const char *dlerror (void);
-extern void *dlsym (void *, const char *);
-extern int dlclose (void *);
-#endif
-#ifndef RTLD_LAZY
-#define RTLD_LAZY 1
-#endif
-#elif defined (WITH_SHL)
-#include <dl.h>
-#endif
-}
+#include "DLList.h"
 
 #include <defaults.h>
-#include "dirfns.h"
+
+#include "defun.h"
 #include "dynamic-ld.h"
-#include "error.h"
-#include "toplev.h"
-#include "pathsearch.h"
-#include "oct-obj.h"
-#include "ov-builtin.h"
-#include "ov.h"
+#include "parse.h"
+#include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
-#if defined (WITH_DL)
+// TRUE means we print a warning if reloading a .oct file forces other
+// functions to be cleared.
+static bool Vwarn_reload_forces_clear;
+
+template class DLNode<octave_shlib>;
+template class DLList<octave_shlib>;
 
 class
-octave_dlopen_dynamic_loader : public octave_dynamic_loader
+octave_shlib_list
 {
 public:
 
-  octave_dlopen_dynamic_loader (void)
-    : octave_dynamic_loader () { }
+  static void append (const octave_shlib& shl);
 
-  ~octave_dlopen_dynamic_loader (void) { }
+  static void remove (octave_shlib& shl);
+
+  static void *search (const string& fcn_name, octave_shlib& shl,
+		       octave_shlib::name_mangler mangler = 0);
 
 private:
 
-  octave_dynamic_loader::builtin_fcn_installer
-  resolve_reference (const string& mangled_name, const string& file);
+  octave_shlib_list (void) { }
+
+  ~octave_shlib_list (void) { }
+
+  void do_append (const octave_shlib& shl);
+
+  void do_remove (octave_shlib& shl);
+
+  void *do_search (const string& fcn_name, octave_shlib& shl,
+		   octave_shlib::name_mangler mangler = 0);
+
+  static octave_shlib_list *instance;
+
+  static bool instance_ok (void);
+
+  // List of libraries we have loaded.
+  DLList<octave_shlib> lib_list;
 
   // No copying!
 
-  octave_dlopen_dynamic_loader (const octave_dlopen_dynamic_loader&);
+  octave_shlib_list (const octave_shlib_list&);
 
-  octave_dlopen_dynamic_loader&
-  operator = (const octave_dlopen_dynamic_loader&);
+  octave_shlib_list& operator = (const octave_shlib_list&);
 };
 
-octave_dynamic_loader::builtin_fcn_installer
-octave_dlopen_dynamic_loader::resolve_reference (const string& name,
-						 const string& file)
-{
-  octave_dynamic_loader::builtin_fcn_installer retval = 0;
-
-  // Dynamic linking with dlopen/dlsym doesn't require specification
-  // of the libraries at runtime.  Instead, they are specified when
-  // the .oct file is created.
-
-  void *handle = dlopen (file.c_str (), RTLD_LAZY);
-
-  string mangled_name = mangle_name (name);
-
-  const char *nm = mangled_name.c_str ();
-
-  if (handle)
-    {
-      // Try the installer function first.
-
-      string tmp_name = mangle_name ("octave_install_dld_functions");
-
-      const char *tmp_nm = tmp_name.c_str ();
-
-      void *tmp = dlsym (handle, tmp_nm);
+octave_shlib_list *octave_shlib_list::instance = 0;
 
-      retval = X_CAST (octave_dynamic_loader::builtin_fcn_installer,
-		       tmp);
-      if (! retval)
-	{
-	  tmp = dlsym (handle, nm);
-
-	  retval = X_CAST (octave_dynamic_loader::builtin_fcn_installer, tmp);
-
-	  if (! retval)
-	    {
-	      const char *errmsg = dlerror ();
-
-	      if (errmsg)
-		error("%s: `%s'", nm, errmsg);
-	      else
-		error("unable to link function `%s'", nm);
-
-	      dlclose (handle);
-	    }
-	}
-    }
-  else
-    error ("%s: %s `%s'", dlerror (), file.c_str (), nm);
-
-  return retval;
+void
+octave_shlib_list::do_append (const octave_shlib& shl)
+{
+  lib_list.append (shl);
 }
 
-#elif defined (WITH_SHL)
-
-class
-octave_shl_load_dynamic_loader : public octave_dynamic_loader
+void
+octave_shlib_list::do_remove (octave_shlib& shl)
 {
-public:
-
-  octave_shl_load_dynamic_loader (void)
-    : octave_dynamic_loader () { }
-
-  ~octave_shl_load_dynamic_loader (void) { }
-
-private:
-
-  octave_dynamic_loader::builtin_fcn_installer
-  resolve_reference (const string& mangled_name, const string& file);
-
-  // No copying!
-
-  octave_shl_load_dynamic_loader (const octave_shl_load_dynamic_loader&);
-
-  octave_shl_load_dynamic_loader&
-  operator = (const octave_shl_load_dynamic_loader&);
-};
-
-octave_dynamic_loader::builtin_fcn_installer
-octave_shl_load_dynamic_loader::resolve_reference (const string& name,
-						   const string& file)
-{
-  octave_dynamic_loader::builtin_fcn_installer retval = 0;
-
-  // Dynamic linking with shl_load/shl_findsym doesn't require
-  // specification of the libraries at runtime.  Instead, they are
-  // specified when the .oct file is created.
+  for (Pix p = lib_list.first (); p != 0; lib_list.next (p))
+    {
+      if (lib_list(p) == shl)
+	{
+	  shl.close ();
 
-  shl_t handle = shl_load (file.c_str (), BIND_DEFERRED, 0L);
-
-  string mangled_name = mangle_name (name);
-
-  const char *nm = mangled_name.c_str ();
-
-  if (handle)
-    {
-      // Try the installer function first.
-
-      string tmp_name = mangle_name ("octave_install_dld_functions");
-
-      const char *tmp_nm = tmp_name.c_str ();
-
-      // Don't use TYPE_PROCEDURE here.  The man page says that future
-      // versions of HP-UX may not support it.
+	  lib_list.del (p);
 
-      int status = shl_findsym (&handle, tmp_nm, TYPE_UNDEFINED, &retval);
-
-      if (status < 0)
-	{
-	  status = shl_findsym (&handle, nm, TYPE_UNDEFINED, &retval);
-
-	  if (status < 0)
-	    {
-	      const char *errmsg = strerror (errno);
-
-	      if (errmsg)
-		error("%s: `%s'", nm, errmsg);
-	      else
-		error("unable to link function `%s'", nm);
-
-	      retval = 0;
-	    }
+	  break;
 	}
     }
-  else
-    error ("%s: %s `%s'", strerror (errno), file.c_str (), nm);
-
-  return retval;
 }
 
-#endif
+void *
+octave_shlib_list::do_search (const string& fcn_name, octave_shlib& shl,
+			      octave_shlib::name_mangler mangler)
+{
+  void *function = 0;
+
+  shl = octave_shlib ();
 
-octave_dynamic_loader *octave_dynamic_loader::instance = 0;
+  for (Pix p = lib_list.first (); p != 0; lib_list.next (p))
+    {
+      function = lib_list(p).search (fcn_name, mangler);
+
+      if (function)
+	{
+	  shl = lib_list(p);
+
+	  break;
+	}
+    }
+
+  return function;
+}
 
 bool
-octave_dynamic_loader::instance_ok (void)
+octave_shlib_list::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    make_dynamic_loader ();
+    instance = new octave_shlib_list ();
 
   if (! instance)
     {
-      error ("unable to create command history object!");
+      ::error ("unable to create shared library list object!");
 
       retval = false;
     }
 
   return retval;
 }
 
 void
-octave_dynamic_loader::make_dynamic_loader (void)
+octave_shlib_list::append (const octave_shlib& shl)
+{
+  if (instance_ok ())
+    instance->do_append (shl);
+}
+
+void
+octave_shlib_list::remove (octave_shlib& shl)
 {
-#if defined (WITH_DL)
-  instance = new octave_dlopen_dynamic_loader ();
-#elif defined (WITH_SHL)
-  instance = new octave_shl_load_dynamic_loader ();
-#else
-  instance = new octave_dynamic_loader ();
-#endif
+  if (instance_ok ())
+    instance->do_remove (shl);
 }
 
+void *
+octave_shlib_list::search (const string& fcn_name, octave_shlib& shl,
+			   octave_shlib::name_mangler mangler)
+{
+  return (instance_ok ()) ? instance->do_search (fcn_name, shl, mangler) : 0;
+}
+
+octave_dynamic_loader *octave_dynamic_loader::instance = 0;
+
+bool octave_dynamic_loader::doing_load = false;
+
 bool
-octave_dynamic_loader::load_fcn_from_dot_oct_file (const string& fcn_name)
+octave_dynamic_loader::instance_ok (void)
 {
-  if (! instance_ok ())
-    make_dynamic_loader ();
-
-  bool retval = false;
+  bool retval = true;
 
-  string oct_file = oct_file_in_path (fcn_name);
+  if (! instance)
+    instance = new octave_dynamic_loader ();
 
-  if (! oct_file.empty ())
+  if (! instance)
     {
-      builtin_fcn_installer f
-	= instance->resolve_reference (fcn_name, oct_file);
+      error ("unable to create dynamic loader object!");
 
-      if (f)
-	retval = f ();
+      retval = false;
     }
 
   return retval;
 }
 
-octave_dynamic_loader::builtin_fcn_installer
-octave_dynamic_loader::resolve_reference (const string&, const string&)
+static
+void clear_function (const string& fcn_name)
+{
+  if (Vwarn_reload_forces_clear)
+    warning ("  %s", fcn_name.c_str ());
+
+  curr_sym_tab->clear (fcn_name);
+
+  if (curr_sym_tab != top_level_sym_tab)
+    top_level_sym_tab->clear (fcn_name);
+
+  global_sym_tab->clear (fcn_name);
+}
+
+bool
+octave_dynamic_loader::do_load (const string& fcn_name)
 {
-  return 0;
+  bool retval = false;
+
+  octave_shlib oct_file;
+
+  unwind_protect::begin_frame ("octave_dynamic_loader::do_load");
+
+  unwind_protect_bool (octave_dynamic_loader::doing_load);
+
+  doing_load = true;
+
+  void *function
+    = octave_shlib_list::search (fcn_name, oct_file, mangle_name);
+
+  if (! error_state)
+    {
+      if (function && oct_file.is_out_of_date ())
+	{
+	  int n = oct_file.number_of_functions_loaded ();
+
+	  if (n > 0 && Vwarn_reload_forces_clear)
+	    warning ("reloading %s clears the following functions:",
+		     oct_file.file_name().c_str ());
+
+	  oct_file.close (clear_function);
+
+	  function = 0;
+	}
+
+      if (! function)
+	{
+	  string oct_file_name = oct_file_in_path (fcn_name);
+
+	  if (! oct_file_name.empty ())
+	    {
+	      oct_file.open (oct_file_name, Vwarn_future_time_stamp);
+
+	      if (! error_state)
+		{
+		  if (oct_file)
+		    {
+		      octave_shlib_list::append (oct_file);
+
+		      function = oct_file.search (fcn_name, mangle_name);
+		    }
+		  else
+		    error ("%s is not a valid shared library",
+			   oct_file_name.c_str ());
+		}
+	    }
+	}
+    }
+
+  if (function)
+    {
+      octave_dld_fcn_installer f
+	= X_CAST (octave_dld_fcn_installer, function);
+
+      retval = f (oct_file);
+
+      if (! retval)
+	error ("failed to install dld function `%s'", fcn_name.c_str ());
+    }
+
+  unwind_protect::run_frame ("octave_dynamic_loader::do_load");
+
+  return retval;
+}
+
+bool
+octave_dynamic_loader::do_remove (const string& fcn_name, octave_shlib& shl)
+{
+  bool retval = false;
+
+  // We don't need to do anything if this is called because we are in
+  // the process of reloading a .oct file that has changed.
+
+  if (! doing_load)
+    {
+      retval = shl.remove (fcn_name);
+
+      if (shl.number_of_functions_loaded () == 0)
+	octave_shlib_list::remove (shl);
+    }
+
+  return retval;
+}
+
+bool
+octave_dynamic_loader::load (const string& fcn_name)
+{
+  return (instance_ok ()) ? instance->do_load (fcn_name) : false;
+}
+
+bool
+octave_dynamic_loader::remove (const string& fcn_name, octave_shlib& shl)
+{
+  return (instance_ok ()) ? instance->do_remove (fcn_name, shl) : false;
 }
 
 string
 octave_dynamic_loader::mangle_name (const string& name)
 {
 #if defined (CXX_PREPENDS_UNDERSCORE)
   string retval ("_FS");
 #else
   string retval ("FS");
 #endif
   retval.append (name);
-  retval.append ("__Fv");
+  retval.append ("__FRC12octave_shlib");
   return retval;
 }
 
+static int
+warn_reload_forces_clear (void)
+{
+  Vwarn_reload_forces_clear = check_preference ("warn_reload_forces_clear");
+
+  return 0;
+}
+
+void
+symbols_of_dynamic_ld (void)
+{
+  DEFVAR (warn_reload_forces_clear, 1.0, warn_reload_forces_clear,
+    "warn if reloading a .oct file forces other functions to be cleared");
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/dynamic-ld.h b/src/dynamic-ld.h
--- a/src/dynamic-ld.h
+++ b/src/dynamic-ld.h
@@ -20,53 +20,54 @@ Software Foundation, 59 Temple Place - S
 
 */
 
 #if !defined (octave_dynamic_ld_h)
 #define octave_dynamic_ld_h 1
 
 #include <string>
 
-class octave_builtin;
+#include "oct-shlib.h"
 
 class
 octave_dynamic_loader
 {
 protected:
 
   octave_dynamic_loader (void) { }
 
 public:
 
-  typedef bool (*builtin_fcn_installer) (void);
-
   virtual ~octave_dynamic_loader (void) { }
 
-  static bool load_fcn_from_dot_oct_file (const string& fcn_name);
+  static bool load (const string& fcn_name);
+
+  static bool remove (const string& fcn_name, octave_shlib& shl);
 
 private:
 
   // No copying!
 
   octave_dynamic_loader (const octave_dynamic_loader&);
 
   octave_dynamic_loader& operator = (const octave_dynamic_loader&);
 
   static octave_dynamic_loader *instance;
 
   static bool instance_ok (void);
 
-  static void make_dynamic_loader (void);
+  bool do_load (const string& fcn_name);
+
+  bool do_remove (const string& fcn_name, octave_shlib& shl);
+
+  static bool doing_load;
 
 protected:
 
-  virtual builtin_fcn_installer
-  resolve_reference (const string& mangled_name, const string& oct_file);
-
-  string mangle_name (const string& name);
+  static string mangle_name (const string& name);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -47,17 +47,16 @@ Software Foundation, 59 Temple Place - S
 #include "file-stat.h"
 #include "lo-error.h"
 #include "oct-env.h"
 #include "pathsearch.h"
 #include "str-vec.h"
 
 #include <defaults.h>
 #include "defun.h"
-#include "dynamic-ld.h"
 #include "error.h"
 #include "file-io.h"
 #include "input.h"
 #include "lex.h"
 #include "oct-hist.h"
 #include "oct-obj.h"
 #include "ops.h"
 #include "toplev.h"
@@ -314,16 +313,17 @@ print_version_and_exit (void)
   cout << OCTAVE_NAME_AND_VERSION << "\n";
   exit (0);
 }
 
 static void
 initialize_error_handlers ()
 {
   set_liboctave_error_handler (error);
+  set_liboctave_warning_handler (warning);
 }
 
 // What happens on --traditional.
 
 static void
 maximum_braindamage (void)
 {
   bind_builtin_variable ("PS1", ">> ");
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -145,16 +145,20 @@ public:
 
   bool is_zero_by_zero (void) const
     { return (rows () == 0 && columns () == 0); }
 
   bool is_constant (void) const { return false; }
 
   bool is_function (void) const { return false; }
 
+  bool is_builtin_function (void) const { return false; }
+
+  bool is_dld_function (void) const { return false; }
+
   int int_value (bool = false, bool = false) const;
 
   int nint_value (bool = false) const;
 
   double double_value (bool = false) const;
 
   double scalar_value (bool frc_str_conv = false) const
     { return double_value (frc_str_conv); }
diff --git a/src/ov-builtin.cc b/src/ov-builtin.cc
--- a/src/ov-builtin.cc
+++ b/src/ov-builtin.cc
@@ -41,17 +41,17 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
 
 static bool
 any_arg_is_magic_colon (const octave_value_list& args)
 {
   int nargin = args.length ();
 
   for (int i = 0; i < nargin; i++)
     if (args(i).is_magic_colon ())
-	return true;
+      return true;
 
   return false;
 }
 
 octave_value_list
 octave_builtin::do_index_op (int nargout, const octave_value_list& args)
 {
   octave_value_list retval;
diff --git a/src/ov-builtin.h b/src/ov-builtin.h
--- a/src/ov-builtin.h
+++ b/src/ov-builtin.h
@@ -47,27 +47,31 @@ public:
   octave_builtin (fcn ff, const string& nm = string (),
 		  const string& ds = string ())
     : octave_function (nm, ds), f (ff) { }
 
   ~octave_builtin (void) { }
 
   octave_function *function_value (bool) { return this; }
 
+  bool is_builtin_function (void) const { return true; }
+
   octave_value_list do_index_op (int nargout, const octave_value_list& args);
 
+protected:
+
+  // A pointer to the actual function.
+  fcn f;
+
 private:
 
   octave_builtin (void);
 
   octave_builtin (const octave_builtin& m);
 
-  // A pointer to the actual function.
-  fcn f;
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 
   DECLARE_OCTAVE_ALLOCATOR
 };
 
 #endif
 
 /*
diff --git a/src/ov-fcn.h b/src/ov-fcn.h
--- a/src/ov-fcn.h
+++ b/src/ov-fcn.h
@@ -25,16 +25,17 @@ Software Foundation, 59 Temple Place - S
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 #include <string>
 
 #include "oct-time.h"
+#include "str-vec.h"
 
 #include "oct-alloc.h"
 #include "ov-base.h"
 #include "ov-typeinfo.h"
 
 class tree_walker;
 
 // Functions.
@@ -52,49 +53,53 @@ public:
   // This should only be called for derived types.
 
   octave_function *clone (void);
 
   bool is_defined (void) const { return true; }
 
   bool is_function (void) const { return true; }
 
+  virtual bool is_dynamically_loaded_function (void) const { return false; }
+
   virtual bool is_system_fcn_file (void) { return false; }
 
   virtual string fcn_file_name (void) const { return string (); }
 
   virtual void mark_fcn_file_up_to_date (const octave_time&) { }
 
   virtual octave_time time_parsed (void) const
     { return octave_time (static_cast<time_t> (0)); }
 
   virtual octave_time time_checked (void) const
     { return octave_time (static_cast<time_t> (0)); }
 
   string name (void) const { return my_name; }
 
   string doc_string (void) const { return doc; }
 
+  virtual void unload (void) { }
+
   virtual void accept (tree_walker&) { }
 
 protected:
 
   octave_function (const string& nm, const string& ds)
     : my_name (nm), doc (ds) { }
 
-private:
-
-  octave_function (void);
-
   // The name of this function.
   string my_name;
 
   // The help text for this function.
   string doc;
 
+private:
+
+  octave_function (void);
+
   DECLARE_OCTAVE_ALLOCATOR
 };
 
 #endif
 
 /*
 ;; Local Variables: ***
 ;; mode: C++ ***
diff --git a/src/ov-usr-fcn.h b/src/ov-usr-fcn.h
--- a/src/ov-usr-fcn.h
+++ b/src/ov-usr-fcn.h
@@ -62,18 +62,17 @@ public:
   octave_function *function_value (bool) { return this; }
 
   octave_user_function *define_param_list (tree_parameter_list *t);
 
   octave_user_function *define_ret_list (tree_parameter_list *t);
 
   void stash_fcn_file_name (void);
 
-  void mark_fcn_file_up_to_date (const octave_time& t)
-    { t_checked = t; }
+  void mark_fcn_file_up_to_date (const octave_time& t) { t_checked = t; }
 
   void stash_fcn_file_time (const octave_time& t)
     {
       t_parsed = t;
       mark_fcn_file_up_to_date (t);
     }
 
   void stash_symtab_ptr (symbol_record *sr)
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -372,16 +372,22 @@ public:
     { return rep->is_zero_by_zero (); }
 
   virtual bool is_constant (void) const
     { return rep->is_constant (); }
 
   virtual bool is_function (void) const
     { return rep->is_function (); }
 
+  virtual bool is_builtin_function (void) const
+    { return rep->is_builtin_function (); }
+
+  virtual bool is_dld_function (void) const
+    { return rep->is_dld_function (); }
+
   // Values.
 
   octave_value eval (void) { return *this; }
 
   virtual int int_value (bool req_int = false, bool frc_str_conv = false) const
     { return rep->int_value (req_int, frc_str_conv); }
 
   virtual int nint_value (bool frc_str_conv = false) const
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -86,16 +86,20 @@ static bool Vwarn_function_name_clash;
 // TRUE means warn about function files that have time stamps in the future.
 bool Vwarn_future_time_stamp;
 
 // If TRUE, generate warning if a statement in a function is not
 // terminated with a semicolon.  Useful for checking functions that
 // should only produce output using explicit printing statements.
 static bool Vwarn_missing_semicolon;
 
+// TRUE means we print a warning if reloading a .oct file forces other
+// functions to be cleared.
+static bool Vwarn_reload_forces_clear;
+
 // Temporary symbol table pointer used to cope with bogus function syntax.
 symbol_table *tmp_local_sym_tab = 0;
 
 // The current input line number.
 int input_line_number = 0;
 
 // The column of the current token.
 int current_input_column = 1;
@@ -2991,17 +2995,17 @@ parse_fcn_file (const string& ff, bool e
 
 bool
 load_fcn_from_file (symbol_record *sym_rec, bool exec_script)
 {
   bool script_file_executed = false;
 
   string nm = sym_rec->name ();
 
-  if (octave_dynamic_loader::load_fcn_from_dot_oct_file (nm))
+  if (octave_dynamic_loader::load (nm))
     {
       force_link_to_function (nm);
     }
   else
     {
       string ff = fcn_file_in_path (nm);
 
       // These are needed by yyparse.
@@ -3288,16 +3292,24 @@ static int
 warn_missing_semicolon (void)
 {
   Vwarn_missing_semicolon = check_preference ("warn_missing_semicolon");
 
   return 0;
 }
 
 static int
+warn_reload_forces_clear (void)
+{
+  Vwarn_reload_forces_clear = check_preference ("warn_reload_forces_clear");
+
+  return 0;
+}
+
+static int
 warn_variable_switch_label (void)
 {
   Vwarn_variable_switch_label
     = check_preference ("warn_variable_switch_label");
 
   return 0;
 }
 
@@ -3316,16 +3328,19 @@ results of commands executed by eval() t
 
   DEFVAR (warn_future_time_stamp, 1.0, warn_future_time_stamp,
     "warn if a function file has a time stamp that is in the future");
 
   DEFVAR (warn_missing_semicolon, 0.0, warn_missing_semicolon,
     "produce a warning if a statement in a function file is not\n\
 terminated with a semicolon");
 
+  DEFVAR (warn_reload_forces_clear, 1.0, warn_reload_forces_clear,
+    "warn if reloading a .oct file forces other functions to be cleared");
+
   DEFVAR (warn_variable_switch_label, 0.0, warn_variable_switch_label,
     "produce warning for variables used as switch labels");
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: text ***
 ;;; End: ***
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -210,33 +210,33 @@ bool
 symbol_record::hides_fcn (void) const
 {
   bool retval = false;
 
   if (is_variable () && is_defined ())
     {
       symbol_def *hidden_def = definition->next_elem;
 
-      if (hidden_def && hidden_def->is_builtin_function ())
+      if (hidden_def && hidden_def->is_user_function ())
 	retval = true;
     }
 
   return retval;
 }
 
 bool
 symbol_record::hides_builtin (void) const
 {
   bool retval = false;
 
   if (is_variable () && is_defined ())
     {
       symbol_def *hidden_def = definition->next_elem;
 
-      if (hidden_def && hidden_def->is_user_function ())
+      if (hidden_def && hidden_def->is_builtin_function ())
 	retval = true;
     }
 
   return retval;
 }
 
 octave_value&
 symbol_record::variable_value (void)
@@ -403,16 +403,19 @@ symbol_record::remove_top_def (void)
 }
 
 void
 symbol_record::replace_all_defs (symbol_def *sd)
 {
   while (definition)
     remove_top_def ();
 
+  if (! sd)
+    sd = new symbol_def ();
+
   push_def (sd);
 }
 
 // A symbol table.
 
 symbol_record *
 symbol_table::lookup (const string& nm, bool insert, bool warn)
 {
@@ -483,17 +486,18 @@ symbol_table::clear (bool clear_user_fun
 {
   for (unsigned int i = 0; i < table_size; i++)
     {
       symbol_record *ptr = table[i].next ();
 
       while (ptr)
 	{
 	  if (ptr->is_user_variable ()
-	      || (clear_user_functions && ptr->is_user_function ()))
+	      || (clear_user_functions
+		  && (ptr->is_user_function () || ptr->is_dld_function ())))
 	    {
 	      ptr->clear ();
 	    }
 
 	  ptr = ptr->next ();
 	}
     }
 }
@@ -504,17 +508,18 @@ symbol_table::clear (const string& nm, b
   unsigned int index = hash (nm);
 
   symbol_record *ptr = table[index].next ();
 
   while (ptr)
     {
       if (ptr->name () == nm
 	  && (ptr->is_user_variable ()
-	      || (clear_user_functions && ptr->is_user_function ())))
+	      || (clear_user_functions
+		  && (ptr->is_user_function () || ptr->is_dld_function ()))))
 	{
 	  ptr->clear ();
 	  return true;
 	}
       ptr = ptr->next ();
     }
 
   return false;
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -48,28 +48,29 @@ class symbol_table;
 // Individual records in a symbol table.
 
 class
 symbol_record
 {
 public:
 
   // If you add or delete an entry here, you'll also need to change
-  // the with parameter in the declaration for symbol_type below...
+  // the width parameter in the declaration for symbol_type below...
 
   enum TYPE
     {
       UNKNOWN = 0,
       USER_FUNCTION = 1,
       USER_VARIABLE = 2,
-      BUILTIN_FUNCTION = 4,
-      TEXT_FUNCTION = 8,
-      MAPPER_FUNCTION = 16,
-      BUILTIN_VARIABLE = 32,
-      BUILTIN_CONSTANT = 64
+      DLD_FUNCTION = 4,
+      BUILTIN_FUNCTION = 8,
+      TEXT_FUNCTION = 16,
+      MAPPER_FUNCTION = 32,
+      BUILTIN_VARIABLE = 64,
+      BUILTIN_CONSTANT = 128
     };
 
 private:
 
   // Variables or functions.
 
   class symbol_def
   {
@@ -89,16 +90,17 @@ private:
       {
 	return (symbol_type & symbol_record::USER_VARIABLE
 		|| symbol_type & symbol_record::BUILTIN_VARIABLE);
       }
 
     bool is_function (void) const
       {
 	return (symbol_type & symbol_record::USER_FUNCTION
+		|| symbol_type & symbol_record::DLD_FUNCTION
 		|| symbol_type & symbol_record::BUILTIN_FUNCTION);
       }
 
     bool is_user_variable (void) const
       { return (symbol_type & symbol_record::USER_VARIABLE); }
 
     bool is_text_function (void) const
       { return (symbol_type & symbol_record::TEXT_FUNCTION); }
@@ -113,16 +115,19 @@ private:
       { return (symbol_type & symbol_record::BUILTIN_CONSTANT); }
 
     bool is_builtin_variable (void) const
       { return (symbol_type & symbol_record::BUILTIN_VARIABLE); }
 
     bool is_builtin_function (void) const
       { return (symbol_type & symbol_record::BUILTIN_FUNCTION); }
 
+    bool is_dld_function (void) const
+      { return (symbol_type & symbol_record::DLD_FUNCTION); }
+
     // XXX FIXME XXX
     bool is_map_element (const string& /* elts */) const
       { return false; }
 
     bool is_defined (void) const
       { return definition.is_defined (); }
 
     bool is_read_only (void) const
@@ -160,17 +165,17 @@ private:
       { return allocator.alloc (size); }
 
     void operator delete (void *p, size_t size)
       { allocator.free (p, size); }
 
     static octave_allocator allocator;
 
     // The type of this symbol (see the enum above).
-    unsigned int symbol_type : 7;
+    unsigned int symbol_type : 8;
 
     // Nonzero means this variable cannot be cleared.
     unsigned int eternal : 1;
 
     // Nonzero means this variable cannot be given a new value.
     unsigned int read_only : 1;
 
     // The doc string associated with this variable.
@@ -230,16 +235,19 @@ public:
     { return definition->is_mapper_function (); }
 
   bool is_user_function (void) const
     { return definition->is_user_function (); }
 
   bool is_builtin_function (void) const
     { return definition->is_builtin_function (); }
 
+  bool is_dld_function (void) const
+    { return definition->is_dld_function (); }
+
   bool is_constant (void) const
     { return definition->is_constant (); }
 
   bool is_builtin_constant (void) const
     { return definition->is_builtin_constant (); }
 
   bool is_variable (void) const
     { return definition->is_variable (); }
@@ -352,16 +360,17 @@ private:
 
 #define SYMTAB_LOCAL_SCOPE 1
 #define SYMTAB_GLOBAL_SCOPE 2
 
 #define SYMTAB_ALL_SCOPES (SYMTAB_LOCAL_SCOPE | SYMTAB_GLOBAL_SCOPE)
 
 #define SYMTAB_ALL_TYPES (symbol_record::USER_FUNCTION \
 			  | symbol_record::USER_VARIABLE \
+			  | symbol_record::DLD_FUNCTION \
 			  | symbol_record::BUILTIN_FUNCTION \
 			  | symbol_record::TEXT_FUNCTION \
 			  | symbol_record::MAPPER_FUNCTION \
 			  | symbol_record::BUILTIN_VARIABLE \
 			  | symbol_record::BUILTIN_CONSTANT)
 
 #define SYMTAB_VARIABLES (symbol_record::USER_VARIABLE \
 			  | symbol_record::BUILTIN_VARIABLE)
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -47,17 +47,16 @@ Software Foundation, 59 Temple Place - S
 #include "file-ops.h"
 #include "lo-error.h"
 #include "lo-mappers.h"
 #include "oct-env.h"
 #include "str-vec.h"
 
 #include <defaults.h>
 #include "defun.h"
-#include "dynamic-ld.h"
 #include "error.h"
 #include "file-io.h"
 #include "input.h"
 #include "lex.h"
 #include <oct-conf.h>
 #include "oct-hist.h"
 #include "oct-map.h"
 #include "oct-obj.h"
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -515,17 +515,22 @@ symbol_out_of_date (symbol_record *sr)
 	  if (! (ff.empty ()
 		 || (Vignore_function_time_stamp
 		     && tmp->is_system_fcn_file ())))
 	    {
 	      if (tmp->time_checked () < Vlast_prompt_time)
 		{
 		  time_t tp = tmp->time_parsed ();
 
-		  string fname = fcn_file_in_path (ff);
+		  string fname;
+
+		  if (tmp->is_dld_function ())
+		    fname = ff;
+		  else
+		    fname = fcn_file_in_path (ff);
 
 		  tmp->mark_fcn_file_up_to_date (octave_time ());
 
 		  file_stat fs (fname);
 
 		  if (fs && fs.is_newer (tp))
 		    retval = true;
 		}
@@ -1077,27 +1082,26 @@ With -x, exclude the named variables")
       string_vector lvars;
       string_vector gvars;
       string_vector fcns;
 
       if (argc > 0)
 	{
 	  string_vector tmp;
 
-	  lvars = curr_sym_tab->name_list (lcount, tmp, false,
-					   SYMTAB_VARIABLES,
-					   SYMTAB_LOCAL_SCOPE);
+	  lvars = curr_sym_tab->name_list
+	    (lcount, tmp, false, SYMTAB_VARIABLES, SYMTAB_LOCAL_SCOPE);
 
-	  gvars = curr_sym_tab->name_list (gcount, tmp, false,
-					   SYMTAB_VARIABLES,
-					   SYMTAB_GLOBAL_SCOPE);
+	  gvars = curr_sym_tab->name_list
+	    (gcount, tmp, false, SYMTAB_VARIABLES, SYMTAB_GLOBAL_SCOPE);
 
-	  fcns = global_sym_tab->name_list (fcount, tmp, false,
-					    symbol_record::USER_FUNCTION,
-					    SYMTAB_ALL_SCOPES);
+	  fcns = global_sym_tab->name_list
+	    (fcount, tmp, false,
+	     symbol_record::USER_FUNCTION|symbol_record::DLD_FUNCTION,
+	     SYMTAB_ALL_SCOPES);
 	}
 
       // XXX FIXME XXX -- this needs to be optimized to avoid the
       // pattern matching code if the string doesn't contain any
       // globbing patterns.
 
       for (int k = idx; k < argc; k++)
 	{
diff --git a/test/ChangeLog b/test/ChangeLog
--- a/test/ChangeLog
+++ b/test/ChangeLog
@@ -1,8 +1,12 @@
+1999-10-29  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* octave.test/system/mktime-1.m (t): Compare whole seconds only.
+
 Fri Dec  4 20:55:47 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* octave.test/system/clock-1.m: Use standard format specifiers %d
 	and %H instead of %e and %k.
 
 Fri Oct 23 15:53:01 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* octave.test/arith/exp-5.m: New test.
diff --git a/test/octave.test/system/mktime-1.m b/test/octave.test/system/mktime-1.m
--- a/test/octave.test/system/mktime-1.m
+++ b/test/octave.test/system/mktime-1.m
@@ -1,2 +1,2 @@
 t = time ();
-mktime (localtime (t)) == t
+fix (mktime (localtime (t))) == fix (t)
