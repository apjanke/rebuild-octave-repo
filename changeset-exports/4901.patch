# HG changeset patch
# User jwe
# Date 1087237982 0
#      Mon Jun 14 18:33:02 2004 +0000
# Node ID 35bfb4e0b96b18a66513fc851e2edda4d0c95ac6
# Parent  cf470c996819e47f5d3eb5a83624b0114690882e
[project @ 2004-06-14 18:33:02 by jwe]

diff --git a/src/Cell.h b/src/Cell.h
--- a/src/Cell.h
+++ b/src/Cell.h
@@ -85,16 +85,19 @@ public:
 
   Cell index (Array<idx_vector>& ra_idx, int resize_ok = 0,
 	      const octave_value& rfv = resize_fill_value ()) const
     { return Cell (ArrayN<octave_value>::index (ra_idx, resize_ok, rfv)); }
 
   Cell& assign (const octave_value_list& idx, const Cell& rhs,
 		const octave_value& fill_val = octave_value ());
 
+  Cell reshape (const dim_vector& new_dims) const
+    { return ArrayN<octave_value>::reshape (new_dims); }
+
   // XXX FIXME XXX
   boolMatrix all (int dim = 0) const { return boolMatrix (); }
 
   // XXX FIXME XXX
   boolMatrix any (int dim = 0) const { return boolMatrix (); }
 
   int cat (const Cell& ra_arg, int dim, int iidx, int move);
 
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,77 @@
+2004-06-14  John W. Eaton  <jwe@octave.org>
+
+	* pr-output.h, pr-output.cc (octave_print_conv): New traits class.
+	(template <class T> void octave_print_internal (std::ostream&,
+	const intNDArray<T>&, bool, int),
+	(template <class T> void octave_print_internal (std::ostream&,
+	const octave_int<T>&, bool)): New template functions.
+	Instantiate versions for new int types.
+
+	* ov-typeinfo.h (octave_value_typeinfo::type_conv_ops):
+	New data member.
+	(octave_value_typeinfo::register_type_conv_op,
+	octave_value_typeinfo::lookup_type_conv_op,
+	octave_value_typeinfo::do_register_type_conv_op,
+	octave_value_typeinfo::do_lookup_type_conv_op): New functions.
+
+	* ov-re-mat.cc (Fdouble): New function.
+
+	* ov-range.h (octave_range::reshape): Reshape array_value, not
+	matrix_value.
+
+	* ov-base-scalar.h (octave_base_scalar<ST>::all,
+	octave_base_scalar<ST>::any, octave_base_scalar<ST>::is_true): Use
+	ST() instead of 0.0.
+
+	* ov-base-mat.h (octave_base_matrix<MT>::byte_size): New function.
+	
+	* ops.h (INSTALL_COLNVOP, DEFCONVFNX, DEFDBLCONVFN, DEFCONVFN,
+	DEFCONVFN2): New macros.
+
+	* DLD-FUNCTIONS/filter.cc (Ffilter): Kluge type conversions.
+
+	* ov.cc (install_types): Register new integer types.
+
+	* ov.h, ov.cc (octave_value::octave_value (const octave_int8&),
+	octave_value::octave_value (const octave_uint8&),
+	octave_value::octave_value (const octave_int16&),
+	octave_value::octave_value (const octave_uint16&),
+	octave_value::octave_value (const octave_int32&),
+	octave_value::octave_value (const octave_uint32&),
+	octave_value::octave_value (const octave_int64&),
+	octave_value::octave_value (const octave_uint64&),
+	octave_value::octave_value (const int8NDArray&),
+	octave_value::octave_value (const uint8NDArray&),
+	octave_value::octave_value (const int16NDArray&),
+	octave_value::octave_value (const uint16NDArray&),
+	octave_value::octave_value (const int32NDArray&),
+	octave_value::octave_value (const uint32NDArray&),
+	octave_value::octave_value (const int64NDArray&),
+	octave_value::octave_value (const uint64NDArray&)):
+	New constructors.
+
+	* ov.h (octave_value::internal_rep): New function.
+	(DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA): Also define
+	static_type_id, static_type_name, and static_class_name
+	functions.
+
+	* Cell.h (Cell::reshape (const dim_vector&)): New forwarding
+	function for return type conversion.
+
+	* ov-int16.cc, ov-int32.cc, ov-int64.cc, ov-int8.cc, ov-uint16.cc,
+	ov-uint32.cc, ov-uint64.cc, ov-uint8.cc, ov-type-conv.h,
+	OPERATORS/op-int-conv.cc, OPERATORS/op-double-conv.cc, 
+	OPERATORS/op-i16-i16.cc, OPERATORS/op-i32-i32.cc,
+	OPERATORS/op-i64-i64.cc, OPERATORS/op-i8-i8.cc,
+	OPERATORS/op-ui16-ui16.cc, OPERATORS/op-ui32-ui32.cc,
+	OPERATORS/op-ui64-ui64.cc, OPERATORS/op-ui8-ui8.cc: New files.
+	Makefile.in: Add them to the appropriate lists.
+
 2004-06-03  John W. Eaton  <jwe@octave.org>
 
 	* ov-fcn-handle.h (octave_function_handle::is_matrix_type,
 	octave_function_handle::is_numeric_type,
 	octave_function_handle::is_constant,
 	octave_function_handle::is_true): New functions.
 	(octave_function_handle::is_defined): Delete (inherited version is
 	OK).
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -409,17 +409,18 @@ H(z) = {\\displaystyle\\sum_{k=0}^M d_{k
 	      for (int i=0; i < si_dims.length (); i++)
 		if ((si_dims (i) != 1) && (si_dims (i) < si_dims.numel ()))
 		  {
 		    si_is_vector = false;
 		    break;
 		  }
 
 	      if (si_is_vector)
-		si = ComplexNDArray (args(3).complex_vector_value ());
+		// XXX FIXME XXX -- there must be a better way...
+		si = ComplexNDArray (MArrayN<Complex> (ArrayN<Complex> (args(3).complex_vector_value ())));
 	      else
 		si = args(3).complex_array_value ();
 	    }
 
 	  if (! error_state)
 	    {
 	      ComplexNDArray y (filter (b, a, x, si, dim));
 
@@ -466,17 +467,18 @@ H(z) = {\\displaystyle\\sum_{k=0}^M d_{k
 	      for (int i=0; i < si_dims.length (); i++)
 		if ((si_dims (i) != 1) && (si_dims (i) < si_dims.numel ()))
 		  {
 		    si_is_vector = false;
 		    break;
 		  }
 
 	      if (si_is_vector)
-		si = NDArray (args(3).vector_value ());
+		// XXX FIXME XXX -- there must be a better way...
+		si = NDArray (MArrayN<double> (ArrayN<double> (args(3).vector_value ())));
 	      else
 		si = args(3).array_value ();
 	    }
 
 	  if (! error_state)
 	    {
 	      NDArray y (filter (b, a, x, si, dim));
 
diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -34,17 +34,16 @@ ifeq ($(ENABLE_DYNAMIC_LINKING), true)
     %.oct : pic/%.o octave$(EXEEXT)
 	  $(DL_LD) $(DL_LDFLAGS) -o $@ $< $(OCT_LINK_DEPS)
   else
     %.oct : %.o octave$(EXEEXT)
 	  $(DL_LD) $(DL_LDFLAGS) -o $@ $< $(OCT_LINK_DEPS)
   endif
 endif
 
-
 OPT_HANDLERS := DASPK-opts.cc DASRT-opts.cc DASSL-opts.cc \
 	LSODE-opts.cc NLEqn-opts.cc ODESSA-opts.cc Quad-opts.cc
 
 DLD_XSRC := balance.cc besselj.cc betainc.cc chol.cc colloc.cc \
 	daspk.cc dasrt.cc dassl.cc det.cc eig.cc expm.cc fft.cc fft2.cc \
 	fftn.cc fftw_wisdom.cc filter.cc find.cc fsolve.cc gammainc.cc \
 	gcd.cc getgrent.cc getpwent.cc getrusage.cc givens.cc hess.cc \
 	inv.cc kron.cc lpsolve.cc lsode.cc lu.cc minmax.cc \
@@ -61,22 +60,28 @@ ifeq ($(ENABLE_DYNAMIC_LINKING), true)
     DLD_PICOBJ := $(addprefix pic/, $(DLD_OBJ))
   else
     DLD_PICOBJ := $(DLD_OBJ)
   endif
 else
   DLD_STATIC_OBJ := $(DLD_OBJ)
 endif
 
+OV_INTTYPE_INC := ov-base-int.h ov-int-traits.h ov-intx.h \
+	ov-int8.h ov-int16.h ov-int32.h ov-int64.h \
+	ov-uint8.h ov-uint16.h ov-uint32.h ov-uint64.h
+
 OV_INCLUDES := ov-re-mat.h ov-cx-mat.h ov-ch-mat.h ov-cs-list.h ov-list.h \
 	ov-struct.h ov-scalar.h ov-range.h ov-complex.h ov-va-args.h \
 	ov-colon.h ov-base.h ov-base-mat.h ov-base-scalar.h \
 	ov-streamoff.h ov-str-mat.h ov-bool-mat.h ov-bool.h \
 	ov-file.h ov-cell.h ov.h ov-fcn.h ov-builtin.h ov-dld-fcn.h \
-	ov-mapper.h ov-usr-fcn.h ov-fcn-handle.h ov-typeinfo.h
+	ov-mapper.h ov-usr-fcn.h ov-fcn-handle.h ov-typeinfo.h \
+	ov-type-conv.h \
+	$(OV_INTTYPE_INC)
 
 PT_INCLUDES := pt.h pt-all.h pt-arg-list.h pt-assign.h pt-binop.h \
         pt-bp.h	pt-cell.h pt-check.h pt-cmd.h pt-colon.h pt-const.h \
 	pt-decl.h pt-except.h pt-exp.h pt-fcn-handle.h pt-id.h pt-idx.h \
 	pt-jump.h pt-loop.h pt-mat.h pt-misc.h pt-plot.h \
 	pt-pr-code.h pt-select.h pt-stmt.h pt-unop.h pt-walk.h \
 
 INCLUDES := Cell.h base-list.h c-file-ptr-stream.h comment-list.h \
@@ -90,35 +95,45 @@ INCLUDES := Cell.h base-list.h c-file-pt
 	parse.h pr-output.h procstream.h sighandlers.h siglist.h \
 	symtab.h sysdep.h token.h toplev.h unwind-prot.h utils.h \
 	variables.h version.h xdiv.h xpow.h $(OV_INCLUDES) $(PT_INCLUDES)
 
 TI_XSRC := Array-oc.cc Array-os.cc Array-sym.cc Array-tc.cc
 
 TI_SRC := $(addprefix TEMPLATE-INST/, $(TI_XSRC))
 
+INTTYPE_OP_XSRC := op-int-conv.cc op-double-conv.cc \
+	op-i8-i8.cc op-i16-i16.cc op-i32-i32.cc op-i64-i64.cc \
+	op-ui8-ui8.cc op-ui16-ui16.cc op-ui32-ui32.cc op-ui64-ui64.cc
+
 OP_XSRC := op-b-b.cc op-b-bm.cc op-bm-b.cc op-bm-bm.cc \
 	op-cell.cc op-chm.cc op-cm-cm.cc op-cm-cs.cc op-cm-m.cc \
 	op-cm-s.cc op-cs-cm.cc op-cs-cs.cc op-cs-m.cc \
 	op-cs-s.cc op-fil-b.cc op-fil-bm.cc op-fil-cm.cc \
 	op-fil-cs.cc op-fil-m.cc op-fil-s.cc op-fil-lis.cc \
 	op-fil-rec.cc op-fil-str.cc op-list.cc op-m-cm.cc \
 	op-m-cs.cc op-m-m.cc op-m-s.cc op-range.cc op-s-cm.cc \
 	op-s-cs.cc op-s-m.cc op-s-s.cc op-str-m.cc \
-	op-str-s.cc op-str-str.cc op-streamoff.cc op-fcn-handle.cc
+	op-str-s.cc op-str-str.cc op-streamoff.cc op-fcn-handle.cc \
+	$(INTTYPE_OP_XSRC)
 
 OP_SRC := $(addprefix OPERATORS/, $(OP_XSRC))
 
+OV_INTTYPE_SRC := ov-base-int.cc \
+	ov-int8.cc ov-int16.cc ov-int32.cc ov-int64.cc \
+	ov-uint8.cc ov-uint16.cc ov-uint32.cc ov-uint64.cc
+
 OV_SRC := ov-base.cc ov-base-mat.cc ov-base-scalar.cc ov-ch-mat.cc \
 	ov-cs-list.cc ov-list.cc ov-re-mat.cc ov-cx-mat.cc \
 	ov-range.cc ov-scalar.cc ov-complex.cc ov-str-mat.cc \
 	ov-streamoff.cc ov-struct.cc ov-va-args.cc \
 	ov-colon.cc ov-bool-mat.cc ov-bool.cc ov-file.cc ov-cell.cc \
 	ov.cc ov-fcn.cc ov-builtin.cc ov-dld-fcn.cc ov-mapper.cc \
-	ov-usr-fcn.cc ov-fcn-handle.cc ov-typeinfo.cc
+	ov-usr-fcn.cc ov-fcn-handle.cc ov-typeinfo.cc \
+	$(OV_INTTYPE_SRC)
 
 PT_SRC := pt.cc pt-arg-list.cc pt-assign.cc pt-bp.cc pt-binop.cc \
 	pt-cell.cc pt-check.cc pt-cmd.cc pt-colon.cc pt-const.cc \
 	pt-decl.cc pt-except.cc pt-exp.cc pt-fcn-handle.cc pt-id.cc \
 	pt-idx.cc pt-jump.cc pt-loop.cc pt-mat.cc pt-misc.cc \
 	pt-plot.cc pt-pr-code.cc pt-select.cc pt-stmt.cc pt-unop.cc
 
 DIST_SRC := Cell.cc c-file-ptr-stream.cc comment-list.cc \
diff --git a/src/OPERATORS/op-double-conv.cc b/src/OPERATORS/op-double-conv.cc
new file mode 100644
--- /dev/null
+++ b/src/OPERATORS/op-double-conv.cc
@@ -0,0 +1,101 @@
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "gripes.h"
+#include "oct-obj.h"
+#include "ov.h"
+#include "ov-int8.h"
+#include "ov-int16.h"
+#include "ov-int32.h"
+#include "ov-int64.h"
+#include "ov-uint8.h"
+#include "ov-uint16.h"
+#include "ov-uint32.h"
+#include "ov-uint64.h"
+#include "ov-scalar.h"
+#include "ov-re-mat.h"
+#include "ov-typeinfo.h"
+#include "ops.h"
+
+// conversion ops
+
+DEFDBLCONVFN (int8_matrix_to_double_matrix, int8_matrix, int8_array)
+DEFDBLCONVFN (int16_matrix_to_double_matrix, int16_matrix, int16_array)
+DEFDBLCONVFN (int32_matrix_to_double_matrix, int32_matrix, int32_array)
+DEFDBLCONVFN (int64_matrix_to_double_matrix, int64_matrix, int64_array)
+
+DEFDBLCONVFN (uint8_matrix_to_double_matrix, uint8_matrix, uint8_array)
+DEFDBLCONVFN (uint16_matrix_to_double_matrix, uint16_matrix, uint16_array)
+DEFDBLCONVFN (uint32_matrix_to_double_matrix, uint32_matrix, uint32_array)
+DEFDBLCONVFN (uint64_matrix_to_double_matrix, uint64_matrix, uint64_array)
+
+DEFDBLCONVFN (int8_scalar_to_double_matrix, int8_scalar, int8_array)
+DEFDBLCONVFN (int16_scalar_to_double_matrix, int16_scalar, int16_array)
+DEFDBLCONVFN (int32_scalar_to_double_matrix, int32_scalar, int32_array)
+DEFDBLCONVFN (int64_scalar_to_double_matrix, int64_scalar, int64_array)
+
+DEFDBLCONVFN (uint8_scalar_to_double_matrix, uint8_scalar, uint8_array)
+DEFDBLCONVFN (uint16_scalar_to_double_matrix, uint16_scalar, uint16_array)
+DEFDBLCONVFN (uint32_scalar_to_double_matrix, uint32_scalar, uint32_array)
+DEFDBLCONVFN (uint64_scalar_to_double_matrix, uint64_scalar, uint64_array)
+
+DEFDBLCONVFN (double_scalar_to_double_matrix, scalar, array)
+
+void
+install_double_conv_ops (void)
+{
+  INSTALL_CONVOP (octave_int8_matrix, octave_matrix, int8_matrix_to_double_matrix);
+  INSTALL_CONVOP (octave_int16_matrix, octave_matrix, int16_matrix_to_double_matrix);
+  INSTALL_CONVOP (octave_int32_matrix, octave_matrix, int32_matrix_to_double_matrix);
+  INSTALL_CONVOP (octave_int64_matrix, octave_matrix, int64_matrix_to_double_matrix);
+
+  INSTALL_CONVOP (octave_uint8_matrix, octave_matrix, uint8_matrix_to_double_matrix);
+  INSTALL_CONVOP (octave_uint16_matrix, octave_matrix, uint16_matrix_to_double_matrix);
+  INSTALL_CONVOP (octave_uint32_matrix, octave_matrix, uint32_matrix_to_double_matrix);
+  INSTALL_CONVOP (octave_uint64_matrix, octave_matrix, uint64_matrix_to_double_matrix);
+
+  INSTALL_CONVOP (octave_int8_scalar, octave_matrix, int8_scalar_to_double_matrix);
+  INSTALL_CONVOP (octave_int16_scalar, octave_matrix, int16_scalar_to_double_matrix);
+  INSTALL_CONVOP (octave_int32_scalar, octave_matrix, int32_scalar_to_double_matrix);
+  INSTALL_CONVOP (octave_int64_scalar, octave_matrix, int64_scalar_to_double_matrix);
+
+  INSTALL_CONVOP (octave_uint8_scalar, octave_matrix, uint8_scalar_to_double_matrix);
+  INSTALL_CONVOP (octave_uint16_scalar, octave_matrix, uint16_scalar_to_double_matrix);
+  INSTALL_CONVOP (octave_uint32_scalar, octave_matrix, uint32_scalar_to_double_matrix);
+  INSTALL_CONVOP (octave_uint64_scalar, octave_matrix, uint64_scalar_to_double_matrix);
+
+  INSTALL_CONVOP (octave_scalar, octave_matrix, double_scalar_to_double_matrix);
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/OPERATORS/op-i16-i16.cc b/src/OPERATORS/op-i16-i16.cc
new file mode 100644
--- /dev/null
+++ b/src/OPERATORS/op-i16-i16.cc
@@ -0,0 +1,139 @@
+/*
+
+Copyright (C) 1996, 1997 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "gripes.h"
+#include "oct-obj.h"
+#include "ov.h"
+#include "ov-int16.h"
+#include "ov-typeinfo.h"
+#include "ops.h"
+#include "xdiv.h"
+#include "xpow.h"
+
+// matrix unary ops.
+
+DEFNDUNOP_OP (not, int16_matrix, int16_array, !)
+DEFNDUNOP_OP (uminus, int16_matrix, int16_array, -)
+
+DEFUNOP (transpose, int16_matrix)
+{
+  CAST_UNOP_ARG (const octave_int16_matrix&);
+
+  if (v.ndims () > 2)
+    {
+      error ("transpose not defined for N-d objects");
+      return octave_value ();
+    }
+  else
+    return octave_value (v.int16_array_value().transpose ());
+}
+
+//DEFNCUNOP_METHOD (incr, int16_matrix, increment)
+//DEFNCUNOP_METHOD (decr, int16_matrix, decrement)
+
+// matrix by matrix ops.
+
+DEFNDBINOP_OP (add, int16_matrix, int16_matrix, int16_array, int16_array, +)
+DEFNDBINOP_OP (sub, int16_matrix, int16_matrix, int16_array, int16_array, -)
+
+// DEFBINOP_OP (mul, int16_matrix, int16_matrix, *)
+// DEFBINOP_FN (div, int16_matrix, int16_matrix, xdiv)
+
+DEFBINOPX (pow, int16_matrix, int16_matrix)
+{
+  error ("can't do A ^ B for A and B both matrices");
+  return octave_value ();
+}
+
+//DEFBINOP_FN (ldiv, int16_matrix, int16_matrix, xleftdiv)
+
+DEFNDBINOP_FN (lt, int16_matrix, int16_matrix, int16_array, int16_array, mx_el_lt)
+DEFNDBINOP_FN (le, int16_matrix, int16_matrix, int16_array, int16_array, mx_el_le)
+DEFNDBINOP_FN (eq, int16_matrix, int16_matrix, int16_array, int16_array, mx_el_eq)
+DEFNDBINOP_FN (ge, int16_matrix, int16_matrix, int16_array, int16_array, mx_el_ge)
+DEFNDBINOP_FN (gt, int16_matrix, int16_matrix, int16_array, int16_array, mx_el_gt)
+DEFNDBINOP_FN (ne, int16_matrix, int16_matrix, int16_array, int16_array, mx_el_ne)
+
+DEFNDBINOP_FN (el_mul, int16_matrix, int16_matrix, int16_array, int16_array, product)
+
+DEFNDBINOP_FN (el_div, int16_matrix, int16_matrix, int16_array, int16_array, quotient)
+
+//DEFNDBINOP_FN (el_pow, int16_matrix, int16_matrix, int16_array, int16_array, elem_xpow)
+
+//DEFBINOP (el_ldiv, int16_matrix, int16_matrix)
+//{
+//  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
+//
+//  return octave_value (quotient (v2.array_value (), v1.array_value ()));
+//}
+
+DEFNDBINOP_FN (el_and, int16_matrix, int16_matrix, int16_array, int16_array, mx_el_and)
+DEFNDBINOP_FN (el_or,  int16_matrix, int16_matrix, int16_array, int16_array, mx_el_or)
+
+DEFNDASSIGNOP_FN (assign, int16_matrix, int16_matrix, int16_array, assign)
+
+void
+install_i16_i16_ops (void)
+{
+  INSTALL_UNOP (op_not, octave_int16_matrix, not);
+  INSTALL_UNOP (op_uminus, octave_int16_matrix, uminus);
+  INSTALL_UNOP (op_transpose, octave_int16_matrix, transpose);
+  INSTALL_UNOP (op_hermitian, octave_int16_matrix, transpose);
+
+  //  INSTALL_NCUNOP (op_incr, octave_int16_matrix, incr);
+  //  INSTALL_NCUNOP (op_decr, octave_int16_matrix, decr);
+
+  INSTALL_BINOP (op_add, octave_int16_matrix, octave_int16_matrix, add);
+  INSTALL_BINOP (op_sub, octave_int16_matrix, octave_int16_matrix, sub);
+  //  INSTALL_BINOP (op_mul, octave_int16_matrix, octave_int16_matrix, mul);
+  //  INSTALL_BINOP (op_div, octave_int16_matrix, octave_int16_matrix, div);
+  INSTALL_BINOP (op_pow, octave_int16_matrix, octave_int16_matrix, pow);
+  //  INSTALL_BINOP (op_ldiv, octave_int16_matrix, octave_int16_matrix, ldiv);
+  INSTALL_BINOP (op_lt, octave_int16_matrix, octave_int16_matrix, lt);
+  INSTALL_BINOP (op_le, octave_int16_matrix, octave_int16_matrix, le);
+  INSTALL_BINOP (op_eq, octave_int16_matrix, octave_int16_matrix, eq);
+  INSTALL_BINOP (op_ge, octave_int16_matrix, octave_int16_matrix, ge);
+  INSTALL_BINOP (op_gt, octave_int16_matrix, octave_int16_matrix, gt);
+  INSTALL_BINOP (op_ne, octave_int16_matrix, octave_int16_matrix, ne);
+  INSTALL_BINOP (op_el_mul, octave_int16_matrix, octave_int16_matrix, el_mul);
+  INSTALL_BINOP (op_el_div, octave_int16_matrix, octave_int16_matrix, el_div);
+  //  INSTALL_BINOP (op_el_pow, octave_int16_matrix, octave_int16_matrix, el_pow);
+  //  INSTALL_BINOP (op_el_ldiv, octave_int16_matrix, octave_int16_matrix, el_ldiv);
+  INSTALL_BINOP (op_el_and, octave_int16_matrix, octave_int16_matrix, el_and);
+  INSTALL_BINOP (op_el_or, octave_int16_matrix, octave_int16_matrix, el_or);
+
+  INSTALL_ASSIGNOP (op_asn_eq, octave_int16_matrix, octave_int16_matrix, assign);
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/OPERATORS/op-i32-i32.cc b/src/OPERATORS/op-i32-i32.cc
new file mode 100644
--- /dev/null
+++ b/src/OPERATORS/op-i32-i32.cc
@@ -0,0 +1,139 @@
+/*
+
+Copyright (C) 1996, 1997 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "gripes.h"
+#include "oct-obj.h"
+#include "ov.h"
+#include "ov-int32.h"
+#include "ov-typeinfo.h"
+#include "ops.h"
+#include "xdiv.h"
+#include "xpow.h"
+
+// matrix unary ops.
+
+DEFNDUNOP_OP (not, int32_matrix, int32_array, !)
+DEFNDUNOP_OP (uminus, int32_matrix, int32_array, -)
+
+DEFUNOP (transpose, int32_matrix)
+{
+  CAST_UNOP_ARG (const octave_int32_matrix&);
+
+  if (v.ndims () > 2)
+    {
+      error ("transpose not defined for N-d objects");
+      return octave_value ();
+    }
+  else
+    return octave_value (v.int32_array_value().transpose ());
+}
+
+//DEFNCUNOP_METHOD (incr, int32_matrix, increment)
+//DEFNCUNOP_METHOD (decr, int32_matrix, decrement)
+
+// matrix by matrix ops.
+
+DEFNDBINOP_OP (add, int32_matrix, int32_matrix, int32_array, int32_array, +)
+DEFNDBINOP_OP (sub, int32_matrix, int32_matrix, int32_array, int32_array, -)
+
+//DEFBINOP_OP (mul, int32_matrix, int32_matrix, *)
+//DEFBINOP_FN (div, int32_matrix, int32_matrix, xdiv)
+
+DEFBINOPX (pow, int32_matrix, int32_matrix)
+{
+  error ("can't do A ^ B for A and B both matrices");
+  return octave_value ();
+}
+
+//DEFBINOP_FN (ldiv, int32_matrix, int32_matrix, xleftdiv)
+
+DEFNDBINOP_FN (lt, int32_matrix, int32_matrix, int32_array, int32_array, mx_el_lt)
+DEFNDBINOP_FN (le, int32_matrix, int32_matrix, int32_array, int32_array, mx_el_le)
+DEFNDBINOP_FN (eq, int32_matrix, int32_matrix, int32_array, int32_array, mx_el_eq)
+DEFNDBINOP_FN (ge, int32_matrix, int32_matrix, int32_array, int32_array, mx_el_ge)
+DEFNDBINOP_FN (gt, int32_matrix, int32_matrix, int32_array, int32_array, mx_el_gt)
+DEFNDBINOP_FN (ne, int32_matrix, int32_matrix, int32_array, int32_array, mx_el_ne)
+
+DEFNDBINOP_FN (el_mul, int32_matrix, int32_matrix, int32_array, int32_array, product)
+
+DEFNDBINOP_FN (el_div, int32_matrix, int32_matrix, int32_array, int32_array, quotient)
+
+//DEFNDBINOP_FN (el_pow, int32_matrix, int32_matrix, int32_array, int32_array, elem_xpow)
+
+//DEFBINOP (el_ldiv, int32_matrix, int32_matrix)
+//{
+//  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
+//
+//  return octave_value (quotient (v2.array_value (), v1.array_value ()));
+//}
+
+DEFNDBINOP_FN (el_and, int32_matrix, int32_matrix, int32_array, int32_array, mx_el_and)
+DEFNDBINOP_FN (el_or,  int32_matrix, int32_matrix, int32_array, int32_array, mx_el_or)
+
+DEFNDASSIGNOP_FN (assign, int32_matrix, int32_matrix, int32_array, assign)
+
+void
+install_i32_i32_ops (void)
+{
+  INSTALL_UNOP (op_not, octave_int32_matrix, not);
+  INSTALL_UNOP (op_uminus, octave_int32_matrix, uminus);
+  INSTALL_UNOP (op_transpose, octave_int32_matrix, transpose);
+  INSTALL_UNOP (op_hermitian, octave_int32_matrix, transpose);
+
+  //  INSTALL_NCUNOP (op_incr, octave_int32_matrix, incr);
+  //  INSTALL_NCUNOP (op_decr, octave_int32_matrix, decr);
+
+  INSTALL_BINOP (op_add, octave_int32_matrix, octave_int32_matrix, add);
+  INSTALL_BINOP (op_sub, octave_int32_matrix, octave_int32_matrix, sub);
+  //  INSTALL_BINOP (op_mul, octave_int32_matrix, octave_int32_matrix, mul);
+  //  INSTALL_BINOP (op_div, octave_int32_matrix, octave_int32_matrix, div);
+  INSTALL_BINOP (op_pow, octave_int32_matrix, octave_int32_matrix, pow);
+  //  INSTALL_BINOP (op_ldiv, octave_int32_matrix, octave_int32_matrix, ldiv);
+  INSTALL_BINOP (op_lt, octave_int32_matrix, octave_int32_matrix, lt);
+  INSTALL_BINOP (op_le, octave_int32_matrix, octave_int32_matrix, le);
+  INSTALL_BINOP (op_eq, octave_int32_matrix, octave_int32_matrix, eq);
+  INSTALL_BINOP (op_ge, octave_int32_matrix, octave_int32_matrix, ge);
+  INSTALL_BINOP (op_gt, octave_int32_matrix, octave_int32_matrix, gt);
+  INSTALL_BINOP (op_ne, octave_int32_matrix, octave_int32_matrix, ne);
+  INSTALL_BINOP (op_el_mul, octave_int32_matrix, octave_int32_matrix, el_mul);
+  INSTALL_BINOP (op_el_div, octave_int32_matrix, octave_int32_matrix, el_div);
+  //  INSTALL_BINOP (op_el_pow, octave_int32_matrix, octave_int32_matrix, el_pow);
+  //  INSTALL_BINOP (op_el_ldiv, octave_int32_matrix, octave_int32_matrix, el_ldiv);
+  INSTALL_BINOP (op_el_and, octave_int32_matrix, octave_int32_matrix, el_and);
+  INSTALL_BINOP (op_el_or, octave_int32_matrix, octave_int32_matrix, el_or);
+
+  INSTALL_ASSIGNOP (op_asn_eq, octave_int32_matrix, octave_int32_matrix, assign);
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/OPERATORS/op-i64-i64.cc b/src/OPERATORS/op-i64-i64.cc
new file mode 100644
--- /dev/null
+++ b/src/OPERATORS/op-i64-i64.cc
@@ -0,0 +1,139 @@
+/*
+
+Copyright (C) 1996, 1997 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "gripes.h"
+#include "oct-obj.h"
+#include "ov.h"
+#include "ov-int64.h"
+#include "ov-typeinfo.h"
+#include "ops.h"
+#include "xdiv.h"
+#include "xpow.h"
+
+// matrix unary ops.
+
+DEFNDUNOP_OP (not, int64_matrix, int64_array, !)
+DEFNDUNOP_OP (uminus, int64_matrix, int64_array, -)
+
+DEFUNOP (transpose, int64_matrix)
+{
+  CAST_UNOP_ARG (const octave_int64_matrix&);
+
+  if (v.ndims () > 2)
+    {
+      error ("transpose not defined for N-d objects");
+      return octave_value ();
+    }
+  else
+    return octave_value (v.int64_array_value().transpose ());
+}
+
+//DEFNCUNOP_METHOD (incr, int64_matrix, increment)
+//DEFNCUNOP_METHOD (decr, int64_matrix, decrement)
+
+// matrix by matrix ops.
+
+//DEFNDBINOP_OP (add, int64_matrix, int64_matrix, int64_array, int64_array, +)
+//DEFNDBINOP_OP (sub, int64_matrix, int64_matrix, int64_array, int64_array, -)
+
+//DEFBINOP_OP (mul, int64_matrix, int64_matrix, *)
+//DEFBINOP_FN (div, int64_matrix, int64_matrix, xdiv)
+
+DEFBINOPX (pow, int64_matrix, int64_matrix)
+{
+  error ("can't do A ^ B for A and B both matrices");
+  return octave_value ();
+}
+
+//DEFBINOP_FN (ldiv, int64_matrix, int64_matrix, xleftdiv)
+
+DEFNDBINOP_FN (lt, int64_matrix, int64_matrix, int64_array, int64_array, mx_el_lt)
+DEFNDBINOP_FN (le, int64_matrix, int64_matrix, int64_array, int64_array, mx_el_le)
+DEFNDBINOP_FN (eq, int64_matrix, int64_matrix, int64_array, int64_array, mx_el_eq)
+DEFNDBINOP_FN (ge, int64_matrix, int64_matrix, int64_array, int64_array, mx_el_ge)
+DEFNDBINOP_FN (gt, int64_matrix, int64_matrix, int64_array, int64_array, mx_el_gt)
+DEFNDBINOP_FN (ne, int64_matrix, int64_matrix, int64_array, int64_array, mx_el_ne)
+
+//DEFNDBINOP_FN (el_mul, int64_matrix, int64_matrix, int64_array, int64_array, product)
+
+//DEFNDBINOP_FN (el_div, int64_matrix, int64_matrix, int64_array, int64_array, quotient)
+
+//DEFNDBINOP_FN (el_pow, int64_matrix, int64_matrix, int64_array, int64_array, elem_xpow)
+
+//DEFBINOP (el_ldiv, int64_matrix, int64_matrix)
+//{
+//  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
+//
+//  return octave_value (quotient (v2.array_value (), v1.array_value ()));
+//}
+
+DEFNDBINOP_FN (el_and, int64_matrix, int64_matrix, int64_array, int64_array, mx_el_and)
+DEFNDBINOP_FN (el_or,  int64_matrix, int64_matrix, int64_array, int64_array, mx_el_or)
+
+DEFNDASSIGNOP_FN (assign, int64_matrix, int64_matrix, int64_array, assign)
+
+void
+install_i64_i64_ops (void)
+{
+  INSTALL_UNOP (op_not, octave_int64_matrix, not);
+  INSTALL_UNOP (op_uminus, octave_int64_matrix, uminus);
+  INSTALL_UNOP (op_transpose, octave_int64_matrix, transpose);
+  INSTALL_UNOP (op_hermitian, octave_int64_matrix, transpose);
+
+  //  INSTALL_NCUNOP (op_incr, octave_int64_matrix, incr);
+  //  INSTALL_NCUNOP (op_decr, octave_int64_matrix, decr);
+
+  //  INSTALL_BINOP (op_add, octave_int64_matrix, octave_int64_matrix, add);
+  //  INSTALL_BINOP (op_sub, octave_int64_matrix, octave_int64_matrix, sub);
+  //  INSTALL_BINOP (op_mul, octave_int64_matrix, octave_int64_matrix, mul);
+  //  INSTALL_BINOP (op_div, octave_int64_matrix, octave_int64_matrix, div);
+  INSTALL_BINOP (op_pow, octave_int64_matrix, octave_int64_matrix, pow);
+  //  INSTALL_BINOP (op_ldiv, octave_int64_matrix, octave_int64_matrix, ldiv);
+  INSTALL_BINOP (op_lt, octave_int64_matrix, octave_int64_matrix, lt);
+  INSTALL_BINOP (op_le, octave_int64_matrix, octave_int64_matrix, le);
+  INSTALL_BINOP (op_eq, octave_int64_matrix, octave_int64_matrix, eq);
+  INSTALL_BINOP (op_ge, octave_int64_matrix, octave_int64_matrix, ge);
+  INSTALL_BINOP (op_gt, octave_int64_matrix, octave_int64_matrix, gt);
+  INSTALL_BINOP (op_ne, octave_int64_matrix, octave_int64_matrix, ne);
+  //  INSTALL_BINOP (op_el_mul, octave_int64_matrix, octave_int64_matrix, el_mul);
+  //  INSTALL_BINOP (op_el_div, octave_int64_matrix, octave_int64_matrix, el_div);
+  //  INSTALL_BINOP (op_el_pow, octave_int64_matrix, octave_int64_matrix, el_pow);
+  //  INSTALL_BINOP (op_el_ldiv, octave_int64_matrix, octave_int64_matrix, el_ldiv);
+  INSTALL_BINOP (op_el_and, octave_int64_matrix, octave_int64_matrix, el_and);
+  INSTALL_BINOP (op_el_or, octave_int64_matrix, octave_int64_matrix, el_or);
+
+  INSTALL_ASSIGNOP (op_asn_eq, octave_int64_matrix, octave_int64_matrix, assign);
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/OPERATORS/op-i8-i8.cc b/src/OPERATORS/op-i8-i8.cc
new file mode 100644
--- /dev/null
+++ b/src/OPERATORS/op-i8-i8.cc
@@ -0,0 +1,139 @@
+/*
+
+Copyright (C) 1996, 1997 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "gripes.h"
+#include "oct-obj.h"
+#include "ov.h"
+#include "ov-int8.h"
+#include "ov-typeinfo.h"
+#include "ops.h"
+#include "xdiv.h"
+#include "xpow.h"
+
+// matrix unary ops.
+
+DEFNDUNOP_OP (not, int8_matrix, int8_array, !)
+DEFNDUNOP_OP (uminus, int8_matrix, int8_array, -)
+
+DEFUNOP (transpose, int8_matrix)
+{
+  CAST_UNOP_ARG (const octave_int8_matrix&);
+
+  if (v.ndims () > 2)
+    {
+      error ("transpose not defined for N-d objects");
+      return octave_value ();
+    }
+  else
+    return octave_value (v.int8_array_value().transpose ());
+}
+
+//DEFNCUNOP_METHOD (incr, int8_matrix, increment)
+//DEFNCUNOP_METHOD (decr, int8_matrix, decrement)
+
+// matrix by matrix ops.
+
+DEFNDBINOP_OP (add, int8_matrix, int8_matrix, int8_array, int8_array, +)
+DEFNDBINOP_OP (sub, int8_matrix, int8_matrix, int8_array, int8_array, -)
+
+// DEFBINOP_OP (mul, int8_matrix, int8_matrix, *)
+// DEFBINOP_FN (div, int8_matrix, int8_matrix, xdiv)
+
+DEFBINOPX (pow, int8_matrix, int8_matrix)
+{
+  error ("can't do A ^ B for A and B both matrices");
+  return octave_value ();
+}
+
+// DEFBINOP_FN (ldiv, int8_matrix, int8_matrix, xleftdiv)
+
+DEFNDBINOP_FN (lt, int8_matrix, int8_matrix, int8_array, int8_array, mx_el_lt)
+DEFNDBINOP_FN (le, int8_matrix, int8_matrix, int8_array, int8_array, mx_el_le)
+DEFNDBINOP_FN (eq, int8_matrix, int8_matrix, int8_array, int8_array, mx_el_eq)
+DEFNDBINOP_FN (ge, int8_matrix, int8_matrix, int8_array, int8_array, mx_el_ge)
+DEFNDBINOP_FN (gt, int8_matrix, int8_matrix, int8_array, int8_array, mx_el_gt)
+DEFNDBINOP_FN (ne, int8_matrix, int8_matrix, int8_array, int8_array, mx_el_ne)
+
+DEFNDBINOP_FN (el_mul, int8_matrix, int8_matrix, int8_array, int8_array, product)
+
+DEFNDBINOP_FN (el_div, int8_matrix, int8_matrix, int8_array, int8_array, quotient)
+
+//DEFNDBINOP_FN (el_pow, int8_matrix, int8_matrix, int8_array, int8_array, elem_xpow)
+
+//DEFBINOP (el_ldiv, int8_matrix, int8_matrix)
+//{
+//  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
+//
+//  return octave_value (quotient (v2.array_value (), v1.array_value ()));
+//}
+
+DEFNDBINOP_FN (el_and, int8_matrix, int8_matrix, int8_array, int8_array, mx_el_and)
+DEFNDBINOP_FN (el_or,  int8_matrix, int8_matrix, int8_array, int8_array, mx_el_or)
+
+DEFNDASSIGNOP_FN (assign, int8_matrix, int8_matrix, int8_array, assign)
+
+void
+install_i8_i8_ops (void)
+{
+  INSTALL_UNOP (op_not, octave_int8_matrix, not);
+  INSTALL_UNOP (op_uminus, octave_int8_matrix, uminus);
+  INSTALL_UNOP (op_transpose, octave_int8_matrix, transpose);
+  INSTALL_UNOP (op_hermitian, octave_int8_matrix, transpose);
+
+  //  INSTALL_NCUNOP (op_incr, octave_int8_matrix, incr);
+  //  INSTALL_NCUNOP (op_decr, octave_int8_matrix, decr);
+
+  INSTALL_BINOP (op_add, octave_int8_matrix, octave_int8_matrix, add);
+  INSTALL_BINOP (op_sub, octave_int8_matrix, octave_int8_matrix, sub);
+  //  INSTALL_BINOP (op_mul, octave_int8_matrix, octave_int8_matrix, mul);
+  //  INSTALL_BINOP (op_div, octave_int8_matrix, octave_int8_matrix, div);
+  INSTALL_BINOP (op_pow, octave_int8_matrix, octave_int8_matrix, pow);
+  //  INSTALL_BINOP (op_ldiv, octave_int8_matrix, octave_int8_matrix, ldiv);
+  INSTALL_BINOP (op_lt, octave_int8_matrix, octave_int8_matrix, lt);
+  INSTALL_BINOP (op_le, octave_int8_matrix, octave_int8_matrix, le);
+  INSTALL_BINOP (op_eq, octave_int8_matrix, octave_int8_matrix, eq);
+  INSTALL_BINOP (op_ge, octave_int8_matrix, octave_int8_matrix, ge);
+  INSTALL_BINOP (op_gt, octave_int8_matrix, octave_int8_matrix, gt);
+  INSTALL_BINOP (op_ne, octave_int8_matrix, octave_int8_matrix, ne);
+  INSTALL_BINOP (op_el_mul, octave_int8_matrix, octave_int8_matrix, el_mul);
+  INSTALL_BINOP (op_el_div, octave_int8_matrix, octave_int8_matrix, el_div);
+  //  INSTALL_BINOP (op_el_pow, octave_int8_matrix, octave_int8_matrix, el_pow);
+  //  INSTALL_BINOP (op_el_ldiv, octave_int8_matrix, octave_int8_matrix, el_ldiv);
+  INSTALL_BINOP (op_el_and, octave_int8_matrix, octave_int8_matrix, el_and);
+  INSTALL_BINOP (op_el_or, octave_int8_matrix, octave_int8_matrix, el_or);
+
+  INSTALL_ASSIGNOP (op_asn_eq, octave_int8_matrix, octave_int8_matrix, assign);
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/OPERATORS/op-int-conv.cc b/src/OPERATORS/op-int-conv.cc
new file mode 100644
--- /dev/null
+++ b/src/OPERATORS/op-int-conv.cc
@@ -0,0 +1,159 @@
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "gripes.h"
+#include "oct-obj.h"
+#include "ov.h"
+#include "ov-int8.h"
+#include "ov-int16.h"
+#include "ov-int32.h"
+#include "ov-int64.h"
+#include "ov-uint8.h"
+#include "ov-uint16.h"
+#include "ov-uint32.h"
+#include "ov-uint64.h"
+#include "ov-scalar.h"
+#include "ov-re-mat.h"
+#include "ov-typeinfo.h"
+#include "ops.h"
+
+// conversion ops
+
+DEFCONVFN (scalar_to_int8, scalar, int8)
+DEFCONVFN (scalar_to_int16, scalar, int16)
+DEFCONVFN (scalar_to_int32, scalar, int32)
+DEFCONVFN (scalar_to_int64, scalar, int64)
+
+DEFCONVFN (scalar_to_uint8, scalar, uint8)
+DEFCONVFN (scalar_to_uint16, scalar, uint16)
+DEFCONVFN (scalar_to_uint32, scalar, uint32)
+DEFCONVFN (scalar_to_uint64, scalar, uint64)
+
+DEFCONVFN (matrix_to_int8, matrix, int8)
+DEFCONVFN (matrix_to_int16, matrix, int16)
+DEFCONVFN (matrix_to_int32, matrix, int32)
+DEFCONVFN (matrix_to_int64, matrix, int64)
+
+DEFCONVFN (matrix_to_uint8, matrix, uint8)
+DEFCONVFN (matrix_to_uint16, matrix, uint16)
+DEFCONVFN (matrix_to_uint32, matrix, uint32)
+DEFCONVFN (matrix_to_uint64, matrix, uint64)
+
+#define INT_CONV_FUNCTIONS(tfrom) \
+  DEFCONVFN2 (tfrom ## _scalar_to_int8, tfrom, scalar, int8) \
+  DEFCONVFN2 (tfrom ## _scalar_to_int16, tfrom, scalar, int16) \
+  DEFCONVFN2 (tfrom ## _scalar_to_int32, tfrom, scalar, int32) \
+  DEFCONVFN2 (tfrom ## _scalar_to_int64, tfrom, scalar, int64) \
+ \
+  DEFCONVFN2 (tfrom ## _scalar_to_uint8, tfrom, scalar, int8) \
+  DEFCONVFN2 (tfrom ## _scalar_to_uint16, tfrom, scalar, int16) \
+  DEFCONVFN2 (tfrom ## _scalar_to_uint32, tfrom, scalar, int32) \
+  DEFCONVFN2 (tfrom ## _scalar_to_uint64, tfrom, scalar, int64) \
+ \
+  DEFCONVFN2 (tfrom ## _matrix_to_int8, tfrom, matrix, uint8) \
+  DEFCONVFN2 (tfrom ## _matrix_to_int16, tfrom, matrix, uint16) \
+  DEFCONVFN2 (tfrom ## _matrix_to_int32, tfrom, matrix, uint32) \
+  DEFCONVFN2 (tfrom ## _matrix_to_int64, tfrom, matrix, uint64) \
+ \
+  DEFCONVFN2 (tfrom ## _matrix_to_uint8, tfrom, matrix, uint8) \
+  DEFCONVFN2 (tfrom ## _matrix_to_uint16, tfrom, matrix, uint16) \
+  DEFCONVFN2 (tfrom ## _matrix_to_uint32, tfrom, matrix, uint32) \
+  DEFCONVFN2 (tfrom ## _matrix_to_uint64, tfrom, matrix, uint64)
+
+INT_CONV_FUNCTIONS (int8)
+INT_CONV_FUNCTIONS (int16)
+INT_CONV_FUNCTIONS (int32)
+INT_CONV_FUNCTIONS (int64)
+
+INT_CONV_FUNCTIONS (uint8)
+INT_CONV_FUNCTIONS (uint16)
+INT_CONV_FUNCTIONS (uint32)
+INT_CONV_FUNCTIONS (uint64)
+
+#define INSTALL_INT_CONV_FUNCTIONS(tfrom) \
+  INSTALL_CONVOP (octave_ ## tfrom ## _scalar, octave_int8_matrix, tfrom ## _scalar_to_int8) \
+  INSTALL_CONVOP (octave_ ## tfrom ## _scalar, octave_int16_matrix, tfrom ## _scalar_to_int16) \
+  INSTALL_CONVOP (octave_ ## tfrom ## _scalar, octave_int32_matrix, tfrom ## _scalar_to_int32) \
+  INSTALL_CONVOP (octave_ ## tfrom ## _scalar, octave_int64_matrix, tfrom ## _scalar_to_int64) \
+ \
+  INSTALL_CONVOP (octave_ ## tfrom ## _scalar, octave_uint8_matrix, tfrom ## _scalar_to_uint8) \
+  INSTALL_CONVOP (octave_ ## tfrom ## _scalar, octave_uint16_matrix, tfrom ## _scalar_to_uint16) \
+  INSTALL_CONVOP (octave_ ## tfrom ## _scalar, octave_uint32_matrix, tfrom ## _scalar_to_uint32) \
+  INSTALL_CONVOP (octave_ ## tfrom ## _scalar, octave_uint64_matrix, tfrom ## _scalar_to_uint64) \
+ \
+  INSTALL_CONVOP (octave_ ## tfrom ## _matrix, octave_int8_matrix, tfrom ## _matrix_to_int8) \
+  INSTALL_CONVOP (octave_ ## tfrom ## _matrix, octave_int16_matrix, tfrom ## _matrix_to_int16) \
+  INSTALL_CONVOP (octave_ ## tfrom ## _matrix, octave_int32_matrix, tfrom ## _matrix_to_int32) \
+  INSTALL_CONVOP (octave_ ## tfrom ## _matrix, octave_int64_matrix, tfrom ## _matrix_to_int64) \
+ \
+  INSTALL_CONVOP (octave_ ## tfrom ## _matrix, octave_uint8_matrix, tfrom ## _matrix_to_uint8) \
+  INSTALL_CONVOP (octave_ ## tfrom ## _matrix, octave_uint16_matrix, tfrom ## _matrix_to_uint16) \
+  INSTALL_CONVOP (octave_ ## tfrom ## _matrix, octave_uint32_matrix, tfrom ## _matrix_to_uint32) \
+  INSTALL_CONVOP (octave_ ## tfrom ## _matrix, octave_uint64_matrix, tfrom ## _matrix_to_uint64) \
+
+void
+install_int_conv_ops (void)
+{
+  INSTALL_CONVOP (octave_scalar, octave_int8_matrix, scalar_to_int8);
+  INSTALL_CONVOP (octave_scalar, octave_int16_matrix, scalar_to_int16);
+  INSTALL_CONVOP (octave_scalar, octave_int32_matrix, scalar_to_int32);
+  INSTALL_CONVOP (octave_scalar, octave_int64_matrix, scalar_to_int64);
+
+  INSTALL_CONVOP (octave_scalar, octave_uint8_matrix, scalar_to_uint8);
+  INSTALL_CONVOP (octave_scalar, octave_uint16_matrix, scalar_to_uint16);
+  INSTALL_CONVOP (octave_scalar, octave_uint32_matrix, scalar_to_uint32);
+  INSTALL_CONVOP (octave_scalar, octave_uint64_matrix, scalar_to_uint64);
+
+  INSTALL_CONVOP (octave_matrix, octave_int8_matrix, matrix_to_int8);
+  INSTALL_CONVOP (octave_matrix, octave_int16_matrix, matrix_to_int16);
+  INSTALL_CONVOP (octave_matrix, octave_int32_matrix, matrix_to_int32);
+  INSTALL_CONVOP (octave_matrix, octave_int64_matrix, matrix_to_int64);
+
+  INSTALL_CONVOP (octave_matrix, octave_uint8_matrix, matrix_to_uint8);
+  INSTALL_CONVOP (octave_matrix, octave_uint16_matrix, matrix_to_uint16);
+  INSTALL_CONVOP (octave_matrix, octave_uint32_matrix, matrix_to_uint32);
+  INSTALL_CONVOP (octave_matrix, octave_uint64_matrix, matrix_to_uint64);
+
+  INSTALL_INT_CONV_FUNCTIONS (int8)
+  INSTALL_INT_CONV_FUNCTIONS (int16)
+  INSTALL_INT_CONV_FUNCTIONS (int32)
+  INSTALL_INT_CONV_FUNCTIONS (int64)
+
+  INSTALL_INT_CONV_FUNCTIONS (uint8)
+  INSTALL_INT_CONV_FUNCTIONS (uint16)
+  INSTALL_INT_CONV_FUNCTIONS (uint32)
+  INSTALL_INT_CONV_FUNCTIONS (uint64)
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/OPERATORS/op-ui16-ui16.cc b/src/OPERATORS/op-ui16-ui16.cc
new file mode 100644
--- /dev/null
+++ b/src/OPERATORS/op-ui16-ui16.cc
@@ -0,0 +1,139 @@
+/*
+
+Copyright (C) 1996, 1997 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "gripes.h"
+#include "oct-obj.h"
+#include "ov.h"
+#include "ov-uint16.h"
+#include "ov-typeinfo.h"
+#include "ops.h"
+#include "xdiv.h"
+#include "xpow.h"
+
+// matrix unary ops.
+
+DEFNDUNOP_OP (not, uint16_matrix, uint16_array, !)
+DEFNDUNOP_OP (uminus, uint16_matrix, uint16_array, -)
+
+DEFUNOP (transpose, uint16_matrix)
+{
+  CAST_UNOP_ARG (const octave_uint16_matrix&);
+
+  if (v.ndims () > 2)
+    {
+      error ("transpose not defined for N-d objects");
+      return octave_value ();
+    }
+  else
+    return octave_value (v.uint16_array_value().transpose ());
+}
+
+//DEFNCUNOP_METHOD (incr, uint16_matrix, increment)
+//DEFNCUNOP_METHOD (decr, uint16_matrix, decrement)
+
+// matrix by matrix ops.
+
+DEFNDBINOP_OP (add, uint16_matrix, uint16_matrix, uint16_array, uint16_array, +)
+DEFNDBINOP_OP (sub, uint16_matrix, uint16_matrix, uint16_array, uint16_array, -)
+
+//DEFBINOP_OP (mul, uint16_matrix, uint16_matrix, *)
+//DEFBINOP_FN (div, uint16_matrix, uint16_matrix, xdiv)
+
+DEFBINOPX (pow, uint16_matrix, uint16_matrix)
+{
+  error ("can't do A ^ B for A and B both matrices");
+  return octave_value ();
+}
+
+//DEFBINOP_FN (ldiv, uint16_matrix, uint16_matrix, xleftdiv)
+
+DEFNDBINOP_FN (lt, uint16_matrix, uint16_matrix, uint16_array, uint16_array, mx_el_lt)
+DEFNDBINOP_FN (le, uint16_matrix, uint16_matrix, uint16_array, uint16_array, mx_el_le)
+DEFNDBINOP_FN (eq, uint16_matrix, uint16_matrix, uint16_array, uint16_array, mx_el_eq)
+DEFNDBINOP_FN (ge, uint16_matrix, uint16_matrix, uint16_array, uint16_array, mx_el_ge)
+DEFNDBINOP_FN (gt, uint16_matrix, uint16_matrix, uint16_array, uint16_array, mx_el_gt)
+DEFNDBINOP_FN (ne, uint16_matrix, uint16_matrix, uint16_array, uint16_array, mx_el_ne)
+
+DEFNDBINOP_FN (el_mul, uint16_matrix, uint16_matrix, uint16_array, uint16_array, product)
+
+DEFNDBINOP_FN (el_div, uint16_matrix, uint16_matrix, uint16_array, uint16_array, quotient)
+
+//DEFNDBINOP_FN (el_pow, uint16_matrix, uint16_matrix, uint16_array, uint16_array, elem_xpow)
+
+//DEFBINOP (el_ldiv, uint16_matrix, uint16_matrix)
+//{
+//  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
+//
+//  return octave_value (quotient (v2.array_value (), v1.array_value ()));
+//}
+
+DEFNDBINOP_FN (el_and, uint16_matrix, uint16_matrix, uint16_array, uint16_array, mx_el_and)
+DEFNDBINOP_FN (el_or,  uint16_matrix, uint16_matrix, uint16_array, uint16_array, mx_el_or)
+
+DEFNDASSIGNOP_FN (assign, uint16_matrix, uint16_matrix, uint16_array, assign)
+
+void
+install_ui16_ui16_ops (void)
+{
+  INSTALL_UNOP (op_not, octave_uint16_matrix, not);
+  INSTALL_UNOP (op_uminus, octave_uint16_matrix, uminus);
+  INSTALL_UNOP (op_transpose, octave_uint16_matrix, transpose);
+  INSTALL_UNOP (op_hermitian, octave_uint16_matrix, transpose);
+
+  //  INSTALL_NCUNOP (op_incr, octave_uint16_matrix, incr);
+  //  INSTALL_NCUNOP (op_decr, octave_uint16_matrix, decr);
+
+  INSTALL_BINOP (op_add, octave_uint16_matrix, octave_uint16_matrix, add);
+  INSTALL_BINOP (op_sub, octave_uint16_matrix, octave_uint16_matrix, sub);
+  //  INSTALL_BINOP (op_mul, octave_uint16_matrix, octave_uint16_matrix, mul);
+  //  INSTALL_BINOP (op_div, octave_uint16_matrix, octave_uint16_matrix, div);
+  //  INSTALL_BINOP (op_pow, octave_uint16_matrix, octave_uint16_matrix, pow);
+  //  INSTALL_BINOP (op_ldiv, octave_uint16_matrix, octave_uint16_matrix, ldiv);
+  INSTALL_BINOP (op_lt, octave_uint16_matrix, octave_uint16_matrix, lt);
+  INSTALL_BINOP (op_le, octave_uint16_matrix, octave_uint16_matrix, le);
+  INSTALL_BINOP (op_eq, octave_uint16_matrix, octave_uint16_matrix, eq);
+  INSTALL_BINOP (op_ge, octave_uint16_matrix, octave_uint16_matrix, ge);
+  INSTALL_BINOP (op_gt, octave_uint16_matrix, octave_uint16_matrix, gt);
+  INSTALL_BINOP (op_ne, octave_uint16_matrix, octave_uint16_matrix, ne);
+  INSTALL_BINOP (op_el_mul, octave_uint16_matrix, octave_uint16_matrix, el_mul);
+  INSTALL_BINOP (op_el_div, octave_uint16_matrix, octave_uint16_matrix, el_div);
+  //  INSTALL_BINOP (op_el_pow, octave_uint16_matrix, octave_uint16_matrix, el_pow);
+  //  INSTALL_BINOP (op_el_ldiv, octave_uint16_matrix, octave_uint16_matrix, el_ldiv);
+  INSTALL_BINOP (op_el_and, octave_uint16_matrix, octave_uint16_matrix, el_and);
+  INSTALL_BINOP (op_el_or, octave_uint16_matrix, octave_uint16_matrix, el_or);
+
+  INSTALL_ASSIGNOP (op_asn_eq, octave_uint16_matrix, octave_uint16_matrix, assign);
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/OPERATORS/op-ui32-ui32.cc b/src/OPERATORS/op-ui32-ui32.cc
new file mode 100644
--- /dev/null
+++ b/src/OPERATORS/op-ui32-ui32.cc
@@ -0,0 +1,139 @@
+/*
+
+Copyright (C) 1996, 1997 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "gripes.h"
+#include "oct-obj.h"
+#include "ov.h"
+#include "ov-uint32.h"
+#include "ov-typeinfo.h"
+#include "ops.h"
+#include "xdiv.h"
+#include "xpow.h"
+
+// matrix unary ops.
+
+DEFNDUNOP_OP (not, uint32_matrix, uint32_array, !)
+DEFNDUNOP_OP (uminus, uint32_matrix, uint32_array, -)
+
+DEFUNOP (transpose, uint32_matrix)
+{
+  CAST_UNOP_ARG (const octave_uint32_matrix&);
+
+  if (v.ndims () > 2)
+    {
+      error ("transpose not defined for N-d objects");
+      return octave_value ();
+    }
+  else
+    return octave_value (v.uint32_array_value().transpose ());
+}
+
+//DEFNCUNOP_METHOD (incr, uint32_matrix, increment)
+//DEFNCUNOP_METHOD (decr, uint32_matrix, decrement)
+
+// matrix by matrix ops.
+
+DEFNDBINOP_OP (add, uint32_matrix, uint32_matrix, uint32_array, uint32_array, +)
+DEFNDBINOP_OP (sub, uint32_matrix, uint32_matrix, uint32_array, uint32_array, -)
+
+//DEFBINOP_OP (mul, uint32_matrix, uint32_matrix, *)
+//DEFBINOP_FN (div, uint32_matrix, uint32_matrix, xdiv)
+
+DEFBINOPX (pow, uint32_matrix, uint32_matrix)
+{
+  error ("can't do A ^ B for A and B both matrices");
+  return octave_value ();
+}
+
+//DEFBINOP_FN (ldiv, uint32_matrix, uint32_matrix, xleftdiv)
+
+DEFNDBINOP_FN (lt, uint32_matrix, uint32_matrix, uint32_array, uint32_array, mx_el_lt)
+DEFNDBINOP_FN (le, uint32_matrix, uint32_matrix, uint32_array, uint32_array, mx_el_le)
+DEFNDBINOP_FN (eq, uint32_matrix, uint32_matrix, uint32_array, uint32_array, mx_el_eq)
+DEFNDBINOP_FN (ge, uint32_matrix, uint32_matrix, uint32_array, uint32_array, mx_el_ge)
+DEFNDBINOP_FN (gt, uint32_matrix, uint32_matrix, uint32_array, uint32_array, mx_el_gt)
+DEFNDBINOP_FN (ne, uint32_matrix, uint32_matrix, uint32_array, uint32_array, mx_el_ne)
+
+DEFNDBINOP_FN (el_mul, uint32_matrix, uint32_matrix, uint32_array, uint32_array, product)
+
+DEFNDBINOP_FN (el_div, uint32_matrix, uint32_matrix, uint32_array, uint32_array, quotient)
+
+//DEFNDBINOP_FN (el_pow, uint32_matrix, uint32_matrix, uint32_array, uint32_array, elem_xpow)
+
+//DEFBINOP (el_ldiv, uint32_matrix, uint32_matrix)
+//{
+//  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
+//
+//  return octave_value (quotient (v2.array_value (), v1.array_value ()));
+//}
+
+DEFNDBINOP_FN (el_and, uint32_matrix, uint32_matrix, uint32_array, uint32_array, mx_el_and)
+DEFNDBINOP_FN (el_or,  uint32_matrix, uint32_matrix, uint32_array, uint32_array, mx_el_or)
+
+DEFNDASSIGNOP_FN (assign, uint32_matrix, uint32_matrix, uint32_array, assign)
+
+void
+install_ui32_ui32_ops (void)
+{
+  INSTALL_UNOP (op_not, octave_uint32_matrix, not);
+  INSTALL_UNOP (op_uminus, octave_uint32_matrix, uminus);
+  INSTALL_UNOP (op_transpose, octave_uint32_matrix, transpose);
+  INSTALL_UNOP (op_hermitian, octave_uint32_matrix, transpose);
+
+  //  INSTALL_NCUNOP (op_incr, octave_uint32_matrix, incr);
+  //  INSTALL_NCUNOP (op_decr, octave_uint32_matrix, decr);
+
+  INSTALL_BINOP (op_add, octave_uint32_matrix, octave_uint32_matrix, add);
+  INSTALL_BINOP (op_sub, octave_uint32_matrix, octave_uint32_matrix, sub);
+  //  INSTALL_BINOP (op_mul, octave_uint32_matrix, octave_uint32_matrix, mul);
+  //  INSTALL_BINOP (op_div, octave_uint32_matrix, octave_uint32_matrix, div);
+  //  INSTALL_BINOP (op_pow, octave_uint32_matrix, octave_uint32_matrix, pow);
+  //  INSTALL_BINOP (op_ldiv, octave_uint32_matrix, octave_uint32_matrix, ldiv);
+  INSTALL_BINOP (op_lt, octave_uint32_matrix, octave_uint32_matrix, lt);
+  INSTALL_BINOP (op_le, octave_uint32_matrix, octave_uint32_matrix, le);
+  INSTALL_BINOP (op_eq, octave_uint32_matrix, octave_uint32_matrix, eq);
+  INSTALL_BINOP (op_ge, octave_uint32_matrix, octave_uint32_matrix, ge);
+  INSTALL_BINOP (op_gt, octave_uint32_matrix, octave_uint32_matrix, gt);
+  INSTALL_BINOP (op_ne, octave_uint32_matrix, octave_uint32_matrix, ne);
+  INSTALL_BINOP (op_el_mul, octave_uint32_matrix, octave_uint32_matrix, el_mul);
+  INSTALL_BINOP (op_el_div, octave_uint32_matrix, octave_uint32_matrix, el_div);
+  //  INSTALL_BINOP (op_el_pow, octave_uint32_matrix, octave_uint32_matrix, el_pow);
+  //  INSTALL_BINOP (op_el_ldiv, octave_uint32_matrix, octave_uint32_matrix, el_ldiv);
+  INSTALL_BINOP (op_el_and, octave_uint32_matrix, octave_uint32_matrix, el_and);
+  INSTALL_BINOP (op_el_or, octave_uint32_matrix, octave_uint32_matrix, el_or);
+
+  INSTALL_ASSIGNOP (op_asn_eq, octave_uint32_matrix, octave_uint32_matrix, assign);
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/OPERATORS/op-ui64-ui64.cc b/src/OPERATORS/op-ui64-ui64.cc
new file mode 100644
--- /dev/null
+++ b/src/OPERATORS/op-ui64-ui64.cc
@@ -0,0 +1,139 @@
+/*
+
+Copyright (C) 1996, 1997 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "gripes.h"
+#include "oct-obj.h"
+#include "ov.h"
+#include "ov-uint64.h"
+#include "ov-typeinfo.h"
+#include "ops.h"
+#include "xdiv.h"
+#include "xpow.h"
+
+// matrix unary ops.
+
+DEFNDUNOP_OP (not, uint64_matrix, uint64_array, !)
+DEFNDUNOP_OP (uminus, uint64_matrix, uint64_array, -)
+
+DEFUNOP (transpose, uint64_matrix)
+{
+  CAST_UNOP_ARG (const octave_uint64_matrix&);
+
+  if (v.ndims () > 2)
+    {
+      error ("transpose not defined for N-d objects");
+      return octave_value ();
+    }
+  else
+    return octave_value (v.uint64_array_value().transpose ());
+}
+
+//DEFNCUNOP_METHOD (incr, uint64_matrix, increment)
+//DEFNCUNOP_METHOD (decr, uint64_matrix, decrement)
+
+// matrix by matrix ops.
+
+//DEFNDBINOP_OP (add, uint64_matrix, uint64_matrix, uint64_array, uint64_array, +)
+//DEFNDBINOP_OP (sub, uint64_matrix, uint64_matrix, uint64_array, uint64_array, -)
+
+//DEFBINOP_OP (mul, uint64_matrix, uint64_matrix, *)
+//DEFBINOP_FN (div, uint64_matrix, uint64_matrix, xdiv)
+
+DEFBINOPX (pow, uint64_matrix, uint64_matrix)
+{
+  error ("can't do A ^ B for A and B both matrices");
+  return octave_value ();
+}
+
+//DEFBINOP_FN (ldiv, uint64_matrix, uint64_matrix, xleftdiv)
+
+DEFNDBINOP_FN (lt, uint64_matrix, uint64_matrix, uint64_array, uint64_array, mx_el_lt)
+DEFNDBINOP_FN (le, uint64_matrix, uint64_matrix, uint64_array, uint64_array, mx_el_le)
+DEFNDBINOP_FN (eq, uint64_matrix, uint64_matrix, uint64_array, uint64_array, mx_el_eq)
+DEFNDBINOP_FN (ge, uint64_matrix, uint64_matrix, uint64_array, uint64_array, mx_el_ge)
+DEFNDBINOP_FN (gt, uint64_matrix, uint64_matrix, uint64_array, uint64_array, mx_el_gt)
+DEFNDBINOP_FN (ne, uint64_matrix, uint64_matrix, uint64_array, uint64_array, mx_el_ne)
+
+//DEFNDBINOP_FN (el_mul, uint64_matrix, uint64_matrix, uint64_array, uint64_array, product)
+
+//DEFNDBINOP_FN (el_div, uint64_matrix, uint64_matrix, uint64_array, uint64_array, quotient)
+
+//DEFNDBINOP_FN (el_pow, uint64_matrix, uint64_matrix, uint64_array, uint64_array, elem_xpow)
+
+//DEFBINOP (el_ldiv, uint64_matrix, uint64_matrix)
+//{
+//  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
+//
+//  return octave_value (quotient (v2.array_value (), v1.array_value ()));
+//}
+
+DEFNDBINOP_FN (el_and, uint64_matrix, uint64_matrix, uint64_array, uint64_array, mx_el_and)
+DEFNDBINOP_FN (el_or,  uint64_matrix, uint64_matrix, uint64_array, uint64_array, mx_el_or)
+
+DEFNDASSIGNOP_FN (assign, uint64_matrix, uint64_matrix, uint64_array, assign)
+
+void
+install_ui64_ui64_ops (void)
+{
+  INSTALL_UNOP (op_not, octave_uint64_matrix, not);
+  INSTALL_UNOP (op_uminus, octave_uint64_matrix, uminus);
+  INSTALL_UNOP (op_transpose, octave_uint64_matrix, transpose);
+  INSTALL_UNOP (op_hermitian, octave_uint64_matrix, transpose);
+
+  //  INSTALL_NCUNOP (op_incr, octave_uint64_matrix, incr);
+  //  INSTALL_NCUNOP (op_decr, octave_uint64_matrix, decr);
+
+  //  INSTALL_BINOP (op_add, octave_uint64_matrix, octave_uint64_matrix, add);
+  //  INSTALL_BINOP (op_sub, octave_uint64_matrix, octave_uint64_matrix, sub);
+  //  INSTALL_BINOP (op_mul, octave_uint64_matrix, octave_uint64_matrix, mul);
+  //  INSTALL_BINOP (op_div, octave_uint64_matrix, octave_uint64_matrix, div);
+  //  INSTALL_BINOP (op_pow, octave_uint64_matrix, octave_uint64_matrix, pow);
+  //  INSTALL_BINOP (op_ldiv, octave_uint64_matrix, octave_uint64_matrix, ldiv);
+  INSTALL_BINOP (op_lt, octave_uint64_matrix, octave_uint64_matrix, lt);
+  INSTALL_BINOP (op_le, octave_uint64_matrix, octave_uint64_matrix, le);
+  INSTALL_BINOP (op_eq, octave_uint64_matrix, octave_uint64_matrix, eq);
+  INSTALL_BINOP (op_ge, octave_uint64_matrix, octave_uint64_matrix, ge);
+  INSTALL_BINOP (op_gt, octave_uint64_matrix, octave_uint64_matrix, gt);
+  INSTALL_BINOP (op_ne, octave_uint64_matrix, octave_uint64_matrix, ne);
+  //  INSTALL_BINOP (op_el_mul, octave_uint64_matrix, octave_uint64_matrix, el_mul);
+  //  INSTALL_BINOP (op_el_div, octave_uint64_matrix, octave_uint64_matrix, el_div);
+  //  INSTALL_BINOP (op_el_pow, octave_uint64_matrix, octave_uint64_matrix, el_pow);
+  //  INSTALL_BINOP (op_el_ldiv, octave_uint64_matrix, octave_uint64_matrix, el_ldiv);
+  INSTALL_BINOP (op_el_and, octave_uint64_matrix, octave_uint64_matrix, el_and);
+  INSTALL_BINOP (op_el_or, octave_uint64_matrix, octave_uint64_matrix, el_or);
+
+  INSTALL_ASSIGNOP (op_asn_eq, octave_uint64_matrix, octave_uint64_matrix, assign);
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/OPERATORS/op-ui8-ui8.cc b/src/OPERATORS/op-ui8-ui8.cc
new file mode 100644
--- /dev/null
+++ b/src/OPERATORS/op-ui8-ui8.cc
@@ -0,0 +1,139 @@
+/*
+
+Copyright (C) 1996, 1997 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "gripes.h"
+#include "oct-obj.h"
+#include "ov.h"
+#include "ov-uint8.h"
+#include "ov-typeinfo.h"
+#include "ops.h"
+#include "xdiv.h"
+#include "xpow.h"
+
+// matrix unary ops.
+
+DEFNDUNOP_OP (not, uint8_matrix, uint8_array, !)
+DEFNDUNOP_OP (uminus, uint8_matrix, uint8_array, -)
+
+DEFUNOP (transpose, uint8_matrix)
+{
+  CAST_UNOP_ARG (const octave_uint8_matrix&);
+
+  if (v.ndims () > 2)
+    {
+      error ("transpose not defined for N-d objects");
+      return octave_value ();
+    }
+  else
+    return octave_value (v.uint8_array_value().transpose ());
+}
+
+//DEFNCUNOP_METHOD (incr, uint8_matrix, increment)
+//DEFNCUNOP_METHOD (decr, uint8_matrix, decrement)
+
+// matrix by matrix ops.
+
+DEFNDBINOP_OP (add, uint8_matrix, uint8_matrix, uint8_array, uint8_array, +)
+DEFNDBINOP_OP (sub, uint8_matrix, uint8_matrix, uint8_array, uint8_array, -)
+
+//DEFBINOP_OP (mul, uint8_matrix, uint8_matrix, *)
+//DEFBINOP_FN (div, uint8_matrix, uint8_matrix, xdiv)
+
+DEFBINOPX (pow, uint8_matrix, uint8_matrix)
+{
+  error ("can't do A ^ B for A and B both matrices");
+  return octave_value ();
+}
+
+//DEFBINOP_FN (ldiv, uint8_matrix, uint8_matrix, xleftdiv)
+
+DEFNDBINOP_FN (lt, uint8_matrix, uint8_matrix, uint8_array, uint8_array, mx_el_lt)
+DEFNDBINOP_FN (le, uint8_matrix, uint8_matrix, uint8_array, uint8_array, mx_el_le)
+DEFNDBINOP_FN (eq, uint8_matrix, uint8_matrix, uint8_array, uint8_array, mx_el_eq)
+DEFNDBINOP_FN (ge, uint8_matrix, uint8_matrix, uint8_array, uint8_array, mx_el_ge)
+DEFNDBINOP_FN (gt, uint8_matrix, uint8_matrix, uint8_array, uint8_array, mx_el_gt)
+DEFNDBINOP_FN (ne, uint8_matrix, uint8_matrix, uint8_array, uint8_array, mx_el_ne)
+
+DEFNDBINOP_FN (el_mul, uint8_matrix, uint8_matrix, uint8_array, uint8_array, product)
+
+DEFNDBINOP_FN (el_div, uint8_matrix, uint8_matrix, uint8_array, uint8_array, quotient)
+
+//DEFNDBINOP_FN (el_pow, uint8_matrix, uint8_matrix, uint8_array, uint8_array, elem_xpow)
+
+//DEFBINOP (el_ldiv, uint8_matrix, uint8_matrix)
+//{
+//  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
+//
+//  return octave_value (quotient (v2.array_value (), v1.array_value ()));
+//}
+
+DEFNDBINOP_FN (el_and, uint8_matrix, uint8_matrix, uint8_array, uint8_array, mx_el_and)
+DEFNDBINOP_FN (el_or,  uint8_matrix, uint8_matrix, uint8_array, uint8_array, mx_el_or)
+
+DEFNDASSIGNOP_FN (assign, uint8_matrix, uint8_matrix, uint8_array, assign)
+
+void
+install_ui8_ui8_ops (void)
+{
+  INSTALL_UNOP (op_not, octave_uint8_matrix, not);
+  INSTALL_UNOP (op_uminus, octave_uint8_matrix, uminus);
+  INSTALL_UNOP (op_transpose, octave_uint8_matrix, transpose);
+  INSTALL_UNOP (op_hermitian, octave_uint8_matrix, transpose);
+
+  //  INSTALL_NCUNOP (op_incr, octave_uint8_matrix, incr);
+  //  INSTALL_NCUNOP (op_decr, octave_uint8_matrix, decr);
+
+  INSTALL_BINOP (op_add, octave_uint8_matrix, octave_uint8_matrix, add);
+  INSTALL_BINOP (op_sub, octave_uint8_matrix, octave_uint8_matrix, sub);
+  //  INSTALL_BINOP (op_mul, octave_uint8_matrix, octave_uint8_matrix, mul);
+  //  INSTALL_BINOP (op_div, octave_uint8_matrix, octave_uint8_matrix, div);
+  //  INSTALL_BINOP (op_pow, octave_uint8_matrix, octave_uint8_matrix, pow);
+  //  INSTALL_BINOP (op_ldiv, octave_uint8_matrix, octave_uint8_matrix, ldiv);
+  INSTALL_BINOP (op_lt, octave_uint8_matrix, octave_uint8_matrix, lt);
+  INSTALL_BINOP (op_le, octave_uint8_matrix, octave_uint8_matrix, le);
+  INSTALL_BINOP (op_eq, octave_uint8_matrix, octave_uint8_matrix, eq);
+  INSTALL_BINOP (op_ge, octave_uint8_matrix, octave_uint8_matrix, ge);
+  INSTALL_BINOP (op_gt, octave_uint8_matrix, octave_uint8_matrix, gt);
+  INSTALL_BINOP (op_ne, octave_uint8_matrix, octave_uint8_matrix, ne);
+  INSTALL_BINOP (op_el_mul, octave_uint8_matrix, octave_uint8_matrix, el_mul);
+  INSTALL_BINOP (op_el_div, octave_uint8_matrix, octave_uint8_matrix, el_div);
+  //  INSTALL_BINOP (op_el_pow, octave_uint8_matrix, octave_uint8_matrix, el_pow);
+  //  INSTALL_BINOP (op_el_ldiv, octave_uint8_matrix, octave_uint8_matrix, el_ldiv);
+  INSTALL_BINOP (op_el_and, octave_uint8_matrix, octave_uint8_matrix, el_and);
+  INSTALL_BINOP (op_el_or, octave_uint8_matrix, octave_uint8_matrix, el_or);
+
+  INSTALL_ASSIGNOP (op_asn_eq, octave_uint8_matrix, octave_uint8_matrix, assign);
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/ops.h b/src/ops.h
--- a/src/ops.h
+++ b/src/ops.h
@@ -48,16 +48,20 @@ extern void install_ops (void);
 #define INSTALL_ASSIGNANYOP(op, t1, f) \
   octave_value_typeinfo::register_assignany_op \
     (octave_value::op, t1::static_type_id (), oct_assignop_ ## f);
 
 #define INSTALL_ASSIGNCONV(t1, t2, tr) \
   octave_value_typeinfo::register_pref_assign_conv \
     (t1::static_type_id (), t2::static_type_id (), tr::static_type_id ());
 
+#define INSTALL_CONVOP(t1, t2, f) \
+  octave_value_typeinfo::register_type_conv_op \
+    (t1::static_type_id (), t2::static_type_id (), oct_conv_ ## f);
+
 #define INSTALL_WIDENOP(t1, t2, f) \
   octave_value_typeinfo::register_widening_op \
     (t1::static_type_id (), t2::static_type_id (), oct_conv_ ## f);
 
 #define BOOL_OP1(xt, xn, get_x, yt, yn, get_y) \
   xt xn = get_x; \
   yt yn = get_y;
 
@@ -123,24 +127,24 @@ extern void install_ops (void);
 				   m2_nr, m2_nc); \
 	      return boolMatrix (); \
 	    } \
 	} \
     } \
   while (0)
 
 #define CAST_UNOP_ARG(t) \
-  t v = DYNAMIC_CAST (t, a);
+  t v = DYNAMIC_CAST (t, a)
 
 #define CAST_BINOP_ARGS(t1, t2) \
   t1 v1 = DYNAMIC_CAST (t1, a1); \
-  t2 v2 = DYNAMIC_CAST (t2, a2);
+  t2 v2 = DYNAMIC_CAST (t2, a2)
 
 #define CAST_CONV_ARG(t) \
-  t v = DYNAMIC_CAST (t, a);
+  t v = DYNAMIC_CAST (t, a)
 
 #define ASSIGNOPDECL(name) \
   static octave_value \
   oct_assignop_ ## name (octave_value& a1, \
 			 const octave_value_list& idx, \
 			 const octave_value& a2)
 
 #define DEFASSIGNOP(name, t1, t2) \
@@ -176,19 +180,41 @@ extern void install_ops (void);
 #define CONVDECL(name) \
   static octave_value * \
   oct_conv_ ## name (const octave_value& a)
 
 #define CONVDECLX(name) \
   static octave_value * \
   oct_conv_ ## name (const octave_value&)
 
-#define DEFCONV(name, from, to) \
+#define DEFCONV(name, a_dummy, b_dummy) \
   CONVDECL (name)
 
+#define DEFCONVFNX(name, tfrom, ovtto, tto, e) \
+  CONVDECL (name) \
+  { \
+    CAST_CONV_ARG (const octave_ ## tfrom&); \
+ \
+    return new octave_ ## ovtto (tto ## NDArray (v.e ## array_value ())); \
+  }
+
+#define DEFDBLCONVFN(name, ovtfrom, e) \
+  CONVDECL (name) \
+  { \
+    CAST_CONV_ARG (const octave_ ## ovtfrom&); \
+ \
+    return new octave_matrix (NDArray (v.e ## _value ())); \
+  }
+
+#define DEFCONVFN(name, tfrom, tto) \
+  DEFCONVFNX (name, tfrom, tto ## _matrix, tto, )
+
+#define DEFCONVFN2(name, tfrom, sm, tto) \
+  DEFCONVFNX (name, tfrom ## _ ## sm, tto ## _matrix, tto, tfrom ## _)
+
 #define UNOPDECL(name, a) \
   static octave_value \
   oct_unop_ ## name (const octave_value& a)
 
 #define DEFUNOPX(name, t) \
   UNOPDECL (name, , )
 
 #define DEFUNOP(name, t) \
diff --git a/src/ov-base-mat.h b/src/ov-base-mat.h
--- a/src/ov-base-mat.h
+++ b/src/ov-base-mat.h
@@ -65,16 +65,18 @@ public:
   octave_base_matrix (const octave_base_matrix& m)
     : octave_base_value (), matrix (m.matrix) { }
 
   ~octave_base_matrix (void) { }
 
   octave_value *clone (void) const { return new octave_base_matrix (*this); }
   octave_value *empty_clone (void) const { return new octave_base_matrix (); }
 
+  size_t byte_size (void) const { return matrix.byte_size (); }
+
   octave_value squeeze (void) const { return matrix.squeeze (); }
 
   octave_value subsref (const std::string& type,
 			const std::list<octave_value_list>& idx);
 
   octave_value_list subsref (const std::string&,
 			     const std::list<octave_value_list>&, int)
     {
diff --git a/src/ov-base-scalar.h b/src/ov-base-scalar.h
--- a/src/ov-base-scalar.h
+++ b/src/ov-base-scalar.h
@@ -76,30 +76,30 @@ public:
 			 const octave_value& rhs);
 
   bool is_constant (void) const { return true; }
 
   bool is_defined (void) const { return true; }
 
   dim_vector dims (void) const { static dim_vector dv (1, 1); return dv; }
 
-  octave_value permute (const Array<int>& vec, bool inv = false) const
+  octave_value permute (const Array<int>&, bool = false) const
     { return scalar; }
 
   size_t byte_size (void) const { return sizeof (ST); }
 
-  octave_value all (int = 0) const { return (scalar != 0.0); }
+  octave_value all (int = 0) const { return (scalar != ST ()); }
 
-  octave_value any (int = 0) const { return (scalar != 0.0); }
+  octave_value any (int = 0) const { return (scalar != ST ()); }
 
   bool is_scalar_type (void) const { return true; }
 
   bool is_numeric_type (void) const { return true; }
 
-  bool is_true (void) const { return (scalar != 0.0); }
+  bool is_true (void) const { return (scalar != ST ()); }
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool print_name_tag (std::ostream& os, const std::string& name) const;
 
 protected:
diff --git a/src/ov-bool-mat.h b/src/ov-bool-mat.h
--- a/src/ov-bool-mat.h
+++ b/src/ov-bool-mat.h
@@ -98,17 +98,17 @@ public:
     { return NDArray (matrix); }
 
   Complex complex_value (bool = false) const;
 
   ComplexMatrix complex_matrix_value (bool = false) const
     { return ComplexMatrix (matrix.matrix_value ( )); }
 
   ComplexNDArray complex_array_value (bool = false) const
-    { return ComplexNDArray (matrix.matrix_value ()); }
+    { return ComplexNDArray (matrix); }
 
   boolMatrix bool_matrix_value (void) const
     { return matrix.matrix_value (); }
 
   boolNDArray bool_array_value (void) const
     { return matrix; }
 
   octave_value convert_to_str_internal (bool pad, bool force) const;
diff --git a/src/ov-int16.cc b/src/ov-int16.cc
new file mode 100644
--- /dev/null
+++ b/src/ov-int16.cc
@@ -0,0 +1,90 @@
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <climits>
+
+#include <iostream>
+#include <vector>
+
+#include "lo-ieee.h"
+#include "lo-utils.h"
+#include "mx-base.h"
+#include "quit.h"
+
+#include "defun.h"
+#include "gripes.h"
+#include "oct-obj.h"
+#include "oct-lvalue.h"
+#include "ops.h"
+#include "ov-base.h"
+#include "ov-base-int.h"
+#include "ov-base-int.cc"
+#include "ov-int16.h"
+#include "ov-type-conv.h"
+#include "pr-output.h"
+#include "variables.h"
+
+#include "byte-swap.h"
+#include "ls-oct-ascii.h"
+#include "ls-utils.h"
+#include "ls-hdf5.h"
+
+template class octave_base_matrix<int16NDArray>;
+
+template class octave_base_int_matrix<int16NDArray>;
+
+DEFINE_OCTAVE_ALLOCATOR (octave_int16_matrix);
+
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int16_matrix,
+				     "int16 matrix", "int16");
+
+template class octave_base_scalar<octave_int16>;
+
+template class octave_base_int_scalar<octave_int16>;
+
+DEFINE_OCTAVE_ALLOCATOR (octave_int16_scalar);
+
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int16_scalar,
+				     "int16 scalar", "int16");
+
+DEFUN (int16, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} int16 (@var{x})\n\
+Convert @var{x} to 16-bit integer type.\n\
+@end deftypefn")
+{
+  OCTAVE_TYPE_CONV_BODY (int16);
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/ov-int32.cc b/src/ov-int32.cc
new file mode 100644
--- /dev/null
+++ b/src/ov-int32.cc
@@ -0,0 +1,90 @@
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <climits>
+
+#include <iostream>
+#include <vector>
+
+#include "lo-ieee.h"
+#include "lo-utils.h"
+#include "mx-base.h"
+#include "quit.h"
+
+#include "defun.h"
+#include "gripes.h"
+#include "oct-obj.h"
+#include "oct-lvalue.h"
+#include "ops.h"
+#include "ov-base.h"
+#include "ov-base-int.h"
+#include "ov-base-int.cc"
+#include "ov-int32.h"
+#include "ov-type-conv.h"
+#include "pr-output.h"
+#include "variables.h"
+
+#include "byte-swap.h"
+#include "ls-oct-ascii.h"
+#include "ls-utils.h"
+#include "ls-hdf5.h"
+
+template class octave_base_matrix<int32NDArray>;
+
+template class octave_base_int_matrix<int32NDArray>;
+
+DEFINE_OCTAVE_ALLOCATOR (octave_int32_matrix);
+
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int32_matrix,
+				     "int32 matrix", "int32");
+
+template class octave_base_scalar<octave_int32>;
+
+template class octave_base_int_scalar<octave_int32>;
+
+DEFINE_OCTAVE_ALLOCATOR (octave_int32_scalar);
+
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int32_scalar,
+				     "int32 scalar", "int32");
+
+DEFUN (int32, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} int32 (@var{x})\n\
+Convert @var{x} to 32-bit integer type.\n\
+@end deftypefn")
+{
+  OCTAVE_TYPE_CONV_BODY (int32);
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/ov-int64.cc b/src/ov-int64.cc
new file mode 100644
--- /dev/null
+++ b/src/ov-int64.cc
@@ -0,0 +1,90 @@
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <climits>
+
+#include <iostream>
+#include <vector>
+
+#include "lo-ieee.h"
+#include "lo-utils.h"
+#include "mx-base.h"
+#include "quit.h"
+
+#include "defun.h"
+#include "gripes.h"
+#include "oct-obj.h"
+#include "oct-lvalue.h"
+#include "ops.h"
+#include "ov-base.h"
+#include "ov-base-int.h"
+#include "ov-base-int.cc"
+#include "ov-int64.h"
+#include "ov-type-conv.h"
+#include "pr-output.h"
+#include "variables.h"
+
+#include "byte-swap.h"
+#include "ls-oct-ascii.h"
+#include "ls-utils.h"
+#include "ls-hdf5.h"
+
+template class octave_base_matrix<int64NDArray>;
+
+template class octave_base_int_matrix<int64NDArray>;
+
+DEFINE_OCTAVE_ALLOCATOR (octave_int64_matrix);
+
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int64_matrix,
+				     "int64 matrix", "int64");
+
+template class octave_base_scalar<octave_int64>;
+
+template class octave_base_int_scalar<octave_int64>;
+
+DEFINE_OCTAVE_ALLOCATOR (octave_int64_scalar);
+
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int64_scalar,
+				     "int64 scalar", "int64");
+
+DEFUN (int64, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} int64 (@var{x})\n\
+Convert @var{x} to 64-bit integer type.\n\
+@end deftypefn")
+{
+  OCTAVE_TYPE_CONV_BODY (int64);
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/ov-int8.cc b/src/ov-int8.cc
new file mode 100644
--- /dev/null
+++ b/src/ov-int8.cc
@@ -0,0 +1,90 @@
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <climits>
+
+#include <iostream>
+#include <vector>
+
+#include "lo-ieee.h"
+#include "lo-utils.h"
+#include "mx-base.h"
+#include "quit.h"
+
+#include "defun.h"
+#include "gripes.h"
+#include "oct-obj.h"
+#include "oct-lvalue.h"
+#include "ops.h"
+#include "ov-base.h"
+#include "ov-base-int.h"
+#include "ov-base-int.cc"
+#include "ov-int8.h"
+#include "ov-type-conv.h"
+#include "pr-output.h"
+#include "variables.h"
+
+#include "byte-swap.h"
+#include "ls-oct-ascii.h"
+#include "ls-utils.h"
+#include "ls-hdf5.h"
+
+template class octave_base_matrix<int8NDArray>;
+
+template class octave_base_int_matrix<int8NDArray>;
+
+DEFINE_OCTAVE_ALLOCATOR (octave_int8_matrix);
+
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int8_matrix,
+				     "int8 matrix", "int8");
+
+template class octave_base_scalar<octave_int8>;
+
+template class octave_base_int_scalar<octave_int8>;
+
+DEFINE_OCTAVE_ALLOCATOR (octave_int8_scalar);
+
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int8_scalar,
+				     "int8 scalar", "int8");
+
+DEFUN (int8, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} int8 (@var{x})\n\
+Convert @var{x} to 8-bit integer type.\n\
+@end deftypefn")
+{
+  OCTAVE_TYPE_CONV_BODY (int8);
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/ov-range.h b/src/ov-range.h
--- a/src/ov-range.h
+++ b/src/ov-range.h
@@ -106,17 +106,17 @@ public:
     {
       int n = range.nelem ();
       return dim_vector (n > 0, n);
     }
 
   size_t byte_size (void) const { return 3 * sizeof (double); }
 
   octave_value reshape (const dim_vector& new_dims) const
-    { return NDArray (matrix_value().reshape (new_dims)); }
+    { return NDArray (array_value().reshape (new_dims)); }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
 
   bool is_range (void) const { return true; }
 
   octave_value all (int dim = 0) const;
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -33,25 +33,27 @@ Software Foundation, 59 Temple Place - S
 #include <iostream>
 #include <vector>
 
 #include "lo-ieee.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "quit.h"
 
+#include "defun.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "oct-lvalue.h"
 #include "ops.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-base-mat.cc"
 #include "ov-scalar.h"
 #include "ov-re-mat.h"
+#include "ov-type-conv.h"
 #include "pr-output.h"
 #include "variables.h"
 
 #include "byte-swap.h"
 #include "ls-oct-ascii.h"
 #include "ls-utils.h"
 #include "ls-hdf5.h"
 
@@ -621,13 +623,22 @@ octave_matrix::load_hdf5 (hid_t loc_id, 
 void
 octave_matrix::print_raw (std::ostream& os,
 			  bool pr_as_read_syntax) const
 {
   octave_print_internal (os, matrix, pr_as_read_syntax,
 			 current_print_indent_level ());
 }
 
+DEFUN (double, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} double (@var{x})\n\
+Convert @var{x} to double precision type.\n\
+@end deftypefn")
+{
+  OCTAVE_TYPE_CONV_BODY3 (double, octave_matrix, octave_scalar);
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-type-conv.h b/src/ov-type-conv.h
new file mode 100644
--- /dev/null
+++ b/src/ov-type-conv.h
@@ -0,0 +1,78 @@
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#define OCTAVE_TYPE_CONV_BODY3(NAME, MATRIX_RESULT_T, SCALAR_RESULT_T) \
+ \
+  octave_value retval; \
+ \
+  int nargin = args.length (); \
+ \
+  if (nargin == 1) \
+    { \
+      const octave_value arg = args(0); \
+ \
+      int t_arg = arg.type_id (); \
+ \
+      int t_result = MATRIX_RESULT_T::static_type_id (); \
+ \
+      if (t_arg != t_result) \
+        { \
+          type_conv_fcn cf \
+	    = octave_value_typeinfo::lookup_type_conv_op (t_arg, t_result); \
+ \
+          if (cf) \
+	    { \
+	      octave_value *tmp (cf (*(arg.internal_rep ()))); \
+ \
+	      if (tmp) \
+		{ \
+		  retval = octave_value (tmp); \
+ \
+		  retval.maybe_mutate (); \
+		} \
+	    } \
+	  else \
+	    { \
+	      std::string arg_tname = arg.type_name (); \
+ \
+	      std::string result_tname = arg.numel () == 1 \
+		? SCALAR_RESULT_T::static_type_name () \
+		: MATRIX_RESULT_T::static_type_name (); \
+ \
+	      gripe_invalid_conversion (arg_tname, result_tname); \
+	    } \
+	} \
+    } \
+  else \
+    print_usage (#NAME); \
+ \
+  return retval
+
+#define OCTAVE_TYPE_CONV_BODY(NAME) \
+  OCTAVE_TYPE_CONV_BODY3 (NAME, octave_ ## NAME ## _matrix, \
+			  octave_ ## NAME ## _scalar)
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/ov-typeinfo.cc b/src/ov-typeinfo.cc
--- a/src/ov-typeinfo.cc
+++ b/src/ov-typeinfo.cc
@@ -136,16 +136,24 @@ bool
 octave_value_typeinfo::register_pref_assign_conv (int t_lhs, int t_rhs,
 						  int t_result) 
 {
   return (instance_ok ())
     ? instance->do_register_pref_assign_conv (t_lhs, t_rhs, t_result) : false;
 }
 
 bool
+octave_value_typeinfo::register_type_conv_op (int t, int t_result,
+					      type_conv_fcn f)
+{
+  return (instance_ok ())
+    ? instance->do_register_type_conv_op (t, t_result, f) : false;
+}
+
+bool
 octave_value_typeinfo::register_widening_op (int t, int t_result,
 					     type_conv_fcn f)
 {
   return (instance_ok ())
     ? instance->do_register_widening_op (t, t_result, f) : false;
 }
 
 // XXX FIXME XXX -- we should also store all class names and provide a
@@ -185,16 +193,18 @@ octave_value_typeinfo::do_register_type 
       assign_ops.resize (static_cast<int> (octave_value::num_assign_ops),
 			 len, len, static_cast<assign_op_fcn> (0));
 
       assignany_ops.resize (static_cast<int> (octave_value::num_assign_ops),
 			    len, static_cast<assign_op_fcn> (0));
 
       pref_assign_conv.resize (len, len, -1);
 
+      type_conv_ops.resize (len, len, static_cast<type_conv_fcn> (0));
+
       widening_ops.resize (len, len, static_cast<type_conv_fcn> (0));
     }
 
   types (i) = t_name;
 
   vals (i) = val;
 
   num_types++;
@@ -310,16 +320,34 @@ octave_value_typeinfo::do_register_pref_
     }
 
   pref_assign_conv.checkelem (t_lhs, t_rhs) = t_result;
 
   return false;
 }
 
 bool
+octave_value_typeinfo::do_register_type_conv_op
+  (int t, int t_result, type_conv_fcn f)
+{
+  if (lookup_type_conv_op (t, t_result))
+    {
+      std::string t_name = types(t);
+      std::string t_result_name = types(t_result);
+
+      warning ("overriding type conversion op for `%s' to `%s'",
+	       t_name.c_str (), t_result_name.c_str ());
+    }
+
+  type_conv_ops.checkelem (t, t_result) = f;
+
+  return false;
+}
+
+bool
 octave_value_typeinfo::do_register_widening_op
   (int t, int t_result, type_conv_fcn f)
 {
   if (lookup_widening_op (t, t_result))
     {
       std::string t_name = types(t);
       std::string t_result_name = types(t_result);
 
@@ -386,16 +414,22 @@ octave_value_typeinfo::do_lookup_assigna
 
 int
 octave_value_typeinfo::do_lookup_pref_assign_conv (int t_lhs, int t_rhs)
 {
   return pref_assign_conv.checkelem (t_lhs, t_rhs);
 }
 
 type_conv_fcn
+octave_value_typeinfo::do_lookup_type_conv_op (int t, int t_result)
+{
+  return type_conv_ops.checkelem (t, t_result);
+}
+
+type_conv_fcn
 octave_value_typeinfo::do_lookup_widening_op (int t, int t_result)
 {
   return widening_ops.checkelem (t, t_result);
 }
 
 string_vector
 octave_value_typeinfo::do_installed_type_names (void)
 {
diff --git a/src/ov-typeinfo.h b/src/ov-typeinfo.h
--- a/src/ov-typeinfo.h
+++ b/src/ov-typeinfo.h
@@ -58,16 +58,18 @@ public:
   static bool register_assign_op (octave_value::assign_op, int, int,
 				  assign_op_fcn);
 
   static bool register_assignany_op (octave_value::assign_op, int,
 				     assign_op_fcn);
 
   static bool register_pref_assign_conv (int, int, int);
 
+  static bool register_type_conv_op (int, int, type_conv_fcn);
+
   static bool register_widening_op (int, int, type_conv_fcn);
 
   static octave_value
   lookup_type (const std::string& nm)
   {
     return instance->do_lookup_type (nm);
   }
 
@@ -103,16 +105,22 @@ public:
 
   static int
   lookup_pref_assign_conv (int t_lhs, int t_rhs)
   {
     return instance->do_lookup_pref_assign_conv (t_lhs, t_rhs);
   }
 
   static type_conv_fcn
+  lookup_type_conv_op (int t, int t_result)
+  {
+    return instance->do_lookup_type_conv_op (t, t_result);
+  }
+
+  static type_conv_fcn
   lookup_widening_op (int t, int t_result)
   {
     return instance->do_lookup_widening_op (t, t_result);
   }
 
   static string_vector installed_type_names (void)
   {
     return instance->do_installed_type_names ();
@@ -129,16 +137,17 @@ protected:
 			   (non_const_unary_op_fcn) 0),
       binary_ops (octave_value::num_binary_ops, init_tab_sz,
 		  init_tab_sz, (binary_op_fcn) 0),
       assign_ops (octave_value::num_assign_ops, init_tab_sz,
 		  init_tab_sz, (assign_op_fcn) 0),
       assignany_ops (octave_value::num_assign_ops, init_tab_sz,
 		     (assign_op_fcn) 0),
       pref_assign_conv (init_tab_sz, init_tab_sz, -1),
+      type_conv_ops (init_tab_sz, init_tab_sz, (type_conv_fcn) 0),
       widening_ops (init_tab_sz, init_tab_sz, (type_conv_fcn) 0)  { }
 
 private:
 
   static const int init_tab_sz;
 
   static octave_value_typeinfo *instance;
 
@@ -155,16 +164,18 @@ private:
   Array3<binary_op_fcn> binary_ops;
 
   Array3<assign_op_fcn> assign_ops;
 
   Array2<assign_op_fcn> assignany_ops;
 
   Array2<int> pref_assign_conv;
 
+  Array2<type_conv_fcn> type_conv_ops;
+
   Array2<type_conv_fcn> widening_ops;
 
   int do_register_type (const std::string&, const std::string&,
 			const octave_value&);
 
   bool do_register_unary_op (octave_value::unary_op, int, unary_op_fcn);
 
   bool do_register_non_const_unary_op (octave_value::unary_op, int,
@@ -176,16 +187,18 @@ private:
   bool do_register_assign_op (octave_value::assign_op, int, int,
 			      assign_op_fcn);
 
   bool do_register_assignany_op (octave_value::assign_op, int,
 				 assign_op_fcn);
 
   bool do_register_pref_assign_conv (int, int, int);
 
+  bool do_register_type_conv_op (int, int, type_conv_fcn);
+
   bool do_register_widening_op (int, int, type_conv_fcn);
 
   octave_value do_lookup_type (const std::string& nm);
 
   unary_op_fcn do_lookup_unary_op (octave_value::unary_op, int);
 
   non_const_unary_op_fcn do_lookup_non_const_unary_op
     (octave_value::unary_op, int);
@@ -193,16 +206,18 @@ private:
   binary_op_fcn do_lookup_binary_op (octave_value::binary_op, int, int);
 
   assign_op_fcn do_lookup_assign_op (octave_value::assign_op, int, int);
 
   assign_op_fcn do_lookup_assignany_op (octave_value::assign_op, int);
 
   int do_lookup_pref_assign_conv (int, int);
 
+  type_conv_fcn do_lookup_type_conv_op (int, int);
+
   type_conv_fcn do_lookup_widening_op (int, int);
 
   string_vector do_installed_type_names (void);
 
   // No copying!
 
   octave_value_typeinfo (const octave_value_typeinfo&);
 
diff --git a/src/ov-uint16.cc b/src/ov-uint16.cc
new file mode 100644
--- /dev/null
+++ b/src/ov-uint16.cc
@@ -0,0 +1,90 @@
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <climits>
+
+#include <iostream>
+#include <vector>
+
+#include "lo-ieee.h"
+#include "lo-utils.h"
+#include "mx-base.h"
+#include "quit.h"
+
+#include "defun.h"
+#include "gripes.h"
+#include "oct-obj.h"
+#include "oct-lvalue.h"
+#include "ops.h"
+#include "ov-base.h"
+#include "ov-base-int.h"
+#include "ov-base-int.cc"
+#include "ov-uint16.h"
+#include "ov-type-conv.h"
+#include "pr-output.h"
+#include "variables.h"
+
+#include "byte-swap.h"
+#include "ls-oct-ascii.h"
+#include "ls-utils.h"
+#include "ls-hdf5.h"
+
+template class octave_base_matrix<uint16NDArray>;
+
+template class octave_base_int_matrix<uint16NDArray>;
+
+DEFINE_OCTAVE_ALLOCATOR (octave_uint16_matrix);
+
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint16_matrix,
+				     "uint16 matrix", "uint16");
+
+template class octave_base_scalar<octave_uint16>;
+
+template class octave_base_int_scalar<octave_uint16>;
+
+DEFINE_OCTAVE_ALLOCATOR (octave_uint16_scalar);
+
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint16_scalar,
+				     "uint16 scalar", "uint16");
+
+DEFUN (uint16, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} uint16 (@var{x})\n\
+Convert @var{x} to unsigned 16-bit integer type.\n\
+@end deftypefn")
+{
+  OCTAVE_TYPE_CONV_BODY (uint16);
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/ov-uint32.cc b/src/ov-uint32.cc
new file mode 100644
--- /dev/null
+++ b/src/ov-uint32.cc
@@ -0,0 +1,90 @@
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <climits>
+
+#include <iostream>
+#include <vector>
+
+#include "lo-ieee.h"
+#include "lo-utils.h"
+#include "mx-base.h"
+#include "quit.h"
+
+#include "defun.h"
+#include "gripes.h"
+#include "oct-obj.h"
+#include "oct-lvalue.h"
+#include "ops.h"
+#include "ov-base.h"
+#include "ov-base-int.h"
+#include "ov-base-int.cc"
+#include "ov-uint32.h"
+#include "ov-type-conv.h"
+#include "pr-output.h"
+#include "variables.h"
+
+#include "byte-swap.h"
+#include "ls-oct-ascii.h"
+#include "ls-utils.h"
+#include "ls-hdf5.h"
+
+template class octave_base_matrix<uint32NDArray>;
+
+template class octave_base_int_matrix<uint32NDArray>;
+
+DEFINE_OCTAVE_ALLOCATOR (octave_uint32_matrix);
+
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint32_matrix,
+				     "uint32 matrix", "uint32");
+
+template class octave_base_scalar<octave_uint32>;
+
+template class octave_base_int_scalar<octave_uint32>;
+
+DEFINE_OCTAVE_ALLOCATOR (octave_uint32_scalar);
+
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint32_scalar,
+				     "uint32 scalar", "uint32");
+
+DEFUN (uint32, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} uint32 (@var{x})\n\
+Convert @var{x} to unsigned 32-bit integer type.\n\
+@end deftypefn")
+{
+  OCTAVE_TYPE_CONV_BODY (uint32);
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/ov-uint64.cc b/src/ov-uint64.cc
new file mode 100644
--- /dev/null
+++ b/src/ov-uint64.cc
@@ -0,0 +1,90 @@
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <climits>
+
+#include <iostream>
+#include <vector>
+
+#include "lo-ieee.h"
+#include "lo-utils.h"
+#include "mx-base.h"
+#include "quit.h"
+
+#include "defun.h"
+#include "gripes.h"
+#include "oct-obj.h"
+#include "oct-lvalue.h"
+#include "ops.h"
+#include "ov-base.h"
+#include "ov-base-int.h"
+#include "ov-base-int.cc"
+#include "ov-uint64.h"
+#include "ov-type-conv.h"
+#include "pr-output.h"
+#include "variables.h"
+
+#include "byte-swap.h"
+#include "ls-oct-ascii.h"
+#include "ls-utils.h"
+#include "ls-hdf5.h"
+
+template class octave_base_matrix<uint64NDArray>;
+
+template class octave_base_int_matrix<uint64NDArray>;
+
+DEFINE_OCTAVE_ALLOCATOR (octave_uint64_matrix);
+
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint64_matrix,
+				     "uint64 matrix", "uint64");
+
+template class octave_base_scalar<octave_uint64>;
+
+template class octave_base_int_scalar<octave_uint64>;
+
+DEFINE_OCTAVE_ALLOCATOR (octave_uint64_scalar);
+
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint64_scalar,
+				     "uint64 scalar", "uint64");
+
+DEFUN (uint64, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} uint64 (@var{x})\n\
+Convert @var{x} to unsigned 64-bit integer type.\n\
+@end deftypefn")
+{
+  OCTAVE_TYPE_CONV_BODY (uint64);
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/ov-uint8.cc b/src/ov-uint8.cc
new file mode 100644
--- /dev/null
+++ b/src/ov-uint8.cc
@@ -0,0 +1,90 @@
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <climits>
+
+#include <iostream>
+#include <vector>
+
+#include "lo-ieee.h"
+#include "lo-utils.h"
+#include "mx-base.h"
+#include "quit.h"
+
+#include "defun.h"
+#include "gripes.h"
+#include "oct-obj.h"
+#include "oct-lvalue.h"
+#include "ops.h"
+#include "ov-base.h"
+#include "ov-base-int.h"
+#include "ov-base-int.cc"
+#include "ov-uint8.h"
+#include "ov-type-conv.h"
+#include "pr-output.h"
+#include "variables.h"
+
+#include "byte-swap.h"
+#include "ls-oct-ascii.h"
+#include "ls-utils.h"
+#include "ls-hdf5.h"
+
+template class octave_base_matrix<uint8NDArray>;
+
+template class octave_base_int_matrix<uint8NDArray>;
+
+DEFINE_OCTAVE_ALLOCATOR (octave_uint8_matrix);
+
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint8_matrix,
+				     "uint8 matrix", "uint8");
+
+template class octave_base_scalar<octave_uint8>;
+
+template class octave_base_int_scalar<octave_uint8>;
+
+DEFINE_OCTAVE_ALLOCATOR (octave_uint8_scalar);
+
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint8_scalar,
+				     "uint8 scalar", "uint8");
+
+DEFUN (uint8, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} uint8 (@var{x})\n\
+Convert @var{x} to unsigned 8-bit integer type.\n\
+@end deftypefn")
+{
+  OCTAVE_TYPE_CONV_BODY (uint8);
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -35,16 +35,24 @@ Software Foundation, 59 Temple Place - S
 #include "oct-obj.h"
 #include "ov.h"
 #include "ov-base.h"
 #include "ov-bool.h"
 #include "ov-bool-mat.h"
 #include "ov-cell.h"
 #include "ov-scalar.h"
 #include "ov-re-mat.h"
+#include "ov-int8.h"
+#include "ov-int16.h"
+#include "ov-int32.h"
+#include "ov-int64.h"
+#include "ov-uint8.h"
+#include "ov-uint16.h"
+#include "ov-uint32.h"
+#include "ov-uint64.h"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-ch-mat.h"
 #include "ov-str-mat.h"
 #include "ov-range.h"
 #include "ov-struct.h"
 #include "ov-file.h"
 #include "ov-streamoff.h"
@@ -563,16 +571,128 @@ octave_value::octave_value (const charND
   : rep (is_str
 	 ? new octave_char_matrix_str (chm)
 	 : new octave_char_matrix (chm))
 {
   rep->count = 1;
   maybe_mutate ();
 }
 
+octave_value::octave_value (const octave_int8& i)
+  : rep (new octave_int8_scalar (i))
+{
+  rep->count = 1;
+  maybe_mutate ();
+}
+
+octave_value::octave_value (const octave_uint8& i)
+  : rep (new octave_uint8_scalar (i))
+{
+  rep->count = 1;
+  maybe_mutate ();
+}
+
+octave_value::octave_value (const octave_int16& i)
+  : rep (new octave_int16_scalar (i))
+{
+  rep->count = 1;
+  maybe_mutate ();
+}
+
+octave_value::octave_value (const octave_uint16& i)
+  : rep (new octave_uint16_scalar (i))
+{
+  rep->count = 1;
+  maybe_mutate ();
+}
+
+octave_value::octave_value (const octave_int32& i)
+  : rep (new octave_int32_scalar (i))
+{
+  rep->count = 1;
+  maybe_mutate ();
+}
+
+octave_value::octave_value (const octave_uint32& i)
+  : rep (new octave_uint32_scalar (i))
+{
+  rep->count = 1;
+  maybe_mutate ();
+}
+
+octave_value::octave_value (const octave_int64& i)
+  : rep (new octave_int64_scalar (i))
+{
+  rep->count = 1;
+  maybe_mutate ();
+}
+
+octave_value::octave_value (const octave_uint64& i)
+  : rep (new octave_uint64_scalar (i))
+{
+  rep->count = 1;
+  maybe_mutate ();
+}
+
+octave_value::octave_value (const int8NDArray& inda)
+  : rep (new octave_int8_matrix (inda))
+{
+  rep->count = 1;
+  maybe_mutate ();
+}
+
+octave_value::octave_value (const uint8NDArray& inda)
+  : rep (new octave_uint8_matrix (inda))
+{
+  rep->count = 1;
+  maybe_mutate ();
+}
+
+octave_value::octave_value (const int16NDArray& inda)
+  : rep (new octave_int16_matrix (inda))
+{
+  rep->count = 1;
+  maybe_mutate ();
+}
+
+octave_value::octave_value (const uint16NDArray& inda)
+  : rep (new octave_uint16_matrix (inda))
+{
+  rep->count = 1;
+  maybe_mutate ();
+}
+
+octave_value::octave_value (const int32NDArray& inda)
+  : rep (new octave_int32_matrix (inda))
+{
+  rep->count = 1;
+  maybe_mutate ();
+}
+
+octave_value::octave_value (const uint32NDArray& inda)
+  : rep (new octave_uint32_matrix (inda))
+{
+  rep->count = 1;
+  maybe_mutate ();
+}
+
+octave_value::octave_value (const int64NDArray& inda)
+  : rep (new octave_int64_matrix (inda))
+{
+  rep->count = 1;
+  maybe_mutate ();
+}
+
+octave_value::octave_value (const uint64NDArray& inda)
+  : rep (new octave_uint64_matrix (inda))
+{
+  rep->count = 1;
+  maybe_mutate ();
+}
+
 octave_value::octave_value (double base, double limit, double inc)
   : rep (new octave_range (base, limit, inc))
 {
   rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const Range& r)
@@ -1900,16 +2020,32 @@ install_types (void)
   octave_complex::register_type ();
   octave_matrix::register_type ();
   octave_complex_matrix::register_type ();
   octave_range::register_type ();
   octave_bool::register_type ();
   octave_bool_matrix::register_type ();
   octave_char_matrix::register_type ();
   octave_char_matrix_str::register_type ();
+  octave_int8_scalar::register_type ();
+  octave_int16_scalar::register_type ();
+  octave_int32_scalar::register_type ();
+  octave_int64_scalar::register_type ();
+  octave_uint8_scalar::register_type ();
+  octave_uint16_scalar::register_type ();
+  octave_uint32_scalar::register_type ();
+  octave_uint64_scalar::register_type ();
+  octave_int8_matrix::register_type ();
+  octave_int16_matrix::register_type ();
+  octave_int32_matrix::register_type ();
+  octave_int64_matrix::register_type ();
+  octave_uint8_matrix::register_type ();
+  octave_uint16_matrix::register_type ();
+  octave_uint32_matrix::register_type ();
+  octave_uint64_matrix::register_type ();
   octave_struct::register_type ();
   octave_file::register_type ();
   octave_list::register_type ();
   octave_cs_list::register_type ();
   octave_all_va_args::register_type ();
   octave_magic_colon::register_type ();
   octave_builtin::register_type ();
   octave_mapper::register_type ();
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -207,16 +207,32 @@ public:
   octave_value (const boolMatrix& bm);
   octave_value (const boolNDArray& bnda);
   octave_value (char c);
   octave_value (const char *s);
   octave_value (const std::string& s);
   octave_value (const string_vector& s);
   octave_value (const charMatrix& chm, bool is_string = false);
   octave_value (const charNDArray& chnda, bool is_string = false);
+  octave_value (const octave_int8& i);
+  octave_value (const octave_uint8& i);
+  octave_value (const octave_int16& i);
+  octave_value (const octave_uint16& i);
+  octave_value (const octave_int32& i);
+  octave_value (const octave_uint32& i);
+  octave_value (const octave_int64& i);
+  octave_value (const octave_uint64& i);
+  octave_value (const int8NDArray& inda);
+  octave_value (const uint8NDArray& inda);
+  octave_value (const int16NDArray& inda);
+  octave_value (const uint16NDArray& inda);
+  octave_value (const int32NDArray& inda);
+  octave_value (const uint32NDArray& inda);
+  octave_value (const int64NDArray& inda);
+  octave_value (const uint64NDArray& inda);
   octave_value (double base, double limit, double inc);
   octave_value (const Range& r);
   octave_value (const Octave_map& m);
   octave_value (const octave_stream& s, int n);
   octave_value (const streamoff_array& off);
   octave_value (octave_function *f);
   octave_value (const fcn_handle_array& fha);
   octave_value (octave_function *f, const std::string &nm); // function handle
@@ -669,16 +685,18 @@ public:
   virtual bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats)
     { return rep->save_hdf5 (loc_id, name, save_as_floats); }
 
   virtual bool load_hdf5 (hid_t loc_id, const char *name,
 			  bool have_h5giterate_bug)
     { return rep->load_hdf5 (loc_id, name, have_h5giterate_bug); }
 #endif
 
+  octave_value *internal_rep (void) const { return rep; }
+
 protected:
 
   octave_value (const octave_xvalue&) : rep (0) { }
 
   // This should only be called for derived types.
 
   octave_value numeric_assign (const std::string& type,
 			       const std::list<octave_value_list>& idx,
@@ -798,16 +816,18 @@ OV_BINOP_FN (op_struct_ref)
 // T_ID is the type id of struct objects, set by register_type().
 // T_NAME is the type name of struct objects.
 #define DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA \
   public: \
     int type_id (void) const { return t_id; } \
     std::string type_name (void) const { return t_name; } \
     std::string class_name (void) const { return c_name; } \
     static int static_type_id (void) { return t_id; } \
+    static std::string static_type_name (void) { return t_name; } \
+    static std::string static_class_name (void) { return c_name; } \
     static void register_type (void); \
  \
   private: \
     static int t_id; \
     static const std::string t_name; \
     static const std::string c_name;
 
 #define DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA(t, n, c) \
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -2082,16 +2082,201 @@ octave_print_internal (std::ostream& os,
 	    os << "\n";
 
 	  if (i < m)
 	    increment_index (ra_idx, dims, 2);
 	}
     }
 }
 
+template <class T>
+class
+octave_print_conv
+{
+public:
+  typedef T print_conv_type;
+};
+
+#define PRINT_CONV(T1, T2) \
+  template <> \
+  class \
+  octave_print_conv<T1> \
+  { \
+  public: \
+    typedef T2 print_conv_type; \
+  }
+
+PRINT_CONV (octave_int8, octave_int16);
+PRINT_CONV (octave_uint8, octave_uint16);
+
+#undef PRINT_CONV
+
+template <class T>
+void
+octave_print_internal (std::ostream& os, const intNDArray<T>& nda,
+		       bool pr_as_read_syntax = false,
+		       int extra_indent = 0)
+{
+  // XXX FIXME XXX -- this mostly duplicates the code in the
+  // PRINT_ND_ARRAY macro.
+
+  if (nda.is_empty ())
+    print_empty_nd_array (os, nda.dims (), pr_as_read_syntax);
+  else if (nda.length () == 1)
+    {
+      os << typename octave_print_conv<T>::print_conv_type (nda(0));
+    }
+  else
+    {
+      int ndims = nda.ndims ();
+
+      dim_vector dims = nda.dims ();
+
+      Array<int> ra_idx (ndims, 0);
+
+      int m = 1;
+
+      for (int i = 2; i < ndims; i++)
+	m *= dims(i);
+
+      int nr = dims(0);
+      int nc = dims(1);
+
+      for (int i = 0; i < m; i++)
+	{
+	  std::string nm = "ans";
+
+	  if (m > 1)
+	    {
+	      nm += "(:,:,";
+
+	      OSSTREAM buf;
+
+	      for (int k = 2; k < ndims; k++)
+		{
+		  buf << ra_idx(k) + 1;
+
+		  if (k < ndims - 1)
+		    buf << ",";
+		  else
+		    buf << ")";
+		}
+
+	      buf << OSSTREAM_ENDS;
+
+	      nm += OSSTREAM_STR (buf);
+
+	      OSSTREAM_FREEZE (buf);
+	    }
+
+	  Array<idx_vector> idx (ndims);
+
+	  idx(0) = idx_vector (':');
+	  idx(1) = idx_vector (':');
+
+	  for (int k = 2; k < ndims; k++)
+	    idx(k) = idx_vector (ra_idx(k) + 1);
+
+	  Array2<T> page (nda.index (idx), nr, nc);
+
+	  // XXX FIXME XXX -- need to do some more work to put these
+	  // in neatly aligned columns...
+
+	  int n_rows = page.rows ();
+	  int n_cols = page.cols ();
+
+	  os << nm << " =\n\n";
+
+	  for (int ii = 0; ii < n_rows; ii++)
+	    {
+	      for (int jj = 0; jj < n_cols; jj++)
+		os << "  " << typename octave_print_conv<T>::print_conv_type (page(ii,jj));
+
+	      os << "\n";
+	    }
+
+	  if (i < m - 1)
+	    os << "\n";
+
+	  if (i < m)
+	    increment_index (ra_idx, dims, 2);
+	}
+    }
+}
+
+// XXX FIXME XXX -- this is not the right spot for this...
+
+template void
+octave_print_internal (std::ostream&, const intNDArray<octave_int8>&,
+		       bool, int);
+
+template void
+octave_print_internal (std::ostream&, const intNDArray<octave_int16>&,
+		       bool, int);
+
+template void
+octave_print_internal (std::ostream&, const intNDArray<octave_int32>&,
+		       bool, int);
+
+template void
+octave_print_internal (std::ostream&, const intNDArray<octave_int64>&,
+		       bool, int);
+
+template void
+octave_print_internal (std::ostream&, const intNDArray<octave_uint8>&,
+		       bool, int);
+
+template void
+octave_print_internal (std::ostream&, const intNDArray<octave_uint16>&,
+		       bool, int);
+
+template void
+octave_print_internal (std::ostream&, const intNDArray<octave_uint32>&,
+		       bool, int);
+
+template void
+octave_print_internal (std::ostream&, const intNDArray<octave_uint64>&,
+		       bool, int);
+
+template <class T>
+void
+octave_print_internal (std::ostream& os, const octave_int<T>& val,
+		       bool pr_as_read_syntax)
+{
+  // XXX FIXME XXX -- we need to handle various formats here...
+
+  os << typename octave_print_conv<octave_int<T> >::print_conv_type (val);
+}
+
+// XXX FIXME XXX -- this is not the right spot for this...
+
+template void
+octave_print_internal (std::ostream&, const octave_int8&, bool);
+
+template void
+octave_print_internal (std::ostream&, const octave_int16&, bool);
+
+template void
+octave_print_internal (std::ostream&, const octave_int32&, bool);
+
+template void
+octave_print_internal (std::ostream&, const octave_int64&, bool);
+
+template void
+octave_print_internal (std::ostream&, const octave_uint8&, bool);
+
+template void
+octave_print_internal (std::ostream&, const octave_uint16&, bool);
+
+template void
+octave_print_internal (std::ostream&, const octave_uint32&, bool);
+
+template void
+octave_print_internal (std::ostream&, const octave_uint64&, bool);
+
 extern void
 octave_print_internal (std::ostream&, const Cell&, bool, int, bool)
 {
   panic_impossible ();
 }
 
 DEFUN (disp, args, nargout,
   "-*- texinfo -*-\n\
diff --git a/src/pr-output.h b/src/pr-output.h
--- a/src/pr-output.h
+++ b/src/pr-output.h
@@ -34,16 +34,19 @@ class Matrix;
 class NDArray;
 class Range;
 class boolMatrix;
 class boolNDArray;
 class charMatrix;
 class charNDArray;
 class Cell;
 
+#include "intNDArray.h"
+#include "oct-inttypes.h"
+
 extern void
 octave_print_internal (std::ostream& os, double d,
 		       bool pr_as_read_syntax = false);
 
 extern void
 octave_print_internal (std::ostream& os, const Matrix& m,
 		       bool pr_as_read_syntax = false,
 		       int extra_indent = 0);
@@ -94,16 +97,27 @@ octave_print_internal (std::ostream& os,
 		       int extra_indent = 0,
 		       bool pr_as_string = false);
 
 extern void
 octave_print_internal (std::ostream& os, const ArrayN<std::string>& sa,
 		       bool pr_as_read_syntax = false,
 		       int extra_indent = 0);
 
+template <class T>
+extern void
+octave_print_internal (std::ostream& os, const intNDArray<T>& sa,
+		       bool pr_as_read_syntax = false,
+		       int extra_indent = 0);
+
+template <class T>
+extern void
+octave_print_internal (std::ostream& os, const octave_int<T>& sa,
+		       bool pr_as_read_syntax = false);
+
 extern void
 octave_print_internal (std::ostream& os, const Cell& cell,
 		       bool pr_as_read_syntax = false,
 		       int extra_indent = 0,
 		       bool pr_as_string = false);
 
 #endif
 
