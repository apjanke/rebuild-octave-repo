# HG changeset patch
# User jwe
# Date 1156358139 0
#      Wed Aug 23 18:35:39 2006 +0000
# Node ID 85c7dc4afe6b64db14e67cd97c2ba42070067d9e
# Parent  370f785718bea7843ae552bd2f8ebcefa3631388
[project @ 2006-08-23 18:35:38 by jwe]

diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -3459,92 +3459,16 @@ ComplexMatrix::column_max (Array<octave_
         }
     }
 
   return result;
 }
 
 // i/o
 
-// Used when converting Inf to something that gnuplot can read.
-
-#ifndef OCT_RBV
-#define OCT_RBV DBL_MAX / 100.0
-#endif
-
-std::ostream&
-ComplexMatrix::save_ascii (std::ostream& os, bool& infnan_warned,
-			   int strip_nan_and_inf)
-{
-  if (strip_nan_and_inf)
-    {
-      octave_idx_type nr = rows ();
-      octave_idx_type nc = columns ();
-
-      for (octave_idx_type i = 0; i < nr; i++)
-	{
-	  if (strip_nan_and_inf)
-	    {
-	      for (octave_idx_type j = 0; j < nc; j++)
-		{
-		  Complex c = elem (i, j);
-
-		  if (xisnan (c))
-		    {
-		      if (strip_nan_and_inf == 1)
-			goto next_row;
-		      else if (strip_nan_and_inf == 2)
-			goto next_row_with_newline;
-		    }
-		}
-	    }
-
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      Complex c = elem (i, j);
-
-	      if (strip_nan_and_inf)
-		{
-		  double re = std::real (c);
-		  double im = std::imag (c);
-
-		  if (xisinf (re))
-		    re = re > 0 ? OCT_RBV : -OCT_RBV;
-
-		  if (xisinf (im))
-		    im = im > 0 ? OCT_RBV : -OCT_RBV;
-
-		  c = Complex (re, im);
-		}
-	      else if (! infnan_warned && (xisnan (c) || xisinf (c)))
-		{
-		  (*current_liboctave_warning_handler)
-		    ("save: Inf or NaN values may not be reloadable");
-
-		  infnan_warned = true;
-		}
-
-	      octave_write_complex (os, c);
-
-	      os << " ";
-	    }
-
-	next_row_with_newline:
-	  os << "\n";
-
-	next_row:
-	  continue;
-	}
-    }
-  else
-    os << *this;
-
-  return os;
-}
-
 std::ostream&
 operator << (std::ostream& os, const ComplexMatrix& a)
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     {
       for (octave_idx_type j = 0; j < a.cols (); j++)
 	{
 	  os << " ";
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -314,19 +314,16 @@ public:
   ComplexRowVector column_min (void) const;
   ComplexRowVector column_max (void) const;
 
   ComplexRowVector column_min (Array<octave_idx_type>& index) const;
   ComplexRowVector column_max (Array<octave_idx_type>& index) const;
 
   // i/o
 
-  std::ostream& save_ascii (std::ostream& os, bool& infnan_warned,
-			    int strip_nan_and_inf);
-
   friend std::ostream& operator << (std::ostream& os, const ComplexMatrix& a);
   friend std::istream& operator >> (std::istream& is, ComplexMatrix& a);
 
   static Complex resize_fill_value (void) { return Complex (0.0, 0.0); }
 
 private:
 
   ComplexMatrix (Complex *d, octave_idx_type r, octave_idx_type c) : MArray2<Complex> (d, r, c) { }
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,13 @@
+2006-08-23  John W. Eaton  <jwe@octave.org>
+
+	* dMatrix.cc, dMatrix.h (Matrix::save_ascii): Delete function and decl.
+	* CMatrix.cc, CMatrix.h (ComplexMatrix::save_ascii): Likewise.
+
 2006-08-22  John W. Eaton  <jwe@octave.org>
 
 	* CMatrix.cc (ComplexMatrix::save_ascii): New function.
 	* dMatrix.cc (Matrix::save_ascii): New function.
 
 	* mx-inlines.cc (MX_ND_CUMULATIVE_OP): Correctly detect empty arrays.
 	If array is empty, return value is same size as array.
 	(MX_ND_REDUCTION): Correctly detect empty arrays.
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -2846,84 +2846,16 @@ Matrix::column_max (Array<octave_idx_typ
 	  result.elem (j) = tmp_max;
 	  idx_arg.elem (j) = xisnan (tmp_max) ? 0 : idx_i;
         }
     }
 
   return result;
 }
 
-// Used when converting Inf to something that gnuplot can read.
-
-#ifndef OCT_RBV
-#define OCT_RBV DBL_MAX / 100.0
-#endif
-
-std::ostream&
-Matrix::save_ascii (std::ostream& os, bool& infnan_warned,
-		    int strip_nan_and_inf)
-{
-  if (strip_nan_and_inf)
-    {
-      octave_idx_type nr = rows ();
-      octave_idx_type nc = columns ();
-
-      for (octave_idx_type i = 0; i < nr; i++)
-	{
-	  if (strip_nan_and_inf)
-	    {
-	      for (octave_idx_type j = 0; j < nc; j++)
-		{
-		  double d = elem (i, j);
-
-		  if (xisnan (d))
-		    {
-		      if (strip_nan_and_inf == 1)
-			goto next_row;
-		      else if (strip_nan_and_inf == 2)
-			goto next_row_with_newline;
-		    }
-		}
-	    }
-
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      double d = elem (i, j);
-
-	      if (strip_nan_and_inf)
-		{
-		  if (xisinf (d))
-		    d = d > 0 ? OCT_RBV : -OCT_RBV;
-		}
-	      else if (! infnan_warned && (xisnan (d) || xisinf (d)))
-		{
-		  (*current_liboctave_warning_handler)
-		    ("save: Inf or NaN values may not be reloadable");
-
-		  infnan_warned = true;
-		}
-
-	      octave_write_double (os, d);
-
-	      os << " ";
-	    }
-
-	next_row_with_newline:
-	  os << "\n";
-
-	next_row:
-	  continue;
-	}
-    }
-  else
-    os << *this;
-
-  return os;
-}
-
 std::ostream&
 operator << (std::ostream& os, const Matrix& a)
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     {
       for (octave_idx_type j = 0; j < a.cols (); j++)
 	{
 	  os << " ";
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -269,19 +269,16 @@ public:
   RowVector column_min (void) const;
   RowVector column_max (void) const;
 
   RowVector column_min (Array<octave_idx_type>& index) const;
   RowVector column_max (Array<octave_idx_type>& index) const;
 
   // i/o
 
-  std::ostream& save_ascii (std::ostream& os, bool& infnan_warned,
-			    int strip_nan_and_inf);
-
   friend std::ostream& operator << (std::ostream& os, const Matrix& a);
   friend std::istream& operator >> (std::istream& is, Matrix& a);
 
   static double resize_fill_value (void) { return 0; }
 
 private:
 
   Matrix (double *d, octave_idx_type r, octave_idx_type c) : MArray2<double> (d, r, c) { }
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,12 @@
+2006-08-23  John W. Eaton  <jwe@octave.org>
+
+	* plot/__plt__.m: Insert using clauses for all plots.
+
 2006-08-23  A S Hodel  <hodelas@auburn.edu>
 
 	* control/system/sysscale.m: Call tf and zp with correct number of
 	args.
 
 2006-08-22  David Bateman  <dbateman@free.fr>
 
 	* pkg/pkg.m (extract_pkgadd, create_pkgadd): New functions to 
diff --git a/scripts/plot/__plt__.m b/scripts/plot/__plt__.m
--- a/scripts/plot/__plt__.m
+++ b/scripts/plot/__plt__.m
@@ -88,27 +88,29 @@ function __plt__ (caller, varargin)
       else
 	x = next_arg;
 	x_set = true;
       endif
 
       if (have_data)
 	if (iscell (__plot_data__{__current_figure__}{__multiplot_xi__,__multiplot_yi__}{j}))
 	  for i = 1:length (__plot_data__{__current_figure__}{__multiplot_xi__,__multiplot_yi__}{j})
+	    usingstr = make_using_clause (__plot_data__{__current_figure__}{__multiplot_xi__,__multiplot_yi__}{j}{i});
 	    __plot_command__{__current_figure__}{__multiplot_xi__,__multiplot_yi__} \
-		= sprintf ("%s%s __plot_data__{__current_figure__}{__multiplot_xi__,__multiplot_yi__}{%d}{%d} %s",
+		= sprintf ("%s%s __plot_data__{__current_figure__}{__multiplot_xi__,__multiplot_yi__}{%d}{%d} %s %s",
 			   __plot_command__{__current_figure__}{__multiplot_xi__,__multiplot_yi__},
-			   __plot_command_sep__, j, i, fmtstr{i});
+			   __plot_command_sep__, j, i, usingstr, fmtstr{i});
 	    __plot_command_sep__ = ",\\\n";
 	  endfor
 	else
+	  usingstr = make_using_clause (__plot_data__{__current_figure__}{__multiplot_xi__,__multiplot_yi__}{j});
 	  __plot_command__{__current_figure__}{__multiplot_xi__,__multiplot_yi__} \
-	    = sprintf ("%s%s __plot_data__{__current_figure__}{__multiplot_xi__,__multiplot_yi__}{%d} %s",
+	    = sprintf ("%s%s __plot_data__{__current_figure__}{__multiplot_xi__,__multiplot_yi__}{%d} %s %s",
 		       __plot_command__{__current_figure__}{__multiplot_xi__,__multiplot_yi__},
-		       __plot_command_sep__, j, fmtstr);
+		       __plot_command_sep__, j, usingstr, fmtstr);
 	  __plot_command_sep__ = ",\\\n";
 	endif
 	j++;
       endif
 
     endwhile
 
     __plot_data_offset__{__current_figure__}(__multiplot_xi__,__multiplot_yi__) = j;
@@ -122,9 +124,21 @@ function __plt__ (caller, varargin)
 
   else
     msg = sprintf ("%s (y)\n", caller);
     msg = sprintf ("%s       %s (x, y, ...)\n", msg, caller);
     msg = sprintf ("%s       %s (x, y, fmt, ...)", msg, caller);
     usage (msg);
   endif
 
-endfunction
+## endfunction
+
+function usingstr = make_using_clause (x)
+  cols = columns (x);
+  if (cols > 0)
+    usingstr = strcat (gnuplot_command_using, " ($1)");
+    for k = 2:cols
+      usingstr = sprintf ("%s:($%d)", usingstr, k);
+    endfor
+  else
+    usingstr = "";
+  endif
+## endfunction
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,55 @@
+2006-08-23  John W. Eaton  <jwe@octave.org>
+
+	* ov.h (octave_value::save_ascii): Delete strip_nan_and_inf arg.
+	* ov-base.h, ov-base.cc (octave_base_value::save_ascii): Likewise.
+	* ov-base-int.h, ov-base-int.cc	(octave_base_int_matrix<T>::save_ascii,
+	octave_base_int_scalar<T>::save_ascii, ): Likewise.
+	* ov-base-sparse.cc, ov-base-sparse.h
+	(octave_base_sparse<T>::save_ascii): Likewise.
+	* ov-bool-mat.cc, ov-bool-mat.h (octave_bool_matrix::save_ascii):
+	Likewise.
+	* ov-bool.cc, ov-bool.h (octave_bool::save_ascii): Likewise.
+	* ov-cell.cc, ov-cell.h (octave_cell::save_ascii): Likewise.
+	* ov-complex.cc, ov-complex.h (octave_complex::save_ascii): Likewise.
+	* ov-fcn-handle.cc, ov-fcn-handle.h (octave_fcn_handle::save_ascii):
+	Likewise.
+	* ov-fcn-inline.cc, ov-fcn-inline.h (octave_fcn_inline::save_ascii):
+	Likewise.
+	* ov-list.cc, ov-list.h (octave_list::save_ascii): Likewise.
+	* ov-range.cc, ov-range.h (octave_range::save_ascii): Likewise.
+	* ov-scalar.cc, ov-scalar.h (octave_scalar::save_ascii): Likewise.
+	* ov-str-mat.cc, ov-str-mat.h (octave_char_matrix_str::save_ascii):
+	Likewise.
+	* ov-struct.cc, ov-struct.h (octave_struct::save_ascii): Likewise.
+	* ov-re-mat.cc, ov-re-mat.cc (octave_matrix::save_ascii): Likewise.
+	* ov-cx-mat.cc, ov-cx-mat.cc (octave_complex_matrix::save_ascii):
+	Likewise.
+	* ov-cx-mat.cc, ov-cx-mat.cc (octave_complex_matrix::save_ascii):
+	Likewise.
+	* ov-re-mat.cc, ov-re-mat.cc (octave_matrix::save_ascii): Likewise.
+
+	* ls-oct-ascii.cc, ls-oct-ascii.h (save_ascii_data):
+	Delete strip_nan_and_inf arg.
+	(save_ascii_data_for_plotting): Delete strip_nan_and_inf arg from
+	call to save_ascii_data.
+
+	* DLD-FUNCTIONS/__gnuplot_raw__.l (handle_using): Accept "(EXPR)"
+	as components of using clauses.
+	(enum _toktype): New element DOLLAR.
+	Accept "$" in lexer.
+
+	* ls-oct-ascii.cc (save_ascii_data): Delete arg strip_nan_and_inf.
+	Change all uses.
+
+	* ls-oct-ascii.h (save_three_d): Provide decl.
+	* load-save.h (save_ascii_data_for_plotting, save_three_d):
+	Delete decls.
+
 2006-08-22  John W. Eaton  <jwe@octave.org>
 
 	* ov.h (octave_value::save_ascii): strip_nan_and_inf is now int,
 	not bool.
 	* ov-base.h, ov-base.cc (octave_base_value::save_ascii): Likewise.
 	* ov-base-int.h, ov-base-int.cc	(octave_base_int_matrix<T>::save_ascii,
 	octave_base_int_scalar<T>::save_ascii, ): Likewise.
 	* ov-base-sparse.cc, ov-base-sparse.h
@@ -18,17 +65,18 @@ 2006-08-22  John W. Eaton  <jwe@octave.o
 	Likewise.
 	* ov-list.cc, ov-list.h (octave_list::save_ascii): Likewise.
 	* ov-range.cc, ov-range.h (octave_range::save_ascii): Likewise.
 	* ov-scalar.cc, ov-scalar.h (octave_scalar::save_ascii): Likewise.
 	* ov-str-mat.cc, ov-str-mat.h (octave_char_matrix_str::save_ascii):
 	Likewise.
 	* ov-struct.cc, ov-struct.h (octave_struct::save_ascii): Likewise.
 	* ov-re-mat.cc, ov-re-mat.cc (octave_matrix::save_ascii): Likewise.
-	* ov-cx-mat.cc, ov-cx-mat.cc (octave_complex_matrix::save_ascii): Likewise.
+	* ov-cx-mat.cc, ov-cx-mat.cc (octave_complex_matrix::save_ascii):
+	Likewise.
 
 	* ov-cx-mat.cc, ov-cx-mat.cc (octave_complex_matrix::save_ascii):
 	Don't strip Inf and NaN here.  Call ComplexMatrix::save_ascii to
 	do the real work.
 	* ov-re-mat.cc, ov-re-mat.cc (octave_matrix::save_ascii):
 	Don't strip Inf and NaN here.  Call Matrix::save_ascii to do the
 	real work.
 
diff --git a/src/DLD-FUNCTIONS/__gnuplot_raw__.l b/src/DLD-FUNCTIONS/__gnuplot_raw__.l
--- a/src/DLD-FUNCTIONS/__gnuplot_raw__.l
+++ b/src/DLD-FUNCTIONS/__gnuplot_raw__.l
@@ -52,17 +52,17 @@ 02110-1301, USA.
 #endif
 
 #include "file-ops.h"
 #include "oct-env.h"
 
 #include "defun-dld.h"
 #include "file-io.h"
 #include "gripes.h"
-#include "load-save.h"
+#include "ls-oct-ascii.h"
 #include "parse.h"
 #include "procstream.h"
 #include "sighandlers.h"
 #include "utils.h"
 #include "variables.h"
 
 enum _toktype
   {
@@ -71,16 +71,17 @@ enum _toktype
     START_BRACE,
     END_BRACE,
     START_BRACKET,
     END_BRACKET,
     COLON,
     SEMICOLON,
     COMMA,
     QUOTE,
+    DOLLAR,
     IDENT,
     NUMBER,
     BINOP,
     UNOP,
     STRING,
     OTHER,
     TITLE,
     USING,
@@ -189,16 +190,22 @@ UNOP    ((\+\+)|(\-\-)|(\.'))
     else
       {
         gpt_quote_is_transpose = true;
         gpt_allow_plotkw = true;
         return handle_string ('\'');
       }
     }
 
+"$" {
+    gpt_quote_is_transpose = false;
+    return DOLLAR;
+    }
+
+
 "\"" {
     return handle_string ('"');
     }
 
 {IDENT} {
     int itok = 0;
     if (can_be_plotkw () && (itok = is_plot_keyword (yytext)))
       {
@@ -572,23 +579,28 @@ handle_using (int& lasttok)
   bool out = false;
 
   octave_value tmp_data;
   int status;
   while (! out)
     {
       expr_str = read_until (colon_plottok_or_end_p, tok);
 
-      tmp_data = eval_string (expr_str, true, status);
-      if (status != 0 || ! tmp_data.is_real_scalar ())
-	throw gpt_parse_error ();
+      if (! expr_str.empty () &&  expr_str[0] == '(')
+	retstr += expr_str;
+      else
+	{
+	  tmp_data = eval_string (expr_str, true, status);
+	  if (status != 0 || ! tmp_data.is_real_scalar ())
+	    throw gpt_parse_error ();
 
-      std::ostringstream tmp_buf;
-      tmp_data.print_raw (tmp_buf);
-      retstr += tmp_buf.str ();
+	  std::ostringstream tmp_buf;
+	  tmp_data.print_raw (tmp_buf);
+	  retstr += tmp_buf.str ();
+	}
 
       if (tok == COLON)
 	retstr += ":";
       else
 	out = true;
     }
 
   lasttok = tok;
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -988,17 +988,17 @@ static void
 do_save (std::ostream& os, const octave_value& tc,
 	 const std::string& name, const std::string& help,
 	 int global, load_save_format fmt, bool save_as_floats,
 	 bool& infnan_warned)
 {
   switch (fmt)
     {
     case LS_ASCII:
-      save_ascii_data (os, tc, name, infnan_warned, false, global, 0);
+      save_ascii_data (os, tc, name, infnan_warned, global, 0);
       break;
 
     case LS_BINARY:
       save_binary_data (os, tc, name, help, global, save_as_floats);
       break;
 
     case LS_MAT_ASCII:
     case LS_MAT_ASCII_LONG:
diff --git a/src/load-save.h b/src/load-save.h
--- a/src/load-save.h
+++ b/src/load-save.h
@@ -40,24 +40,16 @@ enum load_save_format
     LS_MAT5_BINARY,
     LS_MAT7_BINARY,
 #ifdef HAVE_HDF5
     LS_HDF5,
 #endif /* HAVE_HDF5 */
     LS_UNKNOWN
   };
 
-extern bool
-save_ascii_data_for_plotting (std::ostream& os, const octave_value& t,
-			      const std::string& name = std::string ());
-
-extern bool
-save_three_d (std::ostream& os, const octave_value& t,
-	      bool parametric = false);
-
 extern void dump_octave_core (void);
 
 extern int
 read_binary_file_header (std::istream& is, bool& swap,
 			 oct_mach_info::float_format& flt_fmt,
 			 bool quiet = false);
 
 extern octave_value
diff --git a/src/ls-oct-ascii.cc b/src/ls-oct-ascii.cc
--- a/src/ls-oct-ascii.cc
+++ b/src/ls-oct-ascii.cc
@@ -302,34 +302,27 @@ read_ascii_data (std::istream& is, const
 
   return name;
 }
 
 // Save the data from TC along with the corresponding NAME, and global
 // flag MARK_AS_GLOBAL on stream OS in the plain text format described
 // above for load_ascii_data.  If NAME is empty, the name: line is not
 // generated.  PRECISION specifies the number of decimal digits to print. 
-// If STRIP_NAN_AND_INF is 1, rows containing NaNs are deleted,
-// and Infinite values are converted to +/-OCT_RBV (A Real Big Value,
-// but not so big that gnuplot can't handle it when trying to compute
-// axis ranges, etc.).  If STRIP_NAN_AND_INF is 2, rows containing
-// NaNs are converted to blank lines in the output file and infinite
-// values are converted to +/-OCT_RBV.
 //
 // Assumes ranges and strings cannot contain Inf or NaN values.
 //
 // Returns 1 for success and 0 for failure.
 
 // FIXME -- should probably write the help string here too.
 
 bool
 save_ascii_data (std::ostream& os, const octave_value& val_arg,
 		 const std::string& name, bool& infnan_warned,
-		 int strip_nan_and_inf, bool mark_as_global,
-		 int precision)
+		 bool mark_as_global, int precision)
 {
   bool success = true;
 
   if (! name.empty ())
     os << "# name: " << name << "\n";
 
   octave_value val = val_arg;
 
@@ -339,30 +332,30 @@ save_ascii_data (std::ostream& os, const
     os << "# type: " << val.type_name() << "\n";
 
   if (! precision)
     precision = Vsave_precision;
 
   long old_precision = os.precision ();
   os.precision (precision);
 
-  success = val . save_ascii (os, infnan_warned, strip_nan_and_inf);
+  success = val . save_ascii (os, infnan_warned);
 
   os.precision (old_precision);
 
   return (os && success);
 }
 
 bool
 save_ascii_data_for_plotting (std::ostream& os, const octave_value& t,
 			      const std::string& name)
 {
   bool infnan_warned = true;
 
-  return save_ascii_data (os, t, name, infnan_warned, 2, false, 0);
+  return save_ascii_data (os, t, name, infnan_warned, false, 0);
 }
 
 // Maybe this should be a static function in tree-plot.cc?
 
 // If TC is matrix, save it on stream OS in a format useful for
 // making a 3-dimensional plot with gnuplot.  If PARAMETRIC is
 // TRUE, assume a parametric 3-dimensional plot will be generated.
 
diff --git a/src/ls-oct-ascii.h b/src/ls-oct-ascii.h
--- a/src/ls-oct-ascii.h
+++ b/src/ls-oct-ascii.h
@@ -46,23 +46,26 @@ extract_keyword (std::istream& is, const
 
 extern std::string
 read_ascii_data (std::istream& is, const std::string& filename, bool& global,
 		 octave_value& tc, octave_idx_type count);
 
 extern bool
 save_ascii_data (std::ostream& os, const octave_value& val_arg,
 		 const std::string& name, bool& infnan_warned,
-		 int strip_nan_and_inf, bool mark_as_global,
-		 int precision);
+		 bool mark_as_global, int precision);
 
 extern bool
 save_ascii_data_for_plotting (std::ostream& os, const octave_value& t,
 			      const std::string& name);
 
+extern bool
+save_three_d (std::ostream& os, const octave_value& t,
+	      bool parametric = false);
+
 // Match KEYWORD on stream IS, placing the associated value in VALUE,
 // returning TRUE if successful and FALSE otherwise.
 //
 // Input should look something like:
 //
 //  [%#][ \t]*keyword[ \t]*int-value.*\n
 
 template <class T>
diff --git a/src/ov-base-int.cc b/src/ov-base-int.cc
--- a/src/ov-base-int.cc
+++ b/src/ov-base-int.cc
@@ -65,17 +65,17 @@ octave_base_int_matrix<T>::try_narrowing
   if (this->matrix.nelem () == 1)
     retval = new typename octave_value_int_traits<T>::scalar_type (this->matrix (0));
 
   return retval;
 }
 
 template <class T>
 bool
-octave_base_int_matrix<T>::save_ascii (std::ostream& os, bool&, int)
+octave_base_int_matrix<T>::save_ascii (std::ostream& os, bool&)
 {
   dim_vector d = this->dims ();
 
   os << "# ndims: " << d.length () << "\n";
 
   for (int i = 0; i < d.length (); i++)
     os << " " << d (i);
 
@@ -326,17 +326,17 @@ octave_base_int_matrix<T>::print_raw (st
 				      bool pr_as_read_syntax) const
 {
   octave_print_internal (os, this->matrix, pr_as_read_syntax,
    			 this->current_print_indent_level ());
 }
 
 template <class T>
 bool
-octave_base_int_scalar<T>::save_ascii (std::ostream& os, bool& , int)
+octave_base_int_scalar<T>::save_ascii (std::ostream& os, bool&)
 {
   os << this->scalar << "\n";
   return true;
 }
 
 template <class T>
 bool 
 octave_base_int_scalar<T>::load_ascii (std::istream& is)
diff --git a/src/ov-base-int.h b/src/ov-base-int.h
--- a/src/ov-base-int.h
+++ b/src/ov-base-int.h
@@ -62,18 +62,17 @@ public:
   bool is_real_type (void) const { return true; }
 
   //  void increment (void) { matrix += 1; }
 
   //  void decrement (void) { matrix -= 1; }
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  bool save_ascii (std::ostream& os, bool& infnan_warned,
-		   int strip_nan_and_inf);
+  bool save_ascii (std::ostream& os, bool& infnan_warned);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& );
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format );
 
@@ -104,17 +103,17 @@ public:
   octave_base_value *try_narrowing_conversion (void) { return 0; }
 
   bool is_real_type (void) const { return true; }
 
   //  void increment (void) { scalar += 1; }
 
   //  void decrement (void) { scalar -= 1; }
 
-  bool save_ascii (std::ostream& os, bool&, int);
+  bool save_ascii (std::ostream& os, bool&);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& );
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format );
 
diff --git a/src/ov-base-sparse.cc b/src/ov-base-sparse.cc
--- a/src/ov-base-sparse.cc
+++ b/src/ov-base-sparse.cc
@@ -290,17 +290,17 @@ octave_base_sparse<T>::print_raw (std::o
 	      octave_print_internal (os, matrix.data(i), pr_as_read_syntax);
 	    }
 	}
     }
 }
 
 template <class T>
 bool
-octave_base_sparse<T>::save_ascii (std::ostream& os, bool&, int)
+octave_base_sparse<T>::save_ascii (std::ostream& os, bool&)
 {
   dim_vector dv = this->dims ();
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
   os << "# nnz: "      << nzmax () << "\n";
   os << "# rows: "     << dv (0) << "\n";
diff --git a/src/ov-base-sparse.h b/src/ov-base-sparse.h
--- a/src/ov-base-sparse.h
+++ b/src/ov-base-sparse.h
@@ -136,18 +136,17 @@ octave_base_sparse : public octave_base_
   bool print_as_scalar (void) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_info (std::ostream& os, const std::string& prefix) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  bool save_ascii (std::ostream& os, bool& infnan_warned,
-		   int strip_nan_and_inf);
+  bool save_ascii (std::ostream& os, bool& infnan_warned);
 
   bool load_ascii (std::istream& is);
 
   // Unsafe.  These functions exists to support the MEX interface.
   // You should not use them anywhere else.
   void *mex_get_data (void) const { return matrix.mex_get_data (); }
 
   octave_idx_type *mex_get_ir (void) const { return matrix.mex_get_ir (); }
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -810,17 +810,17 @@ octave_value_list
 octave_base_value::list_value (void) const
 {
   octave_value_list retval;
   gripe_wrong_type_arg ("octave_base_value::list_value()", type_name ());
   return retval;
 }
 
 bool 
-octave_base_value::save_ascii (std::ostream&, bool&, int)
+octave_base_value::save_ascii (std::ostream&, bool&)
 {
   gripe_wrong_type_arg ("octave_base_value::save_ascii()", type_name ());
   return false;
 }
 
 bool 
 octave_base_value::load_ascii (std::istream&)
 {
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -409,18 +409,17 @@ public:
   print_name_tag (std::ostream& os, const std::string& name) const;
 
   virtual void
   print_with_name (std::ostream& output_buf, const std::string& name, 
 		   bool print_padding = true) const;
 
   virtual void print_info (std::ostream& os, const std::string& prefix) const;
 
-  virtual bool save_ascii (std::ostream& os, bool& infnan_warned,
-			   int strip_nan_and_inf);
+  virtual bool save_ascii (std::ostream& os, bool& infnan_warned);
 
   virtual bool load_ascii (std::istream& is);
 
   virtual bool save_binary (std::ostream& os, bool& save_as_floats);
 
   virtual bool load_binary (std::istream& is, bool swap, 
 			    oct_mach_info::float_format fmt);
 
diff --git a/src/ov-bool-mat.cc b/src/ov-bool-mat.cc
--- a/src/ov-bool-mat.cc
+++ b/src/ov-bool-mat.cc
@@ -144,18 +144,17 @@ void
 octave_bool_matrix::print_raw (std::ostream& os,
 			       bool pr_as_read_syntax) const
 {
   octave_print_internal (os, matrix, pr_as_read_syntax,
 			 current_print_indent_level ());
 }
 
 bool 
-octave_bool_matrix::save_ascii (std::ostream& os, bool& /* infnan_warned */,
-				int /* strip_nan_and_inf */)
+octave_bool_matrix::save_ascii (std::ostream& os, bool& /* infnan_warned */)
 {
   dim_vector d = dims ();
   if (d.length () > 2)
     {
       NDArray tmp = array_value ();
       os << "# ndims: " << d.length () << "\n";
 
       for (int i = 0; i < d.length (); i++)
diff --git a/src/ov-bool-mat.h b/src/ov-bool-mat.h
--- a/src/ov-bool-mat.h
+++ b/src/ov-bool-mat.h
@@ -159,18 +159,17 @@ public:
 
   SparseBoolMatrix sparse_bool_matrix_value (bool = false) const
   { return SparseBoolMatrix (matrix.matrix_value ()); }
 
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  bool save_ascii (std::ostream& os, bool& infnan_warned,
-		   int strip_nan_and_inf);
+  bool save_ascii (std::ostream& os, bool& infnan_warned);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
diff --git a/src/ov-bool.cc b/src/ov-bool.cc
--- a/src/ov-bool.cc
+++ b/src/ov-bool.cc
@@ -128,18 +128,17 @@ octave_bool::convert_to_str_internal (bo
   char s[2];
   s[0] = static_cast<char> (scalar);
   s[1] = '\0';
 
   return octave_value (s, type);
 }
 
 bool 
-octave_bool::save_ascii (std::ostream& os, bool& /* infnan_warned */,
-			 int /* strip_nan_and_inf */)
+octave_bool::save_ascii (std::ostream& os, bool& /* infnan_warned */)
 {
   double d = double_value ();
 
   octave_write_double (os, d);
   os << "\n";
 
   return true;
 }
diff --git a/src/ov-bool.h b/src/ov-bool.h
--- a/src/ov-bool.h
+++ b/src/ov-bool.h
@@ -151,18 +151,17 @@ public:
 
   boolNDArray bool_array_value (bool = false) const
     { return boolNDArray (dim_vector (1, 1), scalar); }
 
   octave_value resize (const dim_vector& dv, bool fill = false) const;
 
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
-  bool save_ascii (std::ostream& os, bool& infnan_warned,
-		   int strip_nan_and_inf);
+  bool save_ascii (std::ostream& os, bool& infnan_warned);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -428,18 +428,17 @@ octave_cell::print_raw (std::ostream& os
       os << "{" << dv.str () << " Cell Array}";
       newline (os);
     }
 }
 
 #define CELL_ELT_TAG "<cell-element>"
 
 bool 
-octave_cell::save_ascii (std::ostream& os, bool& infnan_warned, 
-			 int strip_nan_and_inf)
+octave_cell::save_ascii (std::ostream& os, bool& infnan_warned)
 {
   dim_vector d = dims ();
   if (d.length () > 2)
     {
       os << "# ndims: " << d.length () << "\n";
       
       for (int i = 0; i < d.length (); i++)
 	os << " " << d (i);
@@ -448,17 +447,17 @@ octave_cell::save_ascii (std::ostream& o
       Cell tmp = cell_value ();
       
       for (octave_idx_type i = 0; i < d.numel (); i++)
 	{
 	  octave_value o_val = tmp.elem (i);
 
 	  // Recurse to print sub-value.
 	  bool b = save_ascii_data (os, o_val, CELL_ELT_TAG, infnan_warned, 
-				    strip_nan_and_inf, 0, 0);
+				    false, 0);
 	      
 	  if (! b)
 	    return os;
 	}
     }
   else
     {
       // Keep this case, rather than use generic code above for backward 
@@ -471,18 +470,17 @@ octave_cell::save_ascii (std::ostream& o
       for (octave_idx_type j = 0; j < tmp.cols (); j++)
 	{
 	  for (octave_idx_type i = 0; i < tmp.rows (); i++)
 	    {
 	      octave_value o_val = tmp.elem (i, j);
 
 	      // Recurse to print sub-value.
 	      bool b = save_ascii_data (os, o_val, CELL_ELT_TAG, 
-					infnan_warned, 
-					strip_nan_and_inf, 0, 0);
+					infnan_warned, false, 0);
 	      
 	      if (! b)
 		return os;
 	    }
 	  
 	  os << "\n";
 	}
     }
diff --git a/src/ov-cell.h b/src/ov-cell.h
--- a/src/ov-cell.h
+++ b/src/ov-cell.h
@@ -108,18 +108,17 @@ public:
 
   bool print_as_scalar (void) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
 
-  bool save_ascii (std::ostream& os, bool& infnan_warned,
-		   int strip_nan_and_inf);
+  bool save_ascii (std::ostream& os, bool& infnan_warned);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
diff --git a/src/ov-complex.cc b/src/ov-complex.cc
--- a/src/ov-complex.cc
+++ b/src/ov-complex.cc
@@ -171,53 +171,29 @@ octave_complex::resize (const dim_vector
       if (dv.numel ())
 	retval(0) = scalar;
 
       return retval;
     }
 }
 
 bool 
-octave_complex::save_ascii (std::ostream& os, bool& infnan_warned, 
-			    int strip_nan_and_inf)
+octave_complex::save_ascii (std::ostream& os, bool& infnan_warned)
 {
   Complex c = complex_value ();
 
-  if (strip_nan_and_inf)
+  if (! infnan_warned && (xisnan (c) || xisinf (c)))
     {
-      if (xisnan (c))
-	{
-	  error ("only value to plot is NaN");
-	  return false;
-	}
-      else
-	{
-	  double re = real (c);
-	  double im = imag (c);
-
-	  re = xisinf (re) ? (re > 0 ? OCT_RBV : -OCT_RBV) : re;
-	  im = xisinf (im) ? (im > 0 ? OCT_RBV : -OCT_RBV) : im;
+      warning ("save: Inf or NaN values may not be reloadable");
+      infnan_warned = true;
+    }
+      
+  octave_write_complex (os, c);
 
-	  c = Complex (re, im);
-
-	  octave_write_complex (os, c);
-	  os << "\n";
-	}
-    }
-  else
-    {
-      if (! infnan_warned && (xisnan (c) || xisinf (c)))
-	{
-	  warning ("save: Inf or NaN values may not be reloadable");
-	  infnan_warned = true;
-	}
-      
-      octave_write_complex (os, c);
-      os << "\n";
-    }
+  os << "\n";
 
   return true;
 }
 
 bool 
 octave_complex::load_ascii (std::istream& is)
 {
   scalar = octave_read_complex (is);
diff --git a/src/ov-complex.h b/src/ov-complex.h
--- a/src/ov-complex.h
+++ b/src/ov-complex.h
@@ -111,18 +111,17 @@ public:
   ComplexMatrix complex_matrix_value (bool = false) const;
 
   ComplexNDArray complex_array_value (bool = false) const;
 
   void increment (void) { scalar += 1.0; }
 
   void decrement (void) { scalar -= 1.0; }
 
-  bool save_ascii (std::ostream& os, bool& infnan_warned,
-		   int strip_nan_and_inf);
+  bool save_ascii (std::ostream& os, bool& infnan_warned);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
diff --git a/src/ov-cx-mat.cc b/src/ov-cx-mat.cc
--- a/src/ov-cx-mat.cc
+++ b/src/ov-cx-mat.cc
@@ -196,31 +196,24 @@ octave_complex_matrix::sparse_matrix_val
 
 SparseComplexMatrix
 octave_complex_matrix::sparse_complex_matrix_value (bool) const
 {
   return SparseComplexMatrix (matrix.matrix_value ());
 }
 
 bool 
-octave_complex_matrix::save_ascii (std::ostream& os, bool& infnan_warned, 
-				   int strip_nan_and_inf)
+octave_complex_matrix::save_ascii (std::ostream& os, bool& infnan_warned)
 {
   dim_vector d = dims ();
   if (d.length () > 2)
     {
       ComplexNDArray tmp = complex_array_value ();
 
-      if (strip_nan_and_inf)
-	{
-	  warning ("save: Can not strip Inf or NaN values");
-	  warning ("save: Inf or NaN values may not be reloadable");
-	  infnan_warned = true;
-	}
-      else if (! infnan_warned && tmp.any_element_is_inf_or_nan ())
+      if (! infnan_warned && tmp.any_element_is_inf_or_nan ())
 	{
 	  warning ("save: Inf or NaN values may not be reloadable");
 	  infnan_warned = true;
 	}
 
       os << "# ndims: " << d.length () << "\n";
 
       for (int i = 0; i < d.length (); i++)
@@ -230,19 +223,17 @@ octave_complex_matrix::save_ascii (std::
     }
   else
     {
       // Keep this case, rather than use generic code above for backward 
       // compatiability. Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
 	 << "# columns: " << columns () << "\n";
 
-      ComplexMatrix tmp = complex_matrix_value ();
-
-      tmp.save_ascii (os, infnan_warned, strip_nan_and_inf);
+      os << complex_matrix_value ();
     }
 
   return true;
 }
 
 bool 
 octave_complex_matrix::load_ascii (std::istream& is)
 {
diff --git a/src/ov-cx-mat.h b/src/ov-cx-mat.h
--- a/src/ov-cx-mat.h
+++ b/src/ov-cx-mat.h
@@ -115,18 +115,17 @@ public:
   SparseMatrix sparse_matrix_value (bool = false) const;
 
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const;
 
   void increment (void) { matrix += Complex (1.0); }
 
   void decrement (void) { matrix -= Complex (1.0); }
 
-  bool save_ascii (std::ostream& os, bool& infnan_warned,
-		   int strip_nan_and_inf);
+  bool save_ascii (std::ostream& os, bool& infnan_warned);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -139,17 +139,17 @@ octave_fcn_handle::subsref (const std::s
 
   if (idx.size () > 1)
     retval = retval(0).next_subsref (nargout, type, idx);
 
   return retval;
 }
 
 bool
-octave_fcn_handle::save_ascii (std::ostream& os, bool&, int)
+octave_fcn_handle::save_ascii (std::ostream& os, bool&)
 {
   os << nm << "\n";
 
   if (nm == "@<anonymous>")
     {
       print_raw (os, true);
       os << "\n";
     }
diff --git a/src/ov-fcn-handle.h b/src/ov-fcn-handle.h
--- a/src/ov-fcn-handle.h
+++ b/src/ov-fcn-handle.h
@@ -79,18 +79,17 @@ public:
     { return fcn.function_value (); }
 
   octave_fcn_handle *fcn_handle_value (bool = false) { return this; }
 
   octave_value fcn_val (void) const { return fcn; }
 
   std::string fcn_name (void) const { return nm; }
 
-  bool save_ascii (std::ostream& os, bool& infnan_warned,
-		   int strip_nan_and_inf);
+  bool save_ascii (std::ostream& os, bool& infnan_warned);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
diff --git a/src/ov-fcn-inline.cc b/src/ov-fcn-inline.cc
--- a/src/ov-fcn-inline.cc
+++ b/src/ov-fcn-inline.cc
@@ -85,17 +85,17 @@ octave_fcn_inline::octave_fcn_inline (co
 	fcn = fh->fcn_val ();
     }
 
   if (fcn.is_undefined ())
     error ("inline: unable to define function");
 }
 
 bool
-octave_fcn_inline::save_ascii (std::ostream& os, bool&, int)
+octave_fcn_inline::save_ascii (std::ostream& os, bool&)
 {
   os << "# nargs: " <<  ifargs.length () << "\n";
   for (int i = 0; i < ifargs.length (); i++)
     os << ifargs(i) << "\n";
   if (nm.length () < 1)
     // Write an invalid value to flag empty fcn handle name.
     os << "0\n";
   else
diff --git a/src/ov-fcn-inline.h b/src/ov-fcn-inline.h
--- a/src/ov-fcn-inline.h
+++ b/src/ov-fcn-inline.h
@@ -60,18 +60,17 @@ public:
   octave_fcn_inline *fcn_inline_value (bool = false) { return this; }
 
   std::string fcn_text (void) const { return iftext; }
 
   string_vector fcn_arg_names (void) const { return ifargs; }
 
   octave_value convert_to_str_internal (bool, bool, char) const;
 
-  bool save_ascii (std::ostream& os, bool& infnan_warned,
-		   int strip_nan_and_inf);
+  bool save_ascii (std::ostream& os, bool& infnan_warned);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
diff --git a/src/ov-list.cc b/src/ov-list.cc
--- a/src/ov-list.cc
+++ b/src/ov-list.cc
@@ -533,32 +533,31 @@ is equivalent to @code{append (@var{list
     }
   else
     print_usage ();
 
   return retval;
 }
 
 bool 
-octave_list::save_ascii (std::ostream& os, bool& infnan_warned, 
-			 int strip_nan_and_inf)
+octave_list::save_ascii (std::ostream& os, bool& infnan_warned)
 {
   octave_value_list lst = list_value ();
   os << "# length: " << lst.length () << "\n";
 
   for (int i = 0; i < lst.length (); ++i)
     {
       // should we use lst.name_tags () to label the elements?
 
       std::ostringstream buf;
       buf << "_" << i;
       std::string s = buf.str ();
 
-      bool b = save_ascii_data (os, lst (i), s.c_str (), infnan_warned, 
-				strip_nan_and_inf, 0, 0);
+      bool b = save_ascii_data (os, lst (i), s.c_str (), infnan_warned,
+				false, 0);
       
       if (! b)
 	return false;
     }
 
   return true;
 }
 
diff --git a/src/ov-list.h b/src/ov-list.h
--- a/src/ov-list.h
+++ b/src/ov-list.h
@@ -94,18 +94,17 @@ public:
   octave_value_list list_value (void) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool print_name_tag (std::ostream& os, const std::string& name) const;
 
-  bool save_ascii (std::ostream& os, bool& infnan_warned,
-		   int strip_nan_and_inf);
+  bool save_ascii (std::ostream& os, bool& infnan_warned);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -280,18 +280,17 @@ skip_comments (std::istream& is)
 	while (is.get (c) && c != '\n')
 	  ; // Skip to beginning of next line, ignoring everything.
       else
 	break;
     }
 }
 
 bool 
-octave_range::save_ascii (std::ostream& os, bool& /* infnan_warned */,
-			  int /* strip_nan_and_inf */)
+octave_range::save_ascii (std::ostream& os, bool& /* infnan_warned */)
 {
   Range r = range_value ();
   double base = r.base ();
   double limit = r.limit ();
   double inc = r.inc ();
 
   os << "# base, limit, increment\n";
   octave_write_double (os, base);
diff --git a/src/ov-range.h b/src/ov-range.h
--- a/src/ov-range.h
+++ b/src/ov-range.h
@@ -181,18 +181,17 @@ public:
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool print_name_tag (std::ostream& os, const std::string& name) const;
 
-  bool save_ascii (std::ostream& os, bool& infnan_warned,
-		   int strip_nan_and_inf);
+  bool save_ascii (std::ostream& os, bool& infnan_warned);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -250,31 +250,25 @@ octave_matrix::convert_to_str_internal (
     }
 
   retval = octave_value (chm, true, type);
 
   return retval;
 }
 
 bool 
-octave_matrix::save_ascii (std::ostream& os, bool& infnan_warned, 
-			   int strip_nan_and_inf)
+octave_matrix::save_ascii (std::ostream& os, bool& infnan_warned)
 {
   dim_vector d = dims ();
+
   if (d.length () > 2)
     {
       NDArray tmp = array_value ();
 
-      if (strip_nan_and_inf)
-	{
-	  warning ("save: Can not strip Inf or NaN values");
-	  warning ("save: Inf or NaN values may not be reloadable");
-	  infnan_warned = true;
-	}
-      else if (! infnan_warned && tmp.any_element_is_inf_or_nan ())
+      if (! infnan_warned && tmp.any_element_is_inf_or_nan ())
 	{
 	  warning ("save: Inf or NaN values may not be reloadable");
 	  infnan_warned = true;
 	}
 
       os << "# ndims: " << d.length () << "\n";
 
       for (int i=0; i < d.length (); i++)
@@ -284,19 +278,17 @@ octave_matrix::save_ascii (std::ostream&
     }
   else
     {
       // Keep this case, rather than use generic code above for backward 
       // compatiability. Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
 	 << "# columns: " << columns () << "\n";
 
-      Matrix tmp = matrix_value ();
-
-      tmp.save_ascii (os, infnan_warned, strip_nan_and_inf);
+      os << matrix_value ();
     }
 
   return true;
 }
 
 bool 
 octave_matrix::load_ascii (std::istream& is)
 {
diff --git a/src/ov-re-mat.h b/src/ov-re-mat.h
--- a/src/ov-re-mat.h
+++ b/src/ov-re-mat.h
@@ -150,18 +150,17 @@ public:
   void increment (void) { matrix += 1.0; }
 
   void decrement (void) { matrix -= 1.0; }
 
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  bool save_ascii (std::ostream& os, bool& infnan_warned,
-		   int strip_nan_and_inf);
+  bool save_ascii (std::ostream& os, bool& infnan_warned);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
diff --git a/src/ov-scalar.cc b/src/ov-scalar.cc
--- a/src/ov-scalar.cc
+++ b/src/ov-scalar.cc
@@ -151,46 +151,29 @@ octave_scalar::convert_to_str_internal (
 
       retval = octave_value (std::string (1, static_cast<char> (ival)), type);
     }
 
   return retval;
 }
 
 bool 
-octave_scalar::save_ascii (std::ostream& os, bool& infnan_warned, 
-			   int strip_nan_and_inf)
+octave_scalar::save_ascii (std::ostream& os, bool& infnan_warned)
 {
   double d = double_value ();
 
-  if (strip_nan_and_inf)
+  if (! infnan_warned && (xisnan (d) || xisinf (d)))
     {
-      if (xisnan (d))
-	{
-	  error ("only value to plot is NaN");
-	  return false;
-	}
-      else
-	{
-	  d = xisinf (d) ? (d > 0 ? OCT_RBV : -OCT_RBV) : d;
-	  octave_write_double (os, d);
-	  os << "\n";
-	}
+      warning ("save: Inf or NaN values may not be reloadable");
+      infnan_warned = true;
     }
-  else
-    {
-      if (! infnan_warned && (xisnan (d) || xisinf (d)))
-	{
-	  warning ("save: Inf or NaN values may not be reloadable");
-	  infnan_warned = true;
-	}
 
-      octave_write_double (os, d);
-      os << "\n";
-    }
+  octave_write_double (os, d);
+
+  os << "\n";
 
   return true;
 }
 
 bool 
 octave_scalar::load_ascii (std::istream& is)
 {
   scalar = octave_read_double (is);
diff --git a/src/ov-scalar.h b/src/ov-scalar.h
--- a/src/ov-scalar.h
+++ b/src/ov-scalar.h
@@ -181,18 +181,17 @@ public:
   streamoff_array streamoff_array_value (void) const;
 
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
   void increment (void) { ++scalar; }
 
   void decrement (void) { --scalar; }
 
-  bool save_ascii (std::ostream& os, bool& infnan_warned,
-		   int strip_nan_and_inf);
+  bool save_ascii (std::ostream& os, bool& infnan_warned);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
diff --git a/src/ov-str-mat.cc b/src/ov-str-mat.cc
--- a/src/ov-str-mat.cc
+++ b/src/ov-str-mat.cc
@@ -264,19 +264,17 @@ octave_char_matrix_str::string_value (bo
 void
 octave_char_matrix_str::print_raw (std::ostream& os, bool pr_as_read_syntax) const
 {
   octave_print_internal (os, matrix, pr_as_read_syntax,
 			 current_print_indent_level (), true);
 }
 
 bool 
-octave_char_matrix_str::save_ascii (std::ostream& os,
-				    bool& /* infnan_warned */, 
-				    int /* strip_nan_and_inf */)
+octave_char_matrix_str::save_ascii (std::ostream& os, bool& /* infnan_warned */)
 {
   dim_vector d = dims ();
   if (d.length () > 2)
     {
       charNDArray tmp = char_array_value ();
       os << "# ndims: " << d.length () << "\n";
       for (int i=0; i < d.length (); i++)
 	os << " " << d (i);
diff --git a/src/ov-str-mat.h b/src/ov-str-mat.h
--- a/src/ov-str-mat.h
+++ b/src/ov-str-mat.h
@@ -124,18 +124,17 @@ public:
   string_vector all_strings (bool pad = false) const;
 
   std::string string_value (bool force = false) const;
 
   bool print_as_scalar (void) const { return (rows () <= 1); }
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  bool save_ascii (std::ostream& os, bool& infnan_warned,
-		   int strip_nan_and_inf);
+  bool save_ascii (std::ostream& os, bool& infnan_warned);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -1011,29 +1011,27 @@ named fields.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 bool
-octave_struct::save_ascii (std::ostream& os, bool& infnan_warned, 
-			   int strip_nan_and_inf)
+octave_struct::save_ascii (std::ostream& os, bool& infnan_warned)
 {
   Octave_map m = map_value ();
   os << "# length: " << m.length () << "\n";
 
   Octave_map::iterator i = m.begin ();
   while (i != m.end ())
     {
       octave_value val = map.contents (i);
 
-      bool b = save_ascii_data (os, val, m.key (i), infnan_warned, 
-				strip_nan_and_inf, 0, 0);
+      bool b = save_ascii_data (os, val, m.key (i), infnan_warned, false, 0);
       
       if (! b)
 	return os;
 
       i++;
     }
 
   return true;
diff --git a/src/ov-struct.h b/src/ov-struct.h
--- a/src/ov-struct.h
+++ b/src/ov-struct.h
@@ -112,18 +112,17 @@ public:
   string_vector map_keys (void) const { return map.keys (); }
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool print_name_tag (std::ostream& os, const std::string& name) const;
 
-  bool save_ascii (std::ostream& os, bool& infnan_warned,
-		   int strip_nan_and_inf);
+  bool save_ascii (std::ostream& os, bool& infnan_warned);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -773,19 +773,18 @@ public:
 				 const octave_value& b,
 				 const Array<int>& ra_idx);
 
   const octave_base_value& get_rep (void) const { return *rep; }
 
   void print_info (std::ostream& os,
 			   const std::string& prefix = std::string ()) const;
 
-  bool save_ascii (std::ostream& os, bool& infnan_warned,
-		   int strip_nan_and_inf) 
-    { return rep->save_ascii (os, infnan_warned, strip_nan_and_inf); }
+  bool save_ascii (std::ostream& os, bool& infnan_warned)
+    { return rep->save_ascii (os, infnan_warned); }
 
   bool load_ascii (std::istream& is)
     { return rep->load_ascii (is); }
 
   bool save_binary (std::ostream& os, bool& save_as_floats)
     { return rep->save_binary (os, save_as_floats); }
 
   bool load_binary (std::istream& is, bool swap,
