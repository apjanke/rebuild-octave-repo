# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1227024871 18000
#      Tue Nov 18 11:14:31 2008 -0500
# Node ID 9238637cb81c1edb10364fb6b9083983961dfee6
# Parent  34fde4755a0f5d015aa185790064a726b106eb86
style fixes

diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -1972,18 +1972,18 @@ typedef int sig_atomic_t;
 
 #ifdef USE_64_BIT_IDX_T
 #define SIZEOF_OCTAVE_IDX_TYPE 8
 #else
 #define SIZEOF_OCTAVE_IDX_TYPE SIZEOF_INT
 #endif
 
 // To be able to use long doubles for 64-bit mixed arithmetics, we need them at
-// least 80 bits wide and we need roundl declared in math.h
-// FIXME: Maybe substitute this by a more precise check in the future.
+// least 80 bits wide and we need roundl declared in math.h.
+// FIXME -- maybe substitute this by a more precise check in the future.
 #if (SIZEOF_LONG_DOUBLE >= 10) && defined (HAVE_ROUNDL)
 #define OCTAVE_INT_USE_LONG_DOUBLE
 #endif
 
 #define OCTAVE_EMPTY_CPP_ARG
 
 #include "oct-dlldefs.h"
 #include "oct-types.h"
diff --git a/liboctave/Array-util.cc b/liboctave/Array-util.cc
--- a/liboctave/Array-util.cc
+++ b/liboctave/Array-util.cc
@@ -24,17 +24,18 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "Array-util.h"
 #include "dim-vector.h"
 #include "lo-error.h"
 
 bool
-index_in_bounds (const Array<octave_idx_type>& ra_idx, const dim_vector& dimensions)
+index_in_bounds (const Array<octave_idx_type>& ra_idx,
+		 const dim_vector& dimensions)
 {
   bool retval = true;
 
   int n = ra_idx.length ();
 
   if (n == dimensions.length ())
     {
       for (int i = 0; i < n; i++)
@@ -334,17 +335,18 @@ all_ones (const Array<octave_idx_type>& 
 	  break;
 	}
     }
 
   return retval;
 }
 
 Array<octave_idx_type>
-get_elt_idx (const Array<idx_vector>& ra_idx, const Array<octave_idx_type>& result_idx)
+get_elt_idx (const Array<idx_vector>& ra_idx,
+	     const Array<octave_idx_type>& result_idx)
 {
   octave_idx_type n = ra_idx.length ();
 
   Array<octave_idx_type> retval (n);
 
   for (octave_idx_type i = 0; i < n; i++)
     retval(i) = ra_idx(i).elem (result_idx(i));
 
@@ -370,17 +372,18 @@ get_ra_idx (octave_idx_type idx, const d
 
   // FIXME -- the solution using increment_index is not
   // efficient.
 
 #if 0
   octave_idx_type var = 1;
   for (int i = 0; i < n_dims; i++)
     {
-      std::cout << "idx: " << idx << ", var: " << var << ", dims(" << i << "): " << dims(i) <<"\n";
+      std::cout << "idx: " << idx << ", var: " << var
+		<< ", dims(" << i << "): " << dims(i) <<"\n";
       retval(i) = ((int)floor(((idx) / (double)var))) % dims(i);
       idx -= var * retval(i);
       var = dims(i);
     }
 #endif
 
   return retval;
 }
@@ -392,27 +395,27 @@ dim_vector zero_dims_inquire (const Arra
   dim_vector rdv;
   rdv.resize (ial);
   bool *scalar = new bool[ial], *colon = new bool[ial];
   // Mark scalars and colons, count non-scalar indices.
   int nonsc = 0; 
   bool all_colons = true;
   for (int i = 0; i < ial; i++)
     {
-      // FIXME: should we check for length() instead?
+      // FIXME -- should we check for length() instead?
       scalar[i] = ia(i).is_scalar ();
       colon[i] = ia(i).is_colon ();
       if (! scalar[i]) nonsc++;
       if (! colon[i]) rdv(i) = ia(i).extent (0);
       all_colons = all_colons && colon[i];
     }
 
   bool match = false;
-  // If the number of nonscalar indices matches the dimensionality of RHS,
-  // we try an exact match, inquiring even singleton dimensions.
+  // If the number of nonscalar indices matches the dimensionality of
+  // RHS, we try an exact match, inquiring even singleton dimensions.
   if (all_colons)
     {
       rdv = rhdv;
       rdv.resize(ial, 1);
     }
   else if (nonsc == rhdvl)
     {
       for (int i = 0, j = 0; i < ial; i++)
diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -744,41 +744,47 @@ Array<T>::index (const idx_vector& i) co
       retval.rep = rep;
     }
   else if (i.extent (n) != n)
     {
       gripe_index_out_of_range ();
     }
   else
     {
-      // FIXME: This is the only place where orig_dimensions are used.
+      // FIXME -- this is the only place where orig_dimensions are used.
       dim_vector rd = i.orig_dimensions ();
       octave_idx_type il = i.length (n);
 
-      // FIXME: This is for Matlab compatibility. Matlab 2007 given `b = ones(3,1)'
+      // FIXME -- this is for Matlab compatibility.  Matlab 2007 given
+      //
+      //   b = ones(3,1)
+      //
       // yields the following:
-      // b(zeros(0,0)) gives []
-      // b(zeros(1,0)) gives zeros(0,1)
-      // b(zeros(0,1)) gives zeros(0,1)
-      // b(zeros(0,m)) gives zeros(0,m)
-      // b(zeros(m,0)) gives zeros(m,0)
-      // b(1:2) gives ones(2,1)
-      // b(ones(2)) gives ones(2) etc.
+      //
+      //   b(zeros(0,0)) gives []
+      //   b(zeros(1,0)) gives zeros(0,1)
+      //   b(zeros(0,1)) gives zeros(0,1)
+      //   b(zeros(0,m)) gives zeros(0,m)
+      //   b(zeros(m,0)) gives zeros(m,0)
+      //   b(1:2) gives ones(2,1)
+      //   b(ones(2)) gives ones(2) etc.
+      //
       // As you can see, the behaviour is weird, but the tests end up pretty
-      // simple. Nah, I don't want to suggest that this is ad hoc :) Neither do
-      // I want to say that Matlab is a lousy piece of s...oftware.
+      // simple.  Nah, I don't want to suggest that this is ad hoc :)
+
       if (ndims () == 2 && n != 1)
         {
           if (columns () == 1 && rd(0) == 1)
             rd = dim_vector (il, 1);
           else if (rows () == 1 && rd(1) == 1)
             rd = dim_vector (1, il);
         }
 
-      // Don't use resize here to avoid useless initialization for POD types.
+      // Don't use resize here to avoid useless initialization for POD
+      // types.
       retval = Array<T> (rd);
 
       if (il != 0)
         i.index (data (), n, retval.fortran_vec ());
     }
 
   return retval;
 }
@@ -882,52 +888,53 @@ Array<T>::index (const Array<idx_vector>
           // Do it.
           rh.index (data (), retval.fortran_vec ());
         }
     }
 
   return retval;
 }
 
-// FIXME: the following is a common error message to resize, regardless of whether it's
-// called from assign or elsewhere. It seems OK to me, but eventually the gripe can be
-// specialized. Anyway, propagating various error messages into procedure is, IMHO, a
-// nonsense. If anything, we should change error handling here (and throughout liboctave)
-// to allow custom handling of errors
+// FIXME -- the following is a common error message to resize,
+// regardless of whether it's called from assign or elsewhere.  It
+// seems OK to me, but eventually the gripe can be specialized.
+// Anyway, propagating various error messages into procedure is, IMHO,
+// a nonsense.  If anything, we should change error handling here (and
+// throughout liboctave) to allow custom handling of errors
 static void gripe_invalid_resize (void)
 {
   (*current_liboctave_error_handler)
     ("resize: Invalid resizing operation or ambiguous assignment to an out-of-bounds array element.");
 }
 
-// The default fill value. Override if you want a different one.
+// The default fill value.  Override if you want a different one.
 
 template <class T>
 T Array<T>::resize_fill_value ()
 {
   return T ();
 }
 
-// Yes, we could do resize using index & assign.  However, that would possibly
-// involve a lot more memory traffic than we actually need.
+// Yes, we could do resize using index & assign.  However, that would
+// possibly involve a lot more memory traffic than we actually need.
 
 template <class T>
 void
 Array<T>::resize_fill (octave_idx_type n, const T& rfv)
 {
   if (n >= 0 && ndims () == 2)
     {
       dim_vector dv;
-      // This is driven by Matlab's behaviour of giving a *row* vector on
-      // some out-of-bounds assignments. Specifically, matlab allows a(i) with
-      // out-of-bouds i when a is either of 0x0, 1x0, 1x1, 0xN, and gives
-      // a row vector in all cases (yes, even the last one, search me why).
-      // Giving a column vector would make much more sense (given the way
-      // trailing singleton dims are treated), but hey, Matlab is not here to
-      // make sense, it's here to make money ;)
+      // This is driven by Matlab's behaviour of giving a *row* vector
+      // on some out-of-bounds assignments.  Specifically, Matlab
+      // allows a(i) with out-of-bouds i when a is either of 0x0, 1x0,
+      // 1x1, 0xN, and gives a row vector in all cases (yes, even the
+      // last one, search me why).  Giving a column vector would make
+      // much more sense (given the way trailing singleton dims are
+      // treated).
       bool invalid = false;
       if (rows () == 0 || rows () == 1)
         dv = dim_vector (1, n);          
       else if (columns () == 1)
         dv = dim_vector (n, 1);
       else
          invalid = true;
         
@@ -1139,30 +1146,32 @@ Array<T>::assign (const idx_vector& i, c
                   const Array<T>& rhs, const T& rfv)
 {
   // Get RHS extents, discarding singletons.
   dim_vector rhdv = rhs.dims (); 
   // Get LHS extents, allowing Fortran indexing in the second dim.
   dim_vector dv = dimensions.redim (2);
   // Check for out-of-bounds and form resizing dimensions.
   dim_vector rdv; 
-  // In the special when all dimensions are zero, colons are allowed to inquire
-  // the shape of RHS. The rules are more obscure, so we solve that elsewhere.
+  // In the special when all dimensions are zero, colons are allowed
+  // to inquire the shape of RHS.  The rules are more obscure, so we
+  // solve that elsewhere.
   if (dv.all_zero ())
     rdv = zero_dims_inquire (i, j, rhdv);
   else
     {
       rdv(0) = i.extent (dv(0));
       rdv(1) = j.extent (dv(1));
     }
 
   bool isfill = rhs.numel () == 1;
   octave_idx_type il = i.length (rdv(0)), jl = j.length (rdv(1));
   rhdv.chop_all_singletons ();
-  bool match = isfill || (rhdv.length () == 2 && il == rhdv(0) && jl == rhdv(1));
+  bool match = (isfill
+		|| (rhdv.length () == 2 && il == rhdv(0) && jl == rhdv(1)));
   match = match || (il == 1 && jl == rhdv(0) && rhdv(1) == 1);
 
   if (match)
     {
       // Resize if requested.
       if (rdv != dv)
         {
           resize (rdv, rfv);
@@ -1237,19 +1246,19 @@ Array<T>::assign (const Array<idx_vector
       dim_vector rhdv = rhs.dims ();
 
       // Get LHS extents, allowing Fortran indexing in the second dim.
       dim_vector dv = dimensions.redim (ial);
       
       // Get the extents forced by indexing. 
       dim_vector rdv;
 
-      // In the special when all dimensions are zero, colons are allowed to
-      // inquire the shape of RHS. The rules are more obscure, so we solve that
-      // elsewhere.
+      // In the special when all dimensions are zero, colons are
+      // allowed to inquire the shape of RHS.  The rules are more
+      // obscure, so we solve that elsewhere.
       if (dv.all_zero ())
         rdv = zero_dims_inquire (ia, rhdv);
       else
         {
           rdv.resize (ial);
           for (int i = 0; i < ial; i++)
             rdv(i) = ia(i).extent (dv(i));
         }
@@ -1686,17 +1695,17 @@ Array<T>::transpose (void) const
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = 0; i < nr; i++)
 	  result.xelem (j, i) = xelem (i, j);
 
       return result;
     }
   else
     {
-      // Fast transpose for vectors and empty matrices
+      // Fast transpose for vectors and empty matrices.
       return Array<T> (*this, dim_vector (nc, nr));
     }
 }
 
 template <class T>
 static T
 no_op_fcn (const T& x)
 {
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -453,42 +453,45 @@ public:
   // Rationale: 
   // These use the default fill value rather than leaving memory uninitialized.
   // Resizing without fill leaves the resulting array in a rather weird state,
   // where part of the data is initialized an part isn't.
 
   void resize (octave_idx_type n)
     { resize_fill (n, resize_fill_value ()); }
 
-  // FIXME: This method cannot be defined here because it would clash with
+  // FIXME -- this method cannot be defined here because it would
+  // clash with
+  //
   //   void resize (octave_idx_type, const T&)
-  // (these become undistinguishable when T = octave_idx_type). 
-  // In the future, I think the resize (.., const T& rfv) overloads should go away
-  // in favor of using resize_fill.
+  //
+  // (these become indistinguishable when T = octave_idx_type).
+  // In the future, I think the resize (.., const T& rfv) overloads
+  // should go away in favor of using resize_fill.
 
   // void resize (octave_idx_type nr, octave_idx_type nc)
   //  { resize_fill (nr, nc, resize_fill_value ()); }
 
   void resize (dim_vector dv)
     { resize_fill (dv, resize_fill_value ()); }
 
-  // FIXME: these are here for backward compatibility. They should go away in favor
-  // of using resize_fill directly.
+  // FIXME -- these are here for backward compatibility. They should
+  // go away in favor of using resize_fill directly.
   void resize (octave_idx_type n, const T& rfv)
     { resize_fill (n, static_cast<T> (rfv)); }
 
   void resize (octave_idx_type nr, octave_idx_type nc, const T& rfv)
     { resize_fill (nr, nc, rfv); }
 
   void resize (dim_vector dv, const T& rfv)
     { resize_fill (dv, rfv); }
 
   // Indexing with possible resizing and fill
-  // FIXME: This is really a corner case, that should better be handled
-  // directly in liboctinterp.
+  // FIXME -- this is really a corner case, that should better be
+  // handled directly in liboctinterp.
 
   Array<T> index (const idx_vector& i, bool resize_ok,
                   const T& rfv = resize_fill_value ()) const;
 
   Array<T> index (const idx_vector& i, const idx_vector& j, 
                   bool resize_ok, const T& rfv = resize_fill_value ()) const;
 
   Array<T> index (const Array<idx_vector>& ia,
@@ -511,17 +514,17 @@ public:
   void delete_elements (const idx_vector& i);
 
   // A(:,...,I,...,:) = [] (>= 2 subscripts, one of them is non-colon)
   void delete_elements (int dim, const idx_vector& i);
 
   // Dispatcher to the above two.
   void delete_elements (const Array<idx_vector>& ia);
 
-  // FIXME: are these required? What exactly are they supposed to do?.
+  // FIXME -- are these required? What exactly are they supposed to do?.
 
   Array<T>& insert (const Array<T>& a, octave_idx_type r, octave_idx_type c);
   Array<T>& insert2 (const Array<T>& a, octave_idx_type r, octave_idx_type c);
   Array<T>& insertN (const Array<T>& a, octave_idx_type r, octave_idx_type c);
 
   Array<T>& insert (const Array<T>& a, const Array<octave_idx_type>& idx);
 
   void print_info (std::ostream& os, const std::string& prefix) const;
@@ -556,20 +559,21 @@ public:
 
     return result;
   }
 };
 
 #define INSTANTIATE_ARRAY(T, API) \
   template class API Array<T>
 
-// FIXME: These are here for compatibility. In current implementation, only
-// homogeneous array assignments are actually instantiated. I think heterogeneous
-// indexed assignments are rare enough to be implemented via conversion first.
-// This decision may still be revised, that's why these macros stay here.
+// FIXME -- these are here for compatibility.  In the current
+// implementation, only homogeneous array assignments are actually
+// instantiated.  I think heterogeneous indexed assignments are rare
+// enough to be implemented via conversion first.  This decision may
+// still be revised, that's why these macros stay here.
 #define INSTANTIATE_ARRAY_AND_ASSIGN(T, API) \
   INSTANTIATE_ARRAY(T, API)
 
 #define INSTANTIATE_ARRAY_ASSIGN(LT, RT, API)
   // do nothing
 
 #define INSTANTIATE_ARRAY_SORT(T) \
   template class octave_sort<T>; \
diff --git a/liboctave/idx-vector.cc b/liboctave/idx-vector.cc
--- a/liboctave/idx-vector.cc
+++ b/liboctave/idx-vector.cc
@@ -32,29 +32,32 @@ along with Octave; see the file COPYING.
 
 #include "idx-vector.h"
 #include "Array.h"
 #include "Range.h"
 
 #include "lo-error.h"
 #include "lo-mappers.h"
 
-static void gripe_invalid_index ()
+static void
+gripe_invalid_index (void)
 {
   (*current_liboctave_error_handler)
     ("subscript indices must be either positive integers or logicals.");
 }
 
-static void gripe_invalid_range ()
+static void
+gripe_invalid_range (void)
 {
   (*current_liboctave_error_handler)
     ("invalid range used as index.");
 }
 
-static void gripe_index_out_of_range ()
+static void
+gripe_index_out_of_range (void)
 {
   (*current_liboctave_error_handler)
     ("internal error: idx_vector index out of range.");
 }
 
 idx_vector::idx_colon_rep::idx_colon_rep (char c)
 {
   if (c != ':')
@@ -94,17 +97,18 @@ idx_vector::idx_range_rep::idx_range_rep
     }
   else if (start < 0)
     {
       gripe_invalid_index ();
       err = true;
     }
 }
 
-static void gripe_non_int_range ()
+static void
+gripe_non_int_range (void)
 {
   (*current_liboctave_error_handler)
     ("If a range is used as subscript, all elements are expected to be integers.");
 }
 
 idx_vector::idx_range_rep::idx_range_rep (const Range& r)
   : start (0), len (r.nelem ()), step (1)
 {
@@ -453,18 +457,19 @@ bool idx_vector::maybe_reduce (octave_id
       break;
     default:
       break;
     }
 
   return reduced;
 }
 
-bool idx_vector::is_cont_range (octave_idx_type n,
-                                octave_idx_type& l, octave_idx_type& u) const
+bool
+idx_vector::is_cont_range (octave_idx_type n,
+			   octave_idx_type& l, octave_idx_type& u) const
 {
   bool res = false;
   switch (rep->idx_class ())
     {
     case class_colon:
       l = 0; u = n;
       res = true;
       break;
diff --git a/liboctave/idx-vector.h b/liboctave/idx-vector.h
--- a/liboctave/idx-vector.h
+++ b/liboctave/idx-vector.h
@@ -74,27 +74,27 @@ private:
 
     // Length of the index vector.
     virtual octave_idx_type length (octave_idx_type n) const = 0;
 
     // The maximum index + 1. The actual dimension is passed in.
     virtual octave_idx_type extent (octave_idx_type n) const = 0;
 
     // Index class.
-    virtual idx_class_type idx_class () const { return class_invalid; }
+    virtual idx_class_type idx_class (void) const { return class_invalid; }
 
     // Sorts, maybe uniqifies, and returns a clone object pointer.
     virtual idx_base_rep *sort_uniq_clone (bool uniq = false) = 0;
 
     // Checks whether the index is colon or a range equivalent to colon.
     virtual bool is_colon_equiv (octave_idx_type) const
       { return false; }
 
     // The original dimensions of this object (used when subscribing by matrices).
-    virtual dim_vector orig_dimensions () const
+    virtual dim_vector orig_dimensions (void) const
       { return dim_vector (); }
 
     // i/o
     virtual std::ostream& print (std::ostream& os) const = 0;
 
     int count;
 
     bool err;
@@ -119,17 +119,17 @@ private:
     octave_idx_type checkelem (octave_idx_type i) const;
 
     octave_idx_type length (octave_idx_type n) const
       { return n; }
 
     octave_idx_type extent (octave_idx_type n) const
       { return n; }
 
-    idx_class_type idx_class () const { return class_colon; }
+    idx_class_type idx_class (void) const { return class_colon; }
 
     idx_base_rep *sort_uniq_clone (bool = false) 
       { count++; return this; }
 
     bool is_colon_equiv (octave_idx_type) const
       { return true; }
 
     std::ostream& print (std::ostream& os) const;
@@ -166,29 +166,29 @@ private:
     octave_idx_type checkelem (octave_idx_type i) const;
 
     octave_idx_type length (octave_idx_type) const
       { return len; }
 
     octave_idx_type extent (octave_idx_type n) const
       { return len ? std::max (n, (start + 1 + (step < 0 ? 0 : step * (len - 1)))) : n; }
 
-    idx_class_type idx_class () const { return class_range; }
+    idx_class_type idx_class (void) const { return class_range; }
 
     idx_base_rep *sort_uniq_clone (bool uniq = false);
 
     bool is_colon_equiv (octave_idx_type n) const
       { return start == 0 && step == 1 && len == n; }
 
-    dim_vector orig_dimensions () const
+    dim_vector orig_dimensions (void) const
       { return dim_vector (1, len); }
 
-    octave_idx_type get_start () const { return start; }
+    octave_idx_type get_start (void) const { return start; }
 
-    octave_idx_type get_step () const { return step; }
+    octave_idx_type get_step (void) const { return step; }
 
     std::ostream& print (std::ostream& os) const;
 
   private:
 
     // No copying!
     idx_range_rep (const idx_range_rep& idx);
 
@@ -218,28 +218,28 @@ private:
     octave_idx_type checkelem (octave_idx_type i) const;
 
     octave_idx_type length (octave_idx_type) const
       { return 1; }
 
     octave_idx_type extent (octave_idx_type n) const
       { return std::max (n, data + 1); }
 
-    idx_class_type idx_class () const { return class_scalar; }
+    idx_class_type idx_class (void) const { return class_scalar; }
 
     idx_base_rep *sort_uniq_clone (bool = false)
       { count++; return this; }
 
     bool is_colon_equiv (octave_idx_type n) const
       { return n == 1 && data == 0; }
 
-    dim_vector orig_dimensions () const
+    dim_vector orig_dimensions (void) const
       { return dim_vector (1, 1); }
 
-    octave_idx_type get_data () const { return data; }
+    octave_idx_type get_data (void) const { return data; }
 
     std::ostream& print (std::ostream& os) const;
 
   private:
 
     // No copying!
     idx_scalar_rep (const idx_scalar_rep& idx);
 
@@ -278,24 +278,24 @@ private:
     octave_idx_type checkelem (octave_idx_type i) const;
 
     octave_idx_type length (octave_idx_type) const
       { return len; }
 
     octave_idx_type extent (octave_idx_type n) const
       { return std::max (n, ext); }
 
-    idx_class_type idx_class () const { return class_vector; }
+    idx_class_type idx_class (void) const { return class_vector; }
 
     idx_base_rep *sort_uniq_clone (bool uniq = false);
 
-    dim_vector orig_dimensions () const
+    dim_vector orig_dimensions (void) const
       { return orig_dims; }
 
-    const octave_idx_type *get_data () const { return data; }
+    const octave_idx_type *get_data (void) const { return data; }
 
     std::ostream& print (std::ostream& os) const;
 
   private:
 
     // No copying!
     idx_vector_rep (const idx_vector_rep& idx);
 
@@ -312,24 +312,24 @@ private:
 
     dim_vector orig_dims;
   };
 
 
   idx_vector (idx_base_rep *r) : rep (r) { }
 
   // The shared empty vector representation (for fast default constructor)
-  static idx_vector_rep *nil_rep ()
+  static idx_vector_rep *nil_rep (void)
     {
       static idx_vector_rep ivr;
       return &ivr;
     }
 
   // The shared empty vector representation with the error flag set.
-  static idx_vector_rep *err_rep ()
+  static idx_vector_rep *err_rep (void)
     {
       static idx_vector_rep ivr;
       ivr.err = true;
       return &ivr;
     }
 
   // If there was an error in constructing the rep, replace it with empty vector
   // for safety.
@@ -436,37 +436,37 @@ public:
     {
 #if defined (BOUNDS_CHECKING)
       return rep->checkelem (n); 
 #else
       return rep->xelem (n);
 #endif
     }
 
-  operator bool () const
+  operator bool (void) const
     { return ! rep->err; }
 
   bool is_colon (void) const 
     { return rep->idx_class () == class_colon; }
 
   bool is_scalar (void) const 
     { return rep->idx_class () == class_scalar; }
 
   bool is_colon_equiv (octave_idx_type n) const
     { return rep->is_colon_equiv (n); }
 
   idx_vector sorted (bool uniq = false) const
     { return idx_vector (rep->sort_uniq_clone (uniq)); }
 
   dim_vector orig_dimensions (void) const { return rep->orig_dimensions (); }
 
-  octave_idx_type orig_rows () const
+  octave_idx_type orig_rows (void) const
     { return orig_dimensions () (0); }
 
-  octave_idx_type orig_columns () const
+  octave_idx_type orig_columns (void) const
     { return orig_dimensions () (1); }
 
   int orig_empty (void) const
     { return (! is_colon () && orig_dimensions().any_zero ()); }
 
   // i/o
 
   std::ostream& print (std::ostream& os) const { return rep->print (os); }
@@ -714,33 +714,34 @@ public:
                      octave_idx_type nj);
 
   bool is_cont_range (octave_idx_type n,
                       octave_idx_type& l, octave_idx_type& u) const;
 
   idx_vector
   complement (octave_idx_type n) const;
 
-  // FIXME: These are here for compatibility. They should be removed when no
-  // longer in use.
+  // FIXME -- these are here for compatibility.  They should be removed
+  // when no longer in use.
 
   octave_idx_type elem (octave_idx_type n) const 
     { return (*this) (n); }
 
   bool is_colon_equiv (octave_idx_type n, int) const
     { return is_colon_equiv (n); }
 
-  octave_idx_type freeze (octave_idx_type z_len, const char *tag, bool resize_ok = false);
+  octave_idx_type
+  freeze (octave_idx_type z_len, const char *tag, bool resize_ok = false);
 
   void sort (bool uniq = false)
     { *this = sorted (uniq); }
 
-  octave_idx_type ones_count () const;
+  octave_idx_type ones_count (void) const;
 
-  octave_idx_type max () const { return extent (1) - 1; }
+  octave_idx_type max (void) const { return extent (1) - 1; }
   
 private:
 
   idx_base_rep *rep;
 
 };
 
 #endif
diff --git a/liboctave/oct-inttypes.cc b/liboctave/oct-inttypes.cc
--- a/liboctave/oct-inttypes.cc
+++ b/liboctave/oct-inttypes.cc
@@ -189,17 +189,17 @@ int64_t
 octave_int_arith_base<int64_t, true>::mul (int64_t x, int64_t y)
 { 
   // The signed case is far worse. The problem is that
   // even if neither integer fits into signed 32-bit range, the result may
   // still be OK. Uh oh.
   
   // Essentially, what we do is compute sign, multiply absolute values
   // (as above) and impose the sign.
-  // FIXME: Can we do something faster if we HAVE_FAST_INT_OPS?
+  // FIXME -- can we do something faster if we HAVE_FAST_INT_OPS?
 
   uint64_t usx = octave_int_abs (x), usy = octave_int_abs (y);
   bool positive = (x < 0) == (y < 0);
 
   // Get upper words
   uint64_t ux = usx >> 32, uy = usy >> 32;
   uint64_t res;
   if (ux)
diff --git a/liboctave/oct-inttypes.h b/liboctave/oct-inttypes.h
--- a/liboctave/oct-inttypes.h
+++ b/liboctave/oct-inttypes.h
@@ -40,19 +40,19 @@ inline long double xround (long double x
 #endif
 
 // Undefine min/max if needed (this may happen under Windows)
 #ifdef min
 #undef min
 #undef max
 #endif
 
-// FIXME: we define this by our own because some compilers, such as MSVC,
-// do not provide std::abs (int64_t) and std::abs (uint64_t). In the future,
-// it should go away in favor of std::abs.
+// FIXME -- we define this by our own because some compilers, such as
+// MSVC, do not provide std::abs (int64_t) and std::abs (uint64_t).  In
+// the future, it should go away in favor of std::abs.
 template <class T>
 inline T octave_int_abs (T x) { return x >= 0 ? x : -x; }
 
 // Query for an integer type of certain sizeof, and signedness.
 template<int qsize, bool qsigned>
 struct query_integer_type
 {
 public:
@@ -277,17 +277,17 @@ private:
   // Computes a real-valued threshold for a max/min check. 
   template <class S>
   static S 
   compute_threshold (S val, T orig_val)
     { 
       val = xround (val); // Fool optimizations (maybe redundant)
       // If val is even, but orig_val is odd, we're one unit off.
       if (orig_val % 2 && val / 2 == xround (val / 2))
-        // FIXME: is this always correct?
+        // FIXME -- is this always correct?
         val *= (static_cast<S>(1) - (std::numeric_limits<S>::epsilon () / 2)); 
       return val;
     }
   
 public:
   // Convert a real number (check NaN and non-int).
   template <class S>
   static T 
@@ -541,19 +541,19 @@ public:
 
   static T
   signum (T x) 
     { 
       // With modest optimizations, this will compile without a jump.
       return ((x > 0) ? 1 : 0) - signbit (x); 
     }
 
-  // FIXME: We do not have an authority what signed shifts should exactly do, so
-  // we define them the easy way. Note that Matlab does not define signed
-  // shifts.
+  // FIXME -- we do not have an authority what signed shifts should
+  // exactly do, so we define them the easy way. Note that Matlab does
+  // not define signed shifts.
 
   static T
   rshift (T x, int n) { return x >> n; }
 
   static T
   lshift (T x, int n) { return x << n; }
 
   // Minus has problems similar to abs.
@@ -709,18 +709,21 @@ public:
               T w = -octave_int_abs (x % y); // Can't overflow, but std::abs (x) can!
               if (w <= y - w) 
                 z -= 1 - (signbit (x) << 1);
             }
         }
       else
         {
           z = x / y;
-          // FIXME: this is a workaround due to MSVC's absence of std::abs (int64_t).
-          T w = octave_int_abs (x % y); // Can't overflow, but std::abs (x) can!
+          // FIXME -- this is a workaround due to MSVC's absence of
+          // std::abs (int64_t).  The call to octave_int_abs can't
+          // overflow, but std::abs (x) can!
+	  T w = octave_int_abs (x % y);
+
           if (w >= y - w) 
             z += 1 - (signbit (x) << 1);
         }
       return z;
     }
 
 };
 
@@ -879,17 +882,17 @@ private:
 
 // No mixed integer binary operations!
 
 template <class T>
 inline bool
 xisnan (const octave_int<T>&)
 { return false; }
 
-// FIXME: Can/should any of these be inline?
+// FIXME -- can/should any of these be inline?
 
 template <class T>
 extern OCTAVE_API octave_int<T>
 pow (const octave_int<T>&, const octave_int<T>&);
 
 template <class T>
 extern OCTAVE_API octave_int<T>
 pow (const double& a, const octave_int<T>& b);
diff --git a/src/Cell.h b/src/Cell.h
--- a/src/Cell.h
+++ b/src/Cell.h
@@ -84,27 +84,28 @@ public:
   Cell index (idx_vector& i, idx_vector& j, int resize_ok = 0,
 	      const octave_value& rfv = resize_fill_value ()) const
     { return Cell (ArrayN<octave_value>::index (i, j, resize_ok, rfv)); }
 
   Cell index (Array<idx_vector>& ra_idx, int resize_ok = 0,
 	      const octave_value& rfv = resize_fill_value ()) const
     { return Cell (ArrayN<octave_value>::index (ra_idx, resize_ok, rfv)); }
 
-  // FIXME: This seems necessary for octave_base_mat<Cell>::delete_elements
-  // to work, but I don't understand why.
+  // FIXME -- this seems necessary for
+  // octave_base_mat<Cell>::delete_elements to work, but I don't
+  // understand why.
   void delete_elements (const Array<idx_vector>& ia)
     { ArrayN<octave_value>::delete_elements (ia); }
 
   Cell& delete_elements (const octave_value_list& idx);
 
   Cell& assign (const octave_value_list& idx, const Cell& rhs,
 		const octave_value& fill_val = octave_value ());
 
-  // FIXME: This seems necessary for octave_base_mat<Cell>::assign
+  // FIXME -- this seems necessary for octave_base_mat<Cell>::assign
   // to work, but I don't understand why.
   void assign (const Array<idx_vector>& ia, const Array<octave_value>& rhs,
                const octave_value& fill_val = octave_value ())
     { ArrayN<octave_value>::assign (ia, rhs, fill_val); }
 
   Cell reshape (const dim_vector& new_dims) const
     { return ArrayN<octave_value>::reshape (new_dims); }
 
diff --git a/src/DLD-FUNCTIONS/__contourc__.cc b/src/DLD-FUNCTIONS/__contourc__.cc
--- a/src/DLD-FUNCTIONS/__contourc__.cc
+++ b/src/DLD-FUNCTIONS/__contourc__.cc
@@ -153,17 +153,18 @@ drawcn (const RowVector& X, const RowVec
 	{
 	  ct_x = px[pt[0]] + (px[pt[1]] - px[pt[0]])/(1 + tmp);
 	  ct_y = py[pt[0]] + (py[pt[1]] - py[pt[0]])/(1 + tmp);
 	}
 
       start_contour (lvl, ct_x, ct_y);
     }
 
-  // Find stop edge FIXME: control flow --> while.
+  // Find stop edge.
+  // FIXME -- perhaps this should use a while loop?
   for (unsigned int k = 1; k <= 4; k++)
     {
       if (start_edge == 0 || start_edge == 2)
         stop_edge = (start_edge + k) % 4;
       else
         stop_edge = (start_edge - k) % 4;
 
       if (static_cast<char> (1 << stop_edge) & id)
diff --git a/src/DLD-FUNCTIONS/amd.cc b/src/DLD-FUNCTIONS/amd.cc
--- a/src/DLD-FUNCTIONS/amd.cc
+++ b/src/DLD-FUNCTIONS/amd.cc
@@ -163,18 +163,18 @@ University of Florida (see @url{http://w
 	    }
 
 	  if (!error_state)
 	    {
 	      OCTAVE_LOCAL_BUFFER (octave_idx_type, P, n_col);
 	      Matrix xinfo (AMD_INFO, 1);
 	      double *Info = xinfo.fortran_vec ();
 
-	      // FIXME: How can we manage the memory allocation of amd in 
-	      // a cleaner manner? 
+	      // FIXME -- how can we manage the memory allocation of
+	      // amd in a cleaner manner? 
 	      amd_malloc = malloc;
 	      amd_free = free;
 	      amd_calloc = calloc;
 	      amd_realloc = realloc;
 	      amd_printf = printf;
 
 	      octave_idx_type result = AMD_NAME (_order) (n_col, cidx, ridx, P,
 							  Control, Info);
diff --git a/src/DLD-FUNCTIONS/fltk_backend.cc b/src/DLD-FUNCTIONS/fltk_backend.cc
--- a/src/DLD-FUNCTIONS/fltk_backend.cc
+++ b/src/DLD-FUNCTIONS/fltk_backend.cc
@@ -759,17 +759,17 @@ public:
       {
 	octave_value ov = go.get (caseless_str ("__plot_stream__"));
 	
 	if (! ov.is_empty ())
 	  {
 	    switch (id)
 	      {
 	      case base_properties::VISIBLE:
-		// FIXME: something to do here
+		// FIXME -- something to do here.
 		break;
 	      }
 	  }
       }
   }
 
   void redraw_figure (const graphics_object& go) const
   {
diff --git a/src/OPERATORS/op-range.cc b/src/OPERATORS/op-range.cc
--- a/src/OPERATORS/op-range.cc
+++ b/src/OPERATORS/op-range.cc
@@ -112,18 +112,19 @@ install_range_ops (void)
   INSTALL_CATOP (octave_complex, octave_range, cs_r);
   INSTALL_CATOP (octave_complex_matrix, octave_range, cm_r);
   INSTALL_CATOP (octave_bool, octave_range, b_r);
   INSTALL_CATOP (octave_bool_matrix, octave_range, bm_r);
   INSTALL_CATOP (octave_char_matrix, octave_range, chm_r);
 
   INSTALL_CONVOP (octave_range, octave_float_matrix, range_to_float_matrix);
 
-  // FIXME: this would be unneccessary if octave_base_value::numeric_assign always tried converting
-  // lhs before rhs.
+  // FIXME -- this would be unneccessary if
+  // octave_base_value::numeric_assign always tried converting lhs
+  // before rhs.
   
   INSTALL_ASSIGNCONV (octave_range, octave_null_matrix, octave_matrix);
   INSTALL_ASSIGNCONV (octave_range, octave_null_str, octave_matrix);
   INSTALL_ASSIGNCONV (octave_range, octave_null_sq_str, octave_matrix);
 
   // However, this should probably be here just in case we need it.
   
   INSTALL_WIDENOP (octave_range, octave_matrix, range_to_matrix);
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -871,17 +871,17 @@ location of the error. Typically @var{er
 		      tmp_msg[len - 1] = '\0';
 		      rethrow_error (id.c_str (), "%s\n", tmp_msg);
 		    }
 		}
 	      else
 		rethrow_error (id.c_str (), "%s", tmp_msg);
 	      delete [] tmp_msg;
 
-	      // FIXME: Need to restore the stack as rethrow_error sets it?
+	      // FIXME -- Need to restore the stack as rethrow_error sets it?
 	      Vlast_error_file = file;
 	      Vlast_error_name = nm;
 	      Vlast_error_line = l;
 	      Vlast_error_column = c;
 
 	      if (err.contains ("stack"))
 		{
 		  if (file.empty ())
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -189,17 +189,17 @@ convert_position (const Matrix& pos, con
     {
       retval(0) = pos(0) * parent_dim(0) + 1;
       retval(1) = pos(1) * parent_dim(1) + 1;
       retval(2) = pos(2) * parent_dim(0);
       retval(3) = pos(3) * parent_dim(1);
     }
   else if (from_units.compare ("characters"))
     {
-      // FIXME: implement this
+      // FIXME -- implement this.
     }
   else
     {
       res = backend.get_screen_resolution ();
 
       double f = 0.0;
 
       if (from_units.compare ("points"))
@@ -224,17 +224,17 @@ convert_position (const Matrix& pos, con
 	{
 	  retval(0) = (retval(0) - 1) / parent_dim(0);
 	  retval(1) = (retval(1) - 1) / parent_dim(1);
 	  retval(2) /= parent_dim(0);
 	  retval(3) /= parent_dim(1);
 	}
       else if (to_units.compare ("characters"))
 	{
-	  // FIXME: implement this
+	  // FIXME -- implement this.
 	}
       else
 	{
 	  if (res <= 0)
 	    res = backend.get_screen_resolution ();
 
 	  double f = 0.0;
 
@@ -679,17 +679,17 @@ double_radio_property::do_set (const oct
   return false;
 }
 
 bool
 array_property::validate (const octave_value& v)
 {
   bool xok = false;
 
-  // FIXME: should we always support []?
+  // FIXME -- should we always support []?
   if (v.is_empty () && v.is_double_type ())
     return true;
 
   // check value type
   if (type_constraints.size () > 0)
     {
       for (std::list<std::string>::const_iterator it = type_constraints.begin ();
            ! xok && it != type_constraints.end (); ++it)
@@ -949,18 +949,18 @@ property::create (const std::string& nam
   else if (type.compare ("data"))
     {
       retval = property (new array_property (name, h, Matrix ()));
 
       if (args.length () > 0)
 	{
 	  retval.set (args(0));
 
-	  // FIXME: additional argument could define constraints
-	  //        but is this really useful...?
+	  // FIXME -- additional argument could define constraints,
+	  // but is this really useful?
 	}
     }
   else if (type.compare ("color"))
     {
       color_values cv (0, 0, 0);
       radio_values rv;
 
       if (args.length () > 1)
@@ -2091,17 +2091,17 @@ figure::properties::set_visible (const o
       visible = val;
     }
 }
 
 Matrix
 figure::properties::get_boundingbox (bool) const
 {
   graphics_backend b = get_backend ();
-  // FIXME: screen size should be obtained from root object
+  // FIXME -- screen size should be obtained from root object.
   Matrix screen_size = b.get_screen_size ();
   Matrix pos;
 
   pos = convert_position (get_position ().matrix_value (), get_units (),
 			  "pixels", screen_size, b);
 
   pos(0)--;
   pos(1)--;
@@ -2109,17 +2109,17 @@ figure::properties::get_boundingbox (boo
 
   return pos;
 }
 
 void
 figure::properties::set_boundingbox (const Matrix& bb)
 {
   graphics_backend b = get_backend ();
-  // FIXME: screen size should be obtained from root object
+  // FIXME -- screen size should be obtained from root object.
   Matrix screen_size = b.get_screen_size ();
   Matrix pos = bb;
 
   pos(1) = screen_size(1) - pos(1) - pos(3);
   pos(1)++;
   pos(0)++;
   pos = convert_position (pos, "pixels", get_units (), screen_size, b);
 
@@ -2796,17 +2796,17 @@ axes::properties::update_camera (void)
   Matrix bb = get_boundingbox (true);
 
   double v_angle;
 
   if (cameraviewanglemode_is ("auto"))
     {
       double af;
 
-      // FIXME: Was this really needed? When compared to Matlab, it
+      // FIXME -- was this really needed?  When compared to Matlab, it
       // does not seem to be required. Need investigation with concrete
       // backend to see results visually.
       if (false && dowarp)
         af = 1.0 / (xM > yM ? xM : yM);
       else
         {
           if ((bb(2)/bb(3)) > (xM/yM))
             af = 1.0 / yM;
@@ -2911,18 +2911,18 @@ axes::properties::update_aspectratios (v
 	  Matrix pba (1, 3, 0.0);
 
 	  pba(0) = dx/da(0);
 	  pba(1) = dy/da(1);
 	  pba(2) = dz/da(2);
 	}
     }
   
-  // FIXME: if plotboxaspectratiomode is "manual", limits
-  // and/or dataaspectratio might be adapted
+  // FIXME -- if plotboxaspectratiomode is "manual", limits
+  // and/or dataaspectratio might be adapted.
 }
 
 // The INTERNAL flag defines whether position or outerposition is used.
 
 Matrix
 axes::properties::get_boundingbox (bool internal) const
 {
   graphics_object obj = gh_manager::get_object (get_parent ());
@@ -2994,18 +2994,18 @@ axes::get_default (const caseless_str& n
       graphics_object parent_obj = gh_manager::get_object (parent);
 
       retval = parent_obj.get_default (name);
     }
 
   return retval;
 }
 
-// FIXME: Remove
-// FIXME: Maybe this should go into array_property class?
+// FIXME -- remove.
+// FIXME -- maybe this should go into array_property class?
 /*
 static void
 check_limit_vals (double& min_val, double& max_val, double& min_pos,
 		  const array_property& data)
 {
   double val = data.min_val ();
   if (! (xisinf (val) || xisnan (val)) && val < min_val)
     min_val = val;
@@ -3601,17 +3601,17 @@ surface::properties::update_normals (voi
       bool x_mat = (x.rows () == q);
       bool y_mat = (y.columns () == p);
 
       NDArray n (dim_vector (q, p, 3), 0.0);
 
       i1 = i2 = i3 = 0;
       j1 = j2 = j3 = 0;
 
-      // FIXME: normal computation at boundaries
+      // FIXME -- normal computation at boundaries.
       for (int i = 1; i < (p-1); i++)
 	{
 	  if (y_mat)
 	    {
 	      i1 = i-1;
 	      i2 = i;
 	      i3 = i+1;
 	    }
diff --git a/src/graphics.h.in b/src/graphics.h.in
--- a/src/graphics.h.in
+++ b/src/graphics.h.in
@@ -969,17 +969,17 @@ public:
       return p;
     }
 
 protected:
   bool do_set (const octave_value& v)
     {
       if (validate (v))
 	{
-	  // FIXME: should we check for actual data change?
+	  // FIXME -- should we check for actual data change?
 	  if (! is_equal (v))
 	    {
 	      data = v;
 
 	      get_data_limits ();
 
 	      return true;
 	    }
@@ -1724,17 +1724,17 @@ protected:
 
   property get_property_dynamic (const caseless_str&);
 
   BEGIN_BASE_PROPERTIES
     // properties common to all objects
     bool_property beingdeleted , "off"
     radio_property busyaction , "{queue}|cancel"
     callback_property buttondownfcn , Matrix ()
-    // FIXME: use a property class for children
+    // FIXME -- use a property class for children.
     Matrix children Gfs , Matrix ()
     bool_property clipping , "on"
     callback_property createfcn , Matrix ()
     callback_property deletefcn , Matrix ()
     radio_property handlevisibility , "{on}|callback|off"
     bool_property hittest , "on"
     bool_property interruptible , "on"
     handle_property parent fs , p
@@ -1742,17 +1742,17 @@ protected:
     bool_property selectionhighlight , "on"
     string_property tag s , ""
     string_property type frs , ty
     any_property userdata , Matrix ()
     bool_property visible , "on"
     // additional (octave-specific) properties
     bool_property __modified__ s , "on"
     graphics_handle __myhandle__ fhrs , mh
-    // FIXME: should this really be here?
+    // FIXME -- should this really be here?
     handle_property uicontextmenu , graphics_handle ()
   END_PROPERTIES
 
 protected:
   struct cmp_caseless_str 
     {
       bool operator () (const caseless_str &a, const caseless_str &b) const
         {
@@ -2641,17 +2641,17 @@ public:
       row_vector_property ytick m , Matrix ()
       row_vector_property ztick m , Matrix ()
       radio_property xtickmode , "{auto}|manual"
       radio_property ytickmode , "{auto}|manual"
       radio_property ztickmode , "{auto}|manual"
       bool_property xminortick , "off"
       bool_property yminortick , "off"
       bool_property zminortick , "off"
-      // FIXME: should be kind of string array
+      // FIXME -- should be kind of string array.
       any_property xticklabel m , ""
       any_property yticklabel m , ""
       any_property zticklabel m , ""
       radio_property xticklabelmode , "{auto}|manual"
       radio_property yticklabelmode , "{auto}|manual"
       radio_property zticklabelmode , "{auto}|manual"
       radio_property interpreter , "tex|{none}|latex"
       color_property color , color_property (color_values (1, 1, 1), radio_values ("none"))
@@ -2682,28 +2682,28 @@ public:
       array_property currentpoint , Matrix (2, 3, 0.0)
       radio_property drawmode , "{normal}|fast"
       radio_property fontangle , "{normal}|italic|oblique"
       string_property fontname , "Helvetica"
       double_property fontsize , 12
       radio_property fontunits , "{points}|normalized|inches|centimeters|pixels"
       radio_property fontweight , "{normal}|light|demi|bold"
       radio_property gridlinestyle , "-|--|{:}|-.|none"
-      // FIXME: should be kind of string array
+      // FIXME -- should be kind of string array.
       string_property linestyleorder , "-"
       double_property linewidth , 0.5
       radio_property minorgridlinestyle , "-|--|{:}|-.|none"
       array_property plotboxaspectratio m , Matrix (1, 3, 1.0)
       radio_property plotboxaspectratiomode , "{auto}|manual"
       radio_property projection , "{orthographic}|perpective"
       radio_property tickdir m , "{in}|out"
       radio_property tickdirmode , "{auto}|manual"
       array_property ticklength , Matrix (1, 2, 0.1)
       array_property tightinset r , Matrix (1, 4, 0.0)
-      // FIXME: uicontextmenu should be moved here
+      // FIXME -- uicontextmenu should be moved here.
       radio_property units , "{normalized}|inches|centimeters|points|pixels|characters"
       // hidden properties for transformation computation
       array_property x_viewtransform h , Matrix (4, 4, 0.0)
       array_property x_projectiontransform h , Matrix (4, 4, 0.0)
       array_property x_viewporttransform h , Matrix (4, 4, 0.0)
       array_property x_normrendertransform h , Matrix (4, 4, 0.0)
       array_property x_rendertransform h , Matrix (4, 4, 0.0)
    END_PROPERTIES
@@ -3075,21 +3075,21 @@ public:
 	cdata.add_constraint ("double");
 	cdata.add_constraint ("logical");
 	cdata.add_constraint ("uint8");
 	cdata.add_constraint (dim_vector (-1, -1));
 	cdata.add_constraint (dim_vector (-1, -1, 3));
       }
 
   private:
-    // FIXME: limits should take pixel width into account
+    // FIXME -- limits should take pixel width into account.
     void update_xdata (void)
       { set_xlim (xdata.get_limits ()); }
 
-    // FIXME: idem
+    // FIXME -- idem.
     void update_ydata (void)
       { set_ylim (ydata.get_limits ()); }
 
     void update_cdata (void)
       {
 	if (cdatamapping_is ("scaled"))
 	  set_clim (cdata.get_limits ());
 	else
diff --git a/src/ov-builtin.cc b/src/ov-builtin.cc
--- a/src/ov-builtin.cc
+++ b/src/ov-builtin.cc
@@ -101,17 +101,17 @@ octave_builtin::do_multi_index_op (int n
       octave_call_stack::push (this);
 
       unwind_protect::add (octave_call_stack::unwind_pop, 0);
 
       try
 	{
 	  retval = (*f) (args, nargout);
           // Do not allow null values to be returned from functions.
-          // FIXME: perhaps true builtins should be allowed?
+          // FIXME -- perhaps true builtins should be allowed?
           retval.normalize_null_values ();
 	}
       catch (octave_execution_exception)
 	{
 	  gripe_library_execution_error ();
 	}
 
       unwind_protect::run_frame ("builtin_func_eval");
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -1972,17 +1972,17 @@ octave_print_internal (std::ostream& os,
 }
 
 void
 octave_print_internal (std::ostream& os, bool d, bool pr_as_read_syntax)
 { 
   octave_print_internal (os, double (d), pr_as_read_syntax); 
 }
 
-// FIXME: Write single precision versions of the printing functions
+// FIXME -- write single precision versions of the printing functions.
 
 void
 octave_print_internal (std::ostream& os, float d, bool pr_as_read_syntax)
 { 
   octave_print_internal (os, double (d), pr_as_read_syntax); 
 }
 
 void
