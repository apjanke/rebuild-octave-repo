# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1481901635 18000
#      Fri Dec 16 10:20:35 2016 -0500
# Node ID 23847979b91ec9519e720b758bed4f2dd44593b0
# Parent  7b368d85e86c61250f2039ad0da8e3ec564cc894
maint: Strip trailing whitespace from source files.

diff --git a/doc/interpreter/genpropdoc.m b/doc/interpreter/genpropdoc.m
--- a/doc/interpreter/genpropdoc.m
+++ b/doc/interpreter/genpropdoc.m
@@ -865,17 +865,17 @@ for the z-axis.  __modemsg__.  @xref{XRE
 
       case "interpreter"
 
       case "linestyle"
         s.doc = "@xref{Line Styles}.";
 
       case "linewidth"
         s.doc = "Width of the line object measured in points.";
-        
+
       case "linejoin"
         s.doc = "Control the shape of the junction of line segments. \
 This property currently only affects the printed output.";
 
       case "marker"
         s.doc = "Shape of the marker for each data point.  \
 @xref{Marker Styles}.";
 
diff --git a/doc/interpreter/intro.txi b/doc/interpreter/intro.txi
--- a/doc/interpreter/intro.txi
+++ b/doc/interpreter/intro.txi
@@ -649,12 +649,12 @@ Record the session in the file named @va
 @end table
 
 With no input or output arguments, @code{diary} toggles the current diary
 state.
 
 If output arguments are requested, @code{diary} ignores inputs and returns
 the current status.  The boolean @var{status} indicates whether recording is on
 or off, and @var{diaryfile} is the name of the file where the session is
-stored.  
+stored.
 @seealso{history, evalc}
 @end deftypefn
 
diff --git a/etc/icons/octave.appdata.xml.in b/etc/icons/octave.appdata.xml.in
--- a/etc/icons/octave.appdata.xml.in
+++ b/etc/icons/octave.appdata.xml.in
@@ -1,24 +1,24 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
   Copyright (C) 2013-2016 CarnÃ« Draug
 
   This file is part of Octave.
-  
+
   Octave is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.
-  
+
   Octave is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
-  
+
   You should have received a copy of the GNU General Public License
   along with Octave; see the file COPYING.  If not, see
   <http://www.gnu.org/licenses/>.
 -->
 <application>
   <id type="desktop">%OCTAVE_DESKTOP_FILE%</id>
   <licence>GPLv3+</licence>
   <name>GNU Octave</name>
diff --git a/libgui/src/resource-manager.h b/libgui/src/resource-manager.h
--- a/libgui/src/resource-manager.h
+++ b/libgui/src/resource-manager.h
@@ -114,17 +114,17 @@ public:
 
   static resource_manager *instance;
 
 public slots:
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
 
 private:
-  
+
   static bool instance_ok (void);
 
   QString settings_directory;
 
   QString settings_file;
 
   QSettings *settings;
 
diff --git a/libinterp/corefcn/gl2ps-print.cc b/libinterp/corefcn/gl2ps-print.cc
--- a/libinterp/corefcn/gl2ps-print.cc
+++ b/libinterp/corefcn/gl2ps-print.cc
@@ -122,31 +122,31 @@ namespace octave
         gl2psDisable (GL2PS_LINE_STIPPLE);
       else
         gl2psEnable (GL2PS_LINE_STIPPLE);
     }
 
     void set_linecap (const std::string& s)
       {
         octave::opengl_renderer::set_linejoin (s);
-      
+
 #if defined (HAVE_GL2PSLINEJOIN)
         if (s == "butt")
           gl2psLineCap (GL2PS_LINE_CAP_BUTT);
         else if (s == "square")
           gl2psLineCap (GL2PS_LINE_CAP_SQUARE);
         else if (s == "round")
           gl2psLineCap (GL2PS_LINE_CAP_ROUND);
 #endif
       }
 
     void set_linejoin (const std::string& s)
     {
       octave::opengl_renderer::set_linejoin (s);
-      
+
 #if defined (HAVE_GL2PSLINEJOIN)
       if (s == "round")
         gl2psLineJoin (GL2PS_LINE_JOIN_ROUND);
       else if (s == "miter")
         gl2psLineJoin (GL2PS_LINE_JOIN_MITER);
       else if (s == "chamfer")
         gl2psLineJoin (GL2PS_LINE_JOIN_BEVEL);
 #endif
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -1613,31 +1613,31 @@ handle_property::do_set (const octave_va
       current_val = gh;
       return true;
     }
 
   return false;
 }
 
 /*
-## Test validation of uicontextmenu property 
+## Test validation of uicontextmenu property
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   hax = axes ("parent", hf);
 %!   hpa = patch ("parent", hax);
-%!   try 
+%!   try
 %!     set (hax, "uicontextmenu", hpa);
 %!   catch
 %!     err = lasterr ();
 %!   end_try_catch
 %!   assert (err, 'set: invalid graphics object type for property "uicontextmenu"');
 %! unwind_protect_cleanup
 %!   delete (hf);
-%! end_unwind_protect   
+%! end_unwind_protect
 */
 
 Matrix
 children_property::do_get_children (bool return_hidden) const
 {
   Matrix retval (children_list.size (), 1);
   octave_idx_type k = 0;
 
@@ -4607,36 +4607,36 @@ axes::properties::init (void)
 
   Matrix tlooseinset = default_axes_position ();
   tlooseinset(2) = 1-tlooseinset(0)-tlooseinset(2);
   tlooseinset(3) = 1-tlooseinset(1)-tlooseinset(3);
   looseinset = tlooseinset;
 }
 
 /*
-## Test validation of axes double properties range 
+## Test validation of axes double properties range
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   hax = axes ("parent", hf);
-%!   try 
+%!   try
 %!     set (hax, "linewidth", -1);
 %!   catch
 %!     err = lasterr ();
 %!   end_try_catch
 %!   assert (err, 'set: "linewidth" must be greater than 0');
-%!   try 
+%!   try
 %!     set (hax, "minorgridalpha", 1.5);
 %!   catch
 %!     err = lasterr ();
 %!   end_try_catch
 %!   assert (err, 'set: "minorgridalpha" must be less than or equal to 1');
 %! unwind_protect_cleanup
 %!   delete (hf);
-%! end_unwind_protect   
+%! end_unwind_protect
 */
 
 Matrix
 axes::properties::calc_tightbox (const Matrix& init_pos)
 {
   Matrix pos = init_pos;
   graphics_object go = gh_manager::get_object (get_parent ());
   Matrix parent_bb = go.get_properties ().get_boundingbox (true);
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -1172,17 +1172,17 @@ public:
   {
     set (val);
     return *this;
   }
 
   base_property* clone (void) const { return new double_property (*this); }
 
   void add_constraint (const std::string& type, double val, bool inclusive)
-  { 
+  {
     if (type == "min")
       minval = std::pair<double, bool> (val, inclusive);
     else if (type == "max")
       maxval = std::pair<double, bool> (val, inclusive);
   }
 
 protected:
   bool do_set (const octave_value& v)
@@ -2672,18 +2672,18 @@ protected:
   };
 
   std::map<caseless_str, property, cmp_caseless_str> all_props;
 
 protected:
   void insert_static_property (const std::string& name, base_property& p)
   { insert_property (name, property (&p, true)); }
 
-  virtual void init (void) 
-  { 
+  virtual void init (void)
+  {
     uicontextmenu.add_constraint ("uicontextmenu");
   }
 };
 
 class OCTINTERP_API base_graphics_object
 {
 public:
   friend class graphics_object;
diff --git a/libinterp/corefcn/pager.cc b/libinterp/corefcn/pager.cc
--- a/libinterp/corefcn/pager.cc
+++ b/libinterp/corefcn/pager.cc
@@ -533,17 +533,17 @@ Record the session in the file named @va
 @end table
 
 With no input or output arguments, @code{diary} toggles the current diary
 state.
 
 If output arguments are requested, @code{diary} ignores inputs and returns
 the current status.  The boolean @var{status} indicates whether recording is on
 or off, and @var{diaryfile} is the name of the file where the session is
-stored.  
+stored.
 @seealso{history, evalc}
 @end deftypefn */)
 {
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
diff --git a/libinterp/corefcn/profiler.h b/libinterp/corefcn/profiler.h
--- a/libinterp/corefcn/profiler.h
+++ b/libinterp/corefcn/profiler.h
@@ -87,17 +87,17 @@ public:
   profile_data_accumulator (void);
 
   // No copying!
 
   profile_data_accumulator (const profile_data_accumulator&) = delete;
 
   profile_data_accumulator&
   operator = (const profile_data_accumulator&) = delete;
-  
+
   virtual ~profile_data_accumulator ();
 
   bool is_active (void) const { return enabled; }
   void set_active (bool);
 
   void reset (void);
 
   octave_value get_flat (void) const;
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -1805,17 +1805,17 @@ public:
       {
         fcn_info& finfo = p->second;
 
         finfo.install_built_in_dispatch (klass);
       }
     else
       error ("install_built_in_dispatch: '%s' is undefined", name.c_str ());
   }
-  
+
   static void push_context (scope_id scope = xcurrent_scope)
   {
     if (scope == xglobal_scope || scope == xtop_scope)
       error ("invalid call to symtab::push_context");
 
     symbol_table *inst = get_instance (scope);
 
     if (inst)
diff --git a/libinterp/dldfcn/__ode15__.cc b/libinterp/dldfcn/__ode15__.cc
--- a/libinterp/dldfcn/__ode15__.cc
+++ b/libinterp/dldfcn/__ode15__.cc
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 
 #if defined (HAVE_NVECTOR_NVECTOR_SERIAL_H)
 #include <nvector/nvector_serial.h>
 #endif
 
 
 #include <oct.h>
 #include <parse.h>
-#include <time.h> 
+#include <time.h>
 
 #include "defun-dld.h"
 #include "iostream"
 #include "error.h"
 #include "ov.h"
 #include "ov-struct.h"
 #include "errwarn.h"
 
@@ -78,17 +78,17 @@ namespace octave
     typedef
     Matrix (*DAEJacCellDense) (Matrix *dfdy, Matrix *dfdyp,
                                realtype cj);
 
     typedef
     SparseMatrix (*DAEJacCellSparse) (SparseMatrix *dfdy,
                                       SparseMatrix *dfdyp, realtype cj);
 
-    //Default 
+    //Default
     IDA (void)
       : t0 (0.0), y0 (), yp0 (), havejac (false), havejacfun (false),
         havejacsparse (false), mem (NULL), num (), ida_fun (NULL),
         ida_jac (NULL), dfdy (NULL), dfdyp (NULL), spdfdy (NULL),
         spdfdyp (NULL), fun (0), jacfun (NULL), jacspfun (0),
         jacdcell (0), jacspcell (0)
     { };
 
@@ -98,29 +98,29 @@ namespace octave
       : t0 (t), y0 (y), yp0 (yp), havejac (false), havejacfun (false),
         havejacsparse (false), mem (NULL), num (), ida_fun (ida_fcn),
         ida_jac (NULL), dfdy (NULL), dfdyp (NULL), spdfdy (NULL),
         spdfdyp (NULL), fun (daefun), jacfun (NULL), jacspfun (0),
         jacdcell (0), jacspcell (0)
     { };
 
 
-    ~IDA (void) { IDAFree (&mem); } 
-  
+    ~IDA (void) { IDAFree (&mem); }
+
     IDA&
     set_jacobian (octave_function *jac, DAEJacFuncDense j)
     {
       jacfun = j;
       ida_jac = jac;
       havejac = true;
       havejacfun = true;
       havejacsparse = false;
       return *this;
     }
-  
+
     IDA&
     set_jacobian (octave_function *jac, DAEJacFuncSparse j)
     {
       jacspfun = j;
       ida_jac = jac;
       havejac = true;
       havejacfun = true;
       havejacsparse = true;
@@ -146,48 +146,48 @@ namespace octave
       jacspcell = j;
       spdfdy = dy;
       spdfdyp = dyp;
       havejac = true;
       havejacfun = false;
       havejacsparse = true;
       return *this;
     }
- 
+
     void
     set_userdata (void);
 
     void
     initialize (void);
 
     static ColumnVector
     NVecToCol (N_Vector& v, long int n);
 
     static N_Vector
-    ColToNVec (const ColumnVector& data, long int n); 
+    ColToNVec (const ColumnVector& data, long int n);
 
     void
     set_up (void);
 
     void
-    set_tolerance (ColumnVector& abstol, realtype reltol); 
+    set_tolerance (ColumnVector& abstol, realtype reltol);
 
     void
-    set_tolerance (realtype abstol, realtype reltol); 
+    set_tolerance (realtype abstol, realtype reltol);
 
     static int
     resfun (realtype t, N_Vector yy, N_Vector yyp,
             N_Vector rr, void *user_data);
 
     void
     resfun_impl (realtype t, N_Vector& yy,
                  N_Vector& yyp, N_Vector& rr);
 
     static int
-    jacdense (long int Neq, realtype t,  realtype cj, 
+    jacdense (long int Neq, realtype t,  realtype cj,
               N_Vector yy, N_Vector yyp, N_Vector resvec,
               DlsMat JJ, void *user_data, N_Vector tempv1,
               N_Vector tempv2, N_Vector tempv3)
     {
       IDA *self =
         static_cast <IDA *> (user_data);
 
       self -> jacdense_impl (Neq, t, cj, yy, yyp, JJ);
@@ -210,33 +210,33 @@ namespace octave
       return 0;
     }
 
     void
     jacsparse_impl (realtype t, realtype cj, N_Vector& yy,
                     N_Vector& yyp, SlsMat& Jac);
 
     void
-    set_maxstep (realtype maxstep); 
+    set_maxstep (realtype maxstep);
 
     void
-    set_initialstep (realtype initialstep); 
+    set_initialstep (realtype initialstep);
 
     bool
     interpolate (int& cont, Matrix& output, ColumnVector& tout,
                  int refine, realtype tend, bool haveoutputfcn,
                  bool haveoutputsel, octave_function *output_fcn,
                  ColumnVector& outputsel, bool haveeventfunction,
                  octave_function * event_fcn, ColumnVector& te,
                  Matrix& ye, ColumnVector& ie, ColumnVector& oldval,
                  ColumnVector& oldisterminal, ColumnVector& olddir,
                  int& temp, ColumnVector& yold);
 
     bool
-    outputfun (octave_function *output_fcn, bool haveoutputsel, 
+    outputfun (octave_function *output_fcn, bool haveoutputsel,
                const ColumnVector& output, realtype tout, realtype tend,
                ColumnVector& outputsel, std::string flag);
 
 
     bool
     event (octave_function *event_fcn,
            ColumnVector& te, Matrix& ye, ColumnVector& ie,
            realtype tsol, const ColumnVector& y, std::string flag,
@@ -252,17 +252,17 @@ namespace octave
                const ColumnVector& y0, const ColumnVector& yp0,
                const int refine, bool haverefine, bool haveoutputfcn,
                octave_function *output_fcn, bool haveoutputsel,
                ColumnVector& outputsel, bool haveeventfunction,
                octave_function *event_fcn);
 
     void
     print_stat (void);
-  
+
   private:
 
     realtype t0;
     ColumnVector y0;
     ColumnVector yp0;
     bool havejac;
     bool havejacfun;
     bool havejacsparse;
@@ -280,17 +280,17 @@ namespace octave
     DAEJacCellDense jacdcell;
     DAEJacCellSparse jacspcell;
 
   };
 
   int
   IDA::resfun (realtype t, N_Vector yy, N_Vector yyp, N_Vector rr,
                void *user_data)
-  { 
+  {
     IDA *self =
       static_cast <IDA *> (user_data);
 
     self -> resfun_impl (t, yy, yyp, rr);
     return 0;
   }
 
   void
@@ -301,19 +301,19 @@ namespace octave
 
     ColumnVector y =
       IDA::NVecToCol (yy, num);
 
     ColumnVector yp =
       IDA::NVecToCol (yyp, num);
 
     ColumnVector res =
-      (*fun) (y, yp, t, ida_fun);  
-    
-    realtype *puntrr = 
+      (*fun) (y, yp, t, ida_fun);
+
+    realtype *puntrr =
       NV_DATA_S (rr);
 
     for (octave_idx_type i = 0; i < num; i++)
       puntrr [i] = res (i);
 
     END_INTERRUPT_WITH_EXCEPTIONS;
   }
 
@@ -347,18 +347,18 @@ namespace octave
               }
           }
       }
   }
 
   void
   IDA::jacdense_impl (long int Neq, realtype t, realtype cj,
                       N_Vector& yy, N_Vector& yyp, DlsMat& JJ)
-  
-  { 
+
+  {
     BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
     ColumnVector y =
       NVecToCol (yy, Neq);
 
     ColumnVector yp =
       NVecToCol (yyp, Neq);
 
@@ -374,18 +374,18 @@ namespace octave
                JJ -> data);
 
     END_INTERRUPT_WITH_EXCEPTIONS;
   }
 
   void
   IDA::jacsparse_impl (realtype t, realtype cj, N_Vector& yy, N_Vector& yyp,
                        SlsMat& Jac)
-  
-  { 
+
+  {
     BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
     ColumnVector y =
       NVecToCol (yy, num);
 
     ColumnVector yp =
       NVecToCol (yyp, num);
 
@@ -394,54 +394,54 @@ namespace octave
     if (havejacfun)
       jac = (*jacspfun) (y, yp, t, cj, ida_jac);
     else
       jac = (*jacspcell) (spdfdy, spdfdyp, cj);
 
     SparseSetMatToZero (Jac);
     int *colptrs = *(Jac -> colptrs);
     int *rowvals = *(Jac -> rowvals);
-    
+
     for (int i = 0; i < num + 1; i++)
       colptrs[i] = jac.cidx(i);
 
     for (int i = 0; i < jac.nnz (); i++)
       {
         rowvals[i] = jac.ridx (i);
         Jac -> data[i] = jac.data (i);
-      }    
+      }
 
     END_INTERRUPT_WITH_EXCEPTIONS;
   }
 
   ColumnVector
   IDA::NVecToCol (N_Vector& v, long int n)
   {
     ColumnVector data (n);
     realtype *punt;
-    punt = NV_DATA_S (v);  
+    punt = NV_DATA_S (v);
 
     for (octave_idx_type i = 0; i < n; i++)
       data (i) = punt [i];
-  
+
     return data;
   }
 
   N_Vector
   IDA::ColToNVec (const ColumnVector &data, long int n)
   {
     N_Vector v =
       N_VNew_Serial (n);
 
     realtype * punt;
     punt = NV_DATA_S (v);
 
     for (octave_idx_type i = 0; i < n; i++)
       punt [i] = data (i);
-  
+
     return v;
   }
 
   void
   IDA::set_userdata (void)
   {
     void * userdata = this;
 
@@ -450,20 +450,20 @@ namespace octave
     if (flag != 0)
       {
         error ("User data not set");
       }
   }
 
   void
   IDA::initialize (void)
-  {  
-    num = y0.numel();   
+  {
+    num = y0.numel();
     mem = IDACreate ();
-  
+
     N_Vector yy =
       ColToNVec(y0, num);
 
     N_Vector yyp =
       ColToNVec(yp0, num);
 
     IDA::set_userdata ();
 
@@ -487,54 +487,54 @@ namespace octave
       {
         error ("IDA: Tolerance not set");
       }
     N_VDestroy_Serial (abs_tol);
   }
 
   void
   IDA::set_tolerance (realtype abstol, realtype reltol)
-  { 
+  {
     int flag =
       IDASStolerances (mem, reltol, abstol);
     if (flag != 0)
       {
         error ("IDA: Tolerance not set");
       }
   }
 
   octave_value_list
   IDA::integrate (const int numt, const ColumnVector& tspan,
                   const ColumnVector& y, const ColumnVector& yp,
-                  const int refine, bool haverefine, bool haveoutputfcn, 
+                  const int refine, bool haverefine, bool haveoutputfcn,
                   octave_function *output_fcn, bool haveoutputsel,
                   ColumnVector& outputsel, bool haveeventfunction,
                   octave_function *event_fcn)
-  {  
+  {
     // Set up output
     ColumnVector tout, yout (num), ypout (num), ysel (outputsel.numel ());
     ColumnVector ie, te, oldval, oldisterminal, olddir;
     Matrix output, ye;
     int cont = 0, flag = 0, temp = 0;
     bool status = 0;
     std::string string = "";
     ColumnVector yold = y;
-    octave_value_list retval;  
-  
+    octave_value_list retval;
+
     realtype tsol =
       tspan (0);
     realtype tend =
       tspan (numt - 1);
-    
+
     N_Vector yyp =
       ColToNVec (yp, num);
-    
+
     N_Vector yy =
-      ColToNVec (y, num);  
-  
+      ColToNVec (y, num);
+
     // Initialize OutputFcn
     if (haveoutputfcn)
       status = IDA::outputfun (output_fcn, haveoutputsel, y,
                                tsol, tend, outputsel, "init");
 
     // Initialize Events
     if (haveeventfunction)
       status = IDA::event (event_fcn, te, ye, ie, tsol, y,
@@ -546,33 +546,33 @@ namespace octave
         // First output value
         tout.resize (numt);
         tout (0) = tsol;
         output.resize (numt, num);
 
         for (octave_idx_type i = 0; i < num; i++)
           output.elem (0, i) = y.elem (i);
 
-        //Main loop 
+        //Main loop
         for (octave_idx_type j = 1; j < numt && status == 0; j++)
           {
             // IDANORMAL already interpolates tspan(j)
             flag = IDASolve (mem, tspan (j), &tsol, yy, yyp, IDA_NORMAL);
             if (flag != 0)
               {
                 error ("IDASolve failed");
               }
-      
+
             yout = NVecToCol (yy, num);
             ypout = NVecToCol (yyp, num);
-            tout (j) = tsol;      
+            tout (j) = tsol;
 
             for (octave_idx_type i = 0; i < num; i++)
               output.elem (j, i) = yout.elem (i);
-      
+
             if (haveoutputfcn)
               status = IDA::outputfun (output_fcn, haveoutputsel, yout, tsol,
                                        tend, outputsel, string);
 
             if (haveeventfunction)
               status = IDA::event (event_fcn, te, ye, ie, tout (j), yout,
                                    string, ypout, oldval, oldisterminal,
                                    olddir, j, temp, tout (j - 1), yold);
@@ -582,17 +582,17 @@ namespace octave
               {
                 output.resize (j + 1, num);
                 tout.resize (j + 1);
               }
 
           }
       }
     else // numel (tspan) == 2
-      { 
+      {
         // First output value
         tout.resize (1);
         tout (0) = tsol;
         output.resize (1, num);
 
         for (octave_idx_type i = 0; i < num; i++)
           output.elem (0, i) = y.elem (i);
 
@@ -612,68 +612,68 @@ namespace octave
 
             if (haverefine)
               status = IDA::interpolate (cont, output, tout, refine, tend,
                                          haveoutputfcn, haveoutputsel,
                                          output_fcn, outputsel,
                                          haveeventfunction, event_fcn, te,
                                          ye, ie, oldval, oldisterminal,
                                          olddir, temp, yold);
-      
+
             ypout = NVecToCol (yyp, num);
             cont += 1;
             output.resize (cont + 1, num); // This may be not efficient
             tout.resize (cont + 1);
-            tout (cont) = tsol;      
+            tout (cont) = tsol;
             yout = NVecToCol (yy, num);
 
             for (octave_idx_type i = 0; i < num; i++)
               output.elem (cont, i) = yout.elem (i);
 
             if (haveoutputfcn && ! haverefine && tout (cont) < tend)
               status = IDA::outputfun (output_fcn, haveoutputsel, yout, tsol,
                                        tend, outputsel, string);
-     
+
             if (haveeventfunction && ! haverefine && tout (cont) < tend)
               status = IDA::event (event_fcn, te, ye, ie, tout (cont), yout,
                                    string, ypout, oldval, oldisterminal,
                                    olddir, cont, temp, tout (cont - 1), yold);
           }
         if (status == 0)
           {
             // Interpolate in tend
-            N_Vector dky = 
+            N_Vector dky =
               N_VNew_Serial (num);
-            
+
             flag = IDAGetDky (mem, tend, 0, dky);
             if (flag != 0)
               {
                 error ("IDA failed to interpolate y");
               }
 
             tout (cont) = tend;
             yout = NVecToCol (dky, num);
 
             for (octave_idx_type i = 0; i < num; i++)
               output.elem (cont, i) = yout.elem (i);
 
-            // Plot final value 
+            // Plot final value
             if (haveoutputfcn)
               {
                 status = IDA::outputfun (output_fcn, haveoutputsel, yout,
                                          tend, tend, outputsel, string);
 
                 // Events during last step
                 if (haveeventfunction)
                   status = IDA::event (event_fcn, te, ye, ie, tend, yout,
                                        string, ypout, oldval, oldisterminal,
                                        olddir, cont, temp, tout (cont - 1),
                                        yold);
               }
- 
+
             N_VDestroy_Serial (dky);
           }
         // Cleanup plotter
         status = IDA::outputfun (output_fcn, haveoutputsel, yout, tend, tend,
                                  outputsel, "done");
 
       }
 
@@ -725,66 +725,66 @@ namespace octave
           {
             if ((val(i) > 0 && oldval(i) < 0 && dir(i) != -1) // increasing
                 || (val(i) < 0 && oldval(i) > 0 && dir(i) != 1)) // decreasing
               {
                 index.resize (index.numel () + 1);
                 index (index.numel () - 1) = i;
               }
           }
-    
+
         if (cont == 1 && index.numel () > 0)  // Events in first step
           {
             temp = 1; // register only the first event
             te.resize (1);
             ye.resize (1, num);
             ie.resize (1);
-      
+
             // Linear interpolation
             ie (0) = index (0);
             te (0) = tsol - val (index (0)) * (tsol - told)
               / (val (index (0)) - oldval (index (0)));
 
             ColumnVector ytemp =
               y - ((tsol - te (0)) * (y - yold ) / (tsol - told));
-      
+
             for (octave_idx_type i = 0; i < num; i++)
-              ye.elem (0, i) = ytemp.elem (i);      
-             
+              ye.elem (0, i) = ytemp.elem (i);
+
           }
-        else if (index.numel () > 0) 
+        else if (index.numel () > 0)
           // Not first step: register all events and test if stop integration or not
           {
             te.resize (temp + index.numel ());
             ye.resize (temp + index.numel (), num);
             ie.resize (temp + index.numel ());
-      
+
             for (octave_idx_type i = 0; i < index.numel (); i++)
               {
 
                 if (isterminal (index (i)) == 1)
                   status = 1; // Stop integration
-        
-                // Linear interpolation  
+
+                // Linear interpolation
                 ie (temp + i) = index (i);
                 te (temp + i) = tsol -
-                  val (index (i)) * (tsol - told) / 
+                  val (index (i)) * (tsol - told) /
                   (val (index (i)) - oldval (index (i)));
 
                 ColumnVector ytemp =
                   y - (tsol - te (temp + i)) * (y - yold) / (tsol - told);
-       
+
                 for (octave_idx_type j = 0; j < num; j++)
-                  ye.elem (temp + i, j) = ytemp.elem (j);  
-  
+                  ye.elem (temp + i, j) = ytemp.elem (j);
+
               }
 
             temp += index.numel ();
           }
-        
+
         // Update variables
         yold = y;
         told = tsol;
         olddir = dir;
         oldval = val;
         oldisterminal = isterminal;
       }
 
@@ -798,115 +798,115 @@ namespace octave
                     ColumnVector& outputsel, bool haveeventfunction,
                     octave_function * event_fcn, ColumnVector& te,
                     Matrix& ye, ColumnVector& ie, ColumnVector& oldval,
                     ColumnVector& oldisterminal, ColumnVector& olddir,
                     int& temp, ColumnVector& yold)
   {
     realtype h = 0, tcur = 0;
     bool status = 0;
-   
+
     N_Vector dky =
       N_VNew_Serial (num);
-    
+
     N_Vector dkyp =
       N_VNew_Serial (num);
-    
+
     ColumnVector yout (num);
     ColumnVector ypout (num);
     std::string string = "";
 
     int flag =
       IDAGetLastStep (mem, &h);
-    
+
     if (flag != 0)
       {
         error ("IDA failed to return last step");
       }
     flag = IDAGetCurrentTime (mem, &tcur);
     if (flag != 0)
       {
         error ("IDA failed to return the current time");
       }
-   
-    realtype tin = 
+
+    realtype tin =
       tcur - h;
 
     realtype step =
       h / refine;
 
-    for (octave_idx_type i = 1; i < refine && tin + step * i < tend 
+    for (octave_idx_type i = 1; i < refine && tin + step * i < tend
            && status == 0; i++)
       {
         flag = IDAGetDky (mem, tin + step*i, 0, dky);
         if (flag != 0)
           {
             error ("IDA failed to interpolate y");
           }
         flag = IDAGetDky (mem, tin + step*i, 1, dkyp);
         if (flag != 0)
           {
             error ("IDA failed to interpolate yp");
           }
         cont += 1;
-        output.resize (cont + 1, num); 
+        output.resize (cont + 1, num);
         tout.resize (cont + 1);
 
-        tout (cont) = tin + step * i;      
+        tout (cont) = tin + step * i;
         yout = NVecToCol (dky, num);
         ypout = NVecToCol (dkyp, num);
 
         for (octave_idx_type j = 0; j < num; j++)
           output.elem (cont, j) = yout.elem (j);
-    
+
         if (haveoutputfcn)
           status = IDA::outputfun (output_fcn, haveoutputsel, yout,
                                    tout (cont), tend, outputsel, "");
 
         if (haveeventfunction)
           status = IDA::event (event_fcn, te, ye, ie, tout (cont),
                                yout, string, ypout, oldval,
                                oldisterminal, olddir, cont, temp,
                                tout (cont - 1), yold);
       }
     N_VDestroy_Serial (dky);
     return status;
   }
 
   bool
-  IDA::outputfun (octave_function *output_fcn, bool haveoutputsel, 
+  IDA::outputfun (octave_function *output_fcn, bool haveoutputsel,
                   const ColumnVector& yout, realtype tsol,
                   realtype tend, ColumnVector& outputsel,
                   std::string flag)
   {
     bool status = 0;
     octave_value_list output, val;
     ColumnVector ysel (outputsel.numel ());
 
     if (haveoutputsel)
       {
         for (octave_idx_type i = 0; i < outputsel.numel (); i++)
           ysel (i) = yout (outputsel (i));
-      
+
         output (1) = ysel;
       }
     else
-      output (1) = yout;    
+      output (1) = yout;
 
     output (2) = flag;
 
     if (flag == "init")
-      {  
+      {
         ColumnVector toutput (2);
         toutput (0) = tsol;
         toutput (1) = tend;
         output (0) = toutput;
-  
+
         feval (output_fcn, output, 0);
-      } 
+      }
     else if (flag == "")
       {
         output (0) = tsol;
         val = feval (output_fcn, output, 1);
         status = val(0).bool_value ();
       }
     else
       {  // Cleanup plotter
@@ -915,48 +915,48 @@ namespace octave
       }
 
     return status;
   }
 
   void
   IDA::set_maxstep (realtype maxstep)
   {
-    int flag = 
+    int flag =
       IDASetMaxStep (mem, maxstep);
 
     if (flag != 0)
       {
         error ("IDA: Max Step not set");
       }
-  } 
+  }
 
   void
-  IDA::set_initialstep (realtype initialstep) 
+  IDA::set_initialstep (realtype initialstep)
   {
     int flag =
       IDASetInitStep (mem, initialstep);
 
     if (flag != 0)
       {
-        error ("IDA: Initial Step not set"); 
+        error ("IDA: Initial Step not set");
       }
-  } 
+  }
 
   void
-  IDA::set_maxorder (int maxorder)  
+  IDA::set_maxorder (int maxorder)
   {
     int flag =
       IDASetMaxOrd (mem, maxorder);
 
     if (flag != 0)
       {
         error ("IDA: Max Order not set");
       }
-  } 
+  }
 
   void
   IDA::print_stat (void)
   {
     long int nsteps = 0, netfails = 0, nrevals = 0;
     int flag =
       IDAGetNumSteps(mem, &nsteps);
 
@@ -968,39 +968,39 @@ namespace octave
     if (flag != 0)
       {
         error ("IDA failed to return the number of internal errors");
       }
     flag = IDAGetNumResEvals(mem, &nrevals);
     if (flag != 0)
       {
         error ("IDA failed to return the number of residual evaluations");
-      }  
+      }
 
     std::cout<<nsteps<<" successful steps\n";
     std::cout<<netfails<<" failed attempts\n";
     std::cout<<nrevals<<" function evaluations\n";
     //std::cout<<<<" partial derivatives\n";
     //std::cout<<<<" LU decompositions\n";
     //std::cout<<<<" solutions of linear systems\n";
   }
- 
+
   ColumnVector
   ida_user_function (const ColumnVector& x, const ColumnVector& xdot,
                      double t, octave_function *ida_fc)
   {
     ColumnVector retval;
     octave_value_list args;
 
     args(2) = xdot;
     args(1) = x;
     args(0) = t;
 
     octave_value_list tmp;
-    
+
     try
       {
         tmp = ida_fc -> do_multi_index_op (1, args);
       }
     catch (octave::execution_exception& e)
       {
         err_user_supplied_eval (e, "__ode15__");
       }
@@ -1017,17 +1017,17 @@ namespace octave
     Matrix retval;
     octave_value_list newargs (3);
 
     newargs (0) = t;
     newargs (1) = x;
     newargs (2) = xdot;
 
     octave_value_list tmp;
-    
+
     try
       {
         tmp = ida_jc -> do_multi_index_op (2, newargs);
       }
     catch (octave::execution_exception& e)
       {
         err_user_supplied_eval (e, "__ode15__");
       }
@@ -1042,31 +1042,31 @@ namespace octave
                   double t, double cj, octave_function *ida_jc)
   {
     SparseMatrix retval;
     octave_value_list newargs (3);
 
     newargs (0) = t;
     newargs (1) = x;
     newargs (2) = xdot;
-  
+
     octave_value_list tmp;
 
     try
       {
         tmp = ida_jc -> do_multi_index_op (2, newargs);
       }
     catch (octave::execution_exception& e)
       {
         err_user_supplied_eval (e, "__ode15__");
       }
 
     retval = tmp(0).sparse_matrix_value () +
       cj * tmp(1).sparse_matrix_value ();
-    
+
     return retval;
   }
 
   Matrix
   ida_dense_cell_jac (Matrix *dfdy, Matrix *dfdyp, double cj)
   {
     Matrix retval;
     retval = (*dfdy) + cj * (*dfdyp);
@@ -1087,50 +1087,50 @@ namespace octave
             const ColumnVector &tspan,
             const int numt,
             const realtype t0,
             const ColumnVector &y0,
             const ColumnVector &yp0,
             const octave_scalar_map &options)
   {
     octave_value_list retval;
-  
+
     // Create object
     IDA dae (t0, y0, yp0, ida_fcn, ida_user_function);
 
     // Set Jacobian
     bool havejac =
       options.getfield ("havejac").bool_value ();
-    
+
     bool havejacsparse =
       options.getfield ("havejacsparse").bool_value ();
-    
+
     bool havejacfun =
       options.getfield ("havejacfun").bool_value ();
- 
+
     Matrix ida_dfdy, ida_dfdyp, *dfdy, *dfdyp;
     SparseMatrix ida_spdfdy, ida_spdfdyp, *spdfdy, *spdfdyp;
     octave_function *ida_jac;
     Cell jaccell;
 
     if (havejac)
       {
         if (havejacfun)
           {
             ida_jac = options.getfield ("Jacobian").function_value ();
-            if (havejacsparse) 
+            if (havejacsparse)
               dae.set_jacobian (ida_jac, ida_sparse_jac);
             else
               dae.set_jacobian (ida_jac, ida_dense_jac);
           }
         else
           {
             jaccell = options.getfield ("Jacobian").cell_value ();
 
-            if (havejacsparse) 
+            if (havejacsparse)
               {
                 ida_spdfdy = jaccell(0).sparse_matrix_value ();
                 ida_spdfdyp = jaccell(1).sparse_matrix_value ();
                 spdfdy = &ida_spdfdy;
                 spdfdyp = &ida_spdfdyp;
                 dae.set_jacobian (spdfdy, spdfdyp, ida_sparse_cell_jac);
               }
             else
@@ -1138,114 +1138,114 @@ namespace octave
                 ida_dfdy = jaccell(0).matrix_value ();
                 ida_dfdyp = jaccell(1).matrix_value ();
                 dfdy = &ida_dfdy;
                 dfdyp = &ida_dfdyp;
                 dae.set_jacobian (dfdy, dfdyp, ida_dense_cell_jac);
               }
           }
       }
-  
+
     // Initialize IDA
     dae.initialize ();
- 
-    // Set tolerances  
+
+    // Set tolerances
     realtype rel_tol =
       options.getfield("RelTol").double_value ();
-    
+
     bool haveabstolvec =
       options.getfield ("haveabstolvec").bool_value ();
-  
-    if (haveabstolvec)  
+
+    if (haveabstolvec)
       {
         ColumnVector abs_tol =
           options.getfield("AbsTol").vector_value ();
-        
+
         dae.set_tolerance (abs_tol, rel_tol);
       }
     else
       {
         realtype abs_tol =
           options.getfield("AbsTol").double_value ();
-        
+
         dae.set_tolerance (abs_tol, rel_tol);
       }
- 
+
     //Set max step
     realtype maxstep =
       options.getfield("MaxStep").double_value ();
-    
+
     dae.set_maxstep (maxstep);
 
     //Set initial step
-    if (!(options.getfield("InitialStep").is_empty ())) 
+    if (!(options.getfield("InitialStep").is_empty ()))
       {
         realtype initialstep =
           options.getfield("InitialStep").double_value ();
-        
+
         dae.set_initialstep (initialstep);
       }
 
     //Set max order FIXME: it doesn't work
     int maxorder =
       options.getfield("MaxOrder").int_value ();
-    
-    dae.set_maxorder (maxorder);  
+
+    dae.set_maxorder (maxorder);
 
     //Set Refine
     const int refine =
       options.getfield("Refine").int_value ();
-    
+
     bool haverefine =
       (refine > 1);
 
     octave_function *output_fcn = NULL;
     ColumnVector outputsel;
 
     // OutputFcn
     bool haveoutputfunction =
       options.getfield("haveoutputfunction").bool_value ();
-    
+
     if (haveoutputfunction)
-      output_fcn = options.getfield("OutputFcn").function_value ();     
+      output_fcn = options.getfield("OutputFcn").function_value ();
 
     // OutputSel
     bool haveoutputsel =
       options.getfield("haveoutputselection").bool_value ();
-    
+
     if (haveoutputsel)
-      outputsel = options.getfield("OutputSel").vector_value (); 
+      outputsel = options.getfield("OutputSel").vector_value ();
 
     octave_function *event_fcn = NULL;
 
     // Events
     bool haveeventfunction =
       options.getfield("haveeventfunction").bool_value ();
 
     if (haveeventfunction)
-      event_fcn = options.getfield("Events").function_value ();     
+      event_fcn = options.getfield("Events").function_value ();
 
     // Set up linear solver
     dae.set_up ();
 
     // Integrate
     retval = dae.integrate (numt, tspan, y0, yp0, refine,
                             haverefine, haveoutputfunction,
                             output_fcn, haveoutputsel, outputsel,
                             haveeventfunction, event_fcn);
- 
-    // Statistics 
-    bool havestats = 
+
+    // Statistics
+    bool havestats =
       options.getfield("havestats").bool_value ();
 
     if (havestats)
       dae.print_stat ();
 
     return retval;
-  }  
+  }
 }
 #endif
 
 
 DEFUN_DLD (__ode15__, args, nargout, doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{t}, @var{y} =} __ode15__ (@var{fun}, @
 @var{tspan}, @var{y0}, @var{yp0}, @var{options})
 Undocumented internal function.
@@ -1256,65 +1256,65 @@ Undocumented internal function.
 
   // Check number of parameters
   int nargin = args.length ();
 
   if (nargin != 5 || nargout != 5)
     print_usage ();
 
   // Check odefun
-  octave_function *ida_fcn = NULL; 
-  
+  octave_function *ida_fcn = NULL;
+
   octave_value f_arg = args(0);
 
   if (f_arg.is_function_handle ())
     ida_fcn = f_arg.function_value ();
   else
     error ("__ode15__: odefun must be a function handle");
 
   // Check input tspan
   ColumnVector tspan =
     args(1).xvector_value ("__ode15__: TRANGE must be a vector of numbers");
-  
+
   int numt =
     tspan.numel ();
-  
+
   realtype t0 =
     tspan (0);
 
-  if (numt < 2) 
+  if (numt < 2)
     error ("__ode15__: TRANGE must contain at least 2 elements");
   else if (!(tspan.is_sorted ()) || (tspan(0) == tspan(numt - 1)))
     error ("__ode15__: TRANGE must be strictly monotonic");
 
   // input y0 and yp0
   ColumnVector y0  =
     args(2).xvector_value ("__ode15__: initial state y0 must be a vector");
-  
+
   ColumnVector yp0 =
-    args(3).xvector_value ("__ode15__: initial state yp0 must be a vector"); 
+    args(3).xvector_value ("__ode15__: initial state yp0 must be a vector");
 
 
   if (y0.numel () != yp0.numel ())
     error ("__ode15__: initial state y0 and yp0 must have the same length");
   else if (y0.numel () < 1)
     error ("__ode15__: initial state yp0 must be a vector or a scalar");
 
 
   if (! args(4).is_map ())
     error ("__ode15__: OPTS argument must be a structure");
-    
-  octave_scalar_map options = 
+
+  octave_scalar_map options =
     args(4).xscalar_map_value ("__ode15__:",
     "OPTS argument must be a scalar structure");
- 
+
 
   return octave::do_ode15 (ida_fcn, tspan, numt, t0,
                            y0, yp0, options);
-  
+
 
 #else
 
   octave_unused_parameter (args);
   err_disabled_feature ("__ode15__", "sundials_ida, sundials_nvecserial");
 
 #endif
 }
diff --git a/run-octave.in b/run-octave.in
--- a/run-octave.in
+++ b/run-octave.in
@@ -1,26 +1,26 @@
 #! /bin/sh
 ##
 ## run-octave -- run Octave in the build tree.
 ##
 ## Copyright (C) 2006-2016 John W. Eaton
 ##
 ## This file is part of Octave.
-## 
+##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or
 ## (at your option) any later version.
-## 
+##
 ## Octave is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 : ${AWK=%AWK%}
 : ${FIND=%FIND%}
 : ${SED=%SED%}
 : ${ADDRESS_SANITIZER_OPTIONS="%ADRESS_SANITIZER_OPTIONS%"}
diff --git a/scripts/mkdoc.pl b/scripts/mkdoc.pl
--- a/scripts/mkdoc.pl
+++ b/scripts/mkdoc.pl
@@ -1,25 +1,25 @@
 #! /usr/bin/perl
 use utf8;
 
 # Copyright (C) 2012-2016 Rik Wehbring
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 3 of the License, or
 # (at your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but
 # WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 use strict;
 use warnings;
 use File::Spec;
 use Cwd;
diff --git a/scripts/ode/decic.m b/scripts/ode/decic.m
--- a/scripts/ode/decic.m
+++ b/scripts/ode/decic.m
@@ -26,17 +26,17 @@
 ## @code{length(@var{y0})} components between @var{fixed_y0} and
 ## @var{fixed_yp0} as fixed values.
 ##
 ## @var{fun} is a function handle. The function must accept three inputs where
 ## the first is time @var{t}, the second is a column vector of unknowns @var{y}
 ## and the third is a column vector of unknowns @var{yp}.
 ##
 ## @var{t0} is the initial time such that @code{@var{fun}(@var{t0},
-## @var{y0_new}, @var{yp0_new}) = 0}, specified as a scalar. 
+## @var{y0_new}, @var{yp0_new}) = 0}, specified as a scalar.
 ##
 ## @var{y0} is a vector used as initial guess for @var{y}.
 ##
 ## @var{fixed_y0} is a vector which specifies the components of @var{y0} to be
 ## hold fixed. Choose a maximum of @code{length(@var{y0})} components between
 ## @var{fixed_y0} and @var{fixed_yp0} as fixed values.
 ## Set @var{fixed_y0}(i) component to 1 if you want to fix the value of
 ## @var{y0}(i).
@@ -51,27 +51,27 @@
 ## Set @var{fixed_yp0}(i) component to 1 if you want to fix the value of
 ## @var{yp0}(i).
 ## Set @var{fixed_yp0}(i) component to 0 if you want to allow the value of
 ## @var{yp0}(i) to change.
 ##
 ## The optional seventh argument @var{options} is a structure array.
 ## Use @code{odeset} to generate this structure. The relevant options are
 ## @code{RelTol} and @code{AbsTol} which specify the error thresholds used to
-## compute the initial conditions. 
+## compute the initial conditions.
 ##
 ## The function typically returns two outputs. Variable @var{y0_new} is a
 ## column vector and contains the consistent initial value of y.  The
 ## output @var{yp0_new} is a column vector and contains the consistent initial
 ## value of yp.
 ##
-## The optional third output @var{resnorm} is the vector of norm of the 
+## The optional third output @var{resnorm} is the vector of norm of the
 ## residuals. If @var{resnorm} is small, @code{decic} has successfully computed
 ## the initial conditions. If the value of  @var{resnorm} is large, use
-## @code{RelTol} and @code{AbsTol} to adjust it.  
+## @code{RelTol} and @code{AbsTol} to adjust it.
 ##
 ## Example: Compute initial conditions of @nospell{Robetson}'s equations:
 ##
 ## @example
 ## @group
 ## function res = robertsidae(@var{t}, @var{y}, @var{yp})
 ## res = [-(@var{yp}(1) + 0.04*@var{y}(1) - 1e4*@var{y}(2)*@var{y}(3));
 ##        -(@var{yp}(2) - 0.04*@var{y}(1) + 1e4*@var{y}(2)*@var{y}(3) +
@@ -86,95 +86,95 @@
 ## @end deftypefn
 
 function [y0_new, yp0_new, resnrm] = decic (odefun, t0, y0, fixed_y0, yp0,
                                             fixed_yp0, options)
 
   if (nargin < 6 || nargin > 7 || nargout > 3)
     print_usage ();
   endif
- 
+
   #Check input
   if (! isa (odefun, "function_handle"))
     error ("Octave:invalid-input-arg",
            "decic: FUN must be a valid function handle");
   endif
 
   if (! isnumeric (t0) || numel (t0) != 1)
     error ("Octave:invalid-input-arg",
            "decic: INIT must be a numeric scalar value");
   endif
 
   if (! isnumeric (y0) || ! isvector (y0) || ! isnumeric (fixed_y0) ||
-      ! isvector (fixed_y0) || ! isnumeric (yp0) || ! isvector (yp0)|| 
+      ! isvector (fixed_y0) || ! isnumeric (yp0) || ! isvector (yp0)||
       ! isnumeric (fixed_yp0) || ! isvector (fixed_yp0))
    error ("Octave:invalid-input-arg",
            "decic: y0, fixed_y0, yp0 and fixed_yp0 must be numeric vectors");
-  
+
   elseif (! isequal (numel (y0), numel (fixed_y0), numel (yp0),
           numel (fixed_yp0)))
     error ("Octave:invalid-input-arg",
            "decic: length of y0, fixed_y0, yp0 and fixed_yp0 must be equal");
   endif
 
   for i = 1:numel (y0)
     if (! (fixed_y0(i) == 0 || fixed_y0(i) == 1) || ! (fixed_yp0(i) == 0
         || fixed_yp0(i) == 1))
       error ("Octave:invalid-input-arg",
              "decic: fixed_y0 and fixed_yp0 must be boolean vectors");
     endif
   endfor
-  
+
   n  = numel (y0);
   nl = sum (~fixed_y0);
   nu = sum (~fixed_yp0);
- 
+
   if (n - nl - nu > 0)
     error ("Octave:invalid-input-arg",
            "decic: you cannot fix more than length(y0) components");
   endif
 
   #Set default value
   TolFun = 0;
   TolX   = eps;
-  
+
   #Check AbsTol and RelTol
   if (nargin == 7)
     if (! isempty (options.AbsTol))
       if (! isscalar (options.AbsTol))
         error ("Octave:invalid-input-arg",
                "decic: AbsTol must be a scalar value");
       else
-        TolFun = options.AbsTol; 
+        TolFun = options.AbsTol;
       endif
     endif
 
     if (! isempty (options.RelTol))
       if (! isscalar (options.RelTol))
         error ("Octave:invalid-input-arg",
                "decic: RelTol must be a scalar value");
       else
-        TolX = options.RelTol; 
+        TolX = options.RelTol;
       endif
     endif
   endif
 
   x0 = [y0(~fixed_y0); yp0(~fixed_yp0)];
   opt = optimset ('tolfun', TolFun, 'tolx', TolX, 'display', 'iter-detailed');
   x = fminunc (@(x) objective (x, t0, y0, fixed_y0, yp0, fixed_yp0, nl, nu,
                                odefun),
                x0, opt);
-  
+
   y0_new  = y0;
   yp0_new = yp0;
-  
+
   y0_new(~fixed_y0)   = x(1:nl);
   yp0_new(~fixed_yp0) = x(nl+1:nl+nu);
   resnrm = odefun (t0, y0_new, yp0_new);
- 
+
 endfunction
 
 function res = objective (x, t0, y0, fixed_y0, yp0,
                           fixed_yp0, nl, nu, odefun)
   y = y0;
   y(~fixed_y0) = x(1:nl);
   yp = yp0;
   yp(~fixed_yp0) = x(nl+1:nl+nu);
@@ -182,22 +182,22 @@ function res = objective (x, t0, y0, fix
 endfunction
 
 %!function res = rob (t, y, yp)
 %! res =[-(yp(1) + 0.04*y(1) - 1e4*y(2)*y(3)); -(yp(2) - 0.04*y(1) +
 %!      + 1e4*y(2)*y(3) + 3e7*y(2)^2); y(1) + y(2) + y(3) - 1];
 %!endfunction
 
 %!test  # Without options
-%! ref1 = [1;0;0]; 
+%! ref1 = [1;0;0];
 %! ref2 = [-4e-2; 4e-2; 0];
 %! [ynew,ypnew] = decic (@rob,0,[1;0;0],[1;1;0],[23;110;0],[0;0;1]);
 %! assert ([ynew(1:end), ypnew(1:end)], [ref1(1:end), ref2(1:end)], 1e-10);
 %!test  # With options
-%! ref1 = [1;0;0]; 
+%! ref1 = [1;0;0];
 %! ref2 = [-4e-2; 4e-2; 0];
 %! opt = odeset ("AbsTol", 1e-8, "RelTol", 1e-4);
 %! [ynew,ypnew] = decic (@rob,0,[1;0;0],[1;1;0],[23;110;0],[0;0;1],opt);
 %! assert ([ynew(1:end), ypnew(1:end)], [ref1(1:end), ref2(1:end)], 1e-5);
 
 ## Test input validation
 %!error decic ()
 %!error decic (1)
diff --git a/scripts/ode/ode15i.m b/scripts/ode/ode15i.m
--- a/scripts/ode/ode15i.m
+++ b/scripts/ode/ode15i.m
@@ -17,26 +17,26 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {} {[@var{t}, @var{y}] =} ode15i (@var{fun}, @var{trange}, @var{y0}, @var{yp0})
 ## @deftypefnx {} {[@var{t}, @var{y}] =} ode15i (@var{fun}, @var{trange}, @var{y0}, @var{yp0}, @var{ode_opt})
 ## @deftypefnx {} {[@var{t}, @var{y}, @var{te}, @var{ye}, @var{ie}] =} ode15i (@dots{})
 ## @deftypefnx {} {@var{solution} =} ode15i (@dots{})
 ##
-## Solve a set of full-implicit Ordinary Differential Equations and 
+## Solve a set of full-implicit Ordinary Differential Equations and
 ## Differential Algebraic Equations (DAEs) of index 1, with the variable-step,
 ## variable order BDF (Backward Differentiation Formula) method, which
 ## ranges from order 1 to 5.
 ##
 ## @var{fun} is a function handle, inline function, or string containing the
 ## name of the function that defines the ODE: @code{f(@var{t},@var{y},@var{yp})}.
 ## The function must accept three inputs where the first is time @var{t}, the
 ## second is a column vector of unknowns @var{y} and the third is a column
-## vector of unknowns @var{yp}. 
+## vector of unknowns @var{yp}.
 ##
 ## @var{trange} specifies the time interval over which the ODE will be
 ## evaluated.  Typically, it is a two-element vector specifying the initial and
 ## final times (@code{[tinit, tfinal]}).  If there are more than two elements
 ## then the solution will also be evaluated at these intermediate time.
 ##
 ## @var{y0} and @var{yp0} contain the initial values for the unknowns @var{y}
 ## and @var{yp}.  If they are row vectors then the solution @var{y} will be a
@@ -87,33 +87,33 @@
 ## [@var{t},@var{y}] = ode15i (@@robertsidae, [0 1e3], [1; 0; 0],[-1e-4; 1e-4; 0]);
 ## @end group
 ## @end example
 ## @seealso{decic, odeset, odeget}
 ## @end deftypefn
 
 function varargout = ode15i (fun, trange, y0, yp0, varargin)
 
-  solver = 'ode15i';  
- 
+  solver = 'ode15i';
+
   if (nargin < 4)
     print_usage ();
   endif
-  
+
   n = numel (y0);
-  
+
   if (nargin > 4)
    options = varargin{1};
   else
    options = odeset ();
   endif
 
   ## Check fun, trange, y0, yp0
   fun = check_default_input (fun, trange, solver, y0, yp0);
-  
+
   if (! isempty (options.Jacobian))
     if (ischar (options.Jacobian))
       try
         options.Jacobian = str2func (options.Jacobian);
       catch
         warning (lasterr);
       end_try_catch
       if (! isa (options.Jacobian, "function_handle"))
@@ -152,17 +152,17 @@ function varargout = ode15i (fun, trange
   endif
 
   [defaults, classes, attributes] = ...
   odedefaults (n, trange(1), trange(end));
 
   persistent ignorefields = {"NonNegative", "Mass", ...
                              "MStateDependence", "MvPattern", ...
                              "MassSingular", "InitialSlope", "BDF"};
-  
+
   defaults   = rmfield (defaults, ignorefields);
   classes    = rmfield (classes, ignorefields);
   attributes = rmfield (attributes, ignorefields);
 
   classes        = odeset (classes, 'Vectorized', {});
   attributes     = ...
   odeset (attributes, 'Jacobian', {}, 'Vectorized', {});
 
@@ -172,17 +172,17 @@ function varargout = ode15i (fun, trange
 
   ## Jacobian
   options.havejac       = false;
   options.havejacsparse = false;
   options.havejacfun    = false;
 
   if (! isempty (options.Jacobian))
     options.havejac = true;
-    if (iscell (options.Jacobian)) 
+    if (iscell (options.Jacobian))
       if (numel (options.Jacobian) == 2)
         if (issparse (options.Jacobian{1}) && issparse (options.Jacobian{2})) ## Jac is sparse cell
           options.havejacsparse = true;
         endif
 
         if (any (size (options.Jacobian{1}) != [n n])
             || any (size (options.Jacobian{2}) != [n n])
             || ! isnumeric (options.Jacobian{1})
@@ -192,17 +192,17 @@ function varargout = ode15i (fun, trange
           error ("Octave:invalid-input-arg",
                [solver ": invalid value assigned to field '%s'"], "Jacobian");
         endif
       else
         error ("Octave:invalid-input-arg",
                [solver ": invalid value assigned to field '%s'"], "Jacobian");
       endif
 
-    elseif (isa (options.Jacobian, "function_handle"))  
+    elseif (isa (options.Jacobian, "function_handle"))
       options.havejacfun = true;
       if (nargin (options.Jacobian) == 3)
         [A, B] = options.Jacobian (trange(1), y0, yp0);
         if (issparse (A) && issparse (B))
           options.havejacsparse = true;  ## Jac is sparse fun
         endif
 
         if (any (size (A) != [n n]) || any (size (B) != [n n])
@@ -215,67 +215,67 @@ function varargout = ode15i (fun, trange
         error ("Octave:invalid-input-arg",
                [solver ": invalid value assigned to field '%s'"], "Jacobian");
       endif
     else
         error ("Octave:invalid-input-arg",
                [solver ": invalid value assigned to field '%s'"], "Jacobian");
     endif
   endif
-  
+
   ## Abstol and Reltol
 
   options.haveabstolvec = false;
 
   if (numel (options.AbsTol) != 1 && numel (options.AbsTol) != n)
     error ("Octave:invalid-input-arg",
            [solver ": invalid value assigned to field '%s'"], "AbsTol");
-  
+
   elseif (numel (options.AbsTol) == n)
     options.haveabstolvec = true;
   endif
 
   ## Stats
-  options.havestats = false;    
+  options.havestats = false;
   if (strcmp (options.Stats, "on"))
-    options.havestats = true;    
+    options.havestats = true;
   endif
 
   ## Don't use Refine when the output is a structure
   if (nargout == 1)
     options.Refine = 1;
   endif
 
   ## OutputFcn and OutputSel
   if (isempty (options.OutputFcn) && nargout == 0)
     options.OutputFcn = @odeplot;
     options.haveoutputfunction = true;
   else
     options.haveoutputfunction = ! isempty (options.OutputFcn);
   endif
-  
+
   options.haveoutputselection = ! isempty (options.OutputSel);
   if (options.haveoutputselection)
     options.OutputSel = options.OutputSel - 1;
   endif
 
   ## Events
   options.haveeventfunction = ! isempty (options.Events);
 
 
   [t, y, te, ye, ie] = __ode15__ (fun, trange, y0, yp0, options);
-  
+
 
   if (nargout == 2)
     varargout{1} = t;
     varargout{2} = y;
   elseif (nargout == 1)
     varargout{1}.x = t;    # Time stamps are saved in field x
     varargout{1}.y = y;    # Results are saved in field y
-    varargout{1}.solver = solver; 
+    varargout{1}.solver = solver;
     if (options.haveeventfunction)
       varargout{1}.xe = te;  # Time info when an event occurred
       varargout{1}.ye = ye;  # Results when an event occurred
       varargout{1}.ie = ie;  # Index info which event occurred
     endif
   elseif (nargout == 5)
     varargout = cell (1,5);
     varargout{1} = t;
@@ -284,28 +284,28 @@ function varargout = ode15i (fun, trange
       varargout{3} = te;  # Time info when an event occurred
       varargout{4} = ye;  # Results when an event occurred
       varargout{5} = ie;  # Index info which event occurred
     endif
   endif
 
 endfunction
 
-%!demo 
-%! 
+%!demo
+%!
 %! ##Solve Robertson's equations with ode15i
 %! fun = @ (t, y, yp) [-(yp(1) + 0.04*y(1) - 1e4*y(2)*y(3));
 %!                     -(yp(2) - 0.04*y(1) + 1e4*y(2)*y(3) + 3e7*y(2)^2);
 %!                     y(1) + y(2) + y(3) - 1];
 %!
 %! opt = odeset ('RelTol',1e-4, 'AbsTol', [1e-8, 1e-14, 1e-6]);
 %! y0 = [1; 0; 0];
 %! yp0 = [-1e-4; 1e-4; 0];
 %! tspan = [0 4*logspace(-6, 6)];
-%! 
+%!
 %! [t, y] = ode15i (fun, tspan, y0, yp0, opt);
 %!
 %! y (:,2) = 1e4 * y (:, 2);
 %! figure (2);
 %! semilogx (t, y, 'o')
 %! xlabel ('time');
 %! ylabel ('species concentration');
 %! title ('Robertson DAE problem with a Conservation Law');
@@ -326,50 +326,50 @@ endfunction
 %!endfunction
 %!
 %!function [DFDY, DFDYP] = jacfundense(t, y, yp)
 %!  DFDY = [-0.04,           1e4*y(3),  1e4*y(2);
 %!           0.04, -1e4*y(3)-6e7*y(2), -1e4*y(2);
 %!              1,                  1,         1];
 %!  DFDYP = [-1,  0, 0;
 %!            0, -1, 0;
-%!            0,  0, 0];   
+%!            0,  0, 0];
 %!endfunction
 %!
 %!function [DFDY, DFDYP] = jacfunsparse(t, y, yp)
 %!  DFDY = sparse ([-0.04,           1e4*y(3),  1e4*y(2);
 %!                   0.04, -1e4*y(3)-6e7*y(2), -1e4*y(2);
 %!                      1,                  1,         1]);
 %!  DFDYP = sparse ([-1,  0, 0;
 %!                    0, -1, 0;
-%!                    0,  0, 0]);   
+%!                    0,  0, 0]);
 %!endfunction
 %!function [DFDY, DFDYP] = jacwrong(t, y, yp)
 %!  DFDY = [-0.04,           1e4*y(3);
 %!           0.04, -1e4*y(3)-6e7*y(2)];
 %!  DFDYP = [-1,  0;
 %!            0, -1];
 %!endfunction
 %!function [DFDY, DFDYP, A] = jacwrong2(t, y, yp)
 %!  DFDY = [-0.04,           1e4*y(3),  1e4*y(2);
 %!           0.04, -1e4*y(3)-6e7*y(2), -1e4*y(2);
 %!              1,                  1,         1];
 %!  DFDYP = [-1,  0, 0;
 %!            0, -1, 0;
 %!            0,  0, 0];
-%!  A = DFDY;   
+%!  A = DFDY;
 %!endfunction
 %!function [val, isterminal, direction] = ff (t, y, yp)
 %!  isterminal = [0 1];
 %!  if (t < 1e1)
 %!    val = [-1, -2];
 %!  else
 %!    val = [1 3];
 %!  endif
-%!  
+%!
 %!  direction = [1 0];
 %!endfunction
 
 %!test  # anonymous function instead of real function
 %! ref = [0.049787079136413];
 %! ff = @(t, u, udot)  udot + 3 * u;
 %! [t, y] = ode15i (ff, 0:1, 1, -3);
 %! assert ([t(end), y(end)], [1, ref], 1e-3);
@@ -382,17 +382,17 @@ endfunction
 %!test  # numel(trange) = 2 final value
 %! [t, y] = ode15i (@rob,[0 100], [1;0;0], [-1e-4;1e-4;0]);
 %! assert ([t(end), y(end,:)], fref, 1e-5);
 %!test  # With empty options
 %! opt = odeset();
 %! [t, y] = ode15i (@rob,[0 1e6 2e6 3e6 4e6], [1;0;0], [-1e-4;1e-4;0], opt);
 %! assert ([t(end), y(end,:)], fref2, 1e-3);
 %! opt = odeset();
-%!test  # Without options 
+%!test  # Without options
 %! [t, y] = ode15i (@rob,[0 1e6 2e6 3e6 4e6], [1;0;0], [-1e-4;1e-4;0]);
 %! assert ([t(end), y(end,:)], fref2, 1e-3);
 %!test  # InitialStep option
 %! opt = odeset ("InitialStep", 1e-8);
 %! [t, y] = ode15i (@rob,[0 100], [1;0;0], [-1e-4;1e-4;0], opt);
 %! assert ([t(2)-t(1)], [1e-8], 1e-9);
 %!test  # MaxStep option
 %! opt = odeset ("MaxStep", 1e-3);
@@ -466,17 +466,17 @@ endfunction
 %! assert (isfield (sol, "ie"));
 %! assert (sol.ie, [0;1]);
 %! assert (isfield (sol, "xe"));
 %! assert (isfield (sol, "ye"));
 %! assert (sol.x(end), 10, 1);
 %!test  # Events option, five output arguments
 %! opt = odeset ("Events", @ff);
 %! [t, y, te, ye, ie] = ode15i (@rob,[0 100], [1;0;0], [-1e-4;1e-4;0], opt);
-%! assert ([t(end), te', ie'], [10, 10, 10, 0, 1], [1, 0.2, 0.2, 0, 0]); 
+%! assert ([t(end), te', ie'], [10, 10, 10, 0, 1], [1, 0.2, 0.2, 0, 0]);
 
 %!error  # Jacobian fun wrong dimension
 %! opt = odeset ("Jacobian", @jacwrong);
 %! [t, y] = ode15i (@rob,[0 4e6], [1;0;0], [-1e-4;1e-4;0], opt);
 %!error  # Jacobian cell dense wrong dimension
 %!  DFDY = [-0.04, 1;
 %!           0.04, 1];
 %!  DFDYP = [-1,  0, 0;
@@ -500,17 +500,17 @@ endfunction
 %! opt = odeset ("Jacobian", [1 2 3; 4 5 6; 7 8 9]);
 %! [t, y] = ode15i (@rob,[0 4e6], [1;0;0], [-1e-4;1e-4;0], opt);
 %!error  # Jacobian single matrix wrong dimension
 %! opt = odeset ("Jacobian", [1 2 3; 4 5 6]);
 %! [t, y] = ode15i (@rob,[0 4e6], [1;0;0], [-1e-4;1e-4;0], opt);
 %!error  # Jacobian strange field
 %! opt = odeset ("Jacobian", "foo");
 %! [t, y] = ode15i (@rob,[0 4e6], [1;0;0], [-1e-4;1e-4;0], opt);
-%!function ydot = fun (t, y, yp)  
+%!function ydot = fun (t, y, yp)
 %! ydot = [y - yp];
 %!endfunction
 %!error ode15i ();
 %!error ode15i (1);
 %!error ode15i (1, 1, 1);
 %!error ode15i (1, 1, 1);
 %!error ode15i (1, 1, 1, 1);
 %!error ode15i (1, 1, 1, 1, 1);
diff --git a/scripts/ode/ode15s.m b/scripts/ode/ode15s.m
--- a/scripts/ode/ode15s.m
+++ b/scripts/ode/ode15s.m
@@ -80,27 +80,27 @@
 ## [@var{t},@var{y}] = ode15s (@@robertsidae, [0 1e3], [1; 0; 0], opt);
 ## @end group
 ## @end example
 ## @seealso{decic, odeset, odeget}
 ## @end deftypefn
 
 function varargout = ode15s (fun, trange, y0, varargin)
 
-  solver = 'ode15s';  
- 
+  solver = 'ode15s';
+
   if (nargin < 3)
     print_usage ();
   endif
-  
+
   ## Check fun, trange, y0, yp0
   fun = check_default_input (fun, trange, solver, y0);
-  
+
   n = numel (y0);
-  
+
   if (nargin > 3)
    options = varargin{1};
   else
    options = odeset ();
   endif
 
   if (! isempty (options.Mass))
     if (ischar (options.Mass))
@@ -109,17 +109,17 @@ function varargout = ode15s (fun, trange
       catch
         warning (lasterr);
       end_try_catch
       if (! isa (options.Mass, "function_handle"))
         error ("Octave:invalid-input-arg",
                [solver ": invalid value assigned to field '%s'"], "Mass");
       endif
     endif
-  endif  
+  endif
 
   if (! isempty (options.Jacobian))
     if (ischar (options.Jacobian))
       try
         options.Jacobian = str2func (options.Jacobian);
       catch
         warning (lasterr);
       end_try_catch
@@ -172,17 +172,17 @@ function varargout = ode15s (fun, trange
   ## Mass
 
   options.havemassfun    = false;
   options.havestatedep   = false;
   options.havetimedep    = false;
   options.havemasssparse = false;
 
   if (! isempty (options.Mass))
-    if (isa (options.Mass, "function_handle"))  
+    if (isa (options.Mass, "function_handle"))
       options.havemassfun = true;
       if (nargin (options.Mass) == 2)
         options.havestatedep = true;
         M = options.Mass (trange(1), y0);
         options.havemasssparse = issparse (M);
         if (any (size (M) != [n n]) || ! isnumeric (M) || ! isreal (M))
           error ("Octave:invalid-input-arg",
                [solver ": invalid value assigned to field '%s'"], "Mass");
@@ -201,31 +201,31 @@ function varargout = ode15s (fun, trange
       endif
     elseif (ismatrix (options.Mass))
       options.havemasssparse = issparse (options.Mass);
       if (any (size (options.Mass) != [n n]) ||
           ! isnumeric (options.Mass) || ! isreal (options.Mass))
         error ("Octave:invalid-input-arg",
                 [solver ": invalid value assigned to field '%s'"], "Mass");
       endif
-    else 
+    else
       error ("Octave:invalid-input-arg",
               [solver ": invalid value assigned to field '%s'"], "Mass");
     endif
   endif
 
 
   ## Jacobian
   options.havejac       = false;
   options.havejacsparse = false;
   options.havejacfun    = false;
 
   if (! isempty (options.Jacobian))
     options.havejac = true;
-    if (isa (options.Jacobian, "function_handle"))  
+    if (isa (options.Jacobian, "function_handle"))
       options.havejacfun = true;
       if (nargin (options.Jacobian) == 2)
         [A] = options.Jacobian (trange(1), y0);
         if (issparse (A))
           options.havejacsparse = true;  ## Jac is sparse fun
         endif
         if (any (size (A) != [n n]) || ! isnumeric (A) || ! isreal (A))
           error ("Octave:invalid-input-arg",
@@ -257,70 +257,70 @@ function varargout = ode15s (fun, trange
       options.Jacobian = [];
       warning ("ode15s:mass_state_dependent_provided",
               ["with MStateDependence != 'none' an internal", ...
                " approximation of Jacobian Matrix will be used.", ...
                " Set MStateDependence equal to 'none' if you want ", ...
                " to provide a constant or time-dependent Jacobian"]);
     endif
   endif
-  
+
   ## Use sparse methods only if all matrices are sparse
   if (! options.havemasssparse)
-    options.havejacsparse = false; 
-  endif       
-  
-  ## If Mass or Jacobian is fun, then new Jacobian is fun  
+    options.havejacsparse = false;
+  endif
+
+  ## If Mass or Jacobian is fun, then new Jacobian is fun
   if (options.havejac)
     if (options.havejacfun || options.havetimedep)
       options.Jacobian = @ (t, y, yp) wrapjacfun (t, y, yp,
                                                   options.Jacobian,
                                                   options.Mass,
                                                   options.havetimedep,
                                                   options.havejacfun);
       options.havejacfun = true;
     else   ## All matrices are constant
       options.Jacobian = {[- options.Jacobian], [options.Mass]};
-           
+
     endif
   endif
 
 
 
   ## Abstol and Reltol
 
   options.haveabstolvec = false;
 
   if (numel (options.AbsTol) != 1 && numel (options.AbsTol) != n)
     error ("Octave:invalid-input-arg",
            [solver ": invalid value assigned to field '%s'"], "AbsTol");
-  
+
   elseif (numel (options.AbsTol) == n)
     options.haveabstolvec = true;
   endif
 
   ## Stats
-  options.havestats = false;    
+  options.havestats = false;
   if (strcmp (options.Stats, "on"))
-    options.havestats = true;    
+    options.havestats = true;
   endif
 
   ## Don't use Refine when the output is a structure
   if (nargout == 1)
     options.Refine = 1;
   endif
 
   ## OutputFcn and OutputSel
   if (isempty (options.OutputFcn) && nargout == 0)
     options.OutputFcn = @odeplot;
     options.haveoutputfunction = true;
   else
     options.haveoutputfunction = ! isempty (options.OutputFcn);
   endif
-  
+
   options.haveoutputselection = ! isempty (options.OutputSel);
   if (options.haveoutputselection)
     options.OutputSel = options.OutputSel - 1;
   endif
 
   ## Events
   options.haveeventfunction = ! isempty (options.Events);
 
@@ -334,17 +334,17 @@ function varargout = ode15s (fun, trange
                                   trange, y0, yp0, options);
 
   if (nargout == 2)
     varargout{1} = t;
     varargout{2} = y;
   elseif (nargout == 1)
     varargout{1}.x = t;    # Time stamps are saved in field x
     varargout{1}.y = y;    # Results are saved in field y
-    varargout{1}.solver = solver; 
+    varargout{1}.solver = solver;
     if (options.haveeventfunction)
       varargout{1}.xe = te;  # Time info when an event occurred
       varargout{1}.ye = ye;  # Results when an event occurred
       varargout{1}.ie = ie;  # Index info which event occurred
     endif
   elseif (nargout == 5)
     varargout = cell (1,5);
     varargout{1} = t;
@@ -355,58 +355,58 @@ function varargout = ode15s (fun, trange
       varargout{5} = ie;  # Index info which event occurred
     endif
   endif
 
 endfunction
 
 function res = wrap (t, y, yp, Mass, havetimedep, havestatedep, fun)
 
-  if (! isempty (Mass) && havestatedep)  
+  if (! isempty (Mass) && havestatedep)
     res = Mass (t, y) * yp - fun (t, y);
   elseif (! isempty (Mass) && havetimedep)
     res = Mass (t) * yp - fun (t, y);
   elseif (! isempty (Mass))
     res = Mass * yp - fun (t, y);
   else
     res = yp - fun (t, y);
   endif
 
 endfunction
 
 function [jac, jact] = wrapjacfun (t, y, yp, Jac, Mass,
-                                   havetimedep, havejacfun) 
+                                   havetimedep, havejacfun)
   if (havejacfun)
     jac = - Jac (t, y);
   else
     jac = - Jac;
   endif
 
-  if (! isempty (Mass) && havetimedep) 
+  if (! isempty (Mass) && havetimedep)
     jact = Mass (t);
   elseif (! isempty (Mass))
     jact = Mass;
   else
     jact = speye (numel (y));
   endif
-  
+
 endfunction
 
 
 %!demo
-%! 
-%! ##Solve Robertson's equations with ode15s 
+%!
+%! ##Solve Robertson's equations with ode15s
 %! fun = @ (t, y) [-0.04*y(1) + 1e4*y(2).*y(3);
 %!                  0.04*y(1) - 1e4*y(2).*y(3) - 3e7*y(2).^2;
 %!                  y(1) + y(2) + y(3) - 1 ];
 %!
 %! y0 = [1; 0; 0];
 %! tspan = [0 4*logspace(-6, 6)];
 %! M = [1 0 0; 0 1 0; 0 0 0];
-%!  
+%!
 %! options = odeset ('RelTol', 1e-4, 'AbsTol', [1e-6 1e-10 1e-6],
 %!                   'MStateDependence', 'none', 'Mass', M);
 %!
 %! [t, y] = ode15s (fun, tspan, y0, options);
 %!
 %! y (:,2) = 1e4 * y (:,2);
 %! figure (2);
 %! semilogx (t, y, 'o')
@@ -444,140 +444,140 @@ endfunction
 %!endfunction
 %!function [val, isterminal, direction] = feve (t, y)
 %!  isterminal = [0 1];
 %!  if (t < 1e1)
 %!    val = [-1, -2];
 %!  else
 %!    val = [1 3];
 %!  endif
-%!  
+%!
 %!  direction = [1 0];
 %!endfunction
 %!function masrob = massdensefunstate (t, y)
-%! masrob = [1 0 0; 0 1 0; 0 0 0];     
+%! masrob = [1 0 0; 0 1 0; 0 0 0];
 %!endfunction
 %!function masrob = masssparsefunstate (t, y)
-%! masrob = sparse([1 0 0; 0 1 0; 0 0 0]);     
+%! masrob = sparse([1 0 0; 0 1 0; 0 0 0]);
 %!endfunction
 %!function masrob = massdensefuntime (t)
-%! masrob = [1 0 0; 0 1 0; 0 0 0];     
+%! masrob = [1 0 0; 0 1 0; 0 0 0];
 %!endfunction
 %!function masrob = masssparsefuntime (t)
-%! masrob = sparse([1 0 0; 0 1 0; 0 0 0]);     
+%! masrob = sparse([1 0 0; 0 1 0; 0 0 0]);
 %!endfunction
 %!function jac = jacfundense (t, y)
 %!  jac = [-0.04,           1e4*y(3),  1e4*y(2);
 %!           0.04, -1e4*y(3)-6e7*y(2), -1e4*y(2);
 %!              1,                  1,         1];
 %!endfunction
 %!function jac = jacfunsparse (t, y)
 %!  jac = sparse([-0.04,           1e4*y(3),  1e4*y(2);
 %!                 0.04, -1e4*y(3)-6e7*y(2), -1e4*y(2);
 %!                    1,                  1,         1]);
 %!endfunction
 
 
 
 %!test
-%! opt = odeset ("MStateDependence", "none", 
+%! opt = odeset ("MStateDependence", "none",
 %!                "Mass", [1 0 0; 0 1 0; 0 0 0]);
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
 %!test
-%! opt = odeset ("MStateDependence", "none", 
+%! opt = odeset ("MStateDependence", "none",
 %!                "Mass", sparse([1 0 0; 0 1 0; 0 0 0]));
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
 %!test
-%! opt = odeset ("MStateDependence", "none", 
+%! opt = odeset ("MStateDependence", "none",
 %!                "Mass", @massdensefunstate);
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
 %!test
-%! opt = odeset ("MStateDependence", "none", 
+%! opt = odeset ("MStateDependence", "none",
 %!                "Mass", @masssparsefunstate);
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
 %!test
-%! opt = odeset ("MStateDependence", "none", 
+%! opt = odeset ("MStateDependence", "none",
 %!                "Mass", 'massdensefuntime');
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
-%! assert ([t(end), y(end,:)], frefrob, 1e-3);  
-%!test 
-%!  opt = odeset ("MStateDependence", "none", 
+%! assert ([t(end), y(end,:)], frefrob, 1e-3);
+%!test
+%!  opt = odeset ("MStateDependence", "none",
 %!                "Mass", [1 0 0; 0 1 0; 0 0 0],
 %!                "Jacobian", 'jacfundense');
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
 %!test
-%! opt = odeset ("MStateDependence", "none", 
+%! opt = odeset ("MStateDependence", "none",
 %!                "Mass", sparse([1 0 0; 0 1 0; 0 0 0]),
-%!                "Jacobian", @jacfundense); 
+%!                "Jacobian", @jacfundense);
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
-%!test              
+%!test
 %! warning ("off", "ode15s:mass_state_dependent_provided", "local");
-%!  opt = odeset ("MStateDependence", "none", 
+%!  opt = odeset ("MStateDependence", "none",
 %!                "Mass", @massdensefunstate,
 %!                "Jacobian", @jacfundense);
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
 %!test
 %! warning ("off", "ode15s:mass_state_dependent_provided", "local");
-%!  opt = odeset ("MStateDependence", "none", 
+%!  opt = odeset ("MStateDependence", "none",
 %!                "Mass", @masssparsefunstate,
 %!                "Jacobian", @jacfundense);
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
 %!test
-%!  opt = odeset ("MStateDependence", "none", 
+%!  opt = odeset ("MStateDependence", "none",
 %!                "Mass", @massdensefuntime,
 %!                "Jacobian", @jacfundense);
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
-%! assert ([t(end), y(end,:)], frefrob, 1e-3);    
-%!  opt = odeset ("MStateDependence", "none", 
+%! assert ([t(end), y(end,:)], frefrob, 1e-3);
+%!  opt = odeset ("MStateDependence", "none",
 %!                "Mass", 'masssparsefuntime',
 %!                "Jacobian", 'jacfundense');
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
-%! assert ([t(end), y(end,:)], frefrob, 1e-3);  
-%!test              
-%!  opt = odeset ("MStateDependence", "none", 
+%! assert ([t(end), y(end,:)], frefrob, 1e-3);
+%!test
+%!  opt = odeset ("MStateDependence", "none",
 %!                "Mass", [1 0 0; 0 1 0; 0 0 0],
 %!                "Jacobian", @jacfunsparse);
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
 %!test
-%!  opt = odeset ("MStateDependence", "none", 
+%!  opt = odeset ("MStateDependence", "none",
 %!                "Mass", sparse([1 0 0; 0 1 0; 0 0 0]),
-%!               "Jacobian", @jacfunsparse); 
+%!               "Jacobian", @jacfunsparse);
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
-%! assert ([t(end), y(end,:)], frefrob, 1e-3); 
-%!test             
+%! assert ([t(end), y(end,:)], frefrob, 1e-3);
+%!test
 %! warning ("off", "ode15s:mass_state_dependent_provided", "local");
-%!  opt = odeset ("MStateDependence", "none", 
+%!  opt = odeset ("MStateDependence", "none",
 %!                "Mass", @massdensefunstate,
 %!                "Jacobian", @jacfunsparse);
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
 %!test
 %! warning ("off", "ode15s:mass_state_dependent_provided", "local");
-%!  opt = odeset ("MStateDependence", "none", 
+%!  opt = odeset ("MStateDependence", "none",
 %!                "Mass", @masssparsefunstate,
 %!                "Jacobian", @jacfunsparse);
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
 %!test
-%!  opt = odeset ("MStateDependence", "none", 
+%!  opt = odeset ("MStateDependence", "none",
 %!                "Mass", @massdensefuntime,
-%!                "Jacobian", @jacfunsparse);  
+%!                "Jacobian", @jacfunsparse);
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
-%! assert ([t(end), y(end,:)], frefrob, 1e-3); 
-%!test 
-%!  opt = odeset ("MStateDependence", "none", 
+%! assert ([t(end), y(end,:)], frefrob, 1e-3);
+%!test
+%!  opt = odeset ("MStateDependence", "none",
 %!                "Mass", @masssparsefuntime,
 %!                "Jacobian", @jacfunsparse);
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
 %!test  # two output arguments
 %! [t, y] = ode15s (@fpol, [0 2], [2 0]);
 %! assert ([t(end), y(end,:)], [2, fref], 1e-2);
 %!test  # anonymous function instead of real function
@@ -668,18 +668,17 @@ endfunction
 %! assert (sol.ie, [0;1]);
 %! assert (isfield (sol, "xe"));
 %! assert (isfield (sol, "ye"));
 %! assert (sol.x(end), 10, 1);
 %!test  # Events option, five output arguments
 %! opt = odeset ("Events", @feve, "Mass", @massdensefunstate,
 %!               "MStateDependence", "none");
 %! [t, y, te, ye, ie] = ode15s (@rob,[0 100], [1;0;0], opt);
-%! assert ([t(end), te', ie'], [10, 10, 10, 0, 1], [1, 0.5, 0.5, 0, 0]); 
+%! assert ([t(end), te', ie'], [10, 10, 10, 0, 1], [1, 0.5, 0.5, 0, 0]);
 
 
 
 
 
 
 
 
-
diff --git a/scripts/ode/private/check_default_input.m b/scripts/ode/private/check_default_input.m
--- a/scripts/ode/private/check_default_input.m
+++ b/scripts/ode/private/check_default_input.m
@@ -32,20 +32,20 @@ function [fun] = check_default_input (fu
     catch
       warning (lasterr);
     end_try_catch
   endif
   if (! isa (fun, "function_handle"))
     error ("Octave:invalid-input-arg",
                [solver ": invalid value assigned to field '%s'"], "fun");
   endif
-  
-  ## Check trange 
+
+  ## Check trange
   validateattributes (trange, {"float"}, {"vector", "real"}, solver, "trange");
-  
+
   if (numel (trange) < 2)
        error ("Octave:invalid-input-arg",
                [solver ": invalid value assigned to field '%s'"], "trange");
   elseif (! ((all (diff (trange) > 0)) || all (diff (-trange) > 0)))
         error ("Octave:invalid-input-arg",
                [solver ": invalid value assigned to field '%s'"], "trange");
   endif
 
@@ -56,10 +56,10 @@ function [fun] = check_default_input (fu
     yp0 = varargin{2};
     n = numel (feval (fun, trange(1), y0, yp0));
     validateattributes (yp0, {"float"}, {"numel", n}, solver, "yp0");
   else
     n = numel (feval (fun, trange (1), y0));
   endif
 
   validateattributes (y0, {"float"}, {"numel", n}, solver, "y0");
- 
+
 endfunction
diff --git a/scripts/plot/draw/isonormals.m b/scripts/plot/draw/isonormals.m
--- a/scripts/plot/draw/isonormals.m
+++ b/scripts/plot/draw/isonormals.m
@@ -190,16 +190,16 @@ endfunction
 %!error isonormals (1)
 %!error isonormals (1,2,3)
 %!error isonormals (1,2,3,4)
 %!error isonormals (1,2,3,4,5,6)
 %!error <Unknown option 'foo'> isonormals (x, y, z, val, vert, "foo")
 %!error <must be a list of vertices> isonormals (1, {1})
 %!error <must be a list of vertices> isonormals (1, [1 2 3 4])
 %!error <must be a .* patch handle> isonormals (x, y, z, val, x)
-## Test validation of private function __interp_cube__ 
+## Test validation of private function __interp_cube__
 %!error <X, Y, Z have unequal dimensions> isonormals ({x}, y, z, val, vert)
 %!error <X, Y, Z have unequal dimensions> isonormals (x, {y}, z, val, vert)
 %!error <X, Y, Z have unequal dimensions> isonormals (x, y, {z}, val, vert)
 %!error <X, Y, Z have unequal dimensions> isonormals (x, y, z(1), val, vert)
 %!error <X, Y, Z have unequal dimensions> isonormals (x(:), y(:), z, val, vert)
 %!error <VAL dimensions must match those of X, Y, and Z> isonormals (1, 2, 3, val, vert)
 
diff --git a/scripts/plot/draw/private/__ezplot__.m b/scripts/plot/draw/private/__ezplot__.m
--- a/scripts/plot/draw/private/__ezplot__.m
+++ b/scripts/plot/draw/private/__ezplot__.m
@@ -499,17 +499,17 @@ function domain = find_valid_domain (X, 
       d = irhi - irlo;
       domain(3) = max (XX(1) - d/8, irlo - d);
       domain(4) = min (XX(end) + d/8, irhi + d);
     else
       domain(3:4) = [XX(1), XX(end)];
     endif
 
     ## Handle exceptional case of constant function
-    if (domain(3) == domain(4)) 
+    if (domain(3) == domain(4))
       domain(3) -= 1;
       domain(4) += 1;
     endif
 
   else
     ## 3-D data such as mesh, surf
     Zfinite = ! isnan (Z);
     Zrows = any (Zfinite, 2);
