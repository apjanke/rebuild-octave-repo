# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1274074014 25200
#      Sun May 16 22:26:54 2010 -0700
# Node ID d1978e7364ad4309a86b3a5a8b34330b91a05c20
# Parent  60542efcfa2cec85817873995bf6e270fe874ebc
Print name of function in error() string messages.

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,33 @@
+2010-05-16  Rik <octave@nomad.inbox5.com>
+
+        * audio/loadaudio.m, audio/playaudio.m, audio/saveaudio.m,
+        audio/wavread.m, general/bicubic.m, general/bitcmp.m, general/bitget.m,
+        general/bitset.m, general/cplxpair.m, general/del2.m,
+        general/gradient.m, general/interp2.m, general/interp3.m,
+        general/interpn.m, general/postpad.m, general/prepad.m,
+        general/private/__splinen__.m, image/image_viewer.m, image/imagesc.m,
+        image/saveimage.m, linear-algebra/expm.m, linear-algebra/krylov.m,
+        miscellaneous/edit.m, miscellaneous/private/__xzip__.m,
+        miscellaneous/what.m, optimization/glpk.m, optimization/optimset.m,
+        optimization/pqpnonneg.m, path/pathdef.m, plot/__go_draw_axes__.m,
+        plot/__marching_cube__.m, plot/gnuplot_drawnow.m, plot/ishold.m,
+        plot/isocolors.m, plot/isonormals.m, plot/print.m,
+        plot/private/__add_datasource__.m, plot/private/__color_str_rgb__.m,
+        plot/private/__errplot__.m, plot/private/__interp_cube__.m,
+        plot/shading.m, plot/specular.m, polynomial/deconv.m,
+        polynomial/polyint.m, polynomial/ppint.m, set/powerset.m,
+        signal/arch_fit.m, signal/arch_test.m, signal/durbinlevinson.m,
+        special-matrix/hadamard.m, statistics/distributions/unidrnd.m,
+        statistics/distributions/unifinv.m,
+        statistics/models/logistic_regression.m, strings/strjust.m,
+        testfun/rundemos.m, testfun/runtests.m, testfun/test.m, time/datenum.m:
+        Print name of function in error() string messages.
+
 2010-05-16  Rik <octave@nomad.inbox5.com>
 
         * scripts/plot/contourc.m, scripts/plot/private/__contour__.m, 
           scripts/plot/surface.m, scripts/plot/surfnorm.m: Check input
           arguments for size and type (bug #29861).
 
 2010-05-13  John W. Eaton  <jwe@octave.org>
 
diff --git a/scripts/audio/loadaudio.m b/scripts/audio/loadaudio.m
--- a/scripts/audio/loadaudio.m
+++ b/scripts/audio/loadaudio.m
@@ -69,14 +69,14 @@ function X = loadaudio (name, ext, bit)
     ## remove file header
     m = find (Y(1:64) == 0, 1, "last");
     if (! isempty (m))
       Y(1:m) = [];
     endif
     X = mu2lin (Y, bit);
   else
     fclose (num);
-    error ("loadaudio does not support given extension");
+    error ("loadaudio: unsupported extension");
   endif
 
   fclose (num);
 
 endfunction
diff --git a/scripts/audio/playaudio.m b/scripts/audio/playaudio.m
--- a/scripts/audio/playaudio.m
+++ b/scripts/audio/playaudio.m
@@ -62,15 +62,15 @@ function playaudio (name, ext)
       print_usage ();
     endif
     if (strcmp (ext, "lin") || strcmp (ext, "raw"))
       system (sprintf ("cat \"%s\" > /dev/dsp", name));
     elseif (strcmp (ext, "mu") || strcmp (ext, "au")
             || strcmp (ext, "snd") || strcmp (ext, "ul"))
       system (sprintf ("cat \"%s\" > /dev/audio", name));
     else
-      error ("playaudio does not support given extension");
+      error ("playaudio: unsupported extension");
     endif
   else
     print_usage ();
   endif
 
 endfunction
diff --git a/scripts/audio/saveaudio.m b/scripts/audio/saveaudio.m
--- a/scripts/audio/saveaudio.m
+++ b/scripts/audio/saveaudio.m
@@ -76,14 +76,14 @@ function saveaudio (name, X, ext, bit)
       c = fwrite (num, X, "short");
     endif
   elseif (strcmp (ext, "mu") || strcmp (ext, "au")
           || strcmp (ext, "snd") || strcmp (ext, "ul"))
     Y = lin2mu (X);
     c = fwrite (num, Y, "uchar");
   else
     fclose (num);
-    error ("saveaudio does not support given extension");
+    error ("saveaudio: unsupported extension");
   endif
 
   fclose (num);
 
 endfunction
diff --git a/scripts/audio/wavread.m b/scripts/audio/wavread.m
--- a/scripts/audio/wavread.m
+++ b/scripts/audio/wavread.m
@@ -47,17 +47,17 @@ function [y, samples_per_sec, bits_per_s
   FORMAT_IEEE_FLOAT = 0x0003;   # IEEE float (32/64 bit)
   BYTEORDER         = "ieee-le";
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (! ischar (filename))
-    error ("wavwrite: expecting filename to be a character string");
+    error ("wavread: expecting filename to be a character string");
   endif
 
   # Open file for binary reading.
   [fid, msg] = fopen (filename, "rb");
   if (fid < 0)
     error ("wavread: %s", msg);
   endif
 
diff --git a/scripts/general/bicubic.m b/scripts/general/bicubic.m
--- a/scripts/general/bicubic.m
+++ b/scripts/general/bicubic.m
@@ -64,33 +64,33 @@ function F = bicubic (X, Y, Z, XI, YI, e
     endif
     Z = X;
     X = [];
     [rz, cz] = size (Z);
     s = linspace (1, cz, (cz-1)*pow2(n)+1);
     t = linspace (1, rz, (rz-1)*pow2(n)+1);
   elseif (nargin == 3)
     if (! isvector (X) || ! isvector (Y))
-      error ("XI and YI must be vector");
+      error ("bicubic: XI and YI must be vector");
     endif
     s = Y;
     t = Z;
     Z = X;
     [rz, cz] = size (Z);
   elseif (nargin == 5 || nargin == 6)
     [rz, cz] = size (Z) ; 
     if (isvector (X) && isvector (Y))
       if (rz != length (Y) || cz != length (X))
-        error ("length of X and Y must match the size of Z");
+        error ("bicubic: length of X and Y must match the size of Z");
       endif
     elseif (size_equal (X, Y) && size_equal (X, Z))
       X = X(1,:);
       Y = Y(:,1);
     else
-      error ("X, Y and Z must be martrices of same size");
+      error ("bicubic: X, Y and Z must be equal size matrices of same size");
     endif
     
     ## Mark values outside the lookup table.
     xfirst_ind = find (XI < X(1));
     xlast_ind  = find (XI > X(cz));    
     yfirst_ind = find (YI < Y(1));
     ylast_ind  = find (YI > Y(rz));
     ## Set value outside the table preliminary to min max index.
@@ -123,17 +123,17 @@ function F = bicubic (X, Y, Z, XI, YI, e
     ## Set s and t used follow codes.
     s = xidx + ((XI .- X(xidx))./(X(xidx+1) .- X(xidx)));
     t = yidx + ((YI - Y(yidx))./(Y(yidx+1) - Y(yidx)));
   else
     print_usage ();
   endif
   
   if (rz < 3 || cz < 3)
-    error ("Z at least a 3 by 3 matrices");
+    error ("bicubic: Z at least a 3 by 3 matrices");
   endif
 
   inds = floor (s);
   d = find (s == cz);
   s = s - floor (s);
   inds(d) = cz-1;
   s(d) = 1.0;
   
diff --git a/scripts/general/bitcmp.m b/scripts/general/bitcmp.m
--- a/scripts/general/bitcmp.m
+++ b/scripts/general/bitcmp.m
@@ -38,17 +38,17 @@
 
 function x = bitcmp (a, n)
   
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (nargin == 2 && (! isscalar (n) || (floor (n) != n)))
-    error ("k must be a scalar integer");
+    error ("bitcmp: k must be a scalar integer");
   endif
 
   if (isa (a, "double"))
     bmax = bitmax;
     amax = ceil (log2 (bmax));
   else
     if (isa (a, "uint8"))
       amax = 8;
@@ -62,27 +62,27 @@ function x = bitcmp (a, n)
       amax = 8;
     elseif (isa (a, "int16"))
       amax = 16;
     elseif (isa (a, "int32"))
       amax = 32;
     elseif (isa (a, "int64"))
       amax = 64;
     else
-      error ("invalid class %s", class (a));
+      error ("bitcmp: invalid class %s", class (a));
     endif
     bmax = intmax (class (a));
   endif
 
   if (nargin == 1 || n == amax)
     x = bitxor (a, bmax);
   else
     m = double (n);
     if (any (m < 1) || any (m > amax))
-      error ("n must be in the range [1,%d]", amax);
+      error ("bitcmp: n must be in the range [1,%d]", amax);
     endif
     mask = bitshift (bmax, n - amax);
     x = bitxor (bitand (a, mask), mask);
   endif
 endfunction
 
 %!shared Amax,Bmax,A
 %! Amax=53;
diff --git a/scripts/general/bitget.m b/scripts/general/bitget.m
--- a/scripts/general/bitget.m
+++ b/scripts/general/bitget.m
@@ -62,19 +62,19 @@ function X = bitget (A, n)
       _conv = @int16;
     elseif (isa (A, "int32"))
       Amax = 32;
       _conv = @int32;
     elseif (isa (A, "int64"))
       Amax = 64;
       _conv = @int64;
     else
-      error ("invalid class %s", class (A));
+      error ("bitget: invalid class %s", class (A));
     endif
   endif
 
   m = double (n(:));
   if (any (m < 1) || any (m > Amax))
-    error ("n must be in the range [1,%d]", Amax);
+    error ("bitget: n must be in the range [1,%d]", Amax);
   endif
 
   X = bitand (A, bitshift (_conv (1), uint8 (n) - uint8 (1))) != _conv (0);
 endfunction
diff --git a/scripts/general/bitset.m b/scripts/general/bitset.m
--- a/scripts/general/bitset.m
+++ b/scripts/general/bitset.m
@@ -69,24 +69,24 @@ function X = bitset (A, n, value)
       _conv = @int16;
     elseif (isa (A, "int32"))
       Amax = 32;
       _conv = @int32;
     elseif (isa (A, "int64"))
       Amax = 64;
       _conv = @int64;
     else
-      error ("invalid class %s", class (A));
+      error ("bitset: invalid class %s", class (A));
     endif
     Bmax = intmax (class (A));
   endif
 
   m = double (n(:));
   if (any (m < 1) || any (m > Amax))
-    error ("n must be in the range [1,%d]", Amax);
+    error ("bitset: n must be in the range [1,%d]", Amax);
   endif
 
   mask = bitshift (_conv (1), uint8 (n) - uint8 (1));
   X = bitxor (A, bitand (A, mask));
 
   if (value)
     X = bitor (A, mask);
   endif
diff --git a/scripts/general/cplxpair.m b/scripts/general/cplxpair.m
--- a/scripts/general/cplxpair.m
+++ b/scripts/general/cplxpair.m
@@ -114,21 +114,21 @@ function y = cplxpair (z, tol, dim)
 
   ## For each remaining z, place the value and its conjugate at the
   ## start of the returned list, and remove them from further
   ## consideration.
   for j = 1:m
     p = n - nr(j);
     for i = 1:2:p
       if (i+1 > p)
-        error ("cplxpair could not pair all complex numbers");
+        error ("cplxpair: could not pair all complex numbers");
       endif
       [v, idx] = min (abs (z(i+1:p) - conj (z(i))));
       if (v > tol)
-        error ("cplxpair could not pair all complex numbers");
+        error ("cplxpair: could not pair all complex numbers");
       endif
       if (imag (z(i)) < 0)
         y([i, i+1]) = z([i, idx+i]);
       else
         y([i, i+1]) = z([idx+i, i]);
       endif
       z(idx+i) = z(i+1);
     endfor
diff --git a/scripts/general/del2.m b/scripts/general/del2.m
--- a/scripts/general/del2.m
+++ b/scripts/general/del2.m
@@ -80,34 +80,34 @@ function D = del2 (M, varargin)
     endif
     for i = 1 : nd
       if (isscalar (h))
         dx{i} = h * ones (sz (i), 1);
       else
         if (length (h) == sz (i))
           dx{i} = diff (h)(:);
         else
-          error ("dimensionality mismatch in %d-th spacing vector", i);
+          error ("del2: dimensionality mismatch in %d-th spacing vector", i);
         endif
       endif
     endfor
   elseif (nargin - 1 == nd)
     ## Reverse dx{1} and dx{2} as the X-dim is the 2nd dim of the ND array
     tmp = varargin{1};
     varargin{1} = varargin{2};
     varargin{2} = tmp;
 
     for i = 1 : nd
       if (isscalar (varargin{i}))
         dx{i} = varargin{i} * ones (sz (i), 1);
       else
         if (length (varargin{i}) == sz (i))
           dx{i} = diff (varargin{i})(:);
         else
-          error ("dimensionality mismatch in %d-th spacing vector", i);
+          error ("del2: dimensionality mismatch in %d-th spacing vector", i);
         endif
       endif
     endfor
   else
     print_usage ();
   endif
 
   idx = cell (1, nd);
diff --git a/scripts/general/gradient.m b/scripts/general/gradient.m
--- a/scripts/general/gradient.m
+++ b/scripts/general/gradient.m
@@ -114,17 +114,17 @@ function varargout = matrix_gradient (m,
       endfor
     else
       ## vector for one-dimensional derivative
       d{1} = diff (varargin{1}(:));
     endif
   else
     ## have spacing value for each dimension
     if (length(varargin) != nd)
-      error ("dimensions and number of spacing values do not match.");
+      error ("gradient: dimensions and number of spacing values do not match.");
     end
     for i = 1:nd
       if (isscalar (varargin{i}))
         d{i} = varargin{i} * ones (sz(i) - 1, 1);
       else
         d{i} = diff (varargin{i}(:));
       endif
     endfor
diff --git a/scripts/general/interp2.m b/scripts/general/interp2.m
--- a/scripts/general/interp2.m
+++ b/scripts/general/interp2.m
@@ -126,70 +126,70 @@ function ZI = interp2 (varargin)
     case 7
         [X, Y, Z, XI, YI, method, extrapval] = deal (varargin{:});
     otherwise
       print_usage ();
   endswitch
 
   ## Type checking.
   if (!ismatrix (Z))
-    error ("interp2 expected matrix Z"); 
+    error ("interp2: expected matrix Z"); 
   endif
   if (!isempty (n) && !isscalar (n))
-    error ("interp2 expected scalar n"); 
+    error ("interp2: expected scalar n"); 
   endif
   if (!ischar (method))
-    error ("interp2 expected string 'method'"); 
+    error ("interp2: expected string 'method'"); 
   endif
   if (ischar (extrapval) || strcmp (extrapval, "extrap"))
     extrapval = [];
   elseif (!isscalar (extrapval))
-    error ("interp2 expected n extrapval");
+    error ("interp2: expected n extrapval");
   endif
 
   ## Define X, Y, XI, YI if needed
   [zr, zc] = size (Z);
   if (isempty (X))
     X = 1:zc; 
     Y = 1:zr;
   endif
   if (! isnumeric (X) || ! isnumeric (Y))
-    error ("interp2 expected numeric X, Y"); 
+    error ("interp2: expected numeric X, Y"); 
   endif
   if (! isempty (n))
     p = 2^n; 
     XI = (p:p*zc)/p; 
     YI = (p:p*zr)'/p; 
   endif
   if (! isnumeric (XI) || ! isnumeric (YI))
-    error ("interp2 expected numeric XI, YI"); 
+    error ("interp2: expected numeric XI, YI"); 
   endif
 
 
   if (strcmp (method, "linear") || strcmp (method, "nearest") ...
       || strcmp (method, "pchip"))
 
     ## If X and Y vectors produce a grid from them
     if (isvector (X) && isvector (Y))
       X = X(:); Y = Y(:);
     elseif (size_equal (X, Y))
       X = X(1,:)'; Y = Y(:,1);
     else
-      error ("X and Y must be matrices of same size");
+      error ("interp2: X and Y must be matrices of same size");
     endif
     if (columns (Z) != length (X) || rows (Z) != length (Y))
-      error ("X and Y size must match Z dimensions");
+      error ("interp2: X and Y size must match Z dimensions");
     endif
 
     ## If Xi and Yi are vectors of different orientation build a grid
     if ((rows (XI) == 1 && columns (YI) == 1)
         || (columns (XI) == 1 && rows (YI) == 1))
       [XI, YI] = meshgrid (XI, YI);
     elseif (! size_equal (XI, YI))
-      error ("XI and YI must be matrices of same size");
+      error ("interp2: XI and YI must be matrices of same size");
     endif
 
     ## if XI, YI are vectors, X and Y should share their orientation.
     if (rows (XI) == 1)
       if (rows (X) != 1)
         X = X.';
       endif
       if (rows (Y) != 1)
@@ -318,31 +318,31 @@ function ZI = interp2 (varargin)
 
   else
 
     ## If X and Y vectors produce a grid from them
     if (isvector (X) && isvector (Y))
       X = X(:).';
       Y = Y(:);
       if (!isequal ([length(X), length(Y)], size(Z)))
-        error ("X and Y size must match Z dimensions");
+        error ("interp2: X and Y size must match Z dimensions");
       endif
     elseif (!size_equal (X, Y))
-      error ("X and Y must be matrices of same size");
+      error ("interp2: X and Y must be matrices of same size");
       if (! size_equal (X, Z))
-        error ("X and Y size must match Z dimensions");
+        error ("interp2: X and Y size must match Z dimensions");
       endif
     endif
 
     ## If Xi and Yi are vectors of different orientation build a grid
     if ((rows (XI) == 1 && columns (YI) == 1)
         || (columns (XI) == 1 && rows (YI) == 1))
       ## Do nothing
     elseif (! size_equal (XI, YI))
-      error ("XI and YI must be matrices of same size");
+      error ("interp2: XI and YI must be matrices of same size");
     endif
 
     ## FIXME bicubic/__splinen__ don't handle arbitrary XI, YI
     if (strcmp (method, "cubic"))
       if (isgriddata (XI) && isgriddata (YI'))
         ZI = bicubic (X, Y, Z, XI (1, :), YI (:, 1), extrapval);
       elseif (isgriddata (X) && isgriddata (Y'))
         ## Allocate output
@@ -396,17 +396,17 @@ function ZI = interp2 (varargin)
     elseif (strcmp (method, "spline"))
       if (isgriddata (XI) && isgriddata (YI'))
         ZI = __splinen__ ({Y(:,1).', X(1,:)}, Z, {YI(:,1), XI(1,:)}, extrapval, 
                         "spline");
       else
         error ("interp2: input data must have `meshgrid' format");
       endif
     else
-      error ("interpolation method not recognized");
+      error ("interp2: interpolation method not recognized");
     endif
 
   endif
 endfunction
 
 function b = isgriddata (X)
   d1 = diff (X, 1, 1);
   d2 = diff (X, 1, 2);
diff --git a/scripts/general/interp3.m b/scripts/general/interp3.m
--- a/scripts/general/interp3.m
+++ b/scripts/general/interp3.m
@@ -70,70 +70,70 @@ function vi = interp3 (varargin)
     print_usage ();
   endif
 
   if (ischar (varargin{end}))
     method = varargin{end};
     nargs = nargs - 1;
   elseif (ischar (varargin{end-1}))
     if (! isnumeric (varargin{end}) || ! isscalar (varargin{end}))
-      error ("extrapal is expected to be a numeric scalar");
+      error ("interp3: extrapal is expected to be a numeric scalar");
     endif
     extrapval = varargin{end};
     method = varargin{end-1};
     nargs = nargs - 2;
   endif
 
   if (nargs < 3 || (nargs == 4 && ! isvector (varargin{1})
                     && nargs == (ndims (varargin{1}) + 1)))
     v = varargin{1};
     if (ndims (v) != 3)
-      error ("expect 3-dimensional array of values");
+      error ("interp3: expect 3-dimensional array of values");
     endif
     x = varargin (2:4);
     if (any (! cellfun (@isvector, x)))
       for i = 2 : 3
         if (! size_equal (x{1}, x{i}))
-          error ("dimensional mismatch");
+          error ("interp3: dimensional mismatch");
         endif
         x{i} = permute (x{i}, [2, 1, 3]);
       endfor
       x{1} = permute (x{1}, [2, 1, 3]);
     endif
     v = permute (v, [2, 1, 3]);
     vi = ipermute (interpn (v, x{:}, method, extrapval), [2, 1, 3]);
   elseif (nargs == 7 && nargs == (2 * ndims (varargin{ceil (nargs / 2)})) + 1)
     v = varargin{4};
     if (ndims (v) != 3)
-      error ("expect 3-dimensional array of values");
+      error ("interp3: expect 3-dimensional array of values");
     endif
     x = varargin (1:3);
     if (any (! cellfun (@isvector, x)))
       for i = 2 : 3
         if (! size_equal (x{1}, x{i}) || ! size_equal (x{i}, v))
-          error ("dimensional mismatch");
+          error ("interp3: dimensional mismatch");
         endif
         x{i} = permute (x{i}, [2, 1, 3]);
       endfor
       x{1} = permute (x{1}, [2, 1, 3]);
     endif
     y = varargin (5:7);
     if (any (! cellfun (@isvector, y)))
       for i = 2 : 3
         if (! size_equal (y{1}, y{i}))
-          error ("dimensional mismatch");
+          error ("interp3: dimensional mismatch");
         endif
         y{i} = permute (y{i}, [2, 1, 3]);
       endfor
       y{1} = permute (y{1}, [2, 1, 3]);
     endif
     v = permute (v, [2, 1, 3]);
     vi = ipermute (interpn (x{:}, v, y{:}, method, extrapval), [2, 1, 3]);
   else
-    error ("wrong number or incorrectly formatted input arguments");
+    error ("interp3: wrong number or incorrectly formatted input arguments");
   endif
 endfunction
 
 %!test
 %! x = y = z = -1:1;
 %! f = @(x,y,z) x.^2 - y - z.^2;
 %! [xx, yy, zz] = meshgrid (x, y, z);
 %! v = f (xx,yy,zz);
diff --git a/scripts/general/interpn.m b/scripts/general/interpn.m
--- a/scripts/general/interpn.m
+++ b/scripts/general/interpn.m
@@ -71,30 +71,30 @@ function vi = interpn (varargin)
     print_usage ();
   endif
 
   if (ischar (varargin{end}))
     method = varargin{end};
     nargs = nargs - 1;
   elseif (ischar (varargin{end - 1}))
     if (! isnumeric (varargin{end}) || ! isscalar (varargin{end}))
-      error ("extrapal is expected to be a numeric scalar");
+      error ("interpn: extrapal is expected to be a numeric scalar");
     endif
     method = varargin{end - 1};
     extrapval = varargin{end};
     nargs = nargs - 2;
   endif
 
   if (nargs < 3)
     v = varargin{1};
     m = 1;
     if (nargs == 2)
       m = varargin{2};
       if (! isnumeric (m) || ! isscalar (m) || floor (m) != m)
-        error ("m is expected to be a integer scalar");
+        error ("interpn: m is expected to be a integer scalar");
       endif
     endif
     sz = size (v);
     nd = ndims (v);
     x = cell (1, nd);
     y = cell (1, nd);
     for i = 1 : nd;
       x{i} = 1 : sz(i);
@@ -113,23 +113,23 @@ function vi = interpn (varargin)
           (2 * ndims (varargin{ceil (nargs / 2)})) + 1)
     nv = ceil (nargs / 2);
     v = varargin{nv};
     sz = size (v);
     nd = ndims (v);
     x = varargin (1 : (nv - 1));
     y = varargin ((nv + 1) : nargs);
   else
-    error ("wrong number or incorrectly formatted input arguments");
+    error ("interpn: wrong number or incorrectly formatted input arguments");
   endif
 
   if (any (! cellfun (@isvector, x)))
     for i = 2 : nd
       if (! size_equal (x{1}, x{i}) || ! size_equal (x{i}, v))
-        error ("dimensional mismatch");
+        error ("interpn: dimensional mismatch");
       endif
       idx (1 : nd) = {1};
       idx (i) = ":";
       x{i} = x{i}(idx{:})(:);
     endfor
     idx (1 : nd) = {1};
     idx (1) = ":";
     x{1} = x{1}(idx{:})(:);
@@ -157,17 +157,17 @@ function vi = interpn (varargin)
       idx |= y{i} < min (x{i}(:)) | y{i} > max (x{i}(:));
     endfor
     vi(idx) = extrapval;
     vi = reshape (vi, yshape); 
   elseif (strcmp (method, "spline"))
     if (any (! cellfun (@isvector, y)))
       for i = 2 : nd
         if (! size_equal (y{1}, y{i}))
-          error ("dimensional mismatch");
+          error ("interpn: dimensional mismatch");
         endif
         idx (1 : nd) = {1};
         idx (i) = ":";
         y{i} = y{i}(idx{:});
       endfor
       idx (1 : nd) = {1};
       idx (1) = ":";
       y{1} = y{1}(idx{:});
@@ -182,19 +182,19 @@ function vi = interpn (varargin)
       for i = 1 : ly
         q(:) = i;
         idx {i} = q;
       endfor
       vi = vi (cellfun (@(x) sub2ind (size(vi), x{:}), idx));
       vi = reshape (vi, size(y{1}));
     endif
   elseif (strcmp (method, "cubic")) 
-    error ("cubic interpolation not yet implemented");
+    error ("interpn: cubic interpolation not yet implemented");
   else
-    error ("unrecognized interpolation method");
+    error ("interpn: unrecognized interpolation method");
   endif
 
 endfunction
 
 %!demo
 %! A=[13,-1,12;5,4,3;1,6,2];
 %! x=[0,1,4]; y=[10,11,12];
 %! xi=linspace(min(x),max(x),17);
diff --git a/scripts/general/postpad.m b/scripts/general/postpad.m
--- a/scripts/general/postpad.m
+++ b/scripts/general/postpad.m
@@ -54,17 +54,17 @@ function y = postpad (x, l, c, dim)
   else
     if (! (isscalar (dim) && dim == round (dim)) && dim > 0 && 
         dim < (nd + 1))
       error ("postpad: dim must be an integer and valid dimension");
     endif
   endif
 
   if (! isscalar (l) || l < 0)
-    error ("second argument must be a positive scaler");
+    error ("postpad: second argument must be a positive scaler");
   endif
 
   if (dim > nd)
     sz(nd+1:dim) = 1;
   endif
 
   d = sz (dim);
 
diff --git a/scripts/general/prepad.m b/scripts/general/prepad.m
--- a/scripts/general/prepad.m
+++ b/scripts/general/prepad.m
@@ -65,17 +65,17 @@ function y = prepad (x, l, c, dim)
   else
     if (! (isscalar (dim) && dim == round (dim)) && dim > 0 && 
         dim < (nd + 1))
       error ("prepad: dim must be an integer and valid dimension");
     endif
   endif
 
   if (! isscalar (l) || l < 0)
-    error ("second argument must be a positive scaler");
+    error ("prepad: second argument must be a positive scaler");
   endif
 
   if (dim > nd)
     sz(nd+1:dim) = 1;
   endif
 
   d = sz (dim);
 
diff --git a/scripts/general/private/__splinen__.m b/scripts/general/private/__splinen__.m
--- a/scripts/general/private/__splinen__.m
+++ b/scripts/general/private/__splinen__.m
@@ -22,23 +22,23 @@
 ## @deftypefn {Function File} {@var{yi} =} __splinen__ (@var{x}, @var{y}, @var{xi})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## FIXME: Allow arbitrary grids..
 
 function yi = __splinen__ (x, y, xi, extrapval, f)
   if (nargin != 5)
-    error ("Incorrect number of arguments");
+    error ("__splinen__: Incorrect number of arguments");
   endif
   ## ND isvector function.
   isvec = @(x) numel (x) == length (x);
   if (!iscell (x) || length(x) < ndims(y) || any (! cellfun (isvec, x)) ||
       !iscell (xi) || length(xi) < ndims(y) || any (! cellfun (isvec, xi)))
-    error ("%s: non gridded data or dimensions inconsistent", f);
+    error ("__splinen__: %s: non gridded data or dimensions inconsistent", f);
   endif
   yi = y;
   for i = length(x):-1:1
     yi = permute (spline (x{i}, yi, xi{i}(:)), [length(x),1:length(x)-1]);
   endfor
 
   [xi{:}] = ndgrid (cellfun (@(x) x(:), xi, "UniformOutput", false){:});
   idx = zeros (size(xi{1}));
diff --git a/scripts/image/image_viewer.m b/scripts/image/image_viewer.m
--- a/scripts/image/image_viewer.m
+++ b/scripts/image/image_viewer.m
@@ -152,12 +152,12 @@ function __img_via_file__ (x, y, im, zoo
     else
       command = sprintf (command, ppm_name);
     endif
     status = system (sprintf ("( %s && %s) > /dev/null 2>&1 &", command, rm));
   endif
   
   ## Did the system call fail?
   if (status != 0)
-    error ("the image viewing command failed");
+    error ("image_viewer: the image viewing command failed");
   endif
 
 endfunction
diff --git a/scripts/image/imagesc.m b/scripts/image/imagesc.m
--- a/scripts/image/imagesc.m
+++ b/scripts/image/imagesc.m
@@ -110,12 +110,12 @@ function ret = __imagesc__ (ax, x, y, A,
 
   ret = image (ax, x, y, A);
   set (ret, "cdatamapping", "scaled")
 
   ## use given limits or guess them from the matrix
   if (length (limits) == 2 && limits(2) >= limits(1))
     set (ax, "clim", limits);
   elseif (! isempty (limits))
-    error ("expected data limits to be [lo, hi]");
+    error ("imagesc: expected data limits to be [lo, hi]");
   endif
 
 endfunction
diff --git a/scripts/image/saveimage.m b/scripts/image/saveimage.m
--- a/scripts/image/saveimage.m
+++ b/scripts/image/saveimage.m
@@ -86,35 +86,35 @@ function saveimage (filename, img, img_f
     else
       map = colormap ();
     endif
   endif
 
   [map_nr, map_nc] = size (map);
 
   if (map_nc != 3)
-    error ("colormap should be an N x 3 matrix");
+    error ("saveimage: colormap should be an N x 3 matrix");
   endif
 
   if (nargin < 3)
     img_form = "img";
   elseif (! ischar (img_form))
-    error ("image format specification must be a string");
+    error ("saveimage: image format specification must be a string");
   elseif (! (strcmp (img_form, "img")
              || strcmp (img_form, "ppm")
              || strcmp (img_form, "ps")))
-    error ("unsupported image format specification");
+    error ("saveimage: unsupported image format specification");
   endif
 
   if (! ismatrix (img))
     warning ("image variable is not a matrix");
   endif
 
   if (! ischar (filename))
-    error ("file name must be a string");
+    error ("saveimage: file name must be a string");
   endif
 
   ## If we just want Octave image format, save and return.
 
   if (strcmp (img_form, "img"))
     save ("-text", filename, "map", "img");
     return;
   endif
@@ -219,17 +219,17 @@ function saveimage (filename, img, img_f
       fprintf (fid, "\n");
       fclose (fid);
 
     endif
 
   elseif (strcmp (img_form, "ps") == 1)
 
     if (! grey)
-      error ("must have a greyscale color map for conversion to PostScript");
+      error ("saveimage: must have a greyscale color map for conversion to PostScript");
     endif
 
     bps = 8;
     dpi = 300;
     pagewid = 612;
     pagehgt = 762;
     MARGIN = 0.95;
     devpix = dpi / 72.0 + 0.5;
diff --git a/scripts/linear-algebra/expm.m b/scripts/linear-algebra/expm.m
--- a/scripts/linear-algebra/expm.m
+++ b/scripts/linear-algebra/expm.m
@@ -87,17 +87,17 @@
 ## @code{Dq(a)}
 ## @end ifnottex
 ## is ill-conditioned.
 ## @end deftypefn
 
 function r = expm (a)
 
   if (! ismatrix (a) || ! issquare (a))
-    error ("expm requires a square matrix");
+    error ("expm: input must be a square matrix");
   endif
 
   n = rows (a);
   ## Trace reduction.
   a(a == -Inf) = -realmax;
   trshift = trace (a) / length (a);
   if (trshift > 0)
     a -= trshift*eye (n);
diff --git a/scripts/linear-algebra/krylov.m b/scripts/linear-algebra/krylov.m
--- a/scripts/linear-algebra/krylov.m
+++ b/scripts/linear-algebra/krylov.m
@@ -77,23 +77,23 @@ function [Uret, H, nu] = krylov (A, V, k
     eps1 = defeps;
   endif
 
   if (isempty (eps1))
     eps1 = defeps;
   endif
 
   if (! issquare (A) || isempty (A))
-    error ("A(%d x %d) must be non-empty square matrix", rows (A), columns (A));
+    error ("krylov: A(%d x %d) must be a non-empty square matrix", rows (A), columns (A));
   endif
   na = rows (A);
 
   [m, kb] = size (V);
   if (m != na)
-    error("A(%d x %d), V(%d x %d): argument dimensions do not match",
+    error ("krylov: A(%d x %d), V(%d x %d): argument dimensions do not match",
           na, na, m, kb)
   endif
 
   if (! isscalar (k))
     error ("krylov: third argument must be a scalar integer");
   endif
 
   Vnrm = norm (V, Inf);
@@ -180,17 +180,17 @@ function [Uret, H, nu] = krylov (A, V, k
     ## Check for oversize V (due to full rank).
     if ((columns (V) > na) && (length (alpha) == na))
       ## Trim to size.
       V = V(:,1:na);
     elseif (columns(V) > na)
       krylov_V = V
       krylov_na = na
       krylov_length_alpha = length (alpha)
-      error ("This case should never happen; submit a bug report");
+      error ("krylov: this case should never happen; submit a bug report");
     endif
 
     if (columns (V) > 0)
       ## Construct next Q and multiply.
       Q = zeros (size (V));
       for kk = 1:columns (Q)
         Q(pivot_vec(nu-columns(Q)+kk),kk) = 1;
       endfor
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -167,17 +167,17 @@ function ret = edit (file, state)
     case "EMAIL"
       FUNCTION.EMAIL = state;
     case "LICENSE"
       FUNCTION.LICENSE = state;
     case "MODE"
       if (strcmp (state, "sync") || strcmp (state, "async"))
         FUNCTION.MODE = state;
       else
-        error('expected "edit MODE sync|async"');
+        error('edit: expected "edit MODE sync|async"');
       endif
     case "EDITINPLACE"
       if (ischar (state))
         if (strcmpi (state, "true"))
           state = true;
         elseif (strcmpi (state, "false"))
           state = false;
         else
@@ -187,17 +187,17 @@ function ret = edit (file, state)
       FUNCTION.EDITINPLACE = state;
     case "GET"
       if (isfield (FUNCTION, toupper(state)))
         ret = FUNCTION.(toupper (state));
       else
         ret = FUNCTION;
       endif
     otherwise
-      error ("expected \"edit EDITOR|HOME|AUTHOR|EMAIL|LICENSE|MODE val\"");
+      error ('edit: expected "edit EDITOR|HOME|AUTHOR|EMAIL|LICENSE|MODE val"');
     endswitch
     return
   endif
 
   ## Start the editor without a file if no file is given.
   if (nargin < 1)
     if (exist (FUNCTION.HOME, "dir") == 7 && (isunix () || ! ispc ()))
       system (cstrcat ("cd \"", FUNCTION.HOME, "\" ; ",
@@ -207,17 +207,17 @@ function ret = edit (file, state)
       system (sprintf (FUNCTION.EDITOR,""), [], FUNCTION.MODE);
     endif
     return;
   endif
 
   ## Check whether the user is trying to edit a builtin of compiled function.
   switch (exist (file))
     case {3, 5}
-      error ("unable to edit a built-in or compiled function");
+      error ("edit: unable to edit a built-in or compiled function");
   endswitch
 
   ## Checks for whether the file is
   ## absolute or relative should be handled inside file_in_loadpath.
   ## That way, it will be possible to look up files correctly given
   ## partial path information.  For example, you should be able to
   ## edit a particular overloaded function by doing any one of
   ##
diff --git a/scripts/miscellaneous/private/__xzip__.m b/scripts/miscellaneous/private/__xzip__.m
--- a/scripts/miscellaneous/private/__xzip__.m
+++ b/scripts/miscellaneous/private/__xzip__.m
@@ -85,17 +85,17 @@ function entries = __xzip__ (commandname
           compressed_files  = cellfun(@(x) sprintf ("%s.%s", x, extension), 
                                       files, "UniformOutput", false);
         endif
 
         if (nargout > 0)
           entries = compressed_files;
         endif
       else
-        error ("%s command failed with exit status = %d",
+        error ("__xzip__: %s command failed with exit status = %d",
                commandname, status);
       endif
     unwind_protect_cleanup
       cd(cwd);
       if (nargin == 4)
         crr = confirm_recursive_rmdir ();
         unwind_protect
           confirm_recursive_rmdir (false);
diff --git a/scripts/miscellaneous/what.m b/scripts/miscellaneous/what.m
--- a/scripts/miscellaneous/what.m
+++ b/scripts/miscellaneous/what.m
@@ -33,17 +33,17 @@ function ret = what (d)
     d = pwd ();
   elseif (isempty (strfind (d, filesep ())))
     ## Find the appropriate directory on the path.
     p = strtrim (strsplit (path (), pathsep()));
     d = p{find (cellfun (@(x) ! isempty (strfind (x, d)), p))(end)};
   else
     [status, msg, msgid] = fileattrib (d);
     if (status != 1)
-      error ("could not find the file or path %s", d);
+      error ("what: could not find the file or path %s", d);
     else
       d = msg.Name;
     endif
   endif
 
   files = dir (d);
   w.path = d;
   w.m = cell (0, 1);
diff --git a/scripts/optimization/glpk.m b/scripts/optimization/glpk.m
--- a/scripts/optimization/glpk.m
+++ b/scripts/optimization/glpk.m
@@ -423,128 +423,128 @@ function [xopt, fmin, status, extra] = g
 
   ## If there is no input output the version and syntax
   if (nargin < 3 || nargin > 9)
     print_usage ();
     return;
   endif
 
   if (all (size (c) > 1) || iscomplex (c) || ischar (c))
-    error ("C must be a real vector");
+    error ("glpk:C must be a real vector");
     return;
   endif
   nx = length (c);
   ## Force column vector.
   c = c(:);
 
   ## 2) Matrix constraint
 
   if (isempty (a))
-    error ("A cannot be an empty matrix");
+    error ("glpk: A cannot be an empty matrix");
     return;
   endif
   [nc, nxa] = size(a);
   if (! isreal (a) || nxa != nx)
-    error ("A must be a real valued %d by %d matrix", nc, nx);
+    error ("glpk: A must be a real valued %d by %d matrix", nc, nx);
     return;
   endif
 
   ## 3) RHS
 
   if (isempty (b))
-    error ("B cannot be an empty vector");
+    error ("glpk: B cannot be an empty vector");
     return;
   endif
   if (! isreal (b) || length (b) != nc)
-    error ("B must be a real valued %d by 1 vector", nc);
+    error ("glpk: B must be a real valued %d by 1 vector", nc);
     return;
   endif
 
   ## 4) Vector with the lower bound of each variable
 
   if (nargin > 3)
     if (isempty (lb))
       lb = zeros (nx, 1);
     elseif (! isreal (lb) || all (size (lb) > 1) || length (lb) != nx)
-      error ("LB must be a real valued %d by 1 column vector", nx);
+      error ("glpk: LB must be a real valued %d by 1 column vector", nx);
       return;
     endif
   else
     lb = zeros (nx, 1);
   endif
 
   ## 5) Vector with the upper bound of each variable
 
   if (nargin > 4)
     if (isempty (ub))
       ub = Inf (nx, 1);
     elseif (! isreal (ub) || all (size (ub) > 1) || length (ub) != nx)
-      error ("UB must be a real valued %d by 1 column vector", nx);
+      error ("glpk: UB must be a real valued %d by 1 column vector", nx);
       return;
     endif
   else
     ub = Inf (nx, 1);
   endif
 
   ## 6) Sense of each constraint
 
   if (nargin > 5)
     if (isempty (ctype))
       ctype = repmat ("S", nc, 1);
     elseif (! ischar (ctype) || all (size (ctype) > 1) || length (ctype) != nc)
-      error ("CTYPE must be a char valued vector of length %d", nc);
+      error ("glpk: CTYPE must be a char valued vector of length %d", nc);
       return;
     elseif (! all (ctype == "F" | ctype == "U" | ctype == "S"
                    | ctype == "L" | ctype == "D"))
-      error ("CTYPE must contain only F, U, S, L, or D");
+      error ("glpk: CTYPE must contain only F, U, S, L, or D");
       return;
     endif
   else
     ctype = repmat ("S", nc, 1);
   endif
 
   ## 7) Vector with the type of variables
 
   if (nargin > 6)
     if (isempty (vartype))
       vartype = repmat ("C", nx, 1);
     elseif (! ischar (vartype) || all (size (vartype) > 1)
             || length (vartype) != nx)
-      error ("VARTYPE must be a char valued vector of length %d", nx);
+      error ("glpk: VARTYPE must be a char valued vector of length %d", nx);
       return;
     elseif (! all (vartype == "C" | vartype == "I"))
-      error ("VARTYPE must contain only C or I");
+      error ("glpk: VARTYPE must contain only C or I");
       return;
     endif
   else
     ## As default we consider continuous vars
     vartype = repmat ("C", nx, 1);
   endif
 
   ## 8) Sense of optimization
 
   if (nargin > 7)
     if (isempty (sense))
       sense = 1;
     elseif (ischar (sense) || all (size (sense) > 1) || ! isreal (sense))
-      error ("SENSE must be an integer value");
+      error ("glpk: SENSE must be an integer value");
     elseif (sense >= 0)
       sense = 1;
     else
       sense = -1;
     endif
   else
     sense = 1;
   endif
 
   ## 9) Parameters vector
 
   if (nargin > 8)
     if (! isstruct (param))
-      error ("PARAM must be a structure");
+      error ("glpk: PARAM must be a structure");
       return;
     endif
   else
     param = struct ();
   endif
 
   [xopt, fmin, status, extra] = ...
     __glpk__ (c, a, b, lb, ub, ctype, vartype, sense, param);
diff --git a/scripts/optimization/optimset.m b/scripts/optimization/optimset.m
--- a/scripts/optimization/optimset.m
+++ b/scripts/optimization/optimset.m
@@ -44,17 +44,17 @@ function retval = optimset (varargin)
       retval = struct ();
     endif
   elseif (nargs == 1 && ischar (varargin{1}))
     ## Return defaults for named function.
     fcn = varargin{1};
     try
       retval = feval (fcn, 'defaults');
     catch
-      error ("no defaults for function `%s'", fcn);
+      error ("optimset: no defaults for function `%s'", fcn);
     end_try_catch
   elseif (nargs == 2 && isstruct (varargin{1}) && isstruct (varargin{2}))
     ## Set slots in old from nonempties in new.  Should we be checking
     ## to ensure that the field names are expected?
     old = varargin{1};
     new = varargin{2};
     fnames = fieldnames (old);
     ## skip validation if we're in the internal query
diff --git a/scripts/optimization/pqpnonneg.m b/scripts/optimization/pqpnonneg.m
--- a/scripts/optimization/pqpnonneg.m
+++ b/scripts/optimization/pqpnonneg.m
@@ -71,17 +71,17 @@ function [x, minval, exitflag, output, l
   if (! (nargin >= 2 && nargin <= 4 && ismatrix (c) && ismatrix (d) && isstruct (options)))
     print_usage ();
   endif
 
   ## Lawson-Hanson Step 1 (LH1): initialize the variables.
   m = rows (c);
   n = columns (c);
   if (m != n)
-    error ("matrix must be square");
+    error ("pqpnonneg: matrix must be square");
   endif
 
   if (isempty (x))
     ## Initial guess is 0s.
     x = zeros (n, 1);
   else
     ## ensure nonnegative guess.
     x = max (x, 0);
diff --git a/scripts/path/pathdef.m b/scripts/path/pathdef.m
--- a/scripts/path/pathdef.m
+++ b/scripts/path/pathdef.m
@@ -108,25 +108,25 @@ function specifiedpath = __extractpath__
           elseif (strcmp (result, endstring))
             endline = linenum - 1;
           endif
         endif
       endwhile
     unwind_protect_cleanup
       closeread = fclose (fid);
       if (closeread < 0)
-        error ("savepath: could not close savefile after reading, %s",
+        error ("__extractpath__: could not close savefile after reading, %s",
                savefile);
       endif
     end_unwind_protect
   endif
 
   ## Extract the path specifiation.
   if (startline > endline || (startline > 0 && endline == 0))
-    error ("savepath: unable to parse file, %s", savefile);
+    error ("__extractpath__: unable to parse file, %s", savefile);
   elseif (startline > 0)
     ## Undo doubling of single quote characters performed by savepath.
     specifiedpath = strrep (regexprep (cstrcat (filelines(startline:endline){:}),
                                        " *path *\\('(.*)'\\); *", "$1"),
                             "''", "'");
   else
     specifiedpath = "";
   endif
diff --git a/scripts/plot/__go_draw_axes__.m b/scripts/plot/__go_draw_axes__.m
--- a/scripts/plot/__go_draw_axes__.m
+++ b/scripts/plot/__go_draw_axes__.m
@@ -513,17 +513,17 @@ function __go_draw_axes__ (h, plot_strea
                hidden_removal = false;
              else
 
                if (isnan (hidden_removal))
                  hidden_removal = true;
                endif
                if (nd == 3)
                  if (numel (xcol) > 3)
-                   error ("gnuplot (as of v4.2) only supports 3D filled triangular patches");
+                   error ("__go_draw_axes__: gnuplot (as of v4.2) only supports 3D filled triangular patches");
                  else
                    if (isnan (data_3d_idx))
                      data_idx++;
                      data_3d_idx = data_idx; 
                      is_image_data(data_idx) = false;
                      parametric(data_idx) = false;
                      have_cdata(data_idx) = true;
                      have_3d_patch(data_idx) = true;
@@ -1974,17 +1974,17 @@ function do_tics_1 (ticmode, tics, mtics
         endfor
         fprintf (plot_stream, ") %s %s;\n", colorspec, fontspec);
         if (strcmp (mtics, "on"))
           fprintf (plot_stream, "set m%stics %d;\n", ax, num_mtics);
         else
           fprintf (plot_stream, "unset m%stics;\n", ax);
         endif
      else
-        error ("unsupported type of ticklabel");
+        error ("__go_draw_axes__: unsupported type of ticklabel");
       endif
     else
       fprintf (plot_stream, "set format %s \"%s\";\n", ax, fmt);
       if (mirror)
         fprintf (plot_stream, "set %stics %s %s %s mirror (", ax, tickdir,
                  ticklength, axispos);
       else
         fprintf (plot_stream, "set %stics %s %s %s nomirror (", ax, tickdir,
diff --git a/scripts/plot/__marching_cube__.m b/scripts/plot/__marching_cube__.m
--- a/scripts/plot/__marching_cube__.m
+++ b/scripts/plot/__marching_cube__.m
@@ -91,29 +91,29 @@ function [T, p, col] = __marching_cube__
   endif
    
   if ((nargin != 5 && nargin != 6) || (nargout != 2 && nargout != 3))
     print_usage ();
   endif
   
   if (!ismatrix (xx) || !ismatrix (yy) || !ismatrix (zz) || !ismatrix (c) || ...
     ndims (xx) != 3 || ndims (yy) != 3 || ndims (zz) != 3 || ndims (c) != 3)
-    error ("xx, yy, zz, c have to be matrizes of dim 3");
+    error ("__marching_cube__: xx, yy, zz, c have to be matrizes of dim 3");
   endif
   
   if (!size_equal (xx, yy, zz, c))
-    error ("xx, yy, zz, c are not the same size");
+    error ("__marching_cube__: xx, yy, zz, c are not the same size");
   endif
   
   if (any (size (xx) < [2 2 2]))
-    error ("grid size has to be at least 2x2x2");
+    error ("__marching_cube__: grid size has to be at least 2x2x2");
   endif
   
   if (!isscalar (iso))
-    error ("iso needs to be scalar value");
+    error ("__marching_cube__: iso needs to be scalar value");
   endif
 
   if (nargin == 6)
     if ( !ismatrix (colors) || ndims (colors) != 3 || size (colors) != size (c) )
       error ( "color has to be matrix of dim 3 and of same size as c" );
     endif
     calc_cols = true;
     lindex = 5;
@@ -204,17 +204,17 @@ endfunction
 function p = vertex_interp(isolevel,p1x, p1y, p1z,...
   p2x, p2y, p2z,valp1,valp2, col1, col2)
   
   if (nargin == 9)
     p = zeros (length (p1x), 3);
   elseif (nargin == 11)
     p = zeros (length (p1x), 4);
   else 
-    error ("Wrong number of arguments");
+    error ("__marching_cube__: wrong number of arguments");
   endif
   mu = zeros (length (p1x), 1);
   id = abs (valp1-valp2) < (10*eps) .* (abs (valp1) .+ abs (valp2));
   if (any (id))
     p(id, 1:3) = [ p1x(id), p1y(id), p1z(id) ];
     if (nargin == 11)
       p(id, 4) = col1(id);
     endif
diff --git a/scripts/plot/gnuplot_drawnow.m b/scripts/plot/gnuplot_drawnow.m
--- a/scripts/plot/gnuplot_drawnow.m
+++ b/scripts/plot/gnuplot_drawnow.m
@@ -219,17 +219,17 @@ function [enhanced, implicit_margin] = g
             gnuplot_size = gnuplot_size * get (h, "__pixels_per_inch__");
           else
             ## Implicit margins are in units of "inches"
             gnuplot_size = gnuplot_size - implicit_margin;
           endif
         endif
         [begin_match, end_match, te, match] = regexp (opts_str, "(\\s-r\\d+)|(^-r\\d+)");
         if (! isempty (begin_match))
-          error ("gnuplot_drawnow.m: specifying resultion, '%s', not supported for terminal '%s'",
+          error ("gnuplot_drawnow: specifying resultion, '%s', not supported for terminal '%s'",
                  strtrim (match{1}), term)
         endif
         if (all (gnuplot_size > 0))
           ## Set terminal size.
           terminals_with_size = {"emf", "gif", "jpeg", "latex", "pbm", ...
                                  "pdf", "png", "postscript", "svg", ...
                                  "epslatex", "pstex", "pslatex", "tikz"};
           if (__gnuplot_has_feature__ ("x11_figure_position"))
diff --git a/scripts/plot/ishold.m b/scripts/plot/ishold.m
--- a/scripts/plot/ishold.m
+++ b/scripts/plot/ishold.m
@@ -35,20 +35,20 @@ function retval = ishold (h)
           ax = __go_axes__ (h);
           set (h, "currentaxes", ax);
         endif
         fig = h;
       elseif (strcmpi (get (h, "type"), "axes"))
         ax = h;
         fig = get (h, "parent");
       else
-        error ("hold: expecting argument to be axes or figure graphics handle");
+        error ("ishold: expecting argument to be axes or figure graphics handle");
       endif
     else
-      error ("hold: expecting argument to be axes or figure graphics handle");
+      error ("ishold: expecting argument to be axes or figure graphics handle");
     endif
   else
     print_usage ();
   endif
 
   retval = (strcmpi (get (fig, "nextplot"), "add")
             && strcmpi (get (ax, "nextplot"), "add"));
 
diff --git a/scripts/plot/isocolors.m b/scripts/plot/isocolors.m
--- a/scripts/plot/isocolors.m
+++ b/scripts/plot/isocolors.m
@@ -132,17 +132,17 @@ function varargout = isocolors(varargin)
   endswitch
   if (ismatrix (vp) && size (vp,2) == 3)
     pa = [];
     v = vp;
   elseif ( ishandle (vp) )
     pa = vp;
     v = get (pa, "Vertices");
   else
-    error("Last argument is no vertex list and no patch handle");
+    error("isocolors: last argument is not a vertex list or patch handle");
   endif
   if ( calc_rgb )
     new_col = zeros (size (v, 1), 3);
     new_col(:, 1) = __interp_cube__ (x, y, z, R, v, "values" );
     new_col(:, 2) = __interp_cube__ (x, y, z, G, v, "values" );
     new_col(:, 3) = __interp_cube__ (x, y, z, B, v, "values" );
   else
     new_col = __interp_cube__ (x, y, z, c, v, "values" );
diff --git a/scripts/plot/isonormals.m b/scripts/plot/isonormals.m
--- a/scripts/plot/isonormals.m
+++ b/scripts/plot/isonormals.m
@@ -93,17 +93,17 @@
 function varargout = isonormals(varargin)
   na = nargin;
   negate = false;
   if (ischar (varargin{nargin}))
     na = nargin-1;
     if (strcmp (lower (varargin{nargin}), "negate"))
       negate = true;
     else
-      error ("Unknown option '%s'", varargin{nargin});
+      error ("isonormals: Unknown option '%s'", varargin{nargin});
     endif
   endif
   switch na
     case 2
       c = varargin{1};
       vp = varargin{2};
       x = 1:size (c, 2);
       y = 1:size (c, 1);
@@ -119,17 +119,17 @@ function varargout = isonormals(varargin
   endswitch
   if (ismatrix (vp) && size (vp,2) == 3)
     pa = [];
     v = vp;
   elseif (ishandle (vp))
     pa = vp;
     v = get (pa, "Vertices");
   else
-    error ("Last argument is no vertex list and no patch handle");
+    error ("isonormals: Last argument is not a vertex list or a patch handle");
   endif
   if (negate)
     normals = -__interp_cube__ (x, y, z, c, v, "normals");
   else
     normals = __interp_cube__ (x, y, z, c, v, "normals");
   endif
   switch nargout
     case 0
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -251,17 +251,17 @@ function print (varargin)
         elseif (length (arg) > 2 && arg(1:2) == "-P")
           printer = arg;
         elseif ((length (arg) > 2) && arg(1:2) == "-G")
           ghostscript_binary = arg(3:end);
           if (exist (ghostscript_binary, "file") != 2)
             ghostscript_binary = file_in_path (EXEC_PATH, ghostscript_binary);
           endif
           if (isempty (ghostscript_binary))
-            error ("print.m: Ghostscript binary ""%s"" could not be located", arg(3:end))
+            error ("print: Ghostscript binary ""%s"" could not be located", arg(3:end))
           endif
         elseif (length (arg) > 2 && arg(1:2) == "-F")
           idx = rindex (arg, ":");
           if (idx)
             font = arg(3:idx-1);
             fontsize = arg(idx+1:length(arg));
           else
             font = arg(3:length(arg));
@@ -698,17 +698,17 @@ function print (varargin)
       if (append_to_file)
         ghostscript_options = "-q -dBATCH -dSAFER -dNOPAUSE";
         command = sprintf ("%s %s -sDEVICE=%s -sOutputFile=%s %s %s -q", ...
                     ghostscript_binary, ghostscript_options, ghostscript_device,  ...
                     temp_name, appended_file_name, name);
         status1 = system (command);
         status2 = system (sprintf ("mv %s %s", temp_name, appended_file_name));
         if (status1 != 0 || status2 != 0)
-          error ("print.m: output failed to append to '%s'.", appended_file_name);
+          error ("print: output failed to append to '%s'.", appended_file_name);
         endif
       endif
     unwind_protect_cleanup
       ## FIXME - it would be nice to delete "__pixels_per_inch__" property here.
       if (restore_properties)
         props = fieldnames (p);
         for n = 1:numel(props)
           set (gcf, props{n}, p.(props{n}))
diff --git a/scripts/plot/private/__add_datasource__.m b/scripts/plot/private/__add_datasource__.m
--- a/scripts/plot/private/__add_datasource__.m
+++ b/scripts/plot/private/__add_datasource__.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{newargs} =} __add_datasource__ (@var{fcn}, @var{h}, @var{data}, @var{varargin})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function newargs = __add_datasource__ (fcn, h, data, varargin)
 
   if (nargin < 3)
-    error ("internal error");
+    error ("__add_datasource__: a minimum of 3 inputs are required");
   endif
 
   if (ischar (data))
     data = {data};
   endif
 
   for i = 1 : numel (data)
     addproperty (strcat (data{i}, "datasource"), h, "string", "");
diff --git a/scripts/plot/private/__color_str_rgb__.m b/scripts/plot/private/__color_str_rgb__.m
--- a/scripts/plot/private/__color_str_rgb__.m
+++ b/scripts/plot/private/__color_str_rgb__.m
@@ -40,11 +40,11 @@ function rgb = __color_str_rgb__ (str)
     elseif (strncmpi (str, "cyan", 4))
       rgb = [0, 1, 1];
     elseif (strncmpi (str, "white", 5))
       rgb = [1, 1, 1];
     else
       rgb = [0, 0, 0];
     endif
   else
-    error ("expecting a string argument");
+    error ("__color_str_rgb__: expecting a string argument");
   endif
 endfunction
diff --git a/scripts/plot/private/__errplot__.m b/scripts/plot/private/__errplot__.m
--- a/scripts/plot/private/__errplot__.m
+++ b/scripts/plot/private/__errplot__.m
@@ -82,17 +82,17 @@ function h = __errplot__ (fstr, p, varar
           ldata = [];
           udata = [];
         elseif (strcmp (ifmt, "yerr") || strcmp (ifmt, "boxy"))
           ldata = varargin{2}(:,i);
           udata = ldata;
           xldata = [];
           xudata = [];
         else
-          error ("2 column errorplot is only valid or xerr or yerr");
+          error ("errorbar: 2 column errorplot is only valid or xerr or yerr");
         endif
       case 3
         if (strcmp (ifmt, "boxxy") || strcmp (ifmt, "xyerr"))
           ydata = varargin{1}(:,i);
           xdata = 1:numel(ydata);
           xldata = varargin{2}(:,i);
           xudata = xldata;
           ldata = varargin{3}(:,i);
@@ -139,20 +139,20 @@ function h = __errplot__ (fstr, p, varar
         if (strcmp (ifmt, "boxxy") || strcmp (ifmt, "xyerr"))
           xdata = varargin{1}(:,i);
           ydata = varargin{2}(:,i);
           xldata = varargin{3}(:,i);
           xudata = varargin{4}(:,i);
           ldata = varargin{5}(:,i);
           udata = varargin{6}(:,i);
         else
-          error ("error plot with 6 columns only valid for boxxy and xyerr");
+          error ("errorbar: error plot with 6 columns only valid for boxxy and xyerr");
         endif        
       otherwise
-        error ("error plot requires 2, 3, 4 or 6 arguments.");
+        error ("errorbar: error plot requires 2, 3, 4 or 6 arguments.");
     endswitch
 
     addproperty ("xdata", hg, "data", xdata(:))
     addproperty ("ydata", hg, "data", ydata(:))
     addproperty ("ldata", hg, "data", ldata(:))
     addproperty ("udata", hg, "data", udata(:))
     addproperty ("xldata", hg, "data", xldata(:))
     addproperty ("xudata", hg, "data", xudata(:))
@@ -253,17 +253,17 @@ function [xdata, ydata] = errorbar_data 
     [x1, y1] = errorbar_data (xdata, ydata, ldata, udata, 
                               xldata, xudata, "xerr", xscale, yscale);
     [x2, y2] = errorbar_data (xdata, ydata, ldata, udata, 
                               xldata, xudata, "yerr", xscale, yscale);
     xdata = [x1; x2];
     ydata = [y1; y2];
     return
   else
-      error ("valid error bar types are xerr, yerr, boxxy, and xyerr.")
+      error ("errorbar: valid error bar types are xerr, yerr, boxxy, and xyerr.")
   endif
   xdata = xdata.'(:);
   ydata = ydata.'(:);
 endfunction
 
 function update_props (hg, dummy, hl)
   set (hl, "color", get (hg, "color"), 
            "linewidth", get (hg, "linewidth"));,
diff --git a/scripts/plot/private/__interp_cube__.m b/scripts/plot/private/__interp_cube__.m
--- a/scripts/plot/private/__interp_cube__.m
+++ b/scripts/plot/private/__interp_cube__.m
@@ -26,26 +26,26 @@ function [Vxyz, idx, frac] = __interp_cu
     x = squeeze (x(1,:,1))(:);
     y = squeeze (y(:,1,1))(:);
     z = squeeze (z(1,1,:))(:);
   elseif (isvector (x) && isvector (y) && isvector (z) )
     x = x(:);
     y = y(:);
     z = z(:);
   else
-    error("x, y, z have wrong dimensions");
+    error("__interp_cube__: x, y, z have wrong dimensions");
   endif
   if (size (val) != [length(x), length(y), length(z)])
-    error ("val has wrong dimensions");
+    error ("__interp_cube__: val has wrong dimensions");
   endif
   if (size (v, 2) != 3)
     error ( "v has to be N*3 matrix");
   endif
   if (!ischar (req))
-   error ("Invalid request parameter use 'values', 'normals' or 'normals8'");
+   error ("__interp_cube__: Invalid request parameter use 'values', 'normals' or 'normals8'");
   endif
   if (isempty (v))
     Vxyz = idx = frac = [];
     return
   endif
 
   switch req
     case "values"
@@ -89,17 +89,17 @@ function [Vxyz, idx, frac] = __interp_cu
       dy = y(2:end) - y(1:end-1);
       dz = z(2:end) - z(1:end-1);
       dx = [dx;dx(end)](idx(:,2));
       dy = [dy;dy(end)](idx(:,1));
       dz = [dz;dz(end)](idx(:,3));
       [Dx, Dy, Dz, idx, frac] = interp_cube_trilin_grad (x, y, z, val, v);
       Vxyz = [Dx./dx, Dy./dy, Dz./dz];
    otherwise
-     error ("Invalid request type '%s', use 'values', 'normals' or 'normals8'", req);
+     error ("__interp_cube__: Invalid request type '%s', use 'values', 'normals' or 'normals8'", req);
   endswitch
 endfunction
 
 function [Vxyz, idx, frac] = interp_cube_trilin(x, y, z, val, v)
   [idx, frac] = cube_idx (x(:), y(:), z(:), v);
   sval = size (val);
   i000 = sub2ind (sval, idx(:, 1), idx(:, 2), idx(:, 3));
   i100 = sub2ind (sval, idx(:, 1)+1, idx(:, 2), idx(:, 3));
@@ -173,9 +173,9 @@ function [idx, frac] = cube_idx(x, y, z,
   frac(:, 2) = (v(:, 1) - x(idx(:, 2)) )...
       ./ (x(idx(:, 2)+1) - x(idx(:, 2)));
   idx(:, 1) = lookup (y(2:end-1), v(:, 2)) + 1;
   frac(:, 1) = (v(:, 2) - y(idx(:, 1))) ...
       ./ (y(idx(:, 1)+1) - y(idx(:, 1)));
   idx(:, 3) = lookup (z(2:end-1), v(:, 3)) + 1;
   frac(:, 3) = (v(:, 3) - z(idx(:, 3))) ...
       ./ (z(idx(:, 3)+1) - z(idx(:, 3)));
-endfunction
\ No newline at end of file
+endfunction
diff --git a/scripts/plot/shading.m b/scripts/plot/shading.m
--- a/scripts/plot/shading.m
+++ b/scripts/plot/shading.m
@@ -62,17 +62,17 @@ function shading (varargin)
       set (h, "edgecolor", "none");
     elseif (strcmpi (mode, "interp"))
       set (h, "facecolor", "interp");
       set (h, "edgecolor", "none");
     elseif (strcmpi (mode, "faceted"))
       set (h, "facecolor", "flat");
       set (h, "edgecolor", [0 0 0]);
     else
-      error ("unknown argument");
+      error ("shading: unknown argument");
     endif
   endfor
 
 endfunction
 
 %!demo
 %! clf
 %! colormap (jet)
diff --git a/scripts/plot/specular.m b/scripts/plot/specular.m
--- a/scripts/plot/specular.m
+++ b/scripts/plot/specular.m
@@ -53,17 +53,17 @@ function retval = specular (sx, sy, sz, 
   if (length (lv) < 2 || length (lv) > 3)
     error ("specular: light vector LV must be a 2- or 3-element vector");
   elseif (length (lv) == 2)
     [lv(1), lv(2), lv(3)] = sph2cart (lv(1) * pi/180, lv(2) * pi/180, 1.0);
   endif
 
   ## Check for view vector (vv) argument.
   if (length (vv) < 2 || length (lv) > 3)
-    error ("view vector VV must be a 2- or 3-element vector");
+    error ("specular: view vector VV must be a 2- or 3-element vector");
   elseif (length (vv) == 2)
     [vv(1), vv(2), vv(3)] = sph2cart (vv(1) * pi / 180, vv(2) * pi / 180, 1.0);
   endif
 
   ## Normalize view and light vector.
   if (sum (abs (lv)) > 0)
     lv  /= norm (lv);
   endif
diff --git a/scripts/polynomial/deconv.m b/scripts/polynomial/deconv.m
--- a/scripts/polynomial/deconv.m
+++ b/scripts/polynomial/deconv.m
@@ -36,17 +36,17 @@
 
 function [b, r] = deconv (y, a)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (! (isvector (y) && isvector (a)))
-    error("conv: both arguments must be vectors");
+    error("deconv: both arguments must be vectors");
   endif
 
   la = length (a);
   ly = length (y);
 
   lb = ly - la + 1;
 
   ## Ensure A is oriented as Y.
diff --git a/scripts/polynomial/polyint.m b/scripts/polynomial/polyint.m
--- a/scripts/polynomial/polyint.m
+++ b/scripts/polynomial/polyint.m
@@ -37,17 +37,17 @@ function p = polyint (p, k)
 
   if (nargin == 1)
     k = 0;
   elseif (! isscalar (k))
     error ("polyint: the constant of integration must be a scalar");
   endif
 
   if (! (isvector (p) || isempty (p)))
-    error ("argument must be a vector");
+    error ("polyint: argument must be a vector");
   endif
 
   lp = length (p);
 
   if (lp == 0)
     p = [];
     return;
   endif
diff --git a/scripts/polynomial/ppint.m b/scripts/polynomial/ppint.m
--- a/scripts/polynomial/ppint.m
+++ b/scripts/polynomial/ppint.m
@@ -23,17 +23,17 @@
 ## @seealso{mkpp,ppval}
 ## @end deftypefn
 
 function ppi = ppint (pp, c)
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
   if (! isstruct (pp))
-    error ("ppder: expects a pp structure");
+    error ("ppint: expects a pp structure");
   endif
 
   [x, p, n, k, d] = unmkpp (pp);
   p = reshape (p, [], k);
   
   ## Get piecewise antiderivatives
   pi = p / diag (k:-1:1);
   k += 1;
diff --git a/scripts/set/powerset.m b/scripts/set/powerset.m
--- a/scripts/set/powerset.m
+++ b/scripts/set/powerset.m
@@ -26,19 +26,19 @@
 ## @seealso{unique, union, setxor, setdiff, ismember}
 
 function p = powerset (a, byrows_arg)
 
   byrows = false;
 
   if (nargin == 2)
     if (! strcmpi (byrows_arg, "rows"))
-      error ("expecting third argument to be \"rows\"");
+      error ('powerset: expecting third argument to be "rows"');
     elseif (iscell (a))
-      warning ("setdiff: \"rows\" not valid for cell arrays");
+      warning ('powerset: "rows" not valid for cell arrays');
     else
       byrows = true;
     endif
   elseif (nargin != 1)
     print_usage ();
   endif
 
   if (byrows)
diff --git a/scripts/signal/arch_fit.m b/scripts/signal/arch_fit.m
--- a/scripts/signal/arch_fit.m
+++ b/scripts/signal/arch_fit.m
@@ -53,26 +53,26 @@
 
 function [a, b] = arch_fit (y, X, p, ITER, gamma, a0, b0)
 
   if ((nargin < 3) || (nargin == 6) || (nargin > 7))
     print_usage ();
   endif
 
   if (! (isvector (y)))
-    error ("arch_test: y must be a vector");
+    error ("arch_fit: y must be a vector");
   endif
 
   T   = length (y);
   y   = reshape (y, T, 1);
   [rx, cx] = size (X);
   if ((rx == 1) && (cx == 1))
     X = autoreg_matrix (y, X);
   elseif (! (rx == T))
-    error ("arch_test: either rows (X) == length (y), or X is a scalar");
+    error ("arch_fit: either rows (X) == length (y), or X is a scalar");
   endif
 
   [T, k] = size (X);
 
   if (nargin == 7)
     a   = a0;
     b   = b0;
     e   = y - X * b;
diff --git a/scripts/signal/arch_test.m b/scripts/signal/arch_test.m
--- a/scripts/signal/arch_test.m
+++ b/scripts/signal/arch_test.m
@@ -64,17 +64,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Test for conditional heteroscedascity
 
 function [pval, lm] = arch_test (y, X, p)
 
   if (nargin != 3)
-    error ("arch_test needs 3 input arguments");
+    error ("arch_test: 3 input arguments required");
   endif
 
   if (! (isvector (y)))
     error ("arch_test: y must be a vector");
   endif
   T   = length (y);
   y   = reshape (y, T, 1);
   [rx, cx] = size (X);
@@ -89,9 +89,9 @@ function [pval, lm] = arch_test (y, X, p
 
   [b, v_b, e] = ols (y, X);
   Z    = autoreg_matrix (e.^2, p);
   f    = e.^2 / v_b - ones (T, 1);
   f    = Z' * f;
   lm   = f' * inv (Z'*Z) * f / 2;
   pval = 1 - chisquare_cdf (lm, p);
 
-endfunction
\ No newline at end of file
+endfunction
diff --git a/scripts/signal/durbinlevinson.m b/scripts/signal/durbinlevinson.m
--- a/scripts/signal/durbinlevinson.m
+++ b/scripts/signal/durbinlevinson.m
@@ -46,17 +46,17 @@ function [newphi, newv] = durbinlevinson
   newphi = 0;
   newv = 0;
 
   if (nargin == 3)
 
     t = length (oldphi) + 1;
 
     if (length (c) < t+1)
-      error ("durbilevinson: c too small");
+      error ("durbinlevinson: c too small");
     endif
 
     if (oldv == 0)
       error ("durbinlevinson: oldv = 0");
     endif
 
     if (rows (oldphi) > 1)
       oldphi = oldphi';
diff --git a/scripts/special-matrix/hadamard.m b/scripts/special-matrix/hadamard.m
--- a/scripts/special-matrix/hadamard.m
+++ b/scripts/special-matrix/hadamard.m
@@ -84,17 +84,17 @@ function h = hadamard (n)
       h = 1;
     case 3
       h = h12 ();
     case 5
       h = h20 ();
     case 7
       h = hnormalize (h28 ());
     otherwise
-      error ("n must be 2^k*p, for p = 1, 12, 20 or 28");
+      error ("hadamard: n must be 2^k*p, for p = 1, 12, 20 or 28");
   endswitch
 
   ## Build H(2^k*n) from kron(H(2^k),H(n)).
   h2 = [1,1;1,-1];
   while (true)
     if (floor (k/2) != k/2)
       h = kron (h2, h); 
     endif
diff --git a/scripts/statistics/distributions/unidrnd.m b/scripts/statistics/distributions/unidrnd.m
--- a/scripts/statistics/distributions/unidrnd.m
+++ b/scripts/statistics/distributions/unidrnd.m
@@ -44,17 +44,17 @@ function retval = unidrnd (n, varargin)
   elseif (nargin > 2)
     for i = 1:nargin-1
       if (! isscalar (varargin{i}))
         error ("unidrnd: expecting scalar dimensions");
       endif
     endfor
     dims = [varargin{:}];
   else
-    error ("unidrnd (n, ...)");
+    error ("unidrnd: Usage unirnd (n, ...)");
   endif
   if (isscalar (n)
       || (length (size (n)) == length (dims) && all (size (n) == dims)))
     retval = ceil (rand (dims) .* n);
   else
     error ("unidrnd: dimension mismatch");
   endif
 endfunction
diff --git a/scripts/statistics/distributions/unifinv.m b/scripts/statistics/distributions/unifinv.m
--- a/scripts/statistics/distributions/unifinv.m
+++ b/scripts/statistics/distributions/unifinv.m
@@ -36,17 +36,17 @@ function inv = unifinv (x, a, b)
   if (nargin == 1)
     a = 0;
     b = 1;
   endif
 
   if (!isscalar (a) || !isscalar(b))
     [retval, x, a, b] = common_size (x, a, b);
     if (retval > 0)
-      error ("uniform_cdf: x, a and b must be of common size or scalar");
+      error ("unifinv: x, a and b must be of common size or scalar");
     endif
   endif
 
   sz = size (x);
   inv = zeros (sz);
 
   k = find ((x < 0) | (x > 1) | isnan (x) | !(a < b));
   if (any (k))
diff --git a/scripts/statistics/models/logistic_regression.m b/scripts/statistics/models/logistic_regression.m
--- a/scripts/statistics/models/logistic_regression.m
+++ b/scripts/statistics/models/logistic_regression.m
@@ -91,17 +91,17 @@ function [theta, beta, dev, dl, d2l, p] 
   ## check input
   y = round (vec (y));
   [my, ny] = size (y);
   if (nargin < 2)
     x = zeros (my, 0);
   endif;
   [mx, nx] = size (x);
   if (mx != my)
-    error ("x and y must have the same number of observations");
+    error ("logistic_regression: x and y must have the same number of observations");
   endif
 
   ## initial calculations
   x = -x;
   tol = 1e-6; incr = 10; decr = 2;
   ymin = min (y); ymax = max (y); yrange = ymax - ymin;
   z  = (y * ones (1, yrange)) == ((y * 0 + 1) * (ymin : (ymax - 1)));
   z1 = (y * ones (1, yrange)) == ((y * 0 + 1) * ((ymin + 1) : ymax));
@@ -136,17 +136,17 @@ function [theta, beta, dev, dl, d2l, p] 
     tb = tbold - d2l \ dl;
     [g, g1, p, dev] = logistic_regression_likelihood (y, x, tb, z, z1);
     if ((dev - devold) / (dl' * (tb - tbold)) < 0)
       epsilon = epsilon / decr;
     else
       while ((dev - devold) / (dl' * (tb - tbold)) > 0)
         epsilon = epsilon * incr;
          if (epsilon > 1e+15)
-           error ("epsilon too large");
+           error ("logistic_regression: epsilon too large");
          endif
          tb = tbold - (d2l - epsilon * eye (size (d2l))) \ dl;
          [g, g1, p, dev] = logistic_regression_likelihood (y, x, tb, z, z1);
          disp ("epsilon"); disp (epsilon);
       endwhile
     endif
     [dl, d2l] = logistic_regression_derivatives (x, z, z1, g, g1, p);
     if (print == 2)
diff --git a/scripts/strings/strjust.m b/scripts/strings/strjust.m
--- a/scripts/strings/strjust.m
+++ b/scripts/strings/strjust.m
@@ -44,17 +44,17 @@ function y = strjust (x, just)
 
   if (nargin == 1)
     just = "right";
   else
     just = tolower (just);
   endif
 
   if (ndims (x) != 2)
-    error ("needs a string or character matrix");
+    error ("strjust: input must be a string or character matrix");
   endif
 
   if (isempty (x))
     y = x;
   else
     ## Apparently, Matlab considers nulls to be blanks as well; however, does
     ## not preserve the nulls, but rather converts them to blanks.  That's a
     ## bit unexpected, but it allows simpler processing, because we can move
diff --git a/scripts/testfun/rundemos.m b/scripts/testfun/rundemos.m
--- a/scripts/testfun/rundemos.m
+++ b/scripts/testfun/rundemos.m
@@ -63,15 +63,15 @@ function run_all_demos (directory)
       endif
     endif
   endfor
 endfunction
 
 function retval = has_demos (f)
   fid = fopen (f);
   if (f < 0)
-    error ("fopen failed: %s", f);
+    error ("rundemos: fopen failed: %s", f);
   else
     str = fscanf (fid, "%s");
     fclose (fid);
     retval = findstr (str, "%!demo");
   endif
 endfunction
diff --git a/scripts/testfun/runtests.m b/scripts/testfun/runtests.m
--- a/scripts/testfun/runtests.m
+++ b/scripts/testfun/runtests.m
@@ -82,17 +82,17 @@ function retval = has_tests (f)
       ln = fgetl (fid);
       if (! isempty (regexp (ln, "%!(assert|error|test)", "lineanchors")))
         retval = true;
         break;
       endif
     endwhile
     fclose (fid);
   else
-    error ("fopen failed: %s", f);
+    error ("runtests: fopen failed: %s", f);
   endif
 endfunction
 
 function print_pass_fail (n, p)
   if (n > 0)
     printf (" PASS %4d/%-4d", p, n);
     nfail = n - p;
     if (nfail > 0)
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -100,17 +100,17 @@ function [__ret1, __ret2, __ret3, __ret4
   __batch = (! isempty (__fid));
 
   ## Decide if error messages should be collected.
   __close_fid = 0;
   if (__batch)
     if (ischar (__fid))
       __fid = fopen (__fid, "wt");
       if (__fid < 0)
-        error ("could not open log file");
+        error ("test: could not open log file");
       endif
       __close_fid = 1;
     endif
     fprintf (__fid, "%sprocessing %s\n", __signal_file, __name);
     fflush (__fid);
   else
     __fid = stdout;
   endif
@@ -144,17 +144,17 @@ function [__ret1, __ret2, __ret3, __ret4
     fprintf (__fid, "# case an error will be reported) or an unexpected\n");
     fprintf (__fid, "# success (in which case no error will be reported).\n");
     fflush (__fid);
     if (__close_fid)
       fclose(__fid);
     endif
     return;
   else
-    error ("test unknown flag '%s'", __flag);
+    error ("test: unknown flag '%s'", __flag);
   endif
 
   ## Locate the file to test.
   __file = file_in_loadpath (__name, "all");
   if (isempty (__file))
     __file = file_in_loadpath (cstrcat (__name, ".m"), "all");
   endif
   if (isempty (__file))
diff --git a/scripts/time/datenum.m b/scripts/time/datenum.m
--- a/scripts/time/datenum.m
+++ b/scripts/time/datenum.m
@@ -75,17 +75,17 @@ function [days, secs] = datenum (Y, M, D
     [Y, M, D, h, m, s] = datevec (Y, M);
   else
     if (nargin < 6) s = 0; endif
     if (nargin < 5) m = 0; endif
     if (nargin < 4) h = 0; endif
     if (nargin == 1)
       nc = columns (Y);
       if (nc > 6 || nc < 3)
-        error ("expected date vector containing [Y, M, D, h, m, s]");
+        error ("datenum: expected date vector containing [Y, M, D, h, m, s]");
       endif
       s = m = h = 0;
       if (nc >= 6) s = Y(:,6); endif
       if (nc >= 5) m = Y(:,5); endif
       if (nc >= 4) h = Y(:,4); endif
       D = Y(:,3);
       M = Y(:,2);
       Y = Y(:,1);
