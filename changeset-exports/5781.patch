# HG changeset patch
# User jwe
# Date 1146598821 0
#      Tue May 02 19:40:21 2006 +0000
# Node ID faafc2d98b8d5055c035b13f32f8625b6f3c2c07
# Parent  cbf717bf81507a7952e61ff05e2b0fcc5466e345
[project @ 2006-05-02 19:40:19 by jwe]

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,17 @@
+2006-05-02  John W. Eaton  <jwe@octave.org>
+
+	* NEWS: New contents for 3.0.
+	* NEWS.2: Move contents of NEWS here.
+
+2006-04-29  John W. Eaton  <jwe@octave.org>
+
+	* run-octave.in: Execute $builddir/src/octave, not src/octave.
+
 2006-04-26  Thomas Weber  <thomas.weber.mail@gmail.com>
 
 	* configure.in: Fix apiversion vs. api_version typo.
 
 2006-04-25  John W. Eaton  <jwe@octave.org>
 
 	* Makefile.in (TARGETS): Include run-octave and .gdbinit in the list.
 	* Makeconf.in (subst-script-vals): New macro.
diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -1,1036 +1,47 @@
-Summary of changes for version 2.1.x:
-------------------------------------
-
-  * Given a matrix, X, and a boolean index, idx, of the same shape as
-    X, X(idx) and X(idx) = RHS now work no matter what the value of
-    do_fortran_indexing is.
-
-  * If you are using GNU Emacs 19.34 or earlier, you will need to add
-    the following code to your ~/.emacs file in order to use Emacs
-    Octave mode:
-
-      ;; Set up the custom library.
-      ;; taken from http://www.dina.kvl.dk/~abraham/custom/
-      (eval-and-compile
-	(condition-case ()
-	    (require 'custom)
-	  (error nil))
-	(if (and (featurep 'custom) (fboundp 'custom-declare-variable))
-	    nil ;; We've got what we needed
-	  ;; We have the old custom-library, hack around it!
-	  (defmacro defgroup (&rest args)
-	    nil)
-	  (defmacro defcustom (var value doc &rest args) 
-	    (` (defvar (, var) (, value) (, doc))))))
-
-  * When `format +' is in effect, Octave uses the following symbols to
-    provide more information about the values in a matrix:
-
-      +      postive real
-      -      negative real
-      i      pure imaginary
-      c      complex
-      blank  zero
-
-  * The ++ and -- operators now work for indexed matrices, and the
-    following operators now work:
-
-      +=, -=, *=, /=, \=, <<=, >>=, .*=, ./=, .\=, &=, |=
-
-    These operators are currently implemented using a relatively
-    inefficient brute-force method but hey, they work.
-
-  * The built-in variable argv is now a list of strings instead of a
-    string vector.
-
-  * The value of LOADPATH set by the environment variable
-    OCTAVE_PATH, the -p or --path command line options, or on the
-    command line is no longer modified to include the default path.
-    Instead it is left as specified.  Its default value is now ":",
-    which tells Octave to search the default path, and the new
-    built-in variable DEFAULT_LOADPATH contains the default list of
-    directories to search.  
-
-  * The function file_in_path no longer does any special processing of
-    its PATH argument.  To search LOADPATH for files, it is now
-    generally better to use the new function file_in_loadpath.
-
-  * If fread is given a skip parameter, the skip is performed after
-    the read instead of before (for compatibility with Matlab).
-
-  * The new built-in variable `crash_dumps_octave_core' controls
-    whether Octave writes user variables to the file `octave-core'
-    when it crashes or is killed by a signal.  The default value is 1
-    (0 if you use --traditional).
-
-  * If LOADPATH contains a doubled colon, the default path is inserted
-    in its place.  This is similar to the substitution that also takes
-    place for leading or trailing colons in the LOADPATH.
-
-  * Loops of the form `for i = STRING ... endfor' are now allowed.
-
-  * It is now possible to set the iteration limit for lsode using
-    lsode_options ("step limit", N).
-
-  * New functions:
-
-      is_complex  -- tell whether a variable is complex
-      rehash      -- re-initialize the cache of directories in LOADPATH
-      graw        -- send a string to the gnuplot subprocess
-
-  * New functions from Kurt Hornik's Octave-ci package:
-
-    In finance (new directory):
-
-      fv    -- future value of an investment
-      fvl   -- future value of an initial lump sum investment
-      irr   -- internal rate of return of an investment
-      nper  -- number of payments needed for amortizing a loan
-      npv   -- net present value of a series of payments
-      pmt   -- amount of periodic payment needed to amortize a loan
-      pv    -- present value of an investment
-      pvl   -- present value of an investment that pays off at the end
-      rate  -- rate of return of an investment
-      vol   -- volatility of financial time series data
-
-    In linear-algebra:
-
-      dmult -- rescale the rows of a matrix
-
-    In signal:
-
-      arch_fit       -- fit an ARCH regression model
-      arch_rnd       -- simulate an ARCH process
-      arch_test      -- test for conditional heteroscedascity
-      arma_rnd       -- simulate an ARMA process
-      autocor        -- compute autocorrelations
-      autocov        -- compute autocovariances
-      autoreg_matrix -- design matrix for autoregressions
-      bartlett       -- coefficients of the Bartlett (triangular) window
-      blackman       -- coefficients of the Blackman window
-      diffpara       -- estimate the fractional differencing parameter
-      durbinlevinson -- perform one step of the Durbin-Levinson algorithm
-      fractdiff      -- compute fractional differences
-      hamming        -- coefficients of the Hamming window
-      hanning        -- coefficients of the Hanning window
-      hurst          -- estimate the Hurst parameter
-      periodogram    -- compute the periodogram
-      rectangle_lw   -- rectangular lag window
-      rectangle_sw   -- rectangular spectral window
-      sinetone       -- compute a sine tone
-      sinewave       -- compute a sine wave
-      spectral_adf   -- spectral density estimation
-      spectral_xdf   -- spectral density estimation
-      spencer        -- apply Spencer's 15-point MA filter
-      stft           -- short-term Fourier transform
-      synthesis      -- recover a signal from its short-term Fourier transform
-      triangle_lw    -- triangular lag window
-      triangle_sw    -- triangular spectral window
-      yulewalker     -- fit AR model by Yule-Walker method
-
-    In statistics/base (new directory):
-
-      center     -- center by subtracting means
-      cloglog    -- complementary log-log function
-      cor        -- compute correlations
-      cov        -- compute covariances
-      cut        -- cut data into intervals
-      iqr        -- interquartile range
-      kendall    -- kendall's rank correlation tau
-      logit      -- logit transformation
-      mean       -- compute arithmetic, geometric, and harmonic mean
-      meansq     -- compute mean square
-      moment     -- compute moments
-      ppplot     -- perform a PP-plot (probability plot)
-      probit     -- probit transformation
-      qqplot     -- perform a QQ-plot (quantile plot)
-      range      -- compute range
-      ranks      -- compute ranks
-      run_count  -- count upward runs
-      spearman   -- spearman's rank correlation rho
-      statistics -- compute basic statistics
-      studentize -- subtract mean and divide by standard deviation
-      table      -- cross tabulation
-      values     -- extract unique elements
-      var        -- compute variance
-
-    In statistics/distributions (new directory):
-
-      beta_cdf           -- CDF of the Beta distribution
-      beta_inv           -- Quantile function of the Beta distribution
-      beta_pdf           -- PDF of the Beta distribution
-      beta_rnd           -- Random deviates from the Beta distribution
-
-      binomial_cdf       -- CDF of the binomial distribution
-      binomial_inv       -- Quantile function of the binomial distribution
-      binomial_pdf       -- PDF of the binomial distribution
-      binomial_rnd       -- Random deviates from the binomial distribution
-
-      cauchy_cdf         -- CDF of the Cauchy distribution
-      cauchy_inv         -- Quantile function of the Cauchy distribution
-      cauchy_pdf         -- PDF of the Cauchy distribution
-      cauchy_rnd         -- Random deviates from the Cauchy distribution
-
-      chisquare_cdf      -- CDF of the chi-square distribution
-      chisquare_inv      -- Quantile function of the chi-square distribution
-      chisquare_pdf      -- PDF of the chi-sqaure distribution
-      chisquare_rnd      -- Random deviates from the chi-square distribution
-
-      discrete_cdf       -- CDF of a discrete distribution
-      discrete_inv       -- Quantile function of a discrete distribution
-      discrete_pdf       -- PDF of a discrete distribution
-      discrete_rnd       -- Random deviates from a discrete distribution
-
-      empirical_cdf      -- CDF of the empirical distribution
-      empirical_inv      -- Quantile function of the empirical distribution
-      empirical_pdf      -- PDF of the empirical distribution
-      empirical_rnd      -- Bootstrap samples from the empirical distribution
-
-      exponential_cdf    -- CDF of the exponential distribution
-      exponential_inv    -- Quantile function of the exponential distribution
-      exponential_pdf    -- PDF of the exponential distribution
-      exponential_rnd    -- Random deviates from the exponential distribution
-
-      f_cdf              -- CDF of the F distribution
-      f_inv              -- Quantile function of the F distribution
-      f_pdf              -- PDF of the F distribution
-      f_rnd              -- Random deviates from the F distribution
-
-      gamma_cdf          -- CDF of the Gamma distribution
-      gamma_inv          -- Quantile function of the Gamma distribution
-      gamma_pdf          -- PDF of the Gamma distribution
-      gamma_rnd          -- Random deviates from the Gamma distribution
-
-      geometric_cdf      -- CDF of the geometric distribution
-      geometric_inv      -- Quantile function of the geometric distribution
-      geometric_pdf      -- PDF of the geometric distribution
-      geometric_rnd      -- Random deviates from the geometric distribution
-
-      hypergeometric_cdf -- CDF of the hypergeometric distribution
-      hypergeometric_inv -- Random deviates from hypergeometric distribution
-      hypergeometric_pdf -- PDF of the hypergeometric distribution
-      hypergeometric_rnd -- Random deviates from hypergeometric distribution
-
-      kolmogorov_smirnov_cdf -- CDF of the Kolmogorov-Smirnov distribution
-
-      laplace_cdf        -- CDF of the Laplace distribution
-      laplace_inv        -- Quantile function of the Laplace distribution
-      laplace_pdf        -- PDF of the Laplace distribution
-      laplace_rnd        -- Random deviates from the Laplace distribution
-
-      logistic_cdf       -- CDF of the logistic distribution
-      logistic_inv       -- Quantile function of the logistic distribution
-      logistic_pdf       -- PDF of the logistic distribution
-      logistic_rnd       -- Random deviates from the logistic distribution
-
-      lognormal_cdf      -- CDF of the log normal distribution
-      lognormal_inv      -- Quantile function of the log normal distribution
-      lognormal_pdf      -- PDF of the log normal distribution
-      lognormal_rnd      -- Random deviates from the log normal distribution
-
-      normal_cdf         -- CDF of the normal distribution
-      normal_inv         -- Quantile function of the normal distribution
-      normal_pdf         -- PDF of the normal distribution
-      normal_rnd         -- Random deviates from the normal distribution
-
-      pascal_cdf         -- CDF of the Pascal (negative binomial) distribution
-      pascal_inv         -- Quantile function of the Pascal distribution
-      pascal_pdf         -- PDF of the Pascal (negative binomial) distribution
-      pascal_rnd         -- Random deviates from the Pascal distribution
-
-      poisson_cdf        -- CDF of the Poisson distribution
-      poisson_inv        -- Quantile function of the Poisson distribution
-      poisson_pdf        -- PDF of the Poisson distribution
-      poisson_rnd        -- Random deviates from the Poisson distribution
-
-      stdnormal_cdf      -- CDF of the standard normal distribution
-      stdnormal_inv      -- Quantile function of standard normal distribution
-      stdnormal_pdf      -- PDF of the standard normal distribution
-      stdnormal_rnd      -- Random deviates from standard normal distribution
-
-      t_cdf              -- CDF of the t distribution
-      t_inv              -- Quantile function of the t distribution
-      t_pdf              -- PDF of the t distribution
-      t_rnd              -- Random deviates from the t distribution
-
-      uniform_cdf        -- CDF of the uniform distribution
-      uniform_inv        -- Quantile function of the uniform distribution
-      uniform_pdf        -- PDF of the uniform distribution
-      uniform_rnd        -- Random deviates from the uniform distribution
-
-      weibull_cdf        -- CDF of the Weibull distribution
-      weibull_inv        -- Quantile function of the Weibull distribution
-      weibull_pdf        -- PDF of the Weibull distribution
-      weibull_rnd        -- Random deviates from the Weibull distribution
-
-      wiener_rnd         -- Simulate a Wiener process
-
-    In statistics/models (new directory):
-
-      logistic_regression             -- ordinal logistic regression
-      logistic_regression_derivatives -- derivates of log-likelihood
-                                         in logistic regression
-      logistic_regression_likelihood  -- likelihood in logistic regression
-
-    In statistics/tests (new directory):
-
-      anova                       -- one-way analysis of variance
-      bartlett_test               -- bartlett test for homogeneity of variances
-      chisquare_test_homogeneity  -- chi-square test for homogeneity
-      chisquare_test_independence -- chi-square test for independence
-      cor_test                    -- test for zero correlation
-      f_test_regression           -- test linear hypotheses in linear
-                                     regression model
-      hotelling_test              -- test for mean of a multivariate normal
-      hotelling_test_2            -- compare means of two multivariate normals
-      kolmogorov_smirnov_test     -- one-sample Kolmogorov-Smirnov test
-      kolmogorov_smirnov_test_2   -- two-sample Kolmogorov-Smirnov test
-      kruskal_wallis_test         -- kruskal-Wallis test
-      manova                      -- one-way multivariate analysis of variance
-      mcnemar_test                -- mcnemar's test for symmetry
-      prop_test_2                 -- compare two proportions
-      run_test                    -- run test for independence
-      sign_test                   -- sign test
-      t_test                      -- student's one-sample t test 
-      t_test_2                    -- student's two-sample t test
-      t_test_regression           -- test one linear hypothesis in linear
-                                     regression model
-      u_test                      -- mann-Whitney U-test
-      var_test                    -- f test to compare two variances
-      welch_test                  -- welch two-sample t test
-      wilcoxon_test               -- wilcoxon signed-rank test
-      z_test                      -- test for mean of a normal sample with
-                                     known variance
-      z_test_2                    -- compare means of two normal samples with
-                                     known variances
-
-  * The save command now accepts the option -append to save the
-    variables at the end of the file, leaving the existing contents.
-
-  * New command-line option --no-history (also available using the
-    single character option -H) inhibits saving command history.
-
-  * The mkoctfile script now accepts -DDEF options and passes them on
-    to the C and C++ compilers.
-
-  * Running `make check' should work now before you run `make install', 
-    even if you build a copy of Octave that depends on shared versions
-    of the Octave libraries.
-
-  * For matrices, x(:) now works and returns a column vector no matter
-    what the value of do_fortran_indexing is.
-
-  * New keywords __FILE__ and __LINE__ expand to the name of the file
-    that is being read and the current input line number, respectively.
-
-  * Octave's expression parser is more general and consistent.  It is
-    now possible to access structure elements and index arbitrary
-    values.  For example, expressions like
-
-      my_home_dir = getpwuid (getuid ()) . dir;
-
-    and
-
-      svd (x) (1:5)
-
-    now work.
-
-  * New built-in variable `print_rhs_assign_val' controls what is
-    printed when an assignment expression is evaluated.  If it is
-    zero, the value of the variable on the left hand side (after the
-    assignment) is printed.  If it is nonzero, the value of the right
-    hand side (i.e., the result of the expression) is printed.  The
-    default value of is zero, so the behavior is the same as in
-    previous versions of Octave.
-
-  * tmpnam now takes two optional arguments, DIR, and PREFIX.  For
-    example, tmpnam ("/foo", "bar-") returns a file name like
-    "/foo/bar-10773baa".  If DIR is omitted or empty, the value of the
-    environment variable TMPDIR, or /tmp is used.  If PREFIX is 
-    omitted, "oct-" is used.
-
-  * The built-in variable `PWD' has been removed.  If you need to get
-    the value of the current working directory, use the pwd() function
-    instead.
-
-  * New operators.  Octave's parser now recognizes the following
-    operators:  << >> += -= *= /= .+= .-= .*= ./= &= |= <<= >>=.  So
-    far, there are only a few operations defined that actually use
-    them (this should change before 2.1 is released).
-
-  * New built-in data types:
-
-    logical:
-
-      A true value is represented by 1, and false value by 0.
-      Comparison operations like <, <=, ==, >, >=, and != now return
-      logical values.  Indexing operations that use zero-one style
-      indexing must now use logical values.  You can use the new
-      function logical() to convert a numeric value to a logical
-      value.  This avoids the need for the built-in variable
-      `prefer_zero_one_indexing', so it has been removed.  Logical
-      values are automatically converted to numeric values where
-      appropriate.
-
-    file:
-
-      A file object represents an open Octave stream object.  The
-      fopen function now returns a file object instead of an integer.
-      File objects can be converted to integers automatically, and the
-      other functions that work with file ids still work with
-      integers, so this change should be backward compatible.
-
-      The binary left-shift operator `<<' has been defined to work as
-      in C++ for file objects and built-in types.  For example,
-
-        my_stream = fopen ("foo", "w");
-        my_stream << "x = " << pi << " marks the spot\n";
-
-      writes `x = 3.1416 marks the spot' in the file foo.
-
-      The built-in variables stdin, stdout, and stderr are now also
-      file objects instead of integers.
-
-    list:
-
-      A list is an array of Octave objects.  It can be indexed using
-      the normal indexing operator.  For example,
-
-        x = list ([1,2;3,4], 1, "foo");
-        stdout << x(2) << "\n"
-        1
-        stdout << x;
-        (
-         [1] =
-        
-           1  2
-           3  4
-        
-          [2] = 1
-          [3] = foo
-        )
-
-      There is currently no special syntax for creating lists; you
-      must use the list function.
-
-  * Commas in global statements are no longer special.  They are now
-    treated as command separators.  This removes a conflict in the
-    grammar and is consistent with the way Matlab behaves.  The
-    variable `warn_comma_in_global_decl' has been eliminated.
-
-  * It is now possible to declare static variables that retain their
-    values across function calls.  For example,
-
-      function ncall = f () static n = 0; ncall = ++n; endfunction
-
-    defines a function that returns the number of times that it has
-    been called.
-
-  * Within user-defined functions, the new automatic variable `argn'
-    contains the names of the arguments that were passed to the
-    function.  For example,
-
-      function f (...)
-        for i = 1:nargin
-          stdout << "argn(" << i << ") = `" << deblank (argn(i,:)) \
-                 << "' and its value is " << va_arg () << "\n";
-        endfor
-      endfunction
-      f (1+2, "foo", sin (pi/2))
-
-    prints
-
-      argn(1) = `1 + 2' and its value is 3
-      argn(2) = `"foo"' and its value is foo
-      argn(3) = `sin (pi)' and its value is 1
-
-    on the standard output stream.  If nargin is zero, argn is not defined.
-  * Functions like quad, fsolve, and lsode can take either a function
-    name or a simple function body as a string.  For example,
-
-      quad ("sqrt (x)", 0, 1)
-
-    is equivalent to
-
-      function y = f (x) y = sqrt (x); endfunction
-      quad ("f", 0, 1)
-
-  * If the argument to eig() is symmetric, Octave uses the specialized
-    Lapack subroutine for symmetric matrices for a significant
-    increase in performance.
-
-  * If the argument to lsode that names the user-supplied function is
-    a 2-element string array, the second element is taken as the name
-    of the Jacobian function.  The named function should have the
-    following form:
-
-      JAC = f (X, T)
-
-    where JAC is the Jacobian matrix of partial derivatives of the
-    right-hand-side functions that define the set of differential
-    equations with respect to the state vector X.
-
-  * Global variables are now initialized to the empty matrix, for
-    compatibility with Matlab.
-
-  * Explicit initialization of global variables only happens once.
-    For example, after the following statements are evaluated, g still
-    has the value 1.
-
-      global g = 1
-      global g = 2
-
-    This is useful for initializing global variables that are used to
-    maintain state information that is shared among several functions.
-
-  * Structure elements completion on the command line actually works
-    now.
-
-  * The new built-in variable `fixed_point_format' controls whether
-    Octave uses a scaled fixed-point format for displaying matrices.
-    The default value is 0 unless you use --traditional.
-
-  * The function sumsq now computes sum (x .* conj (x)) for complex values.
-
-  * The new built-in variable max_recursion_depth allows you to
-    prevent Octave from attempting infinite recursion.  The default
-    value is 256.
-
-  * Octave now uses kpathsea 3.2.
-
-  * New configure option, --enable-readline.
-
-  * New configure option, --enable-static.
-
-Summary of changes for version 2.0.7:
-------------------------------------
-
-  This is a bug-fixing release.  There are no new user-visible features.
-
-Summary of changes for version 2.0.6:
-------------------------------------
-
-  This is primarily a bug-fixing release.  There are only a few new
-  user-visible features.
-
-  * The new built-in variable default_eval_print_flag controls whether
-    Octave prints the results of commands executed by eval() that do
-    not end with semicolons.  The default is 1.
-
-  * The new built-in constant OCTAVE_HOME specifies the top-level
-    directory where Octave is installed.
-
-  * Octave no longer includes functions to work with NPSOL or QPSOL,
-    because they are not free software.
-
-  * The new built-in variable called kluge_procbuf_delay specifies the
-    number of microseconds to delay in the parent process after
-    forking.  By default on gnu-win32 systems, it's set to 500000 (1/2
-    second).  On other systems, the default value is 0.  Delaying for
-    a short time in the parent after forking seems to avoid problems
-    in which communicating with subprocesses via pipes would sometimes
-    cause Octave to hang.  I doubt that the delay is really the right
-    solution.  If anyone has a better idea, I'd love to hear it.
-
-Summary of changes for version 2.0.5:
-------------------------------------
-
-  * A `switch' statement is now available.  See the Statements chapter
-    in the manual for details.
-
-  * Commands like ls, save, and cd may now also be used as formal
-    parameters for functions.
-
-  * More tests.
-
-Summary of changes for version 2.0.4:
-------------------------------------
-
-  * It is now possible to use commands like ls, save, and cd as simple
-    variable names.  They still cannot be used as formal parameters
-    for functions, or as the names of structure variables.  Failed
-    assignments leave them undefined (you can recover the orginal
-    function definition using clear).
-
-  * Is is now possible to invoke commands like ls, save, and cd as
-    normal functions (for example, load ("foo", "x", "y", "z")).
-
-Summary of changes for version 2.0.3:
-------------------------------------
-
-  * The manual has been completely revised and now corresponds much
-    more closely to the features of the current version.
-
-  * The return value for assignment expressions is now the RHS since
-    that is more consistent with the way other programming languages
-    work.  However, Octave still prints the entire LHS value so that
-
-      x = zeros (1, 2);
-      x(2) = 1
-
-    still prints
-
-      x =
-
-        0  1
-
-    but an assignment like
-
-      z = x(2) = 1
-
-    sets z to 1 (not [ 0, 1 ] as in previous versions of Octave).
-
-  * It is now much easier to make binary distributions.  See the
-    Binary Distributions section of the manual for more details.
-
-Summary of changes for version 2.0.2:
-------------------------------------
-
-  * Octave now stops executing commands from a script file if an error
-    is encountered.
-
-  * The return, and break commands now cause Octave to quit executing
-    commands from script files.  When used in invalid contexts, the
-    break, continue, and return commands are now simply ignored
-    instead of producing parse errors.
-
-  * size ("") is now [0, 0].
-
-  * New functions:
-
-      sleep   -- pause execution for a specified number of seconds
-      usleep  -- pause execution for a specified number of microseconds
-
-Summary of changes for version 2.0:
+Summary of changes for version 3.0:
 ----------------------------------
 
-  * The set and show commands for setting and displaying gnuplot
-    parameters have been replaced by gset and gshow.  This change will
-    probably break lots of things, but it is necessary to allow for
-    compatibility with the Matlab graphics and GUI commands in a
-    future version of Octave.  (For now, the old set and show commands
-    do work, but they print an annoying warning message to try to get
-    people to switch to using gset.)
-
-  * Octave has been mostly ported to Windows NT and Windows 95 using
-    the beta 17 release of the Cygnus GNU-WIN32 tools.  Not everything
-    works, but it is usable.  See the file README.WINDOWS for more
-    information.
-
-  * Dynamic linking works on more systems using dlopen() and friends
-    (most modern Unix systems) or shl_load() and friends (HP/UX
-    systems).  A simple example is provided in examples/hello.cc.
-    For this feature to work, you must configure Octave with
-    --enable-shared.  You may also need to have a shared-library
-    version of libg++ and libstdc++.
-
-  * New data types can be added to Octave by writing a C++ class.  On
-    systems that support dynamic linking, new data types can be added
-    to an already running Octave binary.  A simple example appears in
-    the file examples/make_int.cc.  Other examples are the standard
-    Octave data types defined in the files src/ov*.{h,cc} and
-    src/op-*.cc.
-
-  * The configure option --enable-bounds-check turns on bounds
-    checking on element references for Octave's internal array and
-    matrix classes.  It's enabled by default.  To disable this
-    feature, configure Octave with --disable-bounds-check.
-
-  * The C-style I/O functions (fopen, fprintf, etc.) have been
-    rewritten to be more compatible with Matlab.  The fputs function
-    has also been added.  Usage of the *printf functions that was
-    allowed in previous versions of Octave should still work.
-    However, there is no way to make the new versions of the *scanf
-    functions compatible with Matlab *and* previous versions of
-    Octave.  An optional argument to the *scanf functions is now
-    available to make them behave in a way that is compatible with
-    previous versions of Octave.
-
-  * Octave can now read files that contain columns of numbers only,
-    with no header information.  The name of the loaded variable is
-    constructed from the file name.  Each line in the file must have
-    the same number of elements.
+  * Previous versions of Octave had a number of built-in variables to
+    control warnings (for example, warn_divide_by_zero).  These
+    variables have been replaced by warning identifiers that are used
+    with the warning function to control the state of warnings.  Now,
+    instead of writing
 
-  * The interface to the pager has changed.  The new built-in variable
-    `page_output_immediately' controls when Octave sends output to the
-    pager.  If it is nonzero, Octave sends output to the pager as soon
-    as it is available.  Otherwise, Octave buffers its output and
-    waits until just before the prompt is printed to flush it to the
-    pager.
-
-  * Expressions of the form
-
-      A(i,j) = x
-
-    where X is a scalar and the indices i and j define a matrix of
-    elements now work as you would expect rather than giving an error.
-    I am told that this is how Matlab 5.0 will behave when it is
-    released.
-
-  * Indexing of character strings now works.
-
-  * The echo command has been implemented.
-
-  * The document command is now a regular function.
-
-  * New method for handling errors:
+      warn_divide_by_zero = false;
 
-      try
-        BODY
-      catch
-        CLEANUP
-      end_try_catch
-
-    Where BODY and CLEANUP are both optional and may contain any
-    Octave expressions or commands.  The statements in CLEANUP are
-    only executed if an error occurs in BODY.
-
-    No warnings or error messages are printed while BODY is
-    executing.  If an error does occur during the execution of BODY,
-    CLEANUP can access the text of the message that would have been
-    printed in the builtin constant __error_text__.  This is the same
-    as eval (TRY, CATCH) (which may now also use __error_text__) but
-    it is more efficient since the commands do not need to be parsed
-    each time the TRY and CATCH statements are evaluated.
-
-  * Octave no longer parses the help command by grabbing everything
-    after the keyword `help' until a newline character is read.  To
-    get help for `;' or `,', now, you need to use the command
-    `help semicolon' or `help comma'.
-
-  * Octave's parser now does some simple constant folding.  This means
-    that expressions like 3*i are now evaluated only once, when a
-    function is compiled, and the right hand side of expressions like
-    a = [1,2;3,4] are treated as true matrix constants rather than
-    lists of elements which must be evaluated each time they are
-    needed.
+    to disable divide-by-zero warnings, you should write
 
-  * Built-in variables that can take values of "true" and "false" can
-    now also be set to any nonzero scalar value to indicate "true",
-    and 0 to indicate "false".
-
-  * New built-in variables `history_file', `history_size', and
-    `saving_history'.
-
-  * New built-in variable `string_fill_char' specifies the character
-    to fill with when creating arrays of strings.
-
-  * If the new built-in variable `gnuplot_has_frames' is nonzero,
-    Octave assumes that your copy of gnuplot includes support for
-    multiple plot windows when using X11.
-
-    If the new built-in variable `gnuplot_has_multiplot' is nonzero,
-    Octave assumes that your copy of gnuplot has the multiplot support
-    that is included in recent 3.6beta releases.
-
-    The initial values of these variables are determined by configure,
-    but can be changed in your startup script or at the command line
-    in case configure got it wrong, or if you upgrade your gnuplot
-    installation.
+      warning ("off", "Octave:divide-by-zero");
 
-  * The new plot function `figure' allows multiple plot windows when
-    using newer versions of gnuplot with X11.
-
-  * Octave now notices when the plotter has exited unexpectedly.
-
-  * New built-in variable `warn_missing_semicolon'.  If nonzero, Octave
-    will warn when statements in function definitions don't end in
-    semicolons.  The default value is 0.
-
-  * Octave now attempts to continue after floating point exceptions
-    or out-of-memory errors.
-
-  * If Octave crashes, it now attempts to save all user-defined
-    variables in a file named `octave-core' in the current directory
-    before exiting.
-
-  * It is now possible to get the values of individual option settings
-    for the dassl, fsolve, lsode, npsol, qpsol, and quad functions
-    using commands like
-
-      dassl_reltol = dassl_options ("relative tolerance");
-
-  * The svd() function no longer computes the left and right singular
-    matrices unnecessarily.  This can significantly improve
-    performance for large matrices if you are just looking for the  
-    singular values.
+    You may use the same technique in your own code to control
+    warnings.  For example, you can use
 
-  * The filter() function is now a built-in function.
-
-  * New function randn() returns a pseudo-random number from a normal
-    distribution.  The rand() and randn() functions have separate
-    seeds and generators.
-
-  * Octave's command-line arguments are now available in the built-in
-    variable `argv'.  The program name is also available in the
-    variables `program_invocation_name' and `program_name'.  If
-    executing a script from the command line (e.g., octave foo.m) or
-    using the `#! /bin/octave' hack, the program name is set to the
-    name of the script.
-
-  * New built-in variable `completion_append_char' used as the
-    character to append to successful command-line completion
-    attempts.  The default is " " (a single space).
-
-  * Octave now uses a modified copy of the readline library from
-    version 1.14.5 of GNU bash.
-
-  * In prompt strings, `\H' expands to the whole host name.
-
-  * New built-in variable `beep_on_error'.  If nonzero, Octave will try
-    to ring your terminal's bell before printing an error message.
-    The default value is 0.
+      warning ("My-package:phase-of-the-moon",
+               "the phase of the moon could cause trouble today");
 
-  * For functions defined from files, the type command now prints the
-    text of the file.  You can still get the text reconstructed from
-    the parse tree by using the new option -t (-transformed).
-
-  * New command-line argument --traditional sets the following
-    preference variables for compatibility with Matlab:
-
-      PS1                           = ">> "
-      PS2                           = ""
-      beep_on_error                 = 1
-      default_save_format           = "mat-binary"
-      define_all_return_values      = 1
-      do_fortran_indexing           = 1
-      empty_list_elements_ok        = 1
-      implicit_str_to_num_ok        = 1
-      ok_to_lose_imaginary_part     = 1
-      page_screen_output            = 0
-      prefer_column_vectors         = 0
-      prefer_zero_one_indexing      = 1
-      print_empty_dimensions        = 0
-      treat_neg_dim_as_zero         = 1
-      warn_function_name_clash      = 0
-      whitespace_in_literal_matrix  = "traditional"
-
-  * New functions:
+    to allow users to control this warning using the
+    "My-package:phase-of-the-moon" warning identifier.
 
-      readdir  -- returns names of files in directory as array of strings
-      mkdir    -- create a directory
-      rmdir    -- remove a directory
-      rename   -- rename a file
-      unlink   -- delete a file
-      umask    -- set permission mask for file creation
-      stat     -- get information about a file
-      lstat    -- get information about a symbolic link
-      glob     -- perform filename globbing
-      fnmatch  -- match strings with filename globbing patterns
-      more     -- turn the pager on or off
-      gammaln  -- alias for lgamma
-
-  * New audio functions from Andreas Weingessel
-    <Andreas.Weingessel@ci.tuwien.ac.at>.
-
-      lin2mu     -- linear to mu-law encoding
-      loadaudio  -- load an audio file to a vector
-      mu2lin     -- mu-law to linear encoding
-      playaudio  -- play an audio file
-      record     -- record sound and store in vector
-      saveaudio  -- save a vector as an audio file
-      setaudio   -- executes mixer shell command
-
-  * New plotting functions from Vinayak Dutt.  Ones dealing with
-    multiple plots on one page require features from gnuplot 3.6beta
-    (or later).
-
-      bottom_title  -- put title at the bottom of the plot
-      mplot         -- multiplot version of plot
-      multiplot     -- switch multiple-plot mode on or off
-      oneplot       -- return to one plot per page
-      plot_border   -- put a border around plots
-      subplot       -- position multiple plots on a single page
-      subwindow     -- set subwindow position for next plot
-      top_title     -- put title at the top of the plot
-      zlabel        -- put a label on the z-axis
-
-  * New string functions
-
-      bin2dec  -- convert a string of ones and zeros to an integer
-      blanks   -- create a string of blanks
-      deblank  -- delete trailing blanks
-      dec2bin  -- convert an integer to a string of ones and zeros
-      dec2hex  -- convert an integer to a hexadecimal string
-      findstr  -- locate occurrences of one string in another
-      hex2dec  -- convert a hexadecimal string to an integer
-      index    -- return position of first occurrence a string in another
-      rindex   -- return position of last occurrence a string in another
-      split    -- divide one string into pieces separated by another
-      str2mat  -- create a string matrix from a list of strings
-      strrep   -- replace substrings in a string
-      substr   -- extract a substring
+    You may also enable or disable all warnings, or turn them into
+    errors:
 
-    The following functions return a matrix of ones and zeros.
-    Elements that are nonzero indicate that the condition was true for
-    the corresponding character in the string array.
-
-      isalnum   -- letter or a digit
-      isalpha   -- letter
-      isascii   -- ascii
-      iscntrl   -- control character
-      isdigit   -- digit
-      isgraph   -- printable (but not space character)
-      islower   -- lower case
-      isprint   -- printable (including space character)
-      ispunct   -- punctuation
-      isspace   -- whitespace
-      isupper   -- upper case
-      isxdigit  -- hexadecimal digit
-
-    These functions return new strings.
-
-      tolower  -- convert to lower case
-      toupper  -- convert to upper case
-
-  * New function, fgetl.  Both fgetl and fgets accept an optional
-    second argument that specifies a maximum number of characters to
-    read, and the function fgets is now compatible with Matlab.
+      warning ("on", "all");
+      warning ("off", "all");
+      warning ("error", "Octave:divide-by-zero");
+      warning ("error", "all");
 
-  * Printing in hexadecimal format now works (format hex).  It is also
-    possible to print the internal bit representation of a value
-    (format bit).  Note that these formats are only implemented for
-    numeric values.
-
-  * Additional structure features:
-
-    -- Name completion now works for structures.
-
-    -- Values and names of structure elements are now printed by
-       default.  The new built-in variable `struct_levels_to_print'
-       controls the depth of nested structures to print.  The default
-       value is 2.
-
-    -- New functions:
-
-       struct_contains (S, NAME) -- returns 1 if S is a structure with
-                                    element NAME; otherwise returns 0.
-
-       struct_elements (S)       -- returns the names of all elements
-                                    of structure S in an array of strings. 
-
-  * New io/subprocess functions:
-
-      fputs    -- write a string to a file with no formatting
-      popen2   -- start a subprocess with 2-way communication
-      mkfifo   -- create a FIFO special file
-      popen    -- open a pipe to a subprocess
-      pclose   -- close a pipe from a subprocess
-      waitpid  -- check the status of or wait for subprocesses
-
-  * New time functions:
+    You can query the state of current warnings using
 
-      asctime    -- format time structure according to local format
-      ctime      -- equivalent to `asctime (localtime (TMSTRUCT))'
-      gmtime     -- return time structure corresponding to UTC
-      localtime  -- return time structure corresponding to local time zone
-      strftime   -- print given time structure using specified format
-      time       -- return current time
-
-    The `clock' and `date' functions are now implemented in M-files
-    using these basic functions.
-
-  * Access to additional Unix system calls:
-
-      dup2     -- duplicate a file descriptor
-      exec     -- replace current process with a new process
-      fcntl    -- control open file descriptors
-      fork     -- create a copy of the current process
-      getpgrp  -- return the process group id of the current process
-      getpid   -- return the process id of the current process
-      getppid  -- return the process id of the parent process
-      getuid   -- return the real user id of the current process
-      getgid   -- return the real group id of the current process
-      geteuid  -- return the effective user id of the current process
-      getegid  -- return the effective group id of the current process
-      pipe     -- create an interprocess channel
-
-  * Other new functions:
+      warning ("query", ID)
+      warning ("query")
 
-      commutation_matrix  -- compute special matrix form
-      duplication_matrix  -- compute special matrix form
-      common_size.m       -- bring arguments to a common size
-      completion_matches  -- perform command completion on string
-      tilde_expand        -- perform tilde expansion on string
-
-      meshgrid  -- compatible with Matlab's meshgrid function
-      tmpnam    -- replaces octave_tmp_file_name
-      atexit    -- register functions to be called when Octave exits
-      putenv    -- define an environment variable
-      bincoeff  -- compute binomial coefficients
-      nextpow2  -- compute the next power of 2 greater than a number
-      detrend   -- remove a best fit polynomial from data
-      erfinv    -- inverse error function
-      shift     -- perform a circular shift on the elements of a matrix
-      pow2      -- compute 2 .^ x
-      log2      -- compute base 2 logarithms
-      diff      -- compute differences of matrix elements
-      vech      -- stack columns of a matrix below the diagonal
-      vec       -- stack columns of a matrix to form a vector
-      xor       -- compute exclusive or
-
-  * Functions for getting info from the password database on Unix systems:
-
-      getpwent  -- read entry from password-file stream, opening if necessary
-      getpwuid  -- search for password entry with matching user ID
-      getpwnam  -- search for password entry with matching username
-      setpwent  -- rewind the password-file stream
-      endpwent  -- close the password-file stream
+    (only those warning IDs which have been explicitly set are
+    returned).
 
-  * Functions for getting info from the group database on Unix systems:
-
-      getgrent  -- read entry from group-file stream, opening if necessary
-      getgrgid  -- search for group entry with matching group ID
-      getgrnam  -- search for group entry with matching group name
-      setgrent  -- rewind the pgroup-file stream
-      endgrent  -- close the group-file stream
-
-  * The New function octave_config_info returns a structure containing
-    information about how Octave was configured and compiled.
-
-  * New function getrusage returns a structure containing system
-    resource usage statistics.  The `cputime' function is now defined
-    in an M-file using getrusage.
-
-  * The info reader is now a separate binary that runs as a
-    subprocess.  You still need the info reader distributed with
-    Octave though, because there are some new command-line arguments
-    that are not yet available in the public release of Info.
-
-  * There is a new built-in variable, INFO_PROGRAM, which is used as
-    the name of the info program to run.  Its initial value is
-    $OCTAVE_HOME/lib/octave/VERSION/exec/ARCH/info, but that value can
-    be overridden by the environment variable OCTAVE_INFO_PROGRAM, or
-    the command line argument --info-program NAME, or by setting the
-    value of INFO_PROGRAM in a startup script.
+    A partial list and description of warning identifiers is available
+    using
 
-  * There is a new built-in variable, EXEC_PATH, which is used as
-    the list of directories to search when executing subprograms.  Its
-    initial value is taken from the environment variable
-    OCTAVE_EXEC_PATH (if it exists) or PATH, but that value can be
-    overridden by the the command line argument --exec-path PATH, or
-    by setting the value of EXEC_PATH in a startup script.  If the
-    EXEC_PATH begins (ends) with a colon, the directories
-    $OCTAVE_HOME/lib/octave/VERSION/exec/ARCH and $OCTAVE_HOME/bin are
-    prepended (appended) to EXEC_PATH (if you don't specify a value
-    for EXEC_PATH explicitly, these special directories are prepended
-    to your PATH).
+      help warning_ids
 
-  * If it is present, Octave will now use an `ls-R' database file to
-    speed up recursive path searching.  Octave looks for a file called
-    ls-R in the directory specified by the environment variable
-    OCTAVE_DB_DIR.  If that is not set but the environment variable
-    OCTAVE_HOME is set, Octave looks in $OCTAVE_HOME/lib/octave.
-    Otherwise, Octave looks in the directory $datadir/octave (normally
-    /usr/local/lib/octave).
 
-  * New examples directory.
-
-  * There is a new script, mkoctfile, that can be used to create .oct
-    files suitable for dynamic linking.
-
-  * Many more bug fixes.
-
-  * ChangeLogs are now kept in each subdirectory.
-
-See NEWS.1 for old news.
+See NEWS.2 for old news.
diff --git a/NEWS.2 b/NEWS.2
new file mode 100644
--- /dev/null
+++ b/NEWS.2
@@ -0,0 +1,1036 @@
+Summary of changes for version 2.1.x:
+------------------------------------
+
+  * Given a matrix, X, and a boolean index, idx, of the same shape as
+    X, X(idx) and X(idx) = RHS now work no matter what the value of
+    do_fortran_indexing is.
+
+  * If you are using GNU Emacs 19.34 or earlier, you will need to add
+    the following code to your ~/.emacs file in order to use Emacs
+    Octave mode:
+
+      ;; Set up the custom library.
+      ;; taken from http://www.dina.kvl.dk/~abraham/custom/
+      (eval-and-compile
+	(condition-case ()
+	    (require 'custom)
+	  (error nil))
+	(if (and (featurep 'custom) (fboundp 'custom-declare-variable))
+	    nil ;; We've got what we needed
+	  ;; We have the old custom-library, hack around it!
+	  (defmacro defgroup (&rest args)
+	    nil)
+	  (defmacro defcustom (var value doc &rest args) 
+	    (` (defvar (, var) (, value) (, doc))))))
+
+  * When `format +' is in effect, Octave uses the following symbols to
+    provide more information about the values in a matrix:
+
+      +      postive real
+      -      negative real
+      i      pure imaginary
+      c      complex
+      blank  zero
+
+  * The ++ and -- operators now work for indexed matrices, and the
+    following operators now work:
+
+      +=, -=, *=, /=, \=, <<=, >>=, .*=, ./=, .\=, &=, |=
+
+    These operators are currently implemented using a relatively
+    inefficient brute-force method but hey, they work.
+
+  * The built-in variable argv is now a list of strings instead of a
+    string vector.
+
+  * The value of LOADPATH set by the environment variable
+    OCTAVE_PATH, the -p or --path command line options, or on the
+    command line is no longer modified to include the default path.
+    Instead it is left as specified.  Its default value is now ":",
+    which tells Octave to search the default path, and the new
+    built-in variable DEFAULT_LOADPATH contains the default list of
+    directories to search.  
+
+  * The function file_in_path no longer does any special processing of
+    its PATH argument.  To search LOADPATH for files, it is now
+    generally better to use the new function file_in_loadpath.
+
+  * If fread is given a skip parameter, the skip is performed after
+    the read instead of before (for compatibility with Matlab).
+
+  * The new built-in variable `crash_dumps_octave_core' controls
+    whether Octave writes user variables to the file `octave-core'
+    when it crashes or is killed by a signal.  The default value is 1
+    (0 if you use --traditional).
+
+  * If LOADPATH contains a doubled colon, the default path is inserted
+    in its place.  This is similar to the substitution that also takes
+    place for leading or trailing colons in the LOADPATH.
+
+  * Loops of the form `for i = STRING ... endfor' are now allowed.
+
+  * It is now possible to set the iteration limit for lsode using
+    lsode_options ("step limit", N).
+
+  * New functions:
+
+      is_complex  -- tell whether a variable is complex
+      rehash      -- re-initialize the cache of directories in LOADPATH
+      graw        -- send a string to the gnuplot subprocess
+
+  * New functions from Kurt Hornik's Octave-ci package:
+
+    In finance (new directory):
+
+      fv    -- future value of an investment
+      fvl   -- future value of an initial lump sum investment
+      irr   -- internal rate of return of an investment
+      nper  -- number of payments needed for amortizing a loan
+      npv   -- net present value of a series of payments
+      pmt   -- amount of periodic payment needed to amortize a loan
+      pv    -- present value of an investment
+      pvl   -- present value of an investment that pays off at the end
+      rate  -- rate of return of an investment
+      vol   -- volatility of financial time series data
+
+    In linear-algebra:
+
+      dmult -- rescale the rows of a matrix
+
+    In signal:
+
+      arch_fit       -- fit an ARCH regression model
+      arch_rnd       -- simulate an ARCH process
+      arch_test      -- test for conditional heteroscedascity
+      arma_rnd       -- simulate an ARMA process
+      autocor        -- compute autocorrelations
+      autocov        -- compute autocovariances
+      autoreg_matrix -- design matrix for autoregressions
+      bartlett       -- coefficients of the Bartlett (triangular) window
+      blackman       -- coefficients of the Blackman window
+      diffpara       -- estimate the fractional differencing parameter
+      durbinlevinson -- perform one step of the Durbin-Levinson algorithm
+      fractdiff      -- compute fractional differences
+      hamming        -- coefficients of the Hamming window
+      hanning        -- coefficients of the Hanning window
+      hurst          -- estimate the Hurst parameter
+      periodogram    -- compute the periodogram
+      rectangle_lw   -- rectangular lag window
+      rectangle_sw   -- rectangular spectral window
+      sinetone       -- compute a sine tone
+      sinewave       -- compute a sine wave
+      spectral_adf   -- spectral density estimation
+      spectral_xdf   -- spectral density estimation
+      spencer        -- apply Spencer's 15-point MA filter
+      stft           -- short-term Fourier transform
+      synthesis      -- recover a signal from its short-term Fourier transform
+      triangle_lw    -- triangular lag window
+      triangle_sw    -- triangular spectral window
+      yulewalker     -- fit AR model by Yule-Walker method
+
+    In statistics/base (new directory):
+
+      center     -- center by subtracting means
+      cloglog    -- complementary log-log function
+      cor        -- compute correlations
+      cov        -- compute covariances
+      cut        -- cut data into intervals
+      iqr        -- interquartile range
+      kendall    -- kendall's rank correlation tau
+      logit      -- logit transformation
+      mean       -- compute arithmetic, geometric, and harmonic mean
+      meansq     -- compute mean square
+      moment     -- compute moments
+      ppplot     -- perform a PP-plot (probability plot)
+      probit     -- probit transformation
+      qqplot     -- perform a QQ-plot (quantile plot)
+      range      -- compute range
+      ranks      -- compute ranks
+      run_count  -- count upward runs
+      spearman   -- spearman's rank correlation rho
+      statistics -- compute basic statistics
+      studentize -- subtract mean and divide by standard deviation
+      table      -- cross tabulation
+      values     -- extract unique elements
+      var        -- compute variance
+
+    In statistics/distributions (new directory):
+
+      beta_cdf           -- CDF of the Beta distribution
+      beta_inv           -- Quantile function of the Beta distribution
+      beta_pdf           -- PDF of the Beta distribution
+      beta_rnd           -- Random deviates from the Beta distribution
+
+      binomial_cdf       -- CDF of the binomial distribution
+      binomial_inv       -- Quantile function of the binomial distribution
+      binomial_pdf       -- PDF of the binomial distribution
+      binomial_rnd       -- Random deviates from the binomial distribution
+
+      cauchy_cdf         -- CDF of the Cauchy distribution
+      cauchy_inv         -- Quantile function of the Cauchy distribution
+      cauchy_pdf         -- PDF of the Cauchy distribution
+      cauchy_rnd         -- Random deviates from the Cauchy distribution
+
+      chisquare_cdf      -- CDF of the chi-square distribution
+      chisquare_inv      -- Quantile function of the chi-square distribution
+      chisquare_pdf      -- PDF of the chi-sqaure distribution
+      chisquare_rnd      -- Random deviates from the chi-square distribution
+
+      discrete_cdf       -- CDF of a discrete distribution
+      discrete_inv       -- Quantile function of a discrete distribution
+      discrete_pdf       -- PDF of a discrete distribution
+      discrete_rnd       -- Random deviates from a discrete distribution
+
+      empirical_cdf      -- CDF of the empirical distribution
+      empirical_inv      -- Quantile function of the empirical distribution
+      empirical_pdf      -- PDF of the empirical distribution
+      empirical_rnd      -- Bootstrap samples from the empirical distribution
+
+      exponential_cdf    -- CDF of the exponential distribution
+      exponential_inv    -- Quantile function of the exponential distribution
+      exponential_pdf    -- PDF of the exponential distribution
+      exponential_rnd    -- Random deviates from the exponential distribution
+
+      f_cdf              -- CDF of the F distribution
+      f_inv              -- Quantile function of the F distribution
+      f_pdf              -- PDF of the F distribution
+      f_rnd              -- Random deviates from the F distribution
+
+      gamma_cdf          -- CDF of the Gamma distribution
+      gamma_inv          -- Quantile function of the Gamma distribution
+      gamma_pdf          -- PDF of the Gamma distribution
+      gamma_rnd          -- Random deviates from the Gamma distribution
+
+      geometric_cdf      -- CDF of the geometric distribution
+      geometric_inv      -- Quantile function of the geometric distribution
+      geometric_pdf      -- PDF of the geometric distribution
+      geometric_rnd      -- Random deviates from the geometric distribution
+
+      hypergeometric_cdf -- CDF of the hypergeometric distribution
+      hypergeometric_inv -- Random deviates from hypergeometric distribution
+      hypergeometric_pdf -- PDF of the hypergeometric distribution
+      hypergeometric_rnd -- Random deviates from hypergeometric distribution
+
+      kolmogorov_smirnov_cdf -- CDF of the Kolmogorov-Smirnov distribution
+
+      laplace_cdf        -- CDF of the Laplace distribution
+      laplace_inv        -- Quantile function of the Laplace distribution
+      laplace_pdf        -- PDF of the Laplace distribution
+      laplace_rnd        -- Random deviates from the Laplace distribution
+
+      logistic_cdf       -- CDF of the logistic distribution
+      logistic_inv       -- Quantile function of the logistic distribution
+      logistic_pdf       -- PDF of the logistic distribution
+      logistic_rnd       -- Random deviates from the logistic distribution
+
+      lognormal_cdf      -- CDF of the log normal distribution
+      lognormal_inv      -- Quantile function of the log normal distribution
+      lognormal_pdf      -- PDF of the log normal distribution
+      lognormal_rnd      -- Random deviates from the log normal distribution
+
+      normal_cdf         -- CDF of the normal distribution
+      normal_inv         -- Quantile function of the normal distribution
+      normal_pdf         -- PDF of the normal distribution
+      normal_rnd         -- Random deviates from the normal distribution
+
+      pascal_cdf         -- CDF of the Pascal (negative binomial) distribution
+      pascal_inv         -- Quantile function of the Pascal distribution
+      pascal_pdf         -- PDF of the Pascal (negative binomial) distribution
+      pascal_rnd         -- Random deviates from the Pascal distribution
+
+      poisson_cdf        -- CDF of the Poisson distribution
+      poisson_inv        -- Quantile function of the Poisson distribution
+      poisson_pdf        -- PDF of the Poisson distribution
+      poisson_rnd        -- Random deviates from the Poisson distribution
+
+      stdnormal_cdf      -- CDF of the standard normal distribution
+      stdnormal_inv      -- Quantile function of standard normal distribution
+      stdnormal_pdf      -- PDF of the standard normal distribution
+      stdnormal_rnd      -- Random deviates from standard normal distribution
+
+      t_cdf              -- CDF of the t distribution
+      t_inv              -- Quantile function of the t distribution
+      t_pdf              -- PDF of the t distribution
+      t_rnd              -- Random deviates from the t distribution
+
+      uniform_cdf        -- CDF of the uniform distribution
+      uniform_inv        -- Quantile function of the uniform distribution
+      uniform_pdf        -- PDF of the uniform distribution
+      uniform_rnd        -- Random deviates from the uniform distribution
+
+      weibull_cdf        -- CDF of the Weibull distribution
+      weibull_inv        -- Quantile function of the Weibull distribution
+      weibull_pdf        -- PDF of the Weibull distribution
+      weibull_rnd        -- Random deviates from the Weibull distribution
+
+      wiener_rnd         -- Simulate a Wiener process
+
+    In statistics/models (new directory):
+
+      logistic_regression             -- ordinal logistic regression
+      logistic_regression_derivatives -- derivates of log-likelihood
+                                         in logistic regression
+      logistic_regression_likelihood  -- likelihood in logistic regression
+
+    In statistics/tests (new directory):
+
+      anova                       -- one-way analysis of variance
+      bartlett_test               -- bartlett test for homogeneity of variances
+      chisquare_test_homogeneity  -- chi-square test for homogeneity
+      chisquare_test_independence -- chi-square test for independence
+      cor_test                    -- test for zero correlation
+      f_test_regression           -- test linear hypotheses in linear
+                                     regression model
+      hotelling_test              -- test for mean of a multivariate normal
+      hotelling_test_2            -- compare means of two multivariate normals
+      kolmogorov_smirnov_test     -- one-sample Kolmogorov-Smirnov test
+      kolmogorov_smirnov_test_2   -- two-sample Kolmogorov-Smirnov test
+      kruskal_wallis_test         -- kruskal-Wallis test
+      manova                      -- one-way multivariate analysis of variance
+      mcnemar_test                -- mcnemar's test for symmetry
+      prop_test_2                 -- compare two proportions
+      run_test                    -- run test for independence
+      sign_test                   -- sign test
+      t_test                      -- student's one-sample t test 
+      t_test_2                    -- student's two-sample t test
+      t_test_regression           -- test one linear hypothesis in linear
+                                     regression model
+      u_test                      -- mann-Whitney U-test
+      var_test                    -- f test to compare two variances
+      welch_test                  -- welch two-sample t test
+      wilcoxon_test               -- wilcoxon signed-rank test
+      z_test                      -- test for mean of a normal sample with
+                                     known variance
+      z_test_2                    -- compare means of two normal samples with
+                                     known variances
+
+  * The save command now accepts the option -append to save the
+    variables at the end of the file, leaving the existing contents.
+
+  * New command-line option --no-history (also available using the
+    single character option -H) inhibits saving command history.
+
+  * The mkoctfile script now accepts -DDEF options and passes them on
+    to the C and C++ compilers.
+
+  * Running `make check' should work now before you run `make install', 
+    even if you build a copy of Octave that depends on shared versions
+    of the Octave libraries.
+
+  * For matrices, x(:) now works and returns a column vector no matter
+    what the value of do_fortran_indexing is.
+
+  * New keywords __FILE__ and __LINE__ expand to the name of the file
+    that is being read and the current input line number, respectively.
+
+  * Octave's expression parser is more general and consistent.  It is
+    now possible to access structure elements and index arbitrary
+    values.  For example, expressions like
+
+      my_home_dir = getpwuid (getuid ()) . dir;
+
+    and
+
+      svd (x) (1:5)
+
+    now work.
+
+  * New built-in variable `print_rhs_assign_val' controls what is
+    printed when an assignment expression is evaluated.  If it is
+    zero, the value of the variable on the left hand side (after the
+    assignment) is printed.  If it is nonzero, the value of the right
+    hand side (i.e., the result of the expression) is printed.  The
+    default value of is zero, so the behavior is the same as in
+    previous versions of Octave.
+
+  * tmpnam now takes two optional arguments, DIR, and PREFIX.  For
+    example, tmpnam ("/foo", "bar-") returns a file name like
+    "/foo/bar-10773baa".  If DIR is omitted or empty, the value of the
+    environment variable TMPDIR, or /tmp is used.  If PREFIX is 
+    omitted, "oct-" is used.
+
+  * The built-in variable `PWD' has been removed.  If you need to get
+    the value of the current working directory, use the pwd() function
+    instead.
+
+  * New operators.  Octave's parser now recognizes the following
+    operators:  << >> += -= *= /= .+= .-= .*= ./= &= |= <<= >>=.  So
+    far, there are only a few operations defined that actually use
+    them (this should change before 2.1 is released).
+
+  * New built-in data types:
+
+    logical:
+
+      A true value is represented by 1, and false value by 0.
+      Comparison operations like <, <=, ==, >, >=, and != now return
+      logical values.  Indexing operations that use zero-one style
+      indexing must now use logical values.  You can use the new
+      function logical() to convert a numeric value to a logical
+      value.  This avoids the need for the built-in variable
+      `prefer_zero_one_indexing', so it has been removed.  Logical
+      values are automatically converted to numeric values where
+      appropriate.
+
+    file:
+
+      A file object represents an open Octave stream object.  The
+      fopen function now returns a file object instead of an integer.
+      File objects can be converted to integers automatically, and the
+      other functions that work with file ids still work with
+      integers, so this change should be backward compatible.
+
+      The binary left-shift operator `<<' has been defined to work as
+      in C++ for file objects and built-in types.  For example,
+
+        my_stream = fopen ("foo", "w");
+        my_stream << "x = " << pi << " marks the spot\n";
+
+      writes `x = 3.1416 marks the spot' in the file foo.
+
+      The built-in variables stdin, stdout, and stderr are now also
+      file objects instead of integers.
+
+    list:
+
+      A list is an array of Octave objects.  It can be indexed using
+      the normal indexing operator.  For example,
+
+        x = list ([1,2;3,4], 1, "foo");
+        stdout << x(2) << "\n"
+        1
+        stdout << x;
+        (
+         [1] =
+        
+           1  2
+           3  4
+        
+          [2] = 1
+          [3] = foo
+        )
+
+      There is currently no special syntax for creating lists; you
+      must use the list function.
+
+  * Commas in global statements are no longer special.  They are now
+    treated as command separators.  This removes a conflict in the
+    grammar and is consistent with the way Matlab behaves.  The
+    variable `warn_comma_in_global_decl' has been eliminated.
+
+  * It is now possible to declare static variables that retain their
+    values across function calls.  For example,
+
+      function ncall = f () static n = 0; ncall = ++n; endfunction
+
+    defines a function that returns the number of times that it has
+    been called.
+
+  * Within user-defined functions, the new automatic variable `argn'
+    contains the names of the arguments that were passed to the
+    function.  For example,
+
+      function f (...)
+        for i = 1:nargin
+          stdout << "argn(" << i << ") = `" << deblank (argn(i,:)) \
+                 << "' and its value is " << va_arg () << "\n";
+        endfor
+      endfunction
+      f (1+2, "foo", sin (pi/2))
+
+    prints
+
+      argn(1) = `1 + 2' and its value is 3
+      argn(2) = `"foo"' and its value is foo
+      argn(3) = `sin (pi)' and its value is 1
+
+    on the standard output stream.  If nargin is zero, argn is not defined.
+  * Functions like quad, fsolve, and lsode can take either a function
+    name or a simple function body as a string.  For example,
+
+      quad ("sqrt (x)", 0, 1)
+
+    is equivalent to
+
+      function y = f (x) y = sqrt (x); endfunction
+      quad ("f", 0, 1)
+
+  * If the argument to eig() is symmetric, Octave uses the specialized
+    Lapack subroutine for symmetric matrices for a significant
+    increase in performance.
+
+  * If the argument to lsode that names the user-supplied function is
+    a 2-element string array, the second element is taken as the name
+    of the Jacobian function.  The named function should have the
+    following form:
+
+      JAC = f (X, T)
+
+    where JAC is the Jacobian matrix of partial derivatives of the
+    right-hand-side functions that define the set of differential
+    equations with respect to the state vector X.
+
+  * Global variables are now initialized to the empty matrix, for
+    compatibility with Matlab.
+
+  * Explicit initialization of global variables only happens once.
+    For example, after the following statements are evaluated, g still
+    has the value 1.
+
+      global g = 1
+      global g = 2
+
+    This is useful for initializing global variables that are used to
+    maintain state information that is shared among several functions.
+
+  * Structure elements completion on the command line actually works
+    now.
+
+  * The new built-in variable `fixed_point_format' controls whether
+    Octave uses a scaled fixed-point format for displaying matrices.
+    The default value is 0 unless you use --traditional.
+
+  * The function sumsq now computes sum (x .* conj (x)) for complex values.
+
+  * The new built-in variable max_recursion_depth allows you to
+    prevent Octave from attempting infinite recursion.  The default
+    value is 256.
+
+  * Octave now uses kpathsea 3.2.
+
+  * New configure option, --enable-readline.
+
+  * New configure option, --enable-static.
+
+Summary of changes for version 2.0.7:
+------------------------------------
+
+  This is a bug-fixing release.  There are no new user-visible features.
+
+Summary of changes for version 2.0.6:
+------------------------------------
+
+  This is primarily a bug-fixing release.  There are only a few new
+  user-visible features.
+
+  * The new built-in variable default_eval_print_flag controls whether
+    Octave prints the results of commands executed by eval() that do
+    not end with semicolons.  The default is 1.
+
+  * The new built-in constant OCTAVE_HOME specifies the top-level
+    directory where Octave is installed.
+
+  * Octave no longer includes functions to work with NPSOL or QPSOL,
+    because they are not free software.
+
+  * The new built-in variable called kluge_procbuf_delay specifies the
+    number of microseconds to delay in the parent process after
+    forking.  By default on gnu-win32 systems, it's set to 500000 (1/2
+    second).  On other systems, the default value is 0.  Delaying for
+    a short time in the parent after forking seems to avoid problems
+    in which communicating with subprocesses via pipes would sometimes
+    cause Octave to hang.  I doubt that the delay is really the right
+    solution.  If anyone has a better idea, I'd love to hear it.
+
+Summary of changes for version 2.0.5:
+------------------------------------
+
+  * A `switch' statement is now available.  See the Statements chapter
+    in the manual for details.
+
+  * Commands like ls, save, and cd may now also be used as formal
+    parameters for functions.
+
+  * More tests.
+
+Summary of changes for version 2.0.4:
+------------------------------------
+
+  * It is now possible to use commands like ls, save, and cd as simple
+    variable names.  They still cannot be used as formal parameters
+    for functions, or as the names of structure variables.  Failed
+    assignments leave them undefined (you can recover the orginal
+    function definition using clear).
+
+  * Is is now possible to invoke commands like ls, save, and cd as
+    normal functions (for example, load ("foo", "x", "y", "z")).
+
+Summary of changes for version 2.0.3:
+------------------------------------
+
+  * The manual has been completely revised and now corresponds much
+    more closely to the features of the current version.
+
+  * The return value for assignment expressions is now the RHS since
+    that is more consistent with the way other programming languages
+    work.  However, Octave still prints the entire LHS value so that
+
+      x = zeros (1, 2);
+      x(2) = 1
+
+    still prints
+
+      x =
+
+        0  1
+
+    but an assignment like
+
+      z = x(2) = 1
+
+    sets z to 1 (not [ 0, 1 ] as in previous versions of Octave).
+
+  * It is now much easier to make binary distributions.  See the
+    Binary Distributions section of the manual for more details.
+
+Summary of changes for version 2.0.2:
+------------------------------------
+
+  * Octave now stops executing commands from a script file if an error
+    is encountered.
+
+  * The return, and break commands now cause Octave to quit executing
+    commands from script files.  When used in invalid contexts, the
+    break, continue, and return commands are now simply ignored
+    instead of producing parse errors.
+
+  * size ("") is now [0, 0].
+
+  * New functions:
+
+      sleep   -- pause execution for a specified number of seconds
+      usleep  -- pause execution for a specified number of microseconds
+
+Summary of changes for version 2.0:
+----------------------------------
+
+  * The set and show commands for setting and displaying gnuplot
+    parameters have been replaced by gset and gshow.  This change will
+    probably break lots of things, but it is necessary to allow for
+    compatibility with the Matlab graphics and GUI commands in a
+    future version of Octave.  (For now, the old set and show commands
+    do work, but they print an annoying warning message to try to get
+    people to switch to using gset.)
+
+  * Octave has been mostly ported to Windows NT and Windows 95 using
+    the beta 17 release of the Cygnus GNU-WIN32 tools.  Not everything
+    works, but it is usable.  See the file README.WINDOWS for more
+    information.
+
+  * Dynamic linking works on more systems using dlopen() and friends
+    (most modern Unix systems) or shl_load() and friends (HP/UX
+    systems).  A simple example is provided in examples/hello.cc.
+    For this feature to work, you must configure Octave with
+    --enable-shared.  You may also need to have a shared-library
+    version of libg++ and libstdc++.
+
+  * New data types can be added to Octave by writing a C++ class.  On
+    systems that support dynamic linking, new data types can be added
+    to an already running Octave binary.  A simple example appears in
+    the file examples/make_int.cc.  Other examples are the standard
+    Octave data types defined in the files src/ov*.{h,cc} and
+    src/op-*.cc.
+
+  * The configure option --enable-bounds-check turns on bounds
+    checking on element references for Octave's internal array and
+    matrix classes.  It's enabled by default.  To disable this
+    feature, configure Octave with --disable-bounds-check.
+
+  * The C-style I/O functions (fopen, fprintf, etc.) have been
+    rewritten to be more compatible with Matlab.  The fputs function
+    has also been added.  Usage of the *printf functions that was
+    allowed in previous versions of Octave should still work.
+    However, there is no way to make the new versions of the *scanf
+    functions compatible with Matlab *and* previous versions of
+    Octave.  An optional argument to the *scanf functions is now
+    available to make them behave in a way that is compatible with
+    previous versions of Octave.
+
+  * Octave can now read files that contain columns of numbers only,
+    with no header information.  The name of the loaded variable is
+    constructed from the file name.  Each line in the file must have
+    the same number of elements.
+
+  * The interface to the pager has changed.  The new built-in variable
+    `page_output_immediately' controls when Octave sends output to the
+    pager.  If it is nonzero, Octave sends output to the pager as soon
+    as it is available.  Otherwise, Octave buffers its output and
+    waits until just before the prompt is printed to flush it to the
+    pager.
+
+  * Expressions of the form
+
+      A(i,j) = x
+
+    where X is a scalar and the indices i and j define a matrix of
+    elements now work as you would expect rather than giving an error.
+    I am told that this is how Matlab 5.0 will behave when it is
+    released.
+
+  * Indexing of character strings now works.
+
+  * The echo command has been implemented.
+
+  * The document command is now a regular function.
+
+  * New method for handling errors:
+
+      try
+        BODY
+      catch
+        CLEANUP
+      end_try_catch
+
+    Where BODY and CLEANUP are both optional and may contain any
+    Octave expressions or commands.  The statements in CLEANUP are
+    only executed if an error occurs in BODY.
+
+    No warnings or error messages are printed while BODY is
+    executing.  If an error does occur during the execution of BODY,
+    CLEANUP can access the text of the message that would have been
+    printed in the builtin constant __error_text__.  This is the same
+    as eval (TRY, CATCH) (which may now also use __error_text__) but
+    it is more efficient since the commands do not need to be parsed
+    each time the TRY and CATCH statements are evaluated.
+
+  * Octave no longer parses the help command by grabbing everything
+    after the keyword `help' until a newline character is read.  To
+    get help for `;' or `,', now, you need to use the command
+    `help semicolon' or `help comma'.
+
+  * Octave's parser now does some simple constant folding.  This means
+    that expressions like 3*i are now evaluated only once, when a
+    function is compiled, and the right hand side of expressions like
+    a = [1,2;3,4] are treated as true matrix constants rather than
+    lists of elements which must be evaluated each time they are
+    needed.
+
+  * Built-in variables that can take values of "true" and "false" can
+    now also be set to any nonzero scalar value to indicate "true",
+    and 0 to indicate "false".
+
+  * New built-in variables `history_file', `history_size', and
+    `saving_history'.
+
+  * New built-in variable `string_fill_char' specifies the character
+    to fill with when creating arrays of strings.
+
+  * If the new built-in variable `gnuplot_has_frames' is nonzero,
+    Octave assumes that your copy of gnuplot includes support for
+    multiple plot windows when using X11.
+
+    If the new built-in variable `gnuplot_has_multiplot' is nonzero,
+    Octave assumes that your copy of gnuplot has the multiplot support
+    that is included in recent 3.6beta releases.
+
+    The initial values of these variables are determined by configure,
+    but can be changed in your startup script or at the command line
+    in case configure got it wrong, or if you upgrade your gnuplot
+    installation.
+
+  * The new plot function `figure' allows multiple plot windows when
+    using newer versions of gnuplot with X11.
+
+  * Octave now notices when the plotter has exited unexpectedly.
+
+  * New built-in variable `warn_missing_semicolon'.  If nonzero, Octave
+    will warn when statements in function definitions don't end in
+    semicolons.  The default value is 0.
+
+  * Octave now attempts to continue after floating point exceptions
+    or out-of-memory errors.
+
+  * If Octave crashes, it now attempts to save all user-defined
+    variables in a file named `octave-core' in the current directory
+    before exiting.
+
+  * It is now possible to get the values of individual option settings
+    for the dassl, fsolve, lsode, npsol, qpsol, and quad functions
+    using commands like
+
+      dassl_reltol = dassl_options ("relative tolerance");
+
+  * The svd() function no longer computes the left and right singular
+    matrices unnecessarily.  This can significantly improve
+    performance for large matrices if you are just looking for the  
+    singular values.
+
+  * The filter() function is now a built-in function.
+
+  * New function randn() returns a pseudo-random number from a normal
+    distribution.  The rand() and randn() functions have separate
+    seeds and generators.
+
+  * Octave's command-line arguments are now available in the built-in
+    variable `argv'.  The program name is also available in the
+    variables `program_invocation_name' and `program_name'.  If
+    executing a script from the command line (e.g., octave foo.m) or
+    using the `#! /bin/octave' hack, the program name is set to the
+    name of the script.
+
+  * New built-in variable `completion_append_char' used as the
+    character to append to successful command-line completion
+    attempts.  The default is " " (a single space).
+
+  * Octave now uses a modified copy of the readline library from
+    version 1.14.5 of GNU bash.
+
+  * In prompt strings, `\H' expands to the whole host name.
+
+  * New built-in variable `beep_on_error'.  If nonzero, Octave will try
+    to ring your terminal's bell before printing an error message.
+    The default value is 0.
+
+  * For functions defined from files, the type command now prints the
+    text of the file.  You can still get the text reconstructed from
+    the parse tree by using the new option -t (-transformed).
+
+  * New command-line argument --traditional sets the following
+    preference variables for compatibility with Matlab:
+
+      PS1                           = ">> "
+      PS2                           = ""
+      beep_on_error                 = 1
+      default_save_format           = "mat-binary"
+      define_all_return_values      = 1
+      do_fortran_indexing           = 1
+      empty_list_elements_ok        = 1
+      implicit_str_to_num_ok        = 1
+      ok_to_lose_imaginary_part     = 1
+      page_screen_output            = 0
+      prefer_column_vectors         = 0
+      prefer_zero_one_indexing      = 1
+      print_empty_dimensions        = 0
+      treat_neg_dim_as_zero         = 1
+      warn_function_name_clash      = 0
+      whitespace_in_literal_matrix  = "traditional"
+
+  * New functions:
+
+      readdir  -- returns names of files in directory as array of strings
+      mkdir    -- create a directory
+      rmdir    -- remove a directory
+      rename   -- rename a file
+      unlink   -- delete a file
+      umask    -- set permission mask for file creation
+      stat     -- get information about a file
+      lstat    -- get information about a symbolic link
+      glob     -- perform filename globbing
+      fnmatch  -- match strings with filename globbing patterns
+      more     -- turn the pager on or off
+      gammaln  -- alias for lgamma
+
+  * New audio functions from Andreas Weingessel
+    <Andreas.Weingessel@ci.tuwien.ac.at>.
+
+      lin2mu     -- linear to mu-law encoding
+      loadaudio  -- load an audio file to a vector
+      mu2lin     -- mu-law to linear encoding
+      playaudio  -- play an audio file
+      record     -- record sound and store in vector
+      saveaudio  -- save a vector as an audio file
+      setaudio   -- executes mixer shell command
+
+  * New plotting functions from Vinayak Dutt.  Ones dealing with
+    multiple plots on one page require features from gnuplot 3.6beta
+    (or later).
+
+      bottom_title  -- put title at the bottom of the plot
+      mplot         -- multiplot version of plot
+      multiplot     -- switch multiple-plot mode on or off
+      oneplot       -- return to one plot per page
+      plot_border   -- put a border around plots
+      subplot       -- position multiple plots on a single page
+      subwindow     -- set subwindow position for next plot
+      top_title     -- put title at the top of the plot
+      zlabel        -- put a label on the z-axis
+
+  * New string functions
+
+      bin2dec  -- convert a string of ones and zeros to an integer
+      blanks   -- create a string of blanks
+      deblank  -- delete trailing blanks
+      dec2bin  -- convert an integer to a string of ones and zeros
+      dec2hex  -- convert an integer to a hexadecimal string
+      findstr  -- locate occurrences of one string in another
+      hex2dec  -- convert a hexadecimal string to an integer
+      index    -- return position of first occurrence a string in another
+      rindex   -- return position of last occurrence a string in another
+      split    -- divide one string into pieces separated by another
+      str2mat  -- create a string matrix from a list of strings
+      strrep   -- replace substrings in a string
+      substr   -- extract a substring
+
+    The following functions return a matrix of ones and zeros.
+    Elements that are nonzero indicate that the condition was true for
+    the corresponding character in the string array.
+
+      isalnum   -- letter or a digit
+      isalpha   -- letter
+      isascii   -- ascii
+      iscntrl   -- control character
+      isdigit   -- digit
+      isgraph   -- printable (but not space character)
+      islower   -- lower case
+      isprint   -- printable (including space character)
+      ispunct   -- punctuation
+      isspace   -- whitespace
+      isupper   -- upper case
+      isxdigit  -- hexadecimal digit
+
+    These functions return new strings.
+
+      tolower  -- convert to lower case
+      toupper  -- convert to upper case
+
+  * New function, fgetl.  Both fgetl and fgets accept an optional
+    second argument that specifies a maximum number of characters to
+    read, and the function fgets is now compatible with Matlab.
+
+  * Printing in hexadecimal format now works (format hex).  It is also
+    possible to print the internal bit representation of a value
+    (format bit).  Note that these formats are only implemented for
+    numeric values.
+
+  * Additional structure features:
+
+    -- Name completion now works for structures.
+
+    -- Values and names of structure elements are now printed by
+       default.  The new built-in variable `struct_levels_to_print'
+       controls the depth of nested structures to print.  The default
+       value is 2.
+
+    -- New functions:
+
+       struct_contains (S, NAME) -- returns 1 if S is a structure with
+                                    element NAME; otherwise returns 0.
+
+       struct_elements (S)       -- returns the names of all elements
+                                    of structure S in an array of strings. 
+
+  * New io/subprocess functions:
+
+      fputs    -- write a string to a file with no formatting
+      popen2   -- start a subprocess with 2-way communication
+      mkfifo   -- create a FIFO special file
+      popen    -- open a pipe to a subprocess
+      pclose   -- close a pipe from a subprocess
+      waitpid  -- check the status of or wait for subprocesses
+
+  * New time functions:
+
+      asctime    -- format time structure according to local format
+      ctime      -- equivalent to `asctime (localtime (TMSTRUCT))'
+      gmtime     -- return time structure corresponding to UTC
+      localtime  -- return time structure corresponding to local time zone
+      strftime   -- print given time structure using specified format
+      time       -- return current time
+
+    The `clock' and `date' functions are now implemented in M-files
+    using these basic functions.
+
+  * Access to additional Unix system calls:
+
+      dup2     -- duplicate a file descriptor
+      exec     -- replace current process with a new process
+      fcntl    -- control open file descriptors
+      fork     -- create a copy of the current process
+      getpgrp  -- return the process group id of the current process
+      getpid   -- return the process id of the current process
+      getppid  -- return the process id of the parent process
+      getuid   -- return the real user id of the current process
+      getgid   -- return the real group id of the current process
+      geteuid  -- return the effective user id of the current process
+      getegid  -- return the effective group id of the current process
+      pipe     -- create an interprocess channel
+
+  * Other new functions:
+
+      commutation_matrix  -- compute special matrix form
+      duplication_matrix  -- compute special matrix form
+      common_size.m       -- bring arguments to a common size
+      completion_matches  -- perform command completion on string
+      tilde_expand        -- perform tilde expansion on string
+
+      meshgrid  -- compatible with Matlab's meshgrid function
+      tmpnam    -- replaces octave_tmp_file_name
+      atexit    -- register functions to be called when Octave exits
+      putenv    -- define an environment variable
+      bincoeff  -- compute binomial coefficients
+      nextpow2  -- compute the next power of 2 greater than a number
+      detrend   -- remove a best fit polynomial from data
+      erfinv    -- inverse error function
+      shift     -- perform a circular shift on the elements of a matrix
+      pow2      -- compute 2 .^ x
+      log2      -- compute base 2 logarithms
+      diff      -- compute differences of matrix elements
+      vech      -- stack columns of a matrix below the diagonal
+      vec       -- stack columns of a matrix to form a vector
+      xor       -- compute exclusive or
+
+  * Functions for getting info from the password database on Unix systems:
+
+      getpwent  -- read entry from password-file stream, opening if necessary
+      getpwuid  -- search for password entry with matching user ID
+      getpwnam  -- search for password entry with matching username
+      setpwent  -- rewind the password-file stream
+      endpwent  -- close the password-file stream
+
+  * Functions for getting info from the group database on Unix systems:
+
+      getgrent  -- read entry from group-file stream, opening if necessary
+      getgrgid  -- search for group entry with matching group ID
+      getgrnam  -- search for group entry with matching group name
+      setgrent  -- rewind the pgroup-file stream
+      endgrent  -- close the group-file stream
+
+  * The New function octave_config_info returns a structure containing
+    information about how Octave was configured and compiled.
+
+  * New function getrusage returns a structure containing system
+    resource usage statistics.  The `cputime' function is now defined
+    in an M-file using getrusage.
+
+  * The info reader is now a separate binary that runs as a
+    subprocess.  You still need the info reader distributed with
+    Octave though, because there are some new command-line arguments
+    that are not yet available in the public release of Info.
+
+  * There is a new built-in variable, INFO_PROGRAM, which is used as
+    the name of the info program to run.  Its initial value is
+    $OCTAVE_HOME/lib/octave/VERSION/exec/ARCH/info, but that value can
+    be overridden by the environment variable OCTAVE_INFO_PROGRAM, or
+    the command line argument --info-program NAME, or by setting the
+    value of INFO_PROGRAM in a startup script.
+
+  * There is a new built-in variable, EXEC_PATH, which is used as
+    the list of directories to search when executing subprograms.  Its
+    initial value is taken from the environment variable
+    OCTAVE_EXEC_PATH (if it exists) or PATH, but that value can be
+    overridden by the the command line argument --exec-path PATH, or
+    by setting the value of EXEC_PATH in a startup script.  If the
+    EXEC_PATH begins (ends) with a colon, the directories
+    $OCTAVE_HOME/lib/octave/VERSION/exec/ARCH and $OCTAVE_HOME/bin are
+    prepended (appended) to EXEC_PATH (if you don't specify a value
+    for EXEC_PATH explicitly, these special directories are prepended
+    to your PATH).
+
+  * If it is present, Octave will now use an `ls-R' database file to
+    speed up recursive path searching.  Octave looks for a file called
+    ls-R in the directory specified by the environment variable
+    OCTAVE_DB_DIR.  If that is not set but the environment variable
+    OCTAVE_HOME is set, Octave looks in $OCTAVE_HOME/lib/octave.
+    Otherwise, Octave looks in the directory $datadir/octave (normally
+    /usr/local/lib/octave).
+
+  * New examples directory.
+
+  * There is a new script, mkoctfile, that can be used to create .oct
+    files suitable for dynamic linking.
+
+  * Many more bug fixes.
+
+  * ChangeLogs are now kept in each subdirectory.
+
+See NEWS.1 for old news.
diff --git a/libcruft/ChangeLog b/libcruft/ChangeLog
--- a/libcruft/ChangeLog
+++ b/libcruft/ChangeLog
@@ -1,8 +1,17 @@
+2006-04-29  John W. Eaton  <jwe@octave.org>
+
+	* misc/lo-error.c (set_liboctave_warning_with_id_handler,
+	liboctave_warning_with_id): New functions.
+	(current_liboctave_warning_with_id_handler): New variable.
+	* misc/lo-error.h (liboctave_warning_with_id_handler): New typedef.
+	(current_liboctave_warning_with_id_handler, liboctave_warning_with_id
+	set_liboctave_warning_with_id_handler): Provide decls.
+
 2006-04-18  John W. Eaton  <jwe@octave.org>
 
 	* misc/f77-fcn.h (F77_XFCN): Move decls to beginning of blocks for C.
 
 2006-04-13  John W. Eaton  <jwe@octave.org>
 
 	* misc/quit.h BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE_1,
 	END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE): Omit unnecessary casts.
diff --git a/libcruft/misc/lo-error.c b/libcruft/misc/lo-error.c
--- a/libcruft/misc/lo-error.c
+++ b/libcruft/misc/lo-error.c
@@ -35,17 +35,21 @@ 02110-1301, USA.
    symbol errors when creating shared versions of libcruft. */
 
 /* Pointer to the current error handling function. */
 liboctave_error_handler current_liboctave_error_handler
   = liboctave_fatal;
 
 /* Pointer to the current warning handler. */
 liboctave_warning_handler current_liboctave_warning_handler
-  = liboctave_warning; 
+  = liboctave_warning;
+
+/* Pointer to the current warning_with_id handler. */
+liboctave_warning_with_id_handler current_liboctave_warning_with_id_handler
+  = liboctave_warning_with_id;
 
 static void
 verror (const char *name, const char *fmt, va_list args)
 {
   if (name)
     fprintf (stderr, "%s: ", name);
 
   vfprintf (stderr, fmt, args);
@@ -67,16 +71,25 @@ set_liboctave_warning_handler (liboctave
 {
   if (f)
     current_liboctave_warning_handler = f;
   else
     current_liboctave_warning_handler = liboctave_warning;
 }
 
 void
+set_liboctave_warning_with_id_handler (liboctave_warning_with_id_handler f)
+{
+  if (f)
+    current_liboctave_warning_with_id_handler = f;
+  else
+    current_liboctave_warning_with_id_handler = liboctave_warning_with_id;
+}
+
+void
 liboctave_fatal (const char *fmt, ...)
 {
   va_list args;
   va_start (args, fmt);
   verror ("fatal", fmt, args);
   va_end (args);
 
   exit (1);
@@ -86,14 +99,23 @@ void
 liboctave_warning (const char *fmt, ...)
 {
   va_list args;
   va_start (args, fmt);
   verror ("warning", fmt, args);
   va_end (args);
 }
 
+void
+liboctave_warning_with_id (const char *id, const char *fmt, ...)
+{
+  va_list args;
+  va_start (args, fmt);
+  verror ("warning", fmt, args);
+  va_end (args);
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/libcruft/misc/lo-error.h b/libcruft/misc/lo-error.h
--- a/libcruft/misc/lo-error.h
+++ b/libcruft/misc/lo-error.h
@@ -27,30 +27,38 @@ 02110-1301, USA.
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 extern void liboctave_fatal (const char *fmt, ...) GCC_ATTR_NORETURN;
 
 extern void liboctave_warning (const char *fmt, ...);
 
+extern void liboctave_warning_with_id (const char *id, const char *fmt, ...);
+
 typedef void (*liboctave_error_handler) (const char *, ...);
 
 typedef void (*liboctave_warning_handler) (const char *, ...);
 
+typedef void (*liboctave_warning_with_id_handler) (const char *, const char *, ...);
+
 /* Would be nice to make these pointers private, but we want to share
    them among all the liboctave classes. */
 extern liboctave_error_handler current_liboctave_error_handler;
 
 extern liboctave_warning_handler current_liboctave_warning_handler;
 
+extern liboctave_warning_with_id_handler current_liboctave_warning_with_id_handler;
+
 extern void set_liboctave_error_handler (liboctave_error_handler f);
 
 extern void set_liboctave_warning_handler (liboctave_warning_handler f);
 
+extern void set_liboctave_warning_with_id_handler (liboctave_warning_with_id_handler f);
+
 #ifdef __cplusplus
 }
 #endif
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -29,17 +29,16 @@ 02110-1301, USA.
 #include <cassert>
 #include <climits>
 
 #include <iostream>
 #include <sstream>
 #include <vector>
 
 #include "Array.h"
-#include "Array-flags.h"
 #include "Array-util.h"
 #include "Range.h"
 #include "idx-vector.h"
 #include "lo-error.h"
 
 // One dimensional array class.  Handles the reference counting for
 // all the derived classes.
 
@@ -1787,19 +1786,20 @@ Array<T>::maybe_delete_elements (Array<i
 	{
 	  // We have colons in all indices except for one.
 	  // This index tells us which slice to delete
 
 	  if (n_idx < n_lhs_dims)
 	    {
 	      // Collapse dimensions beyond last index.
 
-	      if (liboctave_wfi_flag && ! (ra_idx(n_idx-1).is_colon ()))
-		(*current_liboctave_warning_handler)
-		  ("fewer indices than dimensions for N-d array");
+	      if (! (ra_idx(n_idx-1).is_colon ()))
+		(*current_liboctave_warning_with_id_handler)
+		  ("Octave:fortran-indexing",
+		   "fewer indices than dimensions for N-d array");
 
 	      for (octave_idx_type i = n_idx; i < n_lhs_dims; i++)
 		lhs_dims(n_idx-1) *= lhs_dims(i);
 
 	      lhs_dims.resize (n_idx);
 
 	      // Reshape *this.
 	      dimensions = lhs_dims;
@@ -1940,17 +1940,17 @@ Array<T>::maybe_delete_elements (Array<i
 	  //
 	  // A(3,3,3)=2;
 	  // A(3:5) = []; A(6)=[]
 
 	  octave_idx_type lhs_numel = numel ();
 
 	  idx_vector idx_vec = ra_idx(0);
 
-	  idx_vec.freeze (lhs_numel, 0, true, liboctave_wrore_flag);
+	  idx_vec.freeze (lhs_numel, 0, true);
       
 	  idx_vec.sort (true);
 
 	  octave_idx_type num_to_delete = idx_vec.length (lhs_numel);
 
 	  if (num_to_delete > 0)
 	    {
 	      octave_idx_type new_numel = lhs_numel - num_to_delete;
@@ -2167,21 +2167,21 @@ Array<T>::index2 (idx_vector& idx_arg, i
 	  else
 	    retval = Array<T> (tmp, dim_vector (len, 1));
 	}
       else if (len >= idx_orig_dims.numel ())
 	retval = Array<T> (tmp, idx_orig_dims);
     }
   else
     {
-      if (liboctave_wfi_flag
-	  && ! (idx_arg.one_zero_only ()
-		&& idx_orig_rows == nr
-		&& idx_orig_columns == nc))
-	(*current_liboctave_warning_handler) ("single index used for matrix");
+      if (! (idx_arg.one_zero_only ()
+	     && idx_orig_rows == nr
+	     && idx_orig_columns == nc))
+	(*current_liboctave_warning_with_id_handler)
+	  ("Octave:fortran-indexing", "single index used for matrix");
 
       // This code is only for indexing matrices.  The vector
       // cases are handled above.
 
       idx_arg.freeze (nr * nc, "matrix", resize_ok);
 
       if (idx_arg)
 	{
@@ -2239,21 +2239,20 @@ Array<T>::indexN (idx_vector& ra_idx, in
 
       retval = Array<T> (*this, dim_vector (orig_len, 1));
     }
   else
     {
       bool vec_equiv = vector_equivalent (dv);
 
       if (! vec_equiv
-	  && liboctave_wfi_flag
 	  && ! (ra_idx.is_colon ()
 		|| (ra_idx.one_zero_only () && idx_orig_dims == dv)))
-	(*current_liboctave_warning_handler)
-	  ("single index used for N-d array");
+	(*current_liboctave_warning_with_id_handler)
+	  ("Octave:fortran-indexing", "single index used for N-d array");
 
       octave_idx_type frozen_len
 	= ra_idx.freeze (orig_len, "nd-array", resize_ok);
 
       if (ra_idx)
 	{
 	  dim_vector result_dims;
 
@@ -2507,17 +2506,17 @@ assign1 (Array<LT>& lhs, const Array<RT>
 
   idx_vector *tmp = lhs.get_idx ();
 
   idx_vector lhs_idx = tmp[0];
 
   octave_idx_type lhs_len = lhs.length ();
   octave_idx_type rhs_len = rhs.length ();
 
-  octave_idx_type n = lhs_idx.freeze (lhs_len, "vector", true, liboctave_wrore_flag);
+  octave_idx_type n = lhs_idx.freeze (lhs_len, "vector", true);
 
   if (n != 0)
     {
       if (rhs_len == n || rhs_len == 1)
 	{
 	  octave_idx_type max_idx = lhs_idx.max () + 1;
 	  if (max_idx > lhs_len)
 	    lhs.resize_and_fill (max_idx, rfv);
@@ -2639,19 +2638,19 @@ assign2 (Array<LT>& lhs, const Array<RT>
   if (n_idx > 1)
     idx_j = tmp[1];
 
   if (n_idx > 0)
     idx_i = tmp[0];
 
   if (n_idx == 2)
     {
-      octave_idx_type n = idx_i.freeze (lhs_nr, "row", true, liboctave_wrore_flag);
-
-      octave_idx_type m = idx_j.freeze (lhs_nc, "column", true, liboctave_wrore_flag);
+      octave_idx_type n = idx_i.freeze (lhs_nr, "row", true);
+
+      octave_idx_type m = idx_j.freeze (lhs_nc, "column", true);
 
       int idx_i_is_colon = idx_i.is_colon ();
       int idx_j_is_colon = idx_j.is_colon ();
 
       if (idx_i_is_colon)
 	n = lhs_nr > 0 ? lhs_nr : rhs_nr;
 
       if (idx_j_is_colon)
@@ -2733,45 +2732,44 @@ assign2 (Array<LT>& lhs, const Array<RT>
   else if (n_idx == 1)
     {
       int lhs_is_empty = lhs_nr == 0 || lhs_nc == 0;
 
       if (lhs_is_empty || (lhs_nr == 1 && lhs_nc == 1))
 	{
 	  octave_idx_type lhs_len = lhs.length ();
 
-	  octave_idx_type n = idx_i.freeze (lhs_len, 0, true, liboctave_wrore_flag);
+	  octave_idx_type n = idx_i.freeze (lhs_len, 0, true);
 
 	  if (idx_i)
 	    {
 	      if (rhs_nr == 0 && rhs_nc == 0)
 		{
 		  if (n != 0 && (lhs_nr != 0 || lhs_nc != 0))
 		    lhs.maybe_delete_elements (idx_i);
 		}
 	      else
 		{
-		  if (liboctave_wfi_flag)
+		  if (lhs_is_empty
+		      && idx_i.is_colon ()
+		      && ! (rhs_nr == 1 || rhs_nc == 1))
 		    {
-		      if (lhs_is_empty
-			  && idx_i.is_colon ()
-			  && ! (rhs_nr == 1 || rhs_nc == 1))
-			{
-			  (*current_liboctave_warning_handler)
-			    ("A(:) = X: X is not a vector or scalar");
-			}
-		      else
-			{
-			  octave_idx_type idx_nr = idx_i.orig_rows ();
-			  octave_idx_type idx_nc = idx_i.orig_columns ();
-
-			  if (! (rhs_nr == idx_nr && rhs_nc == idx_nc))
-			    (*current_liboctave_warning_handler)
-			      ("A(I) = X: X does not have same shape as I");
-			}
+		      (*current_liboctave_warning_with_id_handler)
+			("Octave:fortran-indexing",
+			 "A(:) = X: X is not a vector or scalar");
+		    }
+		  else
+		    {
+		      octave_idx_type idx_nr = idx_i.orig_rows ();
+		      octave_idx_type idx_nc = idx_i.orig_columns ();
+
+		      if (! (rhs_nr == idx_nr && rhs_nc == idx_nc))
+			(*current_liboctave_warning_with_id_handler)
+			  ("Octave:fortran-indexing",
+			   "A(I) = X: X does not have same shape as I");
 		    }
 
 		  if (assign1 (lhs, xrhs, rfv))
 		    {
 		      octave_idx_type len = lhs.length ();
 
 		      if (len > 0)
 			{
@@ -2787,17 +2785,17 @@ assign2 (Array<LT>& lhs, const Array<RT>
 		  else
 		    retval = 0;
 		}
 	    }
 	  // idx_vector::freeze() printed an error message for us.
 	}
       else if (lhs_nr == 1)
 	{
-	  idx_i.freeze (lhs_nc, "vector", true, liboctave_wrore_flag);
+	  idx_i.freeze (lhs_nc, "vector", true);
 
 	  if (idx_i)
 	    {
 	      if (rhs_nr == 0 && rhs_nc == 0)
 		lhs.maybe_delete_elements (idx_i);
 	      else
 		{
 		  if (assign1 (lhs, xrhs, rfv))
@@ -2805,17 +2803,17 @@ assign2 (Array<LT>& lhs, const Array<RT>
 		  else
 		    retval = 0;
 		}
 	    }
 	  // idx_vector::freeze() printed an error message for us.
 	}
       else if (lhs_nc == 1)
 	{
-	  idx_i.freeze (lhs_nr, "vector", true, liboctave_wrore_flag);
+	  idx_i.freeze (lhs_nr, "vector", true);
 
 	  if (idx_i)
 	    {
 	      if (rhs_nr == 0 && rhs_nc == 0)
 		lhs.maybe_delete_elements (idx_i);
 	      else
 		{
 		  if (assign1 (lhs, xrhs, rfv))
@@ -2823,23 +2821,22 @@ assign2 (Array<LT>& lhs, const Array<RT>
 		  else
 		    retval = 0;
 		}
 	    }
 	  // idx_vector::freeze() printed an error message for us.
 	}
       else
 	{
-	  if (liboctave_wfi_flag
-	      && ! (idx_i.is_colon ()
-		    || (idx_i.one_zero_only ()
-			&& idx_i.orig_rows () == lhs_nr
-			&& idx_i.orig_columns () == lhs_nc)))
-	    (*current_liboctave_warning_handler)
-	      ("single index used for matrix");
+	  if (! (idx_i.is_colon ()
+		 || (idx_i.one_zero_only ()
+		     && idx_i.orig_rows () == lhs_nr
+		     && idx_i.orig_columns () == lhs_nc)))
+	    (*current_liboctave_warning_with_id_handler)
+	      ("Octave:fortran-indexing", "single index used for matrix");
 
 	  octave_idx_type len = idx_i.freeze (lhs_nr * lhs_nc, "matrix");
 
 	  if (idx_i)
 	    {
 	      if (rhs_nr == 0 && rhs_nc == 0)
 		lhs.maybe_delete_elements (idx_i);
 	      else if (len == 0)
@@ -2925,22 +2922,21 @@ assignN (Array<LT>& lhs, const Array<RT>
 	("invalid number of indices for matrix expression");
 
       retval = 0;
     }
   else if (n_idx == 1)
     {
       idx_vector iidx = idx(0);
 
-      if (liboctave_wfi_flag
-	  && ! (iidx.is_colon ()
-		|| (iidx.one_zero_only ()
-		    && iidx.orig_dimensions () == lhs.dims ())))
-	(*current_liboctave_warning_handler)
-	  ("single index used for N-d array");
+      if (! (iidx.is_colon ()
+	     || (iidx.one_zero_only ()
+		 && iidx.orig_dimensions () == lhs.dims ())))
+	(*current_liboctave_warning_with_id_handler)
+	  ("Octave:fortran-indexing", "single index used for N-d array");
 
       octave_idx_type lhs_len = lhs.length ();
 
       octave_idx_type len = iidx.freeze (lhs_len, "N-d arrray");
 
       if (iidx)
 	{
 	  if (len == 0)
@@ -3001,19 +2997,20 @@ assignN (Array<LT>& lhs, const Array<RT>
       bool orig_empty = lhs_dims.all_zero ();
 
       if (n_idx < lhs_dims_len)
 	{
 	  // Collapse dimensions beyond last index.  Note that we
 	  // delay resizing LHS until we know that the assignment will
 	  // succeed.
 
-	  if (liboctave_wfi_flag && ! (idx(n_idx-1).is_colon ()))
-	    (*current_liboctave_warning_handler)
-	      ("fewer indices than dimensions for N-d array");
+	  if (! (idx(n_idx-1).is_colon ()))
+	    (*current_liboctave_warning_with_id_handler)
+	      ("Octave:fortran-indexing",
+	       "fewer indices than dimensions for N-d array");
 
 	  for (int i = n_idx; i < lhs_dims_len; i++)
 	    lhs_dims(n_idx-1) *= lhs_dims(i);
 
 	  lhs_dims.resize (n_idx);
 
 	  lhs_dims_len = lhs_dims.length ();
 	}
diff --git a/liboctave/ArrayN-idx.h b/liboctave/ArrayN-idx.h
--- a/liboctave/ArrayN-idx.h
+++ b/liboctave/ArrayN-idx.h
@@ -17,17 +17,16 @@ for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 02110-1301, USA.
 
 */
 
-#include "Array-flags.h"
 #include "Range.h"
 #include "idx-vector.h"
 #include "lo-error.h"
 
 #if 0
 
 template <class T>
 ArrayN<T>
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,35 @@
+2006-05-01  John W. Eaton  <jwe@octave.org>
+
+	* oct-shlib.h (octave_shlib::octave_shlib, octave_shlib::open):
+	Delete WARN_FUTURE arg.  Change all uses.
+	* oct-shlib.cc (octave_base_shlib::stamp_time): Delete arg.
+	Change all uses.  Use current_liboctave_warning_with_id_handler.
+	(octave_base_shlib::open): Delete arg.  Change all derived classes
+	and uses.
+
+2006-04-29  John W. Eaton  <jwe@octave.org>
+
+	* Array-flags.cc, Array-flags.h: Delete.
+	* Makefile.in (MATRIX_SRC): Remove Array-flags.cc from the list.
+	(MATRIX_INC): Remove Array-flags.h from the list.
+
+	* idx-vector.cc (IDX_VEC_REP::freeze): Delete warn_resize arg.
+	Use current_liboctave_warning_with_id_handler
+	with warning ID Octave:resize-on-range-error.
+	* idx-vector.h: Fix decl.
+	* Array.cc, Sparse.cc: Change all callers.
+
+	* Array.cc (Array<T>::maybe_delete_elements, Array<T>::index2,
+	assign2, assignN): Use current_liboctave_warning_with_id_handler
+	with warning ID Octave:fortran-indexing instead of
+	liboctave_wfi_flag.
+	* Sparse.cc (assign, Sparse<T>::index): Likewise.
+
 2006-04-26  John W. Eaton  <jwe@octave.org>
 
 	* pathsearch.cc (dir_path::path_sep_char, dir_path::path_sep_str):
 	New static data.
 	* pathsearch.h: Provide decls.
 	(dir_path::is_path_sep): New function.
 
 2006-04-18  John W. Eaton  <jwe@octave.org>
diff --git a/liboctave/Makefile.in b/liboctave/Makefile.in
--- a/liboctave/Makefile.in
+++ b/liboctave/Makefile.in
@@ -20,17 +20,17 @@ INSTALL_DATA = @INSTALL_DATA@
 
 LINK_DEPS = \
   -L../libcruft -L. $(RLD_FLAG) \
   $(LIBCRUFT) $(CHOLMOD_LIBS) $(UMFPACK_LIBS)  $(AMD_LIBS) \
   $(COLAMD_LIBS) $(CCOLAMD_LIBS) $(CXSPARSE_LIBS) \
   $(BLAS_LIBS) $(FFTW_LIBS) $(LIBREADLINE) $(LIBGLOB) $(LIBS) $(FLIBS)
 
 MATRIX_INC := Array.h Array2.h Array3.h ArrayN.h DiagArray2.h \
-	Array-flags.h Array-util.h ArrayN-idx.h MArray-defs.h \
+	Array-util.h ArrayN-idx.h MArray-defs.h \
 	MArray.h MArray2.h MDiagArray2.h Matrix.h MArrayN.h \
 	base-lu.h dim-vector.h mx-base.h mx-op-defs.h mx-ops.h \
 	mx-defs.h mx-ext.h CColVector.h CDiagMatrix.h CMatrix.h \
 	CNDArray.h CRowVector.h CmplxAEPBAL.h CmplxCHOL.h \
 	CmplxDET.h CmplxHESS.h CmplxLU.h CmplxQR.h CmplxQRP.h \
 	CmplxSCHUR.h CmplxSVD.h EIG.h boolMatrix.h boolNDArray.h \
 	chMatrix.h chNDArray.h dColVector.h dDiagMatrix.h dMatrix.h \
 	dNDArray.h dRowVector.h dbleAEPBAL.h dbleCHOL.h dbleDET.h \
@@ -85,17 +85,17 @@ TEMPLATE_SRC := Array.cc ArrayN.cc DiagA
 	sparse-dmsolve.cc
 
 TI_SRC := Array-C.cc Array-b.cc Array-ch.cc Array-i.cc Array-d.cc \
 	Array-s.cc Array-so.cc Array-str.cc Array-idx-vec.cc \
 	MArray-C.cc MArray-ch.cc MArray-i.cc MArray-d.cc MArray-s.cc \
 	MSparse-C.cc MSparse-d.cc Sparse-C.cc Sparse-b.cc Sparse-d.cc \
 	oct-inttypes.cc
 
-MATRIX_SRC := Array-flags.cc Array-util.cc CColVector.cc \
+MATRIX_SRC := Array-util.cc CColVector.cc \
 	CDiagMatrix.cc CMatrix.cc CNDArray.cc CRowVector.cc \
 	CmplxAEPBAL.cc CmplxCHOL.cc CmplxDET.cc CmplxHESS.cc \
 	CmplxLU.cc CmplxQR.cc CmplxQRP.cc CmplxSCHUR.cc CmplxSVD.cc \
 	EIG.cc boolMatrix.cc boolNDArray.cc chMatrix.cc \
 	chNDArray.cc dColVector.cc dDiagMatrix.cc dMatrix.cc \
 	dNDArray.cc dRowVector.cc dbleAEPBAL.cc dbleCHOL.cc \
 	dbleDET.cc dbleHESS.cc dbleLU.cc dbleQR.cc dbleQRP.cc \
 	dbleSCHUR.cc dbleSVD.cc boolSparse.cc CSparse.cc dSparse.cc \
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -28,17 +28,16 @@ Boston, MA 02110-1301, USA.
 #include <cassert>
 #include <climits>
 
 #include <iostream>
 #include <sstream>
 #include <vector>
 
 #include "Array.h"
-#include "Array-flags.h"
 #include "Array-util.h"
 #include "Range.h"
 #include "idx-vector.h"
 #include "lo-error.h"
 #include "quit.h"
 
 #include "Sparse.h"
 #include "sparse-sort.h"
@@ -1720,22 +1719,21 @@ Sparse<T>::index (idx_vector& idx_arg, i
 		      retval.xcidx(i/new_nr+1) = jj;
 		    }
 		}
 	    }
 	}
     }
   else
     {
-      if (liboctave_wfi_flag
-	  && ! (idx_arg.one_zero_only ()
-		&& idx_orig_rows == nr
-		&& idx_orig_columns == nc))
-	(*current_liboctave_warning_handler) 
-	  ("single index used for sparse matrix");
+      if (! (idx_arg.one_zero_only ()
+	     && idx_orig_rows == nr
+	     && idx_orig_columns == nc))
+	(*current_liboctave_warning_with_id_handler) 
+	  ("Octave:fortran-indexing", "single index used for sparse matrix");
 
       // This code is only for indexing matrices.  The vector
       // cases are handled above.
 
       idx_arg.freeze (nr * nc, "matrix", resize_ok);
 
       if (idx_arg)
 	{
@@ -2032,18 +2030,17 @@ assign1 (Sparse<LT>& lhs, const Sparse<R
       lhs.clear_index ();
       return 0;
     }
 
   octave_idx_type nr = lhs.rows ();
   octave_idx_type nc = lhs.cols ();
   octave_idx_type nz = lhs.nnz ();
 
-  octave_idx_type n = lhs_idx.freeze (lhs_len, "vector", true, 
-				      liboctave_wrore_flag);
+  octave_idx_type n = lhs_idx.freeze (lhs_len, "vector", true);
 
   if (n != 0)
     {
       octave_idx_type max_idx = lhs_idx.max () + 1;
       max_idx = max_idx < lhs_len ? lhs_len : max_idx;
 
       // Take a constant copy of lhs. This means that elem won't 
       // create missing elements.
@@ -2396,20 +2393,18 @@ assign (Sparse<LT>& lhs, const Sparse<RT
   if (n_idx > 1)
     idx_j = tmp[1];
 
   if (n_idx > 0)
     idx_i = tmp[0];
 
   if (n_idx == 2)
     {
-      octave_idx_type n = idx_i.freeze (lhs_nr, "row", true, 
-					liboctave_wrore_flag);
-      octave_idx_type m = idx_j.freeze (lhs_nc, "column", true, 
-					liboctave_wrore_flag);
+      octave_idx_type n = idx_i.freeze (lhs_nr, "row", true);
+      octave_idx_type m = idx_j.freeze (lhs_nc, "column", true);
 
       int idx_i_is_colon = idx_i.is_colon ();
       int idx_j_is_colon = idx_j.is_colon ();
 
       if (idx_i_is_colon)
 	n = lhs_nr > 0 ? lhs_nr : rhs_nr;
 
       if (idx_j_is_colon)
@@ -2716,89 +2711,86 @@ assign (Sparse<LT>& lhs, const Sparse<RT
   else if (n_idx == 1)
     {
       int lhs_is_empty = lhs_nr == 0 || lhs_nc == 0;
 
       if (lhs_is_empty || (lhs_nr == 1 && lhs_nc == 1))
 	{
 	  octave_idx_type lhs_len = lhs.length ();
 
-	  octave_idx_type n = idx_i.freeze (lhs_len, 0, true, 
-					    liboctave_wrore_flag);
+	  octave_idx_type n = idx_i.freeze (lhs_len, 0, true);
 
 	  if (idx_i)
 	    {
 	      if (rhs_nr == 0 && rhs_nc == 0)
 		{
 		  if (n != 0 && (lhs_nr != 0 || lhs_nc != 0))
 		    lhs.maybe_delete_elements (idx_i);
 		}
 	      else
 		{
-		  if (liboctave_wfi_flag)
+		  if (lhs_is_empty
+		      && idx_i.is_colon ()
+		      && ! (rhs_nr == 1 || rhs_nc == 1))
 		    {
-		      if (lhs_is_empty
-			  && idx_i.is_colon ()
-			  && ! (rhs_nr == 1 || rhs_nc == 1))
-			{
-			  (*current_liboctave_warning_handler)
-			    ("A(:) = X: X is not a vector or scalar");
-			}
-		      else
-			{
-			  octave_idx_type idx_nr = idx_i.orig_rows ();
-			  octave_idx_type idx_nc = idx_i.orig_columns ();
-
-			  if (! (rhs_nr == idx_nr && rhs_nc == idx_nc))
-			    (*current_liboctave_warning_handler)
-			      ("A(I) = X: X does not have same shape as I");
-			}
+		      (*current_liboctave_warning_with_id_handler)
+			("Octave:fortran-indexing",
+			 "A(:) = X: X is not a vector or scalar");
+		    }
+		  else
+		    {
+		      octave_idx_type idx_nr = idx_i.orig_rows ();
+		      octave_idx_type idx_nc = idx_i.orig_columns ();
+
+		      if (! (rhs_nr == idx_nr && rhs_nc == idx_nc))
+			(*current_liboctave_warning_with_id_handler)
+			  ("Octave:fortran-indexing",
+			   "A(I) = X: X does not have same shape as I");
 		    }
 
 		  if (! assign1 (lhs, rhs))
 		    retval = 0;
 		}
 	    }
 	  // idx_vector::freeze() printed an error message for us.
 	}
       else if (lhs_nr == 1)
 	{
-	  idx_i.freeze (lhs_nc, "vector", true, liboctave_wrore_flag);
+	  idx_i.freeze (lhs_nc, "vector", true);
 
 	  if (idx_i)
 	    {
 	      if (rhs_nr == 0 && rhs_nc == 0)
 		lhs.maybe_delete_elements (idx_i);
 	      else if (! assign1 (lhs, rhs))
 		retval = 0;
 	    }
 	  // idx_vector::freeze() printed an error message for us.
 	}
       else if (lhs_nc == 1)
 	{
-	  idx_i.freeze (lhs_nr, "vector", true, liboctave_wrore_flag);
+	  idx_i.freeze (lhs_nr, "vector", true);
 
 	  if (idx_i)
 	    {
 	      if (rhs_nr == 0 && rhs_nc == 0)
 		lhs.maybe_delete_elements (idx_i);
 	      else if (! assign1 (lhs, rhs))
 		retval = 0;
 	    }
 	  // idx_vector::freeze() printed an error message for us.
 	}
       else
 	{
-	  if (liboctave_wfi_flag
-	      && ! (idx_i.is_colon ()
-		    || (idx_i.one_zero_only ()
-			&& idx_i.orig_rows () == lhs_nr
-			&& idx_i.orig_columns () == lhs_nc)))
-	    (*current_liboctave_warning_handler)
-	      ("single index used for matrix");
+	  if (! (idx_i.is_colon ()
+		 || (idx_i.one_zero_only ()
+		     && idx_i.orig_rows () == lhs_nr
+		     && idx_i.orig_columns () == lhs_nc)))
+	    (*current_liboctave_warning_with_id_handler)
+	      ("Octave:fortran-indexing", "single index used for matrix");
 
 	  octave_idx_type lhs_len = lhs.length ();
 
 	  octave_idx_type len = idx_i.freeze (lhs_nr * lhs_nc, "matrix");
 
 	  if (idx_i)
 	    {
 	      // Take a constant copy of lhs. This means that elem won't 
diff --git a/liboctave/idx-vector.cc b/liboctave/idx-vector.cc
--- a/liboctave/idx-vector.cc
+++ b/liboctave/idx-vector.cc
@@ -533,18 +533,17 @@ std::ostream&
 IDX_VEC_REP::print (std::ostream& os) const
 {
   for (octave_idx_type ii = 0; ii < len; ii++)
     os << data[ii] << "\n";
   return os;
 }
 
 octave_idx_type
-IDX_VEC_REP::freeze (octave_idx_type z_len, const char *tag, bool resize_ok,
-		     bool warn_resize)
+IDX_VEC_REP::freeze (octave_idx_type z_len, const char *tag, bool resize_ok)
 {
   if (frozen)
     return frozen_len;
 
   frozen_len = -1;
 
   if (colon)
     frozen_len = z_len;
@@ -578,25 +577,27 @@ IDX_VEC_REP::freeze (octave_idx_type z_l
 	      else
 		(*current_liboctave_error_handler)
 		  ("invalid index = %d", max_val+1);
 
 	      initialized = 0;
 	    }
 	  else
 	    {
-	      if (warn_resize && max_val >= z_len)
+	      if (max_val >= z_len)
 		{
 		  if (tag)
-		    (*current_liboctave_warning_handler)
-		      ("resizing object with %s index = %d out of bounds",
+		    (*current_liboctave_warning_with_id_handler)
+		      ("Octave:resize-on-range-error",
+		       "resizing object with %s index = %d out of bounds",
 		       tag, max_val+1);
 		  else
-		    (*current_liboctave_warning_handler)
-		      ("resizing object with index = %d out of bounds",
+		    (*current_liboctave_warning_with_id_handler)
+		      ("Octave:resize-on-range-error",
+		       "resizing object with index = %d out of bounds",
 		       max_val+1);
 		}
 
 	      frozen_len = length (z_len);
 	    }
 	}
     }
 
diff --git a/liboctave/idx-vector.h b/liboctave/idx-vector.h
--- a/liboctave/idx-vector.h
+++ b/liboctave/idx-vector.h
@@ -143,17 +143,17 @@ private:
     octave_idx_type orig_columns (void) const { return orig_dims(1); }
 
     dim_vector orig_dimensions (void) const { return orig_dims; }
 
     // other stuff
 
     void shorten (octave_idx_type n); // Unsafe.  Avoid at all cost.
 
-    octave_idx_type freeze (octave_idx_type z_len, const char *tag, bool resize_ok, bool warn_resize);
+    octave_idx_type freeze (octave_idx_type z_len, const char *tag, bool resize_ok);
 
     // i/o
 
     std::ostream& print (std::ostream& os) const;
 
     octave_idx_type *data;
     octave_idx_type len;
     octave_idx_type num_zeros;
@@ -264,19 +264,18 @@ public:
   int orig_empty (void) const
     { return (! is_colon () && orig_dimensions().any_zero ()); }
 
   // Unsafe.  Avoid at all cost.
   void shorten (octave_idx_type n) { rep->shorten (n); }
 
   // i/o
 
-  octave_idx_type freeze (octave_idx_type z_len, const char *tag, bool resize_ok = false,
-	      bool warn_resize = false)
-    { return rep->freeze (z_len, tag, resize_ok, warn_resize); }
+  octave_idx_type freeze (octave_idx_type z_len, const char *tag, bool resize_ok = false)
+    { return rep->freeze (z_len, tag, resize_ok); }
 
   std::ostream& print (std::ostream& os) const { return rep->print (os); }
 
   friend std::ostream& operator << (std::ostream& os, const idx_vector& a)
     { return a.print (os); }
 
   void maybe_convert_one_zero_to_idx (octave_idx_type z_len)
     { rep->maybe_convert_one_zero_to_idx (z_len); }
diff --git a/liboctave/oct-shlib.cc b/liboctave/oct-shlib.cc
--- a/liboctave/oct-shlib.cc
+++ b/liboctave/oct-shlib.cc
@@ -69,17 +69,17 @@ public:
 
   octave_base_shlib (const std::string& f)
     : octave_shlib (octave_xshlib ()), file (f), fcn_names (),
       tm_loaded (static_cast<time_t> (0))
   { count = 1; }
 
   ~octave_base_shlib (void) { }
 
-  void open (const std::string&, bool = false) { }
+  void open (const std::string&) { }
 
   void *search (const std::string&, name_mangler = 0) { return 0; }
 
   void close (octave_shlib::close_hook = 0) { }
 
   bool remove (const std::string& fcn_name);
 
   bool is_open (void) const { return false; }
@@ -95,17 +95,17 @@ public:
 protected:
 
   std::string file;
 
   string_vector fcn_names;
 
   octave_time tm_loaded;
 
-  void stamp_time (bool warn_future = false);
+  void stamp_time (void);
 
   void add_to_fcn_names (const std::string& name);
 
   void do_close_hook (octave_shlib::close_hook = 0);
 
   void tabula_rasa (void);
 
   // No copying!
@@ -145,28 +145,26 @@ bool
 octave_base_shlib::is_out_of_date (void) const
 {
   file_stat fs (file);
 
   return fs.is_newer (tm_loaded);
 }
 
 void
-octave_base_shlib::stamp_time (bool warn_future)
+octave_base_shlib::stamp_time (void)
 {
   tm_loaded.stamp ();
 
-  if (warn_future)
-    {
-      file_stat fs (file);
+  file_stat fs (file);
 
-      if (fs.is_newer (tm_loaded))
-	(*current_liboctave_warning_handler)
-	  ("timestamp on file %s is in the future", file.c_str ());
-    }
+  if (fs.is_newer (tm_loaded))
+    (*current_liboctave_warning_with_id_handler)
+      ("Octave:warn-future-time-stamp",
+       "timestamp on file %s is in the future", file.c_str ());
 }
 
 void
 octave_base_shlib::add_to_fcn_names (const std::string& name)
 {
   int n = number_of_functions_loaded ();
 
   for (int i = 0; i < n; i++)
@@ -203,17 +201,17 @@ class
 octave_dlopen_shlib : public octave_base_shlib
 {
 public:
 
   octave_dlopen_shlib (void);
 
   ~octave_dlopen_shlib (void);
 
-  void open (const std::string& f, bool warn_future = false);
+  void open (const std::string& f);
 
   void *search (const std::string& name, name_mangler mangler = 0);
 
   void close (octave_shlib::close_hook cl_hook = 0);
 
   bool is_open (void) const { return (library != 0); }
 
 private:
@@ -233,17 +231,17 @@ octave_dlopen_shlib::octave_dlopen_shlib
 }
 
 octave_dlopen_shlib::~octave_dlopen_shlib (void)
 {
   close ();
 }
 
 void
-octave_dlopen_shlib::open (const std::string& f, bool warn_future)
+octave_dlopen_shlib::open (const std::string& f)
 {
   if (! is_open ())
     {
       file = f;
 
       int flags = 0;
 
 #if defined (RTLD_LAZY)
@@ -252,17 +250,17 @@ octave_dlopen_shlib::open (const std::st
 
 #if defined (RTLD_GLOBAL)
       flags |= RTLD_GLOBAL;
 #endif
       
       library = dlopen (file.c_str (), flags);
 
       if (library)
-	stamp_time (warn_future);
+	stamp_time ();
       else
 	{
 	  const char *msg = dlerror ();
 
 	  if (msg)
 	    (*current_liboctave_error_handler) ("%s", msg);
 	}
     }
@@ -317,17 +315,17 @@ class
 octave_shl_load_shlib : public octave_base_shlib
 {
 public:
 
   octave_shl_load_shlib (void);
 
   ~octave_shl_load_shlib (void);
 
-  void open (const std::string& f, bool warn_future = false);
+  void open (const std::string& f);
 
   void *search (const std::string& name, name_mangler mangler = 0);
 
   void close (octave_shlib::close_hook cl_hook = 0);
 
   bool is_open (void) const { return (library != 0); }
 
 private:
@@ -347,26 +345,26 @@ octave_shl_load_shlib::octave_shl_load_s
 }
 
 octave_shl_load_shlib::~octave_shl_load_shlib (void)
 {
   close ();
 }
 
 void
-octave_shl_load_shlib::open (const std::string& f, bool warn_future)
+octave_shl_load_shlib::open (const std::string& f)
 {
   if (! is_open ())
     {
       file = f;
 
       library = shl_load (file.c_str (), BIND_DEFERRED, 0L);
 
       if (library)
-	stamp_time (warn_future);
+	stamp_time ();
       else
 	{
 	  using namespace std;
 	  (*current_liboctave_error_handler) ("%s", strerror (errno));
 	}
     }
   else
     (*current_liboctave_error_handler)
@@ -420,17 +418,17 @@ class
 octave_w32_shlib: public octave_base_shlib
 {
 public:
 
   octave_w32_shlib (void);
 
   ~octave_w32_shlib (void);
 
-  void open (const std::string& f, bool warn_future = false);
+  void open (const std::string& f);
 
   void *search (const std::string& name, name_mangler mangler = 0);
 
   void close (octave_shlib::close_hook cl_hook = 0);
 
   bool is_open (void) const { return (handle != 0); }
 
 private:
@@ -450,26 +448,26 @@ octave_w32_shlib::octave_w32_shlib (void
 }
 
 octave_w32_shlib::~octave_w32_shlib (void)
 {
   close ();
 }
 
 void
-octave_w32_shlib::open (const std::string& f, bool warn_future)
+octave_w32_shlib::open (const std::string& f)
 {
   if (! is_open ())
     {
       file = f;
 
       handle = LoadLibrary (file.c_str ());
 
       if (handle != NULL)
-	stamp_time (warn_future);
+	stamp_time ();
       else
 	{
 	  DWORD lastError = GetLastError ();
 	  char *msg;
 
 	  switch (lastError)
 	    {
 	    case ERROR_MOD_NOT_FOUND:
@@ -548,17 +546,17 @@ class
 octave_dyld_shlib : public octave_base_shlib
 {
 public:
 
   octave_dyld_shlib (void);
 
   ~octave_dyld_shlib (void);
 
-  void open (const std::string& f, bool warn_future = false);
+  void open (const std::string& f);
 
   void *search (const std::string& name, name_mangler mangler = 0);
 
   void close (octave_shlib::close_hook cl_hook = 0);
 
   bool is_open (void) const {return (isOpen); }
 
 private:
@@ -580,34 +578,34 @@ octave_dyld_shlib::octave_dyld_shlib (vo
 }
 
 octave_dyld_shlib::~octave_dyld_shlib (void)
 {
   close ();
 }
 
 void
-octave_dyld_shlib::open (const std::string& f, bool warn_future)
+octave_dyld_shlib::open (const std::string& f)
 {
   int returnCode;
 
   if (! is_open ())
     {
       file = f;
 
       returnCode = NSCreateObjectFileImageFromFile (file.c_str (), &img);
 
       if (NSObjectFileImageSuccess == returnCode)
 	{
 	  handle = NSLinkModule (img, file.c_str (),
 				 (NSLINKMODULE_OPTION_RETURN_ON_ERROR
 				  | NSLINKMODULE_OPTION_PRIVATE));
 	  if (handle)
 	    {
-	      stamp_time (warn_future);
+	      stamp_time ();
 	      isOpen = true;
 	    }
 	  else
 	    {
 	      (*current_liboctave_error_handler)
 		("couldn't link module %s", file.c_str ());	
 	    }
 	}
diff --git a/liboctave/oct-shlib.h b/liboctave/oct-shlib.h
--- a/liboctave/oct-shlib.h
+++ b/liboctave/oct-shlib.h
@@ -45,21 +45,17 @@ octave_shlib
 public:
 
   typedef std::string (*name_mangler) (const std::string&);
 
   typedef void (*close_hook) (const std::string&);
 
   octave_shlib (void) : rep (make_shlib ()) { }
 
-  octave_shlib (const std::string& f, bool warn_future)
-    : rep (make_shlib ())
-  {
-    open (f, warn_future);
-  }
+  octave_shlib (const std::string& f) : rep (make_shlib ()) { open (f); }
 
   virtual ~octave_shlib (void)
     {
       if (rep && --rep->count == 0)
 	{
 	  delete rep;
 	  rep = 0;
 	}
@@ -85,18 +81,17 @@ public:
       return *this;
     }
 
   bool operator == (const octave_shlib& sl) const
     { return (rep == sl.rep); }
 
   operator bool () const { return is_open (); }
 
-  virtual void open (const std::string& f, bool warn_future = false)
-    { rep->open (f, warn_future); }
+  virtual void open (const std::string& f) { rep->open (f); }
   
   virtual void *search (const std::string& nm, name_mangler mangler = 0)
     { return rep->search (nm, mangler); }
 
   virtual void close (close_hook cl_hook = 0)
     { rep->close (cl_hook); }
 
   virtual bool remove (const std::string& fcn_name)
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,12 @@
+2006-04-29  John W. Eaton  <jwe@octave.org>
+
+	* startup/main-rcfile: Disable some warnings.
+
 2006-04-14  Bill Denney  <denney@seas.upenn.edu>
 
  	* strings/strcmpi.m: Return false instead of error if args are not
 	char or cellstr.
 
 2006-04-10  John W. Eaton  <jwe@octave.org>
 
 	* miscellaneous/dir.m: Ensure that returned structure array is
diff --git a/scripts/miscellaneous/warning_ids.m b/scripts/miscellaneous/warning_ids.m
new file mode 100644
--- /dev/null
+++ b/scripts/miscellaneous/warning_ids.m
@@ -0,0 +1,212 @@
+## -*- texinfo -*-
+## @table @code
+## @item Octave:array-to-scalar
+## If the @code{Octave:array-to-scalar} warning is enabled, Octave will
+## warn when an implicit conversion from an array to a scalar value is
+## attempted.  By default, the @code{Octave:array-to-scalar} warning is
+## disabled.
+## 
+## @item Octave:array-to-vector
+## If the @code{Octave:array-to-vector} warning is enabled, Octave will
+## warn when an implicit conversion from an array to a vector value is
+## attempted.  By default, the @code{Octave:array-to-vector} warning is
+## disabled.
+## 
+## @item Octave:assign-as-truth-value
+## If the @code{Octave:assign-as-truth-value} warning is
+## enabled, a warning is issued for statements like
+## 
+## @example
+## if (s = t)
+##   ...
+## @end example
+## 
+## @noindent
+## since such statements are not common, and it is likely that the intent
+## was to write
+## 
+## @example
+## if (s == t)
+##   ...
+## @end example
+## 
+## @noindent
+## instead.
+## 
+## There are times when it is useful to write code that contains
+## assignments within the condition of a @code{while} or @code{if}
+## statement.  For example, statements like
+## 
+## @example
+## while (c = getc())
+##   ...
+## @end example
+## 
+## @noindent
+## are common in C programming.
+## 
+## It is possible to avoid all warnings about such statements by
+## disabling the @code{Octave:assign-as-truth-value} warning,
+## but that may also let real errors like
+## 
+## @example
+## if (x = 1)  # intended to test (x == 1)!
+##   ...
+## @end example
+## 
+## @noindent
+## slip by.
+## 
+## In such cases, it is possible suppress errors for specific statements by
+## writing them with an extra set of parentheses.  For example, writing the
+## previous example as
+## 
+## @example
+## while ((c = getc()))
+##   ...
+## @end example
+## 
+## @noindent
+## will prevent the warning from being printed for this statement, while
+## allowing Octave to warn about other assignments used in conditional
+## contexts.
+## 
+## By default, the @code{Octave:assign-as-truth-value} warning is enabled.
+## 
+## @item Octave:associativity-change
+## If the @code{Octave:associativity-change} warning is
+## enabled, Octave will warn about possible changes in the meaning of
+## some code due to changes in associativity for some operators.
+## Associativity changes have typically been made for Matlab
+## compatibility.  By default, the @code{Octave:associativity-change}
+## warning is enabled.
+## 
+## @item Octave:divide-by-zero
+## If the @code{Octave:divide-by-zero} warning is enabled, a
+## warning is issued when Octave encounters a division by zero.  By
+## default, the @code{Octave:divide-by-zero} warning is enabled.
+## 
+## @item Octave:empty-list-elements
+## If the @code{Octave:empty-list-elements} warning is enabled, a
+## warning is issued when an empty matrix is found in a matrix list.
+## For example,
+## 
+## @example
+## a = [1, [], 3, [], 5]
+## @end example
+## 
+## @noindent
+## By default, the @code{Octave:empty-list-elements} warning is enabled.
+## 
+## @item Octave:fortran-indexing
+## If the @code{Octave:fortran-indexing} warning is enabled, a warning is
+## printed for expressions which select elements of a two-dimensional matrix
+## using a single index.  By default, the @code{Octave:fortran-indexing}
+## warning is disabled.
+## 
+## @item Octave:function-name-clash
+## If the @code{Octave:function-name-clash} warning is enabled, a
+## warning is issued when Octave finds that the name of a function
+## defined in a function file differs from the name of the file.  (If
+## the names disagree, the name declared inside the file is ignored.)
+## By default, the @code{Octave:function-name-clash} warning is enabled.
+## 
+## @item Octave:future-time-stamp
+## If the @code{Octave:future-time-stamp} warning is enabled, Octave
+## will print a warning if it finds a function file with a time stamp
+## that is in the future.  By default, the
+## @code{Octave:future-time-stamp} warning is enabled.
+## 
+## @item Octave:imag-to-real
+## If the @code{Octave:imag-to-real} warning is enabled, a warning is
+## printed for implicit conversions of complex numbers to real numbers.
+## By default, the @code{Octave:imag-to-real} warning is disabled.
+## 
+## @item Octave:missing-semicolon
+## If the @code{Octave:missing-semicolon} warning is enabled, Octave
+## will warn when statements in function definitions don't end in
+## semicolons.  By default the @code{Octave:missing-semicolon} warning
+## is disabled.
+## 
+## @item Octave:neg-dim-as-zero
+## If the @code{Octave:neg-dim-as-zero} warning is enabled, print a warning
+## for expressions like
+## 
+## @example
+## eye (-1)
+## @end example
+## 
+## @noindent
+## By default, the @code{Octave:neg-dim-as-zero} warning is disabled.
+## 
+## @item Octave:num-to-str
+## If the @code{Octave:num-to-str} warning is enable, a warning is
+## printed for implicit conversions of numbers to their ASCII character
+## equivalents when strings are constructed using a mixture of strings and
+## numbers in matrix notation.  For example,
+## 
+## @example
+## @group
+## [ "f", 111, 111 ]
+##      @result{} "foo"
+## @end group
+## @end example
+## elicits a warning if the @code{Octave:num-to-str} warning is
+## enabled.  By default, the @code{Octave:num-to-str} warning is enabled.
+## 
+## @item Octave:precedence-change
+## If the @code{Octave:precedence-change} warning is enabled, Octave
+## will warn about possible changes in the meaning of some code due to
+## changes in precedence for some operators.  Precedence changes have
+## typically been made for Matlab compatibility.  By default, the
+## @code{Octave:precedence-change} warning is enabled.
+## 
+## @item Octave:reload-forces-clear
+## If several functions have been loaded from the same file, Octave must
+## clear all the functions before any one of them can be reloaded.  If
+## the @code{Octave:reload-forces-clear} warning is enabled, Octave will
+## warn you when this happens, and print a list of the additional
+## functions that it is forced to clear.  By default, the
+## @code{Octave:reload-forces-clear} warning is enabled.
+## 
+## @item Octave:resize-on-range-error
+## If the @code{Octave:resize-on-range-error} warning is enabled, print a
+## warning when a matrix is resized by an indexed assignment with
+## indices outside the current bounds.  By default, the
+## @code{Octave:resize-on-range-error} warning is disabled.
+## 
+## @item Octave:str-to-num
+## If the @code{Octave:str-to-num} warning is enabled, a warning is printed
+## for implicit conversions of strings to their numeric ASCII equivalents.
+## For example,
+## @example
+## @group
+## "abc" + 0
+##      @result{} 97 98 99
+## @end group
+## @end example
+## elicits a warning if the @code{Octave:str-to-num} warning is enabled.
+## By default, the @code{Octave:str-to-num} warning is disabled.
+## 
+## @item Octave:string-concat
+## If the @code{Octave:string-concat} warning is enabled, print a
+## warning when concatenating a mixture of double and single quoted strings.
+## By default, the @code{Octave:string-concat} warning is disabled.
+## 
+## @item Octave:undefined-return-values
+## If the @code{Octave:undefined-return-values} warning is disabled,
+## print a warning if a function does not define all the values in
+## the return list which are expected.  By default, the
+## @code{Octave:undefined-return-values} warning is enabled.
+## 
+## @item Octave:variable-switch-label
+## If the @code{Octave:variable-switch-label} warning is enabled, Octave
+## will print a warning if a switch label is not a constant or constant
+## expression.  By default, the @code{Octave:variable-switch-label}
+## warning is disabled.
+## @end table
+
+## FIXME -- we should be able to get formatted help for empty scripts,
+## not just functions.
+function warning_ids ()
+endfunction
diff --git a/scripts/special-matrix/toeplitz.m b/scripts/special-matrix/toeplitz.m
--- a/scripts/special-matrix/toeplitz.m
+++ b/scripts/special-matrix/toeplitz.m
@@ -46,17 +46,17 @@
 ## c(2)  c(1)   c(0)  ... r(n-2)
 ##  .     ,      ,   .      .
 ##  .     ,      ,     .    .
 ##  .     ,      ,       .  .
 ## c(n) c(n-1) c(n-2) ...  c(0)
 ## @end group
 ## @end example
 ## @end ifinfo
-## @seealso{hankel, vander, sylvester_matrix, hilb, invhib}
+## @seealso{hankel, vander, sylvester_matrix, hilb, invhilb}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = toeplitz (c, r)
 
   if (nargin == 1)
     r = c;
diff --git a/scripts/startup/main-rcfile b/scripts/startup/main-rcfile
--- a/scripts/startup/main-rcfile
+++ b/scripts/startup/main-rcfile
@@ -1,11 +1,26 @@
 ## System-wide startup file for Octave.
 ##
 ## This file should contain any commands that should be executed each
 ## time Octave starts for every user at this site.
 
+## Default state for warnings is "on", but most people will want to
+## have these disabled.
+
+warning ("off", "Octave:array-to-scalar");
+warning ("off", "Octave:array-to-vector");
+warning ("off", "Octave:empty-list-elements");
+warning ("off", "Octave:fortran-indexing");
+warning ("off", "Octave:imag-to-real");
+warning ("off", "Octave:missing-semicolon");
+warning ("off", "Octave:neg-dim-as-zero");
+warning ("off", "Octave:resize-on-range-error");
+warning ("off", "Octave:str-to-num");
+warning ("off", "Octave:string-concat");
+warning ("off", "Octave:variable-switch-label");
+
 ## Configure readline using the file inputrc in the Octave startup
 ## directory.
 
 read_readline_init_file (sprintf ("%s%s%s",
 				  octave_config_info ("startupfiledir"),
 				  filesep, "inputrc"));
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -605,17 +605,17 @@ endfunction
 %!error <unknown flag> test("test", 'bogus');  # incorrect args, generates error()
 %!error <garbage' undefined> garbage           # usage on nonexistent function should be
 
 %!error test("test", 'bogus');           # test without pattern
 
 %!test
 %! lastwarn();            # clear last warning just in case
 
-%!warning <warning message> warning('warning message')
+%!warning <warning message> warning('warning message');
 
 %!## test of shared variables
 %!shared a                # create a shared variable
 %!test   a=3;             # assign to a shared variable
 %!test   assert(a,3)      # variable should equal 3    
 %!shared b,c              # replace shared variables
 %!test assert (!exist("a"));   # a no longer exists
 %!test assert (isempty(b));    # variables start off empty
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,135 @@
+2006-05-01  John W. Eaton  <jwe@octave.org>
+
+	* error.h (Vwarning_option): Delete.
+	* variables.cc (looks_like_struct): Remove use from commented code.
+
+	* gripes.cc, gripes.h (gripe_implicit_conversion): New arg, ID.
+	Change all uses.
+
+	* defaults.cc (set_local_site_defaults_file, set_site_defaults_file):
+	Allow filenames to be set from the environment.
+
+	* oct-map.cc (octave_map::resize): No longer const.
+	* ov-struct.h (octave_struct::resize): Deal with it.
+
+	* octave.cc (initialize_error_handlers): Also call
+	set_liboctave_warning_with_id_handler.
+	(execute_startup_files): Check that home_rc is not an empty string.
+	(F__version_info__): Resize vinfo before assigining elements.
+
+	* ov-base.cc (warn_num_to_str, warn_resize_on_range_error):
+	Delete functions.
+	(symbols_of_ov_base): Delete DEFVARS.
+	(Vwarn_num_to_str, Vwarn_resize_on_range_error): Delete variables.
+	(value::convert_to_str): Check state of warning ID
+	Octave:num-to-str instead of using Vwarn_num_to_str.
+	* OPERATORS/op-chm.cc: Likewise.
+	* ov-base.h (Vwarn_num_to_str, Vwarn_resize_on_range_error):
+	Delete decls.
+
+	* ov-list.cc (octave_list::assign): Call warning_with_id instead
+	of warning.
+
+	* parse.y (warn_assign_as_truth_value, warn_associativity_change,
+	warn_function_name_clash, warn_future_time_stamp,
+	warn_missing_semicolon, warn_precedence_change,
+	warn_variable_switch_label, symbols_of_parse):	
+	Delete DEFVARs and functions.
+	(Vwarn_assign_as_truth_value, Vwarn_associativity_change,
+	Vwarn_function_name_clash, Vwarn_future_time_stamp,
+	Vwarn_missing_semicolon, Vwarn_precedence_change,
+	Vwarn_variable_switch_label): Delete variables.
+	* parse.h (Vwarn_future_time_stamp): Delete decl.
+	* parse.y (fold): Check state of warning ID
+	Octave:associativity-change and Octave:precedence-change instead
+	of using Vwarn_associativity_change and Vwarn_precedence_change.
+	(maybe_warn_associativity_change, maybe_warn_missing_semi,
+	maybe_warn_assign_as_truth_value, make_binary_op, make_boolean_op,
+	frob_function): Call warning_with_id instead of warning.	
+	* dynamic-ld.cc (octave_dynamic_loader::do_load): Likewise.
+
+	* ov.cc (warn_fortran_indexing, warn_imag_to_real, symbols_of_ov):
+	Delete DEFVARs and functions.
+	(Vwarn_fortran_indexing, Vwarn_imag_to_real): Delete variables.
+
+	* ov.cc (octave_value::vector_value, octave_value::int_vector_value,
+	octave_value::complex_vector_value): Check state of warning ID
+	Octave:fortran-indexing instead of using Vwarn_fortran_indexing.
+	* ov-cx-sparse.cc (octave_sparse_complex_matrix::double_value,
+	octave_sparse_complex_matrix::complex_value): Likewise.
+	* ov-cx-mat.cc (octave_complex_matrix::matrix_value,
+	octave_complex_matrix::complex_value): Likewise.
+	* ov-re-mat.cc (octave_matrix::complex_value,
+	octave_matrix::double_value): Likewise.
+	* ov-streamoff.cc (octave_streamoff::streamoff_value): Likewise.
+	* ov-re-sparse.cc (octave_sparse_matrix::complex_value,
+	octave_sparse_matrix::double_value): Likewise.
+	* ov-range.cc (octave_range::complex_value,
+	octave_range::double_value): Likewise.
+	* ov-ch-mat.cc (octave_char_matrix::complex_value,
+	octave_char_matrix::double_value): Likewise.
+	* ov-bool-sparse.cc (octave_sparse_bool_matrix::complex_value,
+	octave_sparse_bool_matrix::double_value): Likewise.
+	* ov-bool-mat.cc (octave_bool_matrix::complex_value,
+	octave_bool_matrix::double_value): Likewise.
+
+	* ov-cx-sparse.cc (octave_sparse_complex_matrix::double_value,
+	octave_sparse_complex_matrix::matrix_value,
+	octave_sparse_complex_matrix::sparse_matrix_value): Check state of
+	warning ID Octave:imag-to-real instead of using Vwarn_imag_to_real.
+	* ov-cx-mat.cc (octave_complex_matrix::double_value,
+	octave_complex_matrix::matrix_value,
+	octave_complex_matrix::complex_value,
+	octave_complex_matrix::sparse_matrix_value): Likewise.
+	* ov-complex.cc (octave_complex::double_value,
+	octave_complex::matrix_value, octave_complex::array_value): Likewise.
+
+	* ov.h (Vwarn_fortran_indexing, Vwarn_imag_to_real): Delete decls.
+
+	* pt-mat.cc (warn_empty_list_elements, warn_string_concat):	
+	Delete functions.
+	(symbols_of_pt_mat): Delete DEFVARs.
+	(Vwarn_empty_list_elements, Vwarn_string_concat): Delete variables.
+	(tm_row_const::tm_row_const_rep::eval_warning, tm_const::init,
+	maybe_warn_string_concat): Call warning_with_id instead of warning.
+
+	* ov-str-mat.cc (warn_str_to_num, symbols_of_ov_str_mat):
+	Delete DEFVAR and functions.
+	(Vwarn_str_to_num): Delete variable.
+	(CHAR_MATRIX_CONV): Call warning_with_id instead of warning.
+
+	* utils.cc (warn_neg_dim_as_zero, symbols_of_utils):
+	Delete DEFVAR and functions.
+	(Vwarn_neg_dim_as_zero): Delete variable.
+	(check_dimensions): Call warning_with_id instead of warning.
+
+	* pt-misc.cc (warn_undefined_return_values, symbols_of_pt_misc):
+	Delete DEFVAR and functions.
+	(Vwarn_undefined_return_values): Delete variable.
+	(tree_parameter_list::initialize_undefined_elements):
+	Call warning_with_id instead of warning.
+
+	* dynamic-ld.cc	(warn_reload_forces_clear, symbols_of_dynamic_ld):
+	Delete DEFVAR and functions.
+	(Vwarn_reload_forces_clear): Delete variable.
+	(do_clear_function, octave_dynamic_loader::do_load):	
+	Call warning_with_id instead of warning.
+	* error.cc (warning_enabled): Now extern.
+	(Fwarning): If specific id is not found, return state of "all".
+
+	* error.h: Provide decl.
+
+	* gripes.cc (warn_divide_by_zero, symbols_of_gripes):
+	Delete DEFVAR and functions.
+	(gripe_divide_by_zero): Check whether warning is enabled, then
+	call warning_with_id instead of warning.
+	(Vwarn_divide_by_zero): Delete variable.
+
 2006-04-27  John W. Eaton  <jwe@octave.org>
 
 	* variables.cc (Fexist): Fix doc string.
 
 	* help.cc (simple_help): No need to handle built-in constants now.
 	* variables.cc (do_who): Likewise.
 	(symbol_exist): Likewise.
 	(link_to_builtin_or_function): Likewise.
diff --git a/src/OPERATORS/op-chm.cc b/src/OPERATORS/op-chm.cc
--- a/src/OPERATORS/op-chm.cc
+++ b/src/OPERATORS/op-chm.cc
@@ -47,51 +47,51 @@ DEFUNOP (transpose, char_matrix)
 
 DEFNDCATOP_FN (chm_chm, char_matrix, char_matrix, char_array, char_array, 
 	       concat)
 
 DEFCATOP (chm_s, char_matrix, scalar)
 {
   CAST_BINOP_ARGS (octave_char_matrix&, const octave_scalar&);
 
-  if (Vwarn_num_to_str)
-    gripe_implicit_conversion (v2.type_name (), v1.type_name ());
+  gripe_implicit_conversion ("Octave:num-to-str",
+			     v2.type_name (), v1.type_name ());
 
   return octave_value (v1.char_array_value (). concat(v2.array_value (),
 			       ra_idx));
 }
 
 DEFCATOP (chm_m, char_matrix, matrix)
 {
   CAST_BINOP_ARGS (octave_char_matrix&, const octave_matrix&);
 
-  if (Vwarn_num_to_str)
-    gripe_implicit_conversion (v2.type_name (), v1.type_name ());
+  gripe_implicit_conversion ("Octave:num-to-str",
+			     v2.type_name (), v1.type_name ());
 
   return octave_value (v1.char_array_value (). concat (v2.array_value (),
 			       ra_idx));
 }
 
 DEFCATOP (s_chm, scalar, char_matrix)
 {
   CAST_BINOP_ARGS (octave_scalar&, const octave_char_matrix&);
 
-  if (Vwarn_num_to_str)
-    gripe_implicit_conversion (v1.type_name (), v2.type_name ());
+  gripe_implicit_conversion ("Octave:num-to-str",
+			     v1.type_name (), v2.type_name ());
 
   return octave_value (v1.array_value (). concat (v2.char_array_value (),
 			       ra_idx));
 }
 
 DEFCATOP (m_chm, matrix, char_matrix)
 {
   CAST_BINOP_ARGS (octave_matrix&, const octave_char_matrix&);
 
-  if (Vwarn_num_to_str)
-    gripe_implicit_conversion (v1.type_name (), v2.type_name ());
+  gripe_implicit_conversion ("Octave:num-to-str",
+			     v1.type_name (), v2.type_name ());
 
   return octave_value (v1.array_value (). concat (v2.char_array_value (),
 			       ra_idx));
 }
 
 void
 install_chm_ops (void)
 {
diff --git a/src/defaults.cc b/src/defaults.cc
--- a/src/defaults.cc
+++ b/src/defaults.cc
@@ -342,25 +342,39 @@ set_default_editor (void)
 
   if (! env_editor.empty ())
     Veditor = env_editor;
 }
 
 static void
 set_local_site_defaults_file (void)
 {
-  Vlocal_site_defaults_file = subst_octave_home (OCTAVE_LOCALSTARTUPFILEDIR);
-  Vlocal_site_defaults_file.append ("/octaverc");
+  std::string lsf = octave_env::getenv ("OCTAVE_LOCAL_SITE_INITFILE");
+
+  if (lsf.empty ())
+    {
+      Vlocal_site_defaults_file = subst_octave_home (OCTAVE_LOCALSTARTUPFILEDIR);
+      Vlocal_site_defaults_file.append ("/octaverc");
+    }
+  else
+    Vlocal_site_defaults_file = lsf;
 }
 
 static void
 set_site_defaults_file (void)
 {
-  Vsite_defaults_file = subst_octave_home (OCTAVE_STARTUPFILEDIR);
-  Vsite_defaults_file.append ("/octaverc");
+  std::string sf = octave_env::getenv ("OCTAVE_SITE_INITFILE");
+
+  if (sf.empty ())
+    {
+      Vsite_defaults_file = subst_octave_home (OCTAVE_STARTUPFILEDIR);
+      Vsite_defaults_file.append ("/octaverc");
+    }
+  else
+    Vsite_defaults_file = sf;
 }
 
 std::string
 maybe_add_default_load_path (const std::string& pathstring)
 {
   std::string retval;
 
   if (! pathstring.empty ())
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -34,20 +34,16 @@ 02110-1301, USA.
 
 #include "defun.h"
 #include "dynamic-ld.h"
 #include "parse.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
-// TRUE means we print a warning if reloading a .oct file forces other
-// functions to be cleared.
-static bool Vwarn_reload_forces_clear;
-
 class
 octave_shlib_list
 {
 public:
 
   static void append (const octave_shlib& shl);
 
   static void remove (octave_shlib& shl);
@@ -193,18 +189,17 @@ octave_dynamic_loader::instance_ok (void
     }
 
   return retval;
 }
 
 static
 void do_clear_function (const std::string& fcn_name)
 {
-  if (Vwarn_reload_forces_clear)
-    warning ("  %s", fcn_name.c_str ());
+  warning_with_id ("Octave:reload-forces-clear", "  %s", fcn_name.c_str ());
 
   curr_sym_tab->clear (fcn_name);
 
   if (curr_sym_tab != top_level_sym_tab)
     top_level_sym_tab->clear (fcn_name);
 
   fbi_sym_tab->clear (fcn_name);
 }
@@ -227,33 +222,34 @@ octave_dynamic_loader::do_load (const st
     = octave_shlib_list::search (fcn_name, oct_file, mangle_name);
 
   if (! error_state)
     {
       if (function && oct_file.is_out_of_date ())
 	{
 	  int n = oct_file.number_of_functions_loaded ();
 
-	  if (n > 0 && Vwarn_reload_forces_clear)
-	    warning ("reloading %s clears the following functions:",
-		     oct_file.file_name().c_str ());
+	  if (n > 0)
+	    warning_with_id ("Octave:reload-forces-clear",
+			     "reloading %s clears the following functions:",
+			     oct_file.file_name().c_str ());
 
 	  oct_file.close (do_clear_function);
 
 	  function = 0;
 	}
 
       if (! function)
 	{
 	  std::string oct_file_name
 	    = file_name.empty () ? oct_file_in_path (fcn_name) : file_name;
 
 	  if (! oct_file_name.empty ())
 	    {
-	      oct_file.open (oct_file_name, Vwarn_future_time_stamp);
+	      oct_file.open (oct_file_name);
 
 	      if (! error_state)
 		{
 		  if (oct_file)
 		    {
 		      octave_shlib_list::append (oct_file);
 
 		      function = oct_file.search (fcn_name, mangle_name);
@@ -326,34 +322,13 @@ octave_dynamic_loader::mangle_name (cons
   std::string retval ("FS");
 #endif
   retval.append (name);
   retval.append ("_");
   retval.append (STRINGIFY (CXX_ABI));
   return retval;
 }
 
-static int
-warn_reload_forces_clear (void)
-{
-  Vwarn_reload_forces_clear = check_preference ("warn_reload_forces_clear");
-
-  return 0;
-}
-
-void
-symbols_of_dynamic_ld (void)
-{
-  DEFVAR (warn_reload_forces_clear, true, warn_reload_forces_clear,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} warn_reload_forces_clear\n\
-If several functions have been loaded from the same file, Octave must\n\
-clear all the functions before any one of them can be reloaded.  If\n\
-@code{warn_reload_forces_clear}, Octave will warn you when this happens,\n\
-and print a list of the additional functions that it is forced to clear.\n\
-@end defvr");
-}
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -445,17 +445,17 @@ check_state (const std::string& state)
     return 2;
   else
     return -1;
 }
 
 // For given warning ID, return 0 if warnings are disabled, 1 if
 // enabled, and 2 if this ID should be an error instead of a warning.
 
-static int
+int
 warning_enabled (const std::string& id)
 {
   int retval = 0;
 
   int all_state = -1;
   int id_state = -1;
 
   octave_idx_type nel = warning_options.numel ();
@@ -487,17 +487,16 @@ warning_enabled (const std::string& id)
 
 	      if (id_state >= 0)
 		id_found = true;
 	    }
 
 	  if (all_found && id_found)
 	    break;
 	}
-
     }
 
   if (all_state == -1)
     panic_impossible ();
 
   if (all_state == 0)
     {
       if (id_state >= 0)
@@ -720,21 +719,21 @@ handle_message (error_fun f, const char 
     }
 
   return retval;
 }
 
 DEFUN (error, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} error (@var{template}, @dots{})\n\
-The @code{error} function formats the optional arguments under the\n\
-control of the template string @var{template} using the same rules as\n\
-the @code{printf} family of functions (@pxref{Formatted Output}).\n\
-The resulting message is prefixed by the string @samp{error: } and\n\
-printed on the @code{stderr} stream.\n\
+Format the optional arguments under the control of the template string\n\
+@var{template} using the same rules as the @code{printf} family of\n\
+functions (@pxref{Formatted Output}) and print the resulting message\n\
+on the @code{stderr} stream.  The message is prefixed by the character\n\
+string @samp{error: }.\n\
 \n\
 Calling @code{error} also sets Octave's internal error state such that\n\
 control will return to the top level without evaluating any more\n\
 commands.  This is useful for aborting from functions or scripts.\n\
 \n\
 If the error message does not end with a new line character, Octave will\n\
 print a traceback of all the function calls leading to the error.  For\n\
 example, given the following function definitions:\n\
@@ -783,22 +782,40 @@ error: nargin != 1\n\
 
   octave_value_list retval;
   handle_message (error_with_id, "", "unspecified error", args);
   return retval;
 }
 
 DEFCMD (warning, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} warning (@var{msg})\n\
-Print a warning message @var{msg} prefixed by the string @samp{warning: }.  \n\
-After printing the warning message, Octave will continue to execute\n\
-commands.  You should use this function when you want to notify the user\n\
+@deftypefn {Built-in Function} {} warning (@var{template}, @dots{})\n\
+@deftypefnx {Built-in Function} {} warning (@var{id}, @var{template})\n\
+Format the optional arguments under the control of the template string\n\
+@var{template} using the same rules as the @code{printf} family of\n\
+functions (@pxref{Formatted Output}) and print the resulting message\n\
+on the @code{stderr} stream.  The message is prefixed by the character\n\
+string @samp{warning: }.\n\
+You should use this function when you want to notify the user\n\
 of an unusual condition, but only when it makes sense for your program\n\
 to go on.\n\
+\n\
+The optional message identifier allows users to enable or disable\n\
+warnings tagged by @var{id}.  The special identifier @samp{\"all\"} may\n\
+be used to set the state of all warnings.\n\
+\n\
+@deftypefnx {Built-in Function} {} warning (\"on\", @var{id})\n\
+@deftypefnx {Built-in Function} {} warning (\"off\", @var{id})\n\
+@deftypefnx {Built-in Function} {} warning (\"error\", @var{id})\n\
+@deftypefnx {Built-in Function} {} warning (\"query\", @var{id})\n\
+Set or query the the state of a particular warning using the identifier\n\
+@var{id}.  If the identifier is omitted, a value of @samp{\"all\"} is\n\
+assumed.  If you set the state of a warning to @samp{\"error\"}, the\n\
+warning named by @var{id} is handled as if it were an error instead.\n\
+@seealso{warning_ids}.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
   int argc = nargin + 1;
 
   bool done = false;
@@ -956,27 +973,40 @@ to go on.\n\
 		      if (ident(i).string_value () == arg2)
 			{
 			  val = state(i).string_value ();
 			  found = true;
 			  break;
 			}
 		    }
 
+		  if (! found)
+		    {
+		      for (octave_idx_type i = 0; i < nel; i++)
+			{
+			  if (ident(i).string_value () == "all")
+			    {
+			      val = state(i).string_value ();
+			      found = true;
+			      break;
+			    }
+			}
+		    }
+
 		  if (found)
 		    {
 		      Octave_map tmp;
 
 		      tmp.assign ("identifier", arg2);
 		      tmp.assign ("state", val);
 
 		      retval = tmp;
 		    }
 		  else
-		    error ("warning: invalid warning tag `%s'", arg2.c_str ());
+		    error ("warning: unable to find default warning state!");
 		}
 
 	      done = true;
 	    }
 	}
     }
   else if (argc == 1)
     {
diff --git a/src/error.h b/src/error.h
--- a/src/error.h
+++ b/src/error.h
@@ -27,16 +27,18 @@ 02110-1301, USA.
 #include <string>
 
 #define panic_impossible() \
   panic ("impossible state reached in file `%s' at line %d", \
 	 __FILE__, __LINE__)
 
 extern void reset_error_handler (void);
 
+extern int warning_enabled (const std::string& id);
+
 extern void message (const char *name, const char *fmt, ...);
 extern void usage (const char *fmt, ...);
 extern void warning (const char *fmt, ...);
 extern void error (const char *fmt, ...);
 extern void parse_error (const char *fmt, ...);
 
 extern void
 message_with_id (const char *id, const char *name, const char *fmt, ...);
@@ -70,19 +72,15 @@ extern int warning_state;
 extern int buffer_error_messages;
 
 // TRUE means error messages are turned off.
 extern bool discard_error_messages;
 
 // TRUE means warning messages are turned off.
 extern bool discard_warning_messages;
 
-// The current warning state.  Valid values are "on", "off",
-// "backtrace", or "debug".
-extern std::string Vwarning_option;
-
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/gripes.cc b/src/gripes.cc
--- a/src/gripes.cc
+++ b/src/gripes.cc
@@ -26,19 +26,16 @@ 02110-1301, USA.
 #endif
 
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-// Allow divide by zero errors to be suppressed.
-static bool Vwarn_divide_by_zero;
-
 void
 gripe_not_supported (const char *fcn)
 {
   error ("%s: not supported on this system", fcn);
 }
 
 void
 gripe_string_invalid (void)
@@ -162,51 +159,33 @@ gripe_wrong_type_arg_for_unary_op (const
 void
 gripe_wrong_type_arg_for_binary_op (const octave_value& op)
 {
   std::string type = op.type_name ();
   error ("invalid operand `%s' for binary operator", type.c_str ());
 }
 
 void
-gripe_implicit_conversion (const char *from, const char *to)
+gripe_implicit_conversion (const char *id, const char *from, const char *to)
 {
-  warning ("implicit conversion from %s to %s", from, to);
+  warning_with_id (id, "implicit conversion from %s to %s", from, to);
 }
 
 void
-gripe_implicit_conversion (const std::string& from, const std::string& to)
+gripe_implicit_conversion (const std::string& id,
+			   const std::string& from, const std::string& to)
 {
-  warning ("implicit conversion from %s to %s", from.c_str (), to.c_str ());
+  warning_with_id (id.c_str (),
+		   "implicit conversion from %s to %s",
+		   from.c_str (), to.c_str ());
 }
 
 void
 gripe_divide_by_zero (void)
 {
-  if (Vwarn_divide_by_zero)
-    warning ("division by zero");
-}
-
-static int
-warn_divide_by_zero (void)
-{
-  Vwarn_divide_by_zero = check_preference ("warn_divide_by_zero");
-
-  return 0;
-}
-
-void
-symbols_of_gripes (void)
-{
-  DEFVAR (warn_divide_by_zero, true, warn_divide_by_zero,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} warn_divide_by_zero\n\
-If the value of @code{warn_divide_by_zero} is nonzero, a warning\n\
-is issued when Octave encounters a division by zero.  If the value is\n\
-0, the warning is omitted.  The default value is 1.\n\
-@end defvr");
+  warning_with_id ("Octave:divide-by-zero", "division by zero");
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/gripes.h b/src/gripes.h
--- a/src/gripes.h
+++ b/src/gripes.h
@@ -89,20 +89,21 @@ gripe_wrong_type_arg (const char *name, 
 
 extern void
 gripe_wrong_type_arg_for_unary_op (const octave_value& op);
 
 extern void
 gripe_wrong_type_arg_for_binary_op (const octave_value& op);
 
 extern void
-gripe_implicit_conversion (const char *from, const char *to);
+gripe_implicit_conversion (const char *id, const char *from, const char *to);
 
 extern void
-gripe_implicit_conversion (const std::string& from, const std::string& to);
+gripe_implicit_conversion (const std::string& id, const std::string& from,
+			   const std::string& to);
 
 extern void
 gripe_divide_by_zero (void);
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/src/oct-map.cc b/src/oct-map.cc
--- a/src/oct-map.cc
+++ b/src/oct-map.cc
@@ -135,40 +135,35 @@ Octave_map::numel (void) const
     {
       Cell tmp = contents (begin ());
       retval = tmp.numel ();
     }
 
   return retval;
 }
 
-Octave_map 
-Octave_map::resize (const dim_vector& dv, bool fill) const
+void
+Octave_map::resize (const dim_vector& dv, bool fill)
 {
-  Octave_map retval;
-
   if (dv != dims ())
     {
       for (const_iterator p = begin (); p != end (); p++)
 	{
 	  Cell tmp = contents(p);
+
 	  if (fill)
 	    tmp.resize(dv, Cell::resize_fill_value ());
 	  else
 	    tmp.resize(dv);
-	  retval.assign (key(p), tmp);
+
+	  dimensions = dv;
+
+	  assign (key(p), tmp);
 	}
-      
-      retval.dimensions = dv;
     }
-  else
-    retval = *this;
-
-
-  return retval;
 }
 
 Octave_map
 Octave_map::concat (const Octave_map& rb, const Array<octave_idx_type>& ra_idx)
 {
   Octave_map retval;
 
   if (length() == rb.length())
diff --git a/src/oct-map.h b/src/oct-map.h
--- a/src/oct-map.h
+++ b/src/oct-map.h
@@ -122,17 +122,17 @@ Octave_map
   dim_vector dims (void) const { return dimensions; }
 
   int ndims (void) const { return dimensions.length (); }
 
   Octave_map transpose (void) const;
 
   Octave_map reshape (const dim_vector& new_dims) const;
 
-  Octave_map resize (const dim_vector& dv, bool fill = false) const;
+  void resize (const dim_vector& dv, bool fill = false);
 
   octave_idx_type numel (void) const;
 
   Octave_map concat (const Octave_map& rb, const Array<octave_idx_type>& ra_idx);
 
   Octave_map& maybe_delete_elements (const octave_value_list& idx);
 
   Octave_map& assign (const octave_value_list& idx, const Octave_map& rhs);
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -219,22 +219,36 @@ DEFUN (__version_info__, args, ,
   octave_value retval;
 
   static Octave_map vinfo;
 
   int nargin = args.length ();
 
   if (nargin == 4)
     {
-      octave_value idx (vinfo.numel () + 1);
+      if (vinfo.empty ())
+	{
+	  vinfo.assign ("Name", args (0));
+	  vinfo.assign ("Version", args (1));
+	  vinfo.assign ("Release", args (2));
+	  vinfo.assign ("Date", args (3));
+	}
+      else
+	{
+	  octave_idx_type n = vinfo.numel () + 1;
 
-      vinfo.assign (idx, "Name", Cell (octave_value (args (0))));
-      vinfo.assign (idx, "Version", Cell (octave_value (args (1))));
-      vinfo.assign (idx, "Release", Cell (octave_value (args (2))));
-      vinfo.assign (idx, "Date", Cell (octave_value (args (3))));
+	  vinfo.resize (dim_vector (n, 1));
+
+	  octave_value idx (n);
+
+	  vinfo.assign (idx, "Name", Cell (octave_value (args (0))));
+	  vinfo.assign (idx, "Version", Cell (octave_value (args (1))));
+	  vinfo.assign (idx, "Release", Cell (octave_value (args (2))));
+	  vinfo.assign (idx, "Date", Cell (octave_value (args (3))));
+	}
     }
   else if (nargin == 0)
     retval = vinfo;
   else
     print_usage ("__version_info__");
 
   return retval;
 }
@@ -291,17 +305,17 @@ execute_startup_files (void)
 	initfile = ".octaverc";
 
       std::string home_dir = octave_env::get_home_directory ();
 
       std::string home_rc = octave_env::make_absolute (initfile, home_dir);
 
       std::string local_rc;
 
-      if (! home_dir.empty ())
+      if (! home_rc.empty ())
 	{
 	  parse_and_execute (home_rc, verbose);
 
 	  // Names alone are not enough.
 
 	  file_stat fs_home_rc (home_rc);
 
 	  if (fs_home_rc)
@@ -449,16 +463,17 @@ print_version_and_exit (void)
   exit (0);
 }
 
 static void
 initialize_error_handlers ()
 {
   set_liboctave_error_handler (error);
   set_liboctave_warning_handler (warning);
+  set_liboctave_warning_with_id_handler (warning_with_id);
 }
 
 // What happens on --traditional.
 
 static void
 maximum_braindamage (void)
 {
   persist = true;
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -61,24 +61,16 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
 
 // If TRUE, print the name along with the value.
 static bool Vprint_answer_id_name;
 
 // If TRUE, turn off printing of results in functions (as if a
 // semicolon has been appended to each statement).
 static bool Vsilent_functions;
 
-// Should we print a warning when converting `[97, 98, 99, "123"]'
-// to a character string?
-bool Vwarn_num_to_str;
-
-// If TRUE, print a warning when a matrix is resized by an indexed
-// assignment with indices outside the current bounds.
-bool Vwarn_resize_on_range_error;
-
 octave_value
 octave_base_value::squeeze (void) const
 {
   std::string nm = type_name ();
   error ("squeeze: invalid operation for %s type", nm.c_str ());
   return octave_value ();
 }
 
@@ -270,18 +262,19 @@ octave_base_value::any (int) const
   return 0.0;
 }
 
 octave_value
 octave_base_value::convert_to_str (bool pad, bool force, char type) const
 {
   octave_value retval = convert_to_str_internal (pad, force, type);
 
-  if (! force && is_numeric_type () && Vwarn_num_to_str)
-    gripe_implicit_conversion (type_name (), retval.type_name ());
+  if (! force && is_numeric_type ())
+    gripe_implicit_conversion ("Octave:num-to-str",
+			       type_name (), retval.type_name ());
 
   return retval;
 }
 
 octave_value
 octave_base_value::convert_to_str_internal (bool, bool, char) const
 {
   gripe_wrong_type_arg ("octave_base_value::convert_to_str_internal ()",
@@ -1100,35 +1093,16 @@ print_answer_id_name (void)
 static int
 silent_functions (void)
 {
   Vsilent_functions = check_preference ("silent_functions");
 
   return 0;
 }
 
-static int
-warn_num_to_str (void)
-{
-  Vwarn_num_to_str = check_preference ("warn_num_to_str");
-
-  return 0;
-}
-
-static int
-warn_resize_on_range_error (void)
-{
-  Vwarn_resize_on_range_error
-    = check_preference ("warn_resize_on_range_error");
-
-  liboctave_wrore_flag = Vwarn_resize_on_range_error;
-
-  return 0;
-}
-
 void
 symbols_of_ov_base (void)
 {
   DEFVAR (print_answer_id_name, true, print_answer_id_name,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} print_answer_id_name\n\
 If the value of @code{print_answer_id_name} is nonzero, variable\n\
 names are printed along with the result.  Otherwise, only the result\n\
@@ -1150,41 +1124,15 @@ function f ()\n\
   2 + 2\n\
 endfunction\n\
 @end example\n\
 \n\
 @noindent\n\
 is executed, Octave will either print @samp{ans = 4} or nothing\n\
 depending on the value of @code{silent_functions}.\n\
 @end defvr");
-
-  DEFVAR (warn_num_to_str, true, warn_num_to_str,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} warn_num_to_str\n\
-If the value of @code{warn_num_to_str} is nonzero, a warning is\n\
-printed for implicit conversions of numbers to their ASCII character\n\
-equivalents when strings are constructed using a mixture of strings and\n\
-numbers in matrix notation.  For example,\n\
-\n\
-@example\n\
-@group\n\
-[ \"f\", 111, 111 ]\n\
-     @result{} \"foo\"\n\
-@end group\n\
-@end example\n\
-elicits a warning if @code{warn_num_to_str} is nonzero.  The default\n\
-value is 1.\n\
-@end defvr");
-
-  DEFVAR (warn_resize_on_range_error, false, warn_resize_on_range_error,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} warn_resize_on_range_error\n\
-If the value of @code{warn_resize_on_range_error} is nonzero, print a\n\
-warning when a matrix is resized by an indexed assignment with\n\
-indices outside the current bounds.  The default value is 0.\n\
-@end defvr");
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -86,24 +86,16 @@ class tree_walker;
   const std::string t::c_name (c); \
   void t::register_type (void) \
     { \
       t_id = octave_value_typeinfo::register_type (t::t_name, \
 						   t::c_name, \
 						   octave_value (new t ())); \
     }
 
-// Should we print a warning when converting `[97, 98, 99, "123"]'
-// to a character string?
-extern bool Vwarn_num_to_str;
-
-// If TRUE, print a warning when a matrix is resized by an indexed
-// assignment with indices outside the current bounds.
-extern bool Vwarn_resize_on_range_error;
-
 // A base value type, so that derived types only have to redefine what
 // they need (if they are derived from octave_base_value instead of
 // octave_value).
 
 class
 octave_base_value
 {
 public:
diff --git a/src/ov-bool-mat.cc b/src/ov-bool-mat.cc
--- a/src/ov-bool-mat.cc
+++ b/src/ov-bool-mat.cc
@@ -94,44 +94,40 @@ octave_bool_matrix::valid_as_scalar_inde
   return false;
 }
 
 double
 octave_bool_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
-  // FIXME -- maybe this should be a function, valid_as_scalar()
   if (rows () > 0 && columns () > 0)
     {
-      // FIXME -- is warn_fortran_indexing the right variable here?
-      if (Vwarn_fortran_indexing)
-	gripe_implicit_conversion ("bool matrix", "real scalar");
+      gripe_implicit_conversion ("Octave:array-as-scalar",
+				 "bool matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("bool matrix", "real scalar");
 
   return retval;
 }
 
 Complex
 octave_bool_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  // FIXME -- maybe this should be a function, valid_as_scalar()
   if (rows () > 0 && columns () > 0)
     {
-      // FIXME -- is warn_fortran_indexing the right variable here?
-      if (Vwarn_fortran_indexing)
-	gripe_implicit_conversion ("bool matrix", "complex scalar");
+      gripe_implicit_conversion ("Octave:array-as-scalar",
+				 "bool matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("bool matrix", "complex scalar");
 
   return retval;
 }
diff --git a/src/ov-bool-sparse.cc b/src/ov-bool-sparse.cc
--- a/src/ov-bool-sparse.cc
+++ b/src/ov-bool-sparse.cc
@@ -95,41 +95,38 @@ octave_sparse_bool_matrix::valid_as_scal
 
 double
 octave_sparse_bool_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (numel () > 0)
     {
-      // FIXME -- is warn_fortran_indexing the right variable here?
-      if (Vwarn_fortran_indexing)
-	gripe_implicit_conversion ("bool sparse matrix", "real scalar");
+      gripe_implicit_conversion ("Octave:array-as-scalar",
+				 "bool sparse matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("bool sparse matrix", "real scalar");
 
   return retval;
 }
 
 Complex
 octave_sparse_bool_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  // FIXME -- maybe this should be a function, valid_as_scalar()
   if (rows () > 0 && columns () > 0)
     {
-      // FIXME -- is warn_fortran_indexing the right variable here?
-      if (Vwarn_fortran_indexing)
-	gripe_implicit_conversion ("bool sparse matrix", "complex scalar");
+      gripe_implicit_conversion ("Octave:array-as-scalar",
+				 "bool sparse matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("bool sparse matrix", "complex scalar");
 
   return retval;
 }
diff --git a/src/ov-ch-mat.cc b/src/ov-ch-mat.cc
--- a/src/ov-ch-mat.cc
+++ b/src/ov-ch-mat.cc
@@ -52,44 +52,40 @@ octave_char_matrix::valid_as_scalar_inde
   return retval;
 }
 
 double
 octave_char_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
-  // FIXME -- maybe this should be a function, valid_as_scalar()
   if (rows () > 0 && columns () > 0)
     {
-      // FIXME -- is warn_fortran_indexing the right variable here?
-      if (Vwarn_fortran_indexing)
-	gripe_implicit_conversion ("character matrix", "real scalar");
+      gripe_implicit_conversion ("Octave:array-as-scalar",
+				 "character matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("character matrix", "real scalar");
 
   return retval;
 }
 
 Complex
 octave_char_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  // FIXME -- maybe this should be a function, valid_as_scalar()
   if (rows () > 0 && columns () > 0)
     {
-      // FIXME -- is warn_fortran_indexing the right variable here?
-      if (Vwarn_fortran_indexing)
-	gripe_implicit_conversion ("character matrix", "complex scalar");
+      gripe_implicit_conversion ("Octave:array-as-scalar",
+				 "character matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("character matrix", "complex scalar");
 
   return retval;
 }
diff --git a/src/ov-complex.cc b/src/ov-complex.cc
--- a/src/ov-complex.cc
+++ b/src/ov-complex.cc
@@ -91,44 +91,47 @@ octave_complex::do_index_op (const octav
   return retval;
 }
 
 double
 octave_complex::double_value (bool force_conversion) const
 {
   double retval = lo_ieee_nan_value ();
 
-  if (! force_conversion && Vwarn_imag_to_real)
-    gripe_implicit_conversion ("complex scalar", "real scalar");
+  if (! force_conversion)
+    gripe_implicit_conversion ("Octave:imag-to-real",
+			       "complex scalar", "real scalar");
 
   retval = std::real (scalar);
 
   return retval;
 }
 
 Matrix
 octave_complex::matrix_value (bool force_conversion) const
 {
   Matrix retval;
 
-  if (! force_conversion && Vwarn_imag_to_real)
-    gripe_implicit_conversion ("complex scalar", "real matrix");
+  if (! force_conversion)
+    gripe_implicit_conversion ("Octave:imag-to-real",
+			       "complex scalar", "real matrix");
 
   retval = Matrix (1, 1, std::real (scalar));
 
   return retval;
 }
 
 NDArray
 octave_complex::array_value (bool force_conversion) const
 {
   NDArray retval;
 
-  if (! force_conversion && Vwarn_imag_to_real)
-    gripe_implicit_conversion ("complex scalar", "real matrix");
+  if (! force_conversion)
+    gripe_implicit_conversion ("Octave:imag-to-real",
+			       "complex scalar", "real matrix");
 
   retval = NDArray (dim_vector (1, 1), std::real (scalar));
 
   return retval;
 }
 
 Complex
 octave_complex::complex_value (bool) const
diff --git a/src/ov-cx-mat.cc b/src/ov-cx-mat.cc
--- a/src/ov-cx-mat.cc
+++ b/src/ov-cx-mat.cc
@@ -118,60 +118,58 @@ octave_complex_matrix::valid_as_scalar_i
   return false;
 }
 
 double
 octave_complex_matrix::double_value (bool force_conversion) const
 {
   double retval = lo_ieee_nan_value ();
 
-  if (! force_conversion && Vwarn_imag_to_real)
-    gripe_implicit_conversion ("complex matrix", "real scalar");
+  if (! force_conversion)
+    gripe_implicit_conversion ("Octave:imag-to-real",
+			       "complex matrix", "real scalar");
 
-  // FIXME -- maybe this should be a function, valid_as_scalar()
   if (rows () > 0 && columns () > 0)
     {
-      // FIXME -- is warn_fortran_indexing the right variable here?
-      if (Vwarn_fortran_indexing)
-	gripe_implicit_conversion ("complex matrix", "real scalar");
+      gripe_implicit_conversion ("Octave:array-as-scalar",
+				 "complex matrix", "real scalar");
 
       retval = std::real (matrix (0, 0));
     }
   else
     gripe_invalid_conversion ("complex matrix", "real scalar");
 
   return retval;
 }
 
 Matrix
 octave_complex_matrix::matrix_value (bool force_conversion) const
 {
   Matrix retval;
 
-  if (! force_conversion && Vwarn_imag_to_real)
-    gripe_implicit_conversion ("complex matrix", "real matrix");
+  if (! force_conversion)
+    gripe_implicit_conversion ("Octave:imag-to-real",
+			       "complex matrix", "real matrix");
 
   retval = ::real (matrix.matrix_value ());
 
   return retval;
 }
 
 Complex
 octave_complex_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  // FIXME -- maybe this should be a function, valid_as_scalar()
   if (rows () > 0 && columns () > 0)
     {
-      // FIXME -- is warn_fortran_indexing the right variable here?
-      if (Vwarn_fortran_indexing)
-	gripe_implicit_conversion ("complex matrix", "complex scalar");
+      gripe_implicit_conversion ("Octave:array-as-scalar",
+				 "complex matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("complex matrix", "complex scalar");
 
   return retval;
 }
@@ -182,18 +180,19 @@ octave_complex_matrix::complex_matrix_va
   return matrix.matrix_value ();
 }
 
 SparseMatrix
 octave_complex_matrix::sparse_matrix_value (bool force_conversion) const
 {
   SparseMatrix retval;
 
-  if (! force_conversion && Vwarn_imag_to_real)
-    gripe_implicit_conversion ("complex matrix", "real matrix");
+  if (! force_conversion)
+    gripe_implicit_conversion ("Octave:imag-to-real",
+			       "complex matrix", "real matrix");
 
   retval = SparseMatrix (::real (matrix.matrix_value ()));
 
   return retval;
 }
 
 SparseComplexMatrix
 octave_complex_matrix::sparse_complex_matrix_value (bool) const
diff --git a/src/ov-cx-sparse.cc b/src/ov-cx-sparse.cc
--- a/src/ov-cx-sparse.cc
+++ b/src/ov-cx-sparse.cc
@@ -114,60 +114,60 @@ octave_sparse_complex_matrix::valid_as_s
   return false;
 }
 
 double
 octave_sparse_complex_matrix::double_value (bool force_conversion) const
 {
   double retval = lo_ieee_nan_value ();
 
-  if (! force_conversion && Vwarn_imag_to_real)
-    gripe_implicit_conversion ("complex sparse matrix", "real scalar");
+  if (! force_conversion)
+    gripe_implicit_conversion ("Octave:imag-to-real",
+			       "complex sparse matrix", "real scalar");
 
   // FIXME -- maybe this should be a function, valid_as_scalar()
   if (numel () > 0)
     {
-      // FIXME -- is warn_fortran_indexing the right variable here?
-      if (Vwarn_fortran_indexing)
-	gripe_implicit_conversion ("complex sparse matrix", "real scalar");
+      gripe_implicit_conversion ("Octave:array-as-scalar",
+				 "complex sparse matrix", "real scalar");
 
       retval = std::real (matrix (0, 0));
     }
   else
     gripe_invalid_conversion ("complex sparse matrix", "real scalar");
 
   return retval;
 }
 
 Matrix
 octave_sparse_complex_matrix::matrix_value (bool force_conversion) const
 {
   Matrix retval;
 
-  if (! force_conversion && Vwarn_imag_to_real)
-    gripe_implicit_conversion ("complex sparse matrix", "real matrix");
+  if (! force_conversion)
+    gripe_implicit_conversion ("Octave:imag-to-real",
+			       "complex sparse matrix", "real matrix");
 
   retval = ::real (matrix.matrix_value ());
 
   return retval;
 }
 
 Complex
 octave_sparse_complex_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   // FIXME -- maybe this should be a function, valid_as_scalar()
   if (numel () > 0)
     {
-      // FIXME -- is warn_fortran_indexing the right variable here?
-      if (Vwarn_fortran_indexing)
-	gripe_implicit_conversion ("complex sparse matrix", "real scalar");
+      gripe_implicit_conversion ("Octave:array-as-scalar",
+				 "complex sparse matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("complex sparse matrix", "real scalar");
 
   return retval;
 }
@@ -184,18 +184,19 @@ octave_sparse_complex_matrix::complex_ar
   return ComplexNDArray (matrix.matrix_value ());
 }
 
 SparseMatrix
 octave_sparse_complex_matrix::sparse_matrix_value (bool force_conversion) const
 {
   SparseMatrix retval;
 
-  if (! force_conversion && Vwarn_imag_to_real)
-    gripe_implicit_conversion ("complex sparse matrix", 
+  if (! force_conversion)
+    gripe_implicit_conversion ("Octave:imag-to-real",
+			       "complex sparse matrix", 
 			       "real sparse matrix");
 
   retval = ::real (matrix);
 
   return retval;
 }
 
 bool 
diff --git a/src/ov-intx.h b/src/ov-intx.h
--- a/src/ov-intx.h
+++ b/src/ov-intx.h
@@ -84,19 +84,18 @@ public:
 
   double
   double_value (bool = false) const
     {
       double retval = lo_ieee_nan_value ();
 
       if (numel () > 0)
 	{
-	  // FIXME -- is warn_fortran_indexing the right variable here?
-	  if (Vwarn_fortran_indexing)
-	    gripe_implicit_conversion (type_name (), "real scalar");
+	  gripe_implicit_conversion ("Octave:array-as-scalar",
+				     type_name (), "real scalar");
 
 	  retval = double (matrix(0));
 	}
       else
 	gripe_invalid_conversion (type_name (), "real scalar");
 
       return retval;
       
diff --git a/src/ov-list.cc b/src/ov-list.cc
--- a/src/ov-list.cc
+++ b/src/ov-list.cc
@@ -242,18 +242,19 @@ octave_list::assign (const octave_value_
       int i = idx(0).int_value (true);
 
       if (! error_state)
 	{
 	  octave_idx_type n = data.length ();
 
 	  if (i > 0)
 	    {
-	      if (Vwarn_resize_on_range_error && i > n)
-		warning ("list index = %d out of range", i);
+	      if (i > n)
+		warning_with_id ("Octave:resize-on-range-error",
+				 "list index = %d out of range", i);
 
 	      data(i-1) = rhs;
 	    }
 	  else
 	    error ("list index = %d out of range", i);
 	}
       else
 	error ("list index must be an integer");
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -131,19 +131,18 @@ double
 octave_range::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   octave_idx_type nel = range.nelem ();
 
   if (nel > 0)
     {
-      // FIXME -- is warn_fortran_indexing the right variable here?
-      if (Vwarn_fortran_indexing)
-	gripe_implicit_conversion ("range", "real scalar");
+      gripe_implicit_conversion ("Octave:array-as-scalar",
+				 "range", "real scalar");
 
       retval = range.base ();
     }
   else
     gripe_invalid_conversion ("range", "real scalar");
 
   return retval;
 }
@@ -191,19 +190,18 @@ octave_range::complex_value (bool) const
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   octave_idx_type nel = range.nelem ();
 
   if (nel > 0)
     {
-      // FIXME -- is warn_fortran_indexing the right variable here?
-      if (Vwarn_fortran_indexing)
-	gripe_implicit_conversion ("range", "complex scalar");
+      gripe_implicit_conversion ("Octave:array-as-scalar",
+				 "range", "complex scalar");
 
       retval = range.base ();
     }
   else
     gripe_invalid_conversion ("range", "complex scalar");
 
   return retval;
 }
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -87,19 +87,18 @@ octave_matrix::valid_as_scalar_index (vo
 
 double
 octave_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (numel () > 0)
     {
-      // FIXME -- is warn_fortran_indexing the right variable here?
-      if (Vwarn_fortran_indexing)
-	gripe_implicit_conversion ("real matrix", "real scalar");
+      gripe_implicit_conversion ("Octave:array-as-scalar",
+				 "real matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("real matrix", "real scalar");
 
   return retval;
 }
@@ -114,22 +113,20 @@ octave_matrix::matrix_value (bool) const
 
 Complex
 octave_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  // FIXME -- maybe this should be a function, valid_as_scalar()
   if (rows () > 0 && columns () > 0)
     {
-      // FIXME -- is warn_fortran_indexing the right variable here?
-      if (Vwarn_fortran_indexing)
-	gripe_implicit_conversion ("real matrix", "complex scalar");
+      gripe_implicit_conversion ("Octave:array-as-scalar",
+				 "real matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("real matrix", "complex scalar");
 
   return retval;
 }
diff --git a/src/ov-re-sparse.cc b/src/ov-re-sparse.cc
--- a/src/ov-re-sparse.cc
+++ b/src/ov-re-sparse.cc
@@ -93,19 +93,18 @@ octave_sparse_matrix::valid_as_scalar_in
 
 double
 octave_sparse_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (numel () > 0)
     {
-      // FIXME -- is warn_fortran_indexing the right variable here?
-      if (Vwarn_fortran_indexing)
-	gripe_implicit_conversion ("real sparse matrix", "real scalar");
+      gripe_implicit_conversion ("Octave:array-as-scalar",
+				 "real sparse matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("real sparse matrix", "real scalar");
 
   return retval;
 }
@@ -115,19 +114,18 @@ octave_sparse_matrix::complex_value (boo
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   // FIXME -- maybe this should be a function, valid_as_scalar()
   if (rows () > 0 && columns () > 0)
     {
-      // FIXME -- is warn_fortran_indexing the right variable here?
-      if (Vwarn_fortran_indexing)
-	gripe_implicit_conversion ("real sparse matrix", "complex scalar");
+      gripe_implicit_conversion ("Octave:array-as-scalar",
+				 "real sparse matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("real sparse matrix", "complex scalar");
 
   return retval;
 }
diff --git a/src/ov-str-mat.cc b/src/ov-str-mat.cc
--- a/src/ov-str-mat.cc
+++ b/src/ov-str-mat.cc
@@ -50,23 +50,16 @@ 02110-1301, USA.
 #include "utils.h"
 
 DEFINE_OCTAVE_ALLOCATOR (octave_char_matrix_str);
 DEFINE_OCTAVE_ALLOCATOR (octave_char_matrix_sq_str);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_char_matrix_str, "string", "char");
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_char_matrix_sq_str, "sq_string", "char");
 
-// If TRUE, warn for operations like
-//
-//   octave> 'abc' + 0
-//   97 98 99
-//
-static int Vwarn_str_to_num;
-
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
   octave_base_value *retval = 0;
 
   CAST_CONV_ARG (const octave_char_matrix_str&);
 
   NDArray nda = v.array_value (true);
@@ -178,18 +171,19 @@ octave_char_matrix_str::valid_as_scalar_
 
 #define CHAR_MATRIX_CONV(T, INIT, TNAME, FCN) \
   T retval INIT; \
  \
   if (! force_string_conv) \
     gripe_invalid_conversion ("string", TNAME); \
   else \
     { \
-      if (Vwarn_str_to_num) \
-	gripe_implicit_conversion ("string", TNAME); \
+      warning_with_id ("Octave:warn-str-to-num", \
+		       "implicit conversion from %s to %s", \
+		       "string", TNAME); \
  \
       retval = octave_char_matrix::FCN (); \
     } \
  \
   return retval
 
 double
 octave_char_matrix_str::double_value (bool force_string_conv) const
@@ -757,41 +751,13 @@ octave_char_matrix_str::load_hdf5 (hid_t
 	}
     }
 
   return retval;
 }
 
 #endif
 
-static int
-warn_str_to_num (void)
-{
-  Vwarn_str_to_num = check_preference ("warn_str_to_num");
-
-  return 0;
-}
-
-void
-symbols_of_ov_str_mat (void)
-{
-  DEFVAR (warn_str_to_num, false, warn_str_to_num,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} warn_str_to_num\n\
-If the value of @code{warn_str_to_num} is nonzero, a warning is printed\n\
-for implicit conversions of strings to their numeric ASCII equivalents.\n\
-For example,\n\
-@example\n\
-@group\n\
-\"abc\" + 0\n\
-     @result{} 97 98 99\n\
-@end group\n\
-@end example\n\
-elicits a warning if @code{warn_str_to_num} is nonzero.  The default\n\
-value is 0.\n\
-@end defvr");
-}
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-streamoff.cc b/src/ov-streamoff.cc
--- a/src/ov-streamoff.cc
+++ b/src/ov-streamoff.cc
@@ -47,19 +47,18 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
 
 std::streamoff
 octave_streamoff::streamoff_value (void) const
 {
   std::streamoff retval (-1);
 
   if (numel () > 0)
     {
-      // FIXME -- is warn_fortran_indexing the right variable here?
-      if (Vwarn_fortran_indexing)
-	gripe_implicit_conversion ("streamoff array", "scalar streamoff");
+      gripe_implicit_conversion ("Octave:array-as-scalar",
+				 "streamoff array", "scalar streamoff");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("streamoff array", "scalar streamoff");
 
   return retval;
 }
diff --git a/src/ov-struct.h b/src/ov-struct.h
--- a/src/ov-struct.h
+++ b/src/ov-struct.h
@@ -33,17 +33,16 @@ 02110-1301, USA.
 #include "str-vec.h"
 
 #include "error.h"
 #include "oct-alloc.h"
 #include "oct-map.h"
 #include "ov-base.h"
 #include "ov-typeinfo.h"
 
-class Octave_map;
 class octave_value_list;
 
 class tree_walker;
 
 // Data structures.
 
 class
 octave_struct : public octave_base_value
@@ -87,17 +86,17 @@ public:
   dim_vector dims (void) const { return map.dims (); }
 
   size_t byte_size (void) const;
 
   octave_value reshape (const dim_vector& new_dims) const
     { return map.reshape (new_dims); }
 
   octave_value resize (const dim_vector& dv) const
-    { return map.resize (dv); }
+    { Octave_map tmap = map; tmap.resize (dv); return tmap; }
 
   bool is_defined (void) const { return true; }
 
   bool is_map (void) const { return true; }
 
   Octave_map map_value (void) const { return map; }
 
   string_vector map_keys (void) const { return map.keys (); }
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -77,26 +77,16 @@ 02110-1301, USA.
 #include "pr-output.h"
 #include "utils.h"
 #include "variables.h"
 
 // We are likely to have a lot of octave_value objects to allocate, so
 // make the grow_size large.
 DEFINE_OCTAVE_ALLOCATOR2(octave_value, 1024);
 
-// If TRUE, print a warning for assignments like
-//
-//   octave> A(1) = 3; A(2) = 5
-//
-// for A already defined and a matrix type.
-bool Vwarn_fortran_indexing;
-
-// Should we warn about conversions from complex to real?
-int Vwarn_imag_to_real;
-
 // FIXME
 
 // Octave's value type.
 
 std::string
 octave_value::unary_op_as_string (unary_op op)
 {
   std::string retval;
@@ -1137,19 +1127,19 @@ octave_value::vector_value (bool force_s
   else if (nc == 1)
     {
       retval.resize (nr);
       for (octave_idx_type i = 0; i < nr; i++)
 	retval (i) = m (i, 0);
     }
   else if (nr > 0 && nc > 0)
     {
-      // FIXME -- is warn_fortran_indexing the right variable here?
-      if (! force_vector_conversion && Vwarn_fortran_indexing)
-	gripe_implicit_conversion (type_name (), "real vector");
+      if (! force_vector_conversion)
+	gripe_implicit_conversion ("Octave:array-as-vector",
+				   type_name (), "real vector");
 
       retval.resize (nr * nc);
       octave_idx_type k = 0;
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = 0; i < nr; i++)
 	  {
 	    OCTAVE_QUIT;
 
@@ -1212,19 +1202,19 @@ octave_value::int_vector_value (bool for
 	      return retval;
 	    }
 
 	  retval (i) = static_cast<int> (d);
 	}
     }
   else if (nr > 0 && nc > 0)
     {
-      // FIXME -- is warn_fortran_indexing the right variable here?
-      if (! force_vector_conversion && Vwarn_fortran_indexing)
-	gripe_implicit_conversion (type_name (), "real vector");
+      if (! force_vector_conversion)
+	gripe_implicit_conversion ("Octave:array-as-vector",
+				   type_name (), "real vector");
 
       retval.resize (nr * nc);
       octave_idx_type k = 0;
       for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
 	      OCTAVE_QUIT;
@@ -1279,19 +1269,19 @@ octave_value::complex_vector_value (bool
       for (octave_idx_type i = 0; i < nr; i++)
 	{
 	  OCTAVE_QUIT;
 	  retval (i) = m (i, 0);
 	}
     }
   else if (nr > 0 && nc > 0)
     {
-      // FIXME -- is warn_fortran_indexing the right variable here?
-      if (! force_vector_conversion && Vwarn_fortran_indexing)
-	gripe_implicit_conversion (type_name (), "complex vector");
+      if (! force_vector_conversion)
+	gripe_implicit_conversion ("Octave:array-as-vector",
+				   type_name (), "complex vector");
 
       retval.resize (nr * nc);
       octave_idx_type k = 0;
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = 0; i < nr; i++)
 	  {
 	    OCTAVE_QUIT;
 	    retval (k++) = m (i, j);
@@ -1893,51 +1883,13 @@ Return the size of @var{val} in bytes\n\
   if (args.length () == 1)
     retval = args(0).byte_size ();
   else
     print_usage ("sizeof");
 
   return retval;
 }
 
-static int
-warn_fortran_indexing (void)
-{
-  Vwarn_fortran_indexing = check_preference ("warn_fortran_indexing");
-
-  liboctave_wfi_flag = Vwarn_fortran_indexing;
-
-  return 0;
-}
-
-static int
-warn_imag_to_real (void)
-{
-  Vwarn_imag_to_real = check_preference ("warn_imag_to_real");
-
-  return 0;
-}
-
-void
-symbols_of_ov (void)
-{
-  DEFVAR (warn_fortran_indexing, false, warn_fortran_indexing,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} warn_fortran_indexing\n\
-If the value of @code{warn_fortran_indexing} is nonzero, a warning is\n\
-printed for expressions which select elements of a two-dimensional matrix\n\
-using a single index.  The default value is 0.\n\
-@end defvr");
-
-  DEFVAR (warn_imag_to_real, false, warn_imag_to_real,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} warn_imag_to_real\n\
-If the value of @code{warn_imag_to_real} is nonzero, a warning is\n\
-printed for implicit conversions of complex numbers to real numbers.\n\
-The default value is 0.\n\
-@end defvr");
-}
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -856,26 +856,16 @@ OV_BINOP_FN (op_el_mul)
 OV_BINOP_FN (op_el_div)
 OV_BINOP_FN (op_el_pow)
 OV_BINOP_FN (op_el_ldiv)
 OV_BINOP_FN (op_el_and)
 OV_BINOP_FN (op_el_or)
 
 OV_BINOP_FN (op_struct_ref)
 
-// If TRUE, print a warning for assignments like
-//
-//   octave> A(1) = 3; A(2) = 5
-//
-// for A already defined and a matrix type.
-extern bool Vwarn_fortran_indexing;
-
-// Should we warn about conversions from complex to real?
-extern int Vwarn_imag_to_real;
-
 extern void install_types (void);
 
 // FIXME -- these trait classes probably belong somehwere else...
 
 template <typename T>
 class
 octave_type_traits
 {
diff --git a/src/parse.h b/src/parse.h
--- a/src/parse.h
+++ b/src/parse.h
@@ -74,19 +74,16 @@ extern bool evaluating_function_body;
 
 // Keep track of symbol table information when parsing functions.
 extern std::stack<symbol_table*> symtab_context;
 
 // Name of parent function when parsing function files that might
 // contain nested functions.
 extern std::string parent_function_name;
 
-// TRUE means warn about function files that have time stamps in the future.
-extern bool Vwarn_future_time_stamp;
-
 // Keep a count of how many END tokens we expect.
 extern int end_tokens_expected;
 
 extern void
 parse_and_execute (FILE *f);
 
 extern void
 parse_and_execute (const std::string& s, bool verbose = false,
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -69,51 +69,16 @@ 02110-1301, USA.
 #include "parse.h"
 #include "pt-all.h"
 #include "symtab.h"
 #include "token.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
-// If TRUE, generate a warning for the assignment in things like
-//
-//   octave> if (a = 2 < n)
-//
-// but not
-//
-//   octave> if ((a = 2) < n)
-//
-static bool Vwarn_assign_as_truth_value;
-
-// If TRUE, generate warning about the meaning of code changing due to
-// changes in associativity for various ops (typically for Matlab
-// compatibility).
-static bool Vwarn_associativity_change;
-
-// If TRUE, generate warning if declared function name disagrees with
-// the name of the file in which it is defined.
-static bool Vwarn_function_name_clash;
-
-// TRUE means warn about function files that have time stamps in the future.
-bool Vwarn_future_time_stamp;
-
-// If TRUE, generate warning if a statement in a function is not
-// terminated with a semicolon.  Useful for checking functions that
-// should only produce output using explicit printing statements.
-static bool Vwarn_missing_semicolon;
-
-// If TRUE, generate warning about the meaning of code changing due to
-// changes in precedence levels for various ops (typically for Matlab
-// compatibility).
-static bool Vwarn_precedence_change;
-
-// If TRUE, generate a warning for variable switch labels.
-static bool Vwarn_variable_switch_label;
-
 // Temporary symbol table pointer used to cope with bogus function syntax.
 symbol_table *tmp_local_sym_tab = 0;
 
 // The current input line number.
 int input_line_number = 0;
 
 // The column of the current token.
 int current_input_column = 1;
@@ -1555,33 +1520,33 @@ end_token_ok (token *tok, token::end_tok
 }
 
 // Maybe print a warning if an assignment expression is used as the
 // test in a logical expression.
 
 static void
 maybe_warn_assign_as_truth_value (tree_expression *expr)
 {
-  if (Vwarn_assign_as_truth_value
-      && expr->is_assignment_expression ()
+  if (expr->is_assignment_expression ()
       && expr->paren_count () < 2)
     {
-      warning ("suggest parenthesis around assignment used as truth value");
+      warning_with_id
+        ("Octave:assign-as-truth-value",
+         "suggest parenthesis around assignment used as truth value");
     }
 }
 
 // Maybe print a warning about switch labels that aren't constants.
 
 static void
 maybe_warn_variable_switch_label (tree_expression *expr)
 {
-  if (Vwarn_variable_switch_label && ! expr->is_constant ())
-    {
-      warning ("variable switch label");
-    }
+  if (! expr->is_constant ())
+    warning_with_id ("Octave:warn-variable-switch-label",
+    		     "variable switch label");
 }
 
 static tree_expression *
 fold (tree_binary_expression *e)
 {
   tree_expression *retval = e;
 
   unwind_protect::begin_frame ("fold_binary_expression");
@@ -1596,19 +1561,19 @@ fold (tree_binary_expression *e)
   discard_warning_messages = true;
 
   tree_expression *op1 = e->lhs ();
   tree_expression *op2 = e->rhs ();
 
   octave_value::binary_op op_type = e->op_type ();
 
   if (op1->is_constant () && op2->is_constant ()
-      && (! ((Vwarn_associativity_change
+      && (! ((warning_enabled ("Octave:associativity-change")
 	      && (op_type == POW || op_type == EPOW))
-	     || (Vwarn_precedence_change
+	     || (warning_enabled ("Octave:precedence-change")
 		 && (op_type == EXPR_OR || op_type == EXPR_OR_OR)))))
     {
       octave_value tmp = e->rvalue ();
 
       if (! (error_state || warning_state))
 	{
 	  tree_constant *tc_retval = new tree_constant (tmp);
 
@@ -1851,30 +1816,31 @@ make_anon_fcn_handle (tree_parameter_lis
   tree_constant *retval = new tree_constant (fh, l, c);
 
   return retval;
 }
 
 static void
 maybe_warn_associativity_change (tree_expression *op)
 {
-  if (Vwarn_associativity_change
-      && op->paren_count () == 0 && op->is_binary_expression ())
+  if (op->paren_count () == 0 && op->is_binary_expression ())
     {
       tree_binary_expression *e
 	= dynamic_cast<tree_binary_expression *> (op);
 
       octave_value::binary_op op_type = e->op_type ();
 
       if (op_type == octave_value::op_pow
 	  || op_type == octave_value::op_el_pow)
 	{
 	  std::string op_str = octave_value::binary_op_as_string (op_type);
 
-	  warning ("meaning may have changed due to change in associativity for %s operator", op_str.c_str ());
+	  warning_with_id
+	    ("Octave:associativity-change",
+	     "meaning may have changed due to change in associativity for %s operator", op_str.c_str ());
         }
     }
 }
 
 // Build a binary expression.
 
 static tree_expression *
 make_binary_op (int op, tree_expression *op1, token *tok_val,
@@ -1959,24 +1925,25 @@ make_binary_op (int op, tree_expression 
       break;
 
     case EXPR_AND:
       t = octave_value::op_el_and;
       break;
 
     case EXPR_OR:
       t = octave_value::op_el_or;
-      if (Vwarn_precedence_change
-          && op2->paren_count () == 0 && op2->is_binary_expression ())
+      if (op2->paren_count () == 0 && op2->is_binary_expression ())
         {
 	  tree_binary_expression *e
 	    = dynamic_cast<tree_binary_expression *> (op2);
 
 	  if (e->op_type () == octave_value::op_el_and)
-	    warning ("meaning may have changed due to change in precedence for & and | operators");
+	    warning_with_id
+	      ("Octave:precedence-change",
+	       "meaning may have changed due to change in precedence for & and | operators");
         }
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
@@ -2000,24 +1967,25 @@ make_boolean_op (int op, tree_expression
   switch (op)
     {
     case EXPR_AND_AND:
       t = tree_boolean_expression::bool_and;
       break;
 
     case EXPR_OR_OR:
       t = tree_boolean_expression::bool_or;
-      if (Vwarn_precedence_change
-          && op2->paren_count () == 0 && op2->is_boolean_expression ())
+      if (op2->paren_count () == 0 && op2->is_boolean_expression ())
         {
 	  tree_boolean_expression *e
 	    = dynamic_cast<tree_boolean_expression *> (op2);
 
 	  if (e->op_type () == tree_boolean_expression::bool_and)
-	    warning ("meaning may have changed due to change in precedence for && and || operators");
+	    warning_with_id
+	      ("Octave:precedence-change",
+	       "meaning may have changed due to change in precedence for && and || operators");
         }
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
@@ -2503,38 +2471,37 @@ frob_function (const std::string& fname,
   // file.  Matlab doesn't provide a diagnostic (it ignores the stated
   // name).
 
   if (reading_fcn_file || autoloading)
     {
       if (! (lexer_flags.parsing_nested_function || autoloading)
           && curr_fcn_file_name != id_name)
 	{
-	  if (Vwarn_function_name_clash)
-	    warning ("function name `%s' does not agree with function\
- file name `%s'", id_name.c_str (), curr_fcn_file_full_name.c_str ());
+	  warning_with_id
+	    ("Octave:function-name-clash",
+	     "function name `%s' does not agree with function file name `%s'",
+	     id_name.c_str (), curr_fcn_file_full_name.c_str ());
 
 	  id_name = curr_fcn_file_name;
 	}
 
       octave_time now;
 
       fcn->stash_fcn_file_name (curr_fcn_file_full_name);
       fcn->stash_fcn_file_time (now);
       fcn->mark_as_system_fcn_file ();
 
-      if (Vwarn_future_time_stamp)
-	{
-	  std::string nm = fcn->fcn_file_name ();
-
-	  file_stat fs (nm);
-
-	  if (fs && fs.is_newer (now))
-	    warning ("time stamp for `%s' is in the future", nm.c_str ());
-	}
+      std::string nm = fcn->fcn_file_name ();
+
+      file_stat fs (nm);
+
+      if (fs && fs.is_newer (now))
+        warning_with_id ("Octave:future-time-stamp",
+			 "time stamp for `%s' is in the future", nm.c_str ());
     }
   else if (! (input_from_tmp_history_file || input_from_startup_file)
 	   && reading_script_file
 	   && curr_fcn_file_name == id_name)
     {
       warning ("function `%s' defined within script file `%s'",
 	       id_name.c_str (), curr_fcn_file_full_name.c_str ());
     }
@@ -2833,24 +2800,25 @@ finish_cell (tree_cell *c)
   // For now, this doesn't do anything.
 
   return c;
 }
 
 static void
 maybe_warn_missing_semi (tree_statement_list *t)
 {
-  if (lexer_flags.defining_func && Vwarn_missing_semicolon)
+  if (lexer_flags.defining_func)
     {
       tree_statement *tmp = t->back();
 
       if (tmp->is_expression ())
-	warning ("missing semicolon near line %d, column %d in file `%s'",
-		 tmp->line (), tmp->column (),
-		 curr_fcn_file_full_name.c_str ());
+	warning_with_id
+	  ("Octave:missing-semicolon",
+	   "missing semicolon near line %d, column %d in file `%s'",
+	    tmp->line (), tmp->column (), curr_fcn_file_full_name.c_str ());
     }
 }
 
 static void
 set_stmt_print_flag (tree_statement_list *list, char sep,
 		     bool warn_missing_semi)
 {
   switch (sep)
@@ -4092,190 +4060,13 @@ context @var{context}, which may be eith
         error ("evalin: expecting string as first argument");
     }
   else
     print_usage ("evalin");
 
   return retval;
 }
 
-static int
-warn_assign_as_truth_value (void)
-{
-  Vwarn_assign_as_truth_value
-    = check_preference ("warn_assign_as_truth_value");
-
-  return 0;
-}
-
-static int
-warn_associativity_change (void)
-{
-  Vwarn_associativity_change = check_preference ("warn_associativity_change");
-
-  return 0;
-}
-
-static int
-warn_function_name_clash (void)
-{
-  Vwarn_function_name_clash = check_preference ("warn_function_name_clash");
-
-  return 0;
-}
-
-static int
-warn_future_time_stamp (void)
-{
-  Vwarn_future_time_stamp = check_preference ("warn_future_time_stamp");
-
-  return 0;
-}
-
-static int
-warn_missing_semicolon (void)
-{
-  Vwarn_missing_semicolon = check_preference ("warn_missing_semicolon");
-
-  return 0;
-}
-
-static int
-warn_precedence_change (void)
-{
-  Vwarn_precedence_change = check_preference ("warn_precedence_change");
-
-  return 0;
-}
-
-static int
-warn_variable_switch_label (void)
-{
-  Vwarn_variable_switch_label
-    = check_preference ("warn_variable_switch_label");
-
-  return 0;
-}
-
-void
-symbols_of_parse (void)
-{
-  DEFVAR (warn_assign_as_truth_value, true, warn_assign_as_truth_value,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} warn_assign_as_truth_value\n\
-If the value of @code{warn_assign_as_truth_value} is nonzero, a\n\
-warning is issued for statements like\n\
-\n\
-@example\n\
-if (s = t)\n\
-  ...\n\
-@end example\n\
-\n\
-@noindent\n\
-since such statements are not common, and it is likely that the intent\n\
-was to write\n\
-\n\
-@example\n\
-if (s == t)\n\
-  ...\n\
-@end example\n\
-\n\
-@noindent\n\
-instead.\n\
-\n\
-There are times when it is useful to write code that contains\n\
-assignments within the condition of a @code{while} or @code{if}\n\
-statement.  For example, statements like\n\
-\n\
-@example\n\
-while (c = getc())\n\
-  ...\n\
-@end example\n\
-\n\
-@noindent\n\
-are common in C programming.\n\
-\n\
-It is possible to avoid all warnings about such statements by setting\n\
-@code{warn_assign_as_truth_value} to 0, but that may also\n\
-let real errors like\n\
-\n\
-@example\n\
-if (x = 1)  # intended to test (x == 1)!\n\
-  ...\n\
-@end example\n\
-\n\
-@noindent\n\
-slip by.\n\
-\n\
-In such cases, it is possible suppress errors for specific statements by\n\
-writing them with an extra set of parentheses.  For example, writing the\n\
-previous example as\n\
-\n\
-@example\n\
-while ((c = getc()))\n\
-  ...\n\
-@end example\n\
-\n\
-@noindent\n\
-will prevent the warning from being printed for this statement, while\n\
-allowing Octave to warn about other assignments used in conditional\n\
-contexts.\n\
-\n\
-The default value of @code{warn_assign_as_truth_value} is 1.\n\
-@end defvr");
-
-  DEFVAR (warn_associativity_change, true, warn_associativity_change,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} warn_associativity_change\n\
-If the value of this variable is nonzero, Octave will warn about\n\
-possible changes in the meaning of some code due to changes in\n\
-associativity for some operators.  Associativity changes have typically\n\
-been made for Matlab compatibility.  The default value is 1.\n\
-@end defvr");
-
-  DEFVAR (warn_function_name_clash, true, warn_function_name_clash,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} warn_function_name_clash\n\
-If the value of @code{warn_function_name_clash} is nonzero, a warning is\n\
-issued when Octave finds that the name of a function defined in a\n\
-function file differs from the name of the file.  (If the names\n\
-disagree, the name declared inside the file is ignored.)  If the value\n\
-is 0, the warning is omitted.  The default value is 1.\n\
-@end defvr");
-
-  DEFVAR (warn_future_time_stamp, true, warn_future_time_stamp,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} warn_future_time_stamp\n\
-If the value of this variable is nonzero, Octave will print a warning\n\
-if it finds a function file with a time stamp that is in the future.\n\
-@end defvr");
-
-  DEFVAR (warn_missing_semicolon, false, warn_missing_semicolon,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} warn_missing_semicolon\n\
-If the value of this variable is nonzero, Octave will warn when\n\
-statements in function definitions don't end in semicolons.  The default\n\
-value is 0.\n\
-@end defvr");
-
-  DEFVAR (warn_precedence_change, true, warn_precedence_change,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} warn_precedence_change\n\
-If the value of this variable is nonzero, Octave will warn about\n\
-possible changes in the meaning of some code due to changes in\n\
-precedence for some operators.  Precedence changes have typically\n\
-been made for Matlab compatibility.  The default value is 1.\n\
-@end defvr");
-
-  DEFVAR (warn_variable_switch_label, false, warn_variable_switch_label,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} warn_variable_switch_label\n\
-If the value of this variable is nonzero, Octave will print a warning if\n\
-a switch label is not a constant or constant expression\n\
-@end defvr");
-
-}
-
 /*
 ;;; Local Variables: ***
 ;;; mode: text ***
 ;;; End: ***
 */
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -39,25 +39,19 @@ 02110-1301, USA.
 #include "pt-walk.h"
 #include "utils.h"
 #include "ov.h"
 #include "variables.h"
 
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
-// If TRUE, print a warning message for empty elements in a matrix list.
-static bool Vwarn_empty_list_elements;
-
 // The character to fill with when creating string arrays.
 char Vstring_fill_char = ' ';
 
-// Warn if concatenating double and single quoted strings.
-char Vwarn_string_concat = false;
-
 // General matrices.  This list type is much more work to handle than
 // constant matrices, but it allows us to construct matrices from
 // other matrices, variables, and functions.
 
 // But first, some internal classes that make our job much easier.
 
 class
 tm_row_const
@@ -317,17 +311,17 @@ tm_row_const::tm_row_const_rep::do_init_
 		{
 		  eval_error ("dimensions mismatch", elt->line (), elt->column (), 1, dv (i));
 		  return false;
 		}
 	}
       dv.elem (1) = dv.elem (1) + this_elt_nc;
 
     }
-  else if (Vwarn_empty_list_elements)
+  else
     eval_warning ("empty matrix found in matrix list",
 		  elt->line (), elt->column ());
 
   append (val);
 
   if (all_str && ! val.is_string ())
     all_str = false;
 
@@ -423,19 +417,20 @@ tm_row_const::tm_row_const_rep::eval_err
     }
 }
 
 void
 tm_row_const::tm_row_const_rep::eval_warning (const char *msg, int l,
 					      int c) const
 {
   if (l == -1 && c == -1)
-    ::warning ("%s", msg);
+    warning_with_id ("Octave:empty-list-elements", "%s", msg);
   else
-    ::warning ("%s near line %d, column %d", msg, l, c);
+    warning_with_id ("Octave:empty-list-elements",
+		     "%s near line %d, column %d", msg, l, c);
 }
 
 class
 tm_const : public octave_base_list<tm_row_const>
 {
 public:
 
   tm_const (const tree_matrix& tm)
@@ -631,18 +626,19 @@ tm_const::init (const tree_matrix& tm)
 			  break;
 			}
 
 		  if (get_out)
 		    break;
 		}
 	      dv.elem (0) = dv.elem (0) + this_elt_nr;
 	    }
-	  else if (Vwarn_empty_list_elements)
-	    warning ("empty matrix found in matrix list");
+	  else
+	    warning_with_id ("Octave:empty-list-elements",
+			     "empty matrix found in matrix list");
 	}
     }
 
   ok = ! error_state;
 }
 
 tree_matrix::~tree_matrix (void)
 {
@@ -699,18 +695,19 @@ tree_matrix::rvalue (int nargout)
     retval = rvalue ();
 
   return retval;
 }
 
 static void
 maybe_warn_string_concat (bool all_dq_strings_p, bool all_sq_strings_p)
 {
-  if (Vwarn_string_concat && ! (all_dq_strings_p || all_sq_strings_p))
-    ::warning ("concatenation of different character string types may have unintended consequences");
+  if (! (all_dq_strings_p || all_sq_strings_p))
+    warning_with_id ("Octave:string-concat",
+		     "concatenation of different character string types may have unintended consequences");
 }
 
 #define SINGLE_TYPE_CONCAT(TYPE, EXTRACTOR) \
   do \
     { \
       int dv_len = dv.length (); \
       Array<octave_idx_type> ra_idx (dv_len > 1 ? dv_len : 2, 0); \
  \
@@ -938,32 +935,16 @@ done:
 
 void
 tree_matrix::accept (tree_walker& tw)
 {
   tw.visit_matrix (*this);
 }
 
 static int
-warn_empty_list_elements (void)
-{
-  Vwarn_empty_list_elements = check_preference ("warn_empty_list_elements");
-
-  return 0;
-}
-
-static int
-warn_string_concat (void)
-{
-  Vwarn_string_concat = check_preference ("warn_string_concat");
-
-  return 0;
-}
-
-static int
 string_fill_char (void)
 {
   int status = 0;
 
   std::string s = builtin_string_variable ("string_fill_char");
 
   switch (s.length ())
     {
@@ -999,38 +980,15 @@ is @code{\" \"} (a single space).  For e
 string_fill_char = \"X\";\n\
 [ \"these\"; \"are\"; \"strings\" ]\n\
      @result{} \"theseXX\"\n\
         \"areXXXX\"\n\
         \"strings\"\n\
 @end group\n\
 @end example\n\
 @end defvr");
-
-  DEFVAR (warn_empty_list_elements, false, warn_empty_list_elements,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} warn_empty_list_elements\n\
-If the value of @code{warn_empty_list_elements} is nonzero, print a\n\
-warning when an empty matrix is found in a matrix list.  For example,\n\
-\n\
-@example\n\
-a = [1, [], 3, [], 5]\n\
-@end example\n\
-\n\
-@noindent\n\
-The default value is 0.\n\
-@end defvr");
-
-  DEFVAR (warn_string_concat, false, warn_string_concat,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} warn_string_concat\n\
-If the value of @code{warn_string_concat} is nonzero, print a\n\
-warning when concatenating a mixture of double and single quoted strings.\n\
-The default value is 1.\n\
-@end defvr");
-
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pt-misc.cc b/src/pt-misc.cc
--- a/src/pt-misc.cc
+++ b/src/pt-misc.cc
@@ -30,20 +30,16 @@ 02110-1301, USA.
 #include "ov.h"
 #include "oct-lvalue.h"
 #include "pt-id.h"
 #include "pt-idx.h"
 #include "pt-misc.h"
 #include "pt-walk.h"
 #include "utils.h"
 
-// If TRUE, print a warning if a function does not define all the
-// values in the return list which are expected.
-static bool Vwarn_undefined_return_values;
-
 // Parameter lists.
 
 tree_parameter_list::~tree_parameter_list (void)
 {
   while (! empty ())
     {
       iterator p = begin ();
       delete *p;
@@ -74,21 +70,24 @@ tree_parameter_list::initialize_undefine
     {
       if (++count > nargout)
 	break;
 
       tree_identifier *elt = *p;
 
       if (! elt->is_defined ())
 	{
-	  if (Vwarn_undefined_return_values && ! warned)
+	  if (! warned)
 	    {
 	      warned = true;
-	      warning ("%s: some elements in list of return values are undefined",
-		       warnfor.c_str ());
+
+	      warning_with_id
+		("Octave:undefined-return-values",
+		 "%s: some elements in list of return values are undefined",
+		 warnfor.c_str ());
 	    }
 
 	  octave_lvalue tmp = elt->lvalue ();
 
 	  tmp.assign (octave_value::op_asn_eq, val);
 	}
     }
 }
@@ -214,34 +213,13 @@ tree_return_list::~tree_return_list (voi
 }
 
 void
 tree_return_list::accept (tree_walker& tw)
 {
   tw.visit_return_list (*this);
 }
 
-static int
-warn_undefined_return_values (void)
-{
-  Vwarn_undefined_return_values
-    = check_preference ("warn_undefined_return_values");
-
-  return 0;
-}
-
-void
-symbols_of_pt_misc (void)
-{
-  DEFVAR (warn_undefined_return_values, true, warn_undefined_return_values,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} warn_undefined_return_values\n\
-If the value of @code{warn_undefined_return_values} is nonzero,\n\
-print a warning if a function does not define all the values in\n\
-the return list which are expected.  The default value is 1.\n\
-@end defvr");
-}
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -63,22 +63,16 @@ 02110-1301, USA.
 #include "oct-obj.h"
 #include "pager.h"
 #include "sysdep.h"
 #include "toplev.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
-// If TRUE, print a warning for expressions like
-//
-//   ones (-1, 5)
-//
-static int Vwarn_neg_dim_as_zero;
-
 // Return TRUE if S is a valid identifier.
 
 bool
 valid_identifier (const char *s)
 {
   if (! s || ! (isalpha (*s) || *s == '_' || *s == '$'))
      return false;
 
@@ -791,18 +785,18 @@ check_preference (const std::string& var
   return pref;
 }
 
 static void
 check_dimensions (octave_idx_type& nr, octave_idx_type& nc, const char *warnfor)
 {
   if (nr < 0 || nc < 0)
     {
-      if (Vwarn_neg_dim_as_zero)
-	warning ("%s: converting negative dimension to zero", warnfor);
+      warning_with_id ("Octave:neg-dim-as-zero",
+		       "%s: converting negative dimension to zero", warnfor);
 
       nr = (nr < 0) ? 0 : nr;
       nc = (nc < 0) ? 0 : nc;
     }
 }
 
 void
 check_dimensions (dim_vector& dim, const char *warnfor)
@@ -813,18 +807,19 @@ check_dimensions (dim_vector& dim, const
     {
       if (dim(i) < 0)
         {
           dim(i) = 0;
           neg = true;
         }
     }
 
-  if (neg && Vwarn_neg_dim_as_zero)
-    warning ("%s: converting negative dimension to zero", warnfor);
+  if (neg)
+    warning_with_id ("Octave:neg-dim-as-zero",
+		     "%s: converting negative dimension to zero", warnfor);
 }
 
 
 void
 get_dimensions (const octave_value& a, const char *warn_for,
                 dim_vector& dim)
 {
   if (a.is_scalar_type ())
@@ -1119,39 +1114,13 @@ octave_sleep (double seconds)
 
       // Versions of these functions that accept unsigned int args are
       // defined in cutils.c.
       octave_sleep (sec);
       octave_usleep (usec);
     }
 }
 
-static int
-warn_neg_dim_as_zero (void)
-{
-  Vwarn_neg_dim_as_zero = check_preference ("warn_neg_dim_as_zero");
-
-  return 0;
-}
-
-void
-symbols_of_utils (void)
-{
-  DEFVAR (warn_neg_dim_as_zero, false, warn_neg_dim_as_zero,
-    "-*- texinfo -*-\n\
-@defvr {Built-in Variable} warn_neg_dim_as_zero\n\
-If the value of @code{warn_neg_dim_as_zero} is nonzero, print a warning\n\
-for expressions like\n\
-\n\
-@example\n\
-eye (-1)\n\
-@end example\n\
-\n\
-@noindent\n\
-The default value is 0.\n\
-@end defvr");
-}
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -693,21 +693,19 @@ looks_like_struct (const std::string& te
   symbol_record *sr = curr_sym_tab->lookup (text);
 
   if (sr && ! sr->is_function ())
     {
       int parse_status;
 
       unwind_protect::begin_frame ("looks_like_struct");
 
-      unwind_protect_str (Vwarning_option);
       unwind_protect_bool (discard_error_messages);
       unwind_protect_int (error_state);
 
-      Vwarning_option = "off";
       discard_error_messages = true;
 
       octave_value tmp = eval_string (text, true, parse_status);
 
       unwind_protect::run_frame ("looks_like_struct");
 
       retval = (tmp.is_defined () && tmp.is_map ());
     }
diff --git a/test/ChangeLog b/test/ChangeLog
--- a/test/ChangeLog
+++ b/test/ChangeLog
@@ -1,8 +1,17 @@
+2006-04-29  John W. Eaton  <jwe@octave.org>
+
+	* Makefile.in (check): Use run-octave script.
+
+2006-04-28  John W. Eaton  <jwe@octave.org>
+
+	* test_prefer.m: Adjust tests for new way of handling warning state.
+	* build_sparse_tests.sh: Likewise.
+
 2006-04-11  John W. Eaton  <jwe@octave.org>
 
 	* test_system.m, test_struct.m, test_string.m, test_quad.m,
 	test_number.m, test_nonlin.m, test_matrix.m, test_linalg.m,
 	test_io.m, test_diffeq.m, test_arith.m: Update for new usage
 	message format.
 
 2006-04-03  David Bateman  <dbateman@free.fr>
diff --git a/test/Makefile.in b/test/Makefile.in
--- a/test/Makefile.in
+++ b/test/Makefile.in
@@ -31,18 +31,17 @@ ifeq ($(SHARED_LIBS), true)
   endif
   SET_LD_LIBRARY_PATH = @library_path_var@="$(XLD_LIBRARY_PATH)"
 endif
 
 all: check
 .PHONY: all
 
 check: test_sparse.m
-	$(SET_LD_LIBRARY_PATH) $(OCTAVE_BINARY) \
-	  -f -q -H -p $(OCTAVE_SCRIPT_PATH) $(srcdir)/fntests.m $(srcdir)
+	../run-octave --no-site-file --silent --no-history $(srcdir)/fntests.m $(srcdir)
 .PHONY: check
 
 test_sparse.m: build_sparse_tests.sh
 	$(srcdir)/build_sparse_tests.sh
 
 install install-strip: all
 .PHONY: install install-strip
 
diff --git a/test/build_sparse_tests.sh b/test/build_sparse_tests.sh
--- a/test/build_sparse_tests.sh
+++ b/test/build_sparse_tests.sh
@@ -190,20 +190,20 @@ gen_specific_tests() {
 %!assert(nnz(sparse([-1,realmin,realmin]).^1.5),1);
 %!assert(nnz(sparse([-1,realmin,realmin,1]).^1.5),2);
 
 %!assert(nnz(sparse(1,1,0)),0); # Make sure scalar v==0 doesn't confuse matters
 %!assert(nnz(sparse(eye(3))*0),0);
 %!assert(nnz(sparse(eye(3))-sparse(eye(3))),0);
 
 %!test
-%! wdbz=warn_divide_by_zero;
-%! warn_divide_by_zero=0;
+%! wdbz = warning ("query", "Octave:divide-by-zero");
+%! warning ("off", "Octave:divide-by-zero");
 %! assert(sparse(eye(3))/0,sparse(eye(3)/0,1));
-%! warn_divide_by_zero=wdbz;
+%! warning (wdbz.state, "Octave:divide-by-zero");
 
 EOF
 }
 
 
 # =======================================================
 # Main function definition
 
@@ -406,22 +406,22 @@ EOF
 # test mapper matrix operations: uses as,af
 print_mapper_test() {
 echo "%!assert($1(as),sparse($1(af),1))" >>$TESTS
 }
 
 print_real_mapper_test() {
     cat >>$TESTS <<EOF
 %!test
-%! wn2s = warn_num_to_str;
-%! warn_num_to_str = 0;
+%! wn2s = warning ("query", "Octave:num-to-str");
+%! warning ("off", "Octave:num-to-str");
 %! if isreal(af)
 %!    assert($1(as),sparse($1(af),1))
 %! endif
-%! warn_num_to_str = wn2s;
+%! warning (wn2s.state, "Octave:num-to-str");
 
 EOF
 }
 
 gen_mapper_tests() {
 echo "%% Unary matrix tests (uses af,as)">>$TESTS
 print_mapper_test abs
 print_mapper_test acos
@@ -483,24 +483,24 @@ print_real_mapper_test isupper
 print_real_mapper_test isxdigit
 #print_real_mapper_test lgamma
 
 # Specific tests for certain mapper functions
     cat >>$TESTS <<EOF
 
 %% These mapper functions always return a full matrix
 %!test
-%! wn2s = warn_num_to_str;
-%! warn_num_to_str = 0;
+%! wn2s = warning ("query", "Octave:num-to-str");
+%! warning ("off", "Octave:num-to-str");
 %! if isreal(af)
 %!    assert(toascii(as),toascii(af))
 %!    assert(tolower(as),tolower(af))
 %!    assert(toupper(as),toupper(af))
 %! endif
-%! warn_num_to_str = wn2s;
+%! warning (wn2s.state, "Octave:num-to-str");
 
 EOF
 }
 
 # test matrix operations: uses as,af
 gen_unaryop_tests() {
     cat >>$TESTS <<EOF
 %% Unary matrix tests (uses af,as)
diff --git a/test/fntests.m b/test/fntests.m
--- a/test/fntests.m
+++ b/test/fntests.m
@@ -1,16 +1,16 @@
 clear all;
 
 global topsrcdir;
 
 currdir = canonicalize_file_name (".");
 
 if (nargin == 1)
-  xdir = argv{1};
+  xdir = argv(){1};
 else
   xdir = ".";
 endif
 
 srcdir = canonicalize_file_name (xdir);
 topsrcdir = canonicalize_file_name (fullfile (xdir, ".."));
 
 if (strcmp (currdir, srcdir))
@@ -55,17 +55,17 @@ function y = hastests (f)
     y = 1;
   else
     y = 0;
   endif
   fclose(fid);
 endfunction
 
 function [dp, dn] = runtestscript (fid, d);
-  global topsrcdir
+  global topsrcdir;
   lst = dir(d);
   dp = dn = 0;
   for i=1:length(lst)
     nm = lst(i).name;
     if (lst(i).isdir && !strcmp(nm,".") && !strcmp(nm,"..") && 
 	!strcmp(nm,"CVS"))
       [p, n] = runtestscript (fid, [d, "/",nm]);
       dp += p;
@@ -144,9 +144,8 @@ try
   fclose(fid);
   page_screen_output = pso;
   warning(warn_state.state,"quiet");
 catch
   page_screen_output = pso;
   warning(warn_state.state,"quiet");
   disp(lasterr());
 end_try_catch
-
diff --git a/test/test_index-wfi-f.m b/test/test_index-wfi-f.m
--- a/test/test_index-wfi-f.m
+++ b/test/test_index-wfi-f.m
@@ -1,376 +1,376 @@
 %% Automatically generated from DejaGNU files
 
 %% test/octave.test/index-wfi-f/s-1.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [];
 %! assert(isempty (a));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-2.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! assert(a(1),1);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-3.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! assert(a(:),1);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-4.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! assert(a(:,:),1);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-5.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! assert(a(1,:),1);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-6.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! assert(a(:,1),1);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-7.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! assert(isempty (a(logical (0))));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-8.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a(-1)");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-9.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a(2);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-10.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a(2,:);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-11.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a(:,2);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-12.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a(-1,:);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-13.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a(:,-1);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-14.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([1,2,3]);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-15.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([1;2;3]);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-16.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([1,2;3,4]);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-17.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([0,1]);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-18.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([0;1]);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-19.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([-1,0]);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-20.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([-1;0]);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-1.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(a(1),4);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-2.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(a(2),3);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-3.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(all (a(:) == a_prime));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-4.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(all (a(1,:) == a));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-5.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(a(:,3),2);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-6.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(all (a(:,:) == a));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-7.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(all (a(logical ([0,1,1,0])) == mid_a));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-8.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! fail("a(0);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-9.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! fail("a(5);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-10.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! fail("a(0,1);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-11.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(isempty (a(logical (0),:)));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-12.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! fail("a(:,0);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-13.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(isempty (a([])));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-14.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(isempty (a([],:)));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-15.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(isempty (a(:,[])));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/m-1.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [1,2;3,4];
 %! a_fvec = [1;3;2;4];
 %! a_col_1 = [1;3];
 %! a_col_2 = [2;4];
 %! a_row_1 = [1,2];
 %! a_row_2 = [3,4];
 %! assert(all (all (a(:,:) == a)));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/m-2.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [1,2;3,4];
 %! a_fvec = [1;3;2;4];
 %! a_col_1 = [1;3];
 %! a_col_2 = [2;4];
 %! a_row_1 = [1,2];
 %! a_row_2 = [3,4];
 %! assert(all (a(:) == a_fvec));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/m-3.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [1,2;3,4];
 %! a_fvec = [1;3;2;4];
 %! a_col_1 = [1;3];
 %! a_col_2 = [2;4];
 %! a_row_1 = [1,2];
 %! a_row_2 = [3,4];
 %! fail("a(0);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/m-4.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [1,2;3,4];
 %! a_fvec = [1;3;2;4];
 %! a_col_1 = [1;3];
 %! a_col_2 = [2;4];
 %! a_row_1 = [1,2];
 %! a_row_2 = [3,4];
 %! assert(a(2),3);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/misc.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [1,2;3,4];
 %! b = a;
 %! b(:,:,2) = [5,6;7,8];
 %! a1 = [1; 3; 2; 4];
 %! a2 = [1, 3];
 %! a3 = [1, 2; 3, 4];
 %! a4 = [1; 3];
 %! a5 = 1;
@@ -420,10 +420,9 @@
 %! assert(b(:,:,:), b4);
 %! assert(b(:,1,1), b5);
 %! assert(b(:,1,1,[1,1]), b6);
 %! assert(b(1,3), b7);
 %! assert(b(1,[3,4]), b8);
 %! assert(b(1,1:4), b9);
 %! assert(b(1,[],:), b10);
 %! assert(b(1,[]), b11);
-%! warn_fortran_indexing = wfi;
-
+%! warning ("wfi.state", "Octave:fortran-indexing");
diff --git a/test/test_index-wfi-t.m b/test/test_index-wfi-t.m
--- a/test/test_index-wfi-t.m
+++ b/test/test_index-wfi-t.m
@@ -1,365 +1,363 @@
 %% Automatically generated from DejaGNU files
 
 %% test/octave.test/index-wfi-t/s-1.m
 %!test
-%! wfi = warn_fortran_indexing;
+%! wfi = warning ("query", "Octave:fortran-indexing");
 %! warn_fortran_indexing = 1;
 %! a = [];
 %! assert(isempty (a));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-2.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! assert(a(1),1);
-%! warn_fortran_indexing = wfi;
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-3.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! assert(a(:),1);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-4.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! assert(a(:,:),1);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-5.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! assert(a(1,:),1);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-6.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! assert(a(:,1),1);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-7.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! assert(isempty (a(logical (0))));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-8.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a(-1);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-9.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a(2);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-10.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a(2,:);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-11.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a(:,2);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-12.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a(-1,:);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-13.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a(:,-1);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-14.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([1,2,3]);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-15.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([1;2;3]);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-16.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([1,2;3,4]);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-17.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([0,1]);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-18.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([0;1]);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-19.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([-1,0]);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-20.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([-1;0]);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-1.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(a(1),4);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-2.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(a(2),3);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-3.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(all (a(:) == a_prime));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-4.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(all (a(1,:) == a));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-5.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(a(:,3),2);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-6.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(all (a(:,:) == a));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-7.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(all (a(logical ([0,1,1,0])) == mid_a));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-8.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! fail("a(0);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-9.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! fail("a(5);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-10.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! fail("a(0,1);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-11.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(isempty (a(logical (0),:)));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-12.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! fail("a(:,0);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-13.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(isempty (a([])));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-14.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(isempty (a([],:)));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-15.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(isempty (a(:,[])));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/m-1.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [1,2;3,4];
 %! a_fvec = [1;3;2;4];
 %! a_col_1 = [1;3];
 %! a_col_2 = [2;4];
 %! a_row_1 = [1,2];
 %! a_row_2 = [3,4];
 %! assert(all (all (a(:,:) == a)));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/m-2.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [1,2;3,4];
 %! a_fvec = [1;3;2;4];
 %! a_col_1 = [1;3];
 %! a_col_2 = [2;4];
 %! a_row_1 = [1,2];
 %! a_row_2 = [3,4];
 %! assert(all (a(:) == a_fvec));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/m-3.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [1,2;3,4];
 %! a_fvec = [1;3;2;4];
 %! a_col_1 = [1;3];
 %! a_col_2 = [2;4];
 %! a_row_1 = [1,2];
 %! a_row_2 = [3,4];
 %! fail("a(0);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/m-4.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [1,2;3,4];
 %! a_fvec = [1;3;2;4];
 %! a_col_1 = [1;3];
 %! a_col_2 = [2;4];
 %! a_row_1 = [1,2];
 %! a_row_2 = [3,4];
 %! fail("a(2);","warning");
-%! warn_fortran_indexing = wfi;
-
+%! warning ("wfi.state", "Octave:fortran-indexing");
diff --git a/test/test_logical-wfi-f.m b/test/test_logical-wfi-f.m
--- a/test/test_logical-wfi-f.m
+++ b/test/test_logical-wfi-f.m
@@ -1,354 +1,354 @@
 %% Automatically generated from DejaGNU files
 
 %% test/octave.test/logical-wfi-f/s-1.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [];
 %! fail("a(0);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/s-2.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = 2;
 %! assert(a(1) == 2);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/s-3.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = 2;
 %! assert(a(1) == 2);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/s-4.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = 2;
 %! assert(all (a(logical ([1,1])) == [2,2]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/v-1.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8,7,6];
 %! assert(isempty (a(logical ([0,0,0,0]))));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/v-2.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8,7,6];
 %! assert(all (a(logical ([1,1,1,1])) == [9,8,7,6]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/v-3.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8,7,6];
 %! assert(all (a(logical ([0,1,1,0])) == [8,7]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/v-4.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8,7,6];
 %! assert(all (a(logical ([1,1])) == [9,9]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-1.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(isempty (a(logical ([0,0,0,0]))));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-2.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([1,1,1,1])) == [9;7;8;6]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-3.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([0,1,1,0])) == [7;8]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-4.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(logical (0:1),logical (0:1)) == 6);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-5.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical (0:1),2:-1:1) == [6,7]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-6.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(logical (0:1),logical ([0,1])) == 6);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-7.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical (0:1),[2,1]) == [6,7]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-8.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical (0:1),:) == [7,6]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-9.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(logical (0:1),1) == 7);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-10.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical (0:1),logical ([1,1])) == [7,6]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-11.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(2:-1:1,logical (0:1)) == [6;8]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-12.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(2:-1:1,logical ([0,1])) == [6;8]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-13.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a(2:-1:1,logical ([1,1])) == [7,6;9,8])));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-14.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(logical ([0,1]),logical (0:1)) == 6);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-15.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([0,1]),2:-1:1) == [6,7]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-16.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(logical ([0,1]),logical ([0,1])) == 6);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-17.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([0,1]),[2,1]) == [6,7]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-18.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([0,1]),:) == [7,6]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-19.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(logical ([0,1]),1) == 7);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-20.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([0,1]),logical ([1,1])) == [7,6]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-21.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a([2,1],logical (0:1)) == [6;8]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-22.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a([2,1],logical ([0,1])) == [6;8]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-23.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a([2,1],logical ([1,1])) == [7,6;9,8])));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-24.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(:,logical (0:1)) == [8;6]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-25.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(:,logical ([0,1])) == [8;6]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-26.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a(:,logical ([1,1])) == [9,8;7,6])));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-27.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(1,logical (0:1)) == 8);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-28.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(1,logical ([0,1])) == 8);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-29.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(1,logical ([1,1])) == [9,8]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-30.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([1,1]),logical (0:1)) == [8;6]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-31.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a(logical ([1,1]),2:-1:1) == [8,9;6,7])));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-32.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([1,1]),logical ([0,1])) == [8;6]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-33.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a(logical ([1,1]),[2,1]) == [8,9;6,7])));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-34.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a(logical ([1,1]),:) == [9,8;7,6])));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-35.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([1,1]),1) == [9;7]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-36.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 0;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a(logical ([1,1]),logical ([1,1])) == [9,8;7,6])));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
diff --git a/test/test_logical-wfi-t.m b/test/test_logical-wfi-t.m
--- a/test/test_logical-wfi-t.m
+++ b/test/test_logical-wfi-t.m
@@ -1,354 +1,354 @@
 %% Automatically generated from DejaGNU files
 
 %% test/octave.test/logical-wfi-t/s-1.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [];
 %! fail("a(0);");
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/s-2.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = 2;
 %! assert(a(1) == 2);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/s-3.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = 2;
 %! assert(a(1) == 2);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/s-4.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = 2;
 %! assert(all (a(logical ([1,1])) == [2,2]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/v-1.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8,7,6];
 %! assert(isempty (a(logical ([0,0,0,0]))));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/v-2.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8,7,6];
 %! assert(all (a(logical ([1,1,1,1])) == [9,8,7,6]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/v-3.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8,7,6];
 %! assert(all (a(logical ([0,1,1,0])) == [8,7]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/v-4.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8,7,6];
 %! assert(all (a(logical ([1,1])) == [9,9]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-1.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! isempty (a(logical ([0,0,0,0])));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-2.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! all (a(logical ([1,1,1,1])) == [9;7;8;6]);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-3.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! all (a(logical ([0,1,1,0])) == [7;8]);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-4.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(logical (0:1),logical (0:1)) == 6);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-5.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical (0:1),2:-1:1) == [6,7]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-6.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(logical (0:1),logical ([0,1])) == 6);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-7.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical (0:1),[2,1]) == [6,7]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-8.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical (0:1),:) == [7,6]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-9.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(logical (0:1),1) == 7);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-10.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical (0:1),logical ([1,1])) == [7,6]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-11.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(2:-1:1,logical (0:1)) == [6;8]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-12.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(2:-1:1,logical ([0,1])) == [6;8]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-13.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a(2:-1:1,logical ([1,1])) == [7,6;9,8])));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-14.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(logical ([0,1]),logical (0:1)) == 6);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-15.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([0,1]),2:-1:1) == [6,7]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-16.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(logical ([0,1]),logical ([0,1])) == 6);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-17.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([0,1]),[2,1]) == [6,7]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-18.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([0,1]),:) == [7,6]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-19.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(logical ([0,1]),1) == 7);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-20.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([0,1]),logical ([1,1])) == [7,6]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-21.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a([2,1],logical (0:1)) == [6;8]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-22.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a([2,1],logical ([0,1])) == [6;8]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-23.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a([2,1],logical ([1,1])) == [7,6;9,8])));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-24.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(:,logical (0:1)) == [8;6]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-25.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(:,logical ([0,1])) == [8;6]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-26.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a(:,logical ([1,1])) == [9,8;7,6])));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-27.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(1,logical (0:1)) == 8);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-28.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(1,logical ([0,1])) == 8);
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-29.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(1,logical ([1,1])) == [9,8]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-30.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([1,1]),logical (0:1)) == [8;6]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-31.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a(logical ([1,1]),2:-1:1) == [8,9;6,7])));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-32.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([1,1]),logical ([0,1])) == [8;6]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-33.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a(logical ([1,1]),[2,1]) == [8,9;6,7])));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-34.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a(logical ([1,1]),:) == [9,8;7,6])));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-35.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([1,1]),1) == [9;7]));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-36.m
 %!test
-%! wfi = warn_fortran_indexing;
-%! warn_fortran_indexing = 1;
+%! wfi = warning ("query", "Octave:fortran-indexing");
+%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a(logical ([1,1]),logical ([1,1])) == [9,8;7,6])));
-%! warn_fortran_indexing = wfi;
+%! warning ("wfi.state", "Octave:fortran-indexing");
 
diff --git a/test/test_prefer.m b/test/test_prefer.m
--- a/test/test_prefer.m
+++ b/test/test_prefer.m
@@ -49,50 +49,50 @@
 
 %% test/octave.test/prefer/prefer-11.m
 %!test
 %! a = 1;
 %! assert(all ([a -1] == (1:-2:-1)));
 
 %% test/octave.test/prefer/prefer-12.m
 %!test
-%! wsn = warn_str_to_num;
-%! warn_str_to_num = 0;
+%! wsn = warning ("query", "Octave:str-to-num");
+%! warning ("off", "Octave:str-to-num");
 %! assert("d" + 0,100);
-%! warn_str_to_num = wsn;
+%! warning (wsn.state, "Octave:str-to-num");
 
 %% test/octave.test/prefer/prefer-13.m
 %!test
-%! wsn = warn_str_to_num;
-%! warn_str_to_num = 1;
+%! wsn = warning ("query", "Octave:str-to-num");
+%! warning ("on", "Octave:str-to-num");
 %! fail("'d' + 0","warning");
-%! warn_str_to_num = wsn;
+%! warning (wsn.state, "Octave:str-to-num");
 
 %% test/octave.test/prefer/prefer-14.m
 %!test
-%! wir = warn_imag_to_real;
-%! warn_imag_to_real = 0;
+%! wir = warning ("query", "Ocave:imag-to-real");
+%! warning ("off", "Ocave:imag-to-real");
 %! assert(eye (1+i),1);
-%! warn_imag_to_real = wir;
+%! warning (wir.state, "Ocave:imag-to-real");
 
 %% test/octave.test/prefer/prefer-15.m
 %!test
-%! wir = warn_imag_to_real;
-%! warn_imag_to_real = 1;
+%! wir = warning ("query", "Ocave:imag-to-real");
+%! warning ("on", "Ocave:imag-to-real");
 %! fail("eye (1+i)","warning");
-%! warn_imag_to_real = wir;
+%! warning (wir.state, "Ocave:imag-to-real");
 
 %% test/octave.test/prefer/prefer-17.m
 %!test
-%! wrre = warn_resize_on_range_error;
-%! warn_resize_on_range_error = 0;
+%! wrre = warning ("query", "Octave:resize-on-range-error");
+%! warning ("off", "Octave:resize-on-range-error");
 %! clear a; 
 %! a(2) = 1; a(3) = 2; 
 %! assert(all (a == [0,1,2]));
-%! warn_resize_on_range_error = wrre;
+%! warning (wrre.state, "Octave:resize-on-range-error");
 
 %% test/octave.test/prefer/prefer-18.m
 %!test
 %! clear a; 
 %! a(1) = 1; a(2) = 2;
 %! assert(all (a == [1,2]));
 
 %% FIXME How the hell do I test this one in test/assert 
@@ -186,50 +186,50 @@
 %! sf = silent_functions;
 %! silent_functions = 1;
 %! f
 %! assert(??);
 %! silent_functions = sf;
 
 %% test/octave.test/prefer/prefer-32.m
 %!test
-%! wndz = warn_neg_dim_as_zero;
-%! warn_neg_dim_as_zero = 1;
+%! wndz = warning ("query", "Octave:neg-dim-as-zero");
+%! warning ("on", "Octave:neg-dim-as-zero");
 %! fail("eye (-1) == []","warning");
-%! warn_neg_dim_as_zero = wndz;
+%! warning (wndz.state, "Octave:neg-dim-as-zero");
 
 %% test/octave.test/prefer/prefer-33.m
 %!test
-%! wndz = warn_neg_dim_as_zero;
-%! warn_neg_dim_as_zero = 0;
+%! wndz = warning ("query", "Octave:neg-dim-as-zero");
+%! warning ("off", "Octave:neg-dim-as-zero");
 %! assert(all (size (eye (-1)) == [0, 0]));
-%! warn_neg_dim_as_zero = wndz;
+%! warning (wndz.state, "Octave:neg-dim-as-zero");
 
 %% test/octave.test/prefer/prefer-34.m
 %!test
-%! watv = warn_assign_as_truth_value;
-%! warn_assign_as_truth_value = 0;
+%! watv = warning ("query", "Octave:assign-as-truth-value");
+%! warning ("off", "Octave:assign-as-truth-value");
 %! if (x = 1) 1; endif
-%! warn_assign_as_truth_value = watv;
+%! warning (watv.state, "Octave:assign-as-truth-value");
 
 %% test/octave.test/prefer/prefer-35.m
 %!test
-%! watv = warn_assign_as_truth_value;
-%! warn_assign_as_truth_value = 1;
+%! watv = warning ("query", "Octave:assign-as-truth-value");
+%! warning ("on", "Octave:assign-as-truth-value");
 %! fail("if (x = 1) 1; endif","warning");
-%! warn_assign_as_truth_value = watv;
+%! warning (watv.state, "Octave:assign-as-truth-value");
 
 %% test/octave.test/prefer/prefer-38.m
 %!test
-%! wdbz = warn_divide_by_zero;
-%! warn_divide_by_zero = 0;
+%! wdbz = warning ("query", "Octave:divide-by-zero");
+%! warning ("off", "Octave:divide-by-zero");
 %! assert(isinf (1/0));
-%! warn_divide_by_zero = wdbz;
+%! warning (wdbz.state, "Octave:divide-by-zero");
 
 %% test/octave.test/prefer/prefer-39.m
 %!test
-%! wdbz = warn_divide_by_zero;
-%! warn_divide_by_zero = 1;
+%! wdbz = warning ("query", "Octave:divide-by-zero");
+%! warning ("on", "Octave:divide-by-zero");
 %! a = 1;
 %! b = 0;
 %! fail("isinf (a/b);","warning")
-%! warn_divide_by_zero = wdbz;
+%! warning (wdbz.state, "Octave:divide-by-zero");
 
diff --git a/test/test_system.m b/test/test_system.m
--- a/test/test_system.m
+++ b/test/test_system.m
@@ -419,38 +419,38 @@
 %% test/octave.test/system/getenv-2.m
 %!error <Invalid call to getenv.*> getenv ();
 
 %% test/octave.test/system/getenv-3.m
 %!error <Invalid call to getenv.*> getenv ("foo", 1);
 
 %% test/octave.test/system/getenv-4.m
 %!test
-%! wns = warn_num_to_str;
-%! warn_num_to_str = 1;
+%! wns = warning ("query", "Octave:num-to-str");
+%! warning ("on", "Octave:num-to-str");
 %! fail("getenv (1)","warning");
-%! warn_num_to_str = wns;
+%! warning (wns.state, "Octave:num-to-str");
 
 %% test/octave.test/system/putenv-1.m
 %!test
 %! putenv ("foobar", "baz");
 %! assert(strcmp (getenv ("foobar"), "baz"));
 
 %% test/octave.test/system/putenv-2.m
 %!error <Invalid call to putenv.*> putenv ();
 
 %% test/octave.test/system/putenv-3.m
 %!error <Invalid call to putenv.*> putenv ("foo", "bar", 1);
 
 %% test/octave.test/system/putenv-4.m
 %!test
-%! wns = warn_num_to_str;
-%! warn_num_to_str = 1;
+%! wns = warning ("query", "Octave:num-to-str");
+%! warning ("on", "Octave:num-to-str");
 %! fail("putenv (1, 2)","warning");
-%! warn_num_to_str = wns;
+%! warning (wns.state, "Octave:num-to-str");
 
 %% test/octave.test/system/cd-1.m
 %!test
 %! xdir = pwd ();
 %! cd /
 %! d1 = pwd ();
 %! cd (xdir);
 %! assert("/", d1);
