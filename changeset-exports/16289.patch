# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1363063607 14400
#      Tue Mar 12 00:46:47 2013 -0400
# Branch classdef
# Node ID bde729ba838137c6db9503f3f0f19385bb8bc2f7
# Parent  f58257a6d18c024a143995db6412d0d6b99afb8e
# Parent  fe3b9a51e625a4c50c77a3c3a11c5dc243558c12
maint: periodic merge of default to classdef

diff --git a/libinterp/interpfcn/input.cc b/libinterp/interpfcn/input.cc
--- a/libinterp/interpfcn/input.cc
+++ b/libinterp/interpfcn/input.cc
@@ -118,17 +118,17 @@ static std::string last_debugging_comman
 static bool Vgud_mode = false;
 
 // The filemarker used to separate filenames from subfunction names
 char Vfilemarker = '>';
 
 void
 octave_base_reader::do_input_echo (const std::string& input_string) const
 {
-  int do_echo = CURR_LEXER->reading_script_file ?
+  int do_echo = LEXER->reading_script_file ?
     (Vecho_executing_commands & ECHO_SCRIPTS)
       : (Vecho_executing_commands & ECHO_CMD_LINE) && ! forced_interactive;
 
   if (do_echo)
     {
       if (forced_interactive)
         {
           if (pflag > 0)
@@ -490,27 +490,27 @@ get_debug_input (const std::string& prom
     std::cerr << msg << std::endl;
 
   unwind_protect frame;
 
   frame.protect_var (VPS1);
   VPS1 = prompt;
 
   if (! (interactive || forced_interactive)
-      || CURR_LEXER->reading_fcn_file
-      || CURR_LEXER->reading_classdef_file
-      || CURR_LEXER->reading_script_file
-      || CURR_LEXER->input_from_eval_string ())
+      || LEXER->reading_fcn_file
+      || LEXER->reading_classdef_file
+      || LEXER->reading_script_file
+      || LEXER->input_from_eval_string ())
     {
       frame.protect_var (forced_interactive);
       forced_interactive = true;
     }
 
   // octave_parser constructor sets this for us.
-  frame.protect_var (CURR_LEXER);
+  frame.protect_var (LEXER);
 
   octave_parser curr_parser;
 
   while (Vdebugging)
     {
       unwind_protect middle_frame;
 
       reset_error_handler ();
diff --git a/libinterp/interpfcn/toplev.cc b/libinterp/interpfcn/toplev.cc
--- a/libinterp/interpfcn/toplev.cc
+++ b/libinterp/interpfcn/toplev.cc
@@ -555,41 +555,41 @@ main_loop (void)
 
   octave_initialized = true;
 
   // The big loop.
 
   unwind_protect frame;
 
   // octave_parser constructor sets this for us.
-  frame.protect_var (CURR_LEXER);
+  frame.protect_var (LEXER);
 
-  octave_parser curr_parser;
+  octave_parser parser;
 
   int retval = 0;
   do
     {
       try
         {
           unwind_protect inner_frame;
 
           reset_error_handler ();
 
-          curr_parser.reset ();
+          parser.reset ();
 
           if (symbol_table::at_top_level ())
             tree_evaluator::reset_debug_state ();
 
-          retval = curr_parser.run ();
+          retval = parser.run ();
 
           if (retval == 0)
             {
-              if (curr_parser.stmt_list)
+              if (parser.stmt_list)
                 {
-                  curr_parser.stmt_list->accept (*current_evaluator);
+                  parser.stmt_list->accept (*current_evaluator);
 
                   octave_quit ();
 
                   if (! (interactive || forced_interactive))
                     {
                       bool quit = (tree_return_command::returning
                                    || tree_break_command::breaking);
 
@@ -615,17 +615,17 @@ main_loop (void)
                   else
                     {
                       if (octave_completion_matches_called)
                         octave_completion_matches_called = false;
                       else
                         command_editor::increment_current_command_number ();
                     }
                 }
-              else if (curr_parser.curr_lexer->end_of_input)
+              else if (parser.lexer.end_of_input)
                 break;
             }
         }
       catch (octave_interrupt_exception)
         {
           recover_from_exception ();
           octave_stdout << "\n";
           if (quitting_gracefully)
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -81,17 +81,17 @@ along with Octave; see the file COPYING.
 
 // oct-parse.h must be included after pt-all.h
 #include <oct-parse.h>
 
 extern int octave_lex (YYSTYPE *, void *);
 
 // Global access to currently active lexer.
 // FIXME -- to be removed after more parser+lexer refactoring.
-octave_lexer *CURR_LEXER = 0;
+octave_lexer *LEXER = 0;
 
 #if defined (GNULIB_NAMESPACE)
 // Calls to the following functions appear in the generated output from
 // Bison without the namespace tag.  Redefine them so we will use them
 // via the gnulib namespace.
 #define fclose GNULIB_NAMESPACE::fclose
 #define fprintf GNULIB_NAMESPACE::fprintf
 #define malloc GNULIB_NAMESPACE::malloc
@@ -104,17 +104,17 @@ bool reading_startup_message_printed = f
 symtab_context parser_symtab_context;
 
 // List of autoloads (function -> file mapping).
 static std::map<std::string, std::string> autoload_map;
 
 // Forward declarations for some functions defined at the bottom of
 // the file.
 
-static void yyerror (octave_parser& curr_parser, const char *s);
+static void yyerror (octave_base_parser& parser, const char *s);
 
 // Finish building a statement.
 template <class T>
 static tree_statement *
 make_statement (T *arg)
 {
   octave_comment_list *comment = octave_comment_buffer::get_comment ();
 
@@ -123,25 +123,25 @@ make_statement (T *arg)
 
 #define ABORT_PARSE \
   do \
     { \
       yyerrok; \
       if (! parser_symtab_context.empty ()) \
         parser_symtab_context.pop (); \
       if ((interactive || forced_interactive)   \
-          && ! (curr_lexer)->input_from_eval_string ()) \
+          && ! lexer.input_from_eval_string ()) \
         YYACCEPT; \
       else \
         YYABORT; \
     } \
   while (0)
 
-#define curr_lexer curr_parser.curr_lexer
-#define scanner curr_lexer->scanner
+#define lexer parser.lexer
+#define scanner lexer.scanner
 
 %}
 
 // Bison declarations.
 
 // Don't add spaces around the = here; it causes some versions of
 // bison to fail to properly recognize the directive.
 
@@ -153,17 +153,17 @@ make_statement (T *arg)
 // safe to create a parser object and call it while anotehr parser
 // object is active (to parse a callback function while the main
 // interactive parser is waiting for input, for example) if you take
 // care to properly save and restore (typically with an unwind_protect
 // object) relevant global values before and after the nested call.
 
 %define api.pure
 %PUSH_PULL_DECL%
-%parse-param { octave_parser& curr_parser }
+%parse-param { octave_base_parser& parser }
 %lex-param { void *scanner }
 
 %union
 {
   // The type of the basic tokens returned by the lexer.
   token *tok_val;
 
   // Comment strings that we need to deal with mid-rule.
@@ -333,64 +333,64 @@ make_statement (T *arg)
 %%
 
 // ==============================
 // Statements and statement lists
 // ==============================
 
 input           : input1
                   {
-                    curr_parser.stmt_list = $1;
+                    parser.stmt_list = $1;
                     YYACCEPT;
                   }
                 | simple_list parse_error
                   { ABORT_PARSE; }
                 | parse_error
                   { ABORT_PARSE; }
                 ;
 
 input1          : '\n'
                   { $$ = 0; }
                 | END_OF_INPUT
                   {
-                    curr_lexer->end_of_input = true;
+                    lexer.end_of_input = true;
                     $$ = 0;
                   }
                 | simple_list
                   { $$ = $1; }
                 | simple_list '\n'
                   { $$ = $1; }
                 | simple_list END_OF_INPUT
                   { $$ = $1; }
                 ;
 
 simple_list     : simple_list1 opt_sep_no_nl
-                  { $$ = curr_parser.set_stmt_print_flag ($1, $2, false); }
+                  { $$ = parser.set_stmt_print_flag ($1, $2, false); }
                 ;
 
 simple_list1    : statement
-                  { $$ = curr_parser.make_statement_list ($1); }
+                  { $$ = parser.make_statement_list ($1); }
                 | simple_list1 sep_no_nl statement
-                  { $$ = curr_parser.append_statement_list ($1, $2, $3, false); }
+                  { $$ = parser.append_statement_list ($1, $2, $3, false); }
                 ;
 
 opt_list        : // empty
                   { $$ = new tree_statement_list (); }
                 | list
                   { $$ = $1; }
                 ;
 
 list            : list1 opt_sep
-                  { $$ = curr_parser.set_stmt_print_flag ($1, $2, true); }
+                  { $$ = parser.set_stmt_print_flag ($1, $2, true); }
                 ;
 
 list1           : statement
-                  { $$ = curr_parser.make_statement_list ($1); }
+                  { $$ = parser.make_statement_list ($1); }
                 | list1 sep statement
-                  { $$ = curr_parser.append_statement_list ($1, $2, $3, true); }
+                  { $$ = parser.append_statement_list ($1, $2, $3, true); }
                 ;
 
 statement       : expression
                   { $$ = make_statement ($1); }
                 | command
                   { $$ = make_statement ($1); }
                 | word_list_cmd
                   { $$ = make_statement ($1); }
@@ -400,17 +400,17 @@ statement       : expression
 // Word-list command
 // =================
 
 // These are not really like expressions since they can't appear on
 // the RHS of an assignment.  But they are also not like commands (IF,
 // WHILE, etc.
 
 word_list_cmd   : identifier word_list
-                  { $$ = curr_parser.make_index_expression ($1, $2, '('); }
+                  { $$ = parser.make_index_expression ($1, $2, '('); }
                 ;
 
 word_list       : string
                   { $$ = new tree_argument_list ($1); }
                 | word_list string
                   {
                     $1->append ($2);
                     $$ = $1;
@@ -430,55 +430,55 @@ identifier      : NAME
 
 superclass_identifier
                 : SUPERCLASSREF
                   {
                     std::string method_nm = $1->superclass_method_name ();
                     std::string package_nm = $1->superclass_package_name ();
                     std::string class_nm = $1->superclass_class_name ();
 
-                    $$ = curr_parser.make_superclass_ref
+                    $$ = parser.make_superclass_ref
                                        (method_nm, package_nm, class_nm,
                                         $1->line (), $1->column ());
                   }
                 ;
 
 meta_identifier : METAQUERY
                   {
                     std::string package_nm = $1->meta_package_name ();
                     std::string class_nm = $1->meta_class_name ();
 
-                    $$ = curr_parser.make_meta_class_query
+                    $$ = parser.make_meta_class_query
                                        (package_nm, class_nm,
                                         $1->line (), $1->column ());
                   }
                 ;
 
 string          : DQ_STRING
-                  { $$ = curr_parser.make_constant (DQ_STRING, $1); }
+                  { $$ = parser.make_constant (DQ_STRING, $1); }
                 | SQ_STRING
-                  { $$ = curr_parser.make_constant (SQ_STRING, $1); }
+                  { $$ = parser.make_constant (SQ_STRING, $1); }
                 ;
 
 constant        : NUM
-                  { $$ = curr_parser.make_constant (NUM, $1); }
+                  { $$ = parser.make_constant (NUM, $1); }
                 | IMAG_NUM
-                  { $$ = curr_parser.make_constant (IMAG_NUM, $1); }
+                  { $$ = parser.make_constant (IMAG_NUM, $1); }
                 | string
                   { $$ = $1; }
                 ;
 
 matrix          : '[' ']'
                   { $$ = new tree_constant (octave_null_matrix::instance); }
                 | '[' ';' ']'
                   { $$ = new tree_constant (octave_null_matrix::instance); }
                 | '[' ',' ']'
                   { $$ = new tree_constant (octave_null_matrix::instance); }
                 | '[' matrix_rows ']'
-                  { $$ = curr_parser.finish_matrix ($2); }
+                  { $$ = parser.finish_matrix ($2); }
                 ;
 
 matrix_rows     : matrix_rows1
                   { $$ = $1; }
                 | matrix_rows1 ';'      // Ignore trailing semicolon.
                   { $$ = $1; }
                 ;
 
@@ -491,17 +491,17 @@ matrix_rows1    : cell_or_matrix_row
                   }
                 ;
 
 cell            : '{' '}'
                   { $$ = new tree_constant (octave_value (Cell ())); }
                 | '{' ';' '}'
                   { $$ = new tree_constant (octave_value (Cell ())); }
                 | '{' cell_rows '}'
-                  { $$ = curr_parser.finish_cell ($2); }
+                  { $$ = parser.finish_cell ($2); }
                 ;
 
 cell_rows       : cell_rows1
                   { $$ = $1; }
                 | cell_rows1 ';'        // Ignore trailing semicolon.
                   { $$ = $1; }
                 ;
 
@@ -518,37 +518,37 @@ cell_or_matrix_row
                 : arg_list
                   { $$ = $1; }
                 | arg_list ','          // Ignore trailing comma.
                   { $$ = $1; }
                 ;
 
 fcn_handle      : '@' FCN_HANDLE
                   {
-                    $$ = curr_parser.make_fcn_handle ($2);
-                    curr_lexer->looking_at_function_handle--;
+                    $$ = parser.make_fcn_handle ($2);
+                    lexer.looking_at_function_handle--;
                   }
                 ;
 
 anon_fcn_handle : '@' param_list statement
                   {
-                    $$ = curr_parser.make_anon_fcn_handle ($2, $3);
-                    curr_lexer->nesting_level.remove ();
+                    $$ = parser.make_anon_fcn_handle ($2, $3);
+                    lexer.nesting_level.remove ();
                   }
                 ;
 
 primary_expr    : identifier
                   { $$ = $1; }
                 | constant
                   { $$ = $1; }
                 | fcn_handle
                   { $$ = $1; }
                 | matrix
                   {
-                    curr_lexer->looking_at_matrix_or_assign_lhs = false;
+                    lexer.looking_at_matrix_or_assign_lhs = false;
                     $$ = $1;
                   }
                 | cell
                   { $$ = $1; }
                 | meta_identifier
                   { $$ = $1; }
                 | superclass_identifier
                   { $$ = $1; }
@@ -588,169 +588,169 @@ arg_list        : expression
                 | arg_list ',' expression
                   {
                     $1->append ($3);
                     $$ = $1;
                   }
                 ;
 
 indirect_ref_op : '.'
-                  { curr_lexer->looking_at_indirect_ref = true; }
+                  { lexer.looking_at_indirect_ref = true; }
                 ;
 
 oper_expr       : primary_expr
                   { $$ = $1; }
                 | oper_expr PLUS_PLUS
-                  { $$ = curr_parser.make_postfix_op (PLUS_PLUS, $1, $2); }
+                  { $$ = parser.make_postfix_op (PLUS_PLUS, $1, $2); }
                 | oper_expr MINUS_MINUS
-                  { $$ = curr_parser.make_postfix_op (MINUS_MINUS, $1, $2); }
+                  { $$ = parser.make_postfix_op (MINUS_MINUS, $1, $2); }
                 | oper_expr '(' ')'
-                  { $$ = curr_parser.make_index_expression ($1, 0, '('); }
+                  { $$ = parser.make_index_expression ($1, 0, '('); }
                 | oper_expr '(' arg_list ')'
-                  { $$ = curr_parser.make_index_expression ($1, $3, '('); }
+                  { $$ = parser.make_index_expression ($1, $3, '('); }
                 | oper_expr '{' '}'
-                  { $$ = curr_parser.make_index_expression ($1, 0, '{'); }
+                  { $$ = parser.make_index_expression ($1, 0, '{'); }
                 | oper_expr '{' arg_list '}'
-                  { $$ = curr_parser.make_index_expression ($1, $3, '{'); }
+                  { $$ = parser.make_index_expression ($1, $3, '{'); }
                 | oper_expr HERMITIAN
-                  { $$ = curr_parser.make_postfix_op (HERMITIAN, $1, $2); }
+                  { $$ = parser.make_postfix_op (HERMITIAN, $1, $2); }
                 | oper_expr TRANSPOSE
-                  { $$ = curr_parser.make_postfix_op (TRANSPOSE, $1, $2); }
+                  { $$ = parser.make_postfix_op (TRANSPOSE, $1, $2); }
                 | oper_expr indirect_ref_op STRUCT_ELT
-                  { $$ = curr_parser.make_indirect_ref ($1, $3->text ()); }
+                  { $$ = parser.make_indirect_ref ($1, $3->text ()); }
                 | oper_expr indirect_ref_op '(' expression ')'
-                  { $$ = curr_parser.make_indirect_ref ($1, $4); }
+                  { $$ = parser.make_indirect_ref ($1, $4); }
                 | PLUS_PLUS oper_expr %prec UNARY
-                  { $$ = curr_parser.make_prefix_op (PLUS_PLUS, $2, $1); }
+                  { $$ = parser.make_prefix_op (PLUS_PLUS, $2, $1); }
                 | MINUS_MINUS oper_expr %prec UNARY
-                  { $$ = curr_parser.make_prefix_op (MINUS_MINUS, $2, $1); }
+                  { $$ = parser.make_prefix_op (MINUS_MINUS, $2, $1); }
                 | EXPR_NOT oper_expr %prec UNARY
-                  { $$ = curr_parser.make_prefix_op (EXPR_NOT, $2, $1); }
+                  { $$ = parser.make_prefix_op (EXPR_NOT, $2, $1); }
                 | '+' oper_expr %prec UNARY
-                  { $$ = curr_parser.make_prefix_op ('+', $2, $1); }
+                  { $$ = parser.make_prefix_op ('+', $2, $1); }
                 | '-' oper_expr %prec UNARY
-                  { $$ = curr_parser.make_prefix_op ('-', $2, $1); }
+                  { $$ = parser.make_prefix_op ('-', $2, $1); }
                 | oper_expr POW oper_expr
-                  { $$ = curr_parser.make_binary_op (POW, $1, $2, $3); }
+                  { $$ = parser.make_binary_op (POW, $1, $2, $3); }
                 | oper_expr EPOW oper_expr
-                  { $$ = curr_parser.make_binary_op (EPOW, $1, $2, $3); }
+                  { $$ = parser.make_binary_op (EPOW, $1, $2, $3); }
                 | oper_expr '+' oper_expr
-                  { $$ = curr_parser.make_binary_op ('+', $1, $2, $3); }
+                  { $$ = parser.make_binary_op ('+', $1, $2, $3); }
                 | oper_expr '-' oper_expr
-                  { $$ = curr_parser.make_binary_op ('-', $1, $2, $3); }
+                  { $$ = parser.make_binary_op ('-', $1, $2, $3); }
                 | oper_expr '*' oper_expr
-                  { $$ = curr_parser.make_binary_op ('*', $1, $2, $3); }
+                  { $$ = parser.make_binary_op ('*', $1, $2, $3); }
                 | oper_expr '/' oper_expr
-                  { $$ = curr_parser.make_binary_op ('/', $1, $2, $3); }
+                  { $$ = parser.make_binary_op ('/', $1, $2, $3); }
                 | oper_expr EPLUS oper_expr
-                  { $$ = curr_parser.make_binary_op ('+', $1, $2, $3); }
+                  { $$ = parser.make_binary_op ('+', $1, $2, $3); }
                 | oper_expr EMINUS oper_expr
-                  { $$ = curr_parser.make_binary_op ('-', $1, $2, $3); }
+                  { $$ = parser.make_binary_op ('-', $1, $2, $3); }
                 | oper_expr EMUL oper_expr
-                  { $$ = curr_parser.make_binary_op (EMUL, $1, $2, $3); }
+                  { $$ = parser.make_binary_op (EMUL, $1, $2, $3); }
                 | oper_expr EDIV oper_expr
-                  { $$ = curr_parser.make_binary_op (EDIV, $1, $2, $3); }
+                  { $$ = parser.make_binary_op (EDIV, $1, $2, $3); }
                 | oper_expr LEFTDIV oper_expr
-                  { $$ = curr_parser.make_binary_op (LEFTDIV, $1, $2, $3); }
+                  { $$ = parser.make_binary_op (LEFTDIV, $1, $2, $3); }
                 | oper_expr ELEFTDIV oper_expr
-                  { $$ = curr_parser.make_binary_op (ELEFTDIV, $1, $2, $3); }
+                  { $$ = parser.make_binary_op (ELEFTDIV, $1, $2, $3); }
                 ;
 
 colon_expr      : colon_expr1
-                  { $$ = curr_parser.finish_colon_expression ($1); }
+                  { $$ = parser.finish_colon_expression ($1); }
                 ;
 
 colon_expr1     : oper_expr
                   { $$ = new tree_colon_expression ($1); }
                 | colon_expr1 ':' oper_expr
                   {
                     if (! ($$ = $1->append ($3)))
                       ABORT_PARSE;
                   }
                 ;
 
 simple_expr     : colon_expr
                   { $$ = $1; }
                 | simple_expr LSHIFT simple_expr
-                  { $$ = curr_parser.make_binary_op (LSHIFT, $1, $2, $3); }
+                  { $$ = parser.make_binary_op (LSHIFT, $1, $2, $3); }
                 | simple_expr RSHIFT simple_expr
-                  { $$ = curr_parser.make_binary_op (RSHIFT, $1, $2, $3); }
+                  { $$ = parser.make_binary_op (RSHIFT, $1, $2, $3); }
                 | simple_expr EXPR_LT simple_expr
-                  { $$ = curr_parser.make_binary_op (EXPR_LT, $1, $2, $3); }
+                  { $$ = parser.make_binary_op (EXPR_LT, $1, $2, $3); }
                 | simple_expr EXPR_LE simple_expr
-                  { $$ = curr_parser.make_binary_op (EXPR_LE, $1, $2, $3); }
+                  { $$ = parser.make_binary_op (EXPR_LE, $1, $2, $3); }
                 | simple_expr EXPR_EQ simple_expr
-                  { $$ = curr_parser.make_binary_op (EXPR_EQ, $1, $2, $3); }
+                  { $$ = parser.make_binary_op (EXPR_EQ, $1, $2, $3); }
                 | simple_expr EXPR_GE simple_expr
-                  { $$ = curr_parser.make_binary_op (EXPR_GE, $1, $2, $3); }
+                  { $$ = parser.make_binary_op (EXPR_GE, $1, $2, $3); }
                 | simple_expr EXPR_GT simple_expr
-                  { $$ = curr_parser.make_binary_op (EXPR_GT, $1, $2, $3); }
+                  { $$ = parser.make_binary_op (EXPR_GT, $1, $2, $3); }
                 | simple_expr EXPR_NE simple_expr
-                  { $$ = curr_parser.make_binary_op (EXPR_NE, $1, $2, $3); }
+                  { $$ = parser.make_binary_op (EXPR_NE, $1, $2, $3); }
                 | simple_expr EXPR_AND simple_expr
-                  { $$ = curr_parser.make_binary_op (EXPR_AND, $1, $2, $3); }
+                  { $$ = parser.make_binary_op (EXPR_AND, $1, $2, $3); }
                 | simple_expr EXPR_OR simple_expr
-                  { $$ = curr_parser.make_binary_op (EXPR_OR, $1, $2, $3); }
+                  { $$ = parser.make_binary_op (EXPR_OR, $1, $2, $3); }
                 | simple_expr EXPR_AND_AND simple_expr
-                  { $$ = curr_parser.make_boolean_op (EXPR_AND_AND, $1, $2, $3); }
+                  { $$ = parser.make_boolean_op (EXPR_AND_AND, $1, $2, $3); }
                 | simple_expr EXPR_OR_OR simple_expr
-                  { $$ = curr_parser.make_boolean_op (EXPR_OR_OR, $1, $2, $3); }
+                  { $$ = parser.make_boolean_op (EXPR_OR_OR, $1, $2, $3); }
                 ;
 
 assign_lhs      : simple_expr
                   {
-                    $$ = curr_parser.validate_matrix_for_assignment ($1);
+                    $$ = parser.validate_matrix_for_assignment ($1);
 
                     if ($$)
-                      { curr_lexer->looking_at_matrix_or_assign_lhs = false; }
+                      { lexer.looking_at_matrix_or_assign_lhs = false; }
                     else
                       {
                         // validate_matrix_for_assignment deleted $1.
                         ABORT_PARSE;
                       }
                   }
                 ;
 
 assign_expr     : assign_lhs '=' expression
-                  { $$ = curr_parser.make_assign_op ('=', $1, $2, $3); }
+                  { $$ = parser.make_assign_op ('=', $1, $2, $3); }
                 | assign_lhs ADD_EQ expression
-                  { $$ = curr_parser.make_assign_op (ADD_EQ, $1, $2, $3); }
+                  { $$ = parser.make_assign_op (ADD_EQ, $1, $2, $3); }
                 | assign_lhs SUB_EQ expression
-                  { $$ = curr_parser.make_assign_op (SUB_EQ, $1, $2, $3); }
+                  { $$ = parser.make_assign_op (SUB_EQ, $1, $2, $3); }
                 | assign_lhs MUL_EQ expression
-                  { $$ = curr_parser.make_assign_op (MUL_EQ, $1, $2, $3); }
+                  { $$ = parser.make_assign_op (MUL_EQ, $1, $2, $3); }
                 | assign_lhs DIV_EQ expression
-                  { $$ = curr_parser.make_assign_op (DIV_EQ, $1, $2, $3); }
+                  { $$ = parser.make_assign_op (DIV_EQ, $1, $2, $3); }
                 | assign_lhs LEFTDIV_EQ expression
-                  { $$ = curr_parser.make_assign_op (LEFTDIV_EQ, $1, $2, $3); }
+                  { $$ = parser.make_assign_op (LEFTDIV_EQ, $1, $2, $3); }
                 | assign_lhs POW_EQ expression
-                  { $$ = curr_parser.make_assign_op (POW_EQ, $1, $2, $3); }
+                  { $$ = parser.make_assign_op (POW_EQ, $1, $2, $3); }
                 | assign_lhs LSHIFT_EQ expression
-                  { $$ = curr_parser.make_assign_op (LSHIFT_EQ, $1, $2, $3); }
+                  { $$ = parser.make_assign_op (LSHIFT_EQ, $1, $2, $3); }
                 | assign_lhs RSHIFT_EQ expression
-                  { $$ = curr_parser.make_assign_op (RSHIFT_EQ, $1, $2, $3); }
+                  { $$ = parser.make_assign_op (RSHIFT_EQ, $1, $2, $3); }
                 | assign_lhs EMUL_EQ expression
-                  { $$ = curr_parser.make_assign_op (EMUL_EQ, $1, $2, $3); }
+                  { $$ = parser.make_assign_op (EMUL_EQ, $1, $2, $3); }
                 | assign_lhs EDIV_EQ expression
-                  { $$ = curr_parser.make_assign_op (EDIV_EQ, $1, $2, $3); }
+                  { $$ = parser.make_assign_op (EDIV_EQ, $1, $2, $3); }
                 | assign_lhs ELEFTDIV_EQ expression
-                  { $$ = curr_parser.make_assign_op (ELEFTDIV_EQ, $1, $2, $3); }
+                  { $$ = parser.make_assign_op (ELEFTDIV_EQ, $1, $2, $3); }
                 | assign_lhs EPOW_EQ expression
-                  { $$ = curr_parser.make_assign_op (EPOW_EQ, $1, $2, $3); }
+                  { $$ = parser.make_assign_op (EPOW_EQ, $1, $2, $3); }
                 | assign_lhs AND_EQ expression
-                  { $$ = curr_parser.make_assign_op (AND_EQ, $1, $2, $3); }
+                  { $$ = parser.make_assign_op (AND_EQ, $1, $2, $3); }
                 | assign_lhs OR_EQ expression
-                  { $$ = curr_parser.make_assign_op (OR_EQ, $1, $2, $3); }
+                  { $$ = parser.make_assign_op (OR_EQ, $1, $2, $3); }
                 ;
 
 expression      : simple_expr
                   {
                     if ($1 && ($1->is_matrix () || $1->is_cell ()))
                       {
-                        if (curr_parser.validate_array_list ($1))
+                        if (parser.validate_array_list ($1))
                           $$ = $1;
                         else
                           {
                             delete $1;
                             ABORT_PARSE;
                           }
                       }
                     else
@@ -783,43 +783,43 @@ command         : declaration
                 ;
 
 // =====================
 // Declaration statemnts
 // =====================
 
 declaration     : GLOBAL decl1
                   {
-                    $$ = curr_parser.make_decl_command (GLOBAL, $1, $2);
-                    curr_lexer->looking_at_decl_list = false;
+                    $$ = parser.make_decl_command (GLOBAL, $1, $2);
+                    lexer.looking_at_decl_list = false;
                   }
                 | PERSISTENT decl1
                   {
-                    $$ = curr_parser.make_decl_command (PERSISTENT, $1, $2);
-                    curr_lexer->looking_at_decl_list = false;
+                    $$ = parser.make_decl_command (PERSISTENT, $1, $2);
+                    lexer.looking_at_decl_list = false;
                   }
                 ;
 
 decl1           : decl2
                   { $$ = new tree_decl_init_list ($1); }
                 | decl1 decl2
                   {
                     $1->append ($2);
                     $$ = $1;
                   }
                 ;
 
 decl_param_init : // empty
-                { curr_lexer->looking_at_initializer_expression = true; }
+                { lexer.looking_at_initializer_expression = true; }
 
 decl2           : identifier
                   { $$ = new tree_decl_elt ($1); }
                 | identifier '=' decl_param_init expression
                   {
-                    curr_lexer->looking_at_initializer_expression = false;
+                    lexer.looking_at_initializer_expression = false;
                     $$ = new tree_decl_elt ($1, $4);
                   }
                 | magic_tilde
                   {
                     $$ = new tree_decl_elt ($1);
                   }
                 ;
 
@@ -834,62 +834,62 @@ select_command  : if_command
                 ;
 
 // ============
 // If statement
 // ============
 
 if_command      : IF stash_comment if_cmd_list END
                   {
-                    if (! ($$ = curr_parser.finish_if_command ($1, $3, $4, $2)))
+                    if (! ($$ = parser.finish_if_command ($1, $3, $4, $2)))
                       ABORT_PARSE;
                   }
                 ;
 
 if_cmd_list     : if_cmd_list1
                   { $$ = $1; }
                 | if_cmd_list1 else_clause
                   {
                     $1->append ($2);
                     $$ = $1;
                   }
                 ;
 
 if_cmd_list1    : expression opt_sep opt_list
                   {
-                    $1->mark_braindead_shortcircuit (curr_lexer->fcn_file_full_name);
-
-                    $$ = curr_parser.start_if_command ($1, $3);
+                    $1->mark_braindead_shortcircuit (lexer.fcn_file_full_name);
+
+                    $$ = parser.start_if_command ($1, $3);
                   }
                 | if_cmd_list1 elseif_clause
                   {
                     $1->append ($2);
                     $$ = $1;
                   }
                 ;
 
 elseif_clause   : ELSEIF stash_comment opt_sep expression opt_sep opt_list
                   {
-                    $4->mark_braindead_shortcircuit (curr_lexer->fcn_file_full_name);
-
-                    $$ = curr_parser.make_elseif_clause ($1, $4, $6, $2);
+                    $4->mark_braindead_shortcircuit (lexer.fcn_file_full_name);
+
+                    $$ = parser.make_elseif_clause ($1, $4, $6, $2);
                   }
                 ;
 
 else_clause     : ELSE stash_comment opt_sep opt_list
                   { $$ = new tree_if_clause ($4, $2); }
                 ;
 
 // ================
 // Switch statement
 // ================
 
 switch_command  : SWITCH stash_comment expression opt_sep case_list END
                   {
-                    if (! ($$ = curr_parser.finish_switch_command ($1, $3, $5, $6, $2)))
+                    if (! ($$ = parser.finish_switch_command ($1, $3, $5, $6, $2)))
                       ABORT_PARSE;
                   }
                 ;
 
 case_list       : // empty
                   { $$ = new tree_switch_case_list (); }
                 | default_case
                   { $$ = new tree_switch_case_list ($1); }
@@ -907,169 +907,169 @@ case_list1      : switch_case
                 | case_list1 switch_case
                   {
                     $1->append ($2);
                     $$ = $1;
                   }
                 ;
 
 switch_case     : CASE stash_comment opt_sep expression opt_sep opt_list
-                  { $$ = curr_parser.make_switch_case ($1, $4, $6, $2); }
+                  { $$ = parser.make_switch_case ($1, $4, $6, $2); }
                 ;
 
 default_case    : OTHERWISE stash_comment opt_sep opt_list
                   {
                     $$ = new tree_switch_case ($4, $2);
                   }
                 ;
 
 // =======
 // Looping
 // =======
 
 loop_command    : WHILE stash_comment expression opt_sep opt_list END
                   {
-                    $3->mark_braindead_shortcircuit (curr_lexer->fcn_file_full_name);
-
-                    if (! ($$ = curr_parser.make_while_command ($1, $3, $5, $6, $2)))
+                    $3->mark_braindead_shortcircuit (lexer.fcn_file_full_name);
+
+                    if (! ($$ = parser.make_while_command ($1, $3, $5, $6, $2)))
                       ABORT_PARSE;
                   }
                 | DO stash_comment opt_sep opt_list UNTIL expression
                   {
-                    if (! ($$ = curr_parser.make_do_until_command ($5, $4, $6, $2)))
+                    if (! ($$ = parser.make_do_until_command ($5, $4, $6, $2)))
                       ABORT_PARSE;
                   }
                 | FOR stash_comment assign_lhs '=' expression opt_sep opt_list END
                   {
-                    if (! ($$ = curr_parser.make_for_command (FOR, $1, $3, $5, 0,
+                    if (! ($$ = parser.make_for_command (FOR, $1, $3, $5, 0,
                                                   $7, $8, $2)))
                       ABORT_PARSE;
                   }
                 | FOR stash_comment '(' assign_lhs '=' expression ')' opt_sep opt_list END
                   {
-                    if (! ($$ = curr_parser.make_for_command (FOR, $1, $4, $6, 0,
+                    if (! ($$ = parser.make_for_command (FOR, $1, $4, $6, 0,
                                                   $9, $10, $2)))
                       ABORT_PARSE;
                   }
                 | PARFOR stash_comment assign_lhs '=' expression opt_sep opt_list END
                   {
-                    if (! ($$ = curr_parser.make_for_command (PARFOR, $1, $3, $5,
+                    if (! ($$ = parser.make_for_command (PARFOR, $1, $3, $5,
                                                   0, $7, $8, $2)))
                       ABORT_PARSE;
                   }
                 | PARFOR stash_comment '(' assign_lhs '=' expression ',' expression ')' opt_sep opt_list END
                   {
-                    if (! ($$ = curr_parser.make_for_command (PARFOR, $1, $4, $6,
+                    if (! ($$ = parser.make_for_command (PARFOR, $1, $4, $6,
                                                   $8, $11, $12, $2)))
                       ABORT_PARSE;
                   }
                 ;
 
 // =======
 // Jumping
 // =======
 
 jump_command    : BREAK
                   {
-                    if (! ($$ = curr_parser.make_break_command ($1)))
+                    if (! ($$ = parser.make_break_command ($1)))
                       ABORT_PARSE;
                   }
                 | CONTINUE
                   {
-                    if (! ($$ = curr_parser.make_continue_command ($1)))
+                    if (! ($$ = parser.make_continue_command ($1)))
                       ABORT_PARSE;
                   }
                 | FUNC_RET
                   {
-                    if (! ($$ = curr_parser.make_return_command ($1)))
+                    if (! ($$ = parser.make_return_command ($1)))
                       ABORT_PARSE;
                   }
                 ;
 
 // ==========
 // Exceptions
 // ==========
 
 except_command  : UNWIND stash_comment opt_sep opt_list CLEANUP
                   stash_comment opt_sep opt_list END
                   {
-                    if (! ($$ = curr_parser.make_unwind_command ($1, $4, $8, $9, $2, $6)))
+                    if (! ($$ = parser.make_unwind_command ($1, $4, $8, $9, $2, $6)))
                       ABORT_PARSE;
                   }
                 | TRY stash_comment opt_sep opt_list CATCH
                   stash_comment opt_sep opt_list END
                   {
-                    if (! ($$ = curr_parser.make_try_command ($1, $4, $8, $9, $2, $6)))
+                    if (! ($$ = parser.make_try_command ($1, $4, $8, $9, $2, $6)))
                       ABORT_PARSE;
                   }
                 | TRY stash_comment opt_sep opt_list END
                   {
-                    if (! ($$ = curr_parser.make_try_command ($1, $4, 0, $5, $2, 0)))
+                    if (! ($$ = parser.make_try_command ($1, $4, 0, $5, $2, 0)))
                       ABORT_PARSE;
                   }
                 ;
 
 // ===========================================
 // Some 'subroutines' for function definitions
 // ===========================================
 
 push_fcn_symtab : // empty
                   {
-                    curr_parser.curr_fcn_depth++;
-
-                    if (curr_parser.max_fcn_depth < curr_parser.curr_fcn_depth)
-                      curr_parser.max_fcn_depth = curr_parser.curr_fcn_depth;
+                    parser.curr_fcn_depth++;
+
+                    if (parser.max_fcn_depth < parser.curr_fcn_depth)
+                      parser.max_fcn_depth = parser.curr_fcn_depth;
 
                     parser_symtab_context.push ();
 
                     symbol_table::set_scope (symbol_table::alloc_scope ());
 
-                    curr_parser.function_scopes.push_back (symbol_table::current_scope ());
-
-                    if (! curr_lexer->reading_script_file
-                        && curr_parser.curr_fcn_depth == 1
-                        && ! curr_parser.parsing_subfunctions)
-                      curr_parser.primary_fcn_scope = symbol_table::current_scope ();
-
-                    if (curr_lexer->reading_script_file
-                        && curr_parser.curr_fcn_depth > 1)
-                      curr_parser.bison_error ("nested functions not implemented in this context");
+                    parser.function_scopes.push_back (symbol_table::current_scope ());
+
+                    if (! lexer.reading_script_file
+                        && parser.curr_fcn_depth == 1
+                        && ! parser.parsing_subfunctions)
+                      parser.primary_fcn_scope = symbol_table::current_scope ();
+
+                    if (lexer.reading_script_file
+                        && parser.curr_fcn_depth > 1)
+                      parser.bison_error ("nested functions not implemented in this context");
                   }
                 ;
 
 // ===========================
 // List of function parameters
 // ===========================
 
 param_list_beg  : '('
                   {
-                    curr_lexer->looking_at_parameter_list = true;
-
-                    if (curr_lexer->looking_at_function_handle)
+                    lexer.looking_at_parameter_list = true;
+
+                    if (lexer.looking_at_function_handle)
                       {
                         parser_symtab_context.push ();
                         symbol_table::set_scope (symbol_table::alloc_scope ());
-                        curr_lexer->looking_at_function_handle--;
-                        curr_lexer->looking_at_anon_fcn_args = true;
+                        lexer.looking_at_function_handle--;
+                        lexer.looking_at_anon_fcn_args = true;
                       }
                   }
                 ;
 
 param_list_end  : ')'
                   {
-                    curr_lexer->looking_at_parameter_list = false;
-                    curr_lexer->looking_for_object_index = false;
+                    lexer.looking_at_parameter_list = false;
+                    lexer.looking_for_object_index = false;
                   }
                 ;
 
 param_list      : param_list_beg param_list1 param_list_end
                   { $$ = $2; }
                 | param_list_beg error
                   {
-                    curr_parser.bison_error ("invalid parameter list");
+                    parser.bison_error ("invalid parameter list");
                     $$ = 0;
                     ABORT_PARSE;
                   }
                 ;
 
 param_list1     : // empty
                   { $$ = 0; }
                 | param_list2
@@ -1092,30 +1092,30 @@ param_list2     : decl2
                 ;
 
 // ===================================
 // List of function return value names
 // ===================================
 
 return_list     : '[' ']'
                   {
-                    curr_lexer->looking_at_return_list = false;
+                    lexer.looking_at_return_list = false;
                     $$ = new tree_parameter_list ();
                   }
                 | return_list1
                   {
-                    curr_lexer->looking_at_return_list = false;
+                    lexer.looking_at_return_list = false;
                     if ($1->validate (tree_parameter_list::out))
                       $$ = $1;
                     else
                       ABORT_PARSE;
                   }
                 | '[' return_list1 ']'
                   {
-                    curr_lexer->looking_at_return_list = false;
+                    lexer.looking_at_return_list = false;
                     if ($2->validate (tree_parameter_list::out))
                       $$ = $2;
                     else
                       ABORT_PARSE;
                   }
                 ;
 
 return_list1    : identifier
@@ -1128,169 +1128,169 @@ return_list1    : identifier
                 ;
 
 // =======================
 // Script or function file
 // =======================
 
 file            : INPUT_FILE opt_nl opt_list END_OF_INPUT
                   {
-                    if (! curr_lexer->reading_fcn_file)
+                    if (! lexer.reading_fcn_file)
                       {
                         tree_statement *end_of_script
-                          = curr_parser.make_end ("endscript",
-                                                  curr_lexer->input_line_number,
-                                                  curr_lexer->current_input_column);
-
-                        curr_parser.make_script ($3, end_of_script);
+                          = parser.make_end ("endscript",
+                                                  lexer.input_line_number,
+                                                  lexer.current_input_column);
+
+                        parser.make_script ($3, end_of_script);
                       }
 
                     $$ = 0;
                   }
                 | INPUT_FILE opt_nl classdef opt_sep END_OF_INPUT
                   {
-                    if (curr_lexer->reading_classdef_file)
-                      curr_parser.classdef_object = $3;
+                    if (lexer.reading_classdef_file)
+                      parser.classdef_object = $3;
 
                     $$ = 0;
                   }
                 ;
 
 // ===================
 // Function definition
 // ===================
 
 function_beg    : push_fcn_symtab FCN stash_comment
                   {
                     $$ = $3;
-                    if (curr_lexer->reading_classdef_file
-                        || curr_lexer->parsing_classdef)
-                      curr_lexer->maybe_classdef_get_set_method = true;
+                    if (lexer.reading_classdef_file
+                        || lexer.parsing_classdef)
+                      lexer.maybe_classdef_get_set_method = true;
                   }
                 ;
 
 function        : function_beg function1
                   {
-                    $$ = curr_parser.finish_function (0, $2, $1);
-                    curr_parser.recover_from_parsing_function ();
+                    $$ = parser.finish_function (0, $2, $1);
+                    parser.recover_from_parsing_function ();
                   }
                 | function_beg return_list '=' function1
                   {
-                    $$ = curr_parser.finish_function ($2, $4, $1);
-                    curr_parser.recover_from_parsing_function ();
+                    $$ = parser.finish_function ($2, $4, $1);
+                    parser.recover_from_parsing_function ();
                   }
                 ;
 
 fcn_name        : identifier
                   {
                     std::string id_name = $1->name ();
 
-                    curr_lexer->parsed_function_name.top () = true;
-                    curr_lexer->maybe_classdef_get_set_method = false;
+                    lexer.parsed_function_name.top () = true;
+                    lexer.maybe_classdef_get_set_method = false;
 
                     $$ = $1;
                   }
                 | GET '.' identifier
                   {
-                    curr_lexer->parsed_function_name.top () = true;
-                    curr_lexer->maybe_classdef_get_set_method = false;
-                    curr_lexer->parsing_classdef_get_method = true;
+                    lexer.parsed_function_name.top () = true;
+                    lexer.maybe_classdef_get_set_method = false;
+                    lexer.parsing_classdef_get_method = true;
                     $$ = $3;
                   }
                 | SET '.' identifier
                   {
-                    curr_lexer->parsed_function_name.top () = true;
-                    curr_lexer->maybe_classdef_get_set_method = false;
-                    curr_lexer->parsing_classdef_set_method = true;
+                    lexer.parsed_function_name.top () = true;
+                    lexer.maybe_classdef_get_set_method = false;
+                    lexer.parsing_classdef_set_method = true;
                     $$ = $3;
                   }
                 ;
 
 function1       : fcn_name function2
                   {
                     std::string fname = $1->name ();
 
                     delete $1;
 
-                    if (! ($$ = curr_parser.frob_function (fname, $2)))
+                    if (! ($$ = parser.frob_function (fname, $2)))
                       ABORT_PARSE;
                   }
                 ;
 
 function2       : param_list opt_sep opt_list function_end
-                  { $$ = curr_parser.start_function ($1, $3, $4); }
+                  { $$ = parser.start_function ($1, $3, $4); }
                 | opt_sep opt_list function_end
-                  { $$ = curr_parser.start_function (0, $2, $3); }
+                  { $$ = parser.start_function (0, $2, $3); }
                 ;
 
 function_end    : END
                   {
-                    curr_parser.endfunction_found = true;
-                    if (curr_parser.end_token_ok ($1, token::function_end))
-                      $$ = curr_parser.make_end ("endfunction", $1->line (), $1->column ());
+                    parser.endfunction_found = true;
+                    if (parser.end_token_ok ($1, token::function_end))
+                      $$ = parser.make_end ("endfunction", $1->line (), $1->column ());
                     else
                       ABORT_PARSE;
                   }
                 | END_OF_INPUT
                   {
 // A lot of tests are based on the assumption that this is OK
-//                  if (curr_lexer->reading_script_file)
+//                  if (lexer.reading_script_file)
 //                    {
-//                      curr_parser.bison_error ("function body open at end of script");
+//                      parser.bison_error ("function body open at end of script");
 //                      YYABORT;
 //                    }
 
-                    if (curr_parser.endfunction_found)
+                    if (parser.endfunction_found)
                       {
-                        curr_parser.bison_error ("inconsistent function endings -- "
+                        parser.bison_error ("inconsistent function endings -- "
                                  "if one function is explicitly ended, "
                                  "so must all the others");
                         YYABORT;
                       }
 
-                    if (! (curr_lexer->reading_fcn_file || curr_lexer->reading_script_file
-                           || (curr_lexer)->input_from_eval_string ()))
+                    if (! (lexer.reading_fcn_file || lexer.reading_script_file
+                           || lexer.input_from_eval_string ()))
                       {
-                        curr_parser.bison_error ("function body open at end of input");
+                        parser.bison_error ("function body open at end of input");
                         YYABORT;
                       }
 
-                    if (curr_lexer->reading_classdef_file)
+                    if (lexer.reading_classdef_file)
                       {
-                        curr_parser.bison_error ("classdef body open at end of input");
+                        parser.bison_error ("classdef body open at end of input");
                         YYABORT;
                       }
 
-                    $$ = curr_parser.make_end ("endfunction",
-                                                curr_lexer->input_line_number,
-                                                curr_lexer->current_input_column);
+                    $$ = parser.make_end ("endfunction",
+                                                lexer.input_line_number,
+                                                lexer.current_input_column);
                   }
                 ;
 
 // ========
 // Classdef
 // ========
 
 classdef_beg    : CLASSDEF
                   {
-                    if (! curr_lexer->reading_classdef_file)
+                    if (! lexer.reading_classdef_file)
                       {
-                        curr_parser.bison_error ("classdef must appear inside a file containing only a class definition");
+                        parser.bison_error ("classdef must appear inside a file containing only a class definition");
                         YYABORT;
                       }
 
-                    curr_lexer->parsing_classdef = true;
+                    lexer.parsing_classdef = true;
                     $$ = $1;
                   }
                 ;
 
 classdef        : classdef_beg stash_comment opt_attr_list identifier opt_superclass_list opt_sep class_body opt_sep END
                   {
-                    curr_lexer->parsing_classdef = false;
-                    if (! ($$ = curr_parser.make_classdef ($1, $3, $4, $5, $7, $9, $2)))
+                    lexer.parsing_classdef = false;
+                    if (! ($$ = parser.make_classdef ($1, $3, $4, $5, $7, $9, $2)))
                       ABORT_PARSE;
                   }
                 ;
 
 opt_attr_list   : // empty
                   { $$ = 0; }
                 | '(' attr_list ')'
                   { $$ = $2; }
@@ -1304,17 +1304,17 @@ attr_list       : attr
                     $$ = $1;
                   }
                 ;
 
 attr            : identifier
                   { $$ = new tree_classdef_attribute ($1); }
                 | identifier '=' decl_param_init expression
                   {
-                    curr_lexer->looking_at_initializer_expression = false;
+                    lexer.looking_at_initializer_expression = false;
                     $$ = new tree_classdef_attribute ($1, $4);
                   }
                 | EXPR_NOT identifier
                   { $$ = new tree_classdef_attribute ($2, false); }
                 ;
 
 opt_superclass_list
                 : // empty
@@ -1366,17 +1366,17 @@ class_body      : properties_block
                     $1->append ($3);
                     $$ = $1;
                   }
                 ;
 
 properties_block
                 : PROPERTIES stash_comment opt_attr_list opt_sep property_list opt_sep END
                   {
-                    if (! ($$ = curr_parser.make_classdef_properties_block
+                    if (! ($$ = parser.make_classdef_properties_block
                                               ($1, $3, $5, $7, $2)))
                       ABORT_PARSE;
                   }
                 ;
 
 property_list
                 : class_property
                   { $$ = new tree_classdef_property_list ($1); }
@@ -1386,24 +1386,24 @@ property_list
                     $$ = $1;
                   }
                 ;
 
 class_property  : identifier
                   { $$ = new tree_classdef_property ($1); }
                 | identifier '=' decl_param_init expression ';'
                   {
-                    curr_lexer->looking_at_initializer_expression = false;
+                    lexer.looking_at_initializer_expression = false;
                     $$ = new tree_classdef_property ($1, $4);
                   }
                 ;
 
 methods_block   : METHODS stash_comment opt_attr_list opt_sep methods_list opt_sep END
                   {
-                    if (! ($$ = curr_parser.make_classdef_methods_block
+                    if (! ($$ = parser.make_classdef_methods_block
                                               ($1, $3, $5, $7, $2)))
                       ABORT_PARSE;
                   }
                 ;
 
 methods_list    : function
                   {
                     octave_value fcn;
@@ -1421,17 +1421,17 @@ methods_list    : function
 
                     $1->append (fcn);
                     $$ = $1;
                   }
                 ;
 
 events_block    : EVENTS stash_comment opt_attr_list opt_sep events_list opt_sep END
                   {
-                    if (! ($$ = curr_parser.make_classdef_events_block
+                    if (! ($$ = parser.make_classdef_events_block
                                               ($1, $3, $5, $7, $2)))
                       ABORT_PARSE;
                   }
                 ;
 
 events_list     : class_event
                   { $$ = new tree_classdef_events_list ($1); }
                 | events_list opt_sep class_event
@@ -1442,17 +1442,17 @@ events_list     : class_event
                 ;
 
 class_event     : identifier
                   { $$ = new tree_classdef_event ($1); }
                 ;
 
 enum_block      : ENUMERATION stash_comment opt_attr_list opt_sep enum_list opt_sep END
                   {
-                    if (! ($$ = curr_parser.make_classdef_enum_block
+                    if (! ($$ = parser.make_classdef_enum_block
                                               ($1, $3, $5, $7, $2)))
                       ABORT_PARSE;
                   }
                 ;
 
 enum_list       : class_enum
                   { $$ = new tree_classdef_enum_list ($1); }
                 | enum_list opt_sep class_enum
@@ -1470,17 +1470,17 @@ class_enum      : identifier '(' express
 // Miscellaneous
 // =============
 
 stash_comment   : // empty
                   { $$ = octave_comment_buffer::get_comment (); }
                 ;
 
 parse_error     : LEXICAL_ERROR
-                  { curr_parser.bison_error ("parse error"); }
+                  { parser.bison_error ("parse error"); }
                 | error
                 ;
 
 sep_no_nl       : ','
                   { $$ = ','; }
                 | ';'
                   { $$ = ';'; }
                 | sep_no_nl ','
@@ -1526,86 +1526,59 @@ opt_sep         : // empty
                 | sep
                   { $$ = $1; }
                 ;
 
 %%
 
 // Generic error messages.
 
-#undef curr_lexer
+#undef lexer
 
 static void
-yyerror (octave_parser& curr_parser, const char *s)
+yyerror (octave_base_parser& parser, const char *s)
 {
-  curr_parser.bison_error (s);
+  parser.bison_error (s);
 }
 
-octave_parser::~octave_parser (void)
+octave_base_parser::~octave_base_parser (void)
 {
 #if defined (OCTAVE_USE_PUSH_PARSER)
   yypstate_delete (static_cast<yypstate *> (parser_state));
 #endif
 
   delete stmt_list;
 
-  delete curr_lexer;
+  delete &lexer;
 }
-void octave_parser::init (void)
+
+void octave_base_parser::init (void)
 {
 #if defined (OCTAVE_USE_PUSH_PARSER)
   parser_state = yypstate_new ();
 #endif
 
-  CURR_LEXER = curr_lexer;
+  LEXER = &lexer;
 }
 
 void
-octave_parser::reset (void)
+octave_base_parser::reset (void)
 {
   delete stmt_list;
 
   stmt_list = 0;
 
-  curr_lexer->reset ();
-}
-
-int
-octave_parser::run (void)
-{
-  int status = 0;
-
-#if defined (OCTAVE_USE_PUSH_PARSER)
-
-  do
-    {
-      YYSTYPE lval;
-
-      int token = octave_lex (&lval, scanner);
-
-      yypstate *pstate = static_cast<yypstate *> (parser_state);
-
-      status = octave_push_parse (pstate, token, &lval, *this);
-    }
-  while (status == YYPUSH_MORE);
-
-#else
-
-  status = octave_parse (*this);
-
-#endif
-
-  return status;
+  lexer.reset ();
 }
 
 // Error mesages for mismatched end tokens.
 
 void
-octave_parser::end_error (const char *type, token::end_tok_type ettype,
-                          int l, int c)
+octave_base_parser::end_error (const char *type, token::end_tok_type ettype,
+                               int l, int c)
 {
   static const char *fmt
     = "'%s' command matched by '%s' near line %d column %d";
 
   switch (ettype)
     {
     case token::simple_end:
       error (fmt, type, "end", l, c);
@@ -1647,17 +1620,17 @@ octave_parser::end_error (const char *ty
       panic_impossible ();
       break;
     }
 }
 
 // Check to see that end tokens are properly matched.
 
 bool
-octave_parser::end_token_ok (token *tok, token::end_tok_type expected)
+octave_base_parser::end_token_ok (token *tok, token::end_tok_type expected)
 {
   bool retval = true;
 
   token::end_tok_type ettype = tok->ettype ();
 
   if (ettype != expected && ettype != token::simple_end)
     {
       retval = false;
@@ -1717,48 +1690,48 @@ octave_parser::end_token_ok (token *tok,
 
   return retval;
 }
 
 // Maybe print a warning if an assignment expression is used as the
 // test in a logical expression.
 
 void
-octave_parser::maybe_warn_assign_as_truth_value (tree_expression *expr)
+octave_base_parser::maybe_warn_assign_as_truth_value (tree_expression *expr)
 {
   if (expr->is_assignment_expression ()
       && expr->paren_count () < 2)
     {
-      if (curr_lexer->fcn_file_full_name.empty ())
+      if (lexer.fcn_file_full_name.empty ())
         warning_with_id
           ("Octave:assign-as-truth-value",
            "suggest parenthesis around assignment used as truth value");
       else
         warning_with_id
           ("Octave:assign-as-truth-value",
            "suggest parenthesis around assignment used as truth value near line %d, column %d in file '%s'",
-           expr->line (), expr->column (), curr_lexer->fcn_file_full_name.c_str ());
+           expr->line (), expr->column (), lexer.fcn_file_full_name.c_str ());
     }
 }
 
 // Maybe print a warning about switch labels that aren't constants.
 
 void
-octave_parser::maybe_warn_variable_switch_label (tree_expression *expr)
+octave_base_parser::maybe_warn_variable_switch_label (tree_expression *expr)
 {
   if (! expr->is_constant ())
     {
-      if (curr_lexer->fcn_file_full_name.empty ())
+      if (lexer.fcn_file_full_name.empty ())
         warning_with_id ("Octave:variable-switch-label",
                          "variable switch label");
       else
         warning_with_id
           ("Octave:variable-switch-label",
            "variable switch label near line %d, column %d in file '%s'",
-           expr->line (), expr->column (), curr_lexer->fcn_file_full_name.c_str ());
+           expr->line (), expr->column (), lexer.fcn_file_full_name.c_str ());
     }
 }
 
 static tree_expression *
 fold (tree_binary_expression *e)
 {
   tree_expression *retval = e;
 
@@ -1844,17 +1817,17 @@ fold (tree_unary_expression *e)
     }
 
   return retval;
 }
 
 // Finish building a range.
 
 tree_expression *
-octave_parser::finish_colon_expression (tree_colon_expression *e)
+octave_base_parser::finish_colon_expression (tree_colon_expression *e)
 {
   tree_expression *retval = e;
 
   unwind_protect frame;
 
   frame.protect_var (error_state);
   frame.protect_var (warning_state);
 
@@ -1908,17 +1881,17 @@ octave_parser::finish_colon_expression (
     }
 
   return retval;
 }
 
 // Make a constant.
 
 tree_constant *
-octave_parser::make_constant (int op, token *tok_val)
+octave_base_parser::make_constant (int op, token *tok_val)
 {
   int l = tok_val->line ();
   int c = tok_val->column ();
 
   tree_constant *retval = 0;
 
   switch (op)
     {
@@ -1971,35 +1944,35 @@ octave_parser::make_constant (int op, to
     }
 
   return retval;
 }
 
 // Make a function handle.
 
 tree_fcn_handle *
-octave_parser::make_fcn_handle (token *tok_val)
+octave_base_parser::make_fcn_handle (token *tok_val)
 {
   int l = tok_val->line ();
   int c = tok_val->column ();
 
   tree_fcn_handle *retval = new tree_fcn_handle (tok_val->text (), l, c);
 
   return retval;
 }
 
 // Make an anonymous function handle.
 
 tree_anon_fcn_handle *
-octave_parser::make_anon_fcn_handle (tree_parameter_list *param_list,
-                                     tree_statement *stmt)
+octave_base_parser::make_anon_fcn_handle (tree_parameter_list *param_list,
+                                          tree_statement *stmt)
 {
   // FIXME -- need to get these from the location of the @ symbol.
-  int l = curr_lexer->input_line_number;
-  int c = curr_lexer->current_input_column;
+  int l = lexer.input_line_number;
+  int c = lexer.current_input_column;
 
   tree_parameter_list *ret_list = 0;
 
   symbol_table::scope_id fcn_scope = symbol_table::current_scope ();
 
   if (parser_symtab_context.empty ())
     panic_impossible ();
 
@@ -2010,26 +1983,26 @@ octave_parser::make_anon_fcn_handle (tre
   tree_statement_list *body = new tree_statement_list (stmt);
 
   body->mark_as_anon_function_body ();
 
   tree_anon_fcn_handle *retval
     = new tree_anon_fcn_handle (param_list, ret_list, body, fcn_scope, l, c);
   // FIXME: Stash the filename.  This does not work and produces
   // errors when executed.
-  //retval->stash_file_name (curr_lexer->fcn_file_name);
+  //retval->stash_file_name (lexer.fcn_file_name);
 
   return retval;
 }
 
 // Build a binary expression.
 
 tree_expression *
-octave_parser::make_binary_op (int op, tree_expression *op1, token *tok_val,
-                               tree_expression *op2)
+octave_base_parser::make_binary_op (int op, tree_expression *op1,
+                                    token *tok_val, tree_expression *op2)
 {
   octave_value::binary_op t = octave_value::unknown_binary_op;
 
   switch (op)
     {
     case POW:
       t = octave_value::op_pow;
       break;
@@ -2122,18 +2095,18 @@ octave_parser::make_binary_op (int op, t
     = maybe_compound_binary_expression (op1, op2, l, c, t);
 
   return fold (e);
 }
 
 // Build a boolean expression.
 
 tree_expression *
-octave_parser::make_boolean_op (int op, tree_expression *op1, token *tok_val,
-                                tree_expression *op2)
+octave_base_parser::make_boolean_op (int op, tree_expression *op1,
+                                     token *tok_val, tree_expression *op2)
 {
   tree_boolean_expression::type t;
 
   switch (op)
     {
     case EXPR_AND_AND:
       t = tree_boolean_expression::bool_and;
       break;
@@ -2154,17 +2127,18 @@ octave_parser::make_boolean_op (int op, 
     = new tree_boolean_expression (op1, op2, l, c, t);
 
   return fold (e);
 }
 
 // Build a prefix expression.
 
 tree_expression *
-octave_parser::make_prefix_op (int op, tree_expression *op1, token *tok_val)
+octave_base_parser::make_prefix_op (int op, tree_expression *op1,
+                                    token *tok_val)
 {
   octave_value::unary_op t = octave_value::unknown_unary_op;
 
   switch (op)
     {
     case EXPR_NOT:
       t = octave_value::op_not;
       break;
@@ -2197,17 +2171,18 @@ octave_parser::make_prefix_op (int op, t
     = new tree_prefix_expression (op1, l, c, t);
 
   return fold (e);
 }
 
 // Build a postfix expression.
 
 tree_expression *
-octave_parser::make_postfix_op (int op, tree_expression *op1, token *tok_val)
+octave_base_parser::make_postfix_op (int op, tree_expression *op1,
+                                     token *tok_val)
 {
   octave_value::unary_op t = octave_value::unknown_unary_op;
 
   switch (op)
     {
     case HERMITIAN:
       t = octave_value::op_hermitian;
       break;
@@ -2236,22 +2211,22 @@ octave_parser::make_postfix_op (int op, 
     = new tree_postfix_expression (op1, l, c, t);
 
   return fold (e);
 }
 
 // Build an unwind-protect command.
 
 tree_command *
-octave_parser::make_unwind_command (token *unwind_tok,
-                                    tree_statement_list *body,
-                                    tree_statement_list *cleanup_stmts,
-                                    token *end_tok,
-                                    octave_comment_list *lc,
-                                    octave_comment_list *mc)
+octave_base_parser::make_unwind_command (token *unwind_tok,
+                                         tree_statement_list *body,
+                                         tree_statement_list *cleanup_stmts,
+                                         token *end_tok,
+                                         octave_comment_list *lc,
+                                         octave_comment_list *mc)
 {
   tree_command *retval = 0;
 
   if (end_token_ok (end_tok, token::unwind_protect_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       int l = unwind_tok->line ();
@@ -2262,21 +2237,22 @@ octave_parser::make_unwind_command (toke
     }
 
   return retval;
 }
 
 // Build a try-catch command.
 
 tree_command *
-octave_parser::make_try_command (token *try_tok, tree_statement_list *body,
-                                 tree_statement_list *cleanup_stmts,
-                                 token *end_tok,
-                                 octave_comment_list *lc,
-                                 octave_comment_list *mc)
+octave_base_parser::make_try_command (token *try_tok,
+                                      tree_statement_list *body,
+                                      tree_statement_list *cleanup_stmts,
+                                      token *end_tok,
+                                      octave_comment_list *lc,
+                                      octave_comment_list *mc)
 {
   tree_command *retval = 0;
 
   if (end_token_ok (end_tok, token::try_catch_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       int l = try_tok->line ();
@@ -2287,82 +2263,85 @@ octave_parser::make_try_command (token *
     }
 
   return retval;
 }
 
 // Build a while command.
 
 tree_command *
-octave_parser::make_while_command (token *while_tok, tree_expression *expr,
-                                   tree_statement_list *body, token *end_tok,
-                                   octave_comment_list *lc)
+octave_base_parser::make_while_command (token *while_tok,
+                                        tree_expression *expr,
+                                        tree_statement_list *body,
+                                        token *end_tok,
+                                        octave_comment_list *lc)
 {
   tree_command *retval = 0;
 
   maybe_warn_assign_as_truth_value (expr);
 
   if (end_token_ok (end_tok, token::while_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
-      curr_lexer->looping--;
+      lexer.looping--;
 
       int l = while_tok->line ();
       int c = while_tok->column ();
 
       retval = new tree_while_command (expr, body, lc, tc, l, c);
     }
 
   return retval;
 }
 
 // Build a do-until command.
 
 tree_command *
-octave_parser::make_do_until_command (token *until_tok,
-                                      tree_statement_list *body,
-                                      tree_expression *expr,
-                                      octave_comment_list *lc)
+octave_base_parser::make_do_until_command (token *until_tok,
+                                           tree_statement_list *body,
+                                           tree_expression *expr,
+                                           octave_comment_list *lc)
 {
   tree_command *retval = 0;
 
   maybe_warn_assign_as_truth_value (expr);
 
   octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
-  curr_lexer->looping--;
+  lexer.looping--;
 
   int l = until_tok->line ();
   int c = until_tok->column ();
 
   retval = new tree_do_until_command (expr, body, lc, tc, l, c);
 
   return retval;
 }
 
 // Build a for command.
 
 tree_command *
-octave_parser::make_for_command (int tok_id, token *for_tok,
-                                 tree_argument_list *lhs,
-                                 tree_expression *expr,
-                                 tree_expression *maxproc,
-                                 tree_statement_list *body, token *end_tok,
-                                 octave_comment_list *lc)
+octave_base_parser::make_for_command (int tok_id, token *for_tok,
+                                      tree_argument_list *lhs,
+                                      tree_expression *expr,
+                                      tree_expression *maxproc,
+                                      tree_statement_list *body,
+                                      token *end_tok,
+                                      octave_comment_list *lc)
 {
   tree_command *retval = 0;
 
   bool parfor = tok_id == PARFOR;
 
   if (end_token_ok (end_tok, parfor ? token::parfor_end : token::for_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
-      curr_lexer->looping--;
+      lexer.looping--;
 
       int l = for_tok->line ();
       int c = for_tok->column ();
 
       if (lhs->length () == 1)
         {
           tree_expression *tmp = lhs->remove_front ();
 
@@ -2382,76 +2361,78 @@ octave_parser::make_for_command (int tok
     }
 
   return retval;
 }
 
 // Build a break command.
 
 tree_command *
-octave_parser::make_break_command (token *break_tok)
+octave_base_parser::make_break_command (token *break_tok)
 {
   tree_command *retval = 0;
 
   int l = break_tok->line ();
   int c = break_tok->column ();
 
   retval = new tree_break_command (l, c);
 
   return retval;
 }
 
 // Build a continue command.
 
 tree_command *
-octave_parser::make_continue_command (token *continue_tok)
+octave_base_parser::make_continue_command (token *continue_tok)
 {
   tree_command *retval = 0;
 
   int l = continue_tok->line ();
   int c = continue_tok->column ();
 
   retval = new tree_continue_command (l, c);
 
   return retval;
 }
 
 // Build a return command.
 
 tree_command *
-octave_parser::make_return_command (token *return_tok)
+octave_base_parser::make_return_command (token *return_tok)
 {
   tree_command *retval = 0;
 
   int l = return_tok->line ();
   int c = return_tok->column ();
 
   retval = new tree_return_command (l, c);
 
   return retval;
 }
 
 // Start an if command.
 
 tree_if_command_list *
-octave_parser::start_if_command (tree_expression *expr,
-                                 tree_statement_list *list)
+octave_base_parser::start_if_command (tree_expression *expr,
+                                      tree_statement_list *list)
 {
   maybe_warn_assign_as_truth_value (expr);
 
   tree_if_clause *t = new tree_if_clause (expr, list);
 
   return new tree_if_command_list (t);
 }
 
 // Finish an if command.
 
 tree_if_command *
-octave_parser::finish_if_command (token *if_tok, tree_if_command_list *list,
-                                  token *end_tok, octave_comment_list *lc)
+octave_base_parser::finish_if_command (token *if_tok,
+                                       tree_if_command_list *list,
+                                       token *end_tok,
+                                       octave_comment_list *lc)
 {
   tree_if_command *retval = 0;
 
   if (end_token_ok (end_tok, token::if_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       int l = if_tok->line ();
@@ -2472,34 +2453,37 @@ octave_parser::finish_if_command (token 
     }
 
   return retval;
 }
 
 // Build an elseif clause.
 
 tree_if_clause *
-octave_parser::make_elseif_clause (token *elseif_tok, tree_expression *expr,
-                                   tree_statement_list *list,
-                                   octave_comment_list *lc)
+octave_base_parser::make_elseif_clause (token *elseif_tok,
+                                        tree_expression *expr,
+                                        tree_statement_list *list,
+                                        octave_comment_list *lc)
 {
   maybe_warn_assign_as_truth_value (expr);
 
   int l = elseif_tok->line ();
   int c = elseif_tok->column ();
 
   return new tree_if_clause (expr, list, lc, l, c);
 }
 
 // Finish a switch command.
 
 tree_switch_command *
-octave_parser::finish_switch_command (token *switch_tok, tree_expression *expr,
-                                      tree_switch_case_list *list,
-                                      token *end_tok, octave_comment_list *lc)
+octave_base_parser::finish_switch_command (token *switch_tok,
+                                           tree_expression *expr,
+                                           tree_switch_case_list *list,
+                                           token *end_tok,
+                                           octave_comment_list *lc)
 {
   tree_switch_command *retval = 0;
 
   if (end_token_ok (end_tok, token::switch_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       int l = switch_tok->line ();
@@ -2520,33 +2504,34 @@ octave_parser::finish_switch_command (to
     }
 
   return retval;
 }
 
 // Build a switch case.
 
 tree_switch_case *
-octave_parser::make_switch_case (token *case_tok, tree_expression *expr,
-                                 tree_statement_list *list,
-                                 octave_comment_list *lc)
+octave_base_parser::make_switch_case (token *case_tok,
+                                      tree_expression *expr,
+                                      tree_statement_list *list,
+                                      octave_comment_list *lc)
 {
   maybe_warn_variable_switch_label (expr);
 
   int l = case_tok->line ();
   int c = case_tok->column ();
 
   return new tree_switch_case (expr, list, lc, l, c);
 }
 
 // Build an assignment to a variable.
 
 tree_expression *
-octave_parser::make_assign_op (int op, tree_argument_list *lhs, token *eq_tok,
-                               tree_expression *rhs)
+octave_base_parser::make_assign_op (int op, tree_argument_list *lhs,
+                                    token *eq_tok, tree_expression *rhs)
 {
   tree_expression *retval = 0;
 
   octave_value::assign_op t = octave_value::unknown_assign_op;
 
   switch (op)
     {
     case '=':
@@ -2631,44 +2616,44 @@ octave_parser::make_assign_op (int op, t
     bison_error ("computed multiple assignment not allowed");
 
   return retval;
 }
 
 // Define a script.
 
 void
-octave_parser::make_script (tree_statement_list *cmds,
-                            tree_statement *end_script)
+octave_base_parser::make_script (tree_statement_list *cmds,
+                                 tree_statement *end_script)
 {
   if (! cmds)
     cmds = new tree_statement_list ();
 
   cmds->append (end_script);
 
   octave_user_script *script
-    = new octave_user_script (curr_lexer->fcn_file_full_name,
-                              curr_lexer->fcn_file_name,
-                              cmds, curr_lexer->help_text);
-
-  curr_lexer->help_text = "";
+    = new octave_user_script (lexer.fcn_file_full_name,
+                              lexer.fcn_file_name,
+                              cmds, lexer.help_text);
+
+  lexer.help_text = "";
 
   octave_time now;
 
   script->stash_fcn_file_time (now);
 
   primary_fcn_ptr = script;
 }
 
 // Begin defining a function.
 
 octave_user_function *
-octave_parser::start_function (tree_parameter_list *param_list,
-                               tree_statement_list *body,
-                               tree_statement *end_fcn_stmt)
+octave_base_parser::start_function (tree_parameter_list *param_list,
+                                    tree_statement_list *body,
+                                    tree_statement *end_fcn_stmt)
 {
   // We'll fill in the return list later.
 
   if (! body)
     body = new tree_statement_list ();
 
   body->append (end_fcn_stmt);
 
@@ -2682,80 +2667,80 @@ octave_parser::start_function (tree_para
 
       fcn->stash_trailing_comment (tc);
     }
 
   return fcn;
 }
 
 tree_statement *
-octave_parser::make_end (const std::string& type, int l, int c)
+octave_base_parser::make_end (const std::string& type, int l, int c)
 {
   return make_statement (new tree_no_op_command (type, l, c));
 }
 
 // Do most of the work for defining a function.
 
 octave_user_function *
-octave_parser::frob_function (const std::string& fname,
-                              octave_user_function *fcn)
+octave_base_parser::frob_function (const std::string& fname,
+                                   octave_user_function *fcn)
 {
   std::string id_name = fname;
 
   // If input is coming from a file, issue a warning if the name of
   // the file does not match the name of the function stated in the
   // file.  Matlab doesn't provide a diagnostic (it ignores the stated
   // name).
-  if (! autoloading && curr_lexer->reading_fcn_file
+  if (! autoloading && lexer.reading_fcn_file
       && curr_fcn_depth == 1 && ! parsing_subfunctions)
   {
-    // FIXME -- should curr_lexer->fcn_file_name already be
+    // FIXME -- should lexer.fcn_file_name already be
     // preprocessed when we get here?  It seems to only be a
     // problem with relative file names.
 
-    std::string nm = curr_lexer->fcn_file_name;
+    std::string nm = lexer.fcn_file_name;
 
     size_t pos = nm.find_last_of (file_ops::dir_sep_chars ());
 
     if (pos != std::string::npos)
-      nm = curr_lexer->fcn_file_name.substr (pos+1);
+      nm = lexer.fcn_file_name.substr (pos+1);
 
     if (nm != id_name)
       {
         warning_with_id
           ("Octave:function-name-clash",
            "function name '%s' does not agree with function file name '%s'",
-           id_name.c_str (), curr_lexer->fcn_file_full_name.c_str ());
+           id_name.c_str (), lexer.fcn_file_full_name.c_str ());
 
         id_name = nm;
       }
   }
 
-  if (curr_lexer->reading_fcn_file || curr_lexer->reading_classdef_file || autoloading)
+  if (lexer.reading_fcn_file || lexer.reading_classdef_file || autoloading)
     {
       octave_time now;
 
-      fcn->stash_fcn_file_name (curr_lexer->fcn_file_full_name);
+      fcn->stash_fcn_file_name (lexer.fcn_file_full_name);
       fcn->stash_fcn_file_time (now);
       fcn->mark_as_system_fcn_file ();
 
       if (fcn_file_from_relative_lookup)
         fcn->mark_relative ();
 
       if (curr_fcn_depth > 1 || parsing_subfunctions)
         {
-          fcn->stash_parent_fcn_name (curr_lexer->fcn_file_name);
+          fcn->stash_parent_fcn_name (lexer.fcn_file_name);
 
           if (curr_fcn_depth > 1)
             fcn->stash_parent_fcn_scope (function_scopes[function_scopes.size ()-2]);
           else
             fcn->stash_parent_fcn_scope (primary_fcn_scope);
         }
 
-      if (curr_lexer->parsing_class_method)
+      if (lexer.parsing_class_method)
         {
           if (curr_class_name == id_name)
             fcn->mark_as_class_constructor ();
           else
             fcn->mark_as_class_method ();
 
           fcn->stash_dispatch_class (curr_class_name);
         }
@@ -2764,47 +2749,47 @@ octave_parser::frob_function (const std:
 
       file_stat fs (nm);
 
       if (fs && fs.is_newer (now))
         warning_with_id ("Octave:future-time-stamp",
                          "time stamp for '%s' is in the future", nm.c_str ());
     }
   else if (! input_from_tmp_history_file
-           && ! curr_lexer->force_script
-           && curr_lexer->reading_script_file
-           && curr_lexer->fcn_file_name == id_name)
+           && ! lexer.force_script
+           && lexer.reading_script_file
+           && lexer.fcn_file_name == id_name)
     {
       warning ("function '%s' defined within script file '%s'",
-               id_name.c_str (), curr_lexer->fcn_file_full_name.c_str ());
+               id_name.c_str (), lexer.fcn_file_full_name.c_str ());
     }
 
   fcn->stash_function_name (id_name);
-  fcn->stash_fcn_location (curr_lexer->input_line_number,
-                           curr_lexer->current_input_column);
-
-  if (! curr_lexer->help_text.empty () && curr_fcn_depth == 1
+  fcn->stash_fcn_location (lexer.input_line_number,
+                           lexer.current_input_column);
+
+  if (! lexer.help_text.empty () && curr_fcn_depth == 1
       && ! parsing_subfunctions)
     {
-      fcn->document (curr_lexer->help_text);
-
-      curr_lexer->help_text = "";
+      fcn->document (lexer.help_text);
+
+      lexer.help_text = "";
     }
 
-  if (curr_lexer->reading_fcn_file && curr_fcn_depth == 1
+  if (lexer.reading_fcn_file && curr_fcn_depth == 1
       && ! parsing_subfunctions)
     primary_fcn_ptr = fcn;
 
   return fcn;
 }
 
 tree_function_def *
-octave_parser::finish_function (tree_parameter_list *ret_list,
-                                octave_user_function *fcn,
-                                octave_comment_list *lc)
+octave_base_parser::finish_function (tree_parameter_list *ret_list,
+                                     octave_user_function *fcn,
+                                     octave_comment_list *lc)
 {
   tree_function_def *retval = 0;
 
   if (ret_list)
     ret_list->mark_as_formal_parameters ();
 
   if (fcn)
     {
@@ -2837,17 +2822,17 @@ octave_parser::finish_function (tree_par
           else
             symbol_table::install_subfunction (nm, octave_value (fcn),
                                                primary_fcn_scope);
         }
 
       if (curr_fcn_depth == 1 && fcn)
         symbol_table::update_nest (fcn->scope ());
 
-      if (! curr_lexer->reading_fcn_file && curr_fcn_depth == 1)
+      if (! lexer.reading_fcn_file && curr_fcn_depth == 1)
         {
           // We are either reading a script file or defining a function
           // at the command line, so this definition creates a
           // tree_function object that is placed in the parse tree.
           // Otherwise, it is just inserted in the symbol table,
           // either as a subfunction or nested function (see above),
           // or as the primary function for the file, via
           // primary_fcn_ptr (see also load_fcn_from_file,,
@@ -2857,58 +2842,58 @@ octave_parser::finish_function (tree_par
           retval = new tree_function_def (fcn);
         }
     }
 
   return retval;
 }
 
 void
-octave_parser::recover_from_parsing_function (void)
+octave_base_parser::recover_from_parsing_function (void)
 {
   if (parser_symtab_context.empty ())
     panic_impossible ();
 
   parser_symtab_context.pop ();
 
-  if (curr_lexer->reading_fcn_file && curr_fcn_depth == 1
+  if (lexer.reading_fcn_file && curr_fcn_depth == 1
       && ! parsing_subfunctions)
     parsing_subfunctions = true;
 
   curr_fcn_depth--;
   function_scopes.pop_back ();
 
-  curr_lexer->defining_func--;
-  curr_lexer->parsed_function_name.pop ();
-  curr_lexer->looking_at_return_list = false;
-  curr_lexer->looking_at_parameter_list = false;
+  lexer.defining_func--;
+  lexer.parsed_function_name.pop ();
+  lexer.looking_at_return_list = false;
+  lexer.looking_at_parameter_list = false;
 }
 
 tree_funcall *
-octave_parser::make_superclass_ref (const std::string& method_nm,
-                                    const std::string& package_nm,
-                                    const std::string& class_nm,
-                                    int l, int c)
+octave_base_parser::make_superclass_ref (const std::string& method_nm,
+                                         const std::string& package_nm,
+                                         const std::string& class_nm,
+                                         int l, int c)
 {
   octave_value_list args;
 
   args(2) = class_nm;
   args(1) = package_nm;
   args(0) = method_nm;
 
   octave_value fcn
     = symbol_table::find_built_in_function ("__superclass_reference__");
 
   return new tree_funcall (fcn, args);
 }
 
 tree_funcall *
-octave_parser::make_meta_class_query (const std::string& package_nm,
-                                      const std::string& class_nm,
-                                      int l, int c)
+octave_base_parser::make_meta_class_query (const std::string& package_nm,
+                                           const std::string& class_nm,
+                                           int l, int c)
 {
   octave_value_list args;
 
   args(1) = class_nm;
   args(0) = package_nm;
 
   octave_value fcn
     = symbol_table::find_built_in_function ("__meta_class_query__");
@@ -2918,33 +2903,33 @@ octave_parser::make_meta_class_query (co
 
 // A CLASSDEF block defines a class that has a constructor and other
 // methods, but it is not an executable command.  Parsing the block
 // makes some changes in the symbol table (inserting the constructor
 // and methods, and adding to the list of known objects) and creates
 // a parse tree containing meta information about the class.
 
 tree_classdef *
-octave_parser::make_classdef (token *tok_val,
-                              tree_classdef_attribute_list *a,
-                              tree_identifier *id,
-                              tree_classdef_superclass_list *sc,
-                              tree_classdef_body *body, token *end_tok,
-                              octave_comment_list *lc)
+octave_base_parser::make_classdef (token *tok_val,
+                                   tree_classdef_attribute_list *a,
+                                   tree_identifier *id,
+                                   tree_classdef_superclass_list *sc,
+                                   tree_classdef_body *body, token *end_tok,
+                                   octave_comment_list *lc)
 {
   tree_classdef *retval = 0;
 
   std::string cls_name = id->name ();
 
-  std::string nm = curr_lexer->fcn_file_name;
+  std::string nm = lexer.fcn_file_name;
 
   size_t pos = nm.find_last_of (file_ops::dir_sep_chars ());
 
   if (pos != std::string::npos)
-    nm = curr_lexer->fcn_file_name.substr (pos+1);
+    nm = lexer.fcn_file_name.substr (pos+1);
 
   if (nm != cls_name)
     {
       bison_error ("invalid classdef definition, the class name must match the file name");
       return retval;
     }
 
   if (end_token_ok (end_tok, token::classdef_end))
@@ -2956,21 +2941,21 @@ octave_parser::make_classdef (token *tok
 
       retval = new tree_classdef (a, id, sc, body, lc, tc, l, c);
     }
 
   return retval;
 }
 
 tree_classdef_properties_block *
-octave_parser::make_classdef_properties_block (token *tok_val,
-                                               tree_classdef_attribute_list *a,
-                                               tree_classdef_property_list *plist,
-                                               token *end_tok,
-                                               octave_comment_list *lc)
+octave_base_parser::make_classdef_properties_block (token *tok_val,
+                                                    tree_classdef_attribute_list *a,
+                                                    tree_classdef_property_list *plist,
+                                                    token *end_tok,
+                                                    octave_comment_list *lc)
 {
   tree_classdef_properties_block *retval = 0;
 
   if (end_token_ok (end_tok, token::properties_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       int l = tok_val->line ();
@@ -2978,21 +2963,21 @@ octave_parser::make_classdef_properties_
 
       retval = new tree_classdef_properties_block (a, plist, lc, tc, l, c);
     }
 
   return retval;
 }
 
 tree_classdef_methods_block *
-octave_parser::make_classdef_methods_block (token *tok_val,
-                                            tree_classdef_attribute_list *a,
-                                            tree_classdef_methods_list *mlist,
-                                            token *end_tok,
-                                            octave_comment_list *lc)
+octave_base_parser::make_classdef_methods_block (token *tok_val,
+                                                 tree_classdef_attribute_list *a,
+                                                 tree_classdef_methods_list *mlist,
+                                                 token *end_tok,
+                                                 octave_comment_list *lc)
 {
   tree_classdef_methods_block *retval = 0;
 
   if (end_token_ok (end_tok, token::methods_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       int l = tok_val->line ();
@@ -3000,21 +2985,21 @@ octave_parser::make_classdef_methods_blo
 
       retval = new tree_classdef_methods_block (a, mlist, lc, tc, l, c);
     }
 
   return retval;
 }
 
 tree_classdef_events_block *
-octave_parser::make_classdef_events_block (token *tok_val,
-                                           tree_classdef_attribute_list *a,
-                                           tree_classdef_events_list *elist,
-                                           token *end_tok,
-                                           octave_comment_list *lc)
+octave_base_parser::make_classdef_events_block (token *tok_val,
+                                                tree_classdef_attribute_list *a,
+                                                tree_classdef_events_list *elist,
+                                                token *end_tok,
+                                                octave_comment_list *lc)
 {
   tree_classdef_events_block *retval = 0;
 
   if (end_token_ok (end_tok, token::events_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       int l = tok_val->line ();
@@ -3022,21 +3007,21 @@ octave_parser::make_classdef_events_bloc
 
       retval = new tree_classdef_events_block (a, elist, lc, tc, l, c);
     }
 
   return retval;
 }
 
 tree_classdef_enum_block *
-octave_parser::make_classdef_enum_block (token *tok_val,
-                                         tree_classdef_attribute_list *a,
-                                         tree_classdef_enum_list *elist,
-                                         token *end_tok,
-                                         octave_comment_list *lc)
+octave_base_parser::make_classdef_enum_block (token *tok_val,
+                                              tree_classdef_attribute_list *a,
+                                              tree_classdef_enum_list *elist,
+                                              token *end_tok,
+                                              octave_comment_list *lc)
 {
   tree_classdef_enum_block *retval = 0;
 
   if (end_token_ok (end_tok, token::enumeration_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       int l = tok_val->line ();
@@ -3046,18 +3031,19 @@ octave_parser::make_classdef_enum_block 
     }
 
   return retval;
 }
 
 // Make an index expression.
 
 tree_index_expression *
-octave_parser::make_index_expression (tree_expression *expr,
-                                      tree_argument_list *args, char type)
+octave_base_parser::make_index_expression (tree_expression *expr,
+                                           tree_argument_list *args,
+                                           char type)
 {
   tree_index_expression *retval = 0;
 
   if (args && args->has_magic_tilde ())
     {
       bison_error ("invalid use of empty argument (~) in index expression");
       return retval;
     }
@@ -3080,18 +3066,18 @@ octave_parser::make_index_expression (tr
     retval = new tree_index_expression (expr, args, l, c, type);
 
   return retval;
 }
 
 // Make an indirect reference expression.
 
 tree_index_expression *
-octave_parser::make_indirect_ref (tree_expression *expr,
-                                  const std::string& elt)
+octave_base_parser::make_indirect_ref (tree_expression *expr,
+                                       const std::string& elt)
 {
   tree_index_expression *retval = 0;
 
   int l = expr->line ();
   int c = expr->column ();
 
   if (! expr->is_postfix_indexed ()) 
     expr->set_postfix_index ('.');
@@ -3102,25 +3088,26 @@ octave_parser::make_indirect_ref (tree_e
 
       tmp->append (elt);
 
       retval = tmp;
     }
   else
     retval = new tree_index_expression (expr, elt, l, c);
 
-  curr_lexer->looking_at_indirect_ref = false;
+  lexer.looking_at_indirect_ref = false;
 
   return retval;
 }
 
 // Make an indirect reference expression with dynamic field name.
 
 tree_index_expression *
-octave_parser::make_indirect_ref (tree_expression *expr, tree_expression *elt)
+octave_base_parser::make_indirect_ref (tree_expression *expr,
+                                       tree_expression *elt)
 {
   tree_index_expression *retval = 0;
 
   int l = expr->line ();
   int c = expr->column ();
 
   if (! expr->is_postfix_indexed ()) 
     expr->set_postfix_index ('.');
@@ -3131,26 +3118,26 @@ octave_parser::make_indirect_ref (tree_e
 
       tmp->append (elt);
 
       retval = tmp;
     }
   else
     retval = new tree_index_expression (expr, elt, l, c);
 
-  curr_lexer->looking_at_indirect_ref = false;
+  lexer.looking_at_indirect_ref = false;
 
   return retval;
 }
 
 // Make a declaration command.
 
 tree_decl_command *
-octave_parser::make_decl_command (int tok, token *tok_val,
-                                  tree_decl_init_list *lst)
+octave_base_parser::make_decl_command (int tok, token *tok_val,
+                                       tree_decl_init_list *lst)
 {
   tree_decl_command *retval = 0;
 
   int l = tok_val->line ();
   int c = tok_val->column ();
 
   switch (tok)
     {
@@ -3158,34 +3145,34 @@ octave_parser::make_decl_command (int to
       retval = new tree_global_command (lst, l, c);
       break;
 
     case PERSISTENT:
       if (curr_fcn_depth > 0)
         retval = new tree_persistent_command (lst, l, c);
       else
         {
-          if (curr_lexer->reading_script_file)
+          if (lexer.reading_script_file)
             warning ("ignoring persistent declaration near line %d of file '%s'",
-                     l, curr_lexer->fcn_file_full_name.c_str ());
+                     l, lexer.fcn_file_full_name.c_str ());
           else
             warning ("ignoring persistent declaration near line %d", l);
         }
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
   return retval;
 }
 
 bool
-octave_parser::validate_array_list (tree_expression *e)
+octave_base_parser::validate_array_list (tree_expression *e)
 {
   bool retval = true;
 
   tree_array_list *al = dynamic_cast<tree_array_list *> (e);
 
   for (tree_array_list::iterator i = al->begin (); i != al->end (); i++)
     {
       tree_argument_list *row = *i;
@@ -3200,17 +3187,17 @@ octave_parser::validate_array_list (tree
           break;
         }
     }
 
   return retval;
 }
 
 tree_argument_list *
-octave_parser::validate_matrix_for_assignment (tree_expression *e)
+octave_base_parser::validate_matrix_for_assignment (tree_expression *e)
 {
   tree_argument_list *retval = 0;
 
   if (e->is_constant ())
     {
       octave_value ov = e->rvalue1 ();
 
       if (ov.is_empty ())
@@ -3254,17 +3241,17 @@ octave_parser::validate_matrix_for_assig
     }
 
   return retval;
 }
 
 // Finish building an array_list.
 
 tree_expression *
-octave_parser::finish_array_list (tree_array_list *array_list)
+octave_base_parser::finish_array_list (tree_array_list *array_list)
 {
   tree_expression *retval = array_list;
 
   unwind_protect frame;
 
   frame.protect_var (error_state);
   frame.protect_var (warning_state);
 
@@ -3299,47 +3286,47 @@ octave_parser::finish_array_list (tree_a
     }
 
   return retval;
 }
 
 // Finish building a matrix list.
 
 tree_expression *
-octave_parser::finish_matrix (tree_matrix *m)
+octave_base_parser::finish_matrix (tree_matrix *m)
 {
   return finish_array_list (m);
 }
 
 // Finish building a cell list.
 
 tree_expression *
-octave_parser::finish_cell (tree_cell *c)
+octave_base_parser::finish_cell (tree_cell *c)
 {
   return finish_array_list (c);
 }
 
 void
-octave_parser::maybe_warn_missing_semi (tree_statement_list *t)
+octave_base_parser::maybe_warn_missing_semi (tree_statement_list *t)
 {
   if (curr_fcn_depth > 0)
     {
       tree_statement *tmp = t->back ();
 
       if (tmp->is_expression ())
         warning_with_id
           ("Octave:missing-semicolon",
            "missing semicolon near line %d, column %d in file '%s'",
-            tmp->line (), tmp->column (), curr_lexer->fcn_file_full_name.c_str ());
+            tmp->line (), tmp->column (), lexer.fcn_file_full_name.c_str ());
     }
 }
 
 tree_statement_list *
-octave_parser::set_stmt_print_flag (tree_statement_list *list, char sep,
-                                    bool warn_missing_semi)
+octave_base_parser::set_stmt_print_flag (tree_statement_list *list,
+                                         char sep, bool warn_missing_semi)
 {
   tree_statement *tmp = list->back ();
 
   switch (sep)
     {
     case ';':
       tmp->set_print_flag (false);
       break;
@@ -3365,53 +3352,52 @@ octave_parser::set_stmt_print_flag (tree
       list->pop_back ();
       delete tmp;
     }
 
   return list;
 }
 
 tree_statement_list *
-octave_parser::make_statement_list (tree_statement *stmt)
+octave_base_parser::make_statement_list (tree_statement *stmt)
 {
   return new tree_statement_list (stmt);
 }
 
 tree_statement_list *
-octave_parser::append_statement_list (tree_statement_list *list, char sep,
-                                      tree_statement *stmt,
-                                      bool warn_missing_semi)
+octave_base_parser::append_statement_list (tree_statement_list *list,
+                                           char sep, tree_statement *stmt,
+                                           bool warn_missing_semi)
 {
   set_stmt_print_flag (list, sep, warn_missing_semi);
 
   list->append (stmt);
 
   return list;
 }
 
 void
-octave_parser::bison_error (const char *s)
-
+octave_base_parser::bison_error (const char *s)
 {
-  int err_col = curr_lexer->current_input_column - 1;
+  int err_col = lexer.current_input_column - 1;
 
   std::ostringstream output_buf;
 
-  if (curr_lexer->reading_fcn_file || curr_lexer->reading_script_file || curr_lexer->reading_classdef_file)
-    output_buf << "parse error near line " << curr_lexer->input_line_number
-               << " of file " << curr_lexer->fcn_file_full_name;
+  if (lexer.reading_fcn_file || lexer.reading_script_file || lexer.reading_classdef_file)
+    output_buf << "parse error near line " << lexer.input_line_number
+               << " of file " << lexer.fcn_file_full_name;
   else
     output_buf << "parse error:";
 
   if (s && strcmp (s, "parse error") != 0)
     output_buf << "\n\n  " << s;
 
   output_buf << "\n\n";
 
-  std::string curr_line = curr_lexer->current_input_line;
+  std::string curr_line = lexer.current_input_line;
 
   if (! curr_line.empty ())
     {
       size_t len = curr_line.length ();
 
       if (curr_line[len-1] == '\n')
         curr_line.resize (len-1);
 
@@ -3430,16 +3416,22 @@ octave_parser::bison_error (const char *
 
   output_buf << "\n";
 
   std::string msg = output_buf.str ();
 
   parse_error ("%s", msg.c_str ());
 }
 
+int
+octave_parser::run (void)
+{
+  return octave_parse (*this);
+}
+
 static void
 safe_fclose (FILE *f)
 {
   // FIXME -- comments at the end of an input file are
   // discarded (otherwise, they would be appended to the next
   // statement, possibly from the command line or another file, which
   // can be quite confusing).
 
@@ -3476,49 +3468,49 @@ parse_fcn_file (const std::string& full_
 
   if (! full_file.empty ())
     ffile = gnulib::fopen (full_file.c_str (), "rb");
 
   frame.add_fcn (safe_fclose, ffile);
 
   if (ffile)
     {
-      // octave_parser constructor sets this for us.
-      frame.protect_var (CURR_LEXER);
-
-      octave_parser curr_parser (ffile);
-
-      curr_parser.curr_class_name = dispatch_type;
-      curr_parser.autoloading = autoload;
-      curr_parser.fcn_file_from_relative_lookup = relative_lookup;
-
-      curr_parser.curr_lexer->force_script = force_script;
-      curr_parser.curr_lexer->prep_for_file ();
-      curr_parser.curr_lexer->parsing_class_method = ! dispatch_type.empty ();
-
-      curr_parser.curr_lexer->fcn_file_name = file;
-      curr_parser.curr_lexer->fcn_file_full_name = full_file;
-
-      int status = curr_parser.run ();
-
-      fcn_ptr = curr_parser.primary_fcn_ptr;
+      // octave_base_parser constructor sets this for us.
+      frame.protect_var (LEXER);
+
+      octave_parser parser (ffile);
+
+      parser.curr_class_name = dispatch_type;
+      parser.autoloading = autoload;
+      parser.fcn_file_from_relative_lookup = relative_lookup;
+
+      parser.lexer.force_script = force_script;
+      parser.lexer.prep_for_file ();
+      parser.lexer.parsing_class_method = ! dispatch_type.empty ();
+
+      parser.lexer.fcn_file_name = file;
+      parser.lexer.fcn_file_full_name = full_file;
+
+      int status = parser.run ();
+
+      fcn_ptr = parser.primary_fcn_ptr;
 
       if (status == 0)
         {
-          if (curr_parser.curr_lexer->reading_classdef_file
-              && curr_parser.classdef_object)
+          if (parser.lexer.reading_classdef_file
+              && parser.classdef_object)
             {
               // Convert parse tree for classdef object to
               // meta.class info (and stash it in the symbol
               // table?).  Return pointer to constructor?
 
               if (fcn_ptr)
                 panic_impossible ();
 
-              fcn_ptr = curr_parser.classdef_object->make_meta_class ();
+              fcn_ptr = parser.classdef_object->make_meta_class ();
             }
         }
       else
         error ("parse error while reading file %s", full_file.c_str ());
     }
   else if (require_file)
     error ("no such file, '%s'", full_file.c_str ());
   else if (! warn_for.empty ())
@@ -4187,38 +4179,38 @@ another function for the given type sign
 octave_value_list
 eval_string (const std::string& eval_str, bool silent,
              int& parse_status, int nargout)
 {
   octave_value_list retval;
 
   unwind_protect frame;
 
-  // octave_parser constructor sets this for us.
-  frame.protect_var (CURR_LEXER);
-
-  octave_parser curr_parser (eval_str);
+  // octave_base_parser constructor sets this for us.
+  frame.protect_var (LEXER);
+
+  octave_parser parser (eval_str);
 
   do
     {
-      curr_parser.reset ();
-
-      parse_status = curr_parser.run ();
+      parser.reset ();
+
+      parse_status = parser.run ();
 
       // Unmark forced variables.
       frame.run (1);
 
       if (parse_status == 0)
         {
-          if (curr_parser.stmt_list)
+          if (parser.stmt_list)
             {
               tree_statement *stmt = 0;
 
-              if (curr_parser.stmt_list->length () == 1
-                  && (stmt = curr_parser.stmt_list->front ())
+              if (parser.stmt_list->length () == 1
+                  && (stmt = parser.stmt_list->front ())
                   && stmt->is_expression ())
                 {
                   tree_expression *expr = stmt->expression ();
 
                   if (silent)
                     expr->set_print_flag (false);
 
                   bool do_bind_ans = false;
@@ -4237,27 +4229,27 @@ eval_string (const std::string& eval_str
 
                   if (do_bind_ans && ! (error_state || retval.empty ()))
                     bind_ans (retval(0), expr->print_result ());
 
                   if (nargout == 0)
                     retval = octave_value_list ();
                 }
               else if (nargout == 0)
-                curr_parser.stmt_list->accept (*current_evaluator);
+                parser.stmt_list->accept (*current_evaluator);
               else
                 error ("eval: invalid use of statement list");
 
               if (error_state
                   || tree_return_command::returning
                   || tree_break_command::breaking
                   || tree_continue_command::continuing)
                 break;
             }
-          else if (curr_parser.curr_lexer->end_of_input)
+          else if (parser.lexer.end_of_input)
             break;
         }
     }
   while (parse_status == 0);
 
   return retval;
 }
 
diff --git a/libinterp/parse-tree/parse.h b/libinterp/parse-tree/parse.h
--- a/libinterp/parse-tree/parse.h
+++ b/libinterp/parse-tree/parse.h
@@ -131,67 +131,41 @@ eval_string (const std::string&, bool si
 
 extern OCTINTERP_API octave_value
 eval_string (const std::string&, bool silent, int& parse_status);
 
 extern OCTINTERP_API void cleanup_statement_list (tree_statement_list **lst);
 
 // Global access to currently active lexer.
 // FIXME -- to be removed after more parser+lexer refactoring.
-extern octave_lexer *CURR_LEXER;
+extern octave_lexer *LEXER;
 
 class
-octave_parser
+octave_base_parser
 {
 public:
 
-  octave_parser (void)
+  octave_base_parser (octave_lexer& lxr)
     : endfunction_found (false),
       autoloading (false), fcn_file_from_relative_lookup (false),
       parsing_subfunctions (false), max_fcn_depth (0),
       curr_fcn_depth (0), primary_fcn_scope (-1),
       curr_class_name (), function_scopes (), primary_fcn_ptr (0),
       classdef_object (0), stmt_list (0),
-      curr_lexer (new octave_lexer ()), parser_state (0)
-  {
-    init ();
-  }
-
-  octave_parser (FILE *file)
-    : endfunction_found (false),
-      autoloading (false), fcn_file_from_relative_lookup (false),
-      parsing_subfunctions (false), max_fcn_depth (0),
-      curr_fcn_depth (0), primary_fcn_scope (-1),
-      curr_class_name (), function_scopes (), primary_fcn_ptr (0),
-      stmt_list (0),
-      curr_lexer (new octave_lexer (file)), parser_state (0)
+      lexer (lxr), parser_state (0)
   {
     init ();
   }
 
-  octave_parser (const std::string& eval_string)
-    : endfunction_found (false),
-      autoloading (false), fcn_file_from_relative_lookup (false),
-      parsing_subfunctions (false), max_fcn_depth (0),
-      curr_fcn_depth (0), primary_fcn_scope (-1),
-      curr_class_name (), function_scopes (), primary_fcn_ptr (0),
-      stmt_list (0),
-      curr_lexer (new octave_lexer (eval_string)), parser_state (0)
-  {
-    init ();
-  }
-
-  ~octave_parser (void);
+  virtual ~octave_base_parser (void);
 
   void init (void);
 
   void reset (void);
 
-  int run (void);
-
   // Error mesages for mismatched end tokens.
   void end_error (const char *type, token::end_tok_type ettype, int l, int c);
 
   // Check to see that end tokens are properly matched.
   bool end_token_ok (token *tok, token::end_tok_type expected);
 
   // Maybe print a warning if an assignment expression is used as the
   // test in a logical expression.
@@ -459,24 +433,51 @@ public:
 
   // Pointer to the classdef object we just parsed, if any.
   tree_classdef *classdef_object;
 
   // Result of parsing input.
   tree_statement_list *stmt_list;
 
   // State of the lexer.
-  octave_lexer *curr_lexer;
+  octave_lexer& lexer;
 
   // Internal state of the parser.  Only used if USE_PUSH_PARSER is
   // defined.
   void *parser_state;
 
-  // For unwind protect.
-  static void cleanup (octave_parser *parser) { delete parser; }
+private:
+
+  // No copying!
+
+  octave_base_parser (const octave_base_parser&);
+
+  octave_base_parser& operator = (const octave_base_parser&);
+};
+
+class
+octave_parser : public octave_base_parser
+{
+public:
+
+  octave_parser (void)
+    : octave_base_parser (*(new octave_lexer ()))
+  { }
+
+  octave_parser (FILE *file)
+    : octave_base_parser (*(new octave_lexer (file)))
+  { }
+
+  octave_parser (const std::string& eval_string)
+    : octave_base_parser (*(new octave_lexer (eval_string)))
+  { }
+
+  ~octave_parser (void) { }
+
+  int run (void);
 
 private:
 
   // No copying!
 
   octave_parser (const octave_parser&);
 
   octave_parser& operator = (const octave_parser&);
