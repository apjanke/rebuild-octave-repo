# HG changeset patch
# User Rik <rik@octave.org>
# Date 1463784405 25200
#      Fri May 20 15:46:45 2016 -0700
# Node ID ffad2baa90f719f6d5c8b78fb1ef4f62b8d7db96
# Parent  c94fde6d7c270078c20f1973c406e85b2dc82e26
maint: Use newlines to make code more readable.

diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -432,22 +432,22 @@ parse_dbfunction_params (const char *who
 
 /*
 %!test
 %! dbclear all;   # Clear out breakpoints before test
 %! dbstop help;
 %! dbstop in ls;
 %! dbstop help at 100;
 %! dbstop in ls 100;
-%! dbstop help 200 if a==5;
+%! dbstop help 201 if a==5;
 %! dbstop if error Octave:undefined-function;
 %! s = dbstatus;
 %! dbclear all;
 %! assert ({s.bkpt(:).name}, {"help", "help", "help>do_contents", "ls", "ls"});
-%! assert ([s.bkpt(:).line], [48, 100, 200, 58, 100]);
+%! assert ([s.bkpt(:).line], [48, 100, 201, 58, 100]);
 %! assert (s.errs, {"Octave:undefined-function"});
 */
 
 // Return true if there is a valid breakpoint table, false otherwise.
 // If no table exists, one is created; false is only returned if this fails.
 bool
 bp_table::instance_ok (void)
 {
diff --git a/scripts/@ftp/cd.m b/scripts/@ftp/cd.m
--- a/scripts/@ftp/cd.m
+++ b/scripts/@ftp/cd.m
@@ -27,22 +27,25 @@
 ## directory.  Otherwise, set the remote directory to @var{path} and return
 ## the new remote working directory.
 ##
 ## If the directory does not exist, an error message is printed and the
 ## working directory is not changed.
 ## @end deftypefn
 
 function path = cd (f, path)
+
   if (nargin != 1 && nargin != 2)
     print_usage ();
   endif
 
   if (nargin == 2)
     __ftp_cwd__ (f.curlhandle, path);
   endif
+
   path = __ftp_pwd__ (f.curlhandle);
+
 endfunction
 
 
 ## No test possible for interactive function.
 %!assert (1)
 
diff --git a/scripts/@ftp/ftp.m b/scripts/@ftp/ftp.m
--- a/scripts/@ftp/ftp.m
+++ b/scripts/@ftp/ftp.m
@@ -41,26 +41,28 @@
 ## @item mput @tab Upload local files
 ## @item rename @tab Rename remote file or directory
 ## @item rmdir @tab Remove remote directory
 ## @end multitable
 ##
 ## @end deftypefn
 
 function obj = ftp (host = "", username = "anonymous", password = "")
+
   if (nargin == 1 && isa (host, "ftp"))
     obj = host;   # Copy constructor
   else
     p.host = host;
     p.username = username;
     p.password = password;
     p.curlhandle = tempname ("ftp-");
     if (nargin > 0)
       p.curlhandle = __ftp__ (host, username, password);
     endif
     obj = class (p, "ftp");
   endif
+
 endfunction
 
 
 ## No test possible for interactive function.
 %!assert (1)
 
diff --git a/scripts/@ftp/loadobj.m b/scripts/@ftp/loadobj.m
--- a/scripts/@ftp/loadobj.m
+++ b/scripts/@ftp/loadobj.m
@@ -12,29 +12,31 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 function b = loadobj (a)
+
   b = a;
   if (isfield (b, "jobject"))
     b = rmfield (b, "jobject");
   endif
   b.curlhandle = __ftp__ (b.host, b.username, b.password);
   if (isfield (b, "dir"))
     if (! isempty (b.dir))
       __ftp_cwd__ (b.curlhandle, b.dir);
     endif
     b = rmfield (b, "dir");
   elseif (isfield (b, "remotePwd"))
     ## FIXME: Can we read matlab java stringBuffer objects?
     warning ("@ftp/loadobj: can not change remote directory in loaded FTP object");
     b = rmfield (b, "remotePwd");
   endif
+
 endfunction
 
 
 ## No test possible for interactive function.
 %!assert (1)
 
diff --git a/scripts/audio/@audioplayer/set.m b/scripts/audio/@audioplayer/set.m
--- a/scripts/audio/@audioplayer/set.m
+++ b/scripts/audio/@audioplayer/set.m
@@ -57,19 +57,22 @@ function settable = set (varargin)
     endif
   else
     error ("@audioplayer/set: wrong number of arguments to the set method");
   endif
 
 endfunction
 
 function setproperty (player, property, value)
+
   switch (property)
     case "SampleRate"
       __player_set_fs__ (player, value);
     case "Tag"
       __player_set_tag__ (player, value);
     case "UserData"
       __player_set_userdata__ (player, value);
     otherwise
       error ("audioplayer: no such property or the property specified is read-only");
   endswitch
+
 endfunction
+
diff --git a/scripts/audio/@audioplayer/subsref.m b/scripts/audio/@audioplayer/subsref.m
--- a/scripts/audio/@audioplayer/subsref.m
+++ b/scripts/audio/@audioplayer/subsref.m
@@ -19,24 +19,26 @@
 ## -*- texinfo -*-
 ## @deftypefn {} {@var{value} =} subsref (@var{player}, @var{idx})
 ## Perform subscripted selection on the audio player object @var{player}.
 ##
 ## Return the player property value named by @var{idx}.
 ## @end deftypefn
 
 function value = subsref (player, idx)
+
   if (nargin != 2)
     print_usage ();
   endif
 
   if (isempty (idx))
     error ("@audioplayer/subsref: missing index");
   endif
 
   if (strcmp (idx(1).type, "."))
     field = idx.subs;
     value = get (player, field);
   else
     error ("@audioplayer/subsref: invalid subscript type");
   endif
 
 endfunction
+
diff --git a/scripts/audio/@audiorecorder/subsasgn.m b/scripts/audio/@audiorecorder/subsasgn.m
--- a/scripts/audio/@audiorecorder/subsasgn.m
+++ b/scripts/audio/@audiorecorder/subsasgn.m
@@ -19,16 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {} {@var{value} =} subsasgn (@var{recorder}, @var{idx}, @var{rhs})
 ## Perform subscripted assignment on the audio recorder object @var{recorder}.
 ##
 ## Assign the value of @var{rhs} to the recorder property named by @var{idx}.
 ## @end deftypefn
 
 function value = subsasgn (recorder, idx, rhs)
+
   if (nargin != 3)
     print_usage ();
   endif
 
   if (isempty (idx))
     error ("@audiorecorder/subsasgn: missing index");
   endif
 
@@ -36,8 +37,9 @@ function value = subsasgn (recorder, idx
     field = idx.subs;
     set (recorder, field, rhs);
     value = recorder;
   else
     error ("@audiorecorder/subsasgn: invalid subscript type");
   endif
 
 endfunction
+
diff --git a/scripts/general/accumarray.m b/scripts/general/accumarray.m
--- a/scripts/general/accumarray.m
+++ b/scripts/general/accumarray.m
@@ -365,16 +365,17 @@ function A = accumarray (subs, vals, sz 
       else
         A = repmat (fillval, sz);
       endif
 
       ## Set the reduced values.
       A(subs) = vals;
     endif
   endif
+
 endfunction
 
 
 %!assert (accumarray ([1; 2; 4; 2; 4], 101:105), [101; 206; 0; 208])
 %!assert (accumarray ([1 1 1; 2 1 2; 2 3 2; 2 1 2; 2 3 2], 101:105),
 %!                    cat (3, [101 0 0; 0 0 0], [0 0 0; 206 0 208]))
 
 %!assert (accumarray ([1 1 1; 2 1 2; 2 3 2; 2 1 2; 2 3 2], 101:105, [], @(x) sin (sum (x))),
diff --git a/scripts/general/bitcmp.m b/scripts/general/bitcmp.m
--- a/scripts/general/bitcmp.m
+++ b/scripts/general/bitcmp.m
@@ -66,16 +66,17 @@ function C = bitcmp (A, k)
   else
     m = double (k);
     if (any (m < 1) || any (m > amax))
       error ("bitcmp: K must be in the range [1,%d]", amax);
     endif
     mask = bitshift (bmax, k - amax);
     C = bitxor (bitand (A, mask), mask);
   endif
+
 endfunction
 
 
 %!test
 %! Amax = 53;
 %! Bmax = flintmax - 1;
 %! A = bitshift (Bmax,-2);
 %! assert (bitcmp (A,Amax),bitor (bitshift (1,Amax-1), bitshift (1,Amax-2)));
diff --git a/scripts/general/celldisp.m b/scripts/general/celldisp.m
--- a/scripts/general/celldisp.m
+++ b/scripts/general/celldisp.m
@@ -64,27 +64,30 @@ function celldisp (c, name)
     if (iscell (c{i}))
       celldisp (c{i}, sprintf ("%s{%s}", name, indices (size (c), i)));
     else
       disp (sprintf ("%s{%s} = \n", name, indices (size (c), i)));
       disp (c{i});
       disp ("");
     endif
   endfor
+
 endfunction
 
 function s = indices (dv, i)
+
   if (sum (dv != 1) > 1)
     c = cell (size (dv));
     [c{:}] = ind2sub (dv, i);
     s = sprintf ("%i,", c{:});
     s(end) = [];
   else
     s = sprintf ("%i", i);
   endif
+
 endfunction
 
 
 %!demo
 %! c = {1, 2, {31, 32}};
 %! celldisp (c, "b")
 
 ## Test input validation
diff --git a/scripts/general/common_size.m b/scripts/general/common_size.m
--- a/scripts/general/common_size.m
+++ b/scripts/general/common_size.m
@@ -73,16 +73,17 @@ function [errorcode, varargout] = common
         if (any (nscal))
           dims = size (varargin{find (nscal, 1)});
           subs = arrayfun (@ones, 1, dims, "uniformoutput", false);
           varargout(scal) = cellindexmat (varargin(scal), subs{:});
         endif
       endif
     endif
   endif
+
 endfunction
 
 
 %!test
 %! m = [1,2;3,4];
 %! [err, a, b, c] = common_size (m, 3, 5);
 %! assert (err, 0);
 %! assert (a, m);
diff --git a/scripts/general/dblquad.m b/scripts/general/dblquad.m
--- a/scripts/general/dblquad.m
+++ b/scripts/general/dblquad.m
@@ -60,16 +60,17 @@ function q = dblquad (f, xa, xb, ya, yb,
   inner = @__dblquad_inner__;
   if (ischar (f))
     f = @(x,y) feval (f, x, y, varargin{:});
     varargin = {};
   endif
 
   q = feval (quadf, @(y) inner (y, f, xa, xb, tol, quadf,
                                 varargin{:}), ya, yb, tol);
+
 endfunction
 
 function q = __dblquad_inner__ (y, f, xa, xb, tol, quadf, varargin)
   q = zeros (size (y));
   for i = 1 : length (y)
     q(i) = feval (quadf, @(x) f(x, y(i), varargin{:}), xa, xb, tol);
   endfor
 endfunction
diff --git a/scripts/general/del2.m b/scripts/general/del2.m
--- a/scripts/general/del2.m
+++ b/scripts/general/del2.m
@@ -152,16 +152,17 @@ function D = del2 (M, varargin)
             dx{i}(sz(i) - 1) / dx{i}(sz(i) - 2) * DD(idx3{:});
       endif
 
       D += DD;
     endif
   endfor
 
   D ./= nd;
+
 endfunction
 
 
 ## 3x3 constant test
 %!test
 %! a = ones (3,3);
 %! b = del2 (a);
 %! assert (b(:,1), [0.00;0.00;0.00]);
diff --git a/scripts/general/gradient.m b/scripts/general/gradient.m
--- a/scripts/general/gradient.m
+++ b/scripts/general/gradient.m
@@ -79,16 +79,17 @@ function varargout = gradient (m, vararg
                                                        varargin{:});
   else
     error ("gradient: first input must be an array or a function");
   endif
 
 endfunction
 
 function varargout = matrix_gradient (m, varargin)
+
   transposed = false;
   if (isvector (m))
     ## make a row vector.
     transposed = (columns (m) == 1);
     m = m(:).';
   endif
 
   nd = ndims (m);
@@ -163,19 +164,21 @@ function varargout = matrix_gradient (m,
       varargout{i} = shiftdim (Y, nd - i + 1);
       m = shiftdim (m, 1);
     endif
   endfor
 
   if (transposed)
     varargout{1} = varargout{1}.';
   endif
+
 endfunction
 
 function varargout = handle_gradient (f, p0, varargin)
+
   ## Input checking
   p0_size = size (p0);
 
   if (numel (p0_size) != 2)
     error ("gradient: the second input argument should either be a vector or a matrix");
   endif
 
   if (any (p0_size == 1))
@@ -213,16 +216,17 @@ function varargout = handle_gradient (f,
     df_dx = (f (p0{1:d-1}, p0{d}+s, p0{d+1:end})
            - f (p0{1:d-1}, p0{d}-s, p0{d+1:end})) ./ (2*s);
     if (dim == 1)
       varargout{d} = reshape (df_dx, p0_size);
     else
       varargout{d} = df_dx;
     endif
   endfor
+
 endfunction
 
 
 %!test
 %! data = [1, 2, 4, 2];
 %! dx = gradient (data);
 %! dx2 = gradient (data, 0.25);
 %! dx3 = gradient (data, [0.25, 0.5, 1, 3]);
diff --git a/scripts/general/idivide.m b/scripts/general/idivide.m
--- a/scripts/general/idivide.m
+++ b/scripts/general/idivide.m
@@ -61,16 +61,17 @@
 ##   @result{} int8 ([0, 1])
 ## @end group
 ## @end example
 ##
 ## @seealso{ldivide, rdivide}
 ## @end deftypefn
 
 function z = idivide (x, y, op)
+
   if (nargin < 2 || nargin > 3)
     print_usage ();
   elseif (nargin == 2)
     op = "fix";
   else
     op = tolower (op);
   endif
 
@@ -93,16 +94,17 @@ function z = idivide (x, y, op)
     elseif (strcmp (op, "floor"))
       z = cast (floor (double (x) ./ double (y)), typ);
     elseif (strcmp (op, "ceil"))
       z = cast (ceil (double (x) ./ double (y)), typ);
     else
       error ("idivide: unrecognized rounding type");
     endif
   endif
+
 endfunction
 
 
 %!shared a, af, b, bf
 %! a = int8 (3);
 %! af = 3;
 %! b = int8 ([-4, 4]);
 %! bf = [-4, 4];
diff --git a/scripts/general/nthargout.m b/scripts/general/nthargout.m
--- a/scripts/general/nthargout.m
+++ b/scripts/general/nthargout.m
@@ -62,16 +62,17 @@
 ## @end example
 ##
 ## @seealso{nargin, nargout, varargin, varargout, isargout}
 ## @end deftypefn
 
 ## Author: Jordi Gutiérrez Hermoso
 
 function out = nthargout (n, varargin)
+
   if (nargin < 2)
     print_usage ();
   endif
 
   if (isa (varargin{1}, "function_handle") || ischar (varargin{1}))
     ntot = max (n(:));
     func = varargin{1};
     args = varargin(2:end);
diff --git a/scripts/general/polyarea.m b/scripts/general/polyarea.m
--- a/scripts/general/polyarea.m
+++ b/scripts/general/polyarea.m
@@ -44,27 +44,29 @@
 ## Modified-by:
 ##    2000-01-15 Paul Kienzle <pkienzle@kienzle.powernet.co.uk>
 ##    * use matlab compatible interface
 ##    * return absolute value of area so traversal order doesn't matter
 ##    2005-10-13 Torsten Finke
 ##    * optimization saving half the sums and multiplies
 
 function a = polyarea (x, y, dim)
+
   if (nargin != 2 && nargin != 3)
     print_usage ();
-  elseif (size_equal (x, y))
-    if (nargin == 2)
-      a = abs (sum (x .* (shift (y, -1) - shift (y, 1)))) / 2;
-    else
-      a = abs (sum (x .* (shift (y, -1, dim) - shift (y, 1, dim)), dim)) / 2;
-    endif
-  else
+  elseif (! size_equal (x, y))
     error ("polyarea: X and Y must have the same shape");
   endif
+
+  if (nargin == 2)
+    a = abs (sum (x .* (shift (y, -1) - shift (y, 1)))) / 2;
+  else
+    a = abs (sum (x .* (shift (y, -1, dim) - shift (y, 1, dim)), dim)) / 2;
+  endif
+
 endfunction
 
 
 %!shared x, y
 %! x = [1;1;3;3;1];
 %! y = [1;3;3;1;1];
 %!assert (polyarea (x,y), 4, eps)
 %!assert (polyarea ([x,x],[y,y]), [4,4], eps)
diff --git a/scripts/general/private/__splinen__.m b/scripts/general/private/__splinen__.m
--- a/scripts/general/private/__splinen__.m
+++ b/scripts/general/private/__splinen__.m
@@ -21,16 +21,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {} {@var{yi} =} __splinen__ (@var{x}, @var{y}, @var{xi})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## FIXME: Allow arbitrary grids..
 
 function yi = __splinen__ (x, y, xi, extrapval, f)
+
   ## ND isvector function.
   isvec = @(x) numel (x) == length (x);
   if (! iscell (x) || length (x) < ndims (y) || any (! cellfun (isvec, x))
       || ! iscell (xi) || length (xi) < ndims (y)
       || any (! cellfun (isvec, xi)))
     error ("__splinen__: %s: non-gridded data or dimensions inconsistent", f);
   endif
   yi = y;
@@ -41,10 +42,11 @@ function yi = __splinen__ (x, y, xi, ext
   [xi{:}] = ndgrid (cellfun (@(x) x(:), xi, "uniformoutput", false){:});
   if (! isempty (extrapval))
     idx = zeros (size (xi{1}));
     for i = 1 : length (x)
       idx |= xi{i} < min (x{i}(:)) | xi{i} > max (x{i}(:));
     endfor
     yi(idx) = extrapval;
   endif
+
 endfunction
 
diff --git a/scripts/general/profexplore.m b/scripts/general/profexplore.m
--- a/scripts/general/profexplore.m
+++ b/scripts/general/profexplore.m
@@ -129,10 +129,11 @@ function rv = __profexplore_worker (fcn_
       printf ("Invalid 'up' command.  Type 'help' for further");
       printf (" information.\n");
     else
       printf ("Unrecognized input.  Type 'help' to get a list of possible");
       printf (" commands.\n");
     endif
 
   endwhile
+
 endfunction
 
diff --git a/scripts/general/quadgk.m b/scripts/general/quadgk.m
--- a/scripts/general/quadgk.m
+++ b/scripts/general/quadgk.m
@@ -442,16 +442,17 @@ function [q, err] = __quadgk_eval__ (f, 
   center = sum (subs, 2) ./ 2;
   x = (halfwidth * abscissa) + center;
   y = reshape (f (x(:)), size (x));
 
   ## This is faster than using bsxfun as the * operator can use a
   ## single BLAS call, rather than rows (sub) calls to the @times function.
   q = sum (y * weights15, 2) .* halfwidth;
   err = abs (sum (y(:,2:2:end) * weights7, 2) .* halfwidth - q);
+
 endfunction
 
 function t = __quadgk_finite_waypoint__ (x, a, b)
   c = (-4 .* x + 2.* (b + a)) ./ (b - a);
   k = ((sqrt (c .^ 2 - 4) + c) ./ 2) .^ (1/3);
   t = real ((sqrt(3) .* 1i * (1 - k .^ 2) - (1 + k .^ 2)) ./ 2 ./ k);
 endfunction
 
diff --git a/scripts/general/quadv.m b/scripts/general/quadv.m
--- a/scripts/general/quadv.m
+++ b/scripts/general/quadv.m
@@ -109,16 +109,17 @@ function [q, nfun] = quadv (f, a, b, tol
   elseif (hmin < (b - a) * eps)
     warning ("quadv: minimum step size reached -- possible singular integral");
   endif
 
 endfunction
 
 function [q, nfun, hmin] = simpsonstp (f, a, b, c, fa, fb, fc, q0, nfun, hmin,
                                        tol, trace, varargin)
+
   if (nfun > 10_000)
     q = q0;
   else
     d = (a + c) / 2;
     e = (c + b) / 2;
     fd = feval (f, d, varargin{:});
     fe = feval (f, e, varargin{:});
     nfun += 2;
diff --git a/scripts/general/structfun.m b/scripts/general/structfun.m
--- a/scripts/general/structfun.m
+++ b/scripts/general/structfun.m
@@ -102,16 +102,17 @@ function varargout = structfun (func, S,
 
   varargout = cell (max ([nargout, 1]), 1);
   [varargout{:}] = cellfun (func, struct2cell (S), varargin{:});
 
   if (! uniform_output)
     varargout = cellfun ("cell2struct", varargout, {fieldnames(S)}, {1}, ...
                          uo_str, false);
   endif
+
 endfunction
 
 
 %!test
 %! s.name1 = "John Smith";
 %! s.name2 = "Jill Jones";
 %! l.name1 = "Smith";
 %! l.name2 = "Jones";
diff --git a/scripts/general/trapz.m b/scripts/general/trapz.m
--- a/scripts/general/trapz.m
+++ b/scripts/general/trapz.m
@@ -117,16 +117,17 @@ function z = trapz (x, y, dim)
       z = 0.5 * sum (diff (x) .* (y(idx1{:}) + y(idx2{:})), dim);
     else
       if (! size_equal (x, y))
         error ("trapz: X and Y must have same shape");
       endif
       z = 0.5 * sum (diff (x, 1, dim) .* (y(idx1{:}) + y(idx2{:})), dim);
     endif
   endif
+
 endfunction
 
 
 %!assert (trapz (1:5), 12)
 %!assert (trapz (0:0.5:2,1:5), 6)
 %!assert (trapz ([1:5;1:5].',1), [12,12])
 %!assert (trapz ([1:5;1:5],2), [12;12])
 %!assert (trapz (repmat (reshape (1:5,1,1,5),2,2), 3), [12 12; 12 12])
diff --git a/scripts/general/validateattributes.m b/scripts/general/validateattributes.m
--- a/scripts/general/validateattributes.m
+++ b/scripts/general/validateattributes.m
@@ -325,16 +325,17 @@ function validateattributes (A, cls, att
         endif
       otherwise
         error ("validateattributes: unknown ATTRIBUTE %s", attr{idx-1});
     endswitch
     if (problem)
       error ("%s must be %s", err_ini, attr{idx-1});
     endif
   endwhile
+
 endfunction
 
 function retval = valid_arg_idx (arg)
   retval = isnumeric (arg) && isscalar (arg) && arg > 0 && arg == fix (arg);
 endfunction
 
 function cls = replace_cl_group (cls, name, group)
   num_pos = strcmpi (cls, name);
diff --git a/scripts/geometry/dsearch.m b/scripts/geometry/dsearch.m
--- a/scripts/geometry/dsearch.m
+++ b/scripts/geometry/dsearch.m
@@ -22,20 +22,23 @@
 ## Return the index @var{idx} of the closest point in @code{@var{x}, @var{y}}
 ## to the elements @code{[@var{xi}(:), @var{yi}(:)]}.
 ##
 ## The variable @var{s} is accepted for compatibility but is ignored.
 ## @seealso{dsearchn, tsearch}
 ## @end deftypefn
 
 function idx = dsearch (x, y, tri, xi, yi, s)
+
   if (nargin < 5 || nargin > 6)
     print_usage ();
   endif
+
   idx = __dsearchn__ ([x(:), y(:)], [xi(:), yi(:)]);
+
 endfunction
 
 
 %!shared x, y, tri
 %! x = [-1;-1;1];
 %! y = [-1;1;-1];
 %! tri = [1,2,3];
 %!assert (dsearch (x,y,tri,1,1/3), 3)
diff --git a/scripts/geometry/dsearchn.m b/scripts/geometry/dsearchn.m
--- a/scripts/geometry/dsearchn.m
+++ b/scripts/geometry/dsearchn.m
@@ -26,30 +26,32 @@
 ##
 ## If @var{outval} is supplied, then the values of @var{xi} that are not
 ## contained within one of the simplices @var{tri} are set to @var{outval}.
 ## Generally, @var{tri} is returned from @code{delaunayn (@var{x})}.
 ## @seealso{dsearch, tsearch}
 ## @end deftypefn
 
 function [idx, d] = dsearchn (x, tri, xi, outval)
+
   if (nargin < 2 || nargin > 4)
     print_usage ();
   endif
 
   if (nargin == 2)
     [idx, d] = __dsearchn__ (x, tri);
   else
     [idx, d] = __dsearchn__ (x, xi);
     if (nargin == 4)
       idx2 = isnan (tsearchn (x, tri, xi));
       idx(idx2) = outval;
       d(idx2) = outval;
     endif
   endif
+
 endfunction
 
 
 %!shared x, tri
 %! x = [-1,-1;-1,1;1,-1];
 %! tri = [1,2,3];
 %!assert (dsearchn (x,tri,[1,1/3]), 3)
 %!assert (dsearchn (x,tri,[1,1/3],NaN), NaN)
diff --git a/scripts/geometry/tsearchn.m b/scripts/geometry/tsearchn.m
--- a/scripts/geometry/tsearchn.m
+++ b/scripts/geometry/tsearchn.m
@@ -26,16 +26,17 @@
 ## @var{idx} is NaN.
 ##
 ## If requested @code{tsearchn} also returns the Barycentric coordinates
 ## @var{p} of the enclosing triangles.
 ## @seealso{delaunay, delaunayn}
 ## @end deftypefn
 
 function [idx, p] = tsearchn (x, t, xi)
+
   if (nargin != 3)
     print_usage ();
   endif
 
   nt = rows (t);
   [m, n] = size (x);
   mi = rows (xi);
   idx = NaN (mi, 1);
@@ -51,16 +52,17 @@ function [idx, p] = tsearchn (x, t, xi)
     ## (all (b >= 0) && all (b <= 1)).  However as we impose that
     ## sum (b,2) == 1 we only need to test all(b>=0).  Note need to add
     ## a small margin for rounding errors
     intri = all (b >= -1e-12, 2);
     idx(ni(intri)) = i;
     p(ni(intri),:) = b(intri, :);
     ni(intri) = [];
   endfor
+
 endfunction
 
 function Beta = cart2bary (T, P)
   ## Conversion of Cartesian to Barycentric coordinates.
   ## Given a reference simplex in N dimensions represented by a
   ## (N+1)-by-(N) matrix, and arbitrary point P in cartesion coordinates,
   ## represented by a N-by-1 row vector can be written as
   ##
@@ -79,16 +81,17 @@ function Beta = cart2bary (T, P)
   ##
   ## Beta(1:end-1) = (P - T(end,:)) / (T(1:end-1,:) - ones (N,1) * T(end,:))
   ## Beta(end) = sum (Beta)
   ##
   ## Note below is generalize for multiple values of P, one per row.
   [M, N] = size (P);
   Beta = (P - ones (M,1) * T(end,:)) / (T(1:end-1,:) - ones (N,1) * T(end,:));
   Beta (:,end+1) = 1 - sum (Beta, 2);
+
 endfunction
 
 
 %!shared x, tri
 %! x = [-1,-1;-1,1;1,-1];
 %! tri = [1, 2, 3];
 %!test
 %! [idx, p] = tsearchn (x,tri,[-1,-1]);
diff --git a/scripts/gui/waitbar.m b/scripts/gui/waitbar.m
--- a/scripts/gui/waitbar.m
+++ b/scripts/gui/waitbar.m
@@ -156,16 +156,17 @@ function h = waitbar (varargin)
   endif
 
   ## If there were no errors, update current waitbar.
   curr_waitbar = hf;
 
 endfunction
 
 function updatecancelbutton (hf, dummy, hax)
+
   if (! strcmpi (get (hf, "__graphics_toolkit__"), "qt"))
     return
   endif
 
   hbtn = findobj (hf, "type", "uicontrol", "-and", "style", "pushbutton");
   cb = get (hf, "createcancelbtn");
   if (! isempty (cb))
     if (isempty (hbtn))
@@ -194,16 +195,17 @@ function updatecancelbutton (hf, dummy, 
     apos = get (hax, "position");
 
     fpos (2) += 40;
     fpos (4) -= 40;
     apos (2) -= 40;
     set (hf, "position", fpos);
     set (hax, "position", apos, "units", units);
   endif
+
 endfunction
 
 
 %!demo
 %! h = waitbar (0, '0.00%');
 %! for i = 0:0.01:1
 %!   waitbar (i, h, sprintf ('%.2f%%', 100*i));
 %! end
diff --git a/scripts/help/__unimplemented__.m b/scripts/help/__unimplemented__.m
--- a/scripts/help/__unimplemented__.m
+++ b/scripts/help/__unimplemented__.m
@@ -521,32 +521,34 @@ function txt = __unimplemented__ (fcn)
 
   if (nargout == 0)
     warning ("Octave:missing-function", "%s", txt);
   endif
 
 endfunction
 
 function txt = check_package (fcn, name)
+
   txt = sprintf ("the '%s' function belongs to the %s package from Octave Forge",
                  fcn, name);
 
   [~, status] = pkg ("describe", name);
   switch (tolower (status{1}))
     case "loaded",
       txt = sprintf ("%s but has not yet been implemented.", txt);
     case "not loaded",
       txt = sprintf (["%s which you have installed but not loaded.  To ", ...
                       "load the package, run `pkg load %s' from the ", ...
                       "Octave prompt."], txt, name);
     otherwise
       ## this includes "not installed" and anything else if pkg changes
       ## the output of describe
       txt = sprintf ("%s which seems to not be installed in your system.", txt);
   endswitch
+
 endfunction
 
 function list = missing_functions ()
   persistent list = {
   "addcats",
   "addCause",
   "align",
   "alim",
diff --git a/scripts/help/doc_cache_create.m b/scripts/help/doc_cache_create.m
--- a/scripts/help/doc_cache_create.m
+++ b/scripts/help/doc_cache_create.m
@@ -61,16 +61,17 @@ function doc_cache_create (out_file = "d
   if (! isempty (cache))
      save_header_format_string (["# doc-cache created by Octave " OCTAVE_VERSION], "local");
      save ("-text", out_file, "cache");
   endif
 
 endfunction
 
 function [text, first_sentence, status] = handle_function (f, text, format)
+
   first_sentence = "";
   ## Skip internal functions starting with "__"
   if (strncmp (f, "__", 2))
     status = 1;
     return;
   endif
 
   ## Take action depending on help text format
@@ -88,19 +89,21 @@ function [text, first_sentence, status] 
   ## Did we get the help text?
   if (status != 0 || isempty (text))
     warning ("doc_cache_create: unusable help text found in file '%s'", f);
     return;
   endif
 
   ## Get first sentence of help text
   first_sentence = get_first_help_sentence (f);
+
 endfunction
 
 function cache = create_cache (list)
+
   cache = {};
 
   ## For each function:
   for n = 1:length (list)
     f = list{n};
 
     ## Get help text
     [text, format] = get_help_text (f);
@@ -112,16 +115,17 @@ function cache = create_cache (list)
       continue;
     endif
 
     ## Store the help text
     cache(1, end+1) = f;
     cache(2, end) = text;
     cache(3, end) = first_sentence;
   endfor
+
 endfunction
 
 function cache = gen_doc_cache_in_dir (directory)
 
   ## If 'directory' is not in the current path, add it so we search it
   dir_in_path = ismember (directory, ostrsplit (path (), pathsep ()));
 
   ## dirs not in path
@@ -145,21 +149,23 @@ function cache = gen_doc_cache_in_dir (d
   ## remove dirs from path
   if (! isempty (dirs_notpath))
     rmpath (dirs_notpath{:});
   endif
 
 endfunction
 
 function cache = gen_builtin_cache ()
+
   operators = __operators__ ();
   keywords = __keywords__ ();
   builtins = __builtins__ ();
   list = {operators{:}, keywords{:}, builtins{:}};
 
   cache = create_cache (list);
+
 endfunction
 
 
 ## No true tests desirable for this function.
 ## Test input validation
 %!error doc_cache_create (1)
 
diff --git a/scripts/help/get_first_help_sentence.m b/scripts/help/get_first_help_sentence.m
--- a/scripts/help/get_first_help_sentence.m
+++ b/scripts/help/get_first_help_sentence.m
@@ -37,17 +37,17 @@
 ## @group
 ## get_first_help_sentence ("get_first_help_sentence")
 ## @print{} ans = Return the first sentence of a function's help text.
 ## @end group
 ## @end example
 ## @end deftypefn
 
 function [text, status] = get_first_help_sentence (name, max_len = 80)
-  ## Check input
+
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (! ischar (name))
     error ("get_first_help_sentence: NAME must be a string");
   endif
 
@@ -72,16 +72,17 @@ function [text, status] = get_first_help
       error ("get_first_help_sentence: '%s' not found\n", name);
     otherwise
       error ("get_first_help_sentence: internal error: unsupported help text format: '%s'\n", format);
   endswitch
 
   if (nargout <= 1 && status != 0)
     warning ("get_first_help_sentence: couldn't run makeinfo on '%s'", name);
   endif
+
 endfunction
 
 ## This function extracts the first sentence from a plain text help text
 function [text, status] = first_sentence_plain_text (help_text, max_len)
   ## Extract first line by searching for a period followed by a space class
   ## character (to support periods in numbers or words) ...
   period_idx = regexp (help_text, '\.\s', "once");
   ## ... or a double end-of-line (we subtract 1 because we are not interested
@@ -135,16 +136,17 @@ function [text, status] = first_sentence
     help_text = help_text(keep);
   endif
 
   ## Run makeinfo to generate plain text
   [help_text, status] = __makeinfo__ (help_text, "plain text");
 
   ## Extract first line with plain text method.
   text = first_sentence_plain_text (help_text, max_len);
+
 endfunction
 
 ## This function extracts the first sentence from a html help text.
 ## The function simply removes the tags and treats the text as plain text.
 function [text, status] = first_sentence_html (help_text, max_len)
   ## Strip tags
   [help_text, status] = strip_html_tags (help_text);
 
diff --git a/scripts/help/help.m b/scripts/help/help.m
--- a/scripts/help/help.m
+++ b/scripts/help/help.m
@@ -125,17 +125,16 @@ function retval = help (name)
 
   else
     error ("help: invalid input\n");
   endif
 
 endfunction
 
 function retval = do_list_operators ()
-
   retval = sprintf ("*** operators:\n\n%s\n\n",
                     list_in_columns (__operators__ ()));
 endfunction
 
 function retval = do_list_functions ()
 
   operators = do_list_operators ();
 
diff --git a/scripts/help/lookfor.m b/scripts/help/lookfor.m
--- a/scripts/help/lookfor.m
+++ b/scripts/help/lookfor.m
@@ -178,20 +178,23 @@ function [fcn, help1str] = lookfor (str,
     ## Return the results instead of displaying them
     fcn = fcnlist;
     help1str = help_text;
   endif
 
 endfunction
 
 function [fcns, help_texts] = search_cache (str, cache_file, search_type)
+
   load (cache_file);
-  if (! isempty (cache))
-    t1 = strfind (lower (cache (1, :)), str);
-    t2 = strfind (lower (cache (search_type, :)), str);
+
+  if (isempty (cache))
+    fcns = help_texts = {};
+  else
+    t1 = strfind (lower (cache(1, :)), str);
+    t2 = strfind (lower (cache(search_type, :)), str);
     cache_idx = find (! (cellfun ("isempty", t1) & cellfun ("isempty", t2)));
     fcns = cache(1, cache_idx);
     help_texts = cache(3, cache_idx);
-  else
-    fcns = help_texts = {};
   endif
+
 endfunction
 
diff --git a/scripts/help/print_usage.m b/scripts/help/print_usage.m
--- a/scripts/help/print_usage.m
+++ b/scripts/help/print_usage.m
@@ -22,16 +22,17 @@
 ## Print the usage message for the function @var{name}.
 ##
 ## When called with no input arguments the @code{print_usage} function displays
 ## the usage message of the currently executing function.
 ## @seealso{help}
 ## @end deftypefn
 
 function print_usage (name)
+
   x = dbstack ();
   ## Handle input
   if (nargin == 0)
     ## Determine the name of the calling function
     if (numel (x) > 1)
       name = x(2).name;
     else
       error ("Octave:invalid-context", "print_usage: invalid function\n");
@@ -95,16 +96,17 @@ endfunction
 function [retval, status] = get_usage_plain_text (help_text, max_len)
   ## Extract first line by searching for a double line-end.
   line_end_idx = strfind (help_text, "\n\n");
   retval = help_text (1:min ([line_end_idx , max_len, length(help_text)]));
   status = 0;
 endfunction
 
 function [retval, status] = get_usage_texinfo (help_text, max_len)
+
   ## Lines ending with "@\n" are continuation lines, so they should be
   ## concatenated with the following line.
   help_text = strrep (help_text, "@\n", " ");
 
   ## Find, and keep, lines that start with @def or @end def.  This should
   ## include things such as @deftypefn, @deftypefnx, @defvar, etc. and their
   ## corresponding @end's.
   def_idx = strfind (help_text, "@def");
@@ -122,16 +124,17 @@ function [retval, status] = get_usage_te
       endif
     endfor
   else
     [retval, status] = get_usage_plain_text (help_text, max_len);
   endif
 
   ## Run makeinfo to generate plain text
   [retval, status] = __makeinfo__ (buffer, "plain text");
+
 endfunction
 
 function [retval, status] = get_usage_html (help_text, max_len)
   ## Strip tags
   [help_text, status] = strip_html_tags (help_text);
 
   ## Extract first line with plain text method.
   retval = get_usage_plain_text (help_text, max_len);
diff --git a/scripts/help/private/__strip_html_tags__.m b/scripts/help/private/__strip_html_tags__.m
--- a/scripts/help/private/__strip_html_tags__.m
+++ b/scripts/help/private/__strip_html_tags__.m
@@ -20,35 +20,38 @@
 ## @deftypefn {} {[@var{text}, @var{status}] =} __strip_html_tags__ (@var{html_text})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Remove HTML tags from text.  This is used as a simple HTML-to-text
 ## function.
 
 function [text, status] = __strip_html_tags__ (html_text)
+
   start = find (html_text == "<");
   stop  = find (html_text == ">");
   if (length (start) == length (stop))
     text = html_text;
     for n = length(start):-1:1
       text (start (n):stop (n)) = [];
     endfor
     text = strip_superfluous_endlines (text);
     status = 0;
   else
     warning ("help: invalid HTML data -- raw HTML source follows...");
     disp (html_text);
     text = "";
     status = 1;
   endif
+
 endfunction
 
 ## This function removes end-lines (\n) that makes printing look bad
 function text = strip_superfluous_endlines (text)
+
   ## Find groups of end-lines
   els = find (text == "\n");
   dels = diff (els);
   groups = [els(1), 1]; # list containing [start, length] of each group
   for k = 1:length (dels)
     if (dels (k) == 1)
       groups(end, 2) ++;
     else
@@ -73,10 +76,11 @@ function text = strip_superfluous_endlin
   for k = 1:length (idx)
     start = groups(idx(k), 1);
     stop = start + groups(idx(k), 2) - 1;
     keep(start+2:stop) = false;
   endfor
 
   ## Actually remove the elements
   text = text(keep);
+
 endfunction
 
diff --git a/scripts/help/type.m b/scripts/help/type.m
--- a/scripts/help/type.m
+++ b/scripts/help/type.m
@@ -119,16 +119,17 @@ function text = type (varargin)
     endif
 
     if (nargout == 0)
       disp (txt);
     else
       text{n} = txt;
     endif
   endfor
+
 endfunction
 
 
 %!test
 %! var = 1;
 %! text = type ("var");
 %! typestr = text{1}(1:17);
 %! assert (typestr, "var is a variable");
diff --git a/scripts/image/colormap.m b/scripts/image/colormap.m
--- a/scripts/image/colormap.m
+++ b/scripts/image/colormap.m
@@ -55,16 +55,17 @@
 ## @seealso{viridis}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function cmap = colormap (varargin)
+
   mlock; # prevent map_list to be cleared by "clear all"
   persistent map_list = cell ();
 
   [hax, varargin, nargin] = __plt_get_axis_arg__ ("colormap", varargin{:});
 
   if (nargin > 2)
     print_usage ();
   endif
diff --git a/scripts/image/cubehelix.m b/scripts/image/cubehelix.m
--- a/scripts/image/cubehelix.m
+++ b/scripts/image/cubehelix.m
@@ -49,42 +49,42 @@
 function map = cubehelix (n = rows (colormap ()), start = 0.5,
                           rots = -1.5, hue = 1, gamma = 1)
 
   if (nargin > 5)
     print_usage ();
   elseif (! isscalar (n))
     error ("cubehelix: N must be a scalar");
   endif
+
   n = double (n);
-
   if (n > 1)
     coeff = [ -0.14861  -0.29227   1.97294
                1.78277  -0.90649   0.00000];
 
     fract = ((0:n-1) / (n-1))';
     angle = 2 * pi * (start/3 + 1 + rots*fract);
     fract .^= gamma;
     amp   = hue * fract .* (1-fract) /2;
     map   = fract + amp .* ([cos(angle) sin(angle)] * coeff);
 
     ## Clip values (only in case users have changed values of hue or gamma)
     map(map < 0) = 0;
     map(map > 1) = 1;
-
   elseif (n > 0)
     map = [0, 0, 0];
   else
     map = zeros (0, 3);
   endif
 
 endfunction
 
 
-## A better demo of this colormap would be a 3d plot in ntsc instead of
-## rgb values.  That would really show what this colormap is about.
+## A better demo of this colormap would be a 3D plot in NTSC instead of
+## RGB values.  That would really show what this colormap is about.
 %!demo
 %! ## Show the 'cubehelix' colormap profile and as an image
 %! cmap = cubehelix (256);
 %! subplot (2, 1, 1);
 %! rgbplot (cmap, "composite");
 %! subplot (2, 1, 2);
 %! rgbplot (cmap);
+
diff --git a/scripts/image/im2double.m b/scripts/image/im2double.m
--- a/scripts/image/im2double.m
+++ b/scripts/image/im2double.m
@@ -48,47 +48,49 @@
 ##
 ## @seealso{double}
 ## @end deftypefn
 
 ## Author: Søren Hauberg <soren@hauberg.org>
 ## Author: Carnë Draug <carandraug@octave.org>
 
 function img = im2double (img, im_type)
-  ## "normal" (non-indexed) images
-  if (nargin () == 1)
+
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
+  endif
+
+  if (nargin == 1)
+    ## "normal" (non-indexed) images
     switch (class (img))
       case "uint8",   img = double (img) / 255;
       case "uint16",  img = double (img) / 65535;
       case "int16",   img = (double (img) + 32768) / 65535;
       case "single",  img = double (img);
       case "logical", img = double (img);
       case "double",  # do nothing
       otherwise, error ("im2double: IMG is of unsupported class \"%s\"", class (img));
     endswitch
-
-  ## indexed images
-  elseif (nargin () == 2)
+  else
+    ## indexed images
     if (! strcmpi (im_type, "indexed"))
       error ("im2double: second input argument must be the string \"indexed\"");
     elseif (any (isa (img, {"uint8", "uint16"})))
       img = double (img) + 1;
     elseif (isfloat (img) || isbool (img))
       img = double (img);
     else
       ## Technically, it could also be of logical class and we do not
       ## enforce positive integers for floating for Matlab compatibility.
       ## Still, no need to tell that to the user.
       error (["im2double: if IMG is indexed, then it must be positive " ...
               "integer floating points, or unsigned integer class"]);
     endif
+  endif
 
-  else
-    print_usage ();
-  endif
 endfunction
 
 
 %!assert (im2double ([1 2 3]), [1 2 3])
 %!assert (im2double (single ([1 2 3])), [1 2 3])
 %!assert (im2double (uint8 ([0 127 128 255])), [0 127/255 128/255 1])
 %!assert (im2double (uint16 ([0 127 128 65535])), [0 127/65535 128/65535 1])
 %!assert (im2double (int16 ([-32768 -32767 -32766 32767])),
diff --git a/scripts/image/imfinfo.m b/scripts/image/imfinfo.m
--- a/scripts/image/imfinfo.m
+++ b/scripts/image/imfinfo.m
@@ -144,26 +144,30 @@
 ## @end table
 ##
 ## @seealso{imread, imwrite, imshow, imformats}
 ## @end deftypefn
 
 ## Author: Soren Hauberg <hauberg@gmail.com>
 
 function info = imfinfo (filename, varargin)
+
   if (nargin < 1 || nargin > 2)
     print_usage ();
   elseif (! ischar (filename))
     error ("imfinfo: FILENAME must be a string");
   elseif (nargin > 1 && ! ischar (ext))
     error ("imfinfo: EXT must be a string");
   endif
+
   info = imageIO ("imfinfo", @__imfinfo__, "info", filename, varargin{:});
+
 endfunction
 
+
 ## This test is the same as the similar one in imread.  imfinfo must check
 ## if file exists before calling __imfinfo_.  This BIST test confirms this.
 %!testif HAVE_MAGICK
 %! warning ("off", "Octave:GraphicsMagic-Quantum-Depth", "local");
 %! fmt = fmt_ori = imformats ("jpg");
 %! fmt.info = @true;
 %! error_thrown = false;
 %! imformats ("update", "jpg", fmt);
diff --git a/scripts/image/imformats.m b/scripts/image/imformats.m
--- a/scripts/image/imformats.m
+++ b/scripts/image/imformats.m
@@ -66,16 +66,17 @@
 ## Octave, through use of the PKG_ADD and PKG_DEL commands.
 ##
 ## @seealso{imfinfo, imread, imwrite}
 ## @end deftypefn
 
 ## Author: Carnë Draug <carandraug@octave.org>
 
 function varargout = imformats (arg1, arg2, arg3)
+
   if (nargin > 3)
     print_usage ();
   endif
 
   mlock (); # prevent formats to be removed by "clear all"
   persistent formats = default_formats ();
 
   if (nargin == 0 && nargout == 0)
@@ -133,16 +134,17 @@ function varargout = imformats (arg1, ar
           endif
       endswitch
     else
       error ("imformats: first argument must be either a structure or string.");
     endif
   else
     varargout{1} = formats;
   endif
+
 endfunction
 
 function formats = default_formats ()
 
   ## The available formats are dependent on what the user has installed at
   ## a given time, and how GraphicsMagick was built.  Checking for
   ## GraphicsMagick features when building Octave is not enough since it
   ## delegates some of them to external programs which can be removed or
@@ -249,41 +251,45 @@ function formats = default_formats ()
 
   ## the default info, read, and write functions
   [formats.info ] = deal (@__imfinfo__);
   [formats.read ] = deal (@__imread__);
   [formats.write] = deal (@__imwrite__);
 
   ## fills rest of format information by checking with GraphicsMagick
   formats = __magick_formats__ (formats);
+
 endfunction
 
 function is_valid_format (format)
   ## the minimal list of fields required in the structure.  We don't
   ## require multipage because it doesn't exist in matlab
   min_fields  = {"ext", "read", "isa", "write", "info", "alpha", "description"};
   fields_mask = isfield (format, min_fields);
   if (! all (fields_mask))
     error ("imformats: structure has missing field `%s'.", min_fields(! fields_mask){1});
   endif
+
 endfunction
 
 function match = find_ext_idx (formats, ext)
-  ## XXX: what should we do if there's more than one hit?
-  ##      Should this function prevent the addition of
-  ##      duplicated extensions?
+  ## FIXME: what should we do if there's more than one hit?
+  ##        Should this function prevent the addition of
+  ##        duplicated extensions?
   match = cellfun (@(x) any (strcmpi (x, ext)), {formats.ext});
 endfunction
 
 function bool = isa_magick (coder, filename)
+
   bool = false;
   try
     info = __magick_ping__ (filename, 1);
     bool = strcmp (coder, info.Format);
   end_try_catch
+
 endfunction
 
 function pretty_print_formats (formats)
   ## define header names (none should be shorter than 3 characters)
   headers = {"Extension", "isa", "Info", "Read", "Write", "Alpha", "Description"};
   cols_length = cellfun (@numel, headers);
 
   ## Adjust the maximal length of the extensions column
@@ -310,16 +316,17 @@ function pretty_print_formats (formats)
   yes_no_cols(! empty) = "yes";
 
   descriptions = {formats.description};
   table = cat (2, extensions(:), yes_no_cols, descriptions(:));
   printf ([template "\n"], table'{:});
 
 endfunction
 
+
 ## This must work, even without support for image IO
 %!test
 %! formats = imformats ();
 %! assert (isstruct (formats));
 %!
 %! min_fields = {"ext", "read", "isa", "write", "info", "alpha", "description"};
 %! assert (all (ismember (min_fields, fieldnames (formats))));
 %!
diff --git a/scripts/image/imwrite.m b/scripts/image/imwrite.m
--- a/scripts/image/imwrite.m
+++ b/scripts/image/imwrite.m
@@ -92,19 +92,21 @@
 ## @qcode{"Index"} set to @qcode{"all"}.
 ##
 ## @end table
 ##
 ## @seealso{imread, imfinfo, imformats}
 ## @end deftypefn
 
 function imwrite (varargin)
+
   if (nargin < 2)
     print_usage ();
   endif
+
   [filename, ext] = imwrite_filename (varargin{2:end});
 
   fmt = imformats (ext);
   ## When there is no match, fmt will be a 1x1 structure with
   ## no fields, so we can't just use `isempty (fmt)'.
   if (numfields (fmt) == 0)
     if (isempty (ext))
       error ("imwrite: no extension found for %s to identify the image format",
@@ -114,16 +116,17 @@ function imwrite (varargin)
              ext);
     __imwrite__ (varargin{:});
   else
     fmt.write (varargin{:});
   endif
 
 endfunction
 
+
 ## Test input validation
 %!error imwrite ()                            # Wrong # of args
 %!error imwrite (1)                           # Wrong # of args
 %!error imwrite ({"cell"}, "filename.jpg")    # Wrong class for img
 %!error imwrite (1, [], "filename.jpg")       # Empty image map
 %!error imwrite (1, 2, 3)                     # No filename specified
 %!error imwrite (1, "filename")               # No fmt specified
 %!error imwrite (1, "filename", "junk")       # Invalid fmt specified
diff --git a/scripts/image/ntsc2rgb.m b/scripts/image/ntsc2rgb.m
--- a/scripts/image/ntsc2rgb.m
+++ b/scripts/image/ntsc2rgb.m
@@ -77,16 +77,17 @@ function rgb = ntsc2rgb (yiq)
   ## Matlab always returning class double, is a Matlab bug (see patch #8709)
 
   ## truncating / scaling of double rgb values for Matlab compatibility
   rgb = max (0, rgb);
   idx = any (rgb > 1, 2);
   rgb(idx,:) = rgb(idx,:) ./ max (rgb(idx,:), [], 2);
 
   rgb = colorspace_conversion_revert (rgb, sz, is_im, is_nd);
+
 endfunction
 
 
 %!shared trans
 %! trans = [ 1.0,      1.0,      1.0;
 %!          0.95617, -0.27269, -1.10374;
 %!          0.62143, -0.64681,  1.70062 ];
 
diff --git a/scripts/image/private/colorspace_conversion_revert.m b/scripts/image/private/colorspace_conversion_revert.m
--- a/scripts/image/private/colorspace_conversion_revert.m
+++ b/scripts/image/private/colorspace_conversion_revert.m
@@ -18,17 +18,20 @@
 
 ## Private function the functions that convert between color spaces, i.e.,
 ## rgb2ntsc, rgb2hsv, hsv2rgb, and ntsc2rgb.  This reverts a colormap type
 ## into the same shape and class as it was in the input.  The flags are meant
 ## to come from complementary private function
 ## colorspace_conversion_input_check()
 
 function rv = colorspace_conversion_revert (rv, sz, is_im, is_nd)
+
   if (is_im)
     if (is_nd)
       rv = reshape (rv, [sz(1:2) sz(4) sz(3)]);
       rv = permute (rv, [1 2 4 3]);
     else
       rv = reshape (rv, sz);
     endif
   endif
+
 endfunction
+
diff --git a/scripts/linear-algebra/logm.m b/scripts/linear-algebra/logm.m
--- a/scripts/linear-algebra/logm.m
+++ b/scripts/linear-algebra/logm.m
@@ -128,43 +128,47 @@ endfunction
 ######      (SIAM, 2008.).
 #######################################################################
 
 ##LOGM_PADE_PF   Evaluate Pade approximant to matrix log by partial fractions.
 ##   Y = LOGM_PADE_PF(A,M) evaluates the [M/M] Pade approximation to
 ##   LOG(EYE(SIZE(A))+A) using a partial fraction expansion.
 
 function s = logm_pade_pf (A, m)
+
   [nodes, wts] = gauss_legendre (m);
   ## Convert from [-1,1] to [0,1].
   nodes = (nodes+1)/2;
   wts /= 2;
 
   n = length (A);
   s = zeros (n);
   for j = 1:m
     s += wts(j)*(A/(eye (n) + nodes(j)*A));
   endfor
+
 endfunction
 
 ######################################################################
 ## GAUSS_LEGENDRE  Nodes and weights for Gauss-Legendre quadrature.
 ##   [X,W] = GAUSS_LEGENDRE(N) computes the nodes X and weights W
 ##   for N-point Gauss-Legendre quadrature.
 
 ## Reference:
 ## G. H. Golub and J. H. Welsch, Calculation of Gauss quadrature
 ## rules, Math. Comp., 23(106):221-230, 1969.
 
 function [x, w] = gauss_legendre (n)
+
   i = 1:n-1;
   v = i./sqrt ((2*i).^2-1);
   [V, D] = eig (diag (v, -1) + diag (v, 1));
   x = diag (D);
   w = 2*(V(1,:)'.^2);
+
 endfunction
 
 
 %!assert (norm (logm ([1 -1;0 1]) - [0 -1; 0 0]) < 1e-5)
 %!test
 %! warning ("off", "Octave:logm:non-principal", "local");
 %! assert (norm (expm (logm ([-1 2 ; 4 -1])) - [-1 2 ; 4 -1]) < 1e-5);
 %!assert (logm ([1 -1 -1;0 1 -1; 0 0 1]), [0 -1 -1.5; 0 0 -1; 0 0 0], 1e-5)
diff --git a/scripts/linear-algebra/normest.m b/scripts/linear-algebra/normest.m
--- a/scripts/linear-algebra/normest.m
+++ b/scripts/linear-algebra/normest.m
@@ -71,16 +71,17 @@ function [n, c] = normest (A, tol = 1e-6
       x /= normx;
     endif
     y = A' * x;
     n = norm (y);
     c += 1;
   until (abs (n - n0) <= tol * n)
 
   rand ("state", v);    # restore state of random number generator
+
 endfunction
 
 
 %!test
 %! A = toeplitz ([-2,1,0,0]);
 %! assert (normest (A), norm (A), 1e-6);
 
 %!test
diff --git a/scripts/miscellaneous/fact.m b/scripts/miscellaneous/fact.m
--- a/scripts/miscellaneous/fact.m
+++ b/scripts/miscellaneous/fact.m
@@ -263,30 +263,32 @@ function truth = fact ()
   else
     w = wordwrap (w);
     printf ("%s", w);
   endif
 
 endfunction
 
 function out = wordwrap (w)
+
   ncol = terminal_size ()(2);
   wc = ostrsplit (w, " ");
   out = "\n";
   i = 1;
   numwords = numel (wc);
   while (i <= numwords);
     line = wc{i};
     while (i < numwords
            && length (newline = [line " " wc{i+1}]) < ncol)
       line = newline;
       i += 1;
     endwhile
     out = [out, line, "\n"];
     i += 1;
   endwhile
   out = [out, "\n"];
+
 endfunction
 
 
 ## Mark file as being tested.  No real test needed for a documentation .m file
 %!assert (1)
 
diff --git a/scripts/miscellaneous/run.m b/scripts/miscellaneous/run.m
--- a/scripts/miscellaneous/run.m
+++ b/scripts/miscellaneous/run.m
@@ -79,16 +79,17 @@ function run (script)
       script = which (script);
     else
       ## Search PATH with null extension ('.' will be stripped and ext = "")
       script = which ([script "."]);
     endif
     evalin ("caller", sprintf ("source ('%s');", script),
             "rethrow (lasterror ())");
   endif
+
 endfunction
 
 
 ## Test input validation
 %!error run ()
 %!error run ("a", "b")
 %!error <SCRIPT must exist> run ("__A_very_#unlikely#_file_name__")
 
diff --git a/scripts/miscellaneous/symvar.m b/scripts/miscellaneous/symvar.m
--- a/scripts/miscellaneous/symvar.m
+++ b/scripts/miscellaneous/symvar.m
@@ -35,16 +35,17 @@
 ##      [1,1] = x
 ##      [2,1] = y
 ##    @}
 ## @end group
 ## @end example
 ## @end deftypefn
 
 function vars = symvar (str)
+
   vars = argnames (inline (str));
   ## Correct for auto-generated 'x' variable when no symvar was found.
   if (numel (vars) == 1 && strcmp (vars{1}, "x") && ! any (str == "x"))
     vars = {};
   endif
 
 endfunction
 
diff --git a/scripts/miscellaneous/unpack.m b/scripts/miscellaneous/unpack.m
--- a/scripts/miscellaneous/unpack.m
+++ b/scripts/miscellaneous/unpack.m
@@ -285,24 +285,24 @@ function files = __parse_zip__ (output)
 endfunction
 
 function output = __parse_tar__ (output)
   ## This is a no-op, but it makes things simpler for other cases.
 endfunction
 
 function files = __parse_gzip__ (output)
   ## Parse the output from gzip and gunzip returning the files
-  ## commpressed (or decompressed).
+  ## compressed (or decompressed).
 
   files = regexprep (output, '^.+ -- replaced with (.*)$', '$1');
 endfunction
 
 function files = __parse_bzip2__ (output)
   ## Parse the output from bzip2 and bunzip2 returning the files
-  ## commpressed (or decompressed).
+  ## compressed (or decompressed).
 
   ## Strip leading blanks and .bz2 extension from filename
   files = regexprep (output, '^\s+(.*)\.bz2: .*', '$1');
 endfunction
 
 
 %!test
 %! ## Create temporary directory and file for packing and unpacking
diff --git a/scripts/optimization/fminunc.m b/scripts/optimization/fminunc.m
--- a/scripts/optimization/fminunc.m
+++ b/scripts/optimization/fminunc.m
@@ -382,30 +382,32 @@ function [x, fval, info, output, grad, h
   if (nargout > 5)
     hess = hesr'*hesr;
   endif
 
 endfunction
 
 ## A helper function that evaluates a function and checks for bad results.
 function [fx, gx] = guarded_eval (fun, x)
+
   if (nargout > 1)
     [fx, gx] = fun (x);
   else
     fx = fun (x);
     gx = [];
   endif
 
   if (! (isreal (fx) && isreal (gx)))
     error ("fminunc:notreal", "fminunc: non-real value encountered");
   elseif (any (isnan (fx(:))))
     error ("fminunc:isnan", "fminunc: NaN value encountered");
   elseif (any (isinf (fx(:))))
     error ("fminunc:isinf", "fminunc: Inf value encountered");
   endif
+
 endfunction
 
 
 %!function f = __rosenb__ (x)
 %!  n = length (x);
 %!  f = sumsq (1 - x(1:n-1)) + 100 * sumsq (x(2:n) - x(1:n-1).^2);
 %!endfunction
 %!
@@ -432,16 +434,17 @@ endfunction
 ## Solve the double dogleg trust-region minimization problem:
 ## Minimize 1/2*norm(r*x)^2  subject to the constraint norm(d.*x) <= delta,
 ## x being a convex combination of the gauss-newton and scaled gradient.
 
 ## FIXME: error checks
 ## FIXME: handle singularity, or leave it up to mldivide?
 
 function x = __doglegm__ (r, g, d, delta)
+
   ## Get Gauss-Newton direction.
   b = r' \ g;
   x = r \ b;
   xn = norm (d .* x);
   if (xn > delta)
     ## GN is too big, get scaled gradient.
     s = g ./ d;
     sn = norm (s);
@@ -463,10 +466,11 @@ function x = __doglegm__ (r, g, d, delta
       endif
     else
       alpha = delta / xn;
       snm = 0;
     endif
     ## Form the appropriate convex combination.
     x = alpha * x + ((1-alpha) * min (snm, delta)) * s;
   endif
+
 endfunction
 
diff --git a/scripts/optimization/fsolve.m b/scripts/optimization/fsolve.m
--- a/scripts/optimization/fsolve.m
+++ b/scripts/optimization/fsolve.m
@@ -440,39 +440,43 @@ function [x, fvec, info, output, fjac] =
   output.successful = nsuciter;
   output.funcCount = nfev;
 
 endfunction
 
 ## An assistant function that evaluates a function handle and checks for
 ## bad results.
 function [fx, jx] = guarded_eval (fun, x, complexeqn)
+
   if (nargout > 1)
     [fx, jx] = fun (x);
   else
     fx = fun (x);
     jx = [];
   endif
 
   if (! complexeqn && ! (isreal (fx) && isreal (jx)))
     error ("fsolve:notreal", "fsolve: non-real value encountered");
   elseif (complexeqn && ! (isnumeric (fx) && isnumeric (jx)))
     error ("fsolve:notnum", "fsolve: non-numeric value encountered");
   elseif (any (isnan (fx(:))))
     error ("fsolve:isnan", "fsolve: NaN value encountered");
   elseif (any (isinf (fx(:))))
     error ("fsolve:isinf", "fsolve: Inf value encountered");
   endif
+
 endfunction
 
 function [fx, jx] = make_fcn_jac (x, fcn, fjac)
+
   fx = fcn (x);
   if (nargout == 2)
     jx = fjac (x);
   endif
+
 endfunction
 
 
 %!function retval = __f (p)
 %!  x = p(1);
 %!  y = p(2);
 %!  z = p(3);
 %!  retval = zeros (3, 1);
@@ -582,16 +586,17 @@ endfunction
 ## Solve the double dogleg trust-region least-squares problem:
 ## Minimize norm(r*x-b) subject to the constraint norm(d.*x) <= delta,
 ## x being a convex combination of the gauss-newton and scaled gradient.
 
 ## FIXME: error checks
 ## FIXME: handle singularity, or leave it up to mldivide?
 
 function x = __dogleg__ (r, b, d, delta)
+
   ## Get Gauss-Newton direction.
   x = r \ b;
   xn = norm (d .* x);
   if (xn > delta)
     ## GN is too big, get scaled gradient.
     s = (r' * b) ./ d;
     sn = norm (s);
     if (sn > 0)
@@ -612,10 +617,11 @@ function x = __dogleg__ (r, b, d, delta)
       endif
     else
       alpha = delta / xn;
       snm = 0;
     endif
     ## Form the appropriate convex combination.
     x = alpha * x + ((1-alpha) * min (snm, delta)) * s;
   endif
+
 endfunction
 
diff --git a/scripts/optimization/optimset.m b/scripts/optimization/optimset.m
--- a/scripts/optimization/optimset.m
+++ b/scripts/optimization/optimset.m
@@ -110,17 +110,17 @@
 ##
 ## @item Updating
 ## @end table
 ## @seealso{optimget}
 ## @end deftypefn
 
 function retval = optimset (varargin)
 
-  nargs = nargin ();
+  nargs = nargin;
 
   opts = __all_opts__ ();
 
   if (nargs == 0)
     if (nargout == 0)
       ## Display possibilities.
       puts ("\nAll possible optimization options:\n\n");
       printf ("  %s\n", opts{:});
diff --git a/scripts/optimization/private/__fdjac__.m b/scripts/optimization/private/__fdjac__.m
--- a/scripts/optimization/private/__fdjac__.m
+++ b/scripts/optimization/private/__fdjac__.m
@@ -17,16 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {} __fdjac__ (@var{fcn}, @var{x}, @var{fvec}, @var{err})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function fjac = __fdjac__ (fcn, x, fvec, typicalx, cdif, err = 0)
+
   if (cdif)
     err = (max (eps, err)) ^ (1/3);
     h = typicalx*err;
     fjac = zeros (length (fvec), numel (x));
     for i = 1:numel (x)
       x1 = x2 = x;
       x1(i) += h(i);
       x2(i) -= h(i);
@@ -37,12 +38,11 @@ function fjac = __fdjac__ (fcn, x, fvec,
     h = typicalx*err;
     fjac = zeros (length (fvec), numel (x));
     for i = 1:numel (x)
       x1 = x;
       x1(i) += h(i);
       fjac(:,i) = (fcn (x1)(:) - fvec) / (x1(i) - x(i));
     endfor
   endif
+
 endfunction
 
-
-
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -549,18 +549,17 @@ function [merit, obj, globals] = phi_L1 
   if (! isempty (t))
     merit += t;
   endif
 
 endfunction
 
 
 function [x_new, alpha, obj, globals] = ...
-      linesearch_L1 (x, p, obj_fun, obj_grd, ce_fun, ci_fun, lambda, ...
-                     obj, globals)
+   linesearch_L1 (x, p, obj_fun, obj_grd, ce_fun, ci_fun, lambda, obj, globals)
 
   ## Choose parameters
   ##
   ## eta in the range (0, 0.5)
   ## tau in the range (0, 1)
 
   eta = 0.25;
   tau = 0.5;
diff --git a/scripts/pkg/private/build.m b/scripts/pkg/private/build.m
--- a/scripts/pkg/private/build.m
+++ b/scripts/pkg/private/build.m
@@ -29,16 +29,17 @@
 ## @item build anything necessary (configure and make);
 ##
 ## @item repackage specifying the build arch in the tarball filename.
 ## @end enumerate
 ##
 ## @end deftypefn
 
 function build (builddir, tarballs, verbose)
+
   if (nargin != 3)
     print_usage ();
   endif
 
   if (! exist (builddir, "dir"))
     warning ("creating build directory %s", builddir);
     [status, msg] = mkdir (builddir);
     if (status != 1)
@@ -78,9 +79,10 @@ function build (builddir, tarballs, verb
         unlink (tfile);
       catch
         warning ("failed to create and compress %s", tfile);
       end_try_catch
     unwind_protect_cleanup
       chdir (init_wd);
     end_unwind_protect
   endfor
+
 endfunction
diff --git a/scripts/pkg/private/configure_make.m b/scripts/pkg/private/configure_make.m
--- a/scripts/pkg/private/configure_make.m
+++ b/scripts/pkg/private/configure_make.m
@@ -18,16 +18,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {} configure_make (@var{desc}, @var{packdir}, @var{verbose})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function configure_make (desc, packdir, verbose)
+
   ## Perform ./configure, make, make install in "src".
   if (exist (fullfile (packdir, "src"), "dir"))
     src = fullfile (packdir, "src");
     octave_bindir = __octave_config_info__ ("bindir");
     ver = version ();
     ext = __octave_config_info__ ("EXEEXT");
     mkoctfile_program = fullfile (octave_bindir, ...
                                   sprintf ("mkoctfile-%s%s", ver, ext));
@@ -89,18 +90,18 @@ function configure_make (desc, packdir, 
       [status, output] = shell (sprintf ("%s make --jobs %i --directory '%s'",
                                          scenv, jobs, src), verbose);
       if (status != 0)
         rmdir (desc.dir, "s");
         disp (output);
         error ("pkg: error running `make' for the %s package.", desc.name);
       endif
     endif
+  endif
 
-  endif
 endfunction
 
 ## Executes a shell command.  In the end it calls system() but in case of
 ## windows will first check if sh.exe works.
 ##
 ## If VERBOSE is true, it will prints the output to STDOUT in real time and
 ## the second output argument will be an empty string.  Otherwise, it will
 ## contain the output of the execeuted command.
@@ -128,9 +129,11 @@ function [status, output] = shell (cmd, 
   ## are verbose we will return an empty string but it's all fine since
   ## the error message has already been displayed.
   output = "";
   if (verbose)
     [status] = system (cmd);
   else
     [status, output] = system (cmd);
   endif
+
 endfunction
+
diff --git a/scripts/pkg/private/default_prefix.m b/scripts/pkg/private/default_prefix.m
--- a/scripts/pkg/private/default_prefix.m
+++ b/scripts/pkg/private/default_prefix.m
@@ -17,23 +17,25 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {[@var{prefix}, @var{archprefix} =} default_prefix (@var{global_install})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function [prefix, archprefix] = default_prefix (global_install, desc)
+
   if (global_install)
     prefix = fullfile (OCTAVE_HOME (), "share", "octave", "packages");
     if (nargin == 2)
       archprefix = fullfile (__octave_config_info__ ("libdir"), "octave",
                              "packages", [desc.name "-" desc.version]);
     else
       archprefix = fullfile (__octave_config_info__ ("libdir"), "octave",
                              "packages");
     endif
   else
     prefix = tilde_expand (fullfile ("~", "octave"));
     archprefix = prefix;
   endif
+
 endfunction
 
diff --git a/scripts/pkg/private/describe.m b/scripts/pkg/private/describe.m
--- a/scripts/pkg/private/describe.m
+++ b/scripts/pkg/private/describe.m
@@ -77,16 +77,17 @@ function [pkg_desc_list, flag] = describ
     for i = 1:num_pkgnames
       print_package_description (pkg_desc_list{i}.name,
                                  pkg_desc_list{i}.version,
                                  pkg_desc_list{i}.provides,
                                  pkg_desc_list{i}.description,
                                  flag{i}, verbose);
     endfor
   endif
+
 endfunction
 
 
 ## Read an INDEX file.
 function pkg_idx_struct = parse_pkg_idx (packdir)
 
   index_file = fullfile (packdir, "packinfo", "INDEX");
 
@@ -130,29 +131,32 @@ function pkg_idx_struct = parse_pkg_idx 
       while (any (! isspace (line)))
         [fun_name, line] = strtok (line);
         pkg_idx_struct{cat_num}.functions{end+1} = deblank (fun_name);
       endwhile
     endif
     line = fgetl (fid);
   endwhile
   fclose (fid);
+
 endfunction
 
 
 function print_package_description (pkg_name, pkg_ver, pkg_idx_struct,
                                     pkg_desc, status, verbose)
+
   printf ("---\nPackage name:\n\t%s\n", pkg_name);
   printf ("Version:\n\t%s\n", pkg_ver);
   printf ("Short description:\n\t%s\n", pkg_desc);
   printf ("Status:\n\t%s\n", status);
   if (verbose)
     printf ("---\nProvides:\n");
     for i = 1:length (pkg_idx_struct)
       if (! isempty (pkg_idx_struct{i}.functions))
         printf ("%s\n", pkg_idx_struct{i}.category);
         for j = 1:length (pkg_idx_struct{i}.functions)
           printf ("\t%s\n", pkg_idx_struct{i}.functions{j});
         endfor
       endif
     endfor
   endif
+
 endfunction
diff --git a/scripts/pkg/private/dirempty.m b/scripts/pkg/private/dirempty.m
--- a/scripts/pkg/private/dirempty.m
+++ b/scripts/pkg/private/dirempty.m
@@ -18,16 +18,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {@var{emp} =} dirempty (@var{nm}, @var{ign})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function emp = dirempty (nm, ign)
+
   if (exist (nm, "dir"))
     if (nargin < 2)
       ign = {".", ".."};
     else
       ign = [{".", ".."}, ign];
     endif
     l = dir (nm);
     for i = 1:length (l)
@@ -42,10 +43,11 @@ function emp = dirempty (nm, ign)
         emp = false;
         return;
       endif
     endfor
     emp = true;
   else
     emp = true;
   endif
+
 endfunction
 
diff --git a/scripts/pkg/private/get_description.m b/scripts/pkg/private/get_description.m
--- a/scripts/pkg/private/get_description.m
+++ b/scripts/pkg/private/get_description.m
@@ -19,16 +19,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {} {@var{desc} =} get_description (@var{filename})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Parse the DESCRIPTION file.
 function desc = get_description (filename)
+
   [fid, msg] = fopen (filename, "r");
   if (fid == -1)
     error ("the DESCRIPTION file %s could not be read: %s", filename, msg);
   endif
 
   desc = struct ();
 
   line = fgetl (fid);
@@ -75,23 +76,25 @@ function desc = get_description (filenam
   endif
 
   if (isfield (desc, "depends"))
     desc.depends = fix_depends (desc.depends);
   else
     desc.depends = "";
   endif
   desc.name = tolower (desc.name);
+
 endfunction
 
 
 ## Make sure the depends field is of the right format.
 ## This function returns a cell of structures with the following fields:
 ##   package, version, operator
 function deps_cell = fix_depends (depends)
+
   deps = strtrim (ostrsplit (tolower (depends), ","));
   deps_cell = cell (1, length (deps));
   dep_pat = ...
   '\s*(?<name>[-\w]+)\s*(\(\s*(?<op>[<>=]+)\s*(?<ver>\d+\.\d+(\.\d+)*)\s*\))*\s*';
 
   ## For each dependency.
   for i = 1:length (deps)
     dep = deps{i};
@@ -121,22 +124,23 @@ function deps_cell = fix_depends (depend
       deps_cell{i} = struct ("package", package,
                              "operator", operator,
                              "version", nm.ver);
     else
       error ("incorrect syntax for dependency '%s' in the DESCRIPTION file\n",
              dep);
     endif
   endfor
+
 endfunction
 
 function [valid] = is_valid_pkg_version_string (str)
   ## We are limiting ourselves to this set of characters because the
-  ## version will appear on the filepath.  The portable character, according
-  ## to http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_278
+  ## version will appear on the filepath.  The portable character, according to
+  ## http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_278
   ## is [A-Za-z0-9\.\_\-].  However, this is very limited.  We specially
   ## want to support a "+" so we can support "pkgname-2.1.0+" during
   ## development.  So we use Debian's character set for version strings
   ## https://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Version
   ## with the exception of ":" (colon) because that's the PATH separator.
   ##
   ## Debian does not include "_" because it is used to separate the name,
   ## version, and arch in their deb files.  While the actual filenames are
diff --git a/scripts/pkg/private/get_forge_download.m b/scripts/pkg/private/get_forge_download.m
--- a/scripts/pkg/private/get_forge_download.m
+++ b/scripts/pkg/private/get_forge_download.m
@@ -19,11 +19,11 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {} {[@var{url}, @var{local_file}] =} list_forge_packages ()
 ## Undocumented internal function.
 ## @end deftypefn
 
 function [url, local_file] = get_forge_download (name)
   [ver, url] = get_forge_pkg (name);
-  local_file = [name, "-", ver, ".tar.gz"];
+  local_file = [name "-" ver ".tar.gz"];
 endfunction
 
diff --git a/scripts/pkg/private/get_unsatisfied_deps.m b/scripts/pkg/private/get_unsatisfied_deps.m
--- a/scripts/pkg/private/get_unsatisfied_deps.m
+++ b/scripts/pkg/private/get_unsatisfied_deps.m
@@ -18,16 +18,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {@var{bad_deps} =} get_unsatisfied_deps (@var{desc}, @var{installed_pkgs_lst})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function bad_deps = get_unsatisfied_deps (desc, installed_pkgs_lst)
+
   bad_deps = {};
 
   ## For each dependency.
   for i = 1:length (desc.depends)
     dep = desc.depends{i};
 
     ## Is the current dependency Octave?
     if (strcmp (dep.package, "octave"))
@@ -46,10 +47,11 @@ function bad_deps = get_unsatisfied_deps
           break;
         endif
       endfor
       if (! ok)
         bad_deps{end+1} = dep;
       endif
     endif
   endfor
+
 endfunction
 
diff --git a/scripts/pkg/private/getarch.m b/scripts/pkg/private/getarch.m
--- a/scripts/pkg/private/getarch.m
+++ b/scripts/pkg/private/getarch.m
@@ -20,11 +20,12 @@
 ## -*- texinfo -*-
 ## @deftypefn {} {@var{arch} =} getarch ()
 ## Undocumented internal function.
 ## @end deftypefn
 
 function arch = getarch ()
   persistent _arch = [__octave_config_info__("canonical_host_type"), "-", ...
                       __octave_config_info__("api_version")];
+
   arch = _arch;
 endfunction
 
diff --git a/scripts/pkg/private/install.m b/scripts/pkg/private/install.m
--- a/scripts/pkg/private/install.m
+++ b/scripts/pkg/private/install.m
@@ -294,20 +294,22 @@ function install (files, handle_deps, pr
   ## If there is a NEWS file, mention it.
   ## Check if desc exists too because it's possible to get to this point
   ## without creating it such as giving an invalid filename for the package
   if (exist ("desc", "var")
       && exist (fullfile (desc.dir, "packinfo", "NEWS"), "file"))
     printf ("For information about changes from previous versions of the %s package, run 'news %s'.\n",
             desc.name, desc.name);
   endif
+
 endfunction
 
 
 function pkg = extract_pkg (nm, pat)
+
   fid = fopen (nm, "rt");
   pkg = "";
   if (fid >= 0)
     while (! feof (fid))
       ln = fgetl (fid);
       if (ln > 0)
         t = regexp (ln, pat, "tokens");
         if (! isempty (t))
@@ -315,31 +317,35 @@ function pkg = extract_pkg (nm, pat)
         endif
       endif
     endwhile
     if (! isempty (pkg))
       pkg = [pkg "\n"];
     endif
     fclose (fid);
   endif
+
 endfunction
 
 
 ## Make sure the package contains the essential files.
 function verify_directory (dir)
+
   needed_files = {"COPYING", "DESCRIPTION"};
   for f = needed_files
     if (! exist (fullfile (dir, f{1}), "file"))
       error ("package is missing file: %s", f{1});
     endif
   endfor
+
 endfunction
 
 
 function prepare_installation (desc, packdir)
+
   ## Is there a pre_install to call?
   if (exist (fullfile (packdir, "pre_install.m"), "file"))
     wd = pwd ();
     try
       cd (packdir);
       pre_install (desc);
       cd (wd);
     catch
@@ -353,20 +359,22 @@ function prepare_installation (desc, pac
   if (! exist (inst_dir, "dir"))
     [status, msg] = mkdir (inst_dir);
     if (status != 1)
       rmdir (desc.dir, "s");
       error ("the 'inst' directory did not exist and could not be created: %s",
              msg);
     endif
   endif
+
 endfunction
 
 
 function copy_built_files (desc, packdir, verbose)
+
   src = fullfile (packdir, "src");
   if (! exist (src, "dir"))
     return
   endif
 
   ## Copy files to "inst" and "inst/arch" (this is instead of 'make install').
   files = fullfile (src, "FILES");
   instdir = fullfile (packdir, "inst");
@@ -440,16 +448,17 @@ function copy_built_files (desc, packdir
         endif
         [status, output] = copyfile (archdependent, archdir);
         if (status != 1)
           rmdir (desc.dir, "s");
           error ("Couldn't copy files from 'src' to 'inst': %s", output);
         endif
       endif
   endif
+
 endfunction
 
 
 function dep = is_architecture_dependent (nm)
   persistent archdepsuffix = {".oct",".mex",".a",".lib",".so",".so.*",".dll","dylib"};
 
   dep = false;
   for i = 1 : length (archdepsuffix)
@@ -464,20 +473,22 @@ function dep = is_architecture_dependent
     if (pos)
       if (! isglob && (length (nm) - pos(end) != length (ext) - 1))
         continue;
       endif
       dep = true;
       break;
     endif
   endfor
+
 endfunction
 
 
 function copy_files (desc, packdir, global_install)
+
   ## Create the installation directory.
   if (! exist (desc.dir, "dir"))
     [status, output] = mkdir (desc.dir);
     if (status != 1)
       error ("couldn't create installation directory %s : %s",
       desc.dir, output);
     endif
   endif
@@ -584,39 +595,43 @@ function copy_files (desc, packdir, glob
   endif
 
   ## Is there a bin/ directory that needs to be installed?
   ## FIXME: Need to treat architecture dependent files in bin/
   bindir = fullfile (packdir, "bin");
   if (exist (bindir, "dir") && ! dirempty (bindir))
     [status, output] = copyfile (bindir, desc.dir);
   endif
+
 endfunction
 
 
 function packinfo_copy_file (filename, requirement, packdir, packinfo, desc, octfiledir)
+
   filepath = fullfile (packdir, filename);
   if (! exist (filepath, "file") && strcmpi (requirement, "optional"))
     ## do nothing, it's still OK
   else
     [status, output] = copyfile (filepath, packinfo);
     if (status != 1)
       rmdir (desc.dir, "s");
       rmdir (octfiledir, "s");
       error ("Couldn't copy %s file: %s", filename, output);
     endif
   endif
+
 endfunction
 
 
 ## Create an INDEX file for a package that doesn't provide one.
 ##   'desc'  describes the package.
 ##   'dir'   is the 'inst' directory in temporary directory.
 ##   'index_file' is the name (including path) of resulting INDEX file.
 function write_index (desc, dir, index_file, global_install)
+
   ## Get names of functions in dir
   [files, err, msg] = readdir (dir);
   if (err)
     error ("couldn't read directory %s: %s", dir, msg);
   endif
 
   ## Get classes in dir
   class_idx = find (strncmp (files, '@', 1));
@@ -667,20 +682,22 @@ function write_index (desc, dir, index_f
   fid = fopen (index_file, "w");
   if (fid == -1)
     error ("couldn't open %s for writing", index_file);
   endif
   fprintf (fid, "%s >> %s\n", desc.name, desc.title);
   fprintf (fid, "%s\n", categories{1});
   fprintf (fid, "  %s\n", functions{:});
   fclose (fid);
+
 endfunction
 
 
 function create_pkgadddel (desc, packdir, nm, global_install)
+
   instpkg = fullfile (desc.dir, nm);
   instfid = fopen (instpkg, "at"); # append to support PKG_ADD at inst/
   ## If it is exists, most of the PKG_* file should go into the
   ## architecture dependent directory so that the autoload/mfilename
   ## commands work as expected.  The only part that doesn't is the
   ## part in the main directory.
   archdir = fullfile (getarchprefix (desc, global_install),
                       [desc.name "-" desc.version], getarch ());
@@ -733,44 +750,52 @@ function create_pkgadddel (desc, packdir
     if (instfid != archfid)
       fclose (archfid);
       t = dir (archpkg);
       if (t.bytes <= 0)
         unlink (archpkg);
       endif
     endif
   endif
+
 endfunction
 
 
 function archprefix = getarchprefix (desc, global_install)
+
   if (global_install)
     [~, archprefix] = default_prefix (global_install, desc);
   else
     archprefix = desc.dir;
   endif
+
 endfunction
 
 
 function finish_installation (desc, packdir, global_install)
+
   ## Is there a post-install to call?
   if (exist (fullfile (packdir, "post_install.m"), "file"))
     wd = pwd ();
     try
       cd (packdir);
       post_install (desc);
       cd (wd);
     catch
       cd (wd);
       rmdir (desc.dir, "s");
       rmdir (getarchdir (desc), "s");
       rethrow (lasterror ());
     end_try_catch
   endif
+
 endfunction
 
 
 function generate_lookfor_cache (desc)
+
   dirs = strtrim (ostrsplit (genpath (desc.dir), pathsep ()));
   for i = 1 : length (dirs)
     doc_cache_create (fullfile (dirs{i}, "doc-cache"), dirs{i});
   endfor
+
 endfunction
+
diff --git a/scripts/pkg/private/installed_packages.m b/scripts/pkg/private/installed_packages.m
--- a/scripts/pkg/private/installed_packages.m
+++ b/scripts/pkg/private/installed_packages.m
@@ -143,9 +143,10 @@ function [out1, out2] = installed_packag
       if (installed_pkgs_lst{i}.loaded)
         cur_loaded = "*";
       else
         cur_loaded = " ";
       endif
       printf (format, cur_name, cur_loaded, cur_version, cur_dir);
     endfor
   endif
+
 endfunction
diff --git a/scripts/pkg/private/list_forge_packages.m b/scripts/pkg/private/list_forge_packages.m
--- a/scripts/pkg/private/list_forge_packages.m
+++ b/scripts/pkg/private/list_forge_packages.m
@@ -18,28 +18,31 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {@var{list} =} list_forge_packages ()
 ## Undocumented internal function.
 ## @end deftypefn
 
 function list = list_forge_packages ()
+
   [list, succ] = urlread ("http://packages.octave.org/list_packages.php");
-  if (succ)
-    list = ostrsplit (list, " \n\t", true);
-  else
+  if (! succ)
     error ("pkg: could not read URL, please verify internet connection");
   endif
+
+  list = ostrsplit (list, " \n\t", true);
+
   if (nargout == 0)
     page_screen_output (false, "local");
     puts ("OctaveForge provides these packages:\n");
     for i = 1:length (list)
       try
         ver = get_forge_pkg (list{i});
       catch
         ver = "unknown";
       end_try_catch
       printf ("  %s %s\n", list{i}, ver);
     endfor
   endif
+
 endfunction
 
diff --git a/scripts/pkg/private/load_packages.m b/scripts/pkg/private/load_packages.m
--- a/scripts/pkg/private/load_packages.m
+++ b/scripts/pkg/private/load_packages.m
@@ -18,16 +18,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {} load_packages (@var{files}, @var{handle_deps}, @var{local_list}, @var{global_list})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function load_packages (files, handle_deps, local_list, global_list)
+
   installed_pkgs_lst = installed_packages (local_list, global_list);
   num_packages = length (installed_pkgs_lst);
 
   ## Read package names and installdirs into a more convenient format.
   pnames = pdirs = cell (1, num_packages);
   for i = 1:num_packages
     pnames{i} = installed_pkgs_lst{i}.name;
     pdirs{i} = installed_pkgs_lst{i}.dir;
@@ -44,10 +45,11 @@ function load_packages (files, handle_de
           error ("package %s is not installed", files{i});
       endif
       idx(end + 1) = idx2;
     endfor
   endif
 
   ## Load the packages, but take care of the ordering of dependencies.
   load_packages_and_dependencies (idx, handle_deps, installed_pkgs_lst, true);
+
 endfunction
 
diff --git a/scripts/pkg/private/load_packages_and_dependencies.m b/scripts/pkg/private/load_packages_and_dependencies.m
--- a/scripts/pkg/private/load_packages_and_dependencies.m
+++ b/scripts/pkg/private/load_packages_and_dependencies.m
@@ -19,16 +19,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {} {} load_packages_and_dependencies (@var{idx}, @var{handle_deps}, @var{installed_pkgs_lst}, @var{global_install})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function load_packages_and_dependencies (idx, handle_deps, installed_pkgs_lst,
                                          global_install)
+
   idx = load_package_dirs (idx, [], handle_deps, installed_pkgs_lst);
   dirs = {};
   execpath = EXEC_PATH ();
   for i = idx;
     ndir = installed_pkgs_lst{i}.dir;
     dirs{end+1} = ndir;
     if (exist (fullfile (dirs{end}, "bin"), "dir"))
       execpath = [execpath pathsep() fullfile(dirs{end}, "bin")];
@@ -46,20 +47,22 @@ function load_packages_and_dependencies 
   if (length (dirs) > 0)
     addpath (dirs{:});
   endif
 
   ## Add the binaries to exec_path.
   if (! strcmp (EXEC_PATH, execpath))
     EXEC_PATH (execpath);
   endif
+
 endfunction
 
 
 function idx = load_package_dirs (lidx, idx, handle_deps, installed_pkgs_lst)
+
   for i = lidx
     if (isfield (installed_pkgs_lst{i}, "loaded")
         && installed_pkgs_lst{i}.loaded)
       continue;
     else
       ## Insert this package at the front before recursing over dependencies.
       if (! any (idx == i))
         idx = [i, idx];
@@ -81,9 +84,11 @@ function idx = load_package_dirs (lidx, 
             endfor
           endfor
           idx = load_package_dirs (tmplidx, idx, handle_deps,
                                  installed_pkgs_lst);
         endif
       endif
     endif
   endfor
+
 endfunction
+
diff --git a/scripts/pkg/private/rebuild.m b/scripts/pkg/private/rebuild.m
--- a/scripts/pkg/private/rebuild.m
+++ b/scripts/pkg/private/rebuild.m
@@ -18,16 +18,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {@var{descriptions} =} rebuild (@var{prefix}, @var{archprefix}, @var{list}, @var{files}, @var{verbose})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function descriptions = rebuild (prefix, archprefix, list, files, verbose)
+
   if (isempty (files))
     [dirlist, err, msg] = readdir (prefix);
     if (err)
       error ("couldn't read directory %s: %s", prefix, msg);
     endif
     ## the two first entries of dirlist are "." and ".."
     dirlist([1,2]) = [];
   else
@@ -35,16 +36,17 @@ function descriptions = rebuild (prefix,
     wd = pwd ();
     unwind_protect
       cd (prefix);
       dirlist = glob (strcat (files, '-*'));
     unwind_protect_cleanup
       cd (wd);
     end_unwind_protect
   endif
+
   descriptions = {};
   for k = 1:length (dirlist)
     descfile = fullfile (prefix, dirlist{k}, "packinfo", "DESCRIPTION");
     if (verbose)
       printf ("recreating package description from %s\n", dirlist{k});
     endif
     if (exist (descfile, "file"))
       desc = get_description (descfile);
@@ -74,10 +76,11 @@ function descriptions = rebuild (prefix,
           dup = [dup, j];
         endif
       endfor
     endfor
     if (! isempty (dup))
       descriptions(dup) = [];
     endif
   endif
+
 endfunction
 
diff --git a/scripts/pkg/private/save_order.m b/scripts/pkg/private/save_order.m
--- a/scripts/pkg/private/save_order.m
+++ b/scripts/pkg/private/save_order.m
@@ -18,16 +18,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {@var{newdesc} =} save_order (@var{desc})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function newdesc = save_order (desc)
+
   newdesc = {};
   for i = 1 : length (desc)
     deps = desc{i}.depends;
     if (isempty (deps)
         || (length (deps) == 1 && strcmp (deps{1}.package, "octave")))
       newdesc{end + 1} = desc{i};
     else
       tmpdesc = {};
@@ -41,20 +42,22 @@ function newdesc = save_order (desc)
       endfor
       if (! isempty (tmpdesc))
         newdesc = {newdesc{:}, save_order(tmpdesc){:}, desc{i}};
       else
         newdesc{end+1} = desc{i};
       endif
     endif
   endfor
+
   ## Eliminate the duplicates.
   idx = [];
   for i = 1 : length (newdesc)
     for j = (i + 1) : length (newdesc)
       if (strcmp (newdesc{i}.name, newdesc{j}.name))
         idx(end + 1) = j;
       endif
     endfor
   endfor
   newdesc(idx) = [];
+
 endfunction
 
diff --git a/scripts/pkg/private/uninstall.m b/scripts/pkg/private/uninstall.m
--- a/scripts/pkg/private/uninstall.m
+++ b/scripts/pkg/private/uninstall.m
@@ -19,16 +19,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {} {} uninstall (@var{pkgnames}, @var{handle_deps}, @var{verbose}, @var{local_list}, @var{global_list}, @var{global_install})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function uninstall (pkgnames, handle_deps, verbose, local_list,
                     global_list, global_install)
+
   ## Get the list of installed packages.
   [local_packages, global_packages] = installed_packages(local_list,
                                                          global_list);
   if (global_install)
     installed_pkgs_lst = {local_packages{:}, global_packages{:}};
   else
     installed_pkgs_lst = local_packages;
   endif
diff --git a/scripts/pkg/private/unload_packages.m b/scripts/pkg/private/unload_packages.m
--- a/scripts/pkg/private/unload_packages.m
+++ b/scripts/pkg/private/unload_packages.m
@@ -18,16 +18,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {} unload_packages (@var{files}, @var{handle_deps}, @var{local_list}, @var{global_list})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function unload_packages (files, handle_deps, local_list, global_list)
+
   installed_pkgs_lst = installed_packages (local_list, global_list);
   num_packages = length (installed_pkgs_lst);
 
   ## Read package names and installdirs into a more convenient format.
   pnames = pdirs = cell (1, num_packages);
   for i = 1:num_packages
     pnames{i} = installed_pkgs_lst{i}.name;
     pdirs{i} = installed_pkgs_lst{i}.dir;
@@ -71,10 +72,11 @@ function unload_packages (files, handle_
   for i = 1:length (archdirs)
     d = archdirs{i};
     idx = strcmp (p, d);
     if (any (idx))
       rmpath (d);
       ## FIXME: We should also check if we need to remove items from EXEC_PATH.
     endif
   endfor
+
 endfunction
 
diff --git a/scripts/plot/appearance/annotation.m b/scripts/plot/appearance/annotation.m
--- a/scripts/plot/appearance/annotation.m
+++ b/scripts/plot/appearance/annotation.m
@@ -524,101 +524,113 @@ function h = buildannot (hax, objtype, p
       addlistener (h, "verticalalignment",
                    {@update_textbox, "position", [hte hpa]});
 
   endswitch
 
 endfunction
 
 function props = lineprops (varargin)
+
   ## FIXME: Use "axesx(y)lim" instead of "linex(y)data"
   props = {"color", "color", [0 0 0], ...
            "linestyle",  "linelinestyle", "-", ...
            "linewidth", "linelinewidth", 0.5, ...
            "x", "linexdata", [0.3 0.4], ...
            "y", "lineydata", [0.3 0.4]};
   if (strcmp (varargin, "names"))
     props = props(1:3:end);
   endif
+
 endfunction
 
 function col = basecolors ()
   col = {"blue", "black", "cyan", "green", "magenta", "red", ...
          "white", "yellow", "none"};
 endfunction
 
 function linemenu (hui, hpar)
+
   hm = uimenu ("parent", hui, "label", "Line");
 
   ## Color
   vals = basecolors ();
   addbasemenu (hm, hpar, "Color", vals);
 
-
   ## Linestyle
   vals = set (hpar, "linestyle");
   addbasemenu (hm, hpar, "Linestyle", vals);
 
   ## Linewidth
   vals = [0.5 1 1.5 2];
   addbasemenu (hm, hpar, "Linewidth", vals);
+
 endfunction
 
 function props = arrowprops (varargin)
+
   props = {"headlength", "data", 10, ...
            "headstyle",  "radio", "diamond|ellipse|none|plain|rectangle|vback1|{vback2}|vback3", ...
            "headwidth",  "data", 10};
   if (strcmp (varargin, "names"))
     props = props(1:3:end);
   endif
+
 endfunction
 
 function arrowmenu (hui, hpar)
+
   hm = uimenu ("parent", hui, "label", "Arrowhead");
 
   ## Headlength/width
   vals = 6:2:16;
   addbasemenu (hm, hpar, "headlength", vals, "Length");
   addbasemenu (hm, hpar, "headwidth", vals, "Width");
 
   ## Headstyle
   vals = set (hpar, "headstyle");
   addbasemenu (hm, hpar, "Headstyle", vals);
+
 endfunction
 
 function props = dblarrowprops (varargin)
+
   props = {"head1length", "data", 10, ...
            "head1style",  "radio", "diamond|ellipse|none|plain|rectangle|vback1|{vback2}|vback3", ...
            "head1width",  "data", 10, ...
            "head2length", "data", 10, ...
            "head2style",  "radio", "diamond|ellipse|none|plain|rectangle|vback1|{vback2}|vback3", ...
            "head2width", "data", 10};
   if (strcmp (varargin, "names"))
     props = props(1:3:end);
   endif
+
 endfunction
 
 function dblarrowmenu (hui, hpar)
+
   hm1 = uimenu ("parent", hui, "label", "Arrowhead #1");
   hm2 = uimenu ("parent", hui, "label", "Arrowhead #2");
 
   ## Headlength/width
   vals = 6:2:16;
   addbasemenu (hm1, hpar, "head1length", vals, "Length");
   addbasemenu (hm1, hpar, "head1width", vals, "Width");
   addbasemenu (hm2, hpar, "head2length", vals, "Length");
   addbasemenu (hm2, hpar, "head2width", vals, "Width");
 
   ## Headstyle
   vals = set (hpar, "head1style");
   addbasemenu (hm1, hpar, "head1style", vals, "Headstyle");
   addbasemenu (hm2, hpar, "head2style", vals, "Headstyle");
+
 endfunction
 
 function props = textprops (varargin)
+
   props = {"fontangle", "textfontangle", "normal", ...
            "fontname",  "textfontname", "Helvetica", ...
            "fontsize", "textfontsize", 10, ...
            "fontunits", "textfontunits", "points", ...
            "fontweight",  "textfontweight", "normal", ...
            "horizontalalignment", "texthorizontalalignment", "left", ...
            "interpreter", "textinterpreter", "tex", ...
            "string", "textstring", "", ...
@@ -627,36 +639,40 @@ function props = textprops (varargin)
            "textedgecolor", "textedgecolor", "none", ...
            "textlinewidth", "textlinewidth",0.5, ...
            "textmargin", "textmargin", 5, ...
            "textrotation", "textrotation", 0, ...
            "verticalalignment", "textverticalalignment", "middle"};
   if (strcmp (varargin, "names"))
     props = props(1:3:end);
   endif
+
 endfunction
 
 function stringdlg (hpar, prop)
+
   def = get (hpar, prop);
   if (iscell (def))
     prompt = arrayfun (@(n) sprintf ("Line #%d:", n), 1:numel (def),
                        "uniformoutput", false);
   else
     prompt = "";
     def = {def};
   endif
 
   cstr = inputdlg (prompt, prop, 1, def);
 
   if (! isempty (cstr))
     set (hpar, prop, cstr);
   endif
+
 endfunction
 
 function textmenu (hui, hpar)
+
   hm = uimenu ("parent", hui, "label", "Text");
 
   ## String;
   prop = "String";
   fcn = @() stringdlg (hpar, prop);
   uimenu (hm, "label", prop, "callback", fcn);
 
   ## Font properties
@@ -689,16 +705,17 @@ function textmenu (hui, hpar)
   prop = "interpreter";
   vals = set (hpar, prop);
   addbasemenu (hm, hpar, prop, vals, "Interpreter", ...
                "separator", "on");
 
 endfunction
 
 function props = textboxprops (varargin)
+
   props = {"backgroundcolor", "patchfacecolor", "none", ...
            "color", "textcolor", [0 0 0], ...
            "edgecolor", "patchedgecolor", [0 0 0], ...
            "facealpha", "patchfacealpha", 1, ...
            "fontangle", "textfontangle", "normal", ...
            "fontname",  "textfontname", "Helvetica", ...
            "fontsize", "textfontsize", 10, ...
            "fontunits", "textfontunits", "points", ...
@@ -709,19 +726,21 @@ function props = textboxprops (varargin)
            "linewidth", "linelinewidth", 0.5, ...
            "string", "textstring", "", ...
            "fitboxtotext", "radio","{on}|off", ...
            "margin", "data", 5, ...
            "verticalalignment", "textverticalalignment",  "middle"};
   if (strcmp (varargin, "names"))
     props = props(1:3:end);
   endif
+
 endfunction
 
 function textboxmenu (hui, hpar)
+
   ## Text properties
   hm1 = uimenu ("parent", hui, "label", "Text");
 
   prop = "String";
   fcn = @() stringdlg (hpar, prop);
   uimenu (hm1, "label", prop, "callback", fcn);
 
   prop = "Color";
@@ -766,50 +785,56 @@ function textboxmenu (hui, hpar)
   vals = basecolors ();
   addbasemenu (hm2, hpar, prop, vals, "Edge Color");
   prop = "linestyle";
   vals = set (hpar, prop);
   addbasemenu (hm2, hpar, prop, vals, "Line Style");
   prop = "linewidth";
   vals = 0.5:.5:2;
   addbasemenu (hm2, hpar, prop, vals, "Line Width");
+
 endfunction
 
 function props = rectprops (varargin)
+
   props = {"edgecolor", "patchedgecolor", "k", ...
            "facealpha", "patchfacealpha", 1, ...
            "facecolor", "patchfacecolor", "none", ...
            "linestyle", "patchlinestyle", "-", ...
            "linewidth", "patchlinewidth", 0.5};
   if (strcmp (varargin, "names"))
     props = props(1:3:end);
   endif
+
 endfunction
 
 function rectmenu (hui, hpar)
+
   prop = "facecolor";
   vals = basecolors ();
   addbasemenu (hui, hpar, prop, vals, "Face Color");
   prop = "edgecolor";
   vals = basecolors ();
   addbasemenu (hui, hpar, prop, vals, "Edge Color");
   prop = "linestyle";
   vals = set (hpar, prop);
   addbasemenu (hui, hpar, prop, vals, "Line Style");
   prop = "linewidth";
   vals = 0.5:.5:2;
   addbasemenu (hui, hpar, prop, vals, "Line Width");
+
 endfunction
 
 function addbaseprops (h, proptable)
   cellfun (@(pname, ptype, parg) addproperty (pname, h, ptype, parg),
            proptable(1:3:end), proptable(2:3:end), proptable(3:3:end));
 endfunction
 
 function addbasemenu (hm, hpar, pname, vals, mainlabel = "" )
+
   if (isempty (mainlabel))
     mainlabel = pname;
   endif
 
   h = uimenu ("parent", hm, "label", mainlabel);
 
   is_numeric = ! iscell (vals);
   nv = numel (vals);
@@ -820,48 +845,54 @@ function addbasemenu (hm, hpar, pname, v
     else
       val = vals(ii);
       label = num2str (val);
     endif
 
     fcn = @() set (hpar, pname, val);
     htmp(ii) = uimenu (h, "label", label, "callback", fcn);
   endfor
+
   handle_check (hpar, {}, htmp, pname, is_numeric);
   addlistener (hpar, pname, {@handle_check, htmp, pname, is_numeric});
+
 endfunction
 
 function handle_check (h, dummy, hmenus, prop, is_numeric)
+
   vals = get (hmenus, "label");
   current = get (h, prop);
   if (is_numeric)
     current = num2str (current);
   endif
 
   idx = strcmp (vals, current);
   set (hmenus(idx), "checked", "on");
   set (hmenus(! idx), "checked", "off");
+
 endfunction
 
 function update_position (h1, dummy, h, force = false)
+
   if (! force)
     pos = convertposition (h, getappdata (h, "__former_units__"),
                            get (h, "units"));
     setappdata (h, "__former_units__", get (h, "units"));
     set (h, "position", pos);
   else
     ## FIXME: Inefficient trick to force all objects to be redrawn
     set (h, "position", [0 0 .5 .5],
          "position", get (h, "position"));
   endif
+
 endfunction
 
-
 function update_line (h, dummy, prop, hli)
   persistent recursive = false;
+
   if (! recursive)
     switch (prop)
       case "color"
         set (hli, "color", get (h, "color"));
       case "linestyle"
         set (hli, "linestyle", get (h, "linestyle"));
       case "linewidth"
         set (hli, "linewidth", get (h, "linewidth"));
@@ -909,19 +940,21 @@ function update_line (h, dummy, prop, hl
         pos = getnormpos (h);
         x = [pos(1) (pos(1) + pos(3))];
         y = [pos(2) (pos(2) + pos(4))];
         set (hli, "xdata", x);
         set (hli, "ydata", y);
 
     endswitch
   endif
+
 endfunction
 
 function [x, y] = arrowcoordinates (h, nar = [])
+
   pos = getnormpos (h);
   ppos = norm2pts (h, pos(3:4).');
   ang = angle (complex (ppos(1), ppos(2)));
 
   if (isempty (nar))
     ln = get (h, "headlength");   # in points
     wd = get (h, "headwidth");
     headstyle = get (h, "headstyle");
@@ -974,16 +1007,17 @@ function [x, y] = arrowcoordinates (h, n
   R = [cos(ang) -sin(ang);
        sin(ang) cos(ang)];
   XY = R * [x; y];
   XY = pts2norm (h, XY);
   XY = pos(1:2).' .+ XY;
 
   x = XY(1,:).';
   y = XY(2,:).';
+
 endfunction
 
 function update_arrow (h, dummy, prop, hpa = [])
   persistent recursive = false;
 
   nar = [];
   for ii = 1:numel (hpa)
     if (numel (hpa) == 2)
@@ -995,16 +1029,17 @@ function update_arrow (h, dummy, prop, h
           [x, y] = arrowcoordinates (h, nar);
           set (hpa(ii), "xdata", x, "ydata", y);
         case "color"
           set (hpa(ii), "facecolor", get (h, "color"));
           set (hpa(ii), "edgecolor", get (h, "color"));
       endswitch
     endif
   endfor
+
 endfunction
 
 function update_text (h, dummy, prop, hte)
   persistent recursive = false;
 
   if (! recursive)
     switch (prop)
       case "position"
@@ -1019,16 +1054,17 @@ function update_text (h, dummy, prop, ht
       otherwise
         if (strncmp (prop, "text", 4))
           set (hte, prop(5:end), get (h, prop));
         else
           set (hte, prop, get (h, prop));
         endif
     endswitch
   endif
+
 endfunction
 
 function update_textbox (h, dummy, prop, htb)
   persistent recursive = false;
 
   hte = htb(1);
   hpa = htb(2);
 
@@ -1199,28 +1235,29 @@ function pos = getnormpos (h)
 endfunction
 
 function [x, y] = pos2rect (pos)
   x = [pos(1) pos(1)+pos(3) pos(1)+pos(3) pos(1)];
   y = [pos(2) pos(2) pos(2)+pos(4) pos(2)+pos(4)];
 endfunction
 
 function [x, y] = pos2ell (pos)
+
   a = pos(3)/2;
   b = pos(4)/2;
 
-  ## Arbitrarily use 100 points
-  ## when it is spread over
+  ## Arbitrarily use 100 points when it is spread over
   ang = linspace (0, 2*pi, 100);
 
   x = a * cos (ang);
   y = b * sin (ang);
 
   x += pos(1) + a;
   y += pos(2) + b;
+
 endfunction
 
 function update_rect (h, dummy, prop, hre, typ)
   persistent recursive = false;
 
   if (! recursive)
     switch (prop)
       case "position"
@@ -1231,20 +1268,21 @@ function update_rect (h, dummy, prop, hr
           [x, y] = pos2ell (pos);
         endif
 
         set (hre, "xdata", x, "ydata", y);
       otherwise
         set (hre, prop, get (h, prop));
     endswitch
   endif
+
 endfunction
 
 
-## FIXME: the additionnal regular axes is necessary for fltk to draw the
+## FIXME: the additional regular axes is necessary for fltk to draw the
 ##        annotation axes.
 %!demo
 %! clf; axes ('visible', 'off');
 %! annotation ('textbox', [.25 .9 .5 .09], 'string', ...
 %!             {'Right Click on annotation objects', ...
 %!              'to customize their appearance'}, ...
 %!             'horizontalalignment', 'center', 'fitboxtotext', 'off');
 %! annotation ('ellipse', [.2 .2 .6 .6], 'linewidth', 4);
diff --git a/scripts/plot/appearance/datetick.m b/scripts/plot/appearance/datetick.m
--- a/scripts/plot/appearance/datetick.m
+++ b/scripts/plot/appearance/datetick.m
@@ -266,35 +266,37 @@ function __datetick__ (varargin)
   else
     if (keeplimits)
       set (gca (), [ax "tick"], ticks, [ax "ticklabel"], sticks);
     else
       set (gca (), [ax "tick"], ticks, [ax "ticklabel"], sticks,
                    [ax "lim"], [min(ticks), max(ticks)]);
     endif
   endif
+
 endfunction
 
 function [a, b] = __magform__ (x)
+
   if (x == 0)
-    a = 0;
-    b = 0;
+    a = b = 0;
   else
     l = log10 (abs (x));
     r = rem (l, 1);
     a = 10 .^ r;
     b = fix (l - r);
     if (a < 1)
       a *= 10;
       b -= 1;
     endif
     if (x < 0)
       a = -a;
     endif
   endif
+
 endfunction
 
 ## A translation from Tom Holoryd's python code at
 ## http://kurage.nimh.nih.gov/tomh/tics.py
 function sep = __calc_tick_sep__ (lo, hi)
   persistent sqrt_2  = sqrt (2.0);
   persistent sqrt_10 = sqrt (10.0);
   persistent sqrt_50 = sqrt (50.0);
@@ -312,11 +314,13 @@ function sep = __calc_tick_sep__ (lo, hi
     x = 1;
   elseif (a < sqrt_10)
     x = 2;
   elseif (a < sqrt_50)
     x = 5;
   else
     x = 10;
   endif
+
   sep = x * 10 .^ b;
+
 endfunction
 
diff --git a/scripts/plot/appearance/legend.m b/scripts/plot/appearance/legend.m
--- a/scripts/plot/appearance/legend.m
+++ b/scripts/plot/appearance/legend.m
@@ -1099,33 +1099,36 @@ function updatelegend (h, ~)
     unwind_protect_cleanup
       recursive = false;
     end_unwind_protect
   endif
 
 endfunction
 
 function updatelegendtext (h, ~)
+
   kids = get (h, "children");
   htext = [];
   for i = 1:numel (kids)
     if (strcmp (get (kids(i), "type"), "text"))
       htext(end+1) = kids(i);
     endif
   endfor
 
   tprops = {"fontangle", "fontname", "fontweight", "color"};
   lprops = {"fontangle", "fontname", "fontweight", "textcolor"};
   set (htext, tprops, get (h, lprops));
 
   ec = get (h, "edgecolor");
   set (h, "xcolor", ec, "ycolor", ec);
+
 endfunction
 
 function hideshowlegend (h, ~, ca, pos1, pos2)
+
   isvisible = strcmp (get (h, "visible"), "off");
   if (! isvisible)
     kids = get (h, "children");
     if (any (! strcmp (get (kids, "visible"), "off")))
       isvisible = true;
     endif
   endif
 
@@ -1141,58 +1144,63 @@ function hideshowlegend (h, ~, ca, pos1,
         else
           set (ca(i), "position", pos1);
         endif
       unwind_protect_cleanup
         set (ca(i), "units", units);
       end_unwind_protect
     endif
   endfor
+
 endfunction
 
 function deletelegend1 (h, ~, hlegend)
   if (isaxes (hlegend)
       && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"), "off"))
       && strcmp (get (hlegend, "beingdeleted"), "off"))
     delete (hlegend);
   endif
 endfunction
 
 function deletelegend2 (h, ~, ca, pos, outpos, t1, hplots)
+
   for i = 1 : numel (ca)
     if (isaxes (ca(i))
         && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"), "off"))
         && strcmp (get (ca(i), "beingdeleted"), "off"))
       if (! isempty (pos) && ! isempty (outpos))
         units = get (ca(i), "units");
         unwind_protect
           set (ca(i), "units", "points");
           set (ca(i), "position", pos, "deletefcn", "");
         unwind_protect_cleanup
           set (ca(i), "units", units);
         end_unwind_protect
       endif
     endif
   endfor
+
   if (ishandle (t1))
     set (t1, "deletefcn", "");
     delete (t1);
   endif
+
   for i = 1 : numel (hplots)
     if (ishandle (hplots(i)) && strcmp (get (hplots(i), "type"), "line"))
       dellistener (hplots(i), "color");
       dellistener (hplots(i), "linestyle");
       dellistener (hplots(i), "linewidth");
       dellistener (hplots(i), "marker");
       dellistener (hplots(i), "markeredgecolor");
       dellistener (hplots(i), "markerfacecolor");
       dellistener (hplots(i), "markersize");
       dellistener (hplots(i), "displayname");
     endif
   endfor
+
 endfunction
 
 function updateline (h, ~, hlegend, linelength, update_name)
 
   if (update_name)
     ## When string changes, have to rebuild legend completely
     [hplots, text_strings] = __getlegenddata__ (hlegend);
     legend (get (hplots(1), "parent"), hplots, text_strings);
@@ -1240,16 +1248,17 @@ function updateline (h, ~, hlegend, line
             "marker", marker, "markeredgecolor", get (h, "markeredgecolor"),
             "markerfacecolor", get (h, "markerfacecolor"),
             "markersize", min (get (h, "markersize"), 10),
             "linestyle", "none",
             "linewidth", min (get (h, "linewidth"), 5),
             "userdata", h, "parent", hlegend);
     endif
   endif
+
 endfunction
 
 
 %!demo
 %! clf;
 %! plot (rand (2));
 %! title ('legend called with cellstr and string inputs for labels');
 %! h = legend ({'foo'}, 'bar');
diff --git a/scripts/plot/appearance/whitebg.m b/scripts/plot/appearance/whitebg.m
--- a/scripts/plot/appearance/whitebg.m
+++ b/scripts/plot/appearance/whitebg.m
@@ -33,16 +33,17 @@
 ##
 ## If the first argument @var{hfig} is a figure handle, then operate on
 ## this figure rather than the current figure returned by @code{gcf}.  The
 ## root properties will not be changed.
 ## @seealso{reset, get, set}
 ## @end deftypefn
 
 function whitebg (varargin)
+
   h = 0;
   color = NaN;
 
   if (nargin > 0 && nargin < 3)
     if (ishandle (varargin{1}))
       h = varargin{1};
       if (nargin == 2)
         color = varargin{2};
@@ -128,27 +129,27 @@ function whitebg (varargin)
             defaultvalue = ...
               1 - subsref (def, struct ("type", ".", "subs", defaultfield));
             set (h (nh), defaultfield, defaultvalue);
           endfor
         endif
       endif
     endfor
   else
-    ## FIXME
-    ## Is this the right thing to do in this case?
+    ## FIXME: Is this the right thing to do in this case?
     set (findall (fig, "type", "axes"), "color", color);
     if (isroot)
       defs = get (0, "default");
       if (isfield (defs, "defaultaxescolor")
           && strcmp (defs.defaultaxescolor, "none"))
         set (0, "defaultaxescolor", color);
       endif
     endif
   endif
+
 endfunction
 
 
 %!test
 %! dac = get (0, "defaultaxescolor");
 %! dfc = get (0, "defaultfigurecolor");
 %! hf = figure ("visible", "off");
 %! unwind_protect
diff --git a/scripts/plot/appearance/xlim.m b/scripts/plot/appearance/xlim.m
--- a/scripts/plot/appearance/xlim.m
+++ b/scripts/plot/appearance/xlim.m
@@ -38,21 +38,23 @@
 ## or @qcode{"manual"} as the argument.
 ##
 ## If the first argument @var{hax} is an axes handle, then operate on
 ## this axis rather than the current axes returned by @code{gca}.
 ## @seealso{ylim, zlim, axis, set, get, gca}
 ## @end deftypefn
 
 function retval = xlim (varargin)
+
   ret = __axis_limits__ ("xlim", varargin{:});
 
   if (! isempty (ret))
     retval = ret;
   endif
+
 endfunction
 
 
 %!demo
 %! clf;
 %! line ();
 %! xlim ([0.2, 0.8]);
 %! title ('xlim is [0.2, 0.8]');
diff --git a/scripts/plot/appearance/ylim.m b/scripts/plot/appearance/ylim.m
--- a/scripts/plot/appearance/ylim.m
+++ b/scripts/plot/appearance/ylim.m
@@ -38,21 +38,23 @@
 ## or @qcode{"manual"} as the argument.
 ##
 ## If the first argument @var{hax} is an axes handle, then operate on
 ## this axis rather than the current axes returned by @code{gca}.
 ## @seealso{xlim, zlim, axis, set, get, gca}
 ## @end deftypefn
 
 function retval = ylim (varargin)
+
   ret = __axis_limits__ ("ylim", varargin{:});
 
   if (! isempty (ret))
     retval = ret;
   endif
+
 endfunction
 
 
 %!demo
 %! clf;
 %! line ();
 %! ylim ([0.2, 0.8]);
 %! title ('ylim is [0.2, 0.8]');
diff --git a/scripts/plot/appearance/zlim.m b/scripts/plot/appearance/zlim.m
--- a/scripts/plot/appearance/zlim.m
+++ b/scripts/plot/appearance/zlim.m
@@ -38,21 +38,23 @@
 ## or @qcode{"manual"} as the argument.
 ##
 ## If the first argument @var{hax} is an axes handle, then operate on
 ## this axis rather than the current axes returned by @code{gca}.
 ## @seealso{xlim, ylim, axis, set, get, gca}
 ## @end deftypefn
 
 function retval = zlim (varargin)
+
   ret = __axis_limits__ ("zlim", varargin{:});
 
   if (! isempty (ret))
     retval = ret;
   endif
+
 endfunction
 
 
 %!demo
 %! clf;
 %! line ();
 %! zlim ([0.2, 0.8]);
 %! title ('zlim is [0.2, 0.8]');
diff --git a/scripts/plot/draw/area.m b/scripts/plot/draw/area.m
--- a/scripts/plot/draw/area.m
+++ b/scripts/plot/draw/area.m
@@ -182,21 +182,23 @@ function retval = __area__ (ax, x, y, bv
     if (! isempty (args))
       set (hg, args{:});
     endif
   endfor
 
 endfunction
 
 function update_props (h, d)
+
   kids = get (h, "children");
   set (kids, "edgecolor", get (h, "edgecolor"),
              "facecolor", get (h, "facecolor"),
              "linestyle", get (h, "linestyle"),
              "linewidth", get (h, "linewidth"));
+
 endfunction
 
 function move_baseline (h, d)
   persistent recursion = false;
 
   ## Don't allow recursion
   if (! recursion)
     unwind_protect
@@ -212,19 +214,21 @@ function move_baseline (h, d)
           endif
         endif
       endfor
       update_data (h, d);
     unwind_protect_cleanup
       recursion = false;
     end_unwind_protect
   endif
+
 endfunction
 
 function update_data (h, d)
+
   hlist = get (h, "areagroup");
   bv = get (h, "basevalue");
   for i = 1 : length (hlist)
     hh = hlist(i);
     x1 = get (hh, "xdata")(:);
     y1 = get (hh, "ydata")(:);
 
     set (get (hh, "children"), "xdata", [x1(1); x1; flipud(x1)]);
@@ -232,16 +236,17 @@ function update_data (h, d)
       set (get (hh, "children"), "ydata", [bv; y1; bv*ones(length(y1), 1)]);
     else
       y1 = y0 + y1;
       set (get (hh, "children"), "ydata", [y0(1); y1; flipud(y0)]);
     endif
 
     y0 = y1;
   endfor
+
 endfunction
 
 
 %!demo
 %! ## Verify identity sin^2 + cos^2 = 1
 %! clf;
 %! t = linspace (0, 2*pi, 100)';
 %! y = [sin(t).^2, cos(t).^2];
diff --git a/scripts/plot/draw/colorbar.m b/scripts/plot/draw/colorbar.m
--- a/scripts/plot/draw/colorbar.m
+++ b/scripts/plot/draw/colorbar.m
@@ -249,37 +249,39 @@ function h = colorbar (varargin)
 
   if (nargout > 0)
     h = cax;
   endif
 
 endfunction
 
 function deletecolorbar (h, d, hc, orig_props)
-  ## Don't delete the colorbar and reset the axis size if the
-  ## parent figure is being deleted.
+  ## Don't delete the colorbar and reset the axis size
+  ## if the parent figure is being deleted.
   if (isaxes (hc)
       && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"), "off")))
     if (strcmp (get (hc, "beingdeleted"), "off"))
       delete (hc);
     endif
     if (! isempty (ancestor (h, "axes"))
         && strcmp (get (ancestor (h, "axes"), "beingdeleted"), "off"))
       ax = ancestor (h, "axes");
       units = get (ax, "units");
       set (ax, "units", orig_props.units);
       set (ancestor (h, "axes"), "position", orig_props.position,
                             "outerposition", orig_props.outerposition,
                    "activepositionproperty", orig_props.activepositionproperty);
       set (ax, "units", units);
     endif
   endif
+
 endfunction
 
 function resetaxis (cax, d, ax, orig_props)
+
   if (isaxes (ax))
     ## FIXME: Probably don't want to delete everyone's listeners on colormap.
     dellistener (ancestor (ax, "figure"), "colormap");
     dellistener (ax, "clim");
     dellistener (ax, "dataaspectratio");
     dellistener (ax, "dataaspectratiomode");
     dellistener (ax, "plotboxaspectratio");
     dellistener (ax, "plotboxaspectratiomode");
@@ -287,19 +289,21 @@ function resetaxis (cax, d, ax, orig_pro
 
     units = get (ax, "units");
     set (ax, "units", orig_props.units);
     set (ax, "position", orig_props.position,
              "outerposition", orig_props.outerposition,
              "activepositionproperty", orig_props.activepositionproperty);
     set (ax, "units", units);
   endif
+
 endfunction
 
 function update_colorbar_clim (hax, d, hi, vert)
+
   if (isaxes (hax)
       && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"), "off")))
     clen = rows (get (ancestor (hax, "figure"), "colormap"));
     cext = get (hax, "clim");
     cdiff = (cext(2) - cext(1)) / clen / 2;
     cmin = cext(1) + cdiff;
     cmax = cext(2) - cdiff;
 
@@ -307,16 +311,17 @@ function update_colorbar_clim (hax, d, h
     if (vert)
       set (hi, "ydata", [cmin, cmax]);
       set (hiax, "ylim", cext);
     else
       set (hi, "xdata", [cmin, cmax]);
       set (hiax, "xlim", cext);
     endif
   endif
+  
 endfunction
 
 function update_colorbar_cmap (hf, d, hi, vert, init_sz)
   persistent sz = init_sz;
 
   if (ishandle (hf) && strcmp (get (hf, "type"), "figure")
       && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"), "off")))
     clen = rows (get (hf, "colormap"));
@@ -326,19 +331,21 @@ function update_colorbar_cmap (hf, d, hi
       else
         set (hi, "cdata", [1:clen]);
       endif
       sz = clen;
       ## Also update limits on axis or there will be white gaps
       update_colorbar_clim (get (hi, "parent"), d, hi, vert);
     endif
   endif
+
 endfunction
 
 function update_colorbar_axis (h, d, cax, orig_props)
+
   if (isaxes (cax)
       && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"),"off")))
     loc = get (cax, "location");
     obj = get (h);
     obj.__cbar_hax__ = h;
     obj.position = orig_props.position;
     obj.outerposition = orig_props.outerposition;
     [pos, cpos, vertical, mirror] = ...
@@ -358,16 +365,17 @@ function update_colorbar_axis (h, d, cax
                   "xaxislocation", "top", "position", cpos);
       else
         set (cax, "ytick", [], "xdir", "normal", "ydir", "normal",
                   "xaxislocation", "bottom", "position", cpos);
       endif
     endif
 
   endif
+
 endfunction
 
 function [pos, cpos, vertical, mirr] = __position_colorbox__ (cbox, obj, cf)
 
   ## This will always represent the position prior to adding the colorbar.
   pos = obj.position;
   sz = pos(3:4);
 
diff --git a/scripts/plot/draw/fill.m b/scripts/plot/draw/fill.m
--- a/scripts/plot/draw/fill.m
+++ b/scripts/plot/draw/fill.m
@@ -141,29 +141,31 @@ endfunction
 
 function iargs = __find_patches__ (varargin)
   iargs = 1:3:nargin;
   optidx = find (! cellfun (@isnumeric, varargin(iargs)), 1);
   iargs(optidx:end) = [];
 endfunction
 
 function retval = iscolorspec (arg)
+
   retval = false;
   if (ischar (arg))
     persistent colors = {"y", "yellow", "r", "red", "m", "magenta", ...
                          "c", "cyan", "g", "green", "b", "blue", ...
                          "w", "white", "k", "black"};
     if (any (strcmpi (arg, colors)))
       retval = true;
     endif
   elseif (isnumeric (arg))
     ## Assume any numeric argument is correctly formatted cdata.
     ## Let patch worry about the multple different input formats.
     retval = true;
   endif
+
 endfunction
 
 
 %!demo
 %! clf;
 %! t1 = (1/16:1/8:1) * 2*pi;
 %! t2 = ((1/16:1/8:1) + 1/32) * 2*pi;
 %! x1 = sin (t1) - 0.8;
diff --git a/scripts/plot/draw/isocolors.m b/scripts/plot/draw/isocolors.m
--- a/scripts/plot/draw/isocolors.m
+++ b/scripts/plot/draw/isocolors.m
@@ -95,16 +95,17 @@
 ## @end example
 ##
 ## @seealso{isosurface, isonormals}
 ## @end deftypefn
 
 ## Author: Martin Helm <martin@mhelm.de>
 
 function varargout = isocolors (varargin)
+
   calc_rgb = false;
   switch (nargin)
     case 2
       c = varargin{1};
       vp = varargin{2};
       x = 1:size (c, 2);
       y = 1:size (c, 1);
       z = 1:size (c, 3);
@@ -130,43 +131,48 @@ function varargout = isocolors (varargin
       z = varargin{3};
       R = varargin{4};
       G = varargin{5};
       B = varargin{6};
       vp = varargin{7};
     otherwise
       print_usage ();
   endswitch
+
   if (isnumeric (vp) && columns (vp) == 3)
     pa = [];
     v = vp;
   elseif ( ishandle (vp) )
     pa = vp;
     v = get (pa, "Vertices");
   else
     error ("isocolors: last argument is not a vertex list or patch handle");
   endif
+
   if (calc_rgb)
     new_col = zeros (rows (v), 3);
     new_col(:,1) = __interp_cube__ (x, y, z, R, v, "values" );
     new_col(:,2) = __interp_cube__ (x, y, z, G, v, "values" );
     new_col(:,3) = __interp_cube__ (x, y, z, B, v, "values" );
   else
     new_col = __interp_cube__ (x, y, z, c, v, "values" );
   endif
+
+  ## FIXME: No reason to actually error out if an extra argout is used.
   switch (nargout)
     case 0
       if (! isempty (pa))
         set (pa, "FaceVertexCData", new_col);
       endif
     case 1
       varargout = {new_col};
     otherwise
       print_usage ();
   endswitch
+
 endfunction
 
 
 %!test
 %! [x, y, z] = meshgrid (0:.5:2, 0:.5:2, 0:.5:2);
 %! c = (x-.5).^2 + (y-.5).^2 + (z-.5).^2;
 %! [f, v] = isosurface (x, y, z, c, .4);
 %! cdat = isocolors (x, y, z, c, v);
diff --git a/scripts/plot/draw/isonormals.m b/scripts/plot/draw/isonormals.m
--- a/scripts/plot/draw/isonormals.m
+++ b/scripts/plot/draw/isonormals.m
@@ -93,66 +93,72 @@
 ## @end smallexample
 ##
 ## @seealso{isosurface, isocolors}
 ## @end deftypefn
 
 ## Author: Martin Helm <martin@mhelm.de>
 
 function varargout = isonormals (varargin)
+
   na = nargin;
   negate = false;
   if (ischar (varargin{nargin}))
     na = nargin-1;
     if (strcmp (lower (varargin{nargin}), "negate"))
       negate = true;
     else
       error ("isonormals: Unknown option '%s'", varargin{nargin});
     endif
   endif
+
   switch (na)
     case 2
       c = varargin{1};
       vp = varargin{2};
       x = 1:size (c, 2);
       y = 1:size (c, 1);
       z = 1:size (c, 3);
     case 5
       x = varargin{1};
       y = varargin{2};
       z = varargin{3};
       c = varargin{4};
       vp = varargin{5};
     otherwise
       print_usage ();
   endswitch
+
   if (isnumeric (vp) && columns (vp) == 3)
     pa = [];
     v = vp;
   elseif (ishandle (vp))
     pa = vp;
     v = get (pa, "Vertices");
   else
     error ("isonormals: Last argument is not a vertex list or a patch handle");
   endif
+
   if (negate)
     normals = -__interp_cube__ (x, y, z, c, v, "normals");
   else
     normals = __interp_cube__ (x, y, z, c, v, "normals");
   endif
+
   switch (nargout)
     case 0
       if (! isempty (pa))
         set (pa, "VertexNormals", normals);
       endif
     case 1
       varargout = {normals};
     otherwise
       print_usage ();
   endswitch
+
 endfunction
 
 
 %!test
 %! [x, y, z] = meshgrid (0:.5:2, 0:.5:2, 0:.5:2);
 %! c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
 %! [f, v, cdat] = isosurface (x, y, z, c, .4, y);
 %! n = isonormals (x, y, z, c, v);
diff --git a/scripts/plot/draw/plotmatrix.m b/scripts/plot/draw/plotmatrix.m
--- a/scripts/plot/draw/plotmatrix.m
+++ b/scripts/plot/draw/plotmatrix.m
@@ -109,29 +109,32 @@ endfunction
 
 
 %!demo
 %! clf;
 %! plotmatrix (randn (100, 3), 'g+');
 
 
 function plotmatrixdelete (h, d, ax)
+
   for i = 1 : numel (ax)
     hc = ax(i);
     if (isaxes (hc) && strcmpi (get (hc, "beingdeleted"), "off"))
       parent = get (hc, "parent");
       ## If the parent is invalid or being deleted, then do nothing
       if (ishandle (parent) && strcmpi (get (parent, "beingdeleted"), "off"))
         delete (hc);
       endif
     endif
   endfor
+
 endfunction
 
 function [h, ax, p, pax] = __plotmatrix__ (bigax, varargin)
+
   have_line_spec = false;
   have_hist = false;
   parent = get (bigax, "parent");
   narg = nargin ();
   for i = 1 : narg - 1
     arg = varargin{i};
     if (ischar (arg) || iscellstr (arg))
       [linespec, valid] = __pltopt__ ("plotmatrix", varargin{i}, false);
@@ -193,10 +196,11 @@ function [h, ax, p, pax] = __plotmatrix_
           tmp = plot (X (:, i), Y (:, j), linespec);
         else
           tmp = plot (X (:, i), Y (:, j), ".");
         endif
         h = [h ; tmp];
       endif
     endfor
   endfor
+
 endfunction
 
diff --git a/scripts/plot/draw/plotyy.m b/scripts/plot/draw/plotyy.m
--- a/scripts/plot/draw/plotyy.m
+++ b/scripts/plot/draw/plotyy.m
@@ -186,37 +186,40 @@ function [ax, h1, h2] = __plotyy__ (ax, 
   if (ishandle (ax(2)) && ! isprop (ax(2), "__plotyy_axes__"))
     addproperty ("__plotyy_axes__", ax(2), "data");
     set (ax(2), "__plotyy_axes__", ax);
   elseif (ishandle (ax(2)))
     set (ax(2), "__plotyy_axes__", ax);
   else
     error ("plotyy.m: This shouldn't happen.  File a bug report.");
   endif
+
 endfunction
 
 function deleteplotyy (h, ~, ax2, t2)
   if (isaxes (ax2)
       && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"), "off"))
       && strcmp (get (ax2, "beingdeleted"), "off"))
     set (t2, "deletefcn", []);
     delete (ax2);
   endif
 endfunction
 
 function update_nextplot (h, ~, ax2)
   persistent recursion = false;
+
   if (! recursion)
     unwind_protect
       recursion = true;
       set (ax2, "nextplot", get (h, "nextplot"));
     unwind_protect_cleanup
       recursion = false;
     end_unwind_protect
   endif
+
 endfunction
 
 function update_position (h, ~, ax2)
   persistent recursion = false;
 
   ## Don't allow recursion
   if (! recursion)
     unwind_protect
@@ -247,29 +250,32 @@ function update_position (h, ~, ax2)
              && isequal (plotboxaspectratiomode, oldplotboxaspectratiomode)))
         set (ax2, "plotboxaspectratio", plotboxaspectratio,
                   "plotboxaspectratiomode", plotboxaspectratiomode);
       endif
     unwind_protect_cleanup
       recursion = false;
     end_unwind_protect
   endif
+
 endfunction
 
 function color = getcolor (ax)
+
   obj = get (ax);
   if (isfield (obj, "color"))
     color = obj.color;
   elseif (isfield (obj, "facecolor") && ! ischar (obj.facecolor))
     color = obj.facecolor;
   elseif (isfield (obj, "edgecolor") && ! ischar (obj.edgecolor))
     color = obj.edgecolor;
   else
     color = [0, 0, 0];
   endif
+
 endfunction
 
 
 %!demo
 %! clf;
 %! x = 0:0.1:2*pi;
 %! y1 = sin (x);
 %! y2 = exp (x - 1);
diff --git a/scripts/plot/draw/polar.m b/scripts/plot/draw/polar.m
--- a/scripts/plot/draw/polar.m
+++ b/scripts/plot/draw/polar.m
@@ -153,30 +153,32 @@ function h = polar (varargin)
   endif
 
 endfunction
 
 function rtick = __calc_rtick__ (hax, maxr)
   ## FIXME: workaround: calculate r(ho)tick from xtick
   ##        It would be better to just calculate the values,
   ##        but that code is deep in the C++ for the plot engines.
-  savexlim = get (hax, "xlim");
-  saveylim = get (hax, "ylim");
+  saved_lims = get (hax, {"xlim", "ylim"});
   set (hax, "xlim", [-maxr maxr], "ylim", [-maxr maxr]);
+
   xtick = get (hax, "xtick");
   minidx = find (xtick > 0, 1);
   maxidx = find (xtick >= maxr, 1);
   if (! isempty (maxidx))
     rtick = xtick(minidx:maxidx);
   else
     ## Add one more tick through linear interpolation
     rtick = xtick(minidx:end);
     rtick(end+1) = xtick(end) + diff (xtick(end-1:end));
   endif
-  set (hax, "xlim", savexlim, "ylim", saveylim);
+
+  set (hax, {"xlim", "ylim"}, saved_lims);
+
 endfunction
 
 function retval = __plr1__ (h, theta, fmt)
 
   theta = theta(:);
   if (iscomplex (theta))
     rho = imag (theta);
     theta = real (theta);
@@ -189,16 +191,17 @@ function retval = __plr1__ (h, theta, fm
 
 endfunction
 
 function retval = __plr2__ (h, theta, rho, fmt)
 
   if (ndims (theta) > 2 || ndims (rho) > 2)
     error ("polar: THETA and RHO must be 2-D objects");
   endif
+
   theta = real (theta);
   rho = real (rho);
 
   if (isscalar (theta))
     if (isscalar (rho))
       x = rho * cos (theta);
       y = rho * sin (theta);
       retval = __plt__ ("polar", h, x, y, fmt);
@@ -305,16 +308,17 @@ function __update_layer__ (hax, ~, hg)
     if (strcmp (get (hax, "layer"), "bottom"))
       set (hax, "children", [kids(kids != hg); hg]);
     else
       set (hax, "children", [hg; kids(kids != hg)]);
     endif
   unwind_protect_cleanup
     set (0, "showhiddenhandles", shh);
   end_unwind_protect
+
 endfunction
 
 function __update_polar_grid__ (hax, ~, hg)
 
   ## Delete existing polar grid
   delete (get (hg, "children"));
 
   rtick = unique (get (hax, "rtick")(:)');
diff --git a/scripts/plot/draw/private/__bar__.m b/scripts/plot/draw/private/__bar__.m
--- a/scripts/plot/draw/private/__bar__.m
+++ b/scripts/plot/draw/private/__bar__.m
@@ -337,43 +337,47 @@ function hglist = bars (hax, vertical, x
   ## creation of plot when patch objects are added.
   addlistener (hax, "xlim", @update_xlim);
   addlistener (h_baseline, "ydata", @update_baseline);
   addlistener (h_baseline, "visible", @update_baseline);
 
 endfunction
 
 function update_xlim (h, ~)
+
   kids = get (h, "children");
   xlim = get (h, "xlim");
 
   for i = 1 : length (kids)
     obj = get (kids(i));
     if (strcmp (obj.type, "hggroup") && isfield (obj, "baseline"))
       if (any (get (obj.baseline, "xdata") != xlim))
         set (obj.baseline, "xdata", xlim);
       endif
     endif
   endfor
+
 endfunction
 
 function update_baseline (h, ~)
+
   visible = get (h, "visible");
   ydata = get (h, "ydata")(1);
 
   ## Search axis for a bargroup that contains this baseline handle
   kids = get (get (h, "parent"), "children");
   for i = 1 : length (kids)
     obj = get (kids(i));
     if (strcmp (obj.type, "hggroup") && isfield (obj, "baseline")
         && obj.baseline == h)
       set (obj.bargroup, "showbaseline", visible, "basevalue", ydata);
       break;
     endif
   endfor
+
 endfunction
 
 function show_baseline (h, ~, prop = "")
   persistent recursion = false;
 
   ## Don't allow recursion
   if (! recursion)
     unwind_protect
@@ -389,16 +393,17 @@ function show_baseline (h, ~, prop = "")
           showbaseline = "off";
         endif
       endif
       set (get (h, "baseline"), "visible", showbaseline);
     unwind_protect_cleanup
       recursion = false;
     end_unwind_protect
   endif
+
 endfunction
 
 function move_baseline (h, ~)
   persistent recursion = false;
 
   ## Don't allow recursion
   if (! recursion)
     recursion = true;
@@ -409,16 +414,17 @@ function move_baseline (h, ~)
 
       if (strcmp (get (h, "barlayout"), "grouped"))
         update_data (h);
       endif
     unwind_protect_cleanup
       recursion = false;
     end_unwind_protect
   endif
+
 endfunction
 
 function update_props (h, ~)
   kids = get (h, "children");
   set (kids, {"edgecolor", "linewidth", "linestyle", "facecolor"},
        get (h, {"edgecolor", "linewidth", "linestyle", "facecolor"}));
 endfunction
 
@@ -454,16 +460,17 @@ function update_data (h, ~)
         else
           set (hp, "xdata", yb(:,:,i), "ydata", xb(:,:,i));
         endif
       endfor
     unwind_protect_cleanup
       recursion = false;
     end_unwind_protect
   endif
+
 endfunction
 
 function update_group (h, ~)
   persistent recursion = false;
 
   ## Don't allow recursion
   if (! recursion)
     unwind_protect
@@ -476,10 +483,11 @@ function update_group (h, ~)
       hlist = hlist(hlist != h);  # remove current handle being updated
       set (hlist, "barwidth", barwidth, "barlayout", barlayout,
                   "horizontal", horizontal);
       update_data (h);
     unwind_protect_cleanup
       recursion = false;
     end_unwind_protect
   endif
+
 endfunction
 
diff --git a/scripts/plot/draw/private/__contour__.m b/scripts/plot/draw/private/__contour__.m
--- a/scripts/plot/draw/private/__contour__.m
+++ b/scripts/plot/draw/private/__contour__.m
@@ -17,16 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {[@var{c}, @var{hg}] =} __contour__ (@dots{})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function [c, hg] = __contour__ (varargin)
+
   ax = varargin{1};
   zlevel = varargin{2};
   filled = "off";
 
   linespec.color = "auto";
   linespec.linestyle = "-";
   opts = {};
   i = 3;
@@ -201,16 +202,17 @@ function [c, hg] = __contour__ (varargin
 
   if (! isempty (opts))
     set (hg, opts{:});
   endif
 
 endfunction
 
 function add_patch_children (hg)
+
   c = get (hg, "contourmatrix");
   lev = get (hg, "levellist");
   fill = get (hg, "fill");
   zlev = get (hg, "zlevel");
   zmode = get (hg, "zlevelmode");
   lc = get (hg, "linecolor");
   lw = get (hg, "linewidth");
   ls = get (hg, "linestyle");
@@ -374,16 +376,17 @@ function add_patch_children (hg)
     endwhile
   endif
 
   set (ca, "climmode", climmode);
 
 endfunction
 
 function update_zlevel (h, ~)
+
   z = get (h, "zlevel");
   zmode = get (h, "zlevelmode");
   kids = get (h, "children");
 
   switch (zmode)
     case "none"
       set (kids, "zdata", []);
     case "auto"
@@ -391,25 +394,28 @@ function update_zlevel (h, ~)
         set (kids(i), "zdata", get (kids(i), "cdata") .*
              ones (size (get (kids(i), "xdata"))));
       endfor
     otherwise
       for i = 1 : length (kids)
         set (kids(i), "zdata", z .* ones (size (get (kids(i), "xdata"))));
       endfor
   endswitch
+
 endfunction
 
 function update_line (h, ~)
+
   lc = get (h, "linecolor");
   if (strcmp (lc, "auto"))
     lc = "flat";
   endif
   set (findobj (h, "type", "patch"), "edgecolor", lc,
        "linewidth", get (h, "linewidth"), "linestyle", get (h, "linestyle"));
+
 endfunction
 
 function update_data (h, ~, prop = "")
   persistent recursive = false;
 
   if (! recursive)
     recursive = true;
 
@@ -535,26 +541,29 @@ function update_text (h, ~, prop = "")
         otherwise
           __clabel__ (get (h, "contourmatrix"), lvl, h,
                       get (h, "labelspacing"), []);
       endswitch
     endif
 
     recursive = false;
   endif
+
 endfunction
 
 function lvl_eps = get_lvl_eps (lev)
+
   ## FIXME: is this the right thing to do for this tolerance?  Should
   ## it be an absolute or relative tolerance, or switch from one to the
   ## other depending on the value of lev?
   if (isscalar (lev))
     lvl_eps = abs (lev) * sqrt (eps) + sqrt (eps);
   else
     tmp = min (abs (diff (lev)));
     if (tmp < 10*eps)
       lvl_eps = sqrt (eps);
     else
       lvl_eps = tmp / 1000.0;
     endif
   endif
+
 endfunction
 
diff --git a/scripts/plot/draw/private/__errplot__.m b/scripts/plot/draw/private/__errplot__.m
--- a/scripts/plot/draw/private/__errplot__.m
+++ b/scripts/plot/draw/private/__errplot__.m
@@ -278,16 +278,17 @@ function h = __do_errplot__ (fstr, hax, 
     legend (gca (), hlgnd, tlgnd);
   endif
 
 endfunction
 
 function [xdata, ydata] = errorbar_data (xdata, ydata, ldata, udata,
                                          xldata, xudata, ifmt,
                                          xscale, yscale)
+
   if (strcmp (xscale, "linear"))
     dx = 0.01 * (max (xdata(:)) - min (xdata(:)));
     if (dx == 0)
       dx = .1;
     endif
     xlo = xdata - dx;
     xhi = xdata + dx;
   else
@@ -312,16 +313,17 @@ function [xdata, ydata] = errorbar_data 
     if (! any (n))
       n = ydata < 0;
     endif
     logdata = log (abs (ydata(n)));
     ry = exp (0.01 * (max (logdata) - min (logdata)));
     ylo = ydata/ry;
     yhi = ydata*ry;
   endif
+
   nans = NaN + xdata(:);  # fast way to do NaN (size (xdata(:)))
   if (strcmp (ifmt, "yerr"))
     xdata = [xdata, xdata, nans, ...
              xlo, xhi, nans, ...
              xlo, xhi, nans];
     ydata = [ydata-ldata, ydata+udata, nans, ...
              ydata+udata, ydata+udata, nans, ...
              ydata-ldata, ydata-ldata, nans];
@@ -360,23 +362,25 @@ function [xdata, ydata] = errorbar_data 
   endif
 
   xdata = xdata.'(:);
   ydata = ydata.'(:);
 
 endfunction
 
 function update_props (hg, ~, hl)
+
   set (hl, "color", get (hg, "color"),
            "linewidth", get (hg, "linewidth"));
   set (hl(2), "linestyle", get (hg, "linestyle"),
               "marker", get (hg, "marker"),
               "markeredgecolor", get (hg, "markeredgecolor"),
               "markerfacecolor", get (hg, "markerfacecolor"),
               "markersize", get (hg, "markersize"));
+
 endfunction
 
 function update_data (hg, ~, hl)
 
   if (strcmp (get (hg, "type"), "axes"))
     hax = hg;
     hg = ancestor (hl(2), "hggroup");
   else
diff --git a/scripts/plot/draw/private/__interp_cube__.m b/scripts/plot/draw/private/__interp_cube__.m
--- a/scripts/plot/draw/private/__interp_cube__.m
+++ b/scripts/plot/draw/private/__interp_cube__.m
@@ -19,37 +19,40 @@
 ## Author: Martin Helm <martin@mhelm.de>
 
 ## -*- texinfo -*-
 ## @deftypefn {} {[@var{vxyz}, @var{idx}, @var{frac}] =} __interp_cube__ (@var{x}, @var{y}, @var{z}, @var{val}, @var{v})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function [Vxyz, idx, frac] = __interp_cube__ (x, y, z, val, v, req = "values" )
+
   if (isnumeric (x) && ndims (x) == 3 && isnumeric (y) && ndims (y) == 3
        && isnumeric (z) && ndims (z) == 3 && size_equal (x, y, z, val))
     x = squeeze (x(1,:,1))(:);
     y = squeeze (y(:,1,1))(:);
     z = squeeze (z(1,1,:))(:);
   elseif (isvector (x) && isvector (y) && isvector (z))
     x = x(:);
     y = y(:);
     z = z(:);
   else
     error ("__interp_cube__: X, Y, Z have wrong dimensions");
   endif
+
   if (size (val) != [length(x), length(y), length(z)])
     error ("__interp_cube__: VAL has wrong dimensions");
   endif
   if (columns (v) != 3)
     error ( "V has to be Nx3 matrix");
   endif
   ##if (! ischar (req))
-  ## error ('__interp_cube__: Invalid request parameter use "values", "normals" or "normals8"');
+  ##  error ('__interp_cube__: Invalid request parameter use "values", "normals" or "normals8"');
   ##endif
+
   if (isempty (v))
     Vxyz = idx = frac = [];
     return;
   endif
 
   switch (req)
     case "normals"
       [idx, frac] = cube_idx (x, y, z, v);
@@ -94,19 +97,21 @@ function [Vxyz, idx, frac] = __interp_cu
       dz = [dz;dz(end)](idx(:,3));
       [Dx, Dy, Dz, idx, frac] = interp_cube_trilin_grad (x, y, z, val, v);
       Vxyz = [Dx./dx, Dy./dy, Dz./dz];
     case "values"
       [Vxyz, idx, frac] = interp_cube_trilin (x, y, z, val, v);
    otherwise
      error ('__interp_cube__: Invalid request type "%s", use "values", "normals" or "normals8"', req);
   endswitch
+
 endfunction
 
 function [Vxyz, idx, frac] = interp_cube_trilin (x, y, z, val, v)
+
   [idx, frac] = cube_idx (x(:), y(:), z(:), v);
   sval = size (val);
   i000 = sub2ind (sval, idx(:, 1), idx(:, 2), idx(:, 3));
   i100 = sub2ind (sval, idx(:, 1)+1, idx(:, 2), idx(:, 3));
   i010 = sub2ind (sval, idx(:, 1), idx(:, 2)+1, idx(:, 3));
   i001 = sub2ind (sval, idx(:, 1), idx(:, 2), idx(:, 3)+1);
   i101 = sub2ind (sval, idx(:, 1)+1, idx(:, 2), idx(:, 3)+1);
   i011 = sub2ind (sval, idx(:, 1), idx(:, 2)+1, idx(:, 3)+1);
@@ -119,19 +124,21 @@ function [Vxyz, idx, frac] = interp_cube
     val( i000 ) .* (1 .- Bx) .* (1 .- By) .* (1 .- Bz) .+ ...
     val( i100 ) .* Bx .* (1 .- By) .* (1 .- Bz) .+ ...
     val( i010 ) .* (1 .- Bx) .* By .* (1 .- Bz) .+ ...
     val( i001 ) .* (1 .- Bx) .* (1 .- By) .* Bz .+ ...
     val( i011 ) .* (1 .- Bx) .* By .* Bz .+ ...
     val( i101 ) .* Bx .* (1 .- By) .* Bz .+ ...
     val( i110 ) .* Bx .* By .* (1 .- Bz) .+ ...
     val( i111 ) .* Bx .* By .* Bz;
+
 endfunction
 
 function [Dx, Dy, Dz, idx, frac] = interp_cube_trilin_grad (x, y, z, val, v)
+
   [idx, frac] = cube_idx (x(:), y(:), z(:), v);
   sval = size (val);
   i000 = sub2ind (sval, idx(:, 1), idx(:, 2), idx(:, 3));
   i100 = sub2ind (sval, idx(:, 1)+1, idx(:, 2), idx(:, 3));
   i010 = sub2ind (sval, idx(:, 1), idx(:, 2)+1, idx(:, 3));
   i001 = sub2ind (sval, idx(:, 1), idx(:, 2), idx(:, 3)+1);
   i101 = sub2ind (sval, idx(:, 1)+1, idx(:, 2), idx(:, 3)+1);
   i011 = sub2ind (sval, idx(:, 1), idx(:, 2)+1, idx(:, 3)+1);
@@ -162,24 +169,27 @@ function [Dx, Dy, Dz, idx, frac] = inter
     val( i000 ) .* (1 .- Bx) .* (1 .- By) .* -1 .+ ...
     val( i100 ) .* Bx .* (1 .- By) .* -1 .+ ...
     val( i010 ) .* (1 .- Bx) .* By .* -1 .+ ...
     val( i001 ) .* (1 .- Bx) .* (1 .- By) .+ ...
     val( i011 ) .* (1 .- Bx) .* By + ...
     val( i101 ) .* Bx .* (1 .- By) .+ ...
     val( i110 ) .* Bx .* By .* -1 .+ ...
     val( i111 ) .* Bx .* By;
+
 endfunction
 
 function [idx, frac] = cube_idx (x, y, z, v)
+
   idx = zeros (size (v));
   frac = zeros (size (v));
   idx(:, 2) = lookup (x(2:end-1), v(:, 1)) + 1;
   frac(:, 2) = (v(:, 1) - x(idx(:, 2)) )...
       ./ (x(idx(:, 2)+1) - x(idx(:, 2)));
   idx(:, 1) = lookup (y(2:end-1), v(:, 2)) + 1;
   frac(:, 1) = (v(:, 2) - y(idx(:, 1))) ...
       ./ (y(idx(:, 1)+1) - y(idx(:, 1)));
   idx(:, 3) = lookup (z(2:end-1), v(:, 3)) + 1;
   frac(:, 3) = (v(:, 3) - z(idx(:, 3))) ...
       ./ (z(idx(:, 3)+1) - z(idx(:, 3)));
+
 endfunction
 
diff --git a/scripts/plot/draw/private/__marching_cube__.m b/scripts/plot/draw/private/__marching_cube__.m
--- a/scripts/plot/draw/private/__marching_cube__.m
+++ b/scripts/plot/draw/private/__marching_cube__.m
@@ -199,49 +199,54 @@ function [T, p, col] = __marching_cube__
     idp = pp(:, lindex, jj) > 0;
     if (any (idp))
       p(pp(idp, lindex, jj), 1:3) = pp(idp, 1:3, jj);
       if (calc_cols)
         col(pp(idp, lindex, jj),1) = pp(idp, 4, jj);
       endif
     endif
   endfor
+
 endfunction
 
-function p = vertex_interp (isolevel,p1x, p1y, p1z,...
-  p2x, p2y, p2z,valp1,valp2, col1, col2)
+function p = vertex_interp (isolevel, p1x, p1y, p1z, ...
+                            p2x, p2y, p2z,valp1,valp2, col1, col2)
 
   if (nargin == 9)
     p = zeros (length (p1x), 3);
   elseif (nargin == 11)
     p = zeros (length (p1x), 4);
   else
     error ("__marching_cube__: wrong number of arguments");
   endif
-  mu = zeros (length (p1x), 1);
+
   id = abs (valp1-valp2) < (10*eps) .* (abs (valp1) .+ abs (valp2));
   if (any (id))
     p(id, 1:3) = [ p1x(id), p1y(id), p1z(id) ];
     if (nargin == 11)
       p(id, 4) = col1(id);
     endif
   endif
+
+  mu = zeros (length (p1x), 1);
   nid = ! id;
   if (any (nid))
     mu(nid) = (isolevel - valp1(nid)) ./ (valp2(nid) - valp1(nid));
     p(nid, 1:3) = [p1x(nid) + mu(nid) .* (p2x(nid) - p1x(nid)), ...
       p1y(nid) + mu(nid) .* (p2y(nid) - p1y(nid)), ...
       p1z(nid) + mu(nid) .* (p2z(nid) - p1z(nid))];
     if (nargin == 11)
       p(nid, 4) = col1(nid) + mu(nid) .* (col2(nid) - col1(nid));
     endif
   endif
+
 endfunction
 
 function [edge_table, tri_table] = init_mc ()
+
   edge_table = [
   0x0  , 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, ...
   0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00, ...
   0x190, 0x99 , 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, ...
   0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90, ...
   0x230, 0x339, 0x33 , 0x13a, 0x636, 0x73f, 0x435, 0x53c, ...
   0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30, ...
   0x3a0, 0x2a9, 0x1a3, 0xaa , 0x7a6, 0x6af, 0x5a5, 0x4ac, ...
@@ -523,10 +528,11 @@ function [edge_table, tri_table] = init_
   2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1;
   9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1;
   2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1;
   1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1;
   1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1;
   0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1;
   0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1;
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 ] + 1;
+
 endfunction
 
diff --git a/scripts/plot/draw/private/__patch__.m b/scripts/plot/draw/private/__patch__.m
--- a/scripts/plot/draw/private/__patch__.m
+++ b/scripts/plot/draw/private/__patch__.m
@@ -176,9 +176,11 @@ function [h, failed] = __patch__ (p, var
     endif
   else
     args = varargin;
   endif
 
   if (! failed)
     h = __go_patch__ (p, args{:});
   endif
+
 endfunction
+
diff --git a/scripts/plot/draw/private/__pie__.m b/scripts/plot/draw/private/__pie__.m
--- a/scripts/plot/draw/private/__pie__.m
+++ b/scripts/plot/draw/private/__pie__.m
@@ -146,16 +146,17 @@ function hlist = __pie__ (caller, vararg
   addlistener (gca, "view", {@update_text_pos, hlist});
 
   if (strcmp (caller, "pie3"))
     axis ([-1.25, 1.25, -1.25, 1.25, -0.05, 0.4], "equal", "off");
     view (-37.5, 30);
   elseif (strcmp (caller, "pie"))
     axis ([-1.5, 1.5, -1.5, 1.5], "square", "off");
   endif
+
 endfunction
 
 function update_text_pos (all_handles)
   ## Text objects in the foreground should be at the base level.
   ## Text objects in the background should be at the top level.
   ## Text objects on the right side should be aligned to the right
   ## and on the left side to the left.
   tobj = findobj (all_handles, "type", "text");
@@ -192,10 +193,11 @@ function update_text_pos (all_handles)
 
       if (lr_mask(i))
         set (tobj(i), "horizontalalignment", "right");
       else
         set (tobj(i), "horizontalalignment", "left");
       endif
     endfor
   endif
+
 endfunction
 
diff --git a/scripts/plot/draw/private/__plt__.m b/scripts/plot/draw/private/__plt__.m
--- a/scripts/plot/draw/private/__plt__.m
+++ b/scripts/plot/draw/private/__plt__.m
@@ -152,30 +152,32 @@ function retval = __plt__ (caller, h, va
       legend (gca (), hlgnd, tlgnd);
     endif
   else
     error ("__plt__: invalid number of arguments");
   endif
 
 endfunction
 
-function [hlgnd, tlgnd, setlgnd] = __plt_key__ (h, options, hlgnd, tlgnd, setlgnd)
+function [hlgnd, tlgnd, setlgnd] = __plt_key__ (h, options,
+                                                hlgnd, tlgnd, setlgnd)
   n = numel (h);
   if (numel (options) == 1)
     options = repmat (options(:), n, 1);
   endif
 
   for i = 1 : n
     key = options(i).key;
     if (! isempty (key))
       hlgnd = [hlgnd(:); h(i)];
       tlgnd = {tlgnd{:}, key};
       setlgnd = true;
     endif
   endfor
+
 endfunction
 
 function retval = __plt1__ (h, x1, options, properties = {})
 
   if (nargin < 3 || isempty (options))
     options = __default_plot_options__ ();
   endif
 
diff --git a/scripts/plot/draw/private/__quiver__.m b/scripts/plot/draw/private/__quiver__.m
--- a/scripts/plot/draw/private/__quiver__.m
+++ b/scripts/plot/draw/private/__quiver__.m
@@ -406,17 +406,19 @@ function update_data (h, ~)
   set (kids(1), "ydata", y);
   if (is3d)
     set (kids(1), "zdata", z);
   endif
 
 endfunction
 
 function update_props (h, ~)
+
   kids = get (h, "children");
 
   set (kids([3 2]), {"color", "linestyle", "linewidth"},
             get (h, {"color", "linestyle", "linewidth"}));
   set (kids(2), "visible", get (h, "showarrowhead"));
   set (kids(1), {"color", "marker", "markerfacecolor", "markersize"},
         get (h, {"color", "marker", "markerfacecolor", "markersize"}));
+
 endfunction
 
diff --git a/scripts/plot/draw/private/__scatter__.m b/scripts/plot/draw/private/__scatter__.m
--- a/scripts/plot/draw/private/__scatter__.m
+++ b/scripts/plot/draw/private/__scatter__.m
@@ -279,16 +279,17 @@ function hg = __scatter__ (varargin)
 
   if (! isempty (newargs))
     set (hg, newargs{:});
   endif
 
 endfunction
 
 function render_size_color (hg, vert, s, c, marker, filled, isflat)
+
   if (isscalar (s))
     x = vert(:,1);
     y = vert(:,2);
     z = vert(:,3:end);
     toolkit = get (ancestor (hg, "figure"), "__graphics_toolkit__");
     ## Does gnuplot only support triangles with different vertex colors ?
     ## FIXME: Verify gnuplot can only support one color.  If RGB triplets
     ##        can be assigned to each vertex, then fix __gnuplot_draw_axes__.m
@@ -337,31 +338,35 @@ function render_size_color (hg, vert, s,
     ## Round size to one decimal place.
     [ss, ~, s_to_ss] = unique (ceil (s*10) / 10);
     for i = 1:rows (ss)
       idx = (i == s_to_ss);
       render_size_color (hg, vert(idx,:), ss(i), c,
                              marker, filled, isflat);
     endfor
   endif
+
 endfunction
 
 function update_props (h, d)
+
   lw = get (h, "linewidth");
   m  = get (h, "marker");
   fc = get (h, "markerfacecolor");
   ec = get (h, "markeredgecolor");
   kids = get (h, "children");
 
   set (kids, "linewidth", lw, "marker", m,
              "markerfacecolor", fc, "markeredgecolor", ec);
+
 endfunction
 
 ## FIXME: This callback routine doesn't handle the case where N > 100.
 function update_data (h, d)
+
   x = get (h, "xdata");
   y = get (h, "ydata");
   z = get (h, "zdata");
   if (numel (x) > 100)
     error ("scatter: cannot update data with more than 100 points.  Call scatter (x, y, ...) with new data instead.");
   endif
   c = get (h, "cdata");
   one_explicit_color = ischar (c) || isequal (size (c), [1, 3]);
diff --git a/scripts/plot/draw/private/__stem__.m b/scripts/plot/draw/private/__stem__.m
--- a/scripts/plot/draw/private/__stem__.m
+++ b/scripts/plot/draw/private/__stem__.m
@@ -345,30 +345,33 @@ endfunction
 function [lc, ls, mc, ms] = set_default_values ()
   mc = [];
   lc = [];
   ls = "-";
   ms = "o";
 endfunction
 
 function update_xlim (h, ~)
+
   kids = get (h, "children");
   xlim = get (h, "xlim");
 
   for i = 1 : length (kids)
     obj = get (kids(i));
     if (strcmp (obj.type, "hggroup") && isfield (obj, "baseline"))
       if (any (get (obj.baseline, "xdata") != xlim))
         set (obj.baseline, "xdata", xlim);
       endif
     endif
   endfor
+
 endfunction
 
 function update_baseline (h, ~, src)
+
   visible = get (h, "visible");
   if (src == 0)
     basevalue = get (h, "basevalue");
   else
     basevalue = get (h, "ydata")(1);
   endif
 
   kids = get (get (h, "parent"), "children");
@@ -380,56 +383,64 @@ function update_baseline (h, ~, src)
       if (! strcmp (get (kids(i), "showbaseline"), visible))
         set (kids(i), "showbaseline", visible);
       endif
       if (get (kids(i), "basevalue") != basevalue)
         set (kids(i), "basevalue", basevalue);
       endif
     endif
   endfor
+
 endfunction
 
 function show_baseline (h, ~, hg = [])
+
   if (isempty (hg))
     set (get (h, "baseline"), "visible", get (h, "showbaseline"));
   else
     if (all (strcmp (get (hg, "visible"), "off")))
       set (get (h, "baseline"), "visible", "off");
     else
       set (get (h, "baseline"), "visible", "on");
     endif
   endif
+
 endfunction
 
 function move_baseline (h, ~)
+
   b0 = get (h, "basevalue");
   bl = get (h, "baseline");
 
   set (bl, "ydata", [b0, b0]);
   set (bl, "basevalue", b0);
 
   kids = get (h, "children");
   yt = get (h, "ydata")(:)';
   ny = length (yt);
   yt = [b0 * ones(1, ny); yt; NaN(1, ny)](:);
   set (kids(2), "ydata", yt);
+
 endfunction
 
 function update_props (h, ~)
+
   kids = get (h, "children");
   set (kids(2), "color", get (h, "color"),
                 "linestyle", get (h, "linestyle"),
                 "linewidth", get (h, "linewidth"));
   set (kids(1), "color", get (h, "markeredgecolor"),
                 "marker", get (h, "marker"),
                 "markerfacecolor", get (h, "markerfacecolor"),
                 "markersize", get (h, "markersize"));
+
 endfunction
 
 function update_data (h, ~)
+
   x = get (h, "xdata");
   y = get (h, "ydata");
   z = get (h, "zdata");
 
   if (! isempty (z) && size_equal (x, y, z))
     sz = min ([size(x); size(y); size(z)]);
     x = x(1:sz(1),1:sz(2));
     y = y(1:sz(1),1:sz(2));
@@ -452,10 +463,11 @@ function update_data (h, ~)
     y = y(:)';
     yt = [bl * ones(1, nx); y; NaN(1, nx)](:);
     zt = [];
   endif
 
   kids = get (h, "children");
   set (kids(2), "xdata", xt, "ydata", yt, "zdata", zt);
   set (kids(1), "xdata", x, "ydata", y, "zdata", z);
+
 endfunction
 
diff --git a/scripts/plot/draw/rectangle.m b/scripts/plot/draw/rectangle.m
--- a/scripts/plot/draw/rectangle.m
+++ b/scripts/plot/draw/rectangle.m
@@ -75,16 +75,17 @@ function h = rectangle (varargin)
     if (! isempty (oldfig))
       set (0, "currentfigure", oldfig);
     endif
   end_unwind_protect
 
   if (nargout > 0)
     h = htmp;
   endif
+
 endfunction
 
 function hg = __rectangle__ (hax, varargin)
 
   iarg = 1;
   pos = [0, 0, 1, 1];
   curv2 = [0, 0];
   ec = [0, 0, 0];
@@ -170,16 +171,17 @@ function hg = __rectangle__ (hax, vararg
   addproperty ("facecolor", hg, "patchfacecolor", get (h, "facecolor"));
 
   addlistener (hg, "curvature", @update_data);
   addlistener (hg, "position",  @update_data);
   addlistener (hg, "edgecolor", @update_props);
   addlistener (hg, "linewidth", @update_props);
   addlistener (hg, "linestyle", @update_props);
   addlistener (hg, "facecolor", @update_props);
+
 endfunction
 
 function update_data (h, ~)
   persistent recursion = false;
 
   ## Don't allow recursion
   if (! recursion)
     unwind_protect
@@ -216,23 +218,23 @@ function update_data (h, ~)
              pos(2) + pos(4) + cy, pos(2) + c(2)];
       endif
 
       set (kids, "xdata", x, "ydata", y);
     unwind_protect_cleanup
       recursion = false;
     end_unwind_protect
   endif
+
 endfunction
 
 function update_props (h, ~)
   kids = get (h, "children");
   set (kids, {"edgecolor", "linewidth", "linestyle", "facecolor"},
      get (h, {"edgecolor", "linewidth", "linestyle", "facecolor"}));
-
 endfunction
 
 
 %!demo
 %! clf;
 %! axis equal;
 %! rectangle ('Position', [0.05, 0.05, 0.9, 0.9], 'Curvature', [0.5, 0.5]);
 %! title ('rectangle() with corners curved');
diff --git a/scripts/plot/draw/stairs.m b/scripts/plot/draw/stairs.m
--- a/scripts/plot/draw/stairs.m
+++ b/scripts/plot/draw/stairs.m
@@ -240,16 +240,17 @@ function update_props (h, ~)
   set (get (h, "children"),
        {"color", "linestyle", "linewidth", "marker", ...
         "markeredgecolor", "markerfacecolor", "markersize"},
        get (h, {"color", "linestyle", "linewidth", "marker", ...
                 "markeredgecolor", "markerfacecolor", "markersize"}));
 endfunction
 
 function update_data (h, ~)
+
   x = get (h, "xdata");
   y = get (h, "ydata");
 
   sz = min ([size(x); size(y)]);
   x = x(1:sz(1), 1:sz(2));
   y = y(1:sz(1), 1:sz(2));
 
   nr = length (x);
@@ -264,16 +265,17 @@ function update_data (h, ~)
   xs(ridx) = xtmp;
   ys(ridx) = y(1:nr-1);
 
   ridx = 3:2:len;
   xs(ridx) = xtmp;
   ys(ridx) = y(2:nr);
 
   set (get (h, "children"), "xdata", xs, "ydata", ys);
+
 endfunction
 
 
 %!demo
 %! clf;
 %! rand_1x10_data1 = [0.073, 0.455, 0.837, 0.124, 0.426, 0.781, 0.004, 0.024, 0.519, 0.698];
 %! y = rand_1x10_data1;
 %! stairs (y);
diff --git a/scripts/plot/util/__actual_axis_position__.m b/scripts/plot/util/__actual_axis_position__.m
--- a/scripts/plot/util/__actual_axis_position__.m
+++ b/scripts/plot/util/__actual_axis_position__.m
@@ -77,13 +77,14 @@ function pos = __actual_axis_position__ 
     endif
     pos = pos_in_pixels ./ fig_position([3, 4, 3, 4]);
   elseif (strcmp (get (axis_obj.parent, "__graphics_toolkit__"), "gnuplot")
           && strcmp (axis_obj.activepositionproperty, "outerposition"))
     pos = axis_obj.outerposition;
   else
     pos = axis_obj.position;
   endif
+
 endfunction
 
 
 ## No test coverage for internal function.  It is tested through calling fcn.
 %!assert (1)
diff --git a/scripts/plot/util/__gnuplot_drawnow__.m b/scripts/plot/util/__gnuplot_drawnow__.m
--- a/scripts/plot/util/__gnuplot_drawnow__.m
+++ b/scripts/plot/util/__gnuplot_drawnow__.m
@@ -346,31 +346,33 @@ function enhanced = gnuplot_set_term (pl
     ## gnuplot will pick up the GNUTERM environment variable itself
     ## so no need to set the terminal type if not also setting the
     ## figure title, enhanced mode, or position.
   endif
 
 endfunction
 
 function term = gnuplot_default_term (plot_stream)
+
   term = lower (getenv ("GNUTERM"));
   ## If not specified, guess the terminal type.
   if (isempty (term) || ! __gnuplot_has_terminal__ (term, plot_stream))
     if (isguirunning () && __gnuplot_has_terminal__ ("qt", plot_stream))
       term = "qt";
     elseif (ismac ())
       term = "aqua";
     elseif (! isunix ())
       term = "windows";
     elseif (! isempty (getenv ("DISPLAY")))
       term = "x11";
     else
       term = "dumb";
     endif
   endif
+
 endfunction
 
 function [term, opts] = gnuplot_trim_term (string)
   ## Extract the terminal type and terminal options (from print.m)
   string = strtrim (string);
   [term, opts] = strtok (string, ' ');
   if (! isempty (opts))
     opts(1) = "";  # trim extra space from strtok
@@ -393,25 +395,28 @@ function have_enhanced = gnuplot_is_enha
 endfunction
 
 function ret = output_to_screen (term)
   ret = any (strcmpi (term,
                      {"aqua", "dumb", "pm", "qt", "windows", "wxt", "x11"}));
 endfunction
 
 function retval = have_non_legend_axes (h)
+
   retval = false;
+
   all_axes = findall (h, "type", "axes");
   if (! isempty (all_axes))
     n_all_axes = numel (all_axes);
     all_axes_tags = get (all_axes, "tag");
     legend_axes = strcmp (all_axes_tags, "legend");
     if (! isempty (legend_axes))
       n_legend_axes = sum (legend_axes);
       retval = (n_all_axes - n_legend_axes) > 1;
     endif
   endif
+
 endfunction
 
 
 ## No test needed for internal helper function.
 %!assert (1)
 
diff --git a/scripts/plot/util/axes.m b/scripts/plot/util/axes.m
--- a/scripts/plot/util/axes.m
+++ b/scripts/plot/util/axes.m
@@ -91,19 +91,22 @@ function h = axes (varargin)
 
   if (nargout > 0)
     h = htmp;
   endif
 
 endfunction
 
 function restack_axes (h, cf)
+
   show = get (0, "showhiddenhandles");
   set (0, "showhiddenhandles", "on");
   unwind_protect
     ch = get (cf, "children");
     hax = ch(isaxes (ch));
     ch(isaxes (ch)) = [h; hax(hax != h)];
     set (cf, "children", ch);
   unwind_protect_cleanup
     set (0, "showhiddenhandles", show);
   end_unwind_protect
+
 endfunction
+
diff --git a/scripts/plot/util/findobj.m b/scripts/plot/util/findobj.m
--- a/scripts/plot/util/findobj.m
+++ b/scripts/plot/util/findobj.m
@@ -279,16 +279,17 @@ function h = findobj (varargin)
       endfor
     endif
   else
     match = true (numel (h), 1);
   endif
 
   h = h(match);
   h = h(:);
+
 endfunction
 
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   h = findobj (gca (), "-property", "foo");
 %!   assert (isempty (h));
diff --git a/scripts/plot/util/ginput.m b/scripts/plot/util/ginput.m
--- a/scripts/plot/util/ginput.m
+++ b/scripts/plot/util/ginput.m
@@ -131,26 +131,28 @@ function [x, y, n, button] = ginput_accu
 endfunction
 
 function ginput_windowbuttondownfcn (~, button)
   point = get (gca (), "currentpoint");
   ginput_accumulator (1, point(1,1), point(1,2), button);
 endfunction
 
 function ginput_keypressfcn (~, evt)
+
   point = get (gca (), "currentpoint");
   if (strcmp (evt.Key, "return"))
     ## Enter key stops ginput.
     ginput_accumulator (2, NaN, NaN, NaN);
   else
     character = evt.Character;
     if (! isempty (character))
       ginput_accumulator (1, point(1,1), point(1,2), uint8 (character(1)));
     endif
   endif
+
 endfunction
 
 function ginput_closerequestfcn (hfig, ~, orig_closerequestfcn)
   ginput_accumulator (2, NaN, NaN, NaN);  # Stop ginput
   feval (orig_closerequestfcn);           # Close window with original fcn
 endfunction
 
 
diff --git a/scripts/plot/util/hdl2struct.m b/scripts/plot/util/hdl2struct.m
--- a/scripts/plot/util/hdl2struct.m
+++ b/scripts/plot/util/hdl2struct.m
@@ -112,34 +112,34 @@ function s = hdl2struct (h)
     endif
   endif
 
   set (0, "showhiddenhandles", hiddenh);
 
 endfunction
 
 function hdlist = getspecial (h)
-  obj = get (h);
+
   ## return handles to special children
-  fields = fieldnames (obj);
   hdlist = [];
 
-  regkids = get ( h, "children");
+  regkids = get (h, "children");
   set (0, "showhiddenhandles", "on");
-  allkids = get ( h, "children");
+  allkids = get (h, "children");
   set (0, "showhiddenhandles", "off");
   speckids = arrayfun (@(x) ! any (x == regkids), allkids);
   hdlist = allkids (find (speckids));
   hdlist = reshape (hdlist, 1, numel (hdlist));
 
 endfunction
 
 function prpstr = getprops (h)
+
   obj = get (h);
-  ## get usefull properties rejecting readonly, children, handles ...
+  ## get useful properties rejecting readonly, children, handles ...
   fields = fieldnames (obj);
   hdlist = [];
 
   forbid = {"beingdeleted", "busyaction", "buttondownfcn", ...
             "children", "clipping", "createfcn", ...
             "deletefcn", "handlevisibility", "hittest", ...
             "interruptible", "parent", "selected" ,...
             "selectionhighlight", "type", "__modified__", ...
diff --git a/scripts/plot/util/im2frame.m b/scripts/plot/util/im2frame.m
--- a/scripts/plot/util/im2frame.m
+++ b/scripts/plot/util/im2frame.m
@@ -59,16 +59,17 @@ function [frame] = im2frame (x, map = []
   endif
 
   ## support N dimensional images and return a struct array
   if (ndims (x) == 4)
     x = reshape (num2cell (x, [1 2 3]), 1, size (x, 4));
   endif
 
   frame = struct ("cdata", x, "colormap", map);
+
 endfunction
 
 
 %!function f = make_rgb_f ()
 %! f = randi ([0 255], 10, 20, 3);
 %!endfunction
 
 %!function f = make_ind_f ()
diff --git a/scripts/plot/util/ishghandle.m b/scripts/plot/util/ishghandle.m
--- a/scripts/plot/util/ishghandle.m
+++ b/scripts/plot/util/ishghandle.m
@@ -21,18 +21,18 @@
 ## Return true if @var{h} is a graphics handle and false otherwise.
 ##
 ## This function is equivalent to @code{ishandle} and is provided for
 ## compatibility with @sc{matlab}.
 ## @seealso{ishandle}
 ## @end deftypefn
 
 function retval = ishghandle (h)
-  ## This function is just included for compatibility as Octave has
-  ## no simulink equivalent.
+  ## This function is just included for compatibility as
+  ## Octave has no simulink equivalent.
   retval = ishandle (h);
 endfunction
 
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   assert (ishghandle (hf));
diff --git a/scripts/plot/util/isprop.m b/scripts/plot/util/isprop.m
--- a/scripts/plot/util/isprop.m
+++ b/scripts/plot/util/isprop.m
@@ -44,16 +44,17 @@ function res = isprop (h, prop)
 
   res = false (size (h));
   for i = 1:numel (res)
     try
       v = get (h(i), prop);
       res(i) = true;
     end_try_catch
   endfor
+
 endfunction
 
 
 %!assert (isprop (0, "foobar"), false)
 %!assert (isprop (0, "screenpixelsperinch"), true)
 %!assert (isprop (zeros (2, 3), "visible"), true (2, 3))
 
 %!error isprop ()
diff --git a/scripts/plot/util/linkprop.m b/scripts/plot/util/linkprop.m
--- a/scripts/plot/util/linkprop.m
+++ b/scripts/plot/util/linkprop.m
@@ -97,16 +97,17 @@ function update_prop (h, ~, hlist, prop)
   if (! recursion)
     unwind_protect
       recursion = true;
       set (hlist(ishandle (hlist)), prop, get (h, prop));
     unwind_protect_cleanup
       recursion = false;
     end_unwind_protect
   endif
+
 endfunction
 
 function delete_linkprop (hlist, prop)
 
   for i = 1 : numel (hlist)
     if (ishandle (hlist(i)))
       for j = 1 : numel (prop)
         dellistener (hlist(i), prop{j});
diff --git a/scripts/plot/util/pan.m b/scripts/plot/util/pan.m
--- a/scripts/plot/util/pan.m
+++ b/scripts/plot/util/pan.m
@@ -101,19 +101,21 @@ function pan (varargin)
     else
       error ("pan: wrong type argument '%s'", class (arg));
     endif
   endif
 
 endfunction
 
 function update_mouse_mode (hfig, arg)
+
   if (strcmp (arg, "off"))
     set (hfig, "__mouse_mode__", "none");
   else
-    ## FIXME: Is there a better way other than calling these
-    ## functions to set the other mouse mode Enable fields to
-    ## "off"?
+    ## FIXME: Is there a better way other than calling these functions
+    ##        to set the other mouse mode Enable fields to "off"?
     rotate3d ("off");
     zoom ("off");
     set (hfig, "__mouse_mode__", "pan");
   endif
+
 endfunction
+
diff --git a/scripts/plot/util/print.m b/scripts/plot/util/print.m
--- a/scripts/plot/util/print.m
+++ b/scripts/plot/util/print.m
@@ -683,126 +683,142 @@ function cmd = epstool (opts, filein, fi
       else
         cmd = sprintf (" cp %s %s ", filein, fileout);
       endif
     endif
   endif
   if (opts.debug)
     fprintf ("epstool command: '%s'\n", cmd);
   endif
+
 endfunction
 
 function cmd = fig2dev (opts, devopt)
+
   if (nargin < 2)
     devopt = opts.devopt;
   endif
+
   dos_shell = (ispc () && ! isunix ());
   if (! isempty (opts.fig2dev_binary))
     if (dos_shell)
       ## FIXME: Is this the right thing to do for DOS?
       cmd = sprintf ("%s -L %s 2> NUL", opts.fig2dev_binary, devopt);
     else
       cmd = sprintf ("%s -L %s 2> /dev/null", opts.fig2dev_binary, devopt);
     endif
   elseif (isempty (opts.fig2dev_binary))
     error ("print:nofig2dev", "print.m: 'fig2dev' not found in PATH");
   endif
   if (opts.debug)
     fprintf ("fig2dev command: '%s'\n", cmd);
   endif
+
 endfunction
 
 function latex_standalone (opts)
+
   n = find (opts.name == ".", 1, "last");
   if (! isempty (n))
     opts.name = opts.name(1:n-1);
   endif
   latexfile = [opts.name ".tex"];
+
   switch (opts.devopt)
     case {"pdflatexstandalone"}
       packages = "\\usepackage{graphicx,color}";
       graphicsfile = [opts.name "-inc.pdf"];
     case {"pslatexstandalone"}
       packages = "\\usepackage{epsfig,color}";
       graphicsfile = [opts.name "-inc.ps"];
     otherwise
       packages = "\\usepackage{epsfig,color}";
       graphicsfile = [opts.name "-inc.eps"];
   endswitch
+
   papersize = sprintf ("\\usepackage[papersize={%.2fbp,%.2fbp},text={%.2fbp,%.2fbp}]{geometry}",
                        fix (opts.canvas_size), fix (opts.canvas_size));
   prepend = {"\\documentclass{minimal}";
              packages;
              papersize;
              "\\begin{document}";
              "\\centering"};
   postpend = {"\\end{document}"};
+
   fid = fopen (latexfile, "r");
   if (fid >= 0)
     latex = fscanf (fid, "%c", Inf);
     status = fclose (fid);
     if (status != 0)
       error ("print:errorclosingfile",
              "print.m: error closing file '%s'", latexfile);
     endif
     ## FIXME: should this be fixed in GL2PS?
     latex = strrep (latex, "\\includegraphics{}",
                     sprintf ("\\includegraphics{%s}", graphicsfile));
   else
     error ("print:erroropeningfile",
            "print.m: error opening file '%s'", latexfile);
   endif
+
   fid = fopen (latexfile, "w");
   if (fid >= 0)
     fprintf (fid, "%s\n", prepend{:});
     fprintf (fid, "%s", latex);
     fprintf (fid, "%s\n", postpend{:});
     status = fclose (fid);
     if (status != 0)
       error ("print:errorclosingfile",
              "print.m: error closing file '%s'", latexfile);
     endif
   else
     error ("print:erroropeningfile",
            "print.m: error opening file '%s'", latexfile);
   endif
+
 endfunction
 
 function cmd = lpr (opts)
+
   if (nargin < 2)
     devopt = opts.devopt;
   endif
+
   if (! isempty (opts.lpr_binary))
     cmd = opts.lpr_binary;
     if (! isempty (opts.lpr_options))
       cmd = sprintf ("%s %s", cmd, opts.lpr_options);
     endif
     if (! isempty (opts.printer))
       cmd = sprintf ("%s %s", cmd, opts.printer);
     endif
   elseif (isempty (opts.lpr_binary))
     error ("print:nolpr", "print.m: 'lpr' not found in PATH");
   endif
   if (opts.debug)
     fprintf ("lpr command: '%s'\n", cmd);
   endif
+
 endfunction
 
 function cmd = pstoedit (opts, devopt)
+
   if (nargin < 2)
     devopt = opts.devopt;
   endif
+
   dos_shell = (ispc () && ! isunix ());
   if (! isempty (opts.pstoedit_binary))
     if (dos_shell)
       cmd = sprintf ("%s -f %s 2> NUL", opts.pstoedit_binary, devopt);
     else
       ## FIXME: Is this the right thing to do for DOS?
       cmd = sprintf ("%s -f %s 2> /dev/null", opts.pstoedit_binary, devopt);
     endif
   elseif (isempty (opts.pstoedit_binary))
     error ("print:nopstoedit", "print.m: 'pstoedit' not found in PATH");
   endif
   if (opts.debug)
     fprintf ("pstoedit command: '%s'\n", cmd);
   endif
+
 endfunction
 
diff --git a/scripts/plot/util/printd.m b/scripts/plot/util/printd.m
--- a/scripts/plot/util/printd.m
+++ b/scripts/plot/util/printd.m
@@ -75,16 +75,17 @@ function pr_out = printd (obj, filename)
       fclose (pf);
       delete (tempf);
       error ("printd: unknown conversion type: %s.\nOptions are: pdf ps eps txt jpg jpeg", opt);
 
   endswitch
   fclose (pf);
   delete (tempf);
   pr_out = sprintf ("%s file %s written\n", opt, filename);
+
 endfunction
 
 
 %!demo
 %! r2 = char ( ...
 %! 'stem step: 10, data: unsorted.', ...
 %! 'Hinges:    lo: 12, hi: 42'     , ...
 %! '   1 | 22118'                  , ...
diff --git a/scripts/plot/util/private/__add_default_menu__.m b/scripts/plot/util/private/__add_default_menu__.m
--- a/scripts/plot/util/private/__add_default_menu__.m
+++ b/scripts/plot/util/private/__add_default_menu__.m
@@ -55,31 +55,33 @@ function __add_default_menu__ (fig)
         uimenu (gm, "label", "Rotate on", "tag", "rotate3d", "callback", @guimode_cb);
         uimenu (gm, "label", "Enable mousezoom", "tag", "zoom_on", "callback", @guimode_cb);
         uimenu (gm, "label", "Disable mousezoom", "tag", "zoom_off", "callback", @guimode_cb);
 
   endif
 
 endfunction
 
+
 function save_cb (h, e)
   [hcbo, hfig] = gcbo ();
   lbl = get (hcbo, "label");
   if (strcmp (lbl, "&Save"))
     fname = get (hfig, "filename");
     if (isempty (fname))
       __save_as__ (hcbo);
     else
       saveas (hcbo, fname);
     endif
   elseif (strcmp (lbl, "Save &As"))
     __save_as__ (hcbo);
   endif
 endfunction
 
+
 function __save_as__ (caller)
   [filename, filedir] = uiputfile ({"*.pdf;*.ps;*.gif;*.png;*.jpg",
                                     "Supported Graphic Formats"},
                                    "Save Figure",
                                    [pwd, filesep, "untitled.pdf"]);
   if (filename != 0)
     fname = [filedir filesep() filename];
     set (gcbf, "filename", fname);
@@ -91,34 +93,37 @@ endfunction
 function [hax, fig] = __get_axes__ (h)
   ## Get parent figure
   fig = ancestor (h, "figure");
 
   ## Find all axes which aren't legends
   hax = findobj (fig, "type", "axes", "-not", "tag", "legend");
 endfunction
 
+
 function grid_cb (h, e)
   hax = __get_axes__ (h);
   id = get (h, "tag");
   switch (id)
     case "toggle"
       arrayfun (@grid, hax);
     otherwise
       arrayfun (@(h) grid(h, id), hax);
   endswitch
   drawnow ();
 endfunction
 
+
 function autoscale_cb (h, e)
   hax = __get_axes__ (h);
   arrayfun (@(h) axis (h, "auto"), hax);
   drawnow ();
 endfunction
 
+
 function guimode_cb (h, e)
   [hax, fig] = __get_axes__ (h);
   id = get (h, "tag");
   switch (id)
     case "pan_on"
       pan (fig, "on");
     case "pan_xon"
       pan (fig, "xon");
@@ -130,8 +135,9 @@ function guimode_cb (h, e)
       pan (fig, "off");
       rotate3d (fig, "off");
     case "zoom_on"
       arrayfun (@(h) set (h, "mousewheelzoom", 0.05), hax);
     case "zoom_off"
       arrayfun (@(h) set (h, "mousewheelzoom", 0.0), hax);
   endswitch
 endfunction
+
diff --git a/scripts/plot/util/private/__gnuplot_draw_axes__.m b/scripts/plot/util/private/__gnuplot_draw_axes__.m
--- a/scripts/plot/util/private/__gnuplot_draw_axes__.m
+++ b/scripts/plot/util/private/__gnuplot_draw_axes__.m
@@ -1696,23 +1696,25 @@ function __gnuplot_draw_axes__ (h, plot_
     bg_is_set = false;
   endif
 
   fflush (plot_stream);
 
 endfunction
 
 function x = flip (x)
+
   if (rows (x) == 1)
     x = fliplr (x);
   elseif (columns (x) == 1 || ischar (x))
     x = flipud (x);
   else
     x = flipud (fliplr (x));
   endif
+
 endfunction
 
 function spacing_spec = create_spacingspec (f, s, gp_term)
   ## The gnuplot default font size is 10, and default spacing is 1.25.
   ## gnuplot has a concept of a figure global font, and sizes everything
   ## appropriate to that, including the legend spacing.
   ##
   ## This means that if an alternative size is used, gnuplot will use an
@@ -1721,24 +1723,27 @@ function spacing_spec = create_spacingsp
   ## FIXME: Are fractional spacing specifications allowed?  Or should this
   ##        number be rounded?
   spc = s / 10 * 1.25;
   spacing_spec = sprintf ("spacing %d", spc);
 
 endfunction
 
 function fontspec = create_fontspec (f, s, gp_term)
+
   if (isempty (f) || strcmp (f, "*") || strcmp (gp_term, "tikz"))
     fontspec = sprintf ("font \",%d\"", s);
   else
     fontspec = sprintf ("font \"%s,%d\"", f, s);
   endif
+
 endfunction
 
 function idx = do_border_2d (obj, plot_stream, idx)
+
   fprintf (plot_stream, "set border 0\n");
 
   if (strcmp (obj.box, "on") || strcmp (obj.xaxislocation, "bottom"))
     arrow (1, obj.xcolor, obj.linewidth, [0,0,0],[1,0,0]);
   endif
   if (strcmp (obj.box, "on") || strcmp (obj.xaxislocation, "top"))
     arrow (2, obj.xcolor, obj.linewidth, [0,1,0],[1,1,0]);
   endif
@@ -1766,16 +1771,17 @@ function idx = do_border_2d (obj, plot_s
   function arrow (idx, lc, lw, from, to)
     fprintf (plot_stream, "set arrow %d ", idx);
     fprintf (plot_stream, "nohead nofilled front ");
     fprintf (plot_stream, "lc rgb ""#%02x%02x%02x"" ", round (255 * lc));
     fprintf (plot_stream, "linewidth %.3f ", obj.linewidth);
     fprintf (plot_stream, "from graph %d,%d,%d ", from);
     fprintf (plot_stream, "to graph %d,%d,%d\n", to);
   endfunction
+
 endfunction
 
 function [style, ltidx] = do_linestyle_command (obj, linecolor, idx,
                                                 plot_stream, errbars = "")
   idx = idx + 8;
   style = {};
   ltidx = [];
 
@@ -1923,16 +1929,17 @@ function [style, ltidx] = do_linestyle_c
     fputs (plot_stream, " default");
   endif
 
   fputs (plot_stream, ";\n");
 
 endfunction
 
 function [lt] = gnuplot_linetype (obj)
+
   if (isfield (obj, "linestyle"))
     if (__gnuplot_has_feature__ ("dashtype"))
       opt = "dashtype";
       switch (obj.linestyle)
         case "-"
           lt = "solid";
         case "--"
           lt = "'_ '";
@@ -1965,19 +1972,21 @@ function [lt] = gnuplot_linetype (obj)
       lt = "";
     endif
     if (! isempty (lt))
       lt = sprintf ("%s %s", opt, lt);
     endif
   else
     lt = "";
   endif
+
 endfunction
 
 function [pt, pt2, obj] = gnuplot_pointtype (obj)
+
   if (isfield (obj, "marker"))
     switch (obj.marker)
       case "+"
         pt = pt2 = "1";
       case "o"
         pt = "6";
         pt2 = "7";
       case "*"
@@ -2026,20 +2035,20 @@ function [pt, pt2, obj] = gnuplot_pointt
       case "none"
         pt = pt2 = "";
       otherwise
         pt = pt2 = "";
     endswitch
   else
     pt = pt2 = "";
   endif
+
 endfunction
 
 function __gnuplot_write_data__ (plot_stream, data, nd, parametric, cdata)
-
   ## DATA is already transposed.
 
   ## Convert NA elements to normal NaN values because fprintf writes
   ## "NA" and that confuses gnuplot.
   data(isna (data)) = NaN;
 
   if (nd == 2)
     fwrite (plot_stream, data, "float64");
@@ -2139,16 +2148,17 @@ function do_tics (obj, plot_stream, ymir
                obj.ycolor, "y2", plot_stream, ymirror, "border",
                "", "", fontname, fontspec, obj.ticklabelinterpreter,
                obj.yscale, obj.ysgn, gnuplot_term);
   endif
   do_tics_1 (obj.ztickmode, obj.ztick, obj.zminortick, obj.zticklabelmode,
              obj.zticklabel, obj.zcolor, "z", plot_stream, true,
              "border", obj.tickdir, ticklength, fontname, fontspec,
              obj.ticklabelinterpreter, obj.zscale, obj.zsgn, gnuplot_term);
+
 endfunction
 
 function do_tics_1 (ticmode, tics, mtics, labelmode, labels, color, ax,
                     plot_stream, mirror, axispos, tickdir, ticklength,
                     fontname, fontspec, interpreter, scale, sgn, gnuplot_term)
   persistent warned_latex = false;
 
   ## Avoid emitting anything if the tics are empty, because this undoes the
@@ -2220,38 +2230,43 @@ function do_tics_1 (ticmode, tics, mtics
     endfor
     fprintf (plot_stream, ") %s %s;\n", colorspec, fontspec);
   endif
   if (strcmp (mtics, "on"))
     fprintf (plot_stream, "set m%stics %d;\n", ax, num_mtics);
   else
     fprintf (plot_stream, "unset m%stics;\n", ax);
   endif
+
 endfunction
 
 function ticklabel = ticklabel_to_cell (ticklabel)
+
   if (ischar (ticklabel))
     ticklabel = cellstr (ticklabel);
   elseif (iscellstr (ticklabel))
     ticklabel = ticklabel;
   else
     error ("__gnuplot_draw_axes__: unsupported type of ticklabel");
   endif
+
 endfunction
 
 function colorspec = get_text_colorspec (color)
   colorspec = sprintf ("textcolor rgb \"#%02x%02x%02x\"", round (255*color));
 endfunction
 
 function [f, s, fnt, it, bld] = get_fontname_and_size (t)
+
   if (isempty (t.fontname) || strcmp (t.fontname, "*"))
     fnt = "";
   else
     fnt = t.fontname;
   endif
+
   f = fnt;
   it = false;
   bld = false;
   if (! isempty (t.fontweight) && strcmpi (t.fontweight, "bold"))
     if (! isempty (t.fontangle)
         && (strcmpi (t.fontangle, "italic")
             || strcmpi (t.fontangle, "oblique")))
       f = [f "-bolditalic"];
@@ -2262,25 +2277,26 @@ function [f, s, fnt, it, bld] = get_font
       bld = true;
     endif
   elseif (! isempty (t.fontangle)
           && (strcmpi (t.fontangle, "italic")
               || strcmpi (t.fontangle, "oblique")))
     f = [f "-italic"];
     it = true;
   endif
+
   if (isempty (t.fontsize))
     s = 10;
   else
     s = t.fontsize;
   endif
+
 endfunction
 
 function [str, f, s] = __maybe_munge_text__ (enhanced, obj, fld)
-
   persistent warned_latex = false;
 
   if (strcmp (fld, "string"))
     [f, s, fnt, it, bld] = get_fontname_and_size (obj);
   else
     f = "Helvetica";
     s = 10;
     fnt = f;
@@ -2319,16 +2335,17 @@ function [str, f, s] = __maybe_munge_tex
       endif
     elseif (strcmpi (obj.interpreter, "latex"))
       if (! warned_latex)
         warning ("latex markup not supported for text objects");
         warned_latex = true;
       endif
     endif
   endif
+
 endfunction
 
 function str = __tex2enhanced__ (str, fnt, it, bld)
   persistent sym = __setup_sym_table__ ();
   persistent flds = fieldnames (sym);
 
   [s, e, m] = regexp (str, "\\\\([a-zA-Z]+|0)", "start", "end", "matches");
 
@@ -2497,21 +2514,23 @@ function str = __tex2enhanced__ (str, fn
     else
       i += 1;
     endif
   endwhile
 
 endfunction
 
 function l = length_string (s)
+
   l = length (s) - length (strfind (s,'{')) - length (strfind (s,'}'));
   m = regexp (s, '/([\w-]+|[\w-]+=\d+)', 'matches');
   if (! isempty (m))
     l -= sum (cellfun ("length", m));
   endif
+
 endfunction
 
 function sym = __setup_sym_table__ ()
   ## Setup the translation table for TeX to gnuplot enhanced mode.
   sym.forall = '{/Symbol \042}';
   sym.exists = '{/Symbol \044}';
   sym.ni = '{/Symbol \047}';
   sym.cong = '{/Symbol \100}';
@@ -2620,31 +2639,38 @@ function sym = __setup_sym_table__ ()
   sym.lfloor = '{/Symbol \353}';
   sym.lceil = '{/Symbol \351}';
   sym.rfloor = '{/Symbol \373}';
   sym.rceil = '{/Symbol \371}';
   sym.int = '{/Symbol \362}';
 endfunction
 
 function retval = __do_enhanced_option__ (enhanced, obj)
+
   retval = "";
   if (enhanced)
     if (strcmpi (obj.interpreter, "none"))
       retval = "noenhanced";
     else
       retval = "enhanced";
     endif
   endif
+
 endfunction
 
 function maybe_do_xtick_mirror (plot_stream, axis_obj)
+
   if (! isempty(axis_obj.xtick))
     fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
                           axis_obj.tickdir);
   endif
+
 endfunction
 
 function maybe_do_x2tick_mirror (plot_stream, axis_obj)
+
   if (! isempty(axis_obj.xtick))
     fprintf (plot_stream, "unset xtics; set x2tics %s nomirror\n",
                           axis_obj.tickdir);
   endif
+
 endfunction
+
diff --git a/scripts/plot/util/private/__gnuplot_open_stream__.m b/scripts/plot/util/private/__gnuplot_open_stream__.m
--- a/scripts/plot/util/private/__gnuplot_open_stream__.m
+++ b/scripts/plot/util/private/__gnuplot_open_stream__.m
@@ -20,27 +20,31 @@
 ## @deftypefn {} {@var{stream} =} __gnuplot_open_stream__ (@var{npipes}, @var{h})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: 2009-04-11
 
 function plot_stream = __gnuplot_open_stream__ (npipes, h)
+
   [prog, args] = gnuplot_binary ();
+
   if (npipes > 1)
     [plot_stream(1), plot_stream(2), pid] = popen2 (prog, args{:});
     if (pid < 0)
       error ("__gnuplot_open_stream__: failed to open connection to gnuplot");
     else
       plot_stream(3) = pid;
     endif
   else
     plot_stream = popen (sprintf ("%s ", prog, args{:}), "w");
     if (plot_stream < 0)
       error ("__gnuplot_open_stream__: failed to open connection to gnuplot");
     endif
   endif
+
   if (nargin > 1)
     set (h, "__plot_stream__", plot_stream);
   endif
+
 endfunction
 
diff --git a/scripts/plot/util/private/__gnuplot_print__.m b/scripts/plot/util/private/__gnuplot_print__.m
--- a/scripts/plot/util/private/__gnuplot_print__.m
+++ b/scripts/plot/util/private/__gnuplot_print__.m
@@ -193,39 +193,46 @@ function opts = __gnuplot_print__ (opts)
                output,
                "----------- output end -----------");
       error ("gnuplot:failedpipe", "print: failed to print");
     endif
   endfor
 
 endfunction
 
+
 function eps_drawnow (opts, epsfile, gp_opts)
+
   [h, fontsize] = get_figure_text_objs (opts);
   unwind_protect
     fontsize_2x = cellfun (@times, {2}, fontsize, "uniformoutput", false);
     set (h, {"fontsize"}, fontsize_2x);
     local_drawnow (["postscript eps " gp_opts], epsfile, opts);
   unwind_protect_cleanup
     set (h, {"fontsize"}, fontsize);
   end_unwind_protect
+
 endfunction
 
+
 function local_drawnow (term, file, opts)
+
   set (0, "currentfigure", opts.figure);
   if (isempty (opts.debug_file) || ! opts.debug)
     drawnow (term, file);
   else
     drawnow (term, file, opts.debug_file);
   endif
   if (opts.debug)
     fprintf ("Expanded gnuplot terminal = '%s'\n", term);
   endif
+
 endfunction
 
+
 function f = font_spec (opts, varargin)
   for n = 1:2:numel (varargin)
     opts.(varargin{n}) = varargin{n+1};
   endfor
   f = "";
   switch (opts.devopt)
     case "cgm"
       if (! isempty (opts.font) && ! isempty (opts.fontsize))
@@ -321,19 +328,22 @@ function f = font_spec (opts, varargin)
       if (! isempty (opts.font) && ! isempty (opts.fontsize))
         f = sprintf ("font %s fontsize %d", opts.font, opts.fontsize);
       elseif (! isempty (opts.font))
         f = sprintf ("font %s", opts.font);
       elseif (! isempty (opts.fontsize))
         f = sprintf ("fontsize %d", opts.fontsize);
       endif
   endswitch
+
 endfunction
 
+
 function [h, fontsize] = get_figure_text_objs (opts)
+
   h = findall (opts.figure, "-property", "fontsize");
   hp = get (h, "parent");
   if (iscell (hp))
     hp = cell2mat (hp);
   endif
   ## Do not change the text objects fontsizes for the children of a
   ## legend axes.  These will be handled by the fontsize listener.
   is_legend_key_string = strcmp (get (hp, "tag"), "legend") ...
@@ -343,10 +353,11 @@ function [h, fontsize] = get_figure_text
   h(is_legend_key_string) = [];
   fontsize = get (h, "fontsize");
   switch (numel (fontsize))
     case 0
       fontsize = {};
     case 1
       fontsize = {fontsize};
   endswitch
+
 endfunction
 
diff --git a/scripts/plot/util/private/__print_parse_opts__.m b/scripts/plot/util/private/__print_parse_opts__.m
--- a/scripts/plot/util/private/__print_parse_opts__.m
+++ b/scripts/plot/util/private/__print_parse_opts__.m
@@ -447,30 +447,33 @@ endfunction
 %! opts = __print_parse_opts__ ("-f5", "-dljet3");
 %! assert (opts.ghostscript.device, "ljet3");
 %! assert (strfind (opts.ghostscript.output, ".ljet3"));
 %! assert (opts.devopt, "ljet3");
 %! assert (opts.send_to_printer, true);
 %! assert (opts.figure, 5);
 
 function cmd = __quote_path__ (cmd)
+
   if (! isempty (cmd))
     is_quoted = all (cmd([1, end]) == "'");
     if (! is_quoted)
       dos_shell = ! isunix () && ispc ();
       if (dos_shell && any (cmd == "/"))
         cmd = strrep (cmd, "/", "\\");
       endif
       if (any (cmd == " "))
         cmd = ['"' strrep(cmd, '"', '""') '"'];
       endif
     endif
   endif
+
 endfunction
 
+
 function gs = __ghostscript_binary__ ()
 
   persistent ghostscript_binary = ""
   persistent warn_on_no_ghostscript = true
   persistent warn_on_bad_gsc = true
 
   if (isempty (ghostscript_binary))
     GSC = getenv ("GSC");
@@ -604,25 +607,27 @@ function [papersize, paperposition] = gs
     if (strncmp (papersize, "arch", 4))
       papersize(end) = upper (papersize(end));
     endif
   endif
 
 endfunction
 
 function value = convert2points (value, units)
+
   switch (units)
     case "inches"
       value *= 72;
     case "centimeters"
       value *= 72 / 2.54;
     case "normalized"
       error ("print:customnormalized",
              "print.m: papersize=='<custom>' and paperunits='normalized' may not be combined");
   endswitch
+
 endfunction
 
 function device_list = gs_device_list ();
   ## Graphics formats/languages, not printers.
   device_list = {"bmp16"; "bmp16m"; "bmp256"; "bmp32b"; "bmpgray"; ...
                  "epswrite"; "eps2write"; "jpeg"; "jpegcymk"; "jpeggray";
                  "pbm"; "pbmraw"; "pcx16"; "pcx24b"; "pcx256"; "pcx2up"; ...
                  "pcxcmyk"; "pcxgray"; "pcxmono"; "pdfwrite"; "pgm"; ...
diff --git a/scripts/plot/util/refreshdata.m b/scripts/plot/util/refreshdata.m
--- a/scripts/plot/util/refreshdata.m
+++ b/scripts/plot/util/refreshdata.m
@@ -96,16 +96,17 @@ function refreshdata (h, workspace)
         continue;  # datasource field doesn't point to anything
       endif
       expr = obj.(m{j});       # datasource field
       val = evalin (workspace, expr);
       pdname = m{j}(1:end-6);  # property data name without "source"
       set (h(i), pdname, val);
     endfor
   endfor
+
 endfunction
 
 
 %!demo
 %! clf;
 %! x = 0:0.1:10;
 %! y = sin (x);
 %! plot (x, y, 'ydatasource', 'y');
diff --git a/scripts/plot/util/rotate3d.m b/scripts/plot/util/rotate3d.m
--- a/scripts/plot/util/rotate3d.m
+++ b/scripts/plot/util/rotate3d.m
@@ -90,19 +90,22 @@ function rotate3d (varargin)
     else
       error ("rotate3d: wrong type argument '%s'", class (arg));
     endif
   endif
 
 endfunction
 
 function update_mouse_mode (hfig, arg)
+
   if (strcmp (arg, "off"))
     set (hfig, "__mouse_mode__", "none");
   else
     ## FIXME: Is there a better way other than calling these
     ## functions to set the other mouse mode Enable fields to
     ## "off"?
     pan ("off");
     zoom ("off");
     set (hfig, "__mouse_mode__", "rotate");
   endif
+
 endfunction
+
diff --git a/scripts/plot/util/struct2hdl.m b/scripts/plot/util/struct2hdl.m
--- a/scripts/plot/util/struct2hdl.m
+++ b/scripts/plot/util/struct2hdl.m
@@ -172,18 +172,19 @@ function [h, pout] = struct2hdl (s, p=[]
   ## paste properties
   setprops (s, h, p, hilev);
 
   pout = p;
 
 endfunction
 
 function [h, sout] = createaxes (s, p, par)
-  ## regular axes
+
   if (! any (strcmpi (s.properties.tag, {"colorbar", "legend"})))
+    ## regular axes
     propval = {"position", s.properties.position};
     hid = {"autopos_tag", "looseinset"};
     for ii = 1:numel (hid)
       prop = hid{ii};
       if (isfield (s.properties, prop))
         val = s.properties.(prop);
         propval = [propval, prop, val];
       endif
@@ -278,38 +279,42 @@ function [h, sout] = createaxes (s, p, p
                                 {"userdata", "xlabel" ...
                                  "ylabel", "zlabel", ...
                                  "title", "axes"});
       s.children= [];
     else
       error ("hdl2struct: didn't find an object");
     endif
   endif
+
   sout = s;
+
 endfunction
 
 function h = createline (s, par)
   h = line ("parent", par);
   addmissingprops (h, s.properties);
 endfunction
 
 function [h, sout] = createpatch (s, par)
+
   prp.faces = s.properties.faces;
   prp.vertices = s.properties.vertices;
   prp.facevertexcdata = s.properties.facevertexcdata;
   h = patch (prp);
   set (h, "parent", par);
   s.properties = rmfield (s.properties,
                           {"faces", "vertices", "facevertexcdata"});
   ## Also remove derived properties.  Otherwise there is a possibility for
   ## a segfault when 'set (h, properties)' is used to restore properties
   ## which do not match in size the ones created with from the call to patch().
   s.properties = rmfield (s.properties, {"xdata", "ydata", "zdata", "cdata"});
   addmissingprops (h, s.properties);
   sout = s;
+
 endfunction
 
 function h = createtext (s, par)
   h = text ("parent", par);
   addmissingprops (h, s.properties);
 endfunction
 
 function h = createimage (s, par)
@@ -352,21 +357,24 @@ function [h, sout, pout] = createhg (s, 
         p = [p [oldkids(ii++).handle; newkids(nkids--)]];
       endwhile
     endif
   else
     h = hggroup ("parent", par);
     addmissingprops (h, s.properties);
     s.special = [];
   endif
+
   sout = s;
   pout = p;
+
 endfunction
 
 function [h, sout, pout] = createhg_hilev (s, p, par)
+
   fields = s.properties;
   if (isfield (fields, "contourmatrix"))
     ## contours
     xdata = s.properties.xdata;
     ydata = s.properties.ydata;
     zdata = s.properties.zdata;
     levellist = s.properties.levellist;
     textlist = s.properties.textlist;
@@ -542,21 +550,24 @@ function [h, sout, pout] = createhg_hile
                               {"xdata", "ydata", ...
                                "xdatasource", "ydatasource"});
   else
     warning ("struct2hdl: could not infer the hggroup type.  Will build objects but listener/callback functions will be lost");
     h = hggroup ("parent", par);
     addmissingprops (h, s.properties);
     s.special = [];           # children will be treated as normal children
   endif
+
   sout = s;
   pout = p;
+
 endfunction
 
 function setprops (s, h, p, hilev)
+
   if (! any (strcmpi (s.properties.tag, {"colorbar", "legend"})))
     specs = s.children(s.special);
     if (isempty (specs))
       hdls = [];
     else
       hdls = [specs.handle];
     endif
     nh = length (hdls);
@@ -619,32 +630,36 @@ function setprops (s, h, p, hilev)
 
   else
     set (h, s.properties);
   endif
 
 endfunction
 
 function out = valcomp (x, hdls)
+
   if (isfloat (x) && isscalar (x))
     out = any (x == hdls);
   else
     out = 0;
   endif
+
 endfunction
 
 function addmissingprops (h, props)
+
   hid = {"autopos_tag", "looseinset"};
   oldfields = fieldnames (props);
   curfields = fieldnames (get (h));
   missing = ! ismember (oldfields, curfields);
   idx = find (missing);
   for ii = 1:length (idx)
     prop = oldfields{idx(ii)};
     if (! any (strcmp (prop, hid)))
       addproperty (prop, h, "any");
     endif
   endfor
+
 endfunction
 
 
 ## FIXME: Need validation tests
 
diff --git a/scripts/plot/util/subplot.m b/scripts/plot/util/subplot.m
--- a/scripts/plot/util/subplot.m
+++ b/scripts/plot/util/subplot.m
@@ -363,16 +363,17 @@ function [pos, opos, li] = subplot_posit
           (width + margin.left + margin.right), ...
           (height + margin.bottom + margin.top)];
   li = [margin.left, margin.bottom, margin.right, margin.top];
 
 endfunction
 
 function subplot_align (h, d, rmupdate = false)
   persistent updating = false;
+
   if (! updating)
     if (rmupdate)
       ## The "position" property has been changed from outside this routine.
       ## Don't update anymore.
       if (isappdata (h, "__subplotposition__"))
         rmappdata (h, "__subplotposition__");
         rmappdata (h, "__subplotouterposition__");
       endif
diff --git a/scripts/plot/util/zoom.m b/scripts/plot/util/zoom.m
--- a/scripts/plot/util/zoom.m
+++ b/scripts/plot/util/zoom.m
@@ -158,26 +158,27 @@ function zoom (varargin)
     else
       error ("zoom: wrong type argument '%s'", class (arg));
     endif
   endif
 
 endfunction
 
 function update_mouse_mode (hfig, arg)
+
   if (strcmp (arg, "off"))
     set (hfig, "__mouse_mode__", "none");
   else
-    ## FIXME: Is there a better way other than calling these
-    ## functions to set the other mouse mode Enable fields to
-    ## "off"?
+    ## FIXME: Is there a better way other than calling these functions
+    ##        to set the other mouse mode Enable fields to "off"?
     pan ("off");
     rotate3d ("off");
     set (hfig, "__mouse_mode__", "zoom");
   endif
+
 endfunction
 
 
 %!demo
 %! clf;
 %! sombrero ();
 %! pause (1);
 %! %% zoom in by a factor of 2
diff --git a/scripts/polynomial/polyout.m b/scripts/polynomial/polyout.m
--- a/scripts/polynomial/polyout.m
+++ b/scripts/polynomial/polyout.m
@@ -84,25 +84,27 @@ function y = polyout (c, x)
     disp (tmp);
   else
     y = tmp;
   endif
 
 endfunction
 
 function str = coeff (c)
+
   if (imag (c))
     if (real (c))
       str = sprintf ("(%s)", num2str (c, 5));
     else
       str = num2str (c, 5);
     endif
   else
     str = num2str (c, 5);
   endif
+
 endfunction
 
 
 %!assert (polyout ([3 2 1]), "3*s^2 + 2*s^1 + 1")
 %!assert (polyout ([3 2 1], "x"), "3*x^2 + 2*x^1 + 1")
 %!assert (polyout ([3 2 1], "wxyz"), "3*wxyz^2 + 2*wxyz^1 + 1")
 %!assert (polyout ([5 4 3 2 1], "1"),"5*1^4 + 4*1^3 + 3*1^2 + 2*1^1 + 1")
 
diff --git a/scripts/polynomial/ppder.m b/scripts/polynomial/ppder.m
--- a/scripts/polynomial/ppder.m
+++ b/scripts/polynomial/ppder.m
@@ -44,16 +44,17 @@ function ppd = ppder (pp, m = 1)
   else
     f = k : -1 : 1;
     ff = bincoeff (f, m + 1) .* factorial (m + 1) ./ f;
     k -= m;
     pd = p(:,1:k) * diag (ff(1:k));
   endif
 
   ppd = mkpp (x, pd, d);
+
 endfunction
 
 
 %!shared x,y,pp,ppd
 %! x = 0:8;
 %! y = [x.^2; x.^3+1];
 %! pp = spline (x, y);
 %! ppd = ppder (pp);
diff --git a/scripts/polynomial/ppint.m b/scripts/polynomial/ppint.m
--- a/scripts/polynomial/ppint.m
+++ b/scripts/polynomial/ppint.m
@@ -21,16 +21,17 @@
 ## @deftypefnx {} {@var{ppi} =} ppint (@var{pp}, @var{c})
 ## Compute the integral of the piecewise polynomial struct @var{pp}.
 ##
 ## @var{c}, if given, is the constant of integration.
 ## @seealso{mkpp, ppval, ppder}
 ## @end deftypefn
 
 function ppi = ppint (pp, c)
+
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
   if (! (isstruct (pp) && strcmp (pp.form, "pp")))
     error ("ppint: PP must be a structure");
   endif
 
   [x, p, n, k, d] = unmkpp (pp);
diff --git a/scripts/polynomial/ppjumps.m b/scripts/polynomial/ppjumps.m
--- a/scripts/polynomial/ppjumps.m
+++ b/scripts/polynomial/ppjumps.m
@@ -21,16 +21,17 @@
 ## Evaluate the boundary jumps of a piecewise polynomial.
 ##
 ## If there are @math{n} intervals, and the dimensionality of @var{pp} is
 ## @math{d}, the resulting array has dimensions @code{[d, n-1]}.
 ## @seealso{mkpp}
 ## @end deftypefn
 
 function jumps = ppjumps (pp)
+
   if (nargin != 1)
     print_usage ();
   endif
 
   if (! (isstruct (pp) && strcmp (pp.form, "pp")))
     error ("ppjumps: PP must be a structure");
   endif
 
@@ -51,16 +52,17 @@ function jumps = ppjumps (pp)
 
   for i = 2 : k;
     llim .*= dx;
     llim += shiftdim (reshape (P(1:(n-1) * prod (d), i), [d, n-1]), nd - 1);
   endfor
 
   rlim = shiftdim (ppval (pp, x(2:end-1)), nd - 1);
   jumps = shiftdim (rlim - llim, 1);
+
 endfunction
 
 
 %!test
 %! p = [1 6 11 6];
 %! x = linspace (5, 6, 4);
 %! y = polyval (p, x);
 %! pp = spline (x, y);
diff --git a/scripts/polynomial/splinefit.m b/scripts/polynomial/splinefit.m
--- a/scripts/polynomial/splinefit.m
+++ b/scripts/polynomial/splinefit.m
@@ -89,35 +89,38 @@
 ## @end ifnottex
 ## @end group
 ## @end example
 ##
 ## @seealso{interp1, unmkpp, ppval, spline, pchip, ppder, ppint, ppjumps}
 ## @end deftypefn
 
 function pp = splinefit (x, y, breaks, varargin)
+
   if (nargin > 3)
     n = cellfun ("isclass", varargin, "char");
     varargin(n) = lower (varargin(n));
     try
       props = struct (varargin{:});
     catch
       print_usage ();
     end_try_catch
   else
     props = struct ();
   endif
+
   fields = fieldnames (props);
   for f = 1:numel (fields)
     if (! any (strcmp (fields{f},
                        {"periodic", "robust", "beta", "order", "constraints"})))
       error ("splinefit:invalidproperty",
              "unrecognized property '%s'", fields{f});
     endif
   endfor
+
   args = {};
   if (isfield (props, "periodic") && props.periodic)
     args{end+1} = "p";
   endif
   if (isfield (props, "robust") && props.robust)
     args{end+1} = "r";
   endif
   if (isfield (props, "beta"))
@@ -137,17 +140,19 @@ function pp = splinefit (x, y, breaks, v
   if (isfield (props, "constraints"))
     args{end+1} = props.constraints;
   endif
   if (nargin < 3)
     print_usage ();
   elseif (! isnumeric (breaks) || ! isvector (breaks))
     print_usage ();
   endif
+
   pp = __splinefit__ (x, y, breaks, args{:});
+
 endfunction
 
 
 %!demo
 %! % Noisy data
 %! x = linspace (0, 2*pi, 100);
 %! y = sin (x) + 0.1 * randn (size (x));
 %! % Breaks
diff --git a/scripts/signal/detrend.m b/scripts/signal/detrend.m
--- a/scripts/signal/detrend.m
+++ b/scripts/signal/detrend.m
@@ -33,17 +33,17 @@
 ## @seealso{polyfit}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 11 October 1994
 ## Adapted-By: jwe
 
 function y = detrend (x, p = 1)
-  ## Check input
+
   if (nargin > 0 && isreal (x) && ndims (x) <= 2)
     ## Check p
     if (ischar (p) && strcmpi (p, "constant"))
       p = 0;
     elseif (ischar (p) && strcmpi (p, "linear"))
       p = 1;
     elseif (! isscalar (p) || p < 0 || p != fix (p))
       error ("detrend: second input argument must be 'constant', 'linear' or a positive integer");
diff --git a/scripts/signal/filter2.m b/scripts/signal/filter2.m
--- a/scripts/signal/filter2.m
+++ b/scripts/signal/filter2.m
@@ -50,10 +50,11 @@ function y = filter2 (b, x, shape)
     print_usage ();
   endif
   if (nargin < 3)
     shape = "same";
   endif
 
   [nr, nc] = size (b);
   y = conv2 (x, b(nr:-1:1, nc:-1:1), shape);
+
 endfunction
 
diff --git a/scripts/sparse/bicgstab.m b/scripts/sparse/bicgstab.m
--- a/scripts/sparse/bicgstab.m
+++ b/scripts/sparse/bicgstab.m
@@ -67,143 +67,141 @@
 ##
 ## @seealso{bicg, cgs, gmres, pcg, qmr}
 ##
 ## @end deftypefn
 
 function [x, flag, relres, iter, resvec] = bicgstab (A, b, tol, maxit,
                                                      M1, M2, x0)
 
-  if (nargin >= 2 && nargin <= 7 && isvector (full (b)))
+  if (nargin < 2 || nargin > 7 || ! isvector (full (b)))
+    print_usage ();
+  endif
+
+  if (ischar (A))
+    A = str2func (A);
+  elseif (isnumeric(A) && issquare (A))
+    Ax = @(x) A  * x;
+  elseif (isa (A, "function_handle"))
+    Ax = @(x) feval (A, x);
+  else
+    error ("bicgstab: A must be a square matrix or function");
+  endif
 
-    if (ischar (A))
-      A = str2func (A);
-    elseif (isnumeric(A) && issquare (A))
-      Ax = @(x) A  * x;
-    elseif (isa (A, "function_handle"))
-      Ax = @(x) feval (A, x);
-    else
-      error ("bicgstab: A must be a square matrix or function");
-    endif
+  if (nargin < 3 || isempty (tol))
+    tol = 1e-6;
+  endif
+
+  if (nargin < 4 || isempty (maxit))
+    maxit = min (rows (b), 20);
+  endif
 
-    if (nargin < 3 || isempty (tol))
-      tol = 1e-6;
-    endif
-
-    if (nargin < 4 || isempty (maxit))
-      maxit = min (rows (b), 20);
-    endif
+  if (nargin < 5 || isempty (M1))
+    M1m1x = @(x) x;
+  elseif (ischar (M1))
+    M1m1x = str2func (M1);
+  elseif (isnumeric(M1) && ismatrix (M1))
+    M1m1x = @(x) M1  \ x;
+  elseif (isa (M1, "function_handle"))
+    M1m1x = @(x) feval (M1, x);
+  else
+    error ("bicgstab: preconditioner M1 must be a function or matrix");
+  endif
 
-    if (nargin < 5 || isempty (M1))
-      M1m1x = @(x) x;
-    elseif (ischar (M1))
-      M1m1x = str2func (M1);
-    elseif (isnumeric(M1) && ismatrix (M1))
-      M1m1x = @(x) M1  \ x;
-    elseif (isa (M1, "function_handle"))
-      M1m1x = @(x) feval (M1, x);
-    else
-      error ("bicgstab: preconditioner M1 must be a function or matrix");
-    endif
+  if (nargin < 6 || isempty (M2))
+    M2m1x = @(x) x;
+  elseif (ischar (M2))
+    M2m1x = str2func (M2);
+  elseif (isnumeric(M2) && ismatrix (M2))
+    M2m1x = @(x) M2  \ x;
+  elseif (isa (M2, "function_handle"))
+    M2m1x = @(x) feval (M2, x);
+  else
+    error ("bicgstab: preconditioner M2 must be a function or matrix");
+  endif
+
+  precon = @(x) M2m1x (M1m1x (x));
+
+  if (nargin < 7 || isempty (x0))
+    x0 = zeros (size (b));
+  endif
 
-    if (nargin < 6 || isempty (M2))
-      M2m1x = @(x) x;
-    elseif (ischar (M2))
-      M2m1x = str2func (M2);
-    elseif (isnumeric(M2) && ismatrix (M2))
-      M2m1x = @(x) M2  \ x;
-    elseif (isa (M2, "function_handle"))
-      M2m1x = @(x) feval (M2, x);
-    else
-      error ("bicgstab: preconditioner M2 must be a function or matrix");
-    endif
+  ## specifies initial estimate x0
+  if (nargin < 7)
+    x = zeros (rows (b), 1);
+  else
+    x = x0;
+  endif
+
+  norm_b = norm (b);
+
+  res = b - Ax (x);
+  rr = res;
 
-    precon = @(x) M2m1x (M1m1x (x));
+  ## Vector of the residual norms for each iteration.
+  resvec = norm (res) / norm_b;
 
-    if (nargin < 7 || isempty (x0))
-      x0 = zeros (size (b));
-    endif
+  ## Default behavior we don't reach tolerance tol within maxit iterations.
+  flag = 1;
 
-    ## specifies initial estimate x0
-    if (nargin < 7)
-      x = zeros (rows (b), 1);
+  for iter = 1:maxit
+    rho_1 = rr' * res;
+
+    if (iter == 1)
+      p = res;
     else
-      x = x0;
+      beta = (rho_1 / rho_2) * (alpha / omega);
+      p = res + beta * (p - omega * v);
     endif
 
-    norm_b = norm (b);
-
-    res = b - Ax (x);
-    rr = res;
+    phat = precon (p);
 
-    ## Vector of the residual norms for each iteration.
-    resvec = norm (res) / norm_b;
+    v = Ax (phat);
+    alpha = rho_1 / (rr' * v);
+    s = res - alpha * v;
 
-    ## Default behavior we don't reach tolerance tol within maxit iterations.
-    flag = 1;
-
-    for iter = 1:maxit
-      rho_1 = rr' * res;
+    shat = precon (s);
 
-      if (iter == 1)
-        p = res;
-      else
-        beta = (rho_1 / rho_2) * (alpha / omega);
-        p = res + beta * (p - omega * v);
-      endif
-
-      phat = precon (p);
+    t = Ax (shat);
+    omega = (s' * t) / (t' * t);
+    x += alpha * phat + omega * shat;
+    res = s - omega * t;
+    rho_2 = rho_1;
 
-      v = Ax (phat);
-      alpha = rho_1 / (rr' * v);
-      s = res - alpha * v;
-
-      shat = precon (s);
-
-      t = Ax (shat);
-      omega = (s' * t) / (t' * t);
-      x += alpha * phat + omega * shat;
-      res = s - omega * t;
-      rho_2 = rho_1;
+    relres = norm (res) / norm_b;
+    resvec = [resvec; relres];
 
-      relres = norm (res) / norm_b;
-      resvec = [resvec; relres];
-
-      if (relres <= tol)
-        ## We reach tolerance tol within maxit iterations.
-        flag = 0;
-        break;
-      elseif (resvec(end) == resvec(end - 1))
-        ## The method stagnates.
-        flag = 3;
-        break;
-      endif
-    endfor
+    if (relres <= tol)
+      ## We reach tolerance tol within maxit iterations.
+      flag = 0;
+      break;
+    elseif (resvec(end) == resvec(end - 1))
+      ## The method stagnates.
+      flag = 3;
+      break;
+    endif
+  endfor
 
-    if (nargout < 2)
-      if (flag == 0)
-        printf ("bicgstab converged at iteration %i ", iter);
-        printf ("to a solution with relative residual %e\n", relres);
-      elseif (flag == 3)
-        printf ("bicgstab stopped at iteration %i ", iter);
-        printf ("without converging to the desired tolerance %e\n", tol);
-        printf ("because the method stagnated.\n");
-        printf ("The iterate returned (number %i) ", iter);
-        printf ("has relative residual %e\n", relres);
-      else
-        printf ("bicgstab stopped at iteration %i ", iter);
-        printf ("without converging to the desired toleranc %e\n", tol);
-        printf ("because the maximum number of iterations was reached.\n");
-        printf ("The iterate returned (number %i) ", iter);
-        printf ("has relative residual %e\n", relres);
-      endif
+  if (nargout < 2)
+    if (flag == 0)
+      printf ("bicgstab converged at iteration %i ", iter);
+      printf ("to a solution with relative residual %e\n", relres);
+    elseif (flag == 3)
+      printf ("bicgstab stopped at iteration %i ", iter);
+      printf ("without converging to the desired tolerance %e\n", tol);
+      printf ("because the method stagnated.\n");
+      printf ("The iterate returned (number %i) ", iter);
+      printf ("has relative residual %e\n", relres);
+    else
+      printf ("bicgstab stopped at iteration %i ", iter);
+      printf ("without converging to the desired toleranc %e\n", tol);
+      printf ("because the maximum number of iterations was reached.\n");
+      printf ("The iterate returned (number %i) ", iter);
+      printf ("has relative residual %e\n", relres);
     endif
-
-  else
-    print_usage ();
   endif
 
 endfunction
 
 
 %!demo
 %! % Solve system of A*x=b
 %! A = [5 -1 3;-1 2 -2;3 -2 3];
@@ -244,8 +242,9 @@ endfunction
 %! [x, flag, relres, iter, resvec] = bicgstab (A, b, tol, [], diag (diag (A)));
 %! assert (x, ones (size (b)), 1e-7);
 
 %!test
 %! A = [1 + 1i, 1 + 1i; 2 - 1i, 2 + 1i];
 %! b = A * [1; 1];
 %! [x, flag, relres, iter, resvec] = bicgstab (A, b);
 %! assert (x, [1; 1], 1e-6);
+
diff --git a/scripts/sparse/colperm.m b/scripts/sparse/colperm.m
--- a/scripts/sparse/colperm.m
+++ b/scripts/sparse/colperm.m
@@ -30,11 +30,12 @@
 function p = colperm (s)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   [i, j] = find (s);
   idx = find (diff ([j; Inf]) != 0);
-  [dummy, p] = sort (idx - [0; idx(1:(end-1))]);
+  [~, p] = sort (idx - [0; idx(1:(end-1))]);
+
 endfunction
 
diff --git a/scripts/sparse/etreeplot.m b/scripts/sparse/etreeplot.m
--- a/scripts/sparse/etreeplot.m
+++ b/scripts/sparse/etreeplot.m
@@ -29,10 +29,11 @@
 
 function etreeplot (A, varargin)
 
   if (nargin < 1)
     print_usage ();
   endif
 
   treeplot (etree (A+A'), varargin{:});
+
 endfunction
 
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -380,16 +380,17 @@ function [x, flag, relres, iter, resvec,
   endif
 
   if (! matrix_positive_definite)
     flag = 3;
     if (nargout < 2)
       warning ("pcg: matrix not positive definite?\n");
     endif
   endif
+
 endfunction
 
 
 %!demo
 %! ## Simplest usage of pcg (see also 'help pcg')
 %!
 %! N = 10;
 %! A = diag ([1:N]); b = rand (N, 1);
diff --git a/scripts/sparse/qmr.m b/scripts/sparse/qmr.m
--- a/scripts/sparse/qmr.m
+++ b/scripts/sparse/qmr.m
@@ -258,16 +258,17 @@ function [x, flag, relres, iter, resvec]
       endif
     elseif (nargout < 2)
       printf ("qmr converged at iteration %i ", iter);
       printf ("to a solution with relative residual %e\n", res1);
     endif
   else
     print usage();
   endif
+
 endfunction
 
 
 %!demo
 %! % Solve system of A*x=b
 %! A = [5 -1 3;-1 2 -2;3 -2 3];
 %! b = [7;-1;4];
 %! [x, flag, relres, iter, resvec] = qmr (A, b)
diff --git a/scripts/sparse/spaugment.m b/scripts/sparse/spaugment.m
--- a/scripts/sparse/spaugment.m
+++ b/scripts/sparse/spaugment.m
@@ -70,32 +70,34 @@
 ## solution using the @code{spaugment} function.
 ##
 ## In general the left division operator is more stable and faster than using
 ## the @code{spaugment} function.
 ## @seealso{mldivide}
 ## @end deftypefn
 
 function s = spaugment (A, c)
+
   if (nargin < 2)
     if (issparse (A))
       c = max (max (abs (A))) / 1000;
     else
       if (ndims (A) != 2)
         error ("spaugment: A must be a 2-D matrix");
       else
         c = max (abs (A(:))) / 1000;
       endif
     endif
   elseif (! isscalar (c))
     error ("spaugment: C must be a scalar");
   endif
 
   [m, n] = size (A);
   s = [ c * speye(m, m), A; A', sparse(n, n)];
+
 endfunction
 
 
 %!testif HAVE_UMFPACK
 %! m = 11; n = 10; mn = max (m ,n);
 %! A = spdiags ([ones(mn,1), 10*ones(mn,1), -ones(mn,1)],[-1,0,1], m, n);
 %! x0 = A \ ones (m,1);
 %! s = spaugment (A);
diff --git a/scripts/sparse/speye.m b/scripts/sparse/speye.m
--- a/scripts/sparse/speye.m
+++ b/scripts/sparse/speye.m
@@ -27,16 +27,17 @@
 ##
 ## Called with a single argument a square matrix of size
 ## @var{m}-by-@var{m} is created.  If called with a single vector argument
 ## @var{sz}, this argument is taken to be the size of the matrix to create.
 ## @seealso{sparse, spdiags, eye}
 ## @end deftypefn
 
 function s = speye (m, n)
+
   if (nargin == 1)
     if (isvector (m) && length (m) == 2)
       n = m(2);
       m = m(1);
     elseif (isscalar (m))
       n = m;
     else
       error ("speye: invalid matrix dimension");
@@ -44,16 +45,17 @@ function s = speye (m, n)
   else
     if (! isscalar (m) || ! isscalar (n))
       error ("speye: invalid matrix dimension");
     endif
   endif
 
   lo = min ([m, n]);
   s = sparse (1:lo, 1:lo, 1, m, n);
+
 endfunction
 
 
 %!assert (issparse (speye (4)))
 %!assert (speye (4), sparse (1:4,1:4,1))
 %!assert (speye (2,4), sparse (1:2,1:2,1,2,4))
 %!assert (speye (4,2), sparse (1:2,1:2,1,4,2))
 %!assert (speye ([4,2]), sparse (1:2,1:2,1,4,2))
diff --git a/scripts/sparse/treelayout.m b/scripts/sparse/treelayout.m
--- a/scripts/sparse/treelayout.m
+++ b/scripts/sparse/treelayout.m
@@ -25,188 +25,191 @@
 ##
 ## The parameter @var{permutation} is an optional postorder permutation.
 ##
 ## The complexity of the algorithm is O(n) in terms of time and memory
 ## requirements.
 ## @seealso{etreeplot, gplot, treeplot}
 ## @end deftypefn
 
-function [x_coordinate, y_coordinate, height, s] = treelayout (tree, permutation)
+function [x_coordinate, y_coordinate, height, s] = ...
+                                                 treelayout (tree, permutation)
+
   if (nargin < 1 || nargin > 2 || nargout > 4)
     print_usage ();
   elseif (! isvector (tree) || rows (tree) != 1 || ! isnumeric (tree)
           || any (tree > length (tree)) || any (tree < 0))
     error ("treelayout: the first input argument must be a vector of predecessors");
-  else
-    ## Make it a row vector.
-    tree = tree(:)';
+  endif
+
+  ## Make it a row vector.
+  tree = tree(:)';
+
+  ## The count of nodes of the graph.
+  num_nodes = length (tree);
+  ## The number of children.
+  num_children = zeros (1, num_nodes + 1);
 
-    ## The count of nodes of the graph.
-    num_nodes = length (tree);
-    ## The number of children.
-    num_children = zeros (1, num_nodes + 1);
+  ## Checking vector of predecessors.
+  for i = 1 : num_nodes
+    if (tree(i) < i)
+      ## This part of graph was checked before.
+      continue;
+    endif
 
-    ## Checking vector of predecessors.
-    for i = 1 : num_nodes
-      if (tree(i) < i)
+    ## Try to find cicle in this part of graph using modified Floyd's
+    ## cycle-finding algorithm.
+    tortoise = tree(i);
+    hare = tree(tortoise);
+
+    while (tortoise != hare)
+      ## End after finding a cicle or reaching a checked part of graph.
+
+      if (hare < i)
         ## This part of graph was checked before.
-        continue;
+        break
       endif
 
-      ## Try to find cicle in this part of graph using modified Floyd's
-      ## cycle-finding algorithm.
-      tortoise = tree(i);
-      hare = tree(tortoise);
-
-      while (tortoise != hare)
-        ## End after finding a cicle or reaching a checked part of graph.
-
-        if (hare < i)
-          ## This part of graph was checked before.
-          break
-        endif
-
-        tortoise = tree(tortoise);
-        ## Hare will move faster than tortoise so in cicle hare must
-        ## reach tortoise.
-        hare = tree(tree(hare));
-
-      endwhile
-
-      if (tortoise == hare)
-        ## If hare reach tortoise we found circle.
-        error ("treelayout: vector of predecessors has bad format");
-      endif
+      tortoise = tree(tortoise);
+      ## Hare will move faster than tortoise so in cicle hare must
+      ## reach tortoise.
+      hare = tree(tree(hare));
 
-    endfor
-    ## Vector of predecessors has right format.
-
-    for i = 1:num_nodes
-      ## vec_of_child is helping vector which is used to speed up the
-      ## choice of descendant nodes.
-
-      num_children(tree(i)+1) = num_children(tree(i)+1) + 1;
-    endfor
+    endwhile
 
-    pos = 1;
-    start = zeros (1, num_nodes+1);
-    xhelp = zeros (1, num_nodes+1);
-    stop = zeros (1, num_nodes+1);
-    for i = 1 : num_nodes + 1
-      start(i) = pos;
-      xhelp(i) = pos;
-      pos += num_children(i);
-      stop(i) = pos;
-    endfor
-
-    if (nargin == 1)
-      for i = 1:num_nodes
-        vec_of_child(xhelp(tree(i)+1)) = i;
-        xhelp(tree(i)+1) = xhelp(tree(i)+1) + 1;
-      endfor
-    else
-      vec_of_child = permutation;
+    if (tortoise == hare)
+      ## If hare reach tortoise we found circle.
+      error ("treelayout: vector of predecessors has bad format");
     endif
 
-    ## The number of "parent" (actual) node (it's descendants will be
-    ## browse in the next iteration).
-    par_number = 0;
+  endfor
+  ## Vector of predecessors has right format.
+
+  for i = 1:num_nodes
+    ## vec_of_child is helping vector which is used to speed up the
+    ## choice of descendant nodes.
+
+    num_children(tree(i)+1) = num_children(tree(i)+1) + 1;
+  endfor
+
+  pos = 1;
+  start = zeros (1, num_nodes+1);
+  xhelp = zeros (1, num_nodes+1);
+  stop = zeros (1, num_nodes+1);
+  for i = 1 : num_nodes + 1
+    start(i) = pos;
+    xhelp(i) = pos;
+    pos += num_children(i);
+    stop(i) = pos;
+  endfor
 
-    ## The x-coordinate of the left most descendant of "parent node"
-    ## this value is increased in each leaf.
-    left_most = 0;
+  if (nargin == 1)
+    for i = 1:num_nodes
+      vec_of_child(xhelp(tree(i)+1)) = i;
+      xhelp(tree(i)+1) = xhelp(tree(i)+1) + 1;
+    endfor
+  else
+    vec_of_child = permutation;
+  endif
 
-    ## The level of "parent" node (root level is num_nodes).
-    level = num_nodes;
+  ## The number of "parent" (actual) node (it's descendants will be
+  ## browse in the next iteration).
+  par_number = 0;
 
-    ## num_nodes - max_ht is the height of this graph.
-    max_ht = num_nodes;
+  ## The x-coordinate of the left most descendant of "parent node"
+  ## this value is increased in each leaf.
+  left_most = 0;
+
+  ## The level of "parent" node (root level is num_nodes).
+  level = num_nodes;
+
+  ## num_nodes - max_ht is the height of this graph.
+  max_ht = num_nodes;
 
-    ## Main stack - each item consists of two numbers - the number of
-    ## node and the number it's of parent node on the top of stack
-    ## there is "parent node".
-    stk = [-1, 0];
+  ## Main stack - each item consists of two numbers - the number of
+  ## node and the number it's of parent node on the top of stack
+  ## there is "parent node".
+  stk = [-1, 0];
+
+  ## Number of vertices s in the top-level separator.
+  s = 0;
+  ## Flag which says if we are in top level separator.
+  top_level = 1;
+  ## The top of the stack.
+  while (par_number != -1)
+    if (start(par_number+1) < stop(par_number+1))
+      idx = vec_of_child(start(par_number+1) : stop(par_number+1) - 1);
+    else
+      idx = zeros (1, 0);
+    endif
+
+    ## Add to idx the vector of parent descendants.
+    stk = [stk; [idx', ones(fliplr(size(idx))) * par_number]];
 
-    ## Number of vertices s in the top-level separator.
-    s = 0;
-    ## Flag which says if we are in top level separator.
-    top_level = 1;
-    ## The top of the stack.
-    while (par_number != -1)
-      if (start(par_number+1) < stop(par_number+1))
-        idx = vec_of_child(start(par_number+1) : stop(par_number+1) - 1);
-      else
-        idx = zeros (1, 0);
+    ## We are in top level separator when we have one child and the
+    ## flag is 1
+    if (columns (idx) == 1 && top_level == 1)
+      s += 1;
+    else
+      ## We aren't in top level separator now.
+      top_level = 0;
+    endif
+    ## If there is not any descendant of "parent node":
+    if (stk(end,2) != par_number)
+     left_most += 1;
+     x_coordinate_r(par_number) = left_most;
+     max_ht = min (max_ht, level);
+     if (length (stk) > 1 && find ((shift (stk,1) - stk) == 0) > 1
+         && stk(end,2) != stk(end-1,2))
+        ## Return to the nearest branching the position to return
+        ## position is the position on the stack, where should be
+        ## started further search (there are two nodes which has the
+        ## same parent node).
+
+        position = (find ((shift (stk(:,2), 1) - stk(:,2)) == 0))(end) + 1;
+        par_number_vec = stk(position:end,2);
+
+        ## The vector of removed nodes (the content of stack form
+        ## position to end).
+
+        level += length (par_number_vec);
+
+        ## The level have to be decreased.
+
+        x_coordinate_r(par_number_vec) = left_most;
+        stk(position:end,:) = [];
       endif
 
-      ## Add to idx the vector of parent descendants.
-      stk = [stk; [idx', ones(fliplr(size(idx))) * par_number]];
-
-      ## We are in top level separator when we have one child and the
-      ## flag is 1
-      if (columns (idx) == 1 && top_level == 1)
-        s += 1;
-      else
-        ## We aren't in top level separator now.
-        top_level = 0;
-      endif
-      ## If there is not any descendant of "parent node":
-      if (stk(end,2) != par_number)
-       left_most += 1;
-       x_coordinate_r(par_number) = left_most;
-       max_ht = min (max_ht, level);
-       if (length (stk) > 1 && find ((shift (stk,1) - stk) == 0) > 1
-           && stk(end,2) != stk(end-1,2))
-          ## Return to the nearest branching the position to return
-          ## position is the position on the stack, where should be
-          ## started further search (there are two nodes which has the
-          ## same parent node).
-
-          position = (find ((shift (stk(:,2), 1) - stk(:,2)) == 0))(end) + 1;
-          par_number_vec = stk(position:end,2);
+      ## Remove the next node from "searched branch".
 
-          ## The vector of removed nodes (the content of stack form
-          ## position to end).
-
-          level += length (par_number_vec);
-
-          ## The level have to be decreased.
-
-          x_coordinate_r(par_number_vec) = left_most;
-          stk(position:end,:) = [];
-        endif
-
-        ## Remove the next node from "searched branch".
-
-        stk(end,:) = [];
-        ## Choose new "parent node".
-        par_number = stk(end,1);
-        ## If there is another branch start to search it.
-        if (par_number != -1)
-          y_coordinate(par_number) = level;
-          x_coordinate_l(par_number) = left_most + 1;
-        endif
-      else
-
-        ## There were descendants of "parent nod" choose the last of
-        ## them and go on through it.
-        level -= 1;
-        par_number = stk(end,1);
+      stk(end,:) = [];
+      ## Choose new "parent node".
+      par_number = stk(end,1);
+      ## If there is another branch start to search it.
+      if (par_number != -1)
         y_coordinate(par_number) = level;
         x_coordinate_l(par_number) = left_most + 1;
       endif
-    endwhile
+    else
 
-    ## Calculate the x coordinates (the known values are the position
-    ## of most left and most right descendants).
-    x_coordinate = (x_coordinate_l + x_coordinate_r) / 2;
+      ## There were descendants of "parent nod" choose the last of
+      ## them and go on through it.
+      level -= 1;
+      par_number = stk(end,1);
+      y_coordinate(par_number) = level;
+      x_coordinate_l(par_number) = left_most + 1;
+    endif
+  endwhile
 
-    height = num_nodes - max_ht - 1;
-  endif
+  ## Calculate the x coordinates (the known values are the position
+  ## of most left and most right descendants).
+  x_coordinate = (x_coordinate_l + x_coordinate_r) / 2;
+
+  height = num_nodes - max_ht - 1;
+
 endfunction
 
 
 %!test
 %! % Compute a simple tree layout
 %! [x, y, h, s] = treelayout ([0, 1, 2, 2]);
 %! assert (x, [1.5, 1.5, 2, 1]);
 %! assert (y, [3, 2, 1, 1]);
diff --git a/scripts/specfun/expint.m b/scripts/specfun/expint.m
--- a/scripts/specfun/expint.m
+++ b/scripts/specfun/expint.m
@@ -147,16 +147,17 @@ function y = expint_Ei (x)
         y(t) = -(xt^2 - a1*xt + a2) ...
                / ((xt^2 - b1*xt + b2) * (-xt) * exp (-xt)) ...
                - i*pi;
       else
         y(t) = conj (expint_Ei (conj (xt)));
       endif;
     endif
   endfor
+
 endfunction
 
 
 ## Test against A&S Table 5.1
 %!test
 %! x = [5:5:50]'/100;
 %! gamma = 0.5772156649;
 %! y_exp = [0.9876375971;
diff --git a/scripts/specfun/isprime.m b/scripts/specfun/isprime.m
--- a/scripts/specfun/isprime.m
+++ b/scripts/specfun/isprime.m
@@ -126,16 +126,17 @@ function t = isprime (x)
       m = cast (sort (m), class (x));
       t |= lookup (m, x, "b");
     endif
   endif
 
 endfunction
 
 function t = isgaussianprime (z)
+
   ## Assume prime unless proven otherwise
   t = true (size (z));
 
   x = real (z);
   y = imag (z);
 
   ## If purely real or purely imaginary, ordinary prime test for
   ## that complex part if that part is 3 mod 4.
@@ -144,16 +145,17 @@ function t = isgaussianprime (z)
 
   t(xidx) &= isprime (x(xidx));
   t(yidx) &= isprime (y(yidx));
 
   ## Otherwise, prime if x^2 + y^2 is prime
   zidx = ! (xidx | yidx);          # Skip entries that were already evaluated
   zabs = x(zidx).^2 + y(zidx).^2;
   t(zidx) &= isprime (zabs);
+
 endfunction
 
 
 %!assert (isprime (3), true)
 %!assert (isprime (4), false)
 %!assert (isprime (5i), false)
 %!assert (isprime (7i), true)
 %!assert (isprime ([1+2i, (2+3i)*(-1+2i)]), [true, false])
diff --git a/scripts/statistics/base/lscov.m b/scripts/statistics/base/lscov.m
--- a/scripts/statistics/base/lscov.m
+++ b/scripts/statistics/base/lscov.m
@@ -106,16 +106,17 @@ function [x, stdx, mse, S] = lscov (A, b
       S = mse * s;
     else
       S = nan (p, p, k);
       for i = 1:k
         S(:, :, i) = mse(i) * s;
       endfor
     endif
   endif
+
 endfunction
 
 
 %!test
 %! ## Longley data from the NIST Statistical Reference Dataset
 %! Z = [  60323    83.0   234289   2356     1590    107608  1947
 %!        61122    88.5   259426   2325     1456    108632  1948
 %!        60171    88.2   258054   3682     1616    109773  1949
diff --git a/scripts/statistics/base/mode.m b/scripts/statistics/base/mode.m
--- a/scripts/statistics/base/mode.m
+++ b/scripts/statistics/base/mode.m
@@ -98,16 +98,17 @@ function [m, f, c] = mode (x, dim)
     m = sparse (sz2(1), sz2(2));
   else
     m = zeros (sz2, class (x));
   endif
   for i = 1 : prod (sz2)
     c{i} = xs(t2(:, i) == f(i), i);
     m(i) = c{i}(1);
   endfor
+
 endfunction
 
 
 %!test
 %! [m, f, c] = mode (toeplitz (1:5));
 %! assert (m, [1,2,2,2,1]);
 %! assert (f, [1,2,2,2,1]);
 %! assert (c, {[1;2;3;4;5],[2],[2;3],[2],[1;2;3;4;5]});
diff --git a/scripts/statistics/distributions/binoinv.m b/scripts/statistics/distributions/binoinv.m
--- a/scripts/statistics/distributions/binoinv.m
+++ b/scripts/statistics/distributions/binoinv.m
@@ -74,16 +74,17 @@ function inv = binoinv (x, n, p)
 
 endfunction
 
 ## Core algorithm to calculate the inverse binomial, for n and p real scalars
 ## and y a column vector, and for which the output is not NaN or Inf.
 ## Compute CDF in batches of doubling size until CDF > x, or answer > 500
 ## Return the locations of unfinished cases in k.
 function [m, k] = scalar_binoinv (x, n, p)
+
   k = 1:length (x);
   m = zeros (size (x));
   prev_limit = 0;
   limit = 10;
   cdf = 0;
   v = 0;
   do
     cdf = binocdf (prev_limit:limit-1, n, p);
@@ -99,16 +100,17 @@ function [m, k] = scalar_binoinv (x, n, 
 endfunction
 
 ## Core algorithm to calculate the inverse binomial, for n, p, and y column
 ## vectors, and for which the output is not NaN or Inf.
 ## Compute CDF in batches of doubling size until CDF > x, or answer > 500
 ## Return the locations of unfinished cases in k.
 ## Calculates CDF by summing PDF, which is faster than calls to binocdf.
 function [m, k] = vector_binoinv (x, n, p)
+
   k = 1:length(x);
   m = zeros (size (x));
   prev_limit = 0;
   limit = 10;
   cdf = 0;
   v = 0;
   do
     xx = repmat (prev_limit:limit-1, [length(k), 1]);
@@ -130,16 +132,17 @@ endfunction
 
 ## Vectorized binary search.
 ## Can handle vectors n and p, and is faster than the scalar case when the
 ## answer is large.
 ## Could be optimized to call binocdf only for a subset of the x at each stage,
 ## but care must be taken to handle both scalar and vector n, p.  Bookkeeping
 ## may cost more than the extra computations.
 function m = bin_search_binoinv (x, n, p)
+
   k = 1:length (x);
   lower = zeros (size (x));
   limit = 500;              # lower bound on point at which prev phase finished
   while (any (k) && limit < 1e100)
     cdf = binocdf (limit, n, p);
     k = (x > cdf);
     lower(k) = limit;
     limit += limit;
@@ -150,16 +153,17 @@ function m = bin_search_binoinv (x, n, p
     mid = (upper + lower)/2;
     cdf = binocdf (floor(mid(:)), n, p);
     r = (x <= cdf);
     upper(r)  = mid(r);
     lower(! r) = mid(! r);
   endfor
   m = ceil (lower);
   m(x > binocdf (m(:), n, p)) += 1;  # fix off-by-one errors from binary search
+
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
 %!assert (binoinv (x, 2*ones (1,5), 0.5*ones (1,5)), [NaN 0 1 2 NaN])
 %!assert (binoinv (x, 2, 0.5*ones (1,5)), [NaN 0 1 2 NaN])
 %!assert (binoinv (x, 2*ones (1,5), 0.5), [NaN 0 1 2 NaN])
diff --git a/scripts/statistics/distributions/nbininv.m b/scripts/statistics/distributions/nbininv.m
--- a/scripts/statistics/distributions/nbininv.m
+++ b/scripts/statistics/distributions/nbininv.m
@@ -78,16 +78,17 @@ function inv = nbininv (x, n, p)
 endfunction
 
 
 ## Core algorithm to calculate the inverse negative binomial, for n and p real
 ## scalars and y a column vector, and for which the output is not NaN or Inf.
 ## Compute CDF in batches of doubling size until CDF > x, or answer > 500.
 ## Return the locations of unfinished cases in k.
 function [m, k] = scalar_nbininv (x, n, p)
+
   k = 1:length (x);
   m = zeros (size (x));
   prev_limit = 0;
   limit = 10;
   do
     cdf = nbincdf (prev_limit:limit, n, p);
     r = bsxfun (@le, x(k), cdf);
     [v, m(k)] = max (r, [], 2);     # find first instance of x <= cdf
@@ -102,16 +103,17 @@ endfunction
 
 ## Vectorized binary search.
 ## Can handle vectors n and p, and is faster than the scalar case when the
 ## answer is large.
 ## Could be optimized to call nbincdf only for a subset of the x at each stage,
 ## but care must be taken to handle both scalar and vector n,p.  Bookkeeping
 ## may cost more than the extra computations.
 function m = bin_search_nbininv (x, n, p)
+
   k = 1:length (x);
   lower = zeros (size (x));
   limit = 1;
   while (any (k) && limit < 1e100)
     cdf = nbincdf (limit, n, p);
     k = (x > cdf);
     lower(k) = limit;
     limit += limit;
diff --git a/scripts/statistics/distributions/poissinv.m b/scripts/statistics/distributions/poissinv.m
--- a/scripts/statistics/distributions/poissinv.m
+++ b/scripts/statistics/distributions/poissinv.m
@@ -100,16 +100,17 @@ endfunction
 
 ## The following is based on Mike Giles's CUDA implementation,
 ## [http://people.maths.ox.ac.uk/gilesm/codes/poissinv/poissinv_cuda.h]
 ## which is copyright by the University of Oxford
 ## and is provided under the terms of the GNU GPLv3 license:
 ## http://www.gnu.org/licenses/gpl.html
 
 function inv = analytic_approx (x, lambda)
+
   s = norminv (x, 0, 1) ./ sqrt (lambda);
   k = (s > -0.6833501) & (s < 1.777993);
   ## use polynomial approximations in central region
   if (any (k))
     lam = lambda(k);
     if (isscalar (s))
       sk = s;
     else
diff --git a/scripts/testfun/__have_feature__.m b/scripts/testfun/__have_feature__.m
--- a/scripts/testfun/__have_feature__.m
+++ b/scripts/testfun/__have_feature__.m
@@ -17,27 +17,30 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {} __have_feature__ (feature)
 ## Undocumented internal function.
 ## @end deftypefn
 
 function retval = __have_feature__ (feature)
+
   if (strncmp (feature, "ENABLE_", 7))
     features = __octave_config_info__ ();
   else
     features = __octave_config_info__ ("build_features");
   endif
+
   if (iscellstr (feature))
     retval = (all (isfield (features, feature))
               && cellfun (@(x) features.(x), feature));
   elseif (ischar (feature))
     retval = isfield (features, feature) && features.(feature);
   else
     retval = false;
   endif
+
 endfunction
 
 
 ## No test coverage for internal function.  It is tested through calling fcn.
 %!assert (1)
 
diff --git a/scripts/testfun/__printf_assert__.m b/scripts/testfun/__printf_assert__.m
--- a/scripts/testfun/__printf_assert__.m
+++ b/scripts/testfun/__printf_assert__.m
@@ -18,15 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {} {} __printf_assert__ (@dots{})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function __printf_assert__ (varargin)
   global _assert_printf = "";
+
   _assert_printf = cat (2, _assert_printf, sprintf (varargin{:}));
+
 endfunction
 
 
 ## No test coverage for internal function.  It is tested through calling fcn.
 %!assert (1)
 
diff --git a/scripts/testfun/__prog_output_assert__.m b/scripts/testfun/__prog_output_assert__.m
--- a/scripts/testfun/__prog_output_assert__.m
+++ b/scripts/testfun/__prog_output_assert__.m
@@ -18,22 +18,25 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {} {} __prog_output_assert__ (@var{str})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function ret = __prog_output_assert__ (str)
   global _assert_printf = "";
+
   if (isempty (_assert_printf))
     ret = isempty (str);
   elseif (_assert_printf(end) == "\n")
     ret = strcmp (_assert_printf(1:(end-1)), str);
   else
     ret = strcmp (_assert_printf, str);
   endif
+
   _assert_printf = "";
+
 endfunction
 
 
 ## No test coverage for internal function.  It is tested through calling fcn.
 %!assert (1)
 
diff --git a/scripts/testfun/__run_test_suite__.m b/scripts/testfun/__run_test_suite__.m
--- a/scripts/testfun/__run_test_suite__.m
+++ b/scripts/testfun/__run_test_suite__.m
@@ -129,80 +129,87 @@ function [pass, fail, xfail, skip] = __r
 endfunction
 
 function print_test_file_name (nm)
   filler = repmat (".", 1, 60-length (nm));
   printf ("  %s %s", nm, filler);
 endfunction
 
 function print_pass_fail (p, n, xf, sk)
+
   if ((n + sk) > 0)
     printf (" PASS   %4d/%-4d", p, n);
     nfail = n - p - xf;
     if (nfail > 0)
       printf ("\n%71s %3d", "FAIL ", nfail);
     endif
     if (sk > 0)
       printf ("\n%71s %3d", "SKIP ", sk);
     endif
     if (xf > 0)
       printf ("\n%71s %3d", "XFAIL", xf);
     endif
   endif
   puts ("\n");
+
 endfunction
 
 function retval = has_functions (f)
+
   n = length (f);
   if (n > 3 && strcmpi (f((end-2):end), ".cc"))
     fid = fopen (f);
-    if (fid >= 0)
-      str = fread (fid, "*char")';
-      fclose (fid);
-      retval = ! isempty (regexp (str,'^(DEFUN|DEFUN_DLD)\>',
-                                      'lineanchors', 'once'));
-    else
+    if (fid < 0)
       error ("__run_test_suite__: fopen failed: %s", f);
     endif
+    str = fread (fid, "*char")';
+    fclose (fid);
+    retval = ! isempty (regexp (str,'^(DEFUN|DEFUN_DLD)\>',
+                                    'lineanchors', 'once'));
   elseif (n > 2 && strcmpi (f((end-1):end), ".m"))
     retval = true;
   else
     retval = false;
   endif
+
 endfunction
 
 function retval = has_tests (f)
+
   fid = fopen (f);
-  if (fid >= 0)
-    str = fread (fid, "*char")';
-    fclose (fid);
-    retval = ! isempty (regexp (str,
-                                '^%!(assert|error|fail|test|xtest|warning)',
-                                'lineanchors', 'once'));
-  else
+  if (fid < 0)
     error ("__run_test_suite__: fopen failed: %s", f);
   endif
+
+  str = fread (fid, "*char")';
+  fclose (fid);
+  retval = ! isempty (regexp (str,
+                              '^%!(assert|error|fail|test|xtest|warning)',
+                              'lineanchors', 'once'));
+
 endfunction
 
 function [dp, dn, dxf, dsk] = run_test_dir (fid, d);
   global files_with_tests;
   global files_with_no_tests;
+
   lst = dir (d);
   dp = dn = dxf = dsk = 0;
   for i = 1:length (lst)
     nm = lst(i).name;
     if (lst(i).isdir
         && nm(1) != "." && ! strcmp (nm, "private") && nm(1) != "@")
       [p, n, xf, sk] = run_test_dir (fid, [d, filesep, nm]);
       dp += p;
       dn += n;
       dxf += xf;
       dsk += sk;
     endif
   endfor
+
   saved_dir = pwd ();
   unwind_protect
     cd (d);
     for i = 1:length (lst)
       nm = lst(i).name;
       if (length (nm) > 4 && strcmpi (nm((end-3):end), ".tst"))
         p = n = xf = sk = 0;
         ffnm = fullfile (d, nm);
@@ -218,35 +225,38 @@ function [dp, dn, dxf, dsk] = run_test_d
         dn += n;
         dxf += xf;
         dsk += sk;
       endif
     endfor
   unwind_protect_cleanup
     cd (saved_dir);
   end_unwind_protect
+
 endfunction
 
 function [dp, dn, dxf, dsk] = run_test_script (fid, d);
   global files_with_tests;
   global files_with_no_tests;
   global topsrcdir;
   global topbuilddir;
+
   lst = dir (d);
   dp = dn = dxf = dsk = 0;
   for i = 1:length (lst)
     nm = lst(i).name;
     if (lst(i).isdir && nm(1) != ".")
       [p, n, xf, sk] = run_test_script (fid, [d, filesep, nm]);
       dp += p;
       dn += n;
       dxf += xf;
       dsk += sk;
     endif
   endfor
+
   for i = 1:length (lst)
     nm = lst(i).name;
     ## Ignore hidden files
     if (nm(1) == '.')
       continue
     endif
     f = fullfile (d, nm);
     if ((length (nm) > 2 && strcmpi (nm((end-1):end), ".m"))
@@ -269,16 +279,17 @@ function [dp, dn, dxf, dsk] = run_test_s
       else
         ## To reduce the list length, only mark .cc files that contain
         ## DEFUN definitions.
         files_with_no_tests(end+1) = f;
       endif
     endif
   endfor
   ##  printf("%s%s -> passes %d of %d tests\n", ident, d, dp, dn);
+
 endfunction
 
 function n = num_elts_matching_pattern (lst, pat)
   n = sum (! cellfun ("isempty", regexp (lst, pat, 'once')));
 endfunction
 
 function report_files_with_no_tests (with, without, typ)
   pat = ['\' typ "$"];
diff --git a/scripts/testfun/demo.m b/scripts/testfun/demo.m
--- a/scripts/testfun/demo.m
+++ b/scripts/testfun/demo.m
@@ -147,29 +147,32 @@ function demo (name, n = 0)
       printf ("%s example %d: failed\n%s\n", name, doidx(i), lasterr ());
     end_try_catch
     clear __demo__;
   endfor
 
 endfunction
 
 function clear_figures ()
-  ## Prevent proliferation of figure windows.  If any figure windows
-  ## exist, close all but one and clear the one remaining.
+
+  ## Prevent proliferation of figure windows.  If any figure windows exist,
+  ## close all but one and clear the one remaining.
   figs = __go_figure_handles__ ();
   if (! isempty (figs))
     if (numel (figs) > 1)
       figs = sort (figs);
       figs(1) = [];
       close (figs);
     endif
     clf ("reset");
   endif
+
 endfunction
 
+
 %!demo
 %! t = 0:0.01:2*pi;
 %! x = sin (t);
 %! plot (t, x);
 %! title ("one cycle of a sine wave");
 %! #-------------------------------------------------
 %! # the figure window shows one cycle of a sine wave
 
diff --git a/scripts/testfun/private/compare_plot_demos.m b/scripts/testfun/private/compare_plot_demos.m
--- a/scripts/testfun/private/compare_plot_demos.m
+++ b/scripts/testfun/private/compare_plot_demos.m
@@ -103,18 +103,20 @@ function compare_plot_demos (varargin)
           disp (lasterror);
         end_try_catch
       endif
       cd (cwd);
     endfor
   unwind_protect_cleanup
     rmpath (cwd);
   end_unwind_protect
+
   if (! strcmp (arg.toolkits, "matlab"))
     ## Generate the html comparison of the images
     html_compare_plot_demos (arg.toolkits);
   else
     ## We need to run matlab manually before the html page can be created
     printf ('\nNow run %s in Matlab.\nAfter this run html_compare_plot_demos,\n', arg.fcn_file);
     printf ('for example html_compare_plot_demos ({"fltk", "gnuplot", "matlab"}), to create the html page.\n');
   endif
+
 endfunction
 
diff --git a/scripts/testfun/private/dump_demos.m b/scripts/testfun/private/dump_demos.m
--- a/scripts/testfun/private/dump_demos.m
+++ b/scripts/testfun/private/dump_demos.m
@@ -90,19 +90,21 @@ function dump_demos (dirs={"plot/appeara
   ## Stop and flush diary
   fprintf (fid, "diary off\n");
 
   ## Create script ending
   fprintf (fid, "end\n\n")
 
   ## Close script
   fclose (fid);
+
 endfunction
 
 function dump_all_demos (directory, fid, fmt)
+
   dirinfo = dir (fullfile (directory, "*.m"));
   flist = {dirinfo.name};
   ## Remove uigetdir, uigetfile, uiputfile, etc.
   flist = flist(! strncmp (flist, "ui", 2));
   ## Remove linkaxes, linkprops
   flist = flist(! strncmp (flist, "link", 4));
   ## Remove colormap
   flist = flist(! strncmp (flist, "colormap", 8));
@@ -142,29 +144,33 @@ function dump_all_demos (directory, fid,
       fprintf (fid, "  fprintf ('ERROR in %s: %%s\\n', lasterr ());\n", base_fn);
       fprintf (fid, "  err_fid = fopen ('%s.err', 'w');\n", base_fn);
       fprintf (fid, "  fprintf (err_fid, '%%s', lasterr ());\n");
       fprintf (fid, "  fclose (err_fid);\n");
       fprintf (fid, "end\n\n");
     endfor
   endfor
   fprintf (fid, "close all\n");
+
 endfunction
 
 function retval = get_demos (fcn)
+
   [code, idx] = test (fcn, "grabdemo");
   num_demos = length (idx) - 1;
   retval = cell (1, num_demos);
   ## Now split the demos into a cell array
   for k = 1:num_demos
     retval{k} = oct2mat (code(idx(k):idx(k+1)-1));
   endfor
+
 endfunction
 
 function code = oct2mat (code)
+
   ## Simple hacks to make things Matlab compatible
   code = strrep (code, "%!", "%%");
   code = strrep (code, "!", "~");
   ## Simply replacing double quotes with single quotes
   ## causes problems with strings like 'hello "world"'
   ## More complicated regexprep targets only full double quoted strings
   code = regexprep (code, "^([^']*)\"(.*)\"", "$1'$2'",
                           "lineanchors", "dotexceptnewline");
@@ -178,10 +184,11 @@ function code = oct2mat (code)
   endfor
   commentkeywords = {"unwind_protect", "end_unwind_protect"};
   for k = 1:numel (commentkeywords)
     code = strrep (code, commentkeywords{k}, ["%" commentkeywords{k}]);
   endfor
 
   ## Fix up sombrero which now has default argument in Octave
   code = strrep (code, "sombrero ()", "sombrero (41)");
+
 endfunction
 
diff --git a/scripts/testfun/rundemos.m b/scripts/testfun/rundemos.m
--- a/scripts/testfun/rundemos.m
+++ b/scripts/testfun/rundemos.m
@@ -57,16 +57,17 @@ function rundemos (directory)
   for i = 1:numel (dirs)
     d = dirs{i};
     run_all_demos (d, do_class_dirs);
   endfor
 
 endfunction
 
 function run_all_demos (directory, do_class_dirs)
+
   flist = readdir (directory);
   dirs = {};
   for i = 1:numel (flist)
     f = flist{i};
     if ((length (f) > 2 && strcmpi (f((end-1):end), ".m"))
         || (length (f) > 3 && strcmpi (f((end-2):end), ".cc")))
       f = fullfile (directory, f);
       if (has_demos (f))
@@ -89,25 +90,28 @@ function run_all_demos (directory, do_cl
 
   ## Recurse into class directories since they are implied in the path
   if (do_class_dirs)
     for i = 1:numel (dirs)
       d = dirs{i};
       run_all_demos (d, false);
     endfor
   endif
+
 endfunction
 
 function retval = has_demos (f)
+
   fid = fopen (f);
   if (f < 0)
     error ("rundemos: fopen failed: %s", f);
-  else
-    str = fread (fid, "*char").';
-    fclose (fid);
-    retval = ! isempty (regexp (str, '^%!demo', 'lineanchors', 'once'));
   endif
+
+  str = fread (fid, "*char").';
+  fclose (fid);
+  retval = ! isempty (regexp (str, '^%!demo', 'lineanchors', 'once'));
+
 endfunction
 
 
 %!error rundemos ("foo", 1)
 %!error <DIRECTORY argument> rundemos ("#_TOTALLY_/_INVALID_/_PATHNAME_#")
 
diff --git a/scripts/testfun/runtests.m b/scripts/testfun/runtests.m
--- a/scripts/testfun/runtests.m
+++ b/scripts/testfun/runtests.m
@@ -57,16 +57,17 @@ function runtests (directory)
   for i = 1:numel (dirs)
     d = dirs{i};
     run_all_tests (d, do_class_dirs);
   endfor
 
 endfunction
 
 function run_all_tests (directory, do_class_dirs)
+
   flist = readdir (directory);
   dirs = {};
   no_tests = {};
   printf ("Processing files in %s:\n\n", directory);
   fflush (stdout);
   for i = 1:numel (flist)
     f = flist{i};
     if ((length (f) > 2 && strcmpi (f((end-1):end), ".m"))
@@ -94,62 +95,68 @@ function run_all_tests (directory, do_cl
 
   ## Recurse into class directories since they are implied in the path
   if (do_class_dirs)
     for i = 1:numel (dirs)
       d = dirs{i};
       run_all_tests (d, false);
     endfor
   endif
+
 endfunction
 
 function retval = has_functions (f)
+
   n = length (f);
   if (n > 3 && strcmpi (f((end-2):end), ".cc"))
     fid = fopen (f);
-    if (fid >= 0)
-      str = fread (fid, "*char")';
-      fclose (fid);
-      retval = ! isempty (regexp (str,'^(?:DEFUN|DEFUN_DLD|DEFUNX)\>',
-                                      'lineanchors', 'once'));
-    else
+    if (fid < 0)
       error ("runtests: fopen failed: %s", f);
     endif
+    str = fread (fid, "*char")';
+    fclose (fid);
+    retval = ! isempty (regexp (str,'^(?:DEFUN|DEFUN_DLD|DEFUNX)\>',
+                                    'lineanchors', 'once'));
   elseif (n > 2 && strcmpi (f((end-1):end), ".m"))
     retval = true;
   else
     retval = false;
   endif
+
 endfunction
 
 function retval = has_tests (f)
+
   fid = fopen (f);
-  if (fid >= 0)
-    str = fread (fid, "*char").';
-    fclose (fid);
-    retval = ! isempty (regexp (str, '^%!(?:test|xtest|assert|error|warning)',
-                                     'lineanchors', 'once'));
-  else
+  if (fid < 0)
     error ("runtests: fopen failed: %s", f);
   endif
+
+  str = fread (fid, "*char").';
+  fclose (fid);
+  retval = ! isempty (regexp (str, '^%!(?:test|xtest|assert|error|warning)',
+                                   'lineanchors', 'once'));
+
 endfunction
 
 function print_pass_fail (n, p, xf)
+
   if (n > 0)
     printf (" PASS %4d/%-4d", p, n);
     nfail = n - p;
     if (nfail > 0)
       if (nfail != xf)
         printf (" FAIL %d", nfail - xf);
       else
         printf (" XFAIL %d", xf);
       endif
     endif
   endif
   puts ("\n");
+
 endfunction
 
 function print_test_file_name (nm)
   filler = repmat (".", 1, 55-length (nm));
   printf ("  %s %s", nm, filler);
 endfunction
 
 
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -684,16 +684,17 @@ endfunction
 function s = var2struct (varargin)
   for i = 1:nargin
     s.(deblank (argn(i,:))) = varargin{i};
   endfor
 endfunction
 
 ## Find [start,end] of fn in 'function [a,b] = fn'.
 function pos = function_name (def)
+
   pos = [];
 
   ## Find the end of the name.
   right = find (def == "(", 1);
   if (isempty (right))
     return;
   endif
   right = find (def(1:right-1) != " ", 1, "last");
@@ -703,34 +704,37 @@ function pos = function_name (def)
                find(def(1:right)=="=", 1, "last")]);
   if (isempty (left))
     return;
   endif
   left += 1;
 
   ## Return the end points of the name.
   pos = [left, right];
+
 endfunction
 
 ## Strip <pattern> from '<pattern> code'.
 ## Also handles 'id=ID code'
 function [pattern, id, rest] = getpattern (str)
+
   pattern = ".";
   id = [];
   rest = str;
   str = trimleft (str);
   if (! isempty (str) && str(1) == "<")
     close = index (str, ">");
     if (close)
       pattern = str(2:close-1);
       rest = str(close+1:end);
     endif
   elseif (strncmp (str, "id=", 3))
     [id, rest] = strtok (str(4:end));
   endif
+
 endfunction
 
 ## Strip '.*prefix:' from '.*prefix: msg\n' and strip trailing blanks.
 function msg = trimerr (msg, prefix)
   idx = index (msg, [prefix ":"]);
   if (idx > 0)
     msg(1:idx+length(prefix)) = [];
   endif
