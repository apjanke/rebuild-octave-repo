# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1294617665 28800
#      Sun Jan 09 16:01:05 2011 -0800
# Node ID 994e2a93a8e211904fdcd0a4e19d5821072bb05b
# Parent  eb9e0b597d61eb1bfe6499239d4b0c35ae05dbca
Use uppercase 'A' to refer to matrix inputs in m-files.

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,26 @@
+2011-01-09  Rik  <octave@nomad.inbox5.com>
+
+	* general/arrayfun.m, general/blkdiag.m, general/structfun.m,
+	image/imagesc.m, linear-algebra/cond.m, linear-algebra/condest.m,
+	linear-algebra/expm.m, linear-algebra/logm.m,
+	linear-algebra/onenormest.m, linear-algebra/qzhess.m,
+	optimization/glpk.m, optimization/glpkmex.m, polynomial/poly.m,
+	sparse/gplot.m, sparse/pcg.m, sparse/pcr.m, sparse/spaugment.m,
+	sparse/spdiags.m, sparse/svds.m: Use uppercase 'A' to refer to matrix
+	argument.
+
+	* io/dlmwrite.m: Use uppercase 'M' to refer to matrix argument.
+
+	* io/textscan.m: Use uppercase 'C' to refer to Cell Array output.
+	Improve docstring.
+
+	* signal/unwrap.m: Use 'x' instead of 'a' for vector input argument.
+
 2011-01-09  Rik  <octave@nomad.inbox5.com>
 
 	* general/bicubic.m, general/nargchk.m, general/nargoutchk.m,
 	linear-algebra/krylov.m, linear-algebra/krylovb.m,
 	linear-algebra/normest.m, linear-algebra/null.m, linear-algebra/orth.m,
 	linear-algebra/rank.m: Use common names for variables in documentation
 	and code.
 
diff --git a/scripts/general/arrayfun.m b/scripts/general/arrayfun.m
--- a/scripts/general/arrayfun.m
+++ b/scripts/general/arrayfun.m
@@ -13,32 +13,32 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} arrayfun (@var{func}, @var{a})
-## @deftypefnx {Function File} {@var{x} =} arrayfun (@var{func}, @var{a})
-## @deftypefnx {Function File} {@var{x} =} arrayfun (@var{func}, @var{a}, @var{b}, @dots{})
-## @deftypefnx {Function File} {[@var{x}, @var{y}, @dots{}] =} arrayfun (@var{func}, @var{a}, @dots{})
+## @deftypefn  {Function File} {} arrayfun (@var{func}, @var{A})
+## @deftypefnx {Function File} {@var{x} =} arrayfun (@var{func}, @var{A})
+## @deftypefnx {Function File} {@var{x} =} arrayfun (@var{func}, @var{A}, @var{b}, @dots{})
+## @deftypefnx {Function File} {[@var{x}, @var{y}, @dots{}] =} arrayfun (@var{func}, @var{A}, @dots{})
 ## @deftypefnx {Function File} {} arrayfun (@dots{}, "UniformOutput", @var{val})
 ## @deftypefnx {Function File} {} arrayfun (@dots{}, "ErrorHandler", @var{errfunc})
 ##
 ## Execute a function on each element of an array.  This is useful for
 ## functions that do not accept array arguments.  If the function does
 ## accept array arguments it is better to call the function directly.
 ##
 ## The first input argument @var{func} can be a string, a function
 ## handle, an inline function or an anonymous function.  The input
-## argument @var{a} can be a logic array, a numeric array, a string
+## argument @var{A} can be a logic array, a numeric array, a string
 ## array, a structure array or a cell array.  By a call of the function
-## @command{arrayfun} all elements of @var{a} are passed on to the named
+## @command{arrayfun} all elements of @var{A} are passed on to the named
 ## function @var{func} individually.
 ## 
 ## The named function can also take more than two input arguments, with
 ## the input arguments given as third input argument @var{b}, fourth
 ## input argument @var{c}, @dots{}  If given more than one array input
 ## argument then all input arguments must have the same sizes, for
 ## example:
 ##
diff --git a/scripts/general/blkdiag.m b/scripts/general/blkdiag.m
--- a/scripts/general/blkdiag.m
+++ b/scripts/general/blkdiag.m
@@ -12,18 +12,18 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} blkdiag (@var{a}, @var{b}, @var{c}, @dots{})
-## Build a block diagonal matrix from @var{a}, @var{b}, @var{c}, @dots{}.
+## @deftypefn {Function File} {} blkdiag (@var{A}, @var{B}, @var{C}, @dots{})
+## Build a block diagonal matrix from @var{A}, @var{B}, @var{C}, @dots{}.
 ## All the arguments must be numeric and are two-dimensional matrices or
 ## scalars.
 ## @seealso{diag, horzcat, vertcat}
 ## @end deftypefn
 
 ## Author: Daniel Calvelo
 ## Modified by: William Poetra Yoga Hadisoeseno
 
diff --git a/scripts/general/structfun.m b/scripts/general/structfun.m
--- a/scripts/general/structfun.m
+++ b/scripts/general/structfun.m
@@ -14,17 +14,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} structfun (@var{func}, @var{S})
-## @deftypefnx {Function File} {[@var{a}, @dots{}] =} structfun (@dots{})
+## @deftypefnx {Function File} {[@var{A}, @dots{}] =} structfun (@dots{})
 ## @deftypefnx {Function File} {} structfun (@dots{}, "ErrorHandler", @var{errfunc})
 ## @deftypefnx {Function File} {} structfun (@dots{}, "UniformOutput", @var{val})
 ## 
 ## Evaluate the function named @var{name} on the fields of the structure
 ## @var{S}.  The fields of @var{S} are passed to the function @var{func}
 ## individually.
 ##
 ## @code{structfun} accepts an arbitrary function @var{func} in the form of 
diff --git a/scripts/image/imagesc.m b/scripts/image/imagesc.m
--- a/scripts/image/imagesc.m
+++ b/scripts/image/imagesc.m
@@ -13,30 +13,30 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} imagesc (@var{a})
-## @deftypefnx {Function File} {} imagesc (@var{x}, @var{y}, @var{a})
+## @deftypefn  {Function File} {} imagesc (@var{A})
+## @deftypefnx {Function File} {} imagesc (@var{x}, @var{y}, @var{A})
 ## @deftypefnx {Function File} {} imagesc (@dots{}, @var{limits})
 ## @deftypefnx {Function File} {} imagesc (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} imagesc (@dots{})
-## Display a scaled version of the matrix @var{a} as a color image.  The
+## Display a scaled version of the matrix @var{A} as a color image.  The
 ## colormap is scaled so that the entries of the matrix occupy the entire
 ## colormap.  If @var{limits} = [@var{lo}, @var{hi}] are given, then that
 ## range is set to the 'clim' of the current axes.
 ##
 ## The axis values corresponding to the matrix elements are specified in
 ## @var{x} and @var{y}, either as pairs giving the minimum and maximum
 ## values for the respective axes, or as values for each row and column
-## of the matrix @var{a}.
+## of the matrix @var{A}.
 ##
 ## @seealso{image, imshow, caxis}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
diff --git a/scripts/io/dlmwrite.m b/scripts/io/dlmwrite.m
--- a/scripts/io/dlmwrite.m
+++ b/scripts/io/dlmwrite.m
@@ -12,21 +12,21 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} dlmwrite (@var{file}, @var{a})
-## @deftypefnx {Function File} {} dlmwrite (@var{file}, @var{a}, @var{delim}, @var{r}, @var{c})
-## @deftypefnx {Function File} {} dlmwrite (@var{file}, @var{a}, @var{key}, @var{val} @dots{})
-## @deftypefnx {Function File} {} dlmwrite (@var{file}, @var{a}, "-append", @dots{})
-## Write the matrix @var{a} to the named file using delimiters.
+## @deftypefn  {Function File} {} dlmwrite (@var{file}, @var{M})
+## @deftypefnx {Function File} {} dlmwrite (@var{file}, @var{M}, @var{delim}, @var{r}, @var{c})
+## @deftypefnx {Function File} {} dlmwrite (@var{file}, @var{M}, @var{key}, @var{val} @dots{})
+## @deftypefnx {Function File} {} dlmwrite (@var{file}, @var{M}, "-append", @dots{})
+## Write the matrix @var{M} to the named file using delimiters.
 ##
 ## @var{file} should be a file name or writable file ID given by @code{fopen}.
 ##
 ## The parameter @var{delim} specifies the delimiter to use to separate
 ## values on a row.
 ##
 ## The value of @var{r} specifies the number of delimiter-only lines to
 ## add to the start of the file.
@@ -79,28 +79,28 @@
 ## This program was originally granted to the public domain
 ## 
 ## 2002-03-08 Paul Kienzle <pkienzle@users.sf.net>
 ## * Initial revision
 ## 2005-11-27 Bill Denney <bill@givebillmoney.com>
 ## * Significant modifications of the input arguements for additional
 ## functionality.
 
-function dlmwrite (file, a, varargin)
+function dlmwrite (file, M, varargin)
 
   if (nargin < 2 || ! ischar (file))
     print_usage ();
   endif
 
   ## set defaults
   delim = ",";
   r = 0;
   c = 0;
   newline = "\n";
-  if (ischar (a))
+  if (ischar (M))
     precision = "%c";
   else
     precision = "%.16g";
   endif
   opentype = "wt";
 
   ## process the input arguements
   i = 0;
@@ -164,38 +164,38 @@ function dlmwrite (file, a, varargin)
     error ("dlmwrite: file must be a string file ID");
   endif
 
   if (fid < 0)
     error (msg);
   else
     if (r > 0)
       fprintf (fid, "%s",
-               repmat ([repmat(delim, 1, c + columns(a)-1), newline], 1, r));
+               repmat ([repmat(delim, 1, c + columns(M)-1), newline], 1, r));
     endif
-    if (iscomplex (a))
+    if (iscomplex (M))
       cprecision = regexprep (precision, '^%([-.0-9])','%+$1');
       template = [precision, cprecision, "i", ...
                   repmat([delim, precision, cprecision, "i"], 1, ...
-                  columns(a) - 1), newline ];
+                  columns(M) - 1), newline ];
     else
-      template = [precision, repmat([delim, precision], 1, columns(a)-1),...
+      template = [precision, repmat([delim, precision], 1, columns(M)-1),...
                   newline];
     endif
     if (c > 0)
       template = [repmat(delim, 1, c), template];
     endif
-    if (iscomplex (a))
-      a = a.';
-      b = zeros (2*rows(a), columns (a));
-      b(1: 2 : end, :) = real (a);
-      b(2: 2 : end, :) = imag (a);
+    if (iscomplex (M))
+      M = M.';
+      b = zeros (2*rows(M), columns (M));
+      b(1: 2 : end, :) = real (M);
+      b(2: 2 : end, :) = imag (M);
       fprintf (fid, template, b);
     else
-      fprintf (fid, template, a.');
+      fprintf (fid, template, M.');
     endif
     if (! isscalar (file))
       fclose (fid);
     endif
   endif
 endfunction
 
 %!test
diff --git a/scripts/io/textscan.m b/scripts/io/textscan.m
--- a/scripts/io/textscan.m
+++ b/scripts/io/textscan.m
@@ -12,50 +12,50 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{c} =} textscan (@var{fid}, @var{format})
-## @deftypefnx {Function File} {@var{c} =} textscan (@var{fid}, @var{format}, @
+## @deftypefn  {Function File} {@var{C} =} textscan (@var{fid}, @var{format})
+## @deftypefnx {Function File} {@var{C} =} textscan (@var{fid}, @var{format}, @
 ## @var{n})
-## @deftypefnx {Function File} {@var{c} =} textscan (@var{fid}, @var{format}, @
+## @deftypefnx {Function File} {@var{C} =} textscan (@var{fid}, @var{format}, @
 ## @var{param}, @var{value}, @dots{})
-## @deftypefnx {Function File} {@var{c} =} textscan (@var{fid}, @var{format}, @
+## @deftypefnx {Function File} {@var{C} =} textscan (@var{fid}, @var{format}, @
 ## @var{n}, @var{param}, @var{value}, @dots{})
-## @deftypefnx {Function File} {@var{a} =} textscan (@var{str}, @dots{})
-## @deftypefnx {Function File} {[@var{a}, @var{position}] =} textscan (@dots{})
+## @deftypefnx {Function File} {@var{C} =} textscan (@var{str}, @dots{})
+## @deftypefnx {Function File} {[@var{C}, @var{position}] =} textscan (@dots{})
 ## Read data from a text file.
 ##
 ## The file associated with @var{fid} is read and parsed according to @var{format}.
 ## The function behaves like @code{strread} except it works by parsing a file
 ## instead of a string.  See the documentation of @code{strread} for details.
 ## In addition to the options supported by @code{strread}, this function
 ## supports one more:
 ## @itemize
 ## @item "headerlines":
 ## @end itemize
 ## The first @var{value} number of lines of @var{str} are skipped.
 ##
 ## The optional input, @var{n}, specifes the number of lines to be read from
 ## the file, associated with @var{fid}.
 ##
-## The output, @var{c}, is a cell array whose length is given by the number
+## The output, @var{C}, is a cell array whose length is given by the number
 ## of format specifiers.
 ##
 ## The second output, @var{position}, provides the position, in characters,
 ## from the beginning of the file.
 ##
 ## @seealso{dlmread, fscanf, load, strread, textread}
 ## @end deftypefn
 
-function [c, p] = textscan (fid, format, varargin)
+function [C, p] = textscan (fid, format, varargin)
 
   ## Check input
   if (nargin < 1)
     print_usage ();
   elseif (nargin == 1 || isempty (format))
     format = "%f";
   endif
 
@@ -97,21 +97,21 @@ function [c, p] = textscan (fid, format,
         endif
       endif
 
       ## Determine the number of data fields
       num_fields = numel (strfind (format, "%")) - ...
                    numel (idx_star = strfind (format, "%*"));
 
       ## Call strread to make it do the real work
-      c = cell (1, num_fields);
-      [c{:}] = strread (str, format, args{:});
+      C = cell (1, num_fields);
+      [C{:}] = strread (str, format, args{:});
 
       if (ischar (fid) && isfinite (nlines))
-        c = cellfun (@(x) x(1:nlines), c, "uniformoutput", false);
+        C = cellfun (@(x) x(1:nlines), C, "uniformoutput", false);
       endif
 
       if (nargout == 2)
         p = ftell (fid);
       endif
 
     else
       error ("textscan: second input must be a format specification");
diff --git a/scripts/linear-algebra/cond.m b/scripts/linear-algebra/cond.m
--- a/scripts/linear-algebra/cond.m
+++ b/scripts/linear-algebra/cond.m
@@ -13,66 +13,66 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} cond (@var{a})
-## @deftypefnx {Function File} {} cond (@var{a},@var{p})
+## @deftypefn  {Function File} {} cond (@var{A})
+## @deftypefnx {Function File} {} cond (@var{A},@var{p})
 ## Compute the @var{p}-norm condition number of a matrix.  @code{cond
-## (@var{a})} is
+## (@var{A})} is
 ## defined as 
 ## @tex
-## $ {\parallel a \parallel_p * \parallel a^{-1} \parallel_p .} $
+## $ {\parallel A \parallel_p * \parallel A^{-1} \parallel_p .} $
 ## @end tex
 ## @ifnottex
-## @code{norm (@var{a}, @var{p}) * norm (inv (@var{a}), @var{p})}.
+## @code{norm (@var{A}, @var{p}) * norm (inv (@var{A}), @var{p})}.
 ## @end ifnottex
 ##
 ## By default @code{@var{p} = 2} is used which implies a (relatively slow)
 ## singular value decomposition.  Other possible selections are 
 ## @code{@var{p} = 1, Inf, "fro"} which are generally faster.  See
 ## @code{norm} for a full discussion of possible @var{p} values.
 ## @seealso{condest, rcond, norm, svd}
 ## @end deftypefn
 
 ## Author: jwe
 
-function retval = cond (a, p)
+function retval = cond (A, p)
 
   if (nargin && nargin < 3)
-    if (ndims (a) > 2)
+    if (ndims (A) > 2)
       error ("cond: only valid on 2-D objects");
     endif
 
     if (nargin <2)
       p = 2;
     endif
 
     if (! ischar (p) && p == 2)
-      [nr, nc] = size (a);
+      [nr, nc] = size (A);
       if (nr == 0 || nc == 0)
         retval = 0.0;
-      elseif (any (any (isinf (a) | isnan (a))))
+      elseif (any (any (isinf (A) | isnan (A))))
         error ("cond: argument must not contain Inf or NaN values");
       else
-        sigma   = svd (a);
+        sigma   = svd (A);
         sigma_1 = sigma(1);
         sigma_n = sigma(end);
         if (sigma_1 == 0 || sigma_n == 0)
           retval = Inf;
         else
           retval = sigma_1 / sigma_n;
         endif
       endif
     else
-      retval = norm (a, p) * norm (inv (a), p);  
+      retval = norm (A, p) * norm (inv (A), p);  
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
 %!test
diff --git a/scripts/linear-algebra/condest.m b/scripts/linear-algebra/condest.m
--- a/scripts/linear-algebra/condest.m
+++ b/scripts/linear-algebra/condest.m
@@ -12,28 +12,28 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} condest (@var{a}) 
-## @deftypefnx {Function File} {} condest (@var{a}, @var{t}) 
+## @deftypefn  {Function File} {} condest (@var{A}) 
+## @deftypefnx {Function File} {} condest (@var{A}, @var{t}) 
 ## @deftypefnx {Function File} {[@var{est}, @var{v}] =} condest (@dots{}) 
-## @deftypefnx {Function File} {[@var{est}, @var{v}] =} condest (@var{a}, @var{solve}, @var{solve_t}, @var{t})
+## @deftypefnx {Function File} {[@var{est}, @var{v}] =} condest (@var{A}, @var{solve}, @var{solve_t}, @var{t})
 ## @deftypefnx {Function File} {[@var{est}, @var{v}] =} condest (@var{apply}, @var{apply_t}, @var{solve}, @var{solve_t}, @var{n}, @var{t})
 ##
 ## Estimate the 1-norm condition number of a matrix @var{A}
 ## using @var{t} test vectors using a randomized 1-norm estimator.
 ## If @var{t} exceeds 5, then only 5 test vectors are used.
 ##
 ## If the matrix is not explicit, e.g., when estimating the condition 
-## number of @var{a} given an LU factorization, @code{condest} uses the 
+## number of @var{A} given an LU factorization, @code{condest} uses the 
 ## following functions:
 ##
 ## @table @var
 ## @item apply
 ## @code{A*x} for a matrix @code{x} of size @var{n} by @var{t}.
 ##
 ## @item apply_t
 ## @code{A'*x} for a matrix @code{x} of size @var{n} by @var{t}.
diff --git a/scripts/linear-algebra/expm.m b/scripts/linear-algebra/expm.m
--- a/scripts/linear-algebra/expm.m
+++ b/scripts/linear-algebra/expm.m
@@ -12,96 +12,96 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} expm (@var{a})
+## @deftypefn {Function File} {} expm (@var{A})
 ## Return the exponential of a matrix, defined as the infinite Taylor
 ## series
 ## @tex
 ## $$
 ##  \exp (A) = I + A + {A^2 \over 2!} + {A^3 \over 3!} + \cdots
 ## $$
 ## @end tex
 ## @ifnottex
 ## 
 ## @example
-## expm(a) = I + a + a^2/2! + a^3/3! + @dots{}
+## expm(A) = I + A + A^2/2! + A^3/3! + @dots{}
 ## @end example
 ## 
 ## @end ifnottex
 ## The Taylor series is @emph{not} the way to compute the matrix
 ## exponential; see Moler and Van Loan, @cite{Nineteen Dubious Ways to
 ## Compute the Exponential of a Matrix}, SIAM Review, 1978.  This routine
 ## uses Ward's diagonal Pad@'e approximation method with three step 
 ## preconditioning (SIAM Journal on Numerical Analysis, 1977).  Diagonal
 ## Pad@'e approximations are rational polynomials of matrices
 ## @tex
-## $D_q(a)^{-1}N_q(a)$
+## $D_q(A)^{-1}N_q(A)$
 ## @end tex
 ## @ifnottex
 ## 
 ## @example
 ## @group
 ##      -1
-## D (a)   N (a)
+## D (A)   N (A)
 ## @end group
 ## @end example
 ## 
 ## @end ifnottex
 ## whose Taylor series matches the first
 ## @tex
 ## $2 q + 1 $
 ## @end tex
 ## @ifnottex
 ## @code{2q+1}
 ## @end ifnottex
 ## terms of the Taylor series above; direct evaluation of the Taylor series
 ## (with the same preconditioning steps) may be desirable in lieu of the
 ## Pad@'e approximation when
 ## @tex
-## $D_q(a)$
+## $D_q(A)$
 ## @end tex
 ## @ifnottex
-## @code{Dq(a)}
+## @code{Dq(A)}
 ## @end ifnottex
 ## is ill-conditioned.
 ## @end deftypefn
 
-function r = expm (a)
+function r = expm (A)
 
-  if (! ismatrix (a) || ! issquare (a))
+  if (! ismatrix (A) || ! issquare (A))
     error ("expm: input must be a square matrix");
   endif
 
-  if (isscalar (a))
-    r = exp (a);
+  if (isscalar (A))
+    r = exp (A);
     return
-  elseif (strfind (typeinfo (a), "diagonal matrix"))
-    r = diag (exp (diag (a)));
+  elseif (strfind (typeinfo (A), "diagonal matrix"))
+    r = diag (exp (diag (A)));
     return
   endif
 
-  n = rows (a);
+  n = rows (A);
   ## Trace reduction.
-  a(a == -Inf) = -realmax;
-  trshift = trace (a) / length (a);
+  A(A == -Inf) = -realmax;
+  trshift = trace (A) / length (A);
   if (trshift > 0)
-    a -= trshift*eye (n);
+    A -= trshift*eye (n);
   endif
   ## Balancing.
-  [d, p, aa] = balance (a);
+  [d, p, aa] = balance (A);
   ## FIXME: can we both permute and scale at once? Or should we rather do
   ## this:
   ##
-  ##   [d, xx, aa] = balance (a, "noperm");
+  ##   [d, xx, aa] = balance (A, "noperm");
   ##   [xx, p, aa] = balance (aa, "noscal");
   [f, e] = log2 (norm (aa, "inf"));
   s = max (0, e);
   s = min (s, 1023);
   aa *= 2^(-s);
 
   ## Pade approximation for exp(A).
   c = [5.0000000000000000e-1,...
diff --git a/scripts/linear-algebra/logm.m b/scripts/linear-algebra/logm.m
--- a/scripts/linear-algebra/logm.m
+++ b/scripts/linear-algebra/logm.m
@@ -14,49 +14,49 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{s} =} logm (@var{a})
-## @deftypefnx {Function File} {@var{s} =} logm (@var{a}, @var{opt_iters})
+## @deftypefn  {Function File} {@var{s} =} logm (@var{A})
+## @deftypefnx {Function File} {@var{s} =} logm (@var{A}, @var{opt_iters})
 ## @deftypefnx {Function File} {[@var{s}, @var{iters}] =} logm (@dots{})
-## Compute the matrix logarithm of the square matrix @var{a}.  The
+## Compute the matrix logarithm of the square matrix @var{A}.  The
 ## implementation utilizes a Pad@'e approximant and the identity
 ##
 ## @example
-## logm(@var{a}) = 2^k * logm(@var{a}^(1 / 2^k))
+## logm(@var{A}) = 2^k * logm(@var{A}^(1 / 2^k))
 ## @end example
 ##
 ## The optional argument @var{opt_iters} is the maximum number of square roots
 ## to compute and defaults to 100.  The optional output @var{iters} is the
 ## number of square roots actually computed.
 ##
 ## @end deftypefn
 
 ## Reference: N. J. Higham, Functions of Matrices: Theory and Computation 
 ##            (SIAM, 2008.)
 ##
 
-function [s, iters] = logm (a, opt_iters = 100)
+function [s, iters] = logm (A, opt_iters = 100)
  
   if (nargin == 0 || nargin > 2)
     print_usage ();
   endif
 
-  if (! issquare (a))
+  if (! issquare (A))
     error ("logm: argument must be a square matrix");
   endif
 
-  [u, s] = schur (a);
+  [u, s] = schur (A);
 
-  if (isreal (a))
+  if (isreal (A))
     [u, s] = rsf2csf (u, s);
   endif
 
   if (any (diag (s) < 0))
     warning ("Octave:logm:non-principal",
              "logm: principal matrix logarithm is not defined for matrices with negative eigenvalues; computing non-principal logarithm");
   endif
 
@@ -97,29 +97,29 @@ endfunction
 ################## ANCILLARY FUNCTIONS ################################
 ######  Taken from the mfttoolbox (GPL 3) by D. Higham.
 ######  Reference: 
 ######      D. Higham, Functions of Matrices: Theory and Computation 
 ######      (SIAM, 2008.).
 #######################################################################
 
 ##LOGM_PADE_PF   Evaluate Pade approximant to matrix log by partial fractions.
-##   Y = LOGM_PADE_PF(a,M) evaluates the [M/M] Pade approximation to
-##   LOG(EYE(SIZE(a))+a) using a partial fraction expansion.
+##   Y = LOGM_PADE_PF(A,M) evaluates the [M/M] Pade approximation to
+##   LOG(EYE(SIZE(A))+A) using a partial fraction expansion.
 
-function s = logm_pade_pf (a, m)
+function s = logm_pade_pf (A, m)
   [nodes, wts] = gauss_legendre (m);
   ## Convert from [-1,1] to [0,1].
   nodes = (nodes+1)/2;
   wts = wts/2;
 
-  n = length (a);
+  n = length (A);
   s = zeros (n);
   for j = 1:m
-    s += wts(j)*(a/(eye (n) + nodes(j)*a));
+    s += wts(j)*(A/(eye (n) + nodes(j)*A));
   endfor
 endfunction
 
 ######################################################################
 ## GAUSS_LEGENDRE  Nodes and weights for Gauss-Legendre quadrature.
 ##   [X,W] = GAUSS_LEGENDRE(N) computes the nodes X and weights W
 ##   for N-point Gauss-Legendre quadrature.
 
diff --git a/scripts/linear-algebra/onenormest.m b/scripts/linear-algebra/onenormest.m
--- a/scripts/linear-algebra/onenormest.m
+++ b/scripts/linear-algebra/onenormest.m
@@ -12,21 +12,21 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {[@var{est}, @var{v}, @var{w}, @var{iter}] =} onenormest (@var{a}, @var{t}) 
+## @deftypefn  {Function File} {[@var{est}, @var{v}, @var{w}, @var{iter}] =} onenormest (@var{A}, @var{t}) 
 ## @deftypefnx {Function File} {[@var{est}, @var{v}, @var{w}, @var{iter}] =} onenormest (@var{apply}, @var{apply_t}, @var{n}, @var{t})
 ##
 ## Apply Higham and Tisseur's randomized block 1-norm estimator to
-## matrix @var{a} using @var{t} test vectors.  If @var{t} exceeds 5, then
+## matrix @var{A} using @var{t} test vectors.  If @var{t} exceeds 5, then
 ## only 5 test vectors are used.
 ##
 ## If the matrix is not explicit, e.g., when estimating the norm of 
 ## @code{inv (@var{A})} given an LU factorization, @code{onenormest} applies 
 ## @var{A} and its conjugate transpose through a pair of functions 
 ## @var{apply} and @var{apply_t}, respectively, to a dense matrix of size 
 ## @var{n} by @var{t}.  The implicit version requires an explicit dimension 
 ## @var{n}.
diff --git a/scripts/linear-algebra/qzhess.m b/scripts/linear-algebra/qzhess.m
--- a/scripts/linear-algebra/qzhess.m
+++ b/scripts/linear-algebra/qzhess.m
@@ -13,21 +13,21 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{aa}, @var{bb}, @var{q}, @var{z}] =} qzhess (@var{a}, @var{b})
+## @deftypefn {Function File} {[@var{aa}, @var{bb}, @var{q}, @var{z}] =} qzhess (@var{A}, @var{B})
 ## Compute the Hessenberg-triangular decomposition of the matrix pencil
-## @code{(@var{a}, @var{b})}, returning
-## @code{@var{aa} = @var{q} * @var{a} * @var{z}},
-## @code{@var{bb} = @var{q} * @var{b} * @var{z}}, with @var{q} and @var{z}
+## @code{(@var{A}, @var{B})}, returning
+## @code{@var{aa} = @var{q} * @var{A} * @var{z}},
+## @code{@var{bb} = @var{q} * @var{B} * @var{z}}, with @var{q} and @var{z}
 ## orthogonal.  For example:
 ##
 ## @example
 ## @group
 ## [aa, bb, q, z] = qzhess ([1, 2; 3, 4], [5, 6; 7, 8])
 ##      @result{} aa = [ -3.02244, -4.41741;  0.92998,  0.69749 ]
 ##      @result{} bb = [ -8.60233, -9.99730;  0.00000, -0.23250 ]
 ##      @result{}  q = [ -0.58124, -0.81373; -0.81373,  0.58124 ]
@@ -41,32 +41,32 @@
 ## Algorithm taken from Golub and Van Loan, @cite{Matrix Computations, 2nd
 ## edition}.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <scotte@eng.auburn.edu>
 ## Created: August 1993
 ## Adapted-By: jwe
 
-function [aa, bb, q, z] = qzhess (a, b)
+function [aa, bb, q, z] = qzhess (A, B)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  [na, ma] = size (a);
-  [nb, mb] = size (b);
+  [na, ma] = size (A);
+  [nb, mb] = size (B);
   if (na != ma || na != nb || nb != mb)
     error ("qzhess: incompatible dimensions");
   endif
 
   ## Reduce to hessenberg-triangular form.
 
-  [q, bb] = qr (b);
-  aa = q' * a;
+  [q, bb] = qr (B);
+  aa = q' * A;
   q = q';
   z = eye (na);
   for j = 1:(na-2)
     for i = na:-1:(j+2)
 
       ## disp (["zero out aa(", num2str(i), ",", num2str(j), ")"])
 
       rot = givens (aa (i-1, j), aa (i, j));
diff --git a/scripts/optimization/glpk.m b/scripts/optimization/glpk.m
--- a/scripts/optimization/glpk.m
+++ b/scripts/optimization/glpk.m
@@ -12,17 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{xopt}, @var{fmin}, @var{status}, @var{extra}] =} glpk (@var{c}, @var{a}, @var{b}, @var{lb}, @var{ub}, @var{ctype}, @var{vartype}, @var{sense}, @var{param})
+## @deftypefn {Function File} {[@var{xopt}, @var{fmin}, @var{status}, @var{extra}] =} glpk (@var{c}, @var{A}, @var{b}, @var{lb}, @var{ub}, @var{ctype}, @var{vartype}, @var{sense}, @var{param})
 ## Solve a linear program using the GNU @sc{glpk} library.  Given three
 ## arguments, @code{glpk} solves the following standard LP:
 ## @tex
 ## $$
 ##   \min_x C^T x
 ## $$
 ## @end tex
 ## @ifnottex
@@ -80,17 +80,17 @@
 ## @end ifnottex
 ## 
 ## Input arguments:
 ## 
 ## @table @var
 ## @item c
 ## A column array containing the objective function coefficients.
 ## 
-## @item a
+## @item A
 ## A matrix containing the constraints coefficients.
 ## 
 ## @item b
 ## A column array containing the right-hand side value for each constraint
 ## in the constraint matrix.
 ## 
 ## @item lb
 ## An array containing the lower bound on each of the variables.  If
@@ -418,39 +418,39 @@
 ## @end table
 ## @end table
 ## 
 ## Example:
 ## 
 ## @example
 ## @group
 ## c = [10, 6, 4]';
-## a = [ 1, 1, 1;
+## A = [ 1, 1, 1;
 ##      10, 4, 5;
 ##       2, 2, 6];
 ## b = [100, 600, 300]';
 ## lb = [0, 0, 0]';
 ## ub = [];
 ## ctype = "UUU";
 ## vartype = "CCC";
 ## s = -1;
 ## 
 ## param.msglev = 1;
 ## param.itlim = 100;
 ## 
 ## [xmin, fmin, status, extra] = ...
-##    glpk (c, a, b, lb, ub, ctype, vartype, s, param);
+##    glpk (c, A, b, lb, ub, ctype, vartype, s, param);
 ## @end group
 ## @end example
 ## @end deftypefn
 
 ## Author: Nicolo' Giorgetti <giorgetti@dii.unisi.it>
 ## Adapted-by: jwe
 
-function [xopt, fmin, status, extra] = glpk (c, a, b, lb, ub, ctype, vartype, sense, param)
+function [xopt, fmin, status, extra] = glpk (c, A, b, lb, ub, ctype, vartype, sense, param)
 
   ## If there is no input output the version and syntax
   if (nargin < 3 || nargin > 9)
     print_usage ();
     return;
   endif
 
   if (all (size (c) > 1) || iscomplex (c) || ischar (c))
@@ -458,22 +458,22 @@ function [xopt, fmin, status, extra] = g
     return;
   endif
   nx = length (c);
   ## Force column vector.
   c = c(:);
 
   ## 2) Matrix constraint
 
-  if (isempty (a))
+  if (isempty (A))
     error ("glpk: A cannot be an empty matrix");
     return;
   endif
-  [nc, nxa] = size(a);
-  if (! isreal (a) || nxa != nx)
+  [nc, nxa] = size(A);
+  if (! isreal (A) || nxa != nx)
     error ("glpk: A must be a real valued %d by %d matrix", nc, nx);
     return;
   endif
 
   ## 3) RHS
 
   if (isempty (b))
     error ("glpk: B cannot be an empty vector");
@@ -568,11 +568,11 @@ function [xopt, fmin, status, extra] = g
       error ("glpk: PARAM must be a structure");
       return;
     endif
   else
     param = struct ();
   endif
 
   [xopt, fmin, status, extra] = ...
-    __glpk__ (c, a, b, lb, ub, ctype, vartype, sense, param);
+    __glpk__ (c, A, b, lb, ub, ctype, vartype, sense, param);
 
 endfunction
diff --git a/scripts/optimization/glpkmex.m b/scripts/optimization/glpkmex.m
--- a/scripts/optimization/glpkmex.m
+++ b/scripts/optimization/glpkmex.m
@@ -12,17 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{xopt}, @var{fmin}, @var{status}, @var{extra}] =} glpkmex (@var{sense}, @var{c}, @var{a}, @var{b}, @var{ctype}, @var{lb}, @var{ub}, @var{vartype}, @var{param}, @var{lpsolver}, @var{save_pb})
+## @deftypefn {Function File} {[@var{xopt}, @var{fmin}, @var{status}, @var{extra}] =} glpkmex (@var{sense}, @var{c}, @var{A}, @var{b}, @var{ctype}, @var{lb}, @var{ub}, @var{vartype}, @var{param}, @var{lpsolver}, @var{save_pb})
 ## This function is provided for compatibility with the old @sc{matlab}
 ## interface to the GNU @sc{glpk} library.  For Octave code, you should use
 ## the @code{glpk} function instead.
 ## @end deftypefn
 
 function [xopt, fopt, status, extra] = glpkmex (varargin)
 
   ## If there is no input output the version and syntax
diff --git a/scripts/polynomial/poly.m b/scripts/polynomial/poly.m
--- a/scripts/polynomial/poly.m
+++ b/scripts/polynomial/poly.m
@@ -13,23 +13,23 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} poly (@var{a})
+## @deftypefn  {Function File} {} poly (@var{A})
 ## @deftypefnx {Function File} {} poly (@var{x})
-## If @var{a} is a square @math{N}-by-@math{N} matrix, @code{poly (@var{a})}
-## is the row vector of the coefficients of @code{det (z * eye (N) - a)},
-## the characteristic polynomial of @var{a}.  For example, 
-## the following code finds the eigenvalues of @var{a} which are the roots of 
-## @code{poly (@var{a})}.
+## If @var{A} is a square @math{N}-by-@math{N} matrix, @code{poly (@var{A})}
+## is the row vector of the coefficients of @code{det (z * eye (N) - A)},
+## the characteristic polynomial of @var{A}.  For example, 
+## the following code finds the eigenvalues of @var{A} which are the roots of 
+## @code{poly (@var{A})}.
 ##
 ## @example
 ## @group
 ## roots(poly(eye(3)))
 ## @result{} 1.00001 + 0.00001i
 ## @result{} 1.00001 - 0.00001i
 ## @result{} 0.99999 + 0.00000i
 ## @end group
diff --git a/scripts/signal/unwrap.m b/scripts/signal/unwrap.m
--- a/scripts/signal/unwrap.m
+++ b/scripts/signal/unwrap.m
@@ -12,48 +12,48 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{b} =} unwrap (@var{a})
-## @deftypefnx {Function File} {@var{b} =} unwrap (@var{a}, @var{tol})
-## @deftypefnx {Function File} {@var{b} =} unwrap (@var{a}, @var{tol}, @var{dim})
+## @deftypefn  {Function File} {@var{b} =} unwrap (@var{x})
+## @deftypefnx {Function File} {@var{b} =} unwrap (@var{x}, @var{tol})
+## @deftypefnx {Function File} {@var{b} =} unwrap (@var{x}, @var{tol}, @var{dim})
 ## 
 ## Unwrap radian phases by adding multiples of 2*pi as appropriate to
 ## remove jumps greater than @var{tol}.  @var{tol} defaults to pi.
 ##
 ## Unwrap will work along the dimension @var{dim}.  If @var{dim}
 ## is unspecified it defaults to the first non-singleton dimension.
 ## @end deftypefn
 
 ## Author: Bill Lash <lash@tellabs.com>
 
-function retval = unwrap (a, tol, dim)
+function retval = unwrap (x, tol, dim)
         
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
-  if (!isnumeric(a))
-    error ("unwrap: A must be a numeric matrix or vector");
+  if (!isnumeric(x))
+    error ("unwrap: x must be a numeric matrix or vector");
   endif
 
   if (nargin < 2 || isempty (tol))
     tol = pi;
   endif
 
   ## Don't let anyone use a negative value for TOL.
   tol = abs (tol);
 
-  nd = ndims (a);
-  sz = size (a);
+  nd = ndims (x);
+  sz = size (x);
   if (nargin == 3)
     if (!(isscalar (dim) && dim == fix (dim))
         || !(1 <= dim && dim <= nd))
       error ("unwrap: DIM must be an integer and a valid dimension");
     endif
   else
     ## Find the first non-singleton dimension
     dim = find (sz > 1, 1);
@@ -63,40 +63,40 @@ function retval = unwrap (a, tol, dim)
   endif
 
   rng = 2*pi;
   m = sz(dim);
 
   ## Handle case where we are trying to unwrap a scalar, or only have
   ## one sample in the specified dimension.
   if (m == 1)       
-    retval = a;     
+    retval = x;     
     return;         
   endif
 
   ## Take first order difference to see so that wraps will show up
   ## as large values, and the sign will show direction.
   idx = cell ();
   for i = 1:nd
     idx{i} = 1:sz(i);
   endfor
   idx{dim} = [1,1:m-1];
-  d = a(idx{:}) - a;
+  d = x(idx{:}) - x;
 
   ## Find only the peaks, and multiply them by the range so that there
   ## are kronecker deltas at each wrap point multiplied by the range
   ## value.
   p =  rng * (((d > tol) > 0) - ((d < -tol) > 0));
 
   ## Now need to "integrate" this so that the deltas become steps.
   r = cumsum (p, dim);
 
   ## Now add the "steps" to the original data and put output in the
   ## same shape as originally.
-  retval = a + r;
+  retval = x + r;
 
 endfunction
 
 %!function t = xassert(a,b,tol)
 %!  if (nargin == 1)
 %!    t = all(a(:));
 %!  else
 %!    if (nargin == 2)
diff --git a/scripts/sparse/gplot.m b/scripts/sparse/gplot.m
--- a/scripts/sparse/gplot.m
+++ b/scripts/sparse/gplot.m
@@ -12,42 +12,42 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} gplot (@var{a}, @var{xy})
-## @deftypefnx {Function File} {} gplot (@var{a}, @var{xy}, @var{line_style})
-## @deftypefnx {Function File} {[@var{x}, @var{y}] =} gplot (@var{a}, @var{xy})
+## @deftypefn  {Function File} {} gplot (@var{A}, @var{xy})
+## @deftypefnx {Function File} {} gplot (@var{A}, @var{xy}, @var{line_style})
+## @deftypefnx {Function File} {[@var{x}, @var{y}] =} gplot (@var{A}, @var{xy})
 ## Plot a graph defined by @var{A} and @var{xy} in the graph theory
 ## sense.  @var{A} is the adjacency matrix of the array to be plotted
 ## and @var{xy} is an @var{n}-by-2 matrix containing the coordinates of
 ## the nodes of the graph.
 ##
 ## The optional parameter @var{line_style} defines the output style for
 ## the plot.  Called with no output arguments the graph is plotted
 ## directly.  Otherwise, return the coordinates of the plot in @var{x}
 ## and @var{y}.
 ## @seealso{treeplot, etreeplot, spy}
 ## @end deftypefn
 
-function [x, y] = gplot (a, xy, line_style)
+function [x, y] = gplot (A, xy, line_style)
 
   if (nargin < 2 || nargin > 3 || nargout > 2)
     print_usage ();
   endif
 
   if (nargin == 2)
     line_style = "-";
   endif
 
-  [i, j] = find (a);
+  [i, j] = find (A);
   xcoord = [xy(i,1), xy(j,1), NaN(length(i),1) ]'(:);
   ycoord = [xy(i,2), xy(j,2), NaN(length(i),1) ]'(:);
 
   if (nargout == 0)
     plot (xcoord, ycoord, line_style); 
   else
     x = xcoord;
     y = ycoord;
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -12,75 +12,75 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{x} =} pcg (@var{a}, @var{b}, @var{tol}, @var{maxit}, @var{m1}, @var{m2}, @var{x0}, @dots{})
+## @deftypefn  {Function File} {@var{x} =} pcg (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{m1}, @var{m2}, @var{x0}, @dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}, @var{eigest}] =} pcg (@dots{})
 ##
-## Solves the linear system of equations @code{@var{a} * @var{x} =
+## Solves the linear system of equations @code{@var{A} * @var{x} =
 ## @var{b}} by means of the Preconditioned Conjugate Gradient iterative
 ## method.  The input arguments are
 ##
 ## @itemize
 ## @item
-## @var{a} can be either a square (preferably sparse) matrix or a
+## @var{A} can be either a square (preferably sparse) matrix or a
 ## function handle, inline function or string containing the name
-## of a function which computes @code{@var{a} * @var{x}}.  In principle
-## @var{a} should be symmetric and positive definite; if @code{pcg}
-## finds @var{a} to not be positive definite, you will get a warning
+## of a function which computes @code{@var{A} * @var{x}}.  In principle
+## @var{A} should be symmetric and positive definite; if @code{pcg}
+## finds @var{A} to not be positive definite, you will get a warning
 ## message and the @var{flag} output parameter will be set.
 ## 
 ## @item
 ## @var{b} is the right hand side vector.
 ## 
 ## @item
 ## @var{tol} is the required relative tolerance for the residual error,
-## @code{@var{b} - @var{a} * @var{x}}.  The iteration stops if @code{norm
-## (@var{b} - @var{a} * @var{x}) <= @var{tol} * norm (@var{b} - @var{a} *
+## @code{@var{b} - @var{A} * @var{x}}.  The iteration stops if @code{norm
+## (@var{b} - @var{A} * @var{x}) <= @var{tol} * norm (@var{b} - @var{A} *
 ## @var{x0})}.  If @var{tol} is empty or is omitted, the function sets
 ## @code{@var{tol} = 1e-6} by default.
 ## 
 ## @item
 ## @var{maxit} is the maximum allowable number of iterations; if
 ## @code{[]} is supplied for @code{maxit}, or @code{pcg} has less
 ## arguments, a default value equal to 20 is used.
 ## 
 ## @item
 ## @var{m} = @var{m1} * @var{m2} is the (left) preconditioning matrix, so that
 ## the iteration is (theoretically) equivalent to solving by @code{pcg}
 ## @code{@var{P} *
-## @var{x} = @var{m} \ @var{b}}, with @code{@var{P} = @var{m} \ @var{a}}.
+## @var{x} = @var{m} \ @var{b}}, with @code{@var{P} = @var{m} \ @var{A}}.
 ## Note that a proper choice of the preconditioner may dramatically
 ## improve the overall performance of the method.  Instead of matrices
 ## @var{m1} and @var{m2}, the user may pass two functions which return 
 ## the results of applying the inverse of @var{m1} and @var{m2} to 
 ## a vector (usually this is the preferred way of using the preconditioner). 
 ## If @code{[]} is supplied for @var{m1}, or @var{m1} is omitted, no 
 ## preconditioning is applied.  If @var{m2} is omitted, @var{m} = @var{m1}
 ## will be used as preconditioner.
 ## 
 ## @item
 ## @var{x0} is the initial guess.  If @var{x0} is empty or omitted, the 
 ## function sets @var{x0} to a zero vector by default.
 ## @end itemize
 ## 
 ## The arguments which follow @var{x0} are treated as parameters, and
-## passed in a proper way to any of the functions (@var{a} or @var{m})
+## passed in a proper way to any of the functions (@var{A} or @var{m})
 ## which are passed to @code{pcg}.  See the examples below for further
 ## details.  The output arguments are
 ##
 ## @itemize
 ## @item
 ## @var{x} is the computed approximation to the solution of
-## @code{@var{a} * @var{x} = @var{b}}.
+## @code{@var{A} * @var{x} = @var{b}}.
 ## 
 ## @item
 ## @var{flag} reports on the convergence.  @code{@var{flag} = 0} means
 ## the solution converged and the tolerance criterion given by @var{tol}
 ## is satisfied.  @code{@var{flag} = 1} means that the @var{maxit} limit
 ## for the iteration count was reached.  @code{@var{flag} = 3} reports that
 ## the (preconditioned) matrix was found not positive definite.
 ## 
@@ -94,94 +94,94 @@
 ## @item 
 ## @var{resvec} describes the convergence history of the method.
 ## @code{@var{resvec} (i,1)} is the Euclidean norm of the residual, and
 ## @code{@var{resvec} (i,2)} is the preconditioned residual norm,
 ## after the (@var{i}-1)-th iteration, @code{@var{i} =
 ## 1, 2, @dots{}, @var{iter}+1}.  The preconditioned residual norm
 ## is defined as
 ## @code{norm (@var{r}) ^ 2 = @var{r}' * (@var{m} \ @var{r})} where
-## @code{@var{r} = @var{b} - @var{a} * @var{x}}, see also the
+## @code{@var{r} = @var{b} - @var{A} * @var{x}}, see also the
 ## description of @var{m}.  If @var{eigest} is not required, only
 ## @code{@var{resvec} (:,1)} is returned.
 ## 
 ## @item
 ## @var{eigest} returns the estimate for the smallest @code{@var{eigest}
 ## (1)} and largest @code{@var{eigest} (2)} eigenvalues of the
-## preconditioned matrix @code{@var{P} = @var{m} \ @var{a}}.  In 
+## preconditioned matrix @code{@var{P} = @var{m} \ @var{A}}.  In 
 ## particular, if no preconditioning is used, the estimates for the
-## extreme eigenvalues of @var{a} are returned.  @code{@var{eigest} (1)}
+## extreme eigenvalues of @var{A} are returned.  @code{@var{eigest} (1)}
 ## is an overestimate and @code{@var{eigest} (2)} is an underestimate, 
 ## so that @code{@var{eigest} (2) / @var{eigest} (1)} is a lower bound
 ## for @code{cond (@var{P}, 2)}, which nevertheless in the limit should
 ## theoretically be equal to the actual value of the condition number. 
 ## The method which computes @var{eigest} works only for symmetric positive
-## definite @var{a} and @var{m}, and the user is responsible for
+## definite @var{A} and @var{m}, and the user is responsible for
 ## verifying this assumption. 
 ## @end itemize
 ## 
 ## Let us consider a trivial problem with a diagonal matrix (we exploit the
 ## sparsity of A) 
 ## 
 ## @example
 ## @group
 ##      n = 10; 
-##      a = diag (sparse (1:n));
+##      A = diag (sparse (1:n));
 ##      b = rand (n, 1);
-##      [l, u, p, q] = luinc (a, 1.e-3);
+##      [l, u, p, q] = luinc (A, 1.e-3);
 ## @end group
 ## @end example
 ## 
 ## @sc{Example 1:} Simplest use of @code{pcg}
 ## 
 ## @example
 ##   x = pcg(A,b)
 ## @end example
 ## 
 ## @sc{Example 2:} @code{pcg} with a function which computes
-## @code{@var{a} * @var{x}}
+## @code{@var{A} * @var{x}}
 ## 
 ## @example
 ## @group
 ##   function y = apply_a (x)
 ##     y = [1:N]'.*x; 
 ##   endfunction
 ##
 ##   x = pcg ("apply_a", b)
 ## @end group
 ## @end example
 ##
 ## @sc{Example 3:} @code{pcg} with a preconditioner: @var{l} * @var{u}
 ##
 ## @example
-## x = pcg (a, b, 1.e-6, 500, l*u);
+## x = pcg (A, b, 1.e-6, 500, l*u);
 ## @end example
 ##
 ## @sc{Example 4:} @code{pcg} with a preconditioner: @var{l} * @var{u}.
 ## Faster than @sc{Example 3} since lower and upper triangular matrices 
 ## are easier to invert
 ##
 ## @example
-## x = pcg (a, b, 1.e-6, 500, l, u);
+## x = pcg (A, b, 1.e-6, 500, l, u);
 ## @end example
 ##
 ## @sc{Example 5:} Preconditioned iteration, with full diagnostics.  The
 ## preconditioner (quite strange, because even the original matrix
-## @var{a} is trivial) is defined as a function
+## @var{A} is trivial) is defined as a function
 ## 
 ## @example
 ## @group
 ##   function y = apply_m (x)
 ##     k = floor (length (x) - 2);
 ##     y = x;
 ##     y(1:k) = x(1:k)./[1:k]';
 ##   endfunction
 ## 
 ##   [x, flag, relres, iter, resvec, eigest] = ...
-##                      pcg (a, b, [], [], "apply_m");
+##                      pcg (A, b, [], [], "apply_m");
 ##   semilogy (1:iter+1, resvec);
 ## @end group
 ## @end example
 ## 
 ## @sc{Example 6:} Finally, a preconditioner which depends on a
 ## parameter @var{k}.
 ## 
 ## @example
@@ -213,17 +213,17 @@
 ## @seealso{sparse, pcr}
 ## @end deftypefn
 
 ## Author: Piotr Krzyzanowski <piotr.krzyzanowski@mimuw.edu.pl>
 ## Modified by: Vittoria Rezzonico <vittoria.rezzonico@epfl.ch>
 ##    - Add the ability to provide the pre-conditioner as two separate
 ## matrices
 
-function [x, flag, relres, iter, resvec, eigest] = pcg (a, b, tol, maxit, m1, m2, x0, varargin)
+function [x, flag, relres, iter, resvec, eigest] = pcg (A, b, tol, maxit, m1, m2, x0, varargin)
 
   ## M = M1*M2
 
   if (nargin < 7 || isempty (x0))
     x = zeros (size (b));
   else
     x = x0;
   endif
@@ -256,22 +256,22 @@ function [x, flag, relres, iter, resvec,
     preconditioned_residual_out = true;
   endif
 
   ## Assume A is positive definite.
   matrix_positive_definite = true;
 
   p = zeros (size (b));
   oldtau = 1; 
-  if (isnumeric (a))
+  if (isnumeric (A))
     ## A is a matrix.
-    r = b - a*x; 
+    r = b - A*x; 
   else
     ## A should be a function.
-    r = b - feval (a, x, varargin{:});
+    r = b - feval (A, x, varargin{:});
   endif
 
   resvec(1,1) = norm (r);
   alpha = 1;
   iter = 2;
 
   while (resvec (iter-1,1) > tol * resvec (1,1) && iter < maxit)
     if (exist_m1)
@@ -292,22 +292,22 @@ function [x, flag, relres, iter, resvec,
     else
       z = y;
     endif
     tau = z' * r; 
     resvec (iter-1,2) = sqrt (tau);
     beta = tau / oldtau;
     oldtau = tau;
     p = z + beta * p;
-    if (isnumeric (a))
+    if (isnumeric (A))
       ## A is a matrix.
-      w = a * p;
+      w = A * p;
     else
       ## A should be a function.
-      w = feval (a, p, varargin{:});
+      w = feval (A, p, varargin{:});
     endif
     ## Needed only for eigest.
     oldalpha = alpha;
     alpha = tau / (p'*w);
     if (alpha <= 0.0)
       ## Negative matrix.
       matrix_positive_definite = false;
     endif
diff --git a/scripts/sparse/pcr.m b/scripts/sparse/pcr.m
--- a/scripts/sparse/pcr.m
+++ b/scripts/sparse/pcr.m
@@ -12,72 +12,72 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{x} =} pcr (@var{a}, @var{b}, @var{tol}, @var{maxit}, @var{m}, @var{x0}, @dots{})
+## @deftypefn  {Function File} {@var{x} =} pcr (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{m}, @var{x0}, @dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} pcr (@dots{})
 ## 
-## Solves the linear system of equations @code{@var{a} * @var{x} =
+## Solves the linear system of equations @code{@var{A} * @var{x} =
 ## @var{b}} by means of the Preconditioned Conjugate Residuals iterative
 ## method.  The input arguments are
 ##
 ## @itemize
 ## @item
-## @var{a} can be either a square (preferably sparse) matrix or a
+## @var{A} can be either a square (preferably sparse) matrix or a
 ## function handle, inline function or string containing the name
-## of a function which computes @code{@var{a} * @var{x}}.  In principle
-## @var{a} should be symmetric and non-singular; if @code{pcr}
-## finds @var{a} to be numerically singular, you will get a warning
+## of a function which computes @code{@var{A} * @var{x}}.  In principle
+## @var{A} should be symmetric and non-singular; if @code{pcr}
+## finds @var{A} to be numerically singular, you will get a warning
 ## message and the @var{flag} output parameter will be set.
 ## 
 ## @item
 ## @var{b} is the right hand side vector.
 ## 
 ## @item
 ## @var{tol} is the required relative tolerance for the residual error,
-## @code{@var{b} - @var{a} * @var{x}}.  The iteration stops if @code{norm
-## (@var{b} - @var{a} * @var{x}) <= @var{tol} * norm (@var{b} - @var{a} *
+## @code{@var{b} - @var{A} * @var{x}}.  The iteration stops if @code{norm
+## (@var{b} - @var{A} * @var{x}) <= @var{tol} * norm (@var{b} - @var{A} *
 ## @var{x0})}.  If @var{tol} is empty or is omitted, the function sets
 ## @code{@var{tol} = 1e-6} by default.
 ## 
 ## @item
 ## @var{maxit} is the maximum allowable number of iterations; if
 ## @code{[]} is supplied for @code{maxit}, or @code{pcr} has less
 ## arguments, a default value equal to 20 is used.
 ##
 ## @item
 ## @var{m} is the (left) preconditioning matrix, so that the iteration is
 ## (theoretically) equivalent to solving by @code{pcr} @code{@var{P} *
-## @var{x} = @var{m} \ @var{b}}, with @code{@var{P} = @var{m} \ @var{a}}.
+## @var{x} = @var{m} \ @var{b}}, with @code{@var{P} = @var{m} \ @var{A}}.
 ## Note that a proper choice of the preconditioner may dramatically
 ## improve the overall performance of the method.  Instead of matrix
 ## @var{m}, the user may pass a function which returns the results of 
 ## applying the inverse of @var{m} to a vector (usually this is the
 ## preferred way of using the preconditioner).  If @code{[]} is supplied
 ## for @var{m}, or @var{m} is omitted, no preconditioning is applied.
 ## 
 ## @item
 ## @var{x0} is the initial guess.  If @var{x0} is empty or omitted, the 
 ## function sets @var{x0} to a zero vector by default.
 ## @end itemize
 ## 
 ## The arguments which follow @var{x0} are treated as parameters, and
-## passed in a proper way to any of the functions (@var{a} or @var{m})
+## passed in a proper way to any of the functions (@var{A} or @var{m})
 ## which are passed to @code{pcr}.  See the examples below for further
 ## details.  The output arguments are
 ##
 ## @itemize
 ## @item
 ## @var{x} is the computed approximation to the solution of
-## @code{@var{a} * @var{x} = @var{b}}.
+## @code{@var{A} * @var{x} = @var{b}}.
 ## 
 ## @item
 ## @var{flag} reports on the convergence.  @code{@var{flag} = 0} means
 ## the solution converged and the tolerance criterion given by @var{tol}
 ## is satisfied.  @code{@var{flag} = 1} means that the @var{maxit} limit
 ## for the iteration count was reached.  @code{@var{flag} = 3} reports t
 ## @code{pcr} breakdown, see [1] for details.
 ## 
@@ -96,84 +96,84 @@
 ## @end itemize
 ## 
 ## Let us consider a trivial problem with a diagonal matrix (we exploit the
 ## sparsity of A) 
 ## 
 ## @example
 ## @group
 ##      n = 10; 
-##      a = sparse (diag (1:n));
+##      A = sparse (diag (1:n));
 ##      b = rand (N, 1);
 ## @end group
 ## @end example
 ## 
 ## @sc{Example 1:} Simplest use of @code{pcr}
 ## 
 ## @example
 ##   x = pcr(A, b)
 ## @end example
 ## 
 ## @sc{Example 2:} @code{pcr} with a function which computes
-## @code{@var{a} * @var{x}}.
+## @code{@var{A} * @var{x}}.
 ##
 ## @example
 ## @group
 ##   function y = apply_a (x) 
 ##     y = [1:10]'.*x; 
 ##   endfunction
 ## 
 ##   x = pcr ("apply_a", b)
 ## @end group
 ## @end example
 ## 
 ## @sc{Example 3:}  Preconditioned iteration, with full diagnostics.  The
 ## preconditioner (quite strange, because even the original matrix
-## @var{a} is trivial) is defined as a function
+## @var{A} is trivial) is defined as a function
 ## 
 ## @example
 ## @group
 ##   function y = apply_m (x)           
 ##     k = floor (length(x)-2); 
 ##     y = x; 
 ##     y(1:k) = x(1:k)./[1:k]'; 
 ##   endfunction
 ## 
 ##   [x, flag, relres, iter, resvec] = ...
-##                      pcr (a, b, [], [], "apply_m")
+##                      pcr (A, b, [], [], "apply_m")
 ##   semilogy([1:iter+1], resvec);
 ## @end group
 ## @end example
 ##
 ## @sc{Example 4:} Finally, a preconditioner which depends on a
 ## parameter @var{k}.
 ## 
 ## @example
 ## @group
 ##   function y = apply_m (x, varargin)
 ##     k = varargin@{1@}; 
 ##     y = x; y(1:k) = x(1:k)./[1:k]';   
 ##   endfunction
 ## 
 ##   [x, flag, relres, iter, resvec] = ...
-##                      pcr (a, b, [], [], "apply_m"', [], 3)
+##                      pcr (A, b, [], [], "apply_m"', [], 3)
 ## @end group
 ## @end example
 ## 
 ## References:
 ## 
 ##      [1] W. Hackbusch, @cite{Iterative Solution of Large Sparse Systems of
 ##      Equations}, section 9.5.4; Springer, 1994
 ##
 ## @seealso{sparse, pcg}
 ## @end deftypefn
 
 ## Author: Piotr Krzyzanowski <piotr.krzyzanowski@mimuw.edu.pl>
 
-function [x, flag, relres, iter, resvec] = pcr (a, b, tol, maxit, m, x0, varargin)
+function [x, flag, relres, iter, resvec] = pcr (A, b, tol, maxit, m, x0, varargin)
 
   breakdown = false;
 
   if (nargin < 6 || isempty (x0))
     x = zeros (size (b));
   else
     x = x0;
   endif
@@ -192,20 +192,20 @@ function [x, flag, relres, iter, resvec]
     tol = 1e-6;
   endif
 
   if (nargin < 2)
     print_usage ();
   endif
 
   ##  init
-  if (isnumeric (a))            # is A a matrix?
-    r = b - a*x;
+  if (isnumeric (A))            # is A a matrix?
+    r = b - A*x;
   else                          # then A should be a function!
-    r = b - feval (a, x, varargin{:});
+    r = b - feval (A, x, varargin{:});
   endif
 
   if (isnumeric (m))            # is M a matrix?
     if (isempty (m))            # if M is empty, use no precond
       p = r;
     else                        # otherwise, apply the precond
       p = m \ r;
     endif
@@ -213,20 +213,20 @@ function [x, flag, relres, iter, resvec]
     p = feval (m, r, varargin{:});
   endif
 
   iter = 2;
 
   b_bot_old = 1;
   q_old = p_old = s_old = zeros (size (x));
 
-  if (isnumeric (a))            # is A a matrix?
-    q = a * p;
+  if (isnumeric (A))            # is A a matrix?
+    q = A * p;
   else                          # then A should be a function!
-    q = feval (a, p, varargin{:});
+    q = feval (A, p, varargin{:});
   endif
         
   resvec(1) = abs (norm (r)); 
 
   ## iteration
   while (resvec(iter-1) > tol*resvec(1) && iter < maxit)
 
     if (isnumeric (m))          # is M a matrix?
@@ -245,20 +245,20 @@ function [x, flag, relres, iter, resvec]
       breakdown = true;
       break;
     endif
     lambda = b_top / b_bot;
         
     x += lambda*p;
     r -= lambda*q;
         
-    if (isnumeric(a))           # is A a matrix?
-      t = a*s;
+    if (isnumeric(A))           # is A a matrix?
+      t = A*s;
     else                        # then A should be a function!
-      t = feval (a, s, varargin{:});
+      t = feval (A, s, varargin{:});
     endif
         
     alpha0 = (t'*s) / b_bot;
     alpha1 = (t'*s_old) / b_bot_old;
         
     p_temp = p;
     q_temp = q;
 
diff --git a/scripts/sparse/spaugment.m b/scripts/sparse/spaugment.m
--- a/scripts/sparse/spaugment.m
+++ b/scripts/sparse/spaugment.m
@@ -12,91 +12,91 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{s} =} spaugment (@var{a}, @var{c})
-## Creates the augmented matrix of @var{a}.  This is given by
+## @deftypefn {Function File} {@var{s} =} spaugment (@var{A}, @var{c})
+## Creates the augmented matrix of @var{A}.  This is given by
 ##
 ## @example
 ## @group
-## [@var{c} * eye(@var{m}, @var{m}),@var{a}; @var{a}', zeros(@var{n},
+## [@var{c} * eye(@var{m}, @var{m}),@var{A}; @var{A}', zeros(@var{n},
 ## @var{n})]
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## This is related to the least squares solution of 
-## @code{@var{a} \\ @var{b}}, by
+## @code{@var{A} \\ @var{b}}, by
 ## 
 ## @example
 ## @group
 ## @var{s} * [ @var{r} / @var{c}; x] = [@var{b}, zeros(@var{n},
 ## columns(@var{b})]
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## where @var{r} is the residual error
 ##
 ## @example
-## @var{r} = @var{b} - @var{a} * @var{x}
+## @var{r} = @var{b} - @var{A} * @var{x}
 ## @end example
 ##
 ## As the matrix @var{s} is symmetric indefinite it can be factorized
 ## with @code{lu}, and the minimum norm solution can therefore be found
 ## without the need for a @code{qr} factorization.  As the residual
 ## error will be @code{zeros (@var{m}, @var{m})} for under determined
 ## problems, and example can be 
 ##
 ## @example
 ## @group
 ## m = 11; n = 10; mn = max(m ,n);
-## a = spdiags ([ones(mn,1), 10*ones(mn,1), -ones(mn,1)],
+## A = spdiags ([ones(mn,1), 10*ones(mn,1), -ones(mn,1)],
 ##              [-1, 0, 1], m, n);
-## x0 = a \ ones (m,1);
-## s = spaugment (a);
+## x0 = A \ ones (m,1);
+## s = spaugment (A);
 ## [L, U, P, Q] = lu (s);
 ## x1 = Q * (U \ (L \ (P  * [ones(m,1); zeros(n,1)])));
 ## x1 = x1(end - n + 1 : end);
 ## @end group
 ## @end example
 ##
 ## To find the solution of an overdetermined problem needs an estimate
 ## of the residual error @var{r} and so it is more complex to formulate
 ## a minimum norm solution using the @code{spaugment} function.
 ##
 ## In general the left division operator is more stable and faster than
 ## using the @code{spaugment} function.
 ## @end deftypefn
 
-function s = spaugment (a, c)
+function s = spaugment (A, c)
   if (nargin < 2)
-    if (issparse (a))
-      c = max (max (abs (a))) / 1000;
+    if (issparse (A))
+      c = max (max (abs (A))) / 1000;
     else
-      if (ndims (a) != 2)
+      if (ndims (A) != 2)
         error ("spaugment: expecting 2-dimenisional matrix")
       else
-        c = max (abs (a(:))) / 1000;
+        c = max (abs (A(:))) / 1000;
       endif
     endif
   elseif (!isscalar (c))
     error ("spaugment: c must be a scalar");
   endif
 
-  [m, n] = size (a);
-  s = [ c * speye(m, m), a; a', sparse(n, n)];
+  [m, n] = size (A);
+  s = [ c * speye(m, m), A; A', sparse(n, n)];
 endfunction
 
 %!testif HAVE_UMFPACK
 %! m = 11; n = 10; mn = max(m ,n);
-%! a = spdiags ([ones(mn,1), 10*ones(mn,1), -ones(mn,1)],[-1,0,1], m, n);
-%! x0 = a \ ones (m,1);
-%! s = spaugment (a);
+%! A = spdiags ([ones(mn,1), 10*ones(mn,1), -ones(mn,1)],[-1,0,1], m, n);
+%! x0 = A \ ones (m,1);
+%! s = spaugment (A);
 %! [L, U, P, Q] = lu (s);
 %! x1 = Q * (U \ (L \ (P  * [ones(m,1); zeros(n,1)])));
 %! x1 = x1(end - n + 1 : end);
 %! assert (x1, x0, 1e-6)
diff --git a/scripts/sparse/spdiags.m b/scripts/sparse/spdiags.m
--- a/scripts/sparse/spdiags.m
+++ b/scripts/sparse/spdiags.m
@@ -12,29 +12,29 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {[@var{b}, @var{c}] =} spdiags (@var{a})
-## @deftypefnx {Function File} {@var{b} =} spdiags (@var{a}, @var{c})
-## @deftypefnx {Function File} {@var{b} =} spdiags (@var{v}, @var{c}, @var{a})
+## @deftypefn  {Function File} {[@var{b}, @var{c}] =} spdiags (@var{A})
+## @deftypefnx {Function File} {@var{b} =} spdiags (@var{A}, @var{c})
+## @deftypefnx {Function File} {@var{b} =} spdiags (@var{v}, @var{c}, @var{A})
 ## @deftypefnx {Function File} {@var{b} =} spdiags (@var{v}, @var{c}, @var{m}, @var{n})
 ## A generalization of the function @code{diag}.  Called with a single
 ## input argument, the non-zero diagonals @var{c} of @var{A} are extracted.
 ## With two arguments the diagonals to extract are given by the vector 
 ## @var{c}.
 ##
 ## The other two forms of @code{spdiags} modify the input matrix by
 ## replacing the diagonals.  They use the columns of @var{v} to replace
 ## the columns represented by the vector @var{c}.  If the sparse matrix
-## @var{a} is defined then the diagonals of this matrix are replaced.
+## @var{A} is defined then the diagonals of this matrix are replaced.
 ## Otherwise a matrix of @var{m} by @var{n} is created with the
 ## diagonals given by @var{v}.
 ##
 ## Negative values of @var{c} represent diagonals below the main
 ## diagonal, and positive values of @var{c} diagonals above the main
 ## diagonal.
 ##
 ## For example:
diff --git a/scripts/sparse/svds.m b/scripts/sparse/svds.m
--- a/scripts/sparse/svds.m
+++ b/scripts/sparse/svds.m
@@ -12,41 +12,41 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{s} =} svds (@var{a})
-## @deftypefnx {Function File} {@var{s} =} svds (@var{a}, @var{k})
-## @deftypefnx {Function File} {@var{s} =} svds (@var{a}, @var{k}, @var{sigma})
-## @deftypefnx {Function File} {@var{s} =} svds (@var{a}, @var{k}, @var{sigma}, @var{opts})
+## @deftypefn  {Function File} {@var{s} =} svds (@var{A})
+## @deftypefnx {Function File} {@var{s} =} svds (@var{A}, @var{k})
+## @deftypefnx {Function File} {@var{s} =} svds (@var{A}, @var{k}, @var{sigma})
+## @deftypefnx {Function File} {@var{s} =} svds (@var{A}, @var{k}, @var{sigma}, @var{opts})
 ## @deftypefnx {Function File} {[@var{u}, @var{s}, @var{v}] =} svds (@dots{})
 ## @deftypefnx {Function File} {[@var{u}, @var{s}, @var{v}, @var{flag}] =} svds (@dots{})
 ##
-## Find a few singular values of the matrix @var{a}.  The singular values
+## Find a few singular values of the matrix @var{A}.  The singular values
 ## are calculated using 
 ##
 ## @example
 ## @group
-## [@var{m}, @var{n}] = size(@var{a})
-## @var{s} = eigs([sparse(@var{m}, @var{m}), @var{a};
-##                     @var{a}', sparse(@var{n}, @var{n})])
+## [@var{m}, @var{n}] = size(@var{A})
+## @var{s} = eigs([sparse(@var{m}, @var{m}), @var{A};
+##                     @var{A}', sparse(@var{n}, @var{n})])
 ## @end group
 ## @end example
 ##
 ## The eigenvalues returned by @code{eigs} correspond to the singular values 
-## of @var{a}.  The number of singular values to calculate is given by @var{k}
+## of @var{A}.  The number of singular values to calculate is given by @var{k}
 ## and defaults to 6.
 ## 
 ## The argument @var{sigma} specifies which singular values to find.  When 
 ## @var{sigma} is the string 'L', the default, the largest singular values of 
-## @var{a} are found.  Otherwise, @var{sigma} must be a real scalar and the 
+## @var{A} are found.  Otherwise, @var{sigma} must be a real scalar and the 
 ## singular values closest to @var{sigma} are found.  As a corollary, 
 ## @code{@var{sigma} = 0} finds the smallest singular values.  Note that for 
 ## relatively small values of @var{sigma}, there is a chance that the requested
 ## number of singular values will not be found.  In that case @var{sigma} 
 ## should be increased.
 ##
 ## @var{opts} is a structure defining options that @code{svds} will pass
 ## to @code{eigs}.  The possible fields of this structure are documented in 
@@ -61,49 +61,49 @@
 ## The maximum number of iterations.  The default is 300.
 ##
 ## @item disp
 ## The level of diagnostic printout (0|1|2).  If @code{disp} is 0 then 
 ## diagnostics are disabled.  The default value is 0.
 ## @end table
 ##
 ## If more than one output is requested then @code{svds} will return an
-## approximation of the singular value decomposition of @var{a}
+## approximation of the singular value decomposition of @var{A}
 ##
 ## @example
-## @var{a}_approx = @var{u}*@var{s}*@var{v}'
+## @var{A}_approx = @var{u}*@var{s}*@var{v}'
 ## @end example
 ##
 ## @noindent
-## where @var{a}_approx is a matrix of size @var{a} but only rank @var{k}.
+## where @var{A}_approx is a matrix of size @var{A} but only rank @var{k}.
 ## 
 ## @var{flag} returns 0 if the algorithm has succesfully converged, and 1 
 ## otherwise.  The test for convergence is
 ##
 ## @example
 ## @group
-## norm (@var{a}*@var{v} - @var{u}*@var{s}, 1) <= @var{tol} * norm (@var{a}, 1)
+## norm (@var{A}*@var{v} - @var{u}*@var{s}, 1) <= @var{tol} * norm (@var{A}, 1)
 ## @end group
 ## @end example
 ##
 ## @code{svds} is best for finding only a few singular values from a large
-## sparse matrix.  Otherwise, @code{svd (full(@var{a}))} will likely be more
+## sparse matrix.  Otherwise, @code{svd (full(@var{A}))} will likely be more
 ## efficient.
 ## @end deftypefn
 ## @seealso{svd, eigs}
 
-function [u, s, v, flag] = svds (a, k, sigma, opts)
+function [u, s, v, flag] = svds (A, k, sigma, opts)
 
   persistent root2 = sqrt (2);
 
   if (nargin < 1 || nargin > 4)
     print_usage ();
   endif
 
-  if (ndims(a) > 2)
+  if (ndims(A) > 2)
     error ("svds: A must be a 2D matrix")
   endif
 
   if (nargin < 4)
     opts.tol = 1e-10 / root2;
     opts.disp = 0;
     opts.maxit = 300;
   else
@@ -111,49 +111,49 @@ function [u, s, v, flag] = svds (a, k, s
       error ("svds: OPTS must be a structure");
     endif
     if (!isfield (opts, "tol"))
       opts.tol = 1e-10 / root2;
     else
       opts.tol = opts.tol / root2;
     endif
     if (isfield (opts, "v0"))
-      if (!isvector (opts.v0) || (length (opts.v0) != sum (size (a))))
+      if (!isvector (opts.v0) || (length (opts.v0) != sum (size (A))))
         error ("svds: OPTS.v0 must be a vector with rows(A)+columns(A) entries");
       endif
     endif
   endif
 
   if (nargin < 3 || strcmp (sigma, "L"))
-    if (isreal (a))
+    if (isreal (A))
       sigma = "LA";
     else
       sigma = "LR";
     endif
   elseif (isscalar (sigma) && isnumeric (sigma) && isreal (sigma))
     if (sigma < 0)
       error ("svds: SIGMA must be a positive real value");
     endif
   else
     error ("svds: SIGMA must be a positive real value or the string 'L'");
   endif
 
-  [m, n] = size (a);
-  max_a = max (abs (a(:)));
+  [m, n] = size (A);
+  max_a = max (abs (A(:)));
   if (max_a == 0)
     s = zeros (k, 1);  # special case of zero matrix
   else
     if (nargin < 2)
       k = min ([6, m, n]);
     else
       k = min ([k, m, n]);
     endif
 
     ## Scale everything by the 1-norm to make things more stable.
-    b = a / max_a;
+    b = A / max_a;
     b_opts = opts;
     b_opts.tol = opts.tol / max_a;
     b_sigma = sigma;
     if (!ischar (b_sigma))
       b_sigma = b_sigma / max_a;
     endif
 
     if (b_sigma == 0)
@@ -176,17 +176,17 @@ function [u, s, v, flag] = svds (a, k, s
     else
       s = eigs ([sparse(m,m), b; b', sparse(n,n)], b_k, b_sigma, b_opts);
     endif
     s = diag (s);
 
     if (ischar (sigma))
       norma = max (s);
     else
-      norma = normest (a);
+      norma = normest (A);
     endif
     ## We wish to exclude all eigenvalues that are less than zero as these
     ## are artifacts of the way the matrix passed to eigs is formed. There 
     ## is also the possibility that the value of sigma chosen is exactly 
     ## a singular value, and in that case we're dead!! So have to rely on 
     ## the warning from eigs. We exclude the singular values which are
     ## less than or equal to zero to within some tolerance scaled by the
     ## norm since if we don't we might end up with too many singular
@@ -228,49 +228,49 @@ function [u, s, v, flag] = svds (a, k, s
       v = eye (n, k);
     else
       u = root2 * V(1:m,ind);
       s = diag(s);
       v = root2 * V(m+1:end,ind);
     endif
 
     if (nargout > 3)
-      flag = norm (a*v - u*s, 1) > root2 * opts.tol * norm (a, 1);
+      flag = norm (A*v - u*s, 1) > root2 * opts.tol * norm (A, 1);
     endif
   endif
 
 endfunction
 
-%!shared n, k, a, u, s, v, opts
+%!shared n, k, A, u, s, v, opts
 %! n = 100;
 %! k = 7;
-%! a = sparse([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),0.4*n*ones(1,n),ones(1,n-2)]);
-%! [u,s,v] = svd(full(a));
+%! A = sparse([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),0.4*n*ones(1,n),ones(1,n-2)]);
+%! [u,s,v] = svd(full(A));
 %! s = diag(s);
 %! [~, idx] = sort(abs(s));
 %! s = s(idx);
 %! u = u(:,idx);
 %! v = v(:,idx);
 %! randn('state',42);      % Initialize to make normest function reproducible
 %! rand('state',42)
 %! opts.v0 = rand (2*n,1); % Initialize eigs ARPACK starting vector 
 %!                         % to guarantee reproducible results
 %!testif HAVE_ARPACK
-%! [u2,s2,v2,flag] = svds(a,k);
+%! [u2,s2,v2,flag] = svds(A,k);
 %! s2 = diag(s2);
 %! assert(flag,!1);
 %! assert(s2, s(end:-1:end-k+1), 1e-10); 
 %!testif HAVE_ARPACK
-%! [u2,s2,v2,flag] = svds(a,k,0,opts);
+%! [u2,s2,v2,flag] = svds(A,k,0,opts);
 %! s2 = diag(s2);
 %! assert(flag,!1);
 %! assert(s2, s(k:-1:1), 1e-10); 
 %!testif HAVE_ARPACK
 %! idx = floor(n/2);
 %! % Don't put sigma right on a singular value or there are convergence issues 
 %! sigma = 0.99*s(idx) + 0.01*s(idx+1); 
-%! [u2,s2,v2,flag] = svds(a,k,sigma,opts);
+%! [u2,s2,v2,flag] = svds(A,k,sigma,opts);
 %! s2 = diag(s2);
 %! assert(flag,!1);
 %! assert(s2, s((idx+floor(k/2)):-1:(idx-floor(k/2))), 1e-10); 
 %!testif HAVE_ARPACK
 %! [u2,s2,v2,flag] = svds(zeros (10), k);
 %! assert (isequal(u2, eye (10, k)) && isequal (s2, zeros(k)) && isequal (v2, eye(10, 7)))
