# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1471419702 14400
#      Wed Aug 17 03:41:42 2016 -0400
# Node ID d0562b3159c787e24e60f496bbca66ca0c887ad3
# Parent  71dd9d5a5ecd993f824dbd99d865cdd38fca4ba2
move more classes inside octave namespace

* ov-complex.cc, quit.h, lo-array-errwarn.h, lo-array-errwarn.cc,
lo-array-gripes.cc: Move classes inside octave namespace.

* NEWS, file-editor-tab.cc, Cell.cc, __qp__.cc, cellfun.cc, daspk.cc,
dasrt.cc, dassl.cc, data.cc, error.cc, error.h, errwarn.cc, errwarn.h,
file-io.cc, gcd.cc, graphics.cc, graphics.in.h, gripes.cc, gripes.h,
input.cc, interpreter.cc, interpreter.h, inv.cc, jit-typeinfo.cc,
load-path.cc, ls-mat-ascii.cc, ls-mat5.cc, lsode.cc, mex.cc,
oct-handle.h, oct-map.cc, oct-stream.cc, quad.cc, rand.cc,
sparse-xdiv.cc, sparse-xpow.cc, sparse.cc, sub2ind.cc, toplev.cc,
utils.cc, variables.cc, xdiv.cc, xpow.cc, __eigs__.cc,
__init_gnuplot__.cc, ov-base-diag.cc, ov-base-mat.cc,
ov-base-scalar.cc, ov-base-sparse.cc, ov-base.cc, ov-class.cc,
ov-classdef.cc, ov-complex.h, ov-complex.cc, ov-cx-mat.cc,
ov-cx-sparse.cc, ov-fcn-handle.cc, ov-float.cc, ov-float.h,
ov-flt-complex.h, ov-flt-cx-mat.cc, ov-flt-re-mat.cc, ov-java.cc,
ov-oncleanup.cc, ov-perm.cc, ov-range.cc, ov-re-diag.cc, ov-re-mat.cc,
ov-re-sparse.cc, ov-scalar.cc, ov-scalar.h, ov-str-mat.cc, ov.cc,
op-cs-cs.cc, op-fcs-fcs.cc, op-fs-fs.cc, op-int.h, op-s-s.cc, ops.h,
oct-parse.in.yy, pt-assign.cc, pt-eval.cc, pt-idx.cc, pt.cc,
Array-util.cc, Array.cc, CColVector.cc, CDiagMatrix.cc, CMatrix.cc,
CNDArray.cc, CRowVector.cc, CSparse.cc, DiagArray2.cc, MDiagArray2.cc,
MSparse.cc, PermMatrix.cc, Range.cc, Sparse.cc, dColVector.cc,
dDiagMatrix.cc, dMatrix.cc, dNDArray.cc, dRowVector.cc, dSparse.cc,
fCColVector.cc, fCDiagMatrix.cc, fCMatrix.cc, fCNDArray.cc,
fCRowVector.cc, fColVector.cc, fDiagMatrix.cc, fMatrix.cc,
fNDArray.cc, fRowVector.cc, idx-vector.cc, quit.cc, quit.h,
gepbalance.cc, Sparse-diag-op-defs.h, Sparse-op-defs.h,
Sparse-perm-op-defs.h, mx-inlines.cc, mx-op-defs.h, cmd-edit.cc,
lo-array-errwarn.cc, lo-array-errwarn.h, lo-array-gripes.cc,
lo-array-gripes.h, oct-binmap.h: Update to use namespace.

diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -171,17 +171,17 @@ Summary of important user-visible change
       isequalwithequalnans    javamethods
       java_convert_matrix     re_read_readline_init_file
       java_debug              read_readline_init_file
       java_invoke             saving_history
 
  ** The global error_state variable in Octave's C++ API has been
     deprecated and will be removed in a future version.  Now the error
     and print_usage functions throw an exception
-    (octave_execution_exception) after displaying the error message.
+    (octave::execution_exception) after displaying the error message.
     This makes the error and print_usage functions in C++ work more like
     the corresponding functions in the scripting language.
 
  ** The default error handlers in liboctave have been updated to use
     exceptions.  After displaying an error message they no longer return
     control to the calling program.  The error handler function can be
     customized through the global variables
     "current_liboctave_error_handler" and
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -384,19 +384,19 @@ file_editor_tab::handle_context_menu_bre
               // Suppress error messages on the console.
               octave::unwind_protect frame;
               frame.protect_var (buffer_error_messages);
               buffer_error_messages++;
 
               bp_table::condition_valid (new_condition.toStdString ());
               valid = true;
             }
-          catch (const index_exception& e) { }
-          catch (const octave_execution_exception& e) { }
-          catch (const octave_interrupt_exception&)
+          catch (const octave::index_exception& e) { }
+          catch (const octave::execution_exception& e) { }
+          catch (const octave::interrupt_exception&)
             {
               ok = false;
               valid = true;
             }
 
           // In case we repeat, set new prompt.
           prompt = "ERROR: " + last_error_message () + "\n\ndbstop if";
           cond = new_condition;
@@ -1753,17 +1753,17 @@ file_editor_tab::exit_debug_and_clear (c
                                        const QString& base_name_q)
 {
   std::string base_name = base_name_q.toStdString ();
   octave_value sym;
   try
     {
       sym = symbol_table::find (base_name);
     }
-  catch (const octave_execution_exception& e)
+  catch (const octave::execution_exception& e)
     {
       // Ignore syntax error.
       // It was in the old file on disk; the user may have fixed it already.
     }
 
   // Return early if this file is not loaded in the symbol table
   if (!sym.is_defined () || !sym.is_user_code ())
     return true;
diff --git a/libinterp/corefcn/Cell.cc b/libinterp/corefcn/Cell.cc
--- a/libinterp/corefcn/Cell.cc
+++ b/libinterp/corefcn/Cell.cc
@@ -199,17 +199,17 @@ Cell::index (const octave_value_list& id
             for (k = 0; k < n; k++)
               iv(k) = idx_arg(k).index_vector ();
 
             retval = Array<octave_value>::index (iv, resize_ok, Matrix ());
           }
           break;
         }
     }
-  catch (index_exception& e)
+  catch (octave::index_exception& e)
     {
       // Rethrow to allow more info to be reported later.
       e.set_pos_if_unset (n, k+1);
       throw;
     }
 
   return retval;
 }
@@ -230,17 +230,17 @@ Cell::assign (const octave_value_list& i
   Array<idx_vector> ra_idx (dim_vector (len, 1));
 
   for (octave_idx_type i = 0; i < len; i++)
     {
       try
         {
           ra_idx(i) = idx_arg(i).index_vector ();
         }
-      catch (index_exception& e)
+      catch (octave::index_exception& e)
         {
           // Rethrow to allow more info to be reported later.
           e.set_pos (len, i+1);
           throw;
         }
     }
 
   Array<octave_value>::assign (ra_idx, rhs, fill_val);
@@ -254,17 +254,17 @@ Cell::delete_elements (const octave_valu
 
   Array<idx_vector> ra_idx (dim_vector (len, 1));
 
   for (octave_idx_type i = 0; i < len; i++)
     try
       {
         ra_idx.xelem (i) = idx_arg(i).index_vector ();
       }
-    catch (index_exception& e)
+    catch (octave::index_exception& e)
         {
           // Rethrow to allow more info to be reported later.
           e.set_pos (len, i+1);
           throw;
         }
 
   Array<octave_value>::delete_elements (ra_idx);
 }
diff --git a/libinterp/corefcn/__qp__.cc b/libinterp/corefcn/__qp__.cc
--- a/libinterp/corefcn/__qp__.cc
+++ b/libinterp/corefcn/__qp__.cc
@@ -137,17 +137,17 @@ qp (const Matrix& H, const ColumnVector&
   // Computing the ???
 
   EIG eigH;
 
   try
     {
       eigH = EIG (H);
     }
-  catch (octave_execution_exception& e)
+  catch (octave::execution_exception& e)
     {
       error (e, "qp: failed to compute eigenvalues of H");
     }
 
   ColumnVector eigenvalH = real (eigH.eigenvalues ());
   Matrix eigenvecH = real (eigH.right_eigenvectors ());
   double minReal = eigenvalH.min ();
   octave_idx_type indminR = 0;
@@ -285,17 +285,17 @@ qp (const Matrix& H, const ColumnVector&
               // Searching for the most negative curvature.
 
               EIG eigrH;
 
               try
                 {
                   eigrH = EIG (rH);
                 }
-              catch (octave_execution_exception& e)
+              catch (octave::execution_exception& e)
                 {
                   error (e, "qp: failed to compute eigenvalues of rH");
                 }
 
               ColumnVector eigenvalrH = real (eigrH.eigenvalues ());
               Matrix eigenvecrH = real (eigrH.right_eigenvectors ());
               double mRrH = eigenvalrH.min ();
               indminR = 0;
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -73,17 +73,17 @@ get_output_list (octave_idx_type count, 
   octave_value_list tmp;
 
   bool execution_error = false;
 
   try
     {
       tmp = func.do_multi_index_op (nargout, inputlist);
     }
-  catch (const octave_execution_exception& e)
+  catch (const octave::execution_exception& e)
     {
       if (error_handler.is_defined ())
         {
           recover_from_exception ();
 
           execution_error = true;
         }
       else
diff --git a/libinterp/corefcn/daspk.cc b/libinterp/corefcn/daspk.cc
--- a/libinterp/corefcn/daspk.cc
+++ b/libinterp/corefcn/daspk.cc
@@ -74,17 +74,17 @@ daspk_user_function (const ColumnVector&
   if (daspk_fcn)
     {
       octave_value_list tmp;
 
       try
         {
           tmp = daspk_fcn->do_multi_index_op (1, args);
         }
-      catch (octave_execution_exception& e)
+      catch (octave::execution_exception& e)
         {
           err_user_supplied_eval (e, "daspk");
         }
 
       int tlen = tmp.length ();
       if (tlen == 0 || ! tmp(0).is_defined ())
         err_user_supplied_eval ("daspk");
 
@@ -124,17 +124,17 @@ daspk_user_jacobian (const ColumnVector&
   if (daspk_jac)
     {
       octave_value_list tmp;
 
       try
         {
           tmp = daspk_jac->do_multi_index_op (1, args);
         }
-      catch (octave_execution_exception& e)
+      catch (octave::execution_exception& e)
         {
           err_user_supplied_eval (e, "daspk");
         }
 
       int tlen = tmp.length ();
       if (tlen == 0 || ! tmp(0).is_defined ())
         err_user_supplied_eval ("daspk");
 
diff --git a/libinterp/corefcn/dasrt.cc b/libinterp/corefcn/dasrt.cc
--- a/libinterp/corefcn/dasrt.cc
+++ b/libinterp/corefcn/dasrt.cc
@@ -74,17 +74,17 @@ dasrt_user_f (const ColumnVector& x, con
   if (dasrt_f)
     {
       octave_value_list tmp;
 
       try
         {
           tmp = dasrt_f->do_multi_index_op (1, args);
         }
-      catch (octave_execution_exception& e)
+      catch (octave::execution_exception& e)
         {
           err_user_supplied_eval (e, "dasrt");
         }
 
       if (tmp.empty () || ! tmp(0).is_defined ())
         err_user_supplied_eval ("dasrt");
 
       if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
@@ -115,17 +115,17 @@ dasrt_user_cf (const ColumnVector& x, do
   if (dasrt_cf)
     {
       octave_value_list tmp;
 
       try
         {
           tmp = dasrt_cf->do_multi_index_op (1, args);
         }
-      catch (octave_execution_exception& e)
+      catch (octave::execution_exception& e)
         {
           err_user_supplied_eval (e, "dasrt");
         }
 
       if (tmp.empty () || ! tmp(0).is_defined ())
         err_user_supplied_eval ("dasrt");
 
       if (! warned_cf_imaginary && tmp(0).is_complex_type ())
@@ -161,17 +161,17 @@ dasrt_user_j (const ColumnVector& x, con
   if (dasrt_j)
     {
       octave_value_list tmp;
 
       try
         {
           tmp = dasrt_j->do_multi_index_op (1, args);
         }
-      catch (octave_execution_exception& e)
+      catch (octave::execution_exception& e)
         {
           err_user_supplied_eval (e, "dasrt");
         }
 
       int tlen = tmp.length ();
       if (tlen == 0 || ! tmp(0).is_defined ())
         err_user_supplied_eval ("dasrt");
 
diff --git a/libinterp/corefcn/dassl.cc b/libinterp/corefcn/dassl.cc
--- a/libinterp/corefcn/dassl.cc
+++ b/libinterp/corefcn/dassl.cc
@@ -74,17 +74,17 @@ dassl_user_function (const ColumnVector&
   if (dassl_fcn)
     {
       octave_value_list tmp;
 
       try
         {
           tmp = dassl_fcn->do_multi_index_op (1, args);
         }
-      catch (octave_execution_exception& e)
+      catch (octave::execution_exception& e)
         {
           err_user_supplied_eval (e, "dassl");
         }
 
       int tlen = tmp.length ();
       if (tlen == 0 || ! tmp(0).is_defined ())
         err_user_supplied_eval ("dassl");
 
@@ -124,17 +124,17 @@ dassl_user_jacobian (const ColumnVector&
   if (dassl_jac)
     {
       octave_value_list tmp;
 
       try
         {
           tmp = dassl_jac->do_multi_index_op (1, args);
         }
-      catch (octave_execution_exception& e)
+      catch (octave::execution_exception& e)
         {
           err_user_supplied_eval (e, "dassl");
         }
 
       int tlen = tmp.length ();
       if (tlen == 0 || ! tmp(0).is_defined ())
         err_user_supplied_eval ("dassl");
 
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -1794,17 +1794,17 @@ attempt_type_conversion (const octave_va
   if (fcn.is_defined ())
     {
       octave_value_list result;
 
       try
         {
           result = fcn.do_multi_index_op (1, octave_value_list (1, ov));
         }
-      catch (octave_execution_exception& e)
+      catch (octave::execution_exception& e)
         {
           error (e, "conversion from %s to %s failed", dtype.c_str (),
                  cname.c_str ());
         }
 
       if (result.empty ())
         error ("conversion from %s to %s failed", dtype.c_str (),
                cname.c_str ());
@@ -1822,17 +1822,17 @@ attempt_type_conversion (const octave_va
         error ("no constructor for %s!", dtype.c_str ());
 
       octave_value_list result;
 
       try
         {
           result = fcn.do_multi_index_op (1, octave_value_list (1, ov));
         }
-      catch (octave_execution_exception& e)
+      catch (octave::execution_exception& e)
         {
           error (e, "%s constructor failed for %s argument", dtype.c_str (),
                  cname.c_str ());
         }
 
       if (result.empty ())
         error ("%s constructor failed for %s argument", dtype.c_str (),
                cname.c_str ());
@@ -1859,17 +1859,17 @@ do_class_concat (const octave_value_list
       // Have method for dominant type.  Call it and let it handle conversions.
 
       octave_value_list tmp2;
 
       try
         {
           tmp2 = fcn.do_multi_index_op (1, ovl);
         }
-      catch (octave_execution_exception& e)
+      catch (octave::execution_exception& e)
         {
           error (e, "%s/%s method failed", dtype.c_str (), cattype.c_str ());
         }
 
       if (tmp2.empty ())
         error ("%s/%s method did not return a value", dtype.c_str (),
                cattype.c_str ());
 
@@ -6917,17 +6917,17 @@ the ratio K/M is small; otherwise, it ma
 
         default:
           if (argx.is_cellstr ())
             retval = argx.cellstr_value ().nth_element (n, dim);
           else
             err_wrong_type_arg ("nth_element", argx);
         }
     }
-  catch (const index_exception& e)
+  catch (const octave::index_exception& e)
     {
       index_error ("nth_element: invalid N value %s. %s",
                    e.idx (), e.details ());
     }
 
   return retval;
 }
 
@@ -7002,17 +7002,17 @@ Undocumented internal function.
                                         vals.complex_array_value (),
                                         n);
           else
             retval = do_accumarray_sum (idx, vals.array_value (), n);
         }
       else
         err_wrong_type_arg ("accumarray", vals);
     }
-  catch (const index_exception& e)
+  catch (const octave::index_exception& e)
     {
       index_error ("__accumarray_sum__: invalid IDX %s. %s",
                    e.idx (), e.details ());
     }
 
   return retval;
 }
 
@@ -7114,17 +7114,17 @@ do_accumarray_minmax_fun (const octave_v
           retval = do_accumarray_minmax (idx, vals.array_value (), n, ismin,
                                          zero.bool_value ());
           break;
 
         default:
           err_wrong_type_arg ("accumarray", vals);
         }
     }
-  catch (const index_exception& e)
+  catch (const octave::index_exception& e)
     {
       index_error ("do_accumarray_minmax_fun: invalid index %s. %s",
                    e.idx (), e.details ());
     }
 
   return retval;
 }
 
@@ -7222,17 +7222,17 @@ Undocumented internal function.
             retval = do_accumdim_sum (idx, vals.complex_array_value (),
                                       dim, n);
           else
             retval = do_accumdim_sum (idx, vals.array_value (), dim, n);
         }
       else
         err_wrong_type_arg ("accumdim", vals);
     }
-  catch (const index_exception& e)
+  catch (const octave::index_exception& e)
     {
       index_error ("__accumdim_sum__: invalid IDX %s. %s",
                    e.idx (), e.details ());
     }
 
   return retval;
 }
 
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -292,32 +292,32 @@ pr_where (std::ostream& os, const char *
       int line = elt.line ();
       int column = elt.column ();
 
       pr_where_1 (os, "    %s at line %d column %d\n",
                   fcn_name.c_str (), line, column);
     }
 }
 
-static octave_execution_exception
+static octave::execution_exception
 make_execution_exception (const char *who)
 {
   std::ostringstream buf;
 
   pr_where (buf, who);
 
-  octave_execution_exception retval;
+  octave::execution_exception retval;
 
   retval.set_stack_trace (buf.str ());
 
   return retval;
 }
 
 static void
-maybe_enter_debugger (octave_execution_exception& e,
+maybe_enter_debugger (octave::execution_exception& e,
                       bool show_stack_trace = false)
 {
   if ((octave::application::interactive ()
        || octave::application::forced_interactive ())
       && ((Vdebug_on_error && bp_table::debug_on_err (last_error_id ()))
           || (Vdebug_on_caught && bp_table::debug_on_caught (last_error_id ())))
       && octave_call_stack::caller_user_code ())
     {
@@ -410,31 +410,31 @@ message_with_id (const char *name, const
   va_list args;
   va_start (args, fmt);
   vmessage_with_id (name, id, fmt, args);
   va_end (args);
 }
 
 OCTAVE_NORETURN static
 void
-usage_1 (octave_execution_exception& e, const char *id,
+usage_1 (octave::execution_exception& e, const char *id,
          const char *fmt, va_list args)
 {
   verror (true, std::cerr, "usage", id, fmt, args);
 
   maybe_enter_debugger (e);
 
   throw e;
 }
 
 OCTAVE_NORETURN static
 void
 usage_1 (const char *id, const char *fmt, va_list args)
 {
-  octave_execution_exception e = make_execution_exception ("usage");
+  octave::execution_exception e = make_execution_exception ("usage");
 
   usage_1 (e, id, fmt, args);
 }
 
 void
 vusage (const char *fmt, va_list args)
 {
   usage_1 ("", fmt, args);
@@ -461,17 +461,17 @@ usage_with_id (const char *id, const cha
   va_list args;
   va_start (args, fmt);
   vusage_with_id (id, fmt, args);
   va_end (args);
 }
 
 OCTAVE_NORETURN static
 void
-error_1 (octave_execution_exception& e, std::ostream& os,
+error_1 (octave::execution_exception& e, std::ostream& os,
          const char *name, const char *id, const char *fmt,
          va_list args, bool with_cfn = false)
 {
   bool show_stack_trace = false;
 
   if (fmt)
     {
       if (*fmt)
@@ -512,17 +512,17 @@ error_1 (octave_execution_exception& e, 
   throw e;
 }
 
 OCTAVE_NORETURN static
 void
 error_1 (std::ostream& os, const char *name, const char *id,
          const char *fmt, va_list args, bool with_cfn = false)
 {
-  octave_execution_exception e = make_execution_exception ("error");
+  octave::execution_exception e = make_execution_exception ("error");
 
   error_1 (e, os, name, id, fmt, args, with_cfn);
 }
 
 void
 verror (const char *fmt, va_list args)
 {
   error_1 (std::cerr, "error", "", fmt, args);
@@ -533,23 +533,23 @@ error (const char *fmt, ...)
 {
   va_list args;
   va_start (args, fmt);
   verror (fmt, args);
   va_end (args);
 }
 
 void
-verror (octave_execution_exception& e, const char *fmt, va_list args)
+verror (octave::execution_exception& e, const char *fmt, va_list args)
 {
   error_1 (e, std::cerr, "error", "", fmt, args);
 }
 
 void
-error (octave_execution_exception& e, const char *fmt, ...)
+error (octave::execution_exception& e, const char *fmt, ...)
 {
   va_list args;
   va_start (args, fmt);
   verror (e, fmt, args);
   va_end (args);
 }
 
 void
diff --git a/libinterp/corefcn/error.h b/libinterp/corefcn/error.h
--- a/libinterp/corefcn/error.h
+++ b/libinterp/corefcn/error.h
@@ -27,17 +27,20 @@ along with Octave; see the file COPYING.
 
 #include <cstdarg>
 #include <string>
 
 #include "unwind-prot.h"
 
 class octave_map;
 class octave_value_list;
-class octave_execution_exception;
+namespace octave
+{
+  class execution_exception;
+}
 
 #define panic_impossible()                                              \
   panic ("impossible state reached in file '%s' at line %d", __FILE__, __LINE__)
 
 extern OCTINTERP_API void reset_error_handler (void);
 
 extern OCTINTERP_API int warning_enabled (const std::string& id);
 
@@ -59,19 +62,19 @@ extern OCTINTERP_API void warning (const
 
 OCTAVE_NORETURN OCTINTERP_API extern
 void verror (const char *fmt, va_list args);
 
 OCTAVE_NORETURN OCTINTERP_API extern
 void error (const char *fmt, ...);
 
 OCTAVE_NORETURN OCTINTERP_API extern
-void verror (octave_execution_exception&, const char *fmt, va_list args);
+void verror (octave::execution_exception&, const char *fmt, va_list args);
 OCTAVE_NORETURN OCTINTERP_API extern
-void error (octave_execution_exception&, const char *fmt, ...);
+void error (octave::execution_exception&, const char *fmt, ...);
 
 OCTAVE_NORETURN OCTINTERP_API extern
 void verror_with_cfn (const char *fmt, va_list args);
 OCTAVE_NORETURN OCTINTERP_API extern
 void error_with_cfn (const char *fmt, ...);
 
 OCTAVE_NORETURN OCTINTERP_API extern
 void vparse_error (const char *fmt, va_list args);
diff --git a/libinterp/corefcn/errwarn.cc b/libinterp/corefcn/errwarn.cc
--- a/libinterp/corefcn/errwarn.cc
+++ b/libinterp/corefcn/errwarn.cc
@@ -136,127 +136,127 @@ void
 err_user_returned_invalid (const char *name)
 {
   error ("%s: user-supplied function returned invalid value", name);
 }
 
 void
 err_user_supplied_eval (const char *name)
 {
-  octave_execution_exception e;
+  octave::execution_exception e;
 
   err_user_supplied_eval (e, name);
 }
 
 void
-err_user_supplied_eval (octave_execution_exception& e, const char *name)
+err_user_supplied_eval (octave::execution_exception& e, const char *name)
 {
   error (e, "%s: evaluation of user-supplied function failed", name);
 }
 
 void
 err_wrong_type_arg (const char *name, const char *s)
 {
-  octave_execution_exception e;
+  octave::execution_exception e;
 
   err_wrong_type_arg (e, name, s);
 }
 
 void
-err_wrong_type_arg (octave_execution_exception& e,
+err_wrong_type_arg (octave::execution_exception& e,
                     const char *name, const char *s)
 {
   error (e, "%s: wrong type argument '%s'", name, s);
 }
 
 void
 err_wrong_type_arg (const char *name, const std::string& s)
 {
-  octave_execution_exception e;
+  octave::execution_exception e;
 
   err_wrong_type_arg (e, name, s.c_str ());
 }
 
 void
-err_wrong_type_arg (octave_execution_exception& e,
+err_wrong_type_arg (octave::execution_exception& e,
                     const char *name, const std::string& s)
 {
   err_wrong_type_arg (e, name, s.c_str ());
 }
 
 void
 err_wrong_type_arg (const char *name, const octave_value& tc)
 {
-  octave_execution_exception e;
+  octave::execution_exception e;
 
   err_wrong_type_arg (e, name, tc);
 }
 
 void
-err_wrong_type_arg (octave_execution_exception& e,
+err_wrong_type_arg (octave::execution_exception& e,
                     const char *name, const octave_value& tc)
 {
   std::string type = tc.type_name ();
 
   err_wrong_type_arg (e, name, type);
 }
 
 void
 err_wrong_type_arg (const std::string& name, const octave_value& tc)
 {
-  octave_execution_exception e;
+  octave::execution_exception e;
 
   err_wrong_type_arg (e, name, tc);
 }
 
 void
-err_wrong_type_arg (octave_execution_exception& e,
+err_wrong_type_arg (octave::execution_exception& e,
                     const std::string& name, const octave_value& tc)
 {
   err_wrong_type_arg (e, name.c_str (), tc);
 }
 
 void
 err_wrong_type_arg (const char *s)
 {
-  octave_execution_exception e;
+  octave::execution_exception e;
 
   err_wrong_type_arg (e, s);
 }
 
 void
-err_wrong_type_arg (octave_execution_exception& e, const char *s)
+err_wrong_type_arg (octave::execution_exception& e, const char *s)
 {
   error (e, "wrong type argument '%s'", s);
 }
 
 void
 err_wrong_type_arg (const std::string& s)
 {
-  octave_execution_exception e;
+  octave::execution_exception e;
 
   err_wrong_type_arg (e, s);
 }
 
 void
-err_wrong_type_arg (octave_execution_exception& e, const std::string& s)
+err_wrong_type_arg (octave::execution_exception& e, const std::string& s)
 {
   err_wrong_type_arg (e, s.c_str ());
 }
 
 void
 err_wrong_type_arg (const octave_value& tc)
 {
-  octave_execution_exception e;
+  octave::execution_exception e;
 
   err_wrong_type_arg (e, tc);
 }
 
 void
-err_wrong_type_arg (octave_execution_exception& e, const octave_value& tc)
+err_wrong_type_arg (octave::execution_exception& e, const octave_value& tc)
 {
   std::string type = tc.type_name ();
 
   err_wrong_type_arg (e, type);
 }
 
 void
 err_wrong_type_arg_for_binary_op (const octave_value& op)
diff --git a/libinterp/corefcn/errwarn.h b/libinterp/corefcn/errwarn.h
--- a/libinterp/corefcn/errwarn.h
+++ b/libinterp/corefcn/errwarn.h
@@ -25,17 +25,20 @@ along with Octave; see the file COPYING.
 
 #include "octave-config.h"
 
 #include <string>
 
 #include "lo-array-errwarn.h"
 
 class octave_value;
-class octave_execution_exception;
+namespace octave
+{
+  class execution_exception;
+}
 
 ////////////////////////////////////////////////////////////////////////////////
 // Alphabetized list of common errors and warnings.
 ////////////////////////////////////////////////////////////////////////////////
 
 OCTAVE_NORETURN OCTINTERP_API extern void
 err_2_or_3_dim_plot (void);
 
@@ -85,63 +88,63 @@ err_unrecognized_float_fmt (void);
 
 OCTAVE_NORETURN OCTINTERP_API extern void
 err_user_returned_invalid (const char *name);
 
 OCTAVE_NORETURN OCTINTERP_API extern void
 err_user_supplied_eval (const char *name);
 
 OCTAVE_NORETURN OCTINTERP_API extern void
-err_user_supplied_eval (octave_execution_exception& e, const char *name);
+err_user_supplied_eval (octave::execution_exception& e, const char *name);
 
 OCTAVE_NORETURN OCTINTERP_API extern void
 err_wrong_type_arg (const char *name, const char *s);
 
 OCTAVE_NORETURN OCTINTERP_API extern void
-err_wrong_type_arg (octave_execution_exception& e, const char *name,
+err_wrong_type_arg (octave::execution_exception& e, const char *name,
                     const char *s);
 
 OCTAVE_NORETURN OCTINTERP_API extern void
 err_wrong_type_arg (const char *name, const std::string& s);
 
 OCTAVE_NORETURN OCTINTERP_API extern void
-err_wrong_type_arg (octave_execution_exception& e, const char *name,
+err_wrong_type_arg (octave::execution_exception& e, const char *name,
                     const std::string& s);
 
 OCTAVE_NORETURN OCTINTERP_API extern void
 err_wrong_type_arg (const char *name, const octave_value& tc);
 
 OCTAVE_NORETURN OCTINTERP_API extern void
-err_wrong_type_arg (octave_execution_exception& e, const char *name,
+err_wrong_type_arg (octave::execution_exception& e, const char *name,
                     const octave_value& tc);
 
 OCTAVE_NORETURN OCTINTERP_API extern void
 err_wrong_type_arg (const std::string& name, const octave_value& tc);
 
 OCTAVE_NORETURN OCTINTERP_API extern void
-err_wrong_type_arg (octave_execution_exception& e, const std::string& name,
+err_wrong_type_arg (octave::execution_exception& e, const std::string& name,
                     const octave_value& tc);
 
 OCTAVE_NORETURN OCTINTERP_API extern void
 err_wrong_type_arg (const char *s);
 
 OCTAVE_NORETURN OCTINTERP_API extern void
-err_wrong_type_arg (octave_execution_exception& e, const char *s);
+err_wrong_type_arg (octave::execution_exception& e, const char *s);
 
 OCTAVE_NORETURN OCTINTERP_API extern void
 err_wrong_type_arg (const std::string& s);
 
 OCTAVE_NORETURN OCTINTERP_API extern void
-err_wrong_type_arg (octave_execution_exception& e, const std::string& s);
+err_wrong_type_arg (octave::execution_exception& e, const std::string& s);
 
 OCTAVE_NORETURN OCTINTERP_API extern void
 err_wrong_type_arg (const octave_value& tc);
 
 OCTAVE_NORETURN OCTINTERP_API extern void
-err_wrong_type_arg (octave_execution_exception& e, const octave_value& tc);
+err_wrong_type_arg (octave::execution_exception& e, const octave_value& tc);
 
 OCTAVE_NORETURN OCTINTERP_API extern void
 err_wrong_type_arg_for_binary_op (const octave_value& op);
 
 OCTAVE_NORETURN OCTINTERP_API extern void
 err_wrong_type_arg_for_unary_op (const octave_value& op);
 
 OCTINTERP_API extern void
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -2253,28 +2253,28 @@ do_fread (octave_stream& os, const octav
   oct_data_conv::data_type input_type;
   oct_data_conv::data_type output_type;
 
   try
     {
       oct_data_conv::string_to_data_type (prec, block_size,
                                           input_type, output_type);
     }
-  catch (octave_execution_exception& e)
+  catch (octave::execution_exception& e)
     {
       error (e, "fread: invalid PRECISION specified");
     }
 
   int skip = 0;
 
   try
     {
       skip = skip_arg.int_value (true);
     }
-  catch (octave_execution_exception& e)
+  catch (octave::execution_exception& e)
     {
       error (e, "fread: SKIP must be an integer");
     }
 
   std::string arch = arch_arg.xstring_value ("fread: ARCH architecture type must be a string");
 
   octave::mach_info::float_format flt_fmt
     = octave::mach_info::string_to_float_format (arch);
@@ -2501,28 +2501,28 @@ do_fwrite (octave_stream& os, const octa
 
   int block_size = 1;
   oct_data_conv::data_type output_type;
 
   try
     {
       oct_data_conv::string_to_data_type (prec, block_size, output_type);
     }
-  catch (octave_execution_exception& e)
+  catch (octave::execution_exception& e)
     {
       error (e, "fwrite: invalid PRECISION specified");
     }
 
   int skip = 0;
 
   try
     {
       skip = skip_arg.int_value (true);
     }
-  catch (octave_execution_exception& e)
+  catch (octave::execution_exception& e)
     {
       error (e, "fwrite: SKIP must be an integer");
     }
 
   std::string arch = arch_arg.xstring_value ("fwrite: ARCH architecture type must be a string");
 
   octave::mach_info::float_format flt_fmt
     = octave::mach_info::string_to_float_format (arch);
diff --git a/libinterp/corefcn/gcd.cc b/libinterp/corefcn/gcd.cc
--- a/libinterp/corefcn/gcd.cc
+++ b/libinterp/corefcn/gcd.cc
@@ -331,17 +331,17 @@ do_extended_gcd (const octave_value& a, 
     {
       NDA aa = octave_value_extract<NDA> (a);
       NDA bb = octave_value_extract<NDA> (b);
 
       dim_vector dv = aa.dims ();
       if (aa.numel () == 1)
         dv = bb.dims ();
       else if (bb.numel () != 1 && bb.dims () != dv)
-        err_nonconformant ("gcd", a.dims (), b.dims ());
+        octave::err_nonconformant ("gcd", a.dims (), b.dims ());
 
       NDA gg (dv), xx (dv), yy (dv);
 
       const T *aptr = aa.fortran_vec ();
       const T *bptr = bb.fortran_vec ();
 
       bool inca = aa.numel () != 1;
       bool incb = bb.numel () != 1;
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -1317,17 +1317,17 @@ color_property::do_set (const octave_val
 
               if (current_type != color_t || col != color_val)
                 {
                   color_val = col;
                   current_type = color_t;
                   return true;
                 }
             }
-          catch (octave_execution_exception& e)
+          catch (octave::execution_exception& e)
             {
               error (e, "invalid value for color property \"%s\" (value = %s)",
                      get_name ().c_str (), s.c_str ());
             }
         }
     }
   else if (val.is_numeric_type ())
     {
@@ -2900,17 +2900,17 @@ base_properties::set_from_list (base_gra
       for (const auto& prop_val_p : pval_map)
         {
           std::string pname = prop_val_p.first;
 
           try
             {
               bgo.set (pname, prop_val_p.second);
             }
-          catch (octave_execution_exception& e)
+          catch (octave::execution_exception& e)
             {
               error (e, "error setting default property %s", pname.c_str ());
             }
         }
     }
 }
 
 /*
@@ -3217,17 +3217,17 @@ base_graphics_object::remove_all_listene
 
       try
         {
           property p = get_properties ().get_property (pa->first);
 
           if (p.ok ())
             p.delete_listener ();
         }
-      catch (const octave_execution_exception&)
+      catch (const octave::execution_exception&)
         {
           recover_from_exception ();
         }
     }
 }
 
 void
 base_graphics_object::build_user_defaults_map (property_list::pval_map_type &def, const std::string go_name) const
@@ -9542,17 +9542,17 @@ gh_manager::do_execute_callback (const g
         {
           int status;
           std::string s = cb.string_value ();
 
           try
             {
               eval_string (s, false, status, 0);
             }
-          catch (octave_execution_exception&)
+          catch (octave::execution_exception&)
             {
               std::cerr << "execution error in graphics callback function"
                         << std::endl;
               feval ("lasterr",
                      ovl ("execution error in graphics callback function"));
               recover_from_exception ();
             }
         }
@@ -9575,17 +9575,17 @@ gh_manager::do_execute_callback (const g
                  nm.c_str ());
         }
 
       if (fcn)
         try
           {
             feval (fcn, args);
           }
-        catch (octave_execution_exception&)
+        catch (octave::execution_exception&)
           {
             std::cerr << "execution error in graphics callback function"
                       << std::endl;
             feval ("lasterr",
                    ovl ("execution error in graphics callback function"));
             recover_from_exception ();
           }
 
@@ -10375,17 +10375,17 @@ make_graphics_object (const std::string&
   graphics_handle h;
 
   try
     {
       h = gh_manager::make_graphics_handle (go_name, parent,
                                             integer_figure_handle,
                                             false, false);
     }
-  catch (octave_execution_exception& e)
+  catch (octave::execution_exception& e)
     {
       error (e, "__go%s__: unable to create graphics handle",
              go_name.c_str ());
     }
 
   adopt (parent, h);
 
   xset (h, xargs);
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -787,17 +787,17 @@ protected:
     else
       {
         NDArray nda;
 
         try
           {
             nda = val.array_value ();
           }
-        catch (octave_execution_exception& e)
+        catch (octave::execution_exception& e)
           {
             error (e, "set: invalid string property value for \"%s\"",
                    get_name ().c_str ());
           }
 
         octave_idx_type nel = nda.numel ();
 
         value.resize (nel);
@@ -1667,17 +1667,17 @@ protected:
   bool do_set (const octave_value& val)
   {
     Matrix new_kids;
 
     try
       {
         new_kids = val.matrix_value ();
       }
-    catch (octave_execution_exception& e)
+    catch (octave::execution_exception& e)
       {
         error (e, "set: children must be an array of graphics handles");
       }
 
     octave_idx_type nel = new_kids.numel ();
 
     const Matrix new_kids_column = new_kids.reshape (dim_vector (nel, 1));
 
diff --git a/libinterp/corefcn/gripes.cc b/libinterp/corefcn/gripes.cc
--- a/libinterp/corefcn/gripes.cc
+++ b/libinterp/corefcn/gripes.cc
@@ -192,90 +192,90 @@ void
 gripe_user_returned_invalid (const char *name)
 {
   error ("%s: user-supplied function returned invalid value", name);
 }
 
 void
 gripe_user_supplied_eval (const char *name)
 {
-  octave_execution_exception e;
+  octave::execution_exception e;
 
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 #  pragma GCC diagnostic push
 #  pragma GCC diagnostic ignored "-Wdeprecated-declarations"
 #endif
 
   gripe_user_supplied_eval (e, name);
 
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 #  pragma GCC diagnostic pop
 #endif
 }
 
 void
-gripe_user_supplied_eval (octave_execution_exception& e,
+gripe_user_supplied_eval (octave::execution_exception& e,
                           const char *name)
 {
   error (e, "%s: evaluation of user-supplied function failed", name);
 }
 
 void
 gripe_warn_complex_cmp (void)
 {
   warning_with_id ("Octave:language-extension",
                    "comparing complex numbers is not supported in Matlab");
 }
 
 void
 gripe_wrong_type_arg (const char *name, const char *s, bool is_error)
 {
-  octave_execution_exception e;
+  octave::execution_exception e;
 
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 #  pragma GCC diagnostic push
 #  pragma GCC diagnostic ignored "-Wdeprecated-declarations"
 #endif
 
   gripe_wrong_type_arg (e, name, s, is_error);
 
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 #  pragma GCC diagnostic pop
 #endif
 }
 
 void
-gripe_wrong_type_arg (octave_execution_exception& e,
+gripe_wrong_type_arg (octave::execution_exception& e,
                       const char *name, const char *s, bool is_error)
 {
   if (is_error)
     error (e, "%s: wrong type argument '%s'", name, s);
   else
     warning ("%s: wrong type argument '%s'", name, s);
 }
 
 void
 gripe_wrong_type_arg (const char *name, const std::string& s, bool is_error)
 {
-  octave_execution_exception e;
+  octave::execution_exception e;
 
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 #  pragma GCC diagnostic push
 #  pragma GCC diagnostic ignored "-Wdeprecated-declarations"
 #endif
 
   gripe_wrong_type_arg (e, name, s.c_str (), is_error);
 
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 #  pragma GCC diagnostic pop
 #endif
 }
 
 void
-gripe_wrong_type_arg (octave_execution_exception& e,
+gripe_wrong_type_arg (octave::execution_exception& e,
                       const char *name, const std::string& s, bool is_error)
 {
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 #  pragma GCC diagnostic push
 #  pragma GCC diagnostic ignored "-Wdeprecated-declarations"
 #endif
 
   gripe_wrong_type_arg (e, name, s.c_str (), is_error);
@@ -284,32 +284,32 @@ gripe_wrong_type_arg (octave_execution_e
 #  pragma GCC diagnostic pop
 #endif
 }
 
 void
 gripe_wrong_type_arg (const char *name, const octave_value& tc,
                       bool is_error)
 {
-  octave_execution_exception e;
+  octave::execution_exception e;
 
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 #  pragma GCC diagnostic push
 #  pragma GCC diagnostic ignored "-Wdeprecated-declarations"
 #endif
 
   gripe_wrong_type_arg (e, name, tc, is_error);
 
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 #  pragma GCC diagnostic pop
 #endif
 }
 
 void
-gripe_wrong_type_arg (octave_execution_exception& e,
+gripe_wrong_type_arg (octave::execution_exception& e,
                       const char *name, const octave_value& tc,
                       bool is_error)
 {
   std::string type = tc.type_name ();
 
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 #  pragma GCC diagnostic push
 #  pragma GCC diagnostic ignored "-Wdeprecated-declarations"
@@ -321,32 +321,32 @@ gripe_wrong_type_arg (octave_execution_e
 #  pragma GCC diagnostic pop
 #endif
 }
 
 void
 gripe_wrong_type_arg (const std::string& name, const octave_value& tc,
                       bool is_error)
 {
-  octave_execution_exception e;
+  octave::execution_exception e;
 
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 #  pragma GCC diagnostic push
 #  pragma GCC diagnostic ignored "-Wdeprecated-declarations"
 #endif
 
   gripe_wrong_type_arg (e, name, tc, is_error);
 
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 #  pragma GCC diagnostic pop
 #endif
 }
 
 void
-gripe_wrong_type_arg (octave_execution_exception& e,
+gripe_wrong_type_arg (octave::execution_exception& e,
                       const std::string& name, const octave_value& tc,
                       bool is_error)
 {
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 #  pragma GCC diagnostic push
 #  pragma GCC diagnostic ignored "-Wdeprecated-declarations"
 #endif
 
@@ -355,59 +355,59 @@ gripe_wrong_type_arg (octave_execution_e
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 #  pragma GCC diagnostic pop
 #endif
 }
 
 void
 gripe_wrong_type_arg (const char *s, bool is_error)
 {
-  octave_execution_exception e;
+  octave::execution_exception e;
 
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 #  pragma GCC diagnostic push
 #  pragma GCC diagnostic ignored "-Wdeprecated-declarations"
 #endif
 
   gripe_wrong_type_arg (e, s, is_error);
 
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 #  pragma GCC diagnostic pop
 #endif
 }
 
 void
-gripe_wrong_type_arg (octave_execution_exception& e,
+gripe_wrong_type_arg (octave::execution_exception& e,
                       const char *s, bool is_error)
 {
   if (is_error)
     error (e, "wrong type argument '%s'", s);
   else
     warning ("wrong type argument '%s'", s);
 }
 
 void
 gripe_wrong_type_arg (const std::string& s, bool is_error)
 {
-  octave_execution_exception e;
+  octave::execution_exception e;
 
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 #  pragma GCC diagnostic push
 #  pragma GCC diagnostic ignored "-Wdeprecated-declarations"
 #endif
 
   gripe_wrong_type_arg (e, s, is_error);
 
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 #  pragma GCC diagnostic pop
 #endif
 }
 
 void
-gripe_wrong_type_arg (octave_execution_exception& e,
+gripe_wrong_type_arg (octave::execution_exception& e,
                       const std::string& s, bool is_error)
 {
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 #  pragma GCC diagnostic push
 #  pragma GCC diagnostic ignored "-Wdeprecated-declarations"
 #endif
 
   gripe_wrong_type_arg (e, s.c_str (), is_error);
@@ -415,32 +415,32 @@ gripe_wrong_type_arg (octave_execution_e
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 #  pragma GCC diagnostic pop
 #endif
 }
 
 void
 gripe_wrong_type_arg (const octave_value& tc, bool is_error)
 {
-  octave_execution_exception e;
+  octave::execution_exception e;
 
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 #  pragma GCC diagnostic push
 #  pragma GCC diagnostic ignored "-Wdeprecated-declarations"
 #endif
 
   gripe_wrong_type_arg (e, tc, is_error);
 
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 #  pragma GCC diagnostic pop
 #endif
 }
 
 void
-gripe_wrong_type_arg (octave_execution_exception& e,
+gripe_wrong_type_arg (octave::execution_exception& e,
                       const octave_value& tc, bool is_error)
 {
   std::string type = tc.type_name ();
 
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 #  pragma GCC diagnostic push
 #  pragma GCC diagnostic ignored "-Wdeprecated-declarations"
 #endif
diff --git a/libinterp/corefcn/gripes.h b/libinterp/corefcn/gripes.h
--- a/libinterp/corefcn/gripes.h
+++ b/libinterp/corefcn/gripes.h
@@ -26,17 +26,20 @@ along with Octave; see the file COPYING.
 
 #include "octave-config.h"
 
 #include <string>
 
 #include "lo-array-gripes.h"
 
 class octave_value;
-class octave_execution_exception;
+namespace octave
+{
+  class execution_exception;
+}
 
 ////////////////////////////////////////////////////////////////////////////////
 // Alphabetized list of gripes.
 ////////////////////////////////////////////////////////////////////////////////
 
 OCTAVE_DEPRECATED ("use 'err_2_or_3_dim_plot' instead")
 OCTAVE_NORETURN OCTINTERP_API extern void
 gripe_2_or_3_dim_plot (void);
@@ -139,91 +142,91 @@ OCTAVE_NORETURN OCTINTERP_API extern voi
 gripe_user_returned_invalid (const char *name);
 
 OCTAVE_DEPRECATED ("use 'err_user_supplied_eval' instead")
 OCTAVE_NORETURN OCTINTERP_API extern void
 gripe_user_supplied_eval (const char *name);
 
 OCTAVE_DEPRECATED ("use 'err_user_supplied_eval' instead")
 OCTAVE_NORETURN OCTINTERP_API extern void
-gripe_user_supplied_eval (octave_execution_exception& e, const char *name);
+gripe_user_supplied_eval (octave::execution_exception& e, const char *name);
 
 OCTAVE_DEPRECATED ("use 'warn_complex_cmp' instead")
 OCTINTERP_API extern void
 gripe_warn_complex_cmp (void);
 
 OCTAVE_DEPRECATED ("use 'err_wrong_type_arg' instead")
 OCTINTERP_API extern void
 gripe_wrong_type_arg (const char *name, const char *s,
                       bool is_error = true);
 
 OCTAVE_DEPRECATED ("use 'err_wrong_type_arg' instead")
 OCTINTERP_API extern void
-gripe_wrong_type_arg (octave_execution_exception& e,
+gripe_wrong_type_arg (octave::execution_exception& e,
                       const char *name, const char *s,
                       bool is_error = true);
 
 OCTAVE_DEPRECATED ("use 'err_wrong_type_arg' instead")
 OCTINTERP_API extern void
 gripe_wrong_type_arg (const char *name, const std::string& s,
                       bool is_error = true);
 
 OCTAVE_DEPRECATED ("use 'err_wrong_type_arg' instead")
 OCTINTERP_API extern void
-gripe_wrong_type_arg (octave_execution_exception& e,
+gripe_wrong_type_arg (octave::execution_exception& e,
                       const char *name, const std::string& s,
                       bool is_error = true);
 
 OCTAVE_DEPRECATED ("use 'err_wrong_type_arg' or 'warn_wrong_type_arg' instead")
 OCTINTERP_API extern void
 gripe_wrong_type_arg (const char *name, const octave_value& tc,
                       bool is_error = true);
 
 OCTAVE_DEPRECATED ("use 'err_wrong_type_arg' instead")
 OCTINTERP_API extern void
-gripe_wrong_type_arg (octave_execution_exception& e,
+gripe_wrong_type_arg (octave::execution_exception& e,
                       const char *name, const octave_value& tc,
                       bool is_error = true);
 
 OCTAVE_DEPRECATED ("use 'err_wrong_type_arg' instead")
 OCTINTERP_API extern void
 gripe_wrong_type_arg (const std::string& name, const octave_value& tc,
                       bool is_error = true);
 
 OCTAVE_DEPRECATED ("use 'err_wrong_type_arg' instead")
 OCTINTERP_API extern void
-gripe_wrong_type_arg (octave_execution_exception& e,
+gripe_wrong_type_arg (octave::execution_exception& e,
                       const std::string& name, const octave_value& tc,
                       bool is_error = true);
 
 OCTAVE_DEPRECATED ("use 'err_wrong_type_arg' instead")
 OCTINTERP_API extern void
 gripe_wrong_type_arg (const char *s, bool is_error = true);
 
 OCTAVE_DEPRECATED ("use 'err_wrong_type_arg' instead")
 OCTINTERP_API extern void
-gripe_wrong_type_arg (octave_execution_exception& e, const char *s,
+gripe_wrong_type_arg (octave::execution_exception& e, const char *s,
                       bool is_error = true);
 
 OCTAVE_DEPRECATED ("use 'err_wrong_type_arg' instead")
 OCTINTERP_API extern void
 gripe_wrong_type_arg (const std::string& s, bool is_error = true);
 
 OCTAVE_DEPRECATED ("use 'err_wrong_type_arg' instead")
 OCTINTERP_API extern void
-gripe_wrong_type_arg (octave_execution_exception& e, const std::string& s,
+gripe_wrong_type_arg (octave::execution_exception& e, const std::string& s,
                       bool is_error = true);
 
 OCTAVE_DEPRECATED ("use 'err_wrong_type_arg' instead")
 OCTINTERP_API extern void
 gripe_wrong_type_arg (const octave_value& tc, bool is_error = true);
 
 OCTAVE_DEPRECATED ("use 'err_wrong_type_arg' instead")
 OCTINTERP_API extern void
-gripe_wrong_type_arg (octave_execution_exception& e, const octave_value& tc,
+gripe_wrong_type_arg (octave::execution_exception& e, const octave_value& tc,
                       bool is_error = true);
 
 OCTAVE_DEPRECATED ("use 'err_wrong_type_arg_for_binary_op' instead")
 OCTAVE_NORETURN OCTINTERP_API extern void
 gripe_wrong_type_arg_for_binary_op (const octave_value& op);
 
 OCTAVE_DEPRECATED ("use 'err_wrong_type_arg_for_unary_op' instead")
 OCTAVE_NORETURN OCTINTERP_API extern void
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -199,17 +199,17 @@ interactive_input (const std::string& s,
   if (Vdrawnow_requested && octave::application::interactive ())
     {
       bool eval_error = false;
 
       try
         {
           feval ("drawnow");
         }
-      catch (const octave_execution_exception& e)
+      catch (const octave::execution_exception& e)
         {
           eval_error = true;
 
           std::string stack_trace = e.info ();
 
           if (! stack_trace.empty ())
             std::cerr << stack_trace;
 
@@ -705,17 +705,17 @@ get_debug_input (const std::string& prom
 
                   if (octave_completion_matches_called)
                     octave_completion_matches_called = false;
                 }
 
               octave_quit ();
             }
         }
-      catch (const octave_execution_exception& e)
+      catch (const octave::execution_exception& e)
         {
           std::string stack_trace = e.info ();
 
           if (! stack_trace.empty ())
             std::cerr << stack_trace;
 
           // Ignore errors when in debugging mode;
           recover_from_exception ();
diff --git a/libinterp/corefcn/interpreter.cc b/libinterp/corefcn/interpreter.cc
--- a/libinterp/corefcn/interpreter.cc
+++ b/libinterp/corefcn/interpreter.cc
@@ -357,68 +357,68 @@ safe_source_file (const std::string& fil
                   const std::string& context = "",
                   bool verbose = false, bool require_file = true,
                   const std::string& warn_for = "")
 {
   try
     {
       source_file (file_name, context, verbose, require_file, warn_for);
     }
-  catch (const index_exception& e)
+  catch (const octave::index_exception& e)
     {
       recover_from_exception ();
 
       std::cerr << "error: index exception in " << file_name << ": "
                 << e.message () << std::endl;
     }
-  catch (const octave_exit_exception& ex)
+  catch (const octave::exit_exception& ex)
     {
       recover_from_exception ();
 
       clean_up_and_exit (ex.exit_status (), ex.safe_to_return ());
     }
-  catch (const octave_interrupt_exception&)
+  catch (const octave::interrupt_exception&)
     {
       recover_from_exception ();
     }
-  catch (const octave_execution_exception&)
+  catch (const octave::execution_exception&)
     {
       recover_from_exception ();
 
       std::cerr << "error: execution exception in " << file_name << std::endl;
     }
 }
 
 static void
 execute_pkg_add (const std::string& dir)
 {
   std::string file_name = octave::sys::file_ops::concat (dir, "PKG_ADD");
 
   try
     {
       load_path::execute_pkg_add (dir);
     }
-  catch (const index_exception& e)
+  catch (const octave::index_exception& e)
     {
       recover_from_exception ();
 
       std::cerr << "error: index exception in " << file_name << ": "
                 << e.message () << std::endl;
     }
-  catch (const octave_exit_exception& ex)
+  catch (const octave::exit_exception& ex)
     {
       recover_from_exception ();
 
       clean_up_and_exit (ex.exit_status (), ex.safe_to_return ());
     }
-  catch (const octave_interrupt_exception&)
+  catch (const octave::interrupt_exception&)
     {
       recover_from_exception ();
     }
-  catch (const octave_execution_exception&)
+  catch (const octave::execution_exception&)
     {
       recover_from_exception ();
 
       std::cerr << "error: execution exception in " << file_name << std::endl;
     }
 }
 
 static void
@@ -673,17 +673,17 @@ namespace octave
     if (! code_to_eval.empty ())
       {
         int parse_status = 0;
 
         try
           {
             parse_status = execute_eval_option_code (code_to_eval);
           }
-        catch (const octave_execution_exception&)
+        catch (const octave::execution_exception&)
           {
             recover_from_exception ();
 
             parse_status = 1;
           }
 
         if (! options.persist ())
           {
@@ -706,17 +706,17 @@ namespace octave
         try
           {
             string_vector script_args = options.remaining_args ();
 
             m_app_context->intern_argv (script_args);
 
             execute_command_line_file (script_args[0]);
           }
-        catch (const octave_execution_exception&)
+        catch (const octave::execution_exception&)
           {
             recover_from_exception ();
 
             exit_status = 1;
           }
 
         // Restore full set of args.
         m_app_context->intern_argv (options.all_args ());
@@ -783,27 +783,27 @@ namespace octave
     m_interactive = false;
 
     int parse_status = 0;
 
     try
       {
         eval_string (code, false, parse_status, 0);
       }
-    catch (const octave_exit_exception& ex)
+    catch (const octave::exit_exception& ex)
       {
         recover_from_exception ();
 
         clean_up_and_exit (ex.exit_status (), ex.safe_to_return ());
       }
-    catch (const octave_interrupt_exception&)
+    catch (const octave::interrupt_exception&)
       {
         recover_from_exception ();
       }
-    catch (const octave_execution_exception&)
+    catch (const octave::execution_exception&)
       {
         recover_from_exception ();
 
         std::cerr << "error: unhandled execution exception -- eval failed"
                   << std::endl;
       }
 
     return parse_status;
@@ -909,39 +909,39 @@ namespace octave
                       octave_completion_matches_called = false;
                     else
                       octave::command_editor::increment_current_command_number ();
                   }
                 else if (parser.lexer.end_of_input)
                   break;
               }
           }
-        catch (const octave_exit_exception& ex)
+        catch (const octave::exit_exception& ex)
           {
             recover_from_exception ();
 
             clean_up_and_exit (ex.exit_status (), ex.safe_to_return ());
           }
-        catch (const octave_interrupt_exception&)
+        catch (const octave::interrupt_exception&)
           {
             recover_from_exception ();
 
             // Required newline when the user does Ctrl+C at the prompt.
             if (octave::application::interactive ())
               octave_stdout << "\n";
           }
-        catch (const index_exception& e)
+        catch (const octave::index_exception& e)
           {
             recover_from_exception ();
 
             std::cerr << "error: unhandled index exception: "
                       << e.message () << " -- trying to return to prompt"
                       << std::endl;
           }
-        catch (const octave_execution_exception& e)
+        catch (const octave::execution_exception& e)
           {
             std::string stack_trace = e.info ();
 
             if (! stack_trace.empty ())
               std::cerr << stack_trace;
 
             if (octave::application::interactive ())
               recover_from_exception ();
diff --git a/libinterp/corefcn/interpreter.h b/libinterp/corefcn/interpreter.h
--- a/libinterp/corefcn/interpreter.h
+++ b/libinterp/corefcn/interpreter.h
@@ -74,18 +74,18 @@ extern OCTINTERP_API bool octave_initial
           frame.protect_var (Vdebug_on_error);                          \
           frame.protect_var (Vdebug_on_warning);                        \
                                                                         \
           Vdebug_on_error = false;                                      \
           Vdebug_on_warning = false;                                    \
                                                                         \
           F ARGS;                                                       \
         }                                                               \
-      OCTAVE_IGNORE_EXCEPTION (const octave_interrupt_exception&)       \
-        OCTAVE_IGNORE_EXCEPTION (const octave_execution_exception&)     \
+      OCTAVE_IGNORE_EXCEPTION (const octave::interrupt_exception&)       \
+        OCTAVE_IGNORE_EXCEPTION (const octave::execution_exception&)     \
         OCTAVE_IGNORE_EXCEPTION (const std::bad_alloc&)                 \
         }                                                               \
   while (0)
 
 namespace octave
 {
   extern tree_evaluator *current_evaluator;
 
diff --git a/libinterp/corefcn/inv.cc b/libinterp/corefcn/inv.cc
--- a/libinterp/corefcn/inv.cc
+++ b/libinterp/corefcn/inv.cc
@@ -201,17 +201,17 @@ sparse matrix if possible.
     }
   else
     {
       volatile double xrcond = rcond;
       rcond_plus_one_eq_one = xrcond + 1.0 == 1.0;
     }
 
   if (nargout < 2 && (info == -1 || rcond_plus_one_eq_one))
-    warn_singular_matrix (isfloat ? frcond : rcond);
+    octave::warn_singular_matrix (isfloat ? frcond : rcond);
 
   return retval;
 }
 
 /*
 %!assert (inv ([1, 2; 3, 4]), [-2, 1; 1.5, -0.5], sqrt (eps))
 %!assert (inv (single ([1, 2; 3, 4])), single ([-2, 1; 1.5, -0.5]), sqrt (eps ("single")))
 
diff --git a/libinterp/corefcn/jit-typeinfo.cc b/libinterp/corefcn/jit-typeinfo.cc
--- a/libinterp/corefcn/jit-typeinfo.cc
+++ b/libinterp/corefcn/jit-typeinfo.cc
@@ -208,34 +208,34 @@ octave_jit_cast_any_complex (Complex c)
 {
   if (c.imag () == 0)
     return new octave_scalar (c.real ());
   else
     return new octave_complex (c);
 }
 
 extern "C" void
-octave_jit_err_nan_to_logical_conversion (void)
+octave_jit_octave::err_nan_to_logical_conversion (void)
 {
-  err_nan_to_logical_conversion ();
+  octave::err_nan_to_logical_conversion ();
 }
 
 extern "C" void
 octave_jit_ginvalid_index (void)
 {
-  // FIXME: 0-argument form of err_invalid_index removed in cset dd6345fd8a97
+  // FIXME: 0-argument form of octave::err_invalid_index removed in cset dd6345fd8a97
   //        Report -1 as the bad index for all occurrences.
-  err_invalid_index (static_cast<octave_idx_type> (-1));
+  octave::err_invalid_index (static_cast<octave_idx_type> (-1));
 }
 
 extern "C" void
 octave_jit_gindex_range (int nd, int dim, octave_idx_type iext,
                          octave_idx_type ext)
 {
-  err_index_out_of_range (nd, dim, iext, ext);
+  octave::err_index_out_of_range (nd, dim, iext, ext);
 }
 
 extern "C" jit_matrix
 octave_jit_paren_subsasgn_impl (jit_matrix *mat, octave_idx_type index,
                                 double value)
 {
   NDArray *array = mat->array;
   if (array->numel () < index)
@@ -1501,17 +1501,17 @@ jit_typeinfo::jit_typeinfo (llvm::Module
     fn.do_return (builder, ret);
   }
   for_index_fn.add_overload (fn);
 
   // logically true
   logically_true_fn.stash_name ("logically_true");
 
   jit_function gripe_nantl
-    = create_external (JIT_FN (octave_jit_err_nan_to_logical_conversion), 0);
+    = create_external (JIT_FN (octave_jit_octave::err_nan_to_logical_conversion), 0);
   gripe_nantl.mark_can_error ();
 
   fn = create_internal ("octave_jit_logically_true_scalar", boolean, scalar);
   fn.mark_can_error ();
 
   body = fn.new_block ();
   builder.SetInsertPoint (body);
   {
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -86,17 +86,17 @@ load_path::dir_info::update (void)
                 }
               else
                 {
                   // We haven't seen this directory before.
 
                   initialize ();
                 }
             }
-          catch (const octave_execution_exception&)
+          catch (const octave::execution_exception&)
             {
               // Skip updating if we don't know where we are but
               // don't treat it as an error.
 
               recover_from_exception ();
             }
         }
       else if (fs.mtime () + fs.time_resolution () > dir_time_last_checked)
@@ -154,17 +154,17 @@ load_path::dir_info::initialize (void)
           std::string abs_name = octave::sys::env::make_absolute (dir_name);
 
           // FIXME: nothing is ever removed from this cache of
           // directory information, so there could be some resource
           // problems.  Perhaps it should be pruned from time to time.
 
           abs_dir_cache[abs_name] = *this;
         }
-      catch (const octave_execution_exception&)
+      catch (const octave::execution_exception&)
         {
           // Skip updating if we don't know where we are but don't treat
           // it as an error.
 
           recover_from_exception ();
         }
     }
   else
diff --git a/libinterp/corefcn/ls-mat-ascii.cc b/libinterp/corefcn/ls-mat-ascii.cc
--- a/libinterp/corefcn/ls-mat-ascii.cc
+++ b/libinterp/corefcn/ls-mat-ascii.cc
@@ -353,17 +353,17 @@ save_mat_ascii_data (std::ostream& os, c
     warning ("save: omitting imaginary part for ASCII file");
 
   Matrix m;
 
   try
     {
       m = val.matrix_value (true);
     }
-  catch (const octave_execution_exception& e)
+  catch (const octave::execution_exception& e)
     {
       recover_from_exception ();
 
       success = false;
     }
 
   if (success)
     {
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -1208,17 +1208,17 @@ read_mat5_binary_element (std::istream& 
                         != "")
                       {
                         try
                           {
                             octave_value_list tmp = feval ("loadobj", tc, 1);
 
                             tc = tmp(0);
                           }
-                        catch (const octave_execution_exception&)
+                        catch (const octave::execution_exception&)
                           {
                             goto data_read_error;
                           }
                       }
                   }
                 else
                   {
                     tc = m;
@@ -2605,17 +2605,17 @@ save_mat5_binary_element (std::ostream& 
                                      "saveobj") != "")
         {
           try
             {
               octave_value_list tmp = feval ("saveobj", tc, 1);
 
               m = tmp(0).map_value ();
             }
-          catch (const octave_execution_exception&)
+          catch (const octave::execution_exception&)
             {
               error ("save: error while writing '%s' to MAT file",
                      name.c_str ());
             }
         }
       else
         m = tc.map_value ();
 
diff --git a/libinterp/corefcn/lsode.cc b/libinterp/corefcn/lsode.cc
--- a/libinterp/corefcn/lsode.cc
+++ b/libinterp/corefcn/lsode.cc
@@ -71,17 +71,17 @@ lsode_user_function (const ColumnVector&
   if (lsode_fcn)
     {
       octave_value_list tmp;
 
       try
         {
           tmp = lsode_fcn->do_multi_index_op (1, args);
         }
-      catch (octave_execution_exception& e)
+      catch (octave::execution_exception& e)
         {
           err_user_supplied_eval (e, "lsode");
         }
 
       if (tmp.empty () || ! tmp(0).is_defined ())
         err_user_supplied_eval ("lsode");
 
       if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
@@ -111,17 +111,17 @@ lsode_user_jacobian (const ColumnVector&
   if (lsode_jac)
     {
       octave_value_list tmp;
 
       try
         {
           tmp = lsode_jac->do_multi_index_op (1, args);
         }
-      catch (octave_execution_exception& e)
+      catch (octave::execution_exception& e)
         {
           err_user_supplied_eval (e, "lsode");
         }
 
       if (tmp.empty () || ! tmp(0).is_defined ())
         err_user_supplied_eval ("lsode");
 
       if (! warned_jac_imaginary && tmp(0).is_complex_type ())
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -3064,17 +3064,17 @@ mexCallMATLAB (int nargout, mxArray *arg
   bool execution_error = false;
 
   octave_value_list retval;
 
   try
     {
       retval = feval (fname, args, nargout);
     }
-  catch (const octave_execution_exception&)
+  catch (const octave::execution_exception&)
     {
       if (mex_context->trap_feval_error)
         recover_from_exception ();
       else
         {
           args.resize (0);
           retval.resize (0);
 
@@ -3119,17 +3119,17 @@ mexEvalString (const char *s)
   octave_value_list ret;
 
   bool execution_error = false;
 
   try
     {
       ret = eval_string (s, false, parse_status, 0);
     }
-  catch (const octave_execution_exception&)
+  catch (const octave::execution_exception&)
     {
       recover_from_exception ();
 
       execution_error = true;
     }
 
   if (parse_status || execution_error)
     retval = 1;
diff --git a/libinterp/corefcn/oct-handle.h b/libinterp/corefcn/oct-handle.h
--- a/libinterp/corefcn/oct-handle.h
+++ b/libinterp/corefcn/oct-handle.h
@@ -43,17 +43,17 @@ public:
     if (a.is_empty ())
       ; // do nothing
     else
       {
         try
           {
             val = a.double_value ();
           }
-        catch (octave_execution_exception& e)
+        catch (octave::execution_exception& e)
           {
             error (e, "invalid handle");
           }
       }
   }
 
   octave_handle (int a) : val (a) { }
 
diff --git a/libinterp/corefcn/oct-map.cc b/libinterp/corefcn/oct-map.cc
--- a/libinterp/corefcn/oct-map.cc
+++ b/libinterp/corefcn/oct-map.cc
@@ -646,17 +646,17 @@ permute_to_correct_order (octave_idx_typ
         {
           if (i == idx)
             continue;
 
           permute_to_correct_order1 (map_list[idx], map_list[i],
                                      new_map_list[i], perm);
         }
     }
-  catch (octave_execution_exception& e)
+  catch (octave::execution_exception& e)
     {
       error (e, "cat: field names mismatch in concatenating structs");
     }
 }
 
 octave_map
 octave_map::cat (int dim, octave_idx_type n, const octave_scalar_map *map_list)
 {
@@ -930,17 +930,17 @@ octave_map::index (const octave_value_li
             for (k = 0; k < n_idx; k++)
               ia(k) = idx(k).index_vector ();
 
             retval = index (ia, resize_ok);
           }
           break;
         }
     }
-  catch (index_exception& e)
+  catch (octave::index_exception& e)
     {
       // Rethrow to allow more info to be reported later.
       e.set_pos_if_unset (n_idx, k+1);
       throw;
     }
 
   return retval;
 }
@@ -993,17 +993,17 @@ octave_map::assign (const idx_vector& i,
     {
       Array<octave_idx_type> perm;
       octave_map rhs1;
 
       try
         {
           rhs1 = rhs.orderfields (*this, perm);
         }
-      catch (octave_execution_exception& e)
+      catch (octave::execution_exception& e)
         {
           error (e, "incompatible fields in struct assignment");
         }
 
       assert (rhs1.xkeys.is_same (xkeys));
       assign (i, rhs1);
     }
 }
@@ -1041,17 +1041,17 @@ octave_map::assign (const idx_vector& i,
     {
       Array<octave_idx_type> perm;
       octave_map rhs1;
 
       try
         {
           rhs1 = rhs.orderfields (*this, perm);
         }
-      catch (octave_execution_exception& e)
+      catch (octave::execution_exception& e)
         {
           error (e, "incompatible fields in struct assignment");
         }
 
       assert (rhs1.xkeys.is_same (xkeys));
       assign (i, j, rhs1);
     }
 }
@@ -1089,17 +1089,17 @@ octave_map::assign (const Array<idx_vect
     {
       Array<octave_idx_type> perm;
       octave_map rhs1;
 
       try
         {
           rhs1 = rhs.orderfields (*this, perm);
         }
-      catch (octave_execution_exception& e)
+      catch (octave::execution_exception& e)
         {
           error (e, "incompatible fields in struct assignment");
         }
 
       assert (rhs1.xkeys.is_same (xkeys));
       assign (ia, rhs1);
     }
 }
@@ -1145,17 +1145,17 @@ octave_map::assign (const octave_value_l
             for (k = 0; k < n_idx; k++)
               ia(k) = idx(k).index_vector ();
 
             assign (ia, rhs);
           }
           break;
         }
     }
-  catch (index_exception& e)
+  catch (octave::index_exception& e)
     {
       // Rethrow to allow more info to be reported later.
       e.set_pos_if_unset (n_idx, k+1);
       throw;
     }
 }
 
 void
@@ -1264,17 +1264,17 @@ octave_map::delete_elements (const octav
   Array<idx_vector> ia (dim_vector (n_idx, 1));
 
   for (octave_idx_type i = 0; i < n_idx; i++)
     {
       try
         {
           ia(i) = idx(i).index_vector ();
         }
-      catch (index_exception& e)
+      catch (octave::index_exception& e)
         {
           // Rethrow to allow more info to be reported later.
           e.set_pos_if_unset (n_idx, i+1);
           throw;
         }
     }
 
   delete_elements (ia);
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -82,17 +82,17 @@ convert_to_valid_int (const octave_value
   int retval = 0;
 
   double dval = 0.0;
 
   try
     {
       dval = tc.double_value ();
     }
-  catch (const octave_execution_exception&)
+  catch (const octave::execution_exception&)
     {
       recover_from_exception ();
 
       conv_err = 1;
     }
 
   if (! conv_err)
     {
@@ -6459,17 +6459,17 @@ octave_stream::read (const Array<double>
   octave_idx_type char_count = 0;
 
   count = 0;
 
   try
     {
       get_size (size, nr, nc, one_elt_size_spec, "fread");
     }
-  catch (const octave_execution_exception&)
+  catch (const octave::execution_exception&)
     {
       invalid_operation ("fread", "reading");
     }
 
   octave_idx_type elts_to_read;
 
   if (one_elt_size_spec)
     {
diff --git a/libinterp/corefcn/quad.cc b/libinterp/corefcn/quad.cc
--- a/libinterp/corefcn/quad.cc
+++ b/libinterp/corefcn/quad.cc
@@ -68,17 +68,17 @@ quad_user_function (double x)
   if (quad_fcn)
     {
       octave_value_list tmp;
 
       try
         {
           tmp = quad_fcn->do_multi_index_op (1, args);
         }
-      catch (octave_execution_exception& e)
+      catch (octave::execution_exception& e)
         {
           err_user_supplied_eval (e, "quad");
         }
 
       if (! tmp.length () || ! tmp(0).is_defined ())
         err_user_supplied_eval ("quad");
 
       if (! warned_imaginary && tmp(0).is_complex_type ())
@@ -104,17 +104,17 @@ quad_float_user_function (float x)
   if (quad_fcn)
     {
       octave_value_list tmp;
 
       try
         {
           tmp = quad_fcn->do_multi_index_op (1, args);
         }
-      catch (octave_execution_exception& e)
+      catch (octave::execution_exception& e)
         {
           err_user_supplied_eval (e, "quad");
         }
 
       if (! tmp.length () || ! tmp(0).is_defined ())
         err_user_supplied_eval ("quad");
 
       if (! warned_imaginary && tmp(0).is_complex_type ())
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -180,17 +180,17 @@ do_rand (const octave_value_list& args, 
         else if (tmp.is_matrix_type ())
           {
             Array<int> iv;
 
             try
               {
                 iv = tmp.int_vector_value (true);
               }
-            catch (octave_execution_exception& e)
+            catch (octave::execution_exception& e)
               {
                 error (e, "%s: dimensions must be a scalar or array of integers", fcn);
               }
 
             octave_idx_type len = iv.numel ();
 
             dims.resize (len);
 
diff --git a/libinterp/corefcn/sparse-xdiv.cc b/libinterp/corefcn/sparse-xdiv.cc
--- a/libinterp/corefcn/sparse-xdiv.cc
+++ b/libinterp/corefcn/sparse-xdiv.cc
@@ -39,32 +39,32 @@ along with Octave; see the file COPYING.
 #include "CSparse.h"
 #include "CDiagMatrix.h"
 #include "oct-spparms.h"
 #include "sparse-xdiv.h"
 
 static void
 solve_singularity_warning (double rcond)
 {
-  warn_singular_matrix (rcond);
+  octave::warn_singular_matrix (rcond);
 }
 
 template <typename T1, typename T2>
 bool
 mx_leftdiv_conform (const T1& a, const T2& b)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type b_nr = b.rows ();
 
   if (a_nr != b_nr)
     {
       octave_idx_type a_nc = a.cols ();
       octave_idx_type b_nc = b.cols ();
 
-      err_nonconformant ("operator \\", a_nr, a_nc, b_nr, b_nc);
+      octave::err_nonconformant ("operator \\", a_nr, a_nc, b_nr, b_nc);
     }
 
   return true;
 }
 
 #define INSTANTIATE_MX_LEFTDIV_CONFORM(T1, T2)                  \
   template bool mx_leftdiv_conform (const T1&, const T2&)
 
@@ -88,17 +88,17 @@ mx_div_conform (const T1& a, const T2& b
   octave_idx_type a_nc = a.cols ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nc)
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type b_nr = b.rows ();
 
-      err_nonconformant ("operator /", a_nr, a_nc, b_nr, b_nc);
+      octave::err_nonconformant ("operator /", a_nr, a_nc, b_nr, b_nc);
     }
 
   return true;
 }
 
 #define INSTANTIATE_MX_DIV_CONFORM(T1, T2)              \
   template bool mx_div_conform (const T1&, const T2&)
 
diff --git a/libinterp/corefcn/sparse-xpow.cc b/libinterp/corefcn/sparse-xpow.cc
--- a/libinterp/corefcn/sparse-xpow.cc
+++ b/libinterp/corefcn/sparse-xpow.cc
@@ -411,17 +411,17 @@ elem_xpow (const SparseMatrix& a, const 
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a.numel () == 1 && b.numel () > 1)
     return scalar_xpow (a(0), b);
 
   if (nr != b_nr || nc != b_nc)
-    err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
+    octave::err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   int convert_to_complex = 0;
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
       {
         if (a.data(i) < 0.0)
           {
             double btmp = b (a.ridx (i), j);
@@ -513,17 +513,17 @@ elem_xpow (const SparseMatrix& a, const 
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a.numel () == 1 && b.numel () > 1)
     return scalar_xpow (a(0), b);
 
   if (nr != b_nr || nc != b_nc)
-    err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
+    octave::err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   SparseComplexMatrix result (nr, nc, Complex (1.0, 0.0));
   for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
         {
           octave_quit ();
           result.xelem (a.ridx(i), j) = std::pow (a.data (i), b(a.ridx (i), j));
@@ -653,17 +653,17 @@ elem_xpow (const SparseComplexMatrix& a,
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a.numel () == 1 && b.numel () > 1)
     return scalar_xpow (a(0), b);
 
   if (nr != b_nr || nc != b_nc)
-    err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
+    octave::err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   SparseComplexMatrix result (nr, nc, Complex (1.0, 0.0));
   for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
         {
           octave_quit ();
           double btmp = b(a.ridx (i), j);
@@ -720,17 +720,17 @@ elem_xpow (const SparseComplexMatrix& a,
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a.numel () == 1 && b.numel () > 1)
     return scalar_xpow (a(0), b);
 
   if (nr != b_nr || nc != b_nc)
-    err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
+    octave::err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   SparseComplexMatrix result (nr, nc, Complex (1.0, 0.0));
   for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
         {
           octave_quit ();
           result.xelem (a.ridx (i), j) = std::pow (a.data (i),
diff --git a/libinterp/corefcn/sparse.cc b/libinterp/corefcn/sparse.cc
--- a/libinterp/corefcn/sparse.cc
+++ b/libinterp/corefcn/sparse.cc
@@ -204,17 +204,17 @@ Compressed Column Sparse (rows = 3, cols
             retval = SparseComplexMatrix (args(2).complex_array_value(),
                                           i, j, m, n, summation, nzmax);
           else if (args(2).is_numeric_type ())
             retval = SparseMatrix (args(2).array_value (), i, j,
                                    m, n, summation, nzmax);
           else
             err_wrong_type_arg ("sparse", args(2));
         }
-      catch (index_exception& e)
+      catch (octave::index_exception& e)
         {
           // Rethrow to allow more info to be reported later.
           e.set_pos_if_unset (2, k+1);
           throw;
         }
     }
 
   return retval;
diff --git a/libinterp/corefcn/sub2ind.cc b/libinterp/corefcn/sub2ind.cc
--- a/libinterp/corefcn/sub2ind.cc
+++ b/libinterp/corefcn/sub2ind.cc
@@ -107,17 +107,17 @@ ind = sub2ind ([3, 3], s1, s2)
 
       try
         {
           idxa(j) = args(j+1).index_vector ();
 
           if (j > 0 && args(j+1).dims () != args(1).dims ())
             error ("sub2ind: all subscripts must be of the same size");
         }
-      catch (index_exception& e)
+      catch (octave::index_exception& e)
         {
           e.set_pos_if_unset (nargin-1, j+1);
           e.set_var ();
           std::string msg = e.message ();
           error_with_id (e.err_id (), msg.c_str ());
         }
     }
 
@@ -229,17 +229,17 @@ r = ind2sub (dims, ind)
 
   // Redimension to provided number of subscripts.
   dim_vector dv = get_dim_vector (args(0), "ind2sub").redim (nargout);
 
   try
     {
       retval = Array<octave_value> (ind2sub (dv, args(1).index_vector ()));
     }
-  catch (const index_exception& e)
+  catch (const octave::index_exception& e)
     {
       error ("ind2sub: Invalid index %s. %s", e.idx ().c_str (),
         e.details ().c_str ());
     }
 
   return retval;
 }
 
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -224,17 +224,17 @@ command shell that is started to run the
   bool return_output = (nargin == 1 && nargout > 1);
 
   if (nargin > 1)
     {
       try
         {
           return_output = args(1).is_true ();
         }
-      catch (octave_execution_exception& e)
+      catch (octave::execution_exception& e)
         {
           error (e, "system: RETURN_OUTPUT must be boolean value true or false");
         }
     }
 
   if (return_output && type == et_async)
     error ("system: can't return output from commands run asynchronously");
 
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -1199,17 +1199,17 @@ dims_to_numel (const dim_vector& dims, c
           else
             {
               try
                 {
                   idx_vector jdx = idxi.index_vector ();
 
                   retval *= jdx.length (dv(i));
                 }
-              catch (const index_exception& e)
+              catch (const octave::index_exception& e)
                 {
                   std::string idx = e.idx ();
                   std::string msg = e.details ();
 
                   error ("dims_to_numel: Invalid IDX %s. %s",
                          idx.c_str (), msg.c_str ());
                 }
             }
@@ -1367,17 +1367,17 @@ character @nospell{"@xbackslashchar{}0"}
     {
       idx_vector idx = args(0).index_vector (true);
 
       if (nargin == 2)
         retval = idx.extent (n) <= n;
       else
         retval = true;
     }
-  catch (const octave_execution_exception&)
+  catch (const octave::execution_exception&)
     {
       recover_from_exception ();
 
       retval = false;
     }
 
   return retval;
 }
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -279,17 +279,17 @@ generate_struct_completions (const std::
               octave_value tmp = eval_string (prefix, true, parse_status);
 
               frame.run ();
 
               if (tmp.is_defined ()
                   && (tmp.is_map () || tmp.is_java () || tmp.is_classdef_object ()))
                 names = tmp.map_keys ();
             }
-          catch (const octave_execution_exception&)
+          catch (const octave::execution_exception&)
             {
               recover_from_exception ();
             }
         }
     }
 
   // Undo look-back that found the array expression,
   // but insert an extra "." to distinguish from the non-struct case.
diff --git a/libinterp/corefcn/xdiv.cc b/libinterp/corefcn/xdiv.cc
--- a/libinterp/corefcn/xdiv.cc
+++ b/libinterp/corefcn/xdiv.cc
@@ -54,33 +54,33 @@ result_ok (octave_idx_type info)
   assert (info != -1);
 
   return (info != -2);
 }
 
 static void
 solve_singularity_warning (double rcond)
 {
-  warn_singular_matrix (rcond);
+  octave::warn_singular_matrix (rcond);
 }
 
 template <typename T1, typename T2>
 bool
 mx_leftdiv_conform (const T1& a, const T2& b, blas_trans_type blas_trans)
 {
   octave_idx_type a_nr = blas_trans == blas_no_trans ? a.rows () : a.cols ();
   octave_idx_type b_nr = b.rows ();
 
   if (a_nr != b_nr)
     {
       octave_idx_type a_nc = blas_trans == blas_no_trans ? a.cols ()
                                                          : a.rows ();
       octave_idx_type b_nc = b.cols ();
 
-      err_nonconformant ("operator \\", a_nr, a_nc, b_nr, b_nc);
+      octave::err_nonconformant ("operator \\", a_nr, a_nc, b_nr, b_nc);
     }
 
   return true;
 }
 
 #define INSTANTIATE_MX_LEFTDIV_CONFORM(T1, T2)                          \
   template bool mx_leftdiv_conform (const T1&, const T2&, blas_trans_type)
 
@@ -96,17 +96,17 @@ mx_div_conform (const T1& a, const T2& b
   octave_idx_type a_nc = a.cols ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nc)
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type b_nr = b.rows ();
 
-      err_nonconformant ("operator /", a_nr, a_nc, b_nr, b_nc);
+      octave::err_nonconformant ("operator /", a_nr, a_nc, b_nr, b_nc);
     }
 
   return true;
 }
 
 #define INSTANTIATE_MX_DIV_CONFORM(T1, T2)              \
   template bool mx_div_conform (const T1&, const T2&)
 
@@ -398,17 +398,17 @@ xleftdiv (const ComplexMatrix& a, const 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 static void
 solve_singularity_warning (float rcond)
 {
-  warn_singular_matrix (rcond);
+  octave::warn_singular_matrix (rcond);
 }
 
 INSTANTIATE_MX_LEFTDIV_CONFORM (FloatMatrix, FloatMatrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (FloatMatrix, FloatComplexMatrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (FloatComplexMatrix, FloatMatrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (FloatComplexMatrix, FloatComplexMatrix);
 
 INSTANTIATE_MX_DIV_CONFORM (FloatMatrix, FloatMatrix);
diff --git a/libinterp/corefcn/xpow.cc b/libinterp/corefcn/xpow.cc
--- a/libinterp/corefcn/xpow.cc
+++ b/libinterp/corefcn/xpow.cc
@@ -136,17 +136,17 @@ xpow (double a, const Matrix& b)
       ComplexDiagMatrix D (lambda);
 
       ComplexMatrix C = Q * D * Q.inverse ();
       if (a > 0)
         retval = real (C);
       else
         retval = C;
     }
-  catch (const octave_execution_exception&)
+  catch (const octave::execution_exception&)
     {
       err_failed_diagonalization ();
     }
 
   return retval;
 }
 
 // -*- 3 -*-
@@ -183,17 +183,17 @@ xpow (double a, const ComplexMatrix& b)
             lambda(i) = std::pow (a, std::real (elt));
           else
             lambda(i) = std::pow (a, elt);
         }
       ComplexDiagMatrix D (lambda);
 
       retval = ComplexMatrix (Q * D * Q.inverse ());
     }
-  catch (const octave_execution_exception&)
+  catch (const octave::execution_exception&)
     {
       err_failed_diagonalization ();
     }
 
   return retval;
 }
 
 // -*- 5 -*-
@@ -266,17 +266,17 @@ xpow (const Matrix& a, double b)
 
           for (octave_idx_type i = 0; i < nr; i++)
             lambda(i) = std::pow (lambda(i), b);
 
           ComplexDiagMatrix D (lambda);
 
           retval = ComplexMatrix (Q * D * Q.inverse ());
         }
-      catch (const octave_execution_exception&)
+      catch (const octave::execution_exception&)
         {
           err_failed_diagonalization ();
         }
     }
 
   return retval;
 }
 
@@ -342,17 +342,17 @@ xpow (const Matrix& a, const Complex& b)
 
       for (octave_idx_type i = 0; i < nr; i++)
         lambda(i) = std::pow (lambda(i), b);
 
       ComplexDiagMatrix D (lambda);
 
       retval = ComplexMatrix (Q * D * Q.inverse ());
     }
-  catch (const octave_execution_exception&)
+  catch (const octave::execution_exception&)
     {
       err_failed_diagonalization ();
     }
 
   return retval;
 }
 
 // -*- 7 -*-
@@ -395,17 +395,17 @@ xpow (const Complex& a, const Matrix& b)
             lambda(i) = std::pow (a, std::real (elt));
           else
             lambda(i) = std::pow (a, elt);
         }
       ComplexDiagMatrix D (lambda);
 
       retval = ComplexMatrix (Q * D * Q.inverse ());
     }
-  catch (const octave_execution_exception&)
+  catch (const octave::execution_exception&)
     {
       err_failed_diagonalization ();
     }
 
   return retval;
 }
 
 // -*- 9 -*-
@@ -443,17 +443,17 @@ xpow (const Complex& a, const ComplexMat
             lambda(i) = std::pow (a, std::real (elt));
           else
             lambda(i) = std::pow (a, elt);
         }
       ComplexDiagMatrix D (lambda);
 
       retval = ComplexMatrix (Q * D * Q.inverse ());
     }
-  catch (const octave_execution_exception&)
+  catch (const octave::execution_exception&)
     {
       err_failed_diagonalization ();
     }
 
   return retval;
 }
 
 // -*- 11 -*-
@@ -526,17 +526,17 @@ xpow (const ComplexMatrix& a, double b)
 
           for (octave_idx_type i = 0; i < nr; i++)
             lambda(i) = std::pow (lambda(i), b);
 
           ComplexDiagMatrix D (lambda);
 
           retval = ComplexMatrix (Q * D * Q.inverse ());
         }
-      catch (const octave_execution_exception&)
+      catch (const octave::execution_exception&)
         {
           err_failed_diagonalization ();
         }
     }
 
   return retval;
 }
 
@@ -561,17 +561,17 @@ xpow (const ComplexMatrix& a, const Comp
 
       for (octave_idx_type i = 0; i < nr; i++)
         lambda(i) = std::pow (lambda(i), b);
 
       ComplexDiagMatrix D (lambda);
 
       retval = ComplexMatrix (Q * D * Q.inverse ());
     }
-  catch (const octave_execution_exception&)
+  catch (const octave::execution_exception&)
     {
       err_failed_diagonalization ();
     }
 
   return retval;
 }
 
 // -*- 12d -*-
@@ -791,17 +791,17 @@ elem_xpow (const Matrix& a, const Matrix
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
-    err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
+    octave::err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   int convert_to_complex = 0;
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
         double atmp = a (i, j);
         double btmp = b (i, j);
@@ -871,17 +871,17 @@ elem_xpow (const Matrix& a, const Comple
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
-    err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
+    octave::err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
         result (i, j) = std::pow (Complex (a (i, j)), b (i, j));
@@ -1008,17 +1008,17 @@ elem_xpow (const ComplexMatrix& a, const
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
-    err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
+    octave::err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
         double btmp = b (i, j);
@@ -1056,17 +1056,17 @@ elem_xpow (const ComplexMatrix& a, const
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
-    err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
+    octave::err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
         result (i, j) = std::pow (a (i, j), b (i, j));
@@ -1228,17 +1228,17 @@ elem_xpow (const NDArray& a, const NDArr
   octave_value retval;
 
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
       if (! is_valid_bsxfun ("operator .^", a_dims, b_dims))
-        err_nonconformant ("operator .^", a_dims, b_dims);
+        octave::err_nonconformant ("operator .^", a_dims, b_dims);
 
       //Potentially complex results
       NDArray xa = octave_value_extract<NDArray> (a);
       NDArray xb = octave_value_extract<NDArray> (b);
       if (! xb.all_integers () && xa.any_element_is_negative ())
         return octave_value (bsxfun_pow (ComplexNDArray (xa), xb));
       else
         return octave_value (bsxfun_pow (xa, xb));
@@ -1311,17 +1311,17 @@ octave_value
 elem_xpow (const NDArray& a, const ComplexNDArray& b)
 {
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
       if (! is_valid_bsxfun ("operator .^", a_dims, b_dims))
-        err_nonconformant ("operator .^", a_dims, b_dims);
+        octave::err_nonconformant ("operator .^", a_dims, b_dims);
 
       return bsxfun_pow (a, b);
     }
 
   ComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.numel (); i++)
     {
@@ -1405,17 +1405,17 @@ octave_value
 elem_xpow (const ComplexNDArray& a, const NDArray& b)
 {
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
       if (! is_valid_bsxfun ("operator .^", a_dims, b_dims))
-        err_nonconformant ("operator .^", a_dims, b_dims);
+        octave::err_nonconformant ("operator .^", a_dims, b_dims);
 
       return bsxfun_pow (a, b);
     }
 
   ComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.numel (); i++)
     {
@@ -1450,17 +1450,17 @@ octave_value
 elem_xpow (const ComplexNDArray& a, const ComplexNDArray& b)
 {
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
       if (! is_valid_bsxfun ("operator .^", a_dims, b_dims))
-        err_nonconformant ("operator .^", a_dims, b_dims);
+        octave::err_nonconformant ("operator .^", a_dims, b_dims);
 
       return bsxfun_pow (a, b);
     }
 
   ComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.numel (); i++)
     {
@@ -1541,17 +1541,17 @@ xpow (float a, const FloatMatrix& b)
 
       FloatComplexMatrix C = Q * D * Q.inverse ();
 
       if (a > 0)
         retval = real (C);
       else
         retval = C;
     }
-  catch (const octave_execution_exception&)
+  catch (const octave::execution_exception&)
     {
       err_failed_diagonalization ();
     }
 
   return retval;
 }
 
 // -*- 3 -*-
@@ -1588,17 +1588,17 @@ xpow (float a, const FloatComplexMatrix&
             lambda(i) = std::pow (a, std::real (elt));
           else
             lambda(i) = std::pow (a, elt);
         }
       FloatComplexDiagMatrix D (lambda);
 
       retval = FloatComplexMatrix (Q * D * Q.inverse ());
     }
-  catch (const octave_execution_exception&)
+  catch (const octave::execution_exception&)
     {
       err_failed_diagonalization ();
     }
 
   return retval;
 }
 
 // -*- 5 -*-
@@ -1671,17 +1671,17 @@ xpow (const FloatMatrix& a, float b)
 
           for (octave_idx_type i = 0; i < nr; i++)
             lambda(i) = std::pow (lambda(i), b);
 
           FloatComplexDiagMatrix D (lambda);
 
           retval = FloatComplexMatrix (Q * D * Q.inverse ());
         }
-      catch (const octave_execution_exception&)
+      catch (const octave::execution_exception&)
         {
           err_failed_diagonalization ();
         }
     }
 
   return retval;
 }
 
@@ -1737,17 +1737,17 @@ xpow (const FloatMatrix& a, const FloatC
 
       for (octave_idx_type i = 0; i < nr; i++)
         lambda(i) = std::pow (lambda(i), b);
 
       FloatComplexDiagMatrix D (lambda);
 
       retval = FloatComplexMatrix (Q * D * Q.inverse ());
     }
-  catch (const octave_execution_exception&)
+  catch (const octave::execution_exception&)
     {
       err_failed_diagonalization ();
     }
 
   return retval;
 }
 
 // -*- 7 -*-
@@ -1790,17 +1790,17 @@ xpow (const FloatComplex& a, const Float
             lambda(i) = std::pow (a, std::real (elt));
           else
             lambda(i) = std::pow (a, elt);
         }
       FloatComplexDiagMatrix D (lambda);
 
       retval = FloatComplexMatrix (Q * D * Q.inverse ());
     }
-  catch (const octave_execution_exception&)
+  catch (const octave::execution_exception&)
     {
       err_failed_diagonalization ();
     }
 
   return retval;
 }
 
 // -*- 9 -*-
@@ -1838,17 +1838,17 @@ xpow (const FloatComplex& a, const Float
             lambda(i) = std::pow (a, std::real (elt));
           else
             lambda(i) = std::pow (a, elt);
         }
       FloatComplexDiagMatrix D (lambda);
 
       retval = FloatComplexMatrix (Q * D * Q.inverse ());
     }
-  catch (const octave_execution_exception&)
+  catch (const octave::execution_exception&)
     {
       err_failed_diagonalization ();
     }
 
   return retval;
 }
 
 // -*- 11 -*-
@@ -1921,17 +1921,17 @@ xpow (const FloatComplexMatrix& a, float
 
           for (octave_idx_type i = 0; i < nr; i++)
             lambda(i) = std::pow (lambda(i), b);
 
           FloatComplexDiagMatrix D (lambda);
 
           retval = FloatComplexMatrix (Q * D * Q.inverse ());
         }
-      catch (const octave_execution_exception&)
+      catch (const octave::execution_exception&)
         {
           err_failed_diagonalization ();
         }
     }
 
   return retval;
 }
 
@@ -1956,17 +1956,17 @@ xpow (const FloatComplexMatrix& a, const
 
       for (octave_idx_type i = 0; i < nr; i++)
         lambda(i) = std::pow (lambda(i), b);
 
       FloatComplexDiagMatrix D (lambda);
 
       retval = FloatComplexMatrix (Q * D * Q.inverse ());
     }
-  catch (const octave_execution_exception&)
+  catch (const octave::execution_exception&)
     {
       err_failed_diagonalization ();
     }
 
   return retval;
 }
 
 // -*- 12d -*-
@@ -2142,17 +2142,17 @@ elem_xpow (const FloatMatrix& a, const F
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
-    err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
+    octave::err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   int convert_to_complex = 0;
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
         float atmp = a (i, j);
         float btmp = b (i, j);
@@ -2222,17 +2222,17 @@ elem_xpow (const FloatMatrix& a, const F
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
-    err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
+    octave::err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
         result (i, j) = std::pow (FloatComplex (a (i, j)), b (i, j));
@@ -2320,17 +2320,17 @@ elem_xpow (const FloatComplexMatrix& a, 
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
-    err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
+    octave::err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
         float btmp = b (i, j);
@@ -2368,17 +2368,17 @@ elem_xpow (const FloatComplexMatrix& a, 
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
-    err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
+    octave::err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
         result (i, j) = std::pow (a (i, j), b (i, j));
@@ -2540,17 +2540,17 @@ elem_xpow (const FloatNDArray& a, const 
   octave_value retval;
 
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
       if (! is_valid_bsxfun ("operator .^", a_dims, b_dims))
-        err_nonconformant ("operator .^", a_dims, b_dims);
+        octave::err_nonconformant ("operator .^", a_dims, b_dims);
 
       //Potentially complex results
       FloatNDArray xa = octave_value_extract<FloatNDArray> (a);
       FloatNDArray xb = octave_value_extract<FloatNDArray> (b);
       if (! xb.all_integers () && xa.any_element_is_negative ())
         return octave_value (bsxfun_pow (FloatComplexNDArray (xa), xb));
       else
         return octave_value (bsxfun_pow (xa, xb));
@@ -2623,17 +2623,17 @@ octave_value
 elem_xpow (const FloatNDArray& a, const FloatComplexNDArray& b)
 {
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
       if (! is_valid_bsxfun ("operator .^", a_dims, b_dims))
-        err_nonconformant ("operator .^", a_dims, b_dims);
+        octave::err_nonconformant ("operator .^", a_dims, b_dims);
 
       return bsxfun_pow (a, b);
     }
 
   FloatComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.numel (); i++)
     {
@@ -2717,17 +2717,17 @@ octave_value
 elem_xpow (const FloatComplexNDArray& a, const FloatNDArray& b)
 {
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
       if (! is_valid_bsxfun ("operator .^", a_dims, b_dims))
-        err_nonconformant ("operator .^", a_dims, b_dims);
+        octave::err_nonconformant ("operator .^", a_dims, b_dims);
 
       return bsxfun_pow (a, b);
     }
 
   FloatComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.numel (); i++)
     {
@@ -2762,17 +2762,17 @@ octave_value
 elem_xpow (const FloatComplexNDArray& a, const FloatComplexNDArray& b)
 {
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
       if (! is_valid_bsxfun ("operator .^", a_dims, b_dims))
-        err_nonconformant ("operator .^", a_dims, b_dims);
+        octave::err_nonconformant ("operator .^", a_dims, b_dims);
 
       return bsxfun_pow (a, b);
     }
 
   FloatComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.numel (); i++)
     {
diff --git a/libinterp/dldfcn/__eigs__.cc b/libinterp/dldfcn/__eigs__.cc
--- a/libinterp/dldfcn/__eigs__.cc
+++ b/libinterp/dldfcn/__eigs__.cc
@@ -58,17 +58,17 @@ eigs_func (const ColumnVector &x, int &e
   if (eigs_fcn)
     {
       octave_value_list tmp;
 
       try
         {
           tmp = eigs_fcn->do_multi_index_op (1, args);
         }
-      catch (octave_execution_exception& e)
+      catch (octave::execution_exception& e)
         {
           err_user_supplied_eval (e, "eigs");
         }
 
       if (tmp.length () && tmp(0).is_defined ())
         {
           if (! warned_imaginary && tmp(0).is_complex_type ())
             {
@@ -98,17 +98,17 @@ eigs_complex_func (const ComplexColumnVe
   if (eigs_fcn)
     {
       octave_value_list tmp;
 
       try
         {
           tmp = eigs_fcn->do_multi_index_op (1, args);
         }
-      catch (octave_execution_exception& e)
+      catch (octave::execution_exception& e)
         {
           err_user_supplied_eval (e, "eigs");
         }
 
       if (tmp.length () && tmp(0).is_defined ())
         {
           retval = tmp(0).complex_vector_value ("eigs: evaluation of user-supplied function failed");
         }
diff --git a/libinterp/dldfcn/__init_gnuplot__.cc b/libinterp/dldfcn/__init_gnuplot__.cc
--- a/libinterp/dldfcn/__init_gnuplot__.cc
+++ b/libinterp/dldfcn/__init_gnuplot__.cc
@@ -193,17 +193,17 @@ have_gnuplot_binary (void)
               gnuplot_path = search_path_for_file (path, args);
 
               fs = octave::sys::file_stat (gnuplot_path);
             }
 
           retval = fs.exists ();
         }
     }
-  catch (octave_execution_exception&)
+  catch (octave::execution_exception&)
     {
     }
 
   return retval;
 }
 
 // Initialize the gnuplot graphics toolkit.
 
diff --git a/libinterp/octave-value/ov-base-diag.cc b/libinterp/octave-value/ov-base-diag.cc
--- a/libinterp/octave-value/ov-base-diag.cc
+++ b/libinterp/octave-value/ov-base-diag.cc
@@ -123,17 +123,17 @@ octave_base_diag<DMT, MT>::do_index_op (
                   DMT rm (matrix);
                   rm.resize (m, n);
                   retval = rm;
                 }
               else
                 retval = to_dense ().do_index_op (idx, resize_ok);
             }
         }
-      catch (index_exception& e)
+      catch (octave::index_exception& e)
         {
           // Rethrow to allow more info to be reported later.
           e.set_pos_if_unset (2, k+1);
           throw;
         }
     }
   else
     retval = to_dense ().do_index_op (idx, resize_ok);
@@ -187,17 +187,17 @@ octave_base_diag<DMT, MT>::subsasgn (con
                   {
                     matrix.dgelem (i0(0)) = val;
                     retval = this;
                     this->count++;
                     // invalidate cache
                     dense_cache = octave_value ();
                   }
               }
-            catch (index_exception& e)
+            catch (octave::index_exception& e)
               {
                 // Rethrow to allow more info to be reported later.
                 e.set_pos_if_unset (2, k+1);
                 throw;
               }
           }
         else if (jdx.length () == 2
                  && jdx(0).is_scalar_type () && jdx(1).is_scalar_type ())
@@ -215,17 +215,17 @@ octave_base_diag<DMT, MT>::subsasgn (con
                   {
                     matrix.dgelem (i0(0)) = val;
                     retval = this;
                     this->count++;
                     // invalidate cache
                     dense_cache = octave_value ();
                   }
               }
-            catch (index_exception& e)
+            catch (octave::index_exception& e)
               {
                 // Rethrow to allow more info to be reported later.
                 e.set_pos_if_unset (2, k+1);
                 throw;
               }
           }
 
         if (! retval.is_defined ())
diff --git a/libinterp/octave-value/ov-base-mat.cc b/libinterp/octave-value/ov-base-mat.cc
--- a/libinterp/octave-value/ov-base-mat.cc
+++ b/libinterp/octave-value/ov-base-mat.cc
@@ -194,17 +194,17 @@ octave_base_matrix<MT>::do_index_op (con
             if (scalar_opt)
               retval = cmatrix.checkelem (conv_to_int_array (idx_vec));
             else
               retval = MT (matrix.index (idx_vec, resize_ok));
           }
           break;
         }
     }
-  catch (index_exception& e)
+  catch (octave::index_exception& e)
     {
       // Rethrow to allow more info to be reported later.
       e.set_pos_if_unset (n_idx, k+1);
       throw;
     }
 
   return retval;
 }
@@ -255,19 +255,19 @@ octave_base_matrix<MT>::assign (const oc
               for (k = 0; k < n_idx; k++)
                 idx_vec(k) = idx(k).index_vector ();
 
               matrix.assign (idx_vec, rhs);
             }
             break;
         }
     }
-  catch (const index_exception& e)
+  catch (const octave::index_exception& e)
     {
-      err_invalid_index (e.idx (), n_idx, k+1);
+      octave::err_invalid_index (e.idx (), n_idx, k+1);
     }
 
   // Clear cache.
   clear_cached_info ();
 }
 
 template <typename MT>
 MatrixType
@@ -359,19 +359,19 @@ octave_base_matrix<MT>::assign (const oc
                 matrix(j) = rhs;
               }
             else
               matrix.assign (idx_vec, mrhs);
           }
           break;
         }
     }
-  catch (const index_exception& e)
+  catch (const octave::index_exception& e)
     {
-      err_invalid_index (e.idx (), n_idx, k+1);
+      octave::err_invalid_index (e.idx (), n_idx, k+1);
     }
 
   // Clear cache.
   clear_cached_info ();
 }
 
 template <typename MT>
 void
@@ -411,17 +411,17 @@ octave_base_matrix<MT>::is_true (void) c
   dim_vector dv = matrix.dims ();
   int nel = dv.numel ();
 
   if (nel > 0)
     {
       MT t1 (matrix.reshape (dim_vector (nel, 1)));
 
       if (t1.any_element_is_nan ())
-        err_nan_to_logical_conversion ();
+        octave::err_nan_to_logical_conversion ();
 
       if (nel > 1)
         warn_array_as_logical (dv);
 
       boolNDArray t2 = t1.all ();
 
       retval = t2(0);
     }
diff --git a/libinterp/octave-value/ov-base-scalar.cc b/libinterp/octave-value/ov-base-scalar.cc
--- a/libinterp/octave-value/ov-base-scalar.cc
+++ b/libinterp/octave-value/ov-base-scalar.cc
@@ -137,17 +137,17 @@ octave_base_scalar<ST>::diag (octave_idx
   return Array<ST> (dim_vector (1, 1), scalar).diag (m, n);
 }
 
 template <typename ST>
 bool
 octave_base_scalar<ST>::is_true (void) const
 {
   if (octave::math::isnan (scalar))
-    err_nan_to_logical_conversion ();
+    octave::err_nan_to_logical_conversion ();
 
   return (scalar != ST ());
 }
 
 template <typename ST>
 void
 octave_base_scalar<ST>::print (std::ostream& os, bool pr_as_read_syntax)
 {
diff --git a/libinterp/octave-value/ov-base-sparse.cc b/libinterp/octave-value/ov-base-sparse.cc
--- a/libinterp/octave-value/ov-base-sparse.cc
+++ b/libinterp/octave-value/ov-base-sparse.cc
@@ -88,17 +88,17 @@ octave_base_sparse<T>::do_index_op (cons
             retval = octave_value (matrix.index (i, j, resize_ok));
           }
           break;
 
         default:
           error ("sparse indexing needs 1 or 2 indices");
         }
     }
-  catch (index_exception& e)
+  catch (octave::index_exception& e)
     {
       // Rethrow to allow more info to be reported later.
       e.set_pos_if_unset (n_idx, k+1);
       throw;
     }
 
   return retval;
 }
@@ -213,17 +213,17 @@ octave_base_sparse<T>::assign (const oct
 
             break;
           }
 
         default:
           error ("sparse indexing needs 1 or 2 indices");
         }
     }
-  catch (index_exception& e)
+  catch (octave::index_exception& e)
     {
       // Rethrow to allow more info to be reported later.
       e.set_pos_if_unset (len, k+1);
       throw;
     }
 
   // Invalidate matrix type.
   typ.invalidate_type ();
@@ -265,17 +265,17 @@ octave_base_sparse<MT>::delete_elements 
 
             break;
           }
 
         default:
           error ("sparse indexing needs 1 or 2 indices");
         }
     }
-  catch (index_exception& e)
+  catch (octave::index_exception& e)
     {
       // Rethrow to allow more info to be reported later.
       e.set_pos_if_unset (len, k+1);
       throw;
     }
 
   // Invalidate the matrix type
   typ.invalidate_type ();
@@ -299,17 +299,17 @@ octave_base_sparse<T>::is_true (void) co
   octave_idx_type nel = dv.numel ();
   octave_idx_type nz = nnz ();
 
   if (nel > 0)
     {
       T t1 (matrix.reshape (dim_vector (nel, 1)));
 
       if (t1.any_element_is_nan ())
-        err_nan_to_logical_conversion ();
+        octave::err_nan_to_logical_conversion ();
 
       if (nel > 1)
         warn_array_as_logical (dv);
 
       if (nz == nel)
         {
           SparseBoolMatrix t2 = t1.all ();
 
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -269,17 +269,17 @@ octave_base_value::do_multi_index_op (in
   // Fall back.
   return do_multi_index_op (nargout, idx);
 }
 
 idx_vector
 octave_base_value::index_vector (bool /* require_integers */) const
 {
   std::string nm = "<" + type_name () + ">";
-  err_invalid_index (nm.c_str ());
+  octave::err_invalid_index (nm.c_str ());
 }
 
 octave_value
 octave_base_value::subsasgn (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              const octave_value& rhs)
 {
   octave_value retval;
@@ -502,17 +502,17 @@ octave_base_value::print_info (std::ostr
     T retval = 0;                                                       \
                                                                         \
     double d = 0.0;                                                     \
                                                                         \
     try                                                                 \
       {                                                                 \
         d = double_value (frc_str_conv);                                \
       }                                                                 \
-    catch (octave_execution_exception& e)                               \
+    catch (octave::execution_exception& e)                               \
       {                                                                 \
         err_wrong_type_arg (e, "octave_base_value::" #F "_value ()", type_name ()); \
       }                                                                 \
                                                                         \
     if (require_int && octave::math::x_nint (d) != d)                   \
       error_with_cfn ("conversion of %g to " #T " value failed", d);    \
     else if (d < std::numeric_limits<T>::min ())                        \
       retval = std::numeric_limits<T>::min ();                          \
@@ -540,17 +540,17 @@ int
 octave_base_value::nint_value (bool frc_str_conv) const
 {
   double d = 0.0;
 
   try
     {
       d = double_value (frc_str_conv);
     }
-  catch (octave_execution_exception& e)
+  catch (octave::execution_exception& e)
     {
       err_wrong_type_arg (e, "octave_base_value::nint_value ()", type_name ());
     }
 
   if (octave::math::isnan (d))
     error ("conversion of NaN to integer value failed");
 
   return static_cast<int> (octave::math::fix (d));
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -1087,17 +1087,17 @@ octave_class::reconstruct_exemplar (void
           bool execution_error = false;
 
           octave_value_list result;
 
           try
             {
               result = ctor.do_multi_index_op (1, octave_value_list ());
             }
-          catch (const octave_execution_exception&)
+          catch (const octave::execution_exception&)
             {
               recover_from_exception ();
 
               execution_error = true;
             }
 
           if (! execution_error && result.length () == 1)
             retval = true;
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -1516,17 +1516,17 @@ cdef_object_array::subsref (const std::s
         Array<idx_vector> iv (dim_vector (1, ival.length ()));
 
         for (int i = 0; i < ival.length (); i++)
           {
             try
               {
                 iv(i) = ival(i).index_vector ();
               }
-            catch (index_exception& e)
+            catch (octave::index_exception& e)
               {
                 // Rethrow to allow more info to be reported later.
                 e.set_pos_if_unset (ival.length (), i+1);
                 throw;
               }
 
             is_scalar = is_scalar && iv(i).is_scalar ();
           }
@@ -1612,17 +1612,17 @@ cdef_object_array::subsasgn (const std::
           Array<idx_vector> iv (dim_vector (1, ival.length ()));
 
           for (int i = 0; i < ival.length (); i++)
             {
               try
                 {
                   iv(i) = ival(i).index_vector ();
                 }
-              catch (index_exception& e)
+              catch (octave::index_exception& e)
                 {
                   e.set_pos_if_unset (ival.length (), i+1);
                   throw;   // var name set in pt-idx.cc / pt-assign.cc
                 }
 
               is_scalar = is_scalar && iv(i).is_scalar ();
             }
 
@@ -1656,17 +1656,17 @@ cdef_object_array::subsasgn (const std::
             static_cast<octave_idx_type> (2))));
 
           for (int i = 0; i < ival.length (); i++)
             {
               try
                 {
                   iv(i) = ival(i).index_vector ();
                 }
-              catch (index_exception& e)
+              catch (octave::index_exception& e)
                 {
                   // Rethrow to allow more info to be reported later.
                   e.set_pos_if_unset (ival.length (), i+1);
                   throw;
                 }
 
               is_scalar = is_scalar && iv(i).is_scalar ();
 
diff --git a/libinterp/octave-value/ov-complex.cc b/libinterp/octave-value/ov-complex.cc
--- a/libinterp/octave-value/ov-complex.cc
+++ b/libinterp/octave-value/ov-complex.cc
@@ -56,38 +56,41 @@ along with Octave; see the file COPYING.
 extern template class OCTINTERP_API octave_base_scalar<double>;
 extern template class OCTINTERP_API octave_base_scalar<FloatComplex>;
 
 template class octave_base_scalar<Complex>;
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_complex,
                                      "complex scalar", "double");
 
-// Complain if a complex value is used as a subscript.
-
-class complex_index_exception : public index_exception
+namespace octave
 {
-public:
+  // Complain if a complex value is used as a subscript.
 
-  complex_index_exception (const std::string& value)
-    : index_exception (value) { }
+  class complex_index_exception : public index_exception
+  {
+  public:
 
-  ~complex_index_exception (void) { }
+    complex_index_exception (const std::string& value)
+      : index_exception (value) { }
+
+    ~complex_index_exception (void) { }
 
-  std::string details (void) const
-  {
-    return "subscripts must be real (forgot to initialize i or j?)";
-  }
+    std::string details (void) const
+    {
+      return "subscripts must be real (forgot to initialize i or j?)";
+    }
 
-  // ID of error to throw.
-  const char *err_id (void) const
-  {
-    return "Octave:invalid-index";
-  }
-};
+    // ID of error to throw.
+    const char *err_id (void) const
+    {
+      return "Octave:invalid-index";
+    }
+  };
+}
 
 static octave_base_value *
 default_numeric_demotion_function (const octave_base_value& a)
 {
   const octave_complex& v = dynamic_cast<const octave_complex&> (a);
 
   return new octave_float_complex (v.float_complex_value ());
 }
@@ -132,17 +135,17 @@ octave_complex::do_index_op (const octav
 }
 
 // Can't make an index_vector from a complex number.  Throw an error.
 idx_vector
 octave_complex::index_vector (bool) const
 {
   std::ostringstream buf;
   buf << scalar.real () << std::showpos << scalar.imag () << "i";
-  complex_index_exception e (buf.str ());
+  octave::complex_index_exception e (buf.str ());
 
   throw e;
 }
 
 double
 octave_complex::double_value (bool force_conversion) const
 {
   double retval;
diff --git a/libinterp/octave-value/ov-complex.h b/libinterp/octave-value/ov-complex.h
--- a/libinterp/octave-value/ov-complex.h
+++ b/libinterp/octave-value/ov-complex.h
@@ -136,27 +136,27 @@ public:
 
   ComplexNDArray complex_array_value (bool = false) const;
 
   FloatComplexNDArray float_complex_array_value (bool = false) const;
 
   bool bool_value (bool warn = false) const
   {
     if (octave::math::isnan (scalar))
-      err_nan_to_logical_conversion ();
+      octave::err_nan_to_logical_conversion ();
     if (warn && scalar != 0.0 && scalar != 1.0)
       warn_logical_conversion ();
 
     return scalar != 0.0;
   }
 
   boolNDArray bool_array_value (bool warn = false) const
   {
     if (octave::math::isnan (scalar))
-      err_nan_to_logical_conversion ();
+      octave::err_nan_to_logical_conversion ();
     if (warn && scalar != 0.0 && scalar != 1.0)
       warn_logical_conversion ();
 
     return boolNDArray (dim_vector (1, 1), scalar != 0.0);
   }
 
   octave_value as_double (void) const;
   octave_value as_single (void) const;
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -231,17 +231,17 @@ octave_complex_matrix::float_complex_mat
 {
   return FloatComplexMatrix (ComplexMatrix (matrix));
 }
 
 boolNDArray
 octave_complex_matrix::bool_array_value (bool warn) const
 {
   if (matrix.any_element_is_nan ())
-    err_nan_to_logical_conversion ();
+    octave::err_nan_to_logical_conversion ();
   if (warn && (! matrix.all_elements_are_real ()
                || real (matrix).any_element_not_one_or_zero ()))
     warn_logical_conversion ();
 
   return mx_el_ne (matrix, Complex (0.0));
 }
 
 charNDArray
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -208,17 +208,17 @@ octave_sparse_complex_matrix::sparse_mat
 
   return retval;
 }
 
 SparseBoolMatrix
 octave_sparse_complex_matrix::sparse_bool_matrix_value (bool warn) const
 {
   if (matrix.any_element_is_nan ())
-    err_nan_to_logical_conversion ();
+    octave::err_nan_to_logical_conversion ();
   if (warn && (! matrix.all_elements_are_real ()
                || real (matrix).any_element_not_one_or_zero ()))
     warn_logical_conversion ();
 
   return mx_el_ne (matrix, Complex (0.0));
 }
 
 octave_value
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -2042,17 +2042,17 @@ octave_fcn_binder::maybe_binder (const o
                               // Simulate try/catch.
                               octave::unwind_protect frame;
                               interpreter_try (frame);
 
                               try
                                 {
                                   root_val = make_fcn_handle (head_name);
                                 }
-                              catch (const octave_execution_exception&)
+                              catch (const octave::execution_exception&)
                                 {
                                   recover_from_exception ();
 
                                   bad = true;
                                 }
                             }
                         }
                     }
diff --git a/libinterp/octave-value/ov-float.cc b/libinterp/octave-value/ov-float.cc
--- a/libinterp/octave-value/ov-float.cc
+++ b/libinterp/octave-value/ov-float.cc
@@ -168,17 +168,17 @@ octave_float_scalar::diag (octave_idx_ty
 }
 
 octave_value
 octave_float_scalar::convert_to_str_internal (bool, bool, char type) const
 {
   octave_value retval;
 
   if (octave::math::isnan (scalar))
-    err_nan_to_character_conversion ();
+    octave::err_nan_to_character_conversion ();
 
   int ival = octave::math::nint (scalar);
 
   if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
     {
       // FIXME: is there something better we could do?
 
       ival = 0;
diff --git a/libinterp/octave-value/ov-float.h b/libinterp/octave-value/ov-float.h
--- a/libinterp/octave-value/ov-float.h
+++ b/libinterp/octave-value/ov-float.h
@@ -196,27 +196,27 @@ public:
     charNDArray retval (dim_vector (1, 1));
     retval(0) = static_cast<char> (scalar);
     return retval;
   }
 
   bool bool_value (bool warn = false) const
   {
     if (octave::math::isnan (scalar))
-      err_nan_to_logical_conversion ();
+      octave::err_nan_to_logical_conversion ();
     if (warn && scalar != 0 && scalar != 1)
       warn_logical_conversion ();
 
     return scalar;
   }
 
   boolNDArray bool_array_value (bool warn = false) const
   {
     if (octave::math::isnan (scalar))
-      err_nan_to_logical_conversion ();
+      octave::err_nan_to_logical_conversion ();
     if (warn && scalar != 0 && scalar != 1)
       warn_logical_conversion ();
 
     return boolNDArray (dim_vector (1, 1), scalar);
   }
 
   octave_value as_double (void) const;
   octave_value as_single (void) const;
diff --git a/libinterp/octave-value/ov-flt-complex.h b/libinterp/octave-value/ov-flt-complex.h
--- a/libinterp/octave-value/ov-flt-complex.h
+++ b/libinterp/octave-value/ov-flt-complex.h
@@ -132,27 +132,27 @@ public:
 
   ComplexNDArray complex_array_value (bool = false) const;
 
   FloatComplexNDArray float_complex_array_value (bool = false) const;
 
   bool bool_value (bool warn = false) const
   {
     if (octave::math::isnan (scalar))
-      err_nan_to_logical_conversion ();
+      octave::err_nan_to_logical_conversion ();
     if (warn && scalar != 0.0f && scalar != 1.0f)
       warn_logical_conversion ();
 
     return scalar != 0.0f;
   }
 
   boolNDArray bool_array_value (bool warn = false) const
   {
     if (octave::math::isnan (scalar))
-      err_nan_to_logical_conversion ();
+      octave::err_nan_to_logical_conversion ();
     if (warn && scalar != 0.0f && scalar != 1.0f)
       warn_logical_conversion ();
 
     return boolNDArray (dim_vector (1, 1), scalar != 1.0f);
   }
 
   octave_value as_double (void) const;
   octave_value as_single (void) const;
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -205,17 +205,17 @@ octave_float_complex_matrix::float_compl
 {
   return FloatComplexMatrix (matrix);
 }
 
 boolNDArray
 octave_float_complex_matrix::bool_array_value (bool warn) const
 {
   if (matrix.any_element_is_nan ())
-    err_nan_to_logical_conversion ();
+    octave::err_nan_to_logical_conversion ();
   if (warn && (! matrix.all_elements_are_real ()
                || real (matrix).any_element_not_one_or_zero ()))
     warn_logical_conversion ();
 
   return mx_el_ne (matrix, FloatComplex (0.0));
 }
 
 charNDArray
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -209,17 +209,17 @@ octave_float_matrix::array_value (bool) 
 {
   return NDArray (matrix);
 }
 
 boolNDArray
 octave_float_matrix::bool_array_value (bool warn) const
 {
   if (matrix.any_element_is_nan ())
-    err_nan_to_logical_conversion ();
+    octave::err_nan_to_logical_conversion ();
   if (warn && matrix.any_element_not_one_or_zero ())
     warn_logical_conversion ();
 
   return boolNDArray (matrix);
 }
 
 charNDArray
 octave_float_matrix::char_array_value (bool) const
@@ -347,17 +347,17 @@ octave_float_matrix::convert_to_str_inte
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       octave_quit ();
 
       float d = matrix(i);
 
       if (octave::math::isnan (d))
-        err_nan_to_character_conversion ();
+        octave::err_nan_to_character_conversion ();
 
       int ival = octave::math::nint (d);
 
       if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
         {
           // FIXME: is there something better we could do?
 
           ival = 0;
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -941,17 +941,17 @@ make_java_index (JNIEnv *jni_env, const 
           buf[k] = v(k);
 
         // set retval[i]=i_array
         jni_env->ReleaseIntArrayElements (i_array, buf, 0);
         jni_env->SetObjectArrayElement (retval, i, i_array);
 
         check_exception (jni_env);
       }
-    catch (index_exception& e)
+    catch (octave::index_exception& e)
       {
         // Rethrow to allow more info to be reported later.
         e.set_pos_if_unset (idx.length (), i+1);
         throw;
       }
 
   return retval;
 }
diff --git a/libinterp/octave-value/ov-oncleanup.cc b/libinterp/octave-value/ov-oncleanup.cc
--- a/libinterp/octave-value/ov-oncleanup.cc
+++ b/libinterp/octave-value/ov-oncleanup.cc
@@ -78,23 +78,23 @@ octave_oncleanup::~octave_oncleanup (voi
 
   interpreter_try (frame);
 
   try
     {
       // Run the actual code.
       fcn.do_multi_index_op (0, octave_value_list ());
     }
-  catch (const octave_interrupt_exception&)
+  catch (const octave::interrupt_exception&)
     {
       recover_from_exception ();
 
       warning ("onCleanup: interrupt occurred in cleanup action");
     }
-  catch (const octave_execution_exception&)
+  catch (const octave::execution_exception&)
     {
       std::string msg = last_error_message ();
       warning ("onCleanup: error caught while executing cleanup function:\n%s\n",
                msg.c_str ());
 
     }
   catch (...) // Yes, the black hole.  We're in a d-tor.
     {
diff --git a/libinterp/octave-value/ov-perm.cc b/libinterp/octave-value/ov-perm.cc
--- a/libinterp/octave-value/ov-perm.cc
+++ b/libinterp/octave-value/ov-perm.cc
@@ -76,17 +76,17 @@ octave_perm_matrix::do_index_op (const o
     {
       int k = 0;    // index we're processing when index_vector throws
       try
         {
           idx0 = idx(0).index_vector ();
           k = 1;
           idx1 = idx(1).index_vector ();
         }
-      catch (index_exception& e)
+      catch (octave::index_exception& e)
         {
           // Rethrow to allow more info to be reported later.
           e.set_pos_if_unset (2, k+1);
           throw;
         }
     }
 
   // This hack is to allow constructing permutation matrices using
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -143,17 +143,17 @@ octave_range::do_index_op (const octave_
         {
           idx_vector i = idx(0).index_vector ();
 
           if (i.is_scalar () && i(0) < range.numel ())
             retval = range.elem (i(0));
           else
             retval = range.index (i);
         }
-      catch (index_exception& e)
+      catch (octave::index_exception& e)
         {
           // More info may be added later before displaying error.
 
           e.set_pos_if_unset (1, 1);
           throw;
         }
 
       return retval;
@@ -353,17 +353,17 @@ octave_range::float_complex_value (bool)
 }
 
 boolNDArray
 octave_range::bool_array_value (bool warn) const
 {
   Matrix m = range.matrix_value ();
 
   if (m.any_element_is_nan ())
-    err_nan_to_logical_conversion ();
+    octave::err_nan_to_logical_conversion ();
   if (warn && m.any_element_not_one_or_zero ())
     warn_logical_conversion ();
 
   return boolNDArray (m);
 }
 
 octave_value
 octave_range::resize (const dim_vector& dv, bool fill) const
diff --git a/libinterp/octave-value/ov-re-diag.cc b/libinterp/octave-value/ov-re-diag.cc
--- a/libinterp/octave-value/ov-re-diag.cc
+++ b/libinterp/octave-value/ov-re-diag.cc
@@ -114,17 +114,17 @@ octave_diag_matrix::do_index_op (const o
                 retval = PermMatrix (idx1, true);
               else
                 {
                   retval = this;
                   this->count++;
                 }
             }
         }
-      catch (index_exception& e)
+      catch (octave::index_exception& e)
         {
           // Rethrow to allow more info to be reported later.
           e.set_pos_if_unset (2, k+1);
           throw;
         }
     }
 
   if (retval.is_undefined ())
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -218,17 +218,17 @@ octave_matrix::float_complex_array_value
 {
   return FloatComplexNDArray (matrix);
 }
 
 boolNDArray
 octave_matrix::bool_array_value (bool warn) const
 {
   if (matrix.any_element_is_nan ())
-    err_nan_to_logical_conversion ();
+    octave::err_nan_to_logical_conversion ();
   if (warn && matrix.any_element_not_one_or_zero ())
     warn_logical_conversion ();
 
   return boolNDArray (matrix);
 }
 
 charNDArray
 octave_matrix::char_array_value (bool) const
@@ -449,17 +449,17 @@ octave_matrix::convert_to_str_internal (
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       octave_quit ();
 
       double d = matrix(i);
 
       if (octave::math::isnan (d))
-        err_nan_to_character_conversion ();
+        octave::err_nan_to_character_conversion ();
 
       int ival = octave::math::nint (d);
 
       if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
         {
           // FIXME: is there something better we could do?
 
           ival = 0;
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -57,17 +57,17 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
 idx_vector
 octave_sparse_matrix::index_vector (bool /* require_integers */) const
 {
   if (matrix.numel () == matrix.nnz ())
     return idx_vector (array_value ());
   else
     {
       std::string nm = "<" + type_name () + ">";
-      err_invalid_index (nm.c_str ());
+      octave::err_invalid_index (nm.c_str ());
     }
 }
 
 octave_base_value *
 octave_sparse_matrix::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
@@ -136,17 +136,17 @@ octave_sparse_matrix::matrix_value (bool
 }
 
 boolNDArray
 octave_sparse_matrix::bool_array_value (bool warn) const
 {
   NDArray m = matrix.matrix_value ();
 
   if (m.any_element_is_nan ())
-    err_nan_to_logical_conversion ();
+    octave::err_nan_to_logical_conversion ();
   if (warn && m.any_element_not_one_or_zero ())
     warn_logical_conversion ();
 
   return boolNDArray (m);
 }
 
 charNDArray
 octave_sparse_matrix::char_array_value (bool) const
@@ -179,17 +179,17 @@ octave_sparse_matrix::array_value (bool)
 {
   return NDArray (matrix.matrix_value ());
 }
 
 SparseBoolMatrix
 octave_sparse_matrix::sparse_bool_matrix_value (bool warn) const
 {
   if (matrix.any_element_is_nan ())
-    err_nan_to_logical_conversion ();
+    octave::err_nan_to_logical_conversion ();
   if (warn && matrix.any_element_not_one_or_zero ())
     warn_logical_conversion ();
 
   return mx_el_ne (matrix, 0.0);
 }
 
 octave_value
 octave_sparse_matrix::convert_to_str_internal (bool, bool, char type) const
@@ -215,17 +215,17 @@ octave_sparse_matrix::convert_to_str_int
         for (octave_idx_type i = matrix.cidx (j);
              i < matrix.cidx (j+1); i++)
           {
             octave_quit ();
 
             double d = matrix.data (i);
 
             if (octave::math::isnan (d))
-              err_nan_to_character_conversion ();
+              octave::err_nan_to_character_conversion ();
 
             int ival = octave::math::nint (d);
 
             if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
               {
                 // FIXME: is there something better we could do?
 
                 ival = 0;
diff --git a/libinterp/octave-value/ov-scalar.cc b/libinterp/octave-value/ov-scalar.cc
--- a/libinterp/octave-value/ov-scalar.cc
+++ b/libinterp/octave-value/ov-scalar.cc
@@ -187,17 +187,17 @@ octave_scalar::diag (octave_idx_type m, 
 }
 
 octave_value
 octave_scalar::convert_to_str_internal (bool, bool, char type) const
 {
   octave_value retval;
 
   if (octave::math::isnan (scalar))
-    err_nan_to_character_conversion ();
+    octave::err_nan_to_character_conversion ();
 
   int ival = octave::math::nint (scalar);
 
   if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
     {
       // FIXME: is there something better we could do?
 
       ival = 0;
diff --git a/libinterp/octave-value/ov-scalar.h b/libinterp/octave-value/ov-scalar.h
--- a/libinterp/octave-value/ov-scalar.h
+++ b/libinterp/octave-value/ov-scalar.h
@@ -195,27 +195,27 @@ public:
     charNDArray retval (dim_vector (1, 1));
     retval(0) = static_cast<char> (scalar);
     return retval;
   }
 
   bool bool_value (bool warn = false) const
   {
     if (octave::math::isnan (scalar))
-      err_nan_to_logical_conversion ();
+      octave::err_nan_to_logical_conversion ();
     if (warn && scalar != 0 && scalar != 1)
       warn_logical_conversion ();
 
     return scalar;
   }
 
   boolNDArray bool_array_value (bool warn = false) const
   {
     if (octave::math::isnan (scalar))
-      err_nan_to_logical_conversion ();
+      octave::err_nan_to_logical_conversion ();
     if (warn && scalar != 0 && scalar != 1)
       warn_logical_conversion ();
 
     return boolNDArray (dim_vector (1, 1), scalar);
   }
 
   octave_value as_double (void) const;
   octave_value as_single (void) const;
diff --git a/libinterp/octave-value/ov-str-mat.cc b/libinterp/octave-value/ov-str-mat.cc
--- a/libinterp/octave-value/ov-str-mat.cc
+++ b/libinterp/octave-value/ov-str-mat.cc
@@ -134,17 +134,17 @@ octave_char_matrix_str::do_index_op_inte
 
             retval =
               octave_value (charNDArray (matrix.index (idx_vec, resize_ok)),
                             type);
           }
           break;
         }
     }
-  catch (index_exception& e)
+  catch (octave::index_exception& e)
     {
       // Rethrow to allow more info to be reported later.
       e.set_pos_if_unset (len, k+1);
       throw;
     }
 
   return retval;
 }
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -2037,17 +2037,17 @@ octave_value::float_complex_vector_value
   octave_value::NAME (const char *fmt, ...) const       \
   {                                                     \
     TYPE retval;                                        \
                                                         \
     try                                                 \
       {                                                 \
         retval = FCN ();                                \
       }                                                 \
-    catch (octave_execution_exception& e)               \
+    catch (octave::execution_exception& e)               \
       {                                                 \
         if (fmt)                                        \
           {                                             \
             va_list args;                               \
             va_start (args, fmt);                       \
             verror (e, fmt, args);                      \
             va_end (args);                              \
           }                                             \
@@ -2583,37 +2583,37 @@ do_colon_op (const octave_value& base, c
       bool dq_str = (base.is_dq_string () || limit.is_dq_string ());
 
       Matrix m_base, m_limit, m_increment;
 
       try
         {
           m_base = base.matrix_value (true);
         }
-      catch (octave_execution_exception& e)
+      catch (octave::execution_exception& e)
         {
           error (e, "invalid base value in colon expression");
         }
 
       try
         {
           m_limit = limit.matrix_value (true);
         }
-      catch (octave_execution_exception& e)
+      catch (octave::execution_exception& e)
         {
           error (e, "invalid limit value in colon expression");
         }
 
       try
         {
           m_increment = (increment.is_defined ()
                          ? increment.matrix_value (true)
                          : Matrix (1, 1, 1.0));
         }
-      catch (octave_execution_exception& e)
+      catch (octave::execution_exception& e)
         {
           error (e, "invalid increment value in colon expression");
         }
 
       bool base_empty = m_base.is_empty ();
       bool limit_empty = m_limit.is_empty ();
       bool increment_empty = m_increment.is_empty ();
 
diff --git a/libinterp/operators/op-cs-cs.cc b/libinterp/operators/op-cs-cs.cc
--- a/libinterp/operators/op-cs-cs.cc
+++ b/libinterp/operators/op-cs-cs.cc
@@ -40,17 +40,17 @@ along with Octave; see the file COPYING.
 
 // unary complex scalar ops.
 
 DEFUNOP (not, complex)
 {
   const octave_complex& v = dynamic_cast<const octave_complex&> (a);
   Complex x = v.complex_value ();
   if (octave::math::isnan (x))
-    err_nan_to_logical_conversion ();
+    octave::err_nan_to_logical_conversion ();
 
   return octave_value (x == 0.0);
 }
 
 DEFUNOP_OP (uplus, complex, /* no-op */)
 DEFUNOP_OP (uminus, complex, -)
 DEFUNOP_OP (transpose, complex, /* no-op */)
 
diff --git a/libinterp/operators/op-fcs-fcs.cc b/libinterp/operators/op-fcs-fcs.cc
--- a/libinterp/operators/op-fcs-fcs.cc
+++ b/libinterp/operators/op-fcs-fcs.cc
@@ -38,17 +38,17 @@ along with Octave; see the file COPYING.
 
 // unary complex scalar ops.
 
 DEFUNOP (not, float_complex)
 {
   const octave_float_complex& v = dynamic_cast<const octave_float_complex&> (a);
   FloatComplex x = v.float_complex_value ();
   if (octave::math::isnan (x))
-    err_nan_to_logical_conversion ();
+    octave::err_nan_to_logical_conversion ();
 
   return octave_value (x == 0.0f);
 }
 
 DEFUNOP_OP (uplus, float_complex, /* no-op */)
 DEFUNOP_OP (uminus, float_complex, -)
 DEFUNOP_OP (transpose, float_complex, /* no-op */)
 
diff --git a/libinterp/operators/op-fs-fs.cc b/libinterp/operators/op-fs-fs.cc
--- a/libinterp/operators/op-fs-fs.cc
+++ b/libinterp/operators/op-fs-fs.cc
@@ -40,17 +40,17 @@ along with Octave; see the file COPYING.
 
 // scalar unary ops.
 
 DEFUNOP (not, float_scalar)
 {
   const octave_float_scalar& v = dynamic_cast<const octave_float_scalar&> (a);
   float x = v.float_value ();
   if (octave::math::isnan (x))
-    err_nan_to_logical_conversion ();
+    octave::err_nan_to_logical_conversion ();
 
   return octave_value (x == 0.0f);
 }
 
 DEFUNOP_OP (uplus, float_scalar, /* no-op */)
 DEFUNOP_OP (uminus, float_scalar, -)
 DEFUNOP_OP (transpose, float_scalar, /* no-op */)
 DEFUNOP_OP (hermitian, float_scalar, /* no-op */)
diff --git a/libinterp/operators/op-int.h b/libinterp/operators/op-int.h
--- a/libinterp/operators/op-int.h
+++ b/libinterp/operators/op-int.h
@@ -726,17 +726,17 @@ along with Octave; see the file COPYING.
   octave_value                                                  \
   elem_xpow (const T1 ## NDArray& a, const T2 ## NDArray& b)    \
   {                                                             \
     dim_vector a_dims = a.dims ();                              \
     dim_vector b_dims = b.dims ();                              \
     if (a_dims != b_dims)                                       \
       {                                                         \
         if (! is_valid_bsxfun ("operator .^", a_dims, b_dims))  \
-          err_nonconformant ("operator .^", a_dims, b_dims);    \
+          octave::err_nonconformant ("operator .^", a_dims, b_dims);    \
                                                                 \
         return bsxfun_pow (a, b);                               \
       }                                                         \
     T1 ## NDArray result (a_dims);                              \
     for (int i = 0; i < a.numel (); i++)                        \
       {                                                         \
         OCTAVE_QUIT;                                            \
         result (i) = pow (a(i), b(i));                          \
@@ -747,17 +747,17 @@ along with Octave; see the file COPYING.
   octave_value                                                  \
   elem_xpow (const T1 ## NDArray& a, const NDArray& b)          \
   {                                                             \
     dim_vector a_dims = a.dims ();                              \
     dim_vector b_dims = b.dims ();                              \
     if (a_dims != b_dims)                                       \
       {                                                         \
         if (! is_valid_bsxfun ("operator .^", a_dims, b_dims))  \
-          err_nonconformant ("operator .^", a_dims, b_dims);    \
+          octave::err_nonconformant ("operator .^", a_dims, b_dims);    \
                                                                 \
         return bsxfun_pow (a, b);                               \
       }                                                         \
     T1 ## NDArray result (a_dims);                              \
     for (int i = 0; i < a.numel (); i++)                        \
       {                                                         \
         OCTAVE_QUIT;                                            \
         result (i) = pow (a(i), b(i));                          \
@@ -768,17 +768,17 @@ along with Octave; see the file COPYING.
   octave_value                                                  \
   elem_xpow (const NDArray& a, const T2 ## NDArray& b)          \
   {                                                             \
     dim_vector a_dims = a.dims ();                              \
     dim_vector b_dims = b.dims ();                              \
     if (a_dims != b_dims)                                       \
       {                                                         \
         if (! is_valid_bsxfun ("operator .^", a_dims, b_dims))  \
-          err_nonconformant ("operator .^", a_dims, b_dims);    \
+          octave::err_nonconformant ("operator .^", a_dims, b_dims);    \
                                                                 \
         return bsxfun_pow (a, b);                               \
       }                                                         \
     T2 ## NDArray result (a_dims);                              \
     for (int i = 0; i < a.numel (); i++)                        \
       {                                                         \
         OCTAVE_QUIT;                                            \
         result (i) = pow (a(i), b(i));                          \
@@ -789,17 +789,17 @@ along with Octave; see the file COPYING.
   octave_value                                                  \
   elem_xpow (const T1 ## NDArray& a, const FloatNDArray& b)     \
   {                                                             \
     dim_vector a_dims = a.dims ();                              \
     dim_vector b_dims = b.dims ();                              \
     if (a_dims != b_dims)                                       \
       {                                                         \
         if (! is_valid_bsxfun ("operator .^", a_dims, b_dims))  \
-          err_nonconformant ("operator .^", a_dims, b_dims);    \
+          octave::err_nonconformant ("operator .^", a_dims, b_dims);    \
                                                                 \
         return bsxfun_pow (a, b);                               \
       }                                                         \
     T1 ## NDArray result (a_dims);                              \
     for (int i = 0; i < a.numel (); i++)                        \
       {                                                         \
         OCTAVE_QUIT;                                            \
         result (i) = powf (a(i), b(i));                         \
@@ -810,17 +810,17 @@ along with Octave; see the file COPYING.
   octave_value                                                  \
   elem_xpow (const FloatNDArray& a, const T2 ## NDArray& b)     \
   {                                                             \
     dim_vector a_dims = a.dims ();                              \
     dim_vector b_dims = b.dims ();                              \
     if (a_dims != b_dims)                                       \
       {                                                         \
         if (! is_valid_bsxfun ("operator .^", a_dims, b_dims))  \
-          err_nonconformant ("operator .^", a_dims, b_dims);    \
+          octave::err_nonconformant ("operator .^", a_dims, b_dims);    \
                                                                 \
         return bsxfun_pow (a, b);                               \
       }                                                         \
     T2 ## NDArray result (a_dims);                              \
     for (int i = 0; i < a.numel (); i++)                        \
       {                                                         \
         OCTAVE_QUIT;                                            \
         result (i) = powf (a(i), b(i));                         \
diff --git a/libinterp/operators/op-s-s.cc b/libinterp/operators/op-s-s.cc
--- a/libinterp/operators/op-s-s.cc
+++ b/libinterp/operators/op-s-s.cc
@@ -41,17 +41,17 @@ along with Octave; see the file COPYING.
 
 // scalar unary ops.
 
 DEFUNOP (not, scalar)
 {
   const octave_scalar& v = dynamic_cast<const octave_scalar&> (a);
   double x = v.scalar_value ();
   if (octave::math::isnan (x))
-    err_nan_to_logical_conversion ();
+    octave::err_nan_to_logical_conversion ();
 
   return octave_value (x == 0.0);
 }
 
 DEFUNOP_OP (uplus, scalar, /* no-op */)
 DEFUNOP_OP (uminus, scalar, -)
 DEFUNOP_OP (transpose, scalar, /* no-op */)
 DEFUNOP_OP (hermitian, scalar, /* no-op */)
diff --git a/libinterp/operators/ops.h b/libinterp/operators/ops.h
--- a/libinterp/operators/ops.h
+++ b/libinterp/operators/ops.h
@@ -255,17 +255,17 @@ extern void install_ops (void);
   static octave_value                                                   \
   CONCAT2 (oct_binop_, name) (const octave_base_value& a1,              \
                               const octave_base_value& a2)              \
   {                                                                     \
     const CONCAT2 (octave_, t1)& v1 = dynamic_cast<const CONCAT2 (octave_, t1)&> (a1); \
     const CONCAT2 (octave_, t2)& v2 = dynamic_cast<const CONCAT2 (octave_, t2)&> (a2); \
                                                                         \
     if (octave::math::isnan (v1.CONCAT2 (t1, _value) ()) || octave::math::isnan (v2.CONCAT2 (t2, _value) ())) \
-      err_nan_to_logical_conversion ();                                 \
+      octave::err_nan_to_logical_conversion ();                                 \
                                                                         \
     return octave_value                                                 \
       (v1.CONCAT2 (t1, _value) () op v2.CONCAT2 (t2, _value) ());       \
   }
 
 #define DEFNDBINOP_OP(name, t1, t2, e1, e2, op)                         \
   static octave_value                                                   \
   CONCAT2 (oct_binop_, name) (const octave_base_value& a1,              \
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -2243,17 +2243,17 @@ namespace octave
                     e->accept (tpc);
 
                     tc_retval->stash_original_text (buf.str ());
 
                     delete e;
 
                     retval = tc_retval;
                   }
-                catch (const octave_execution_exception&)
+                catch (const octave::execution_exception&)
                   {
                     recover_from_exception ();
                   }
               }
           }
         else
           {
             e->preserve_base ();
@@ -3860,17 +3860,17 @@ namespace octave
             array_list->accept (tpc);
 
             tc_retval->stash_original_text (buf.str ());
 
             delete array_list;
 
             retval = tc_retval;
           }
-        catch (const octave_execution_exception&)
+        catch (const octave::execution_exception&)
           {
             recover_from_exception ();
           }
       }
 
     return retval;
   }
 
@@ -4027,26 +4027,26 @@ namespace octave
     int status = -1;
 
     yypstate *pstate = static_cast<yypstate *> (parser_state);
 
     try
       {
         status = octave_pull_parse (pstate, *this);
       }
-    catch (octave_execution_exception& e)
+    catch (octave::execution_exception& e)
       {
         std::string file = lexer.fcn_file_full_name;
 
         if (file.empty ())
           error (e, "parse error");
         else
           error (e, "parse error in %s", file.c_str ());
       }
-    catch (octave_interrupt_exception &)
+    catch (octave::interrupt_exception &)
       {
         throw;
       }
     catch (...)
       {
         std::string file = lexer.fcn_file_full_name;
 
         if (file.empty ())
@@ -4087,26 +4087,26 @@ namespace octave
           }
 
         yypstate *pstate = static_cast<yypstate *> (parser_state);
 
         try
           {
             status = octave_push_parse (pstate, token, &lval, *this);
           }
-        catch (octave_execution_exception& e)
+        catch (octave::execution_exception& e)
           {
             std::string file = lexer.fcn_file_full_name;
 
             if (file.empty ())
               error (e, "parse error");
             else
               error (e, "parse error in %s", file.c_str ());
           }
-        catch (octave_interrupt_exception &)
+        catch (octave::interrupt_exception &)
           {
             throw;
           }
         catch (...)
           {
             std::string file = lexer.fcn_file_full_name;
 
             if (file.empty ())
@@ -4626,17 +4626,17 @@ source_file (const std::string& file_nam
   // If no symbol of this name, or the symbol is for a different file, load
   if (! fcn)
     {
       try
         {
           fcn = parse_fcn_file (file_full_name, file_name, "", "",
                                 require_file, true, false, false, warn_for);
         }
-      catch (octave_execution_exception& e)
+      catch (octave::execution_exception& e)
         {
           error (e, "source: error sourcing file '%s'",
                  file_full_name.c_str ());
         }
     }
 
   // Return or error if we don't have a valid script
   if (! fcn)
@@ -4786,17 +4786,17 @@ feval (const std::string& name, const oc
   if (fcn.is_defined ())
     retval = fcn.do_multi_index_op (nargout, args);
   else
     {
       try
         {
           maybe_missing_function_hook (name);
         }
-      catch (octave_execution_exception& e)
+      catch (octave::execution_exception& e)
         {
           error (e, "feval: function '%s' not found", name.c_str ());
         }
     }
 
   return retval;
 }
 
@@ -5110,17 +5110,17 @@ does.
   bool execution_error = false;
 
   octave_value_list tmp;
 
   try
     {
       tmp = eval_string (args(0), nargout > 0, parse_status, nargout);
     }
-  catch (const octave_execution_exception&)
+  catch (const octave::execution_exception&)
     {
       recover_from_exception ();
 
       execution_error = true;
     }
 
   if (nargin > 1 && (parse_status != 0 || execution_error))
     {
@@ -5280,17 +5280,17 @@ Like @code{eval}, except that the expres
 
   octave_value_list tmp;
 
   try
     {
       tmp = eval_string (args(1), nargout > 0,
                          parse_status, nargout);
     }
-  catch (const octave_execution_exception&)
+  catch (const octave::execution_exception&)
     {
       recover_from_exception ();
 
       execution_error = true;
     }
 
   if (nargin > 2 && (parse_status != 0 || execution_error))
     {
@@ -5365,22 +5365,22 @@ s = evalc ("t = 42"), t
   std::streambuf* old_out_buf = out_stream.rdbuf (buffer.rdbuf ());
   std::streambuf* old_err_buf = err_stream.rdbuf (buffer.rdbuf ());
 
 
   // call standard eval function
   octave_value_list retval;
   int eval_nargout = std::max (0, nargout - 1);
 
-  const octave_execution_exception* eval_exception = 0;
+  const octave::execution_exception* eval_exception = 0;
   try
     {
       retval = Feval (args, eval_nargout);
     }
-  catch (const octave_execution_exception& e)
+  catch (const octave::execution_exception& e)
     {
       // hold back exception from eval until we have restored streams
       eval_exception = &e;
     }
 
   // stop capturing buffer and restore stdout/stderr
   out_stream.flush ();
   err_stream.flush ();
diff --git a/libinterp/parse-tree/pt-assign.cc b/libinterp/parse-tree/pt-assign.cc
--- a/libinterp/parse-tree/pt-assign.cc
+++ b/libinterp/parse-tree/pt-assign.cc
@@ -116,17 +116,17 @@ tree_simple_assignment::rvalue1 (int)
               ult.clear_index ();
 
               octave_value lhs_val = ult.value ();
 
               lhs_val.print_with_name (octave_stdout,
                                        lhs->name ());
             }
         }
-      catch (index_exception& e)
+      catch (octave::index_exception& e)
         {
           e.set_var (lhs->name ());
           std::string msg = e.message ();
           error_with_id (e.err_id (), msg.c_str ());
         }
     }
 
   return retval;
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -835,17 +835,17 @@ namespace octave
       if (try_code)
         {
           try
             {
               in_try_catch++;
               try_code->accept (*this);
               in_try_catch--;
             }
-          catch (const octave_execution_exception&)
+          catch (const octave::execution_exception&)
             {
               recover_from_exception ();
 
               in_try_catch--;          // must be restored before "catch" block
               execution_error = true;
             }
         }
       // Unwind to let the user print any messages from
@@ -907,17 +907,17 @@ namespace octave
     frame.protect_var (tree_break_command::breaking);
     tree_break_command::breaking = 0;
 
     try
       {
         if (list)
           list->accept (*this);
       }
-    catch (const octave_execution_exception&)
+    catch (const octave::execution_exception&)
       {
         recover_from_exception ();
 
         if (tree_break_command::breaking || tree_return_command::returning)
           frame.discard (2);
         else
           frame.run (2);
 
@@ -967,17 +967,17 @@ namespace octave
     tree_statement_list *unwind_protect_code = cmd.body ();
 
     if (unwind_protect_code)
       {
         try
           {
             unwind_protect_code->accept (*this);
           }
-        catch (const octave_execution_exception&)
+        catch (const octave::execution_exception&)
           {
             // FIXME: Maybe we should be able to temporarily set the
             // interpreter's exception handling state to something "safe"
             // while the cleanup block runs instead of just resetting it
             // here?
             recover_from_exception ();
 
             // Run the cleanup code on exceptions, so that it is run even
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -269,17 +269,17 @@ tree_index_expression::rvalue (int nargo
   return tree_index_expression::rvalue (nargout, 0);
 }
 
 // Final step of processing an indexing error.  Add the name of the
 // variable being indexed, if any, then issue an error.  (Will this also
 // be needed by pt-lvalue, which calls subsref?)
 
 static void
-final_index_error (index_exception& e, const tree_expression *expr)
+final_index_error (octave::index_exception& e, const tree_expression *expr)
 {
   if (expr->is_identifier ()
       && dynamic_cast<const tree_identifier *> (expr)->is_variable ())
     e.set_var (expr->name ());
 
   std::string msg = e.message ();
   error_with_id (e.err_id (), msg.c_str ());
 }
@@ -381,17 +381,17 @@ tree_index_expression::rvalue (int nargo
                           tmp = (tmp_list.length ()
                                  ? tmp_list(0) : octave_value ());
 
                           if (tmp.is_cs_list ())
                             err_indexed_cs_list ();
                         }
                     }
                 }
-              catch (index_exception& e)  // problems with index range, type etc.
+              catch (octave::index_exception& e)  // problems with index range, type etc.
                 {
                   final_index_error (e, expr);
                 }
             }
         }
 
       switch (type[i])
         {
@@ -423,17 +423,17 @@ tree_index_expression::rvalue (int nargo
       p_dyn_field++;
     }
 
   try
     {
       retval = tmp.subsref (type.substr (tmpi, n - tmpi), idx, nargout,
                             lvalue_list);
     }
-  catch (index_exception& e)    // problems with range, invalid index type etc.
+  catch (octave::index_exception& e)    // problems with range, invalid index type etc.
     {
       final_index_error (e, expr);
     }
 
   octave_value val = retval.length () ? retval(0) : octave_value ();
 
   if (val.is_function ())
     {
@@ -493,17 +493,17 @@ tree_index_expression::lvalue (void)
         err_indexed_cs_list ();
 
       if (tmpi < i)
         {
           try
             {
               tmp = tmp.subsref (type.substr (tmpi, i-tmpi), tmpidx, true);
             }
-          catch (index_exception& e)  // problems with range, invalid type etc.
+          catch (octave::index_exception& e)  // problems with range, invalid type etc.
             {
               final_index_error (e, expr);
             }
 
           tmpidx.clear ();
         }
 
       switch (type[i])
diff --git a/libinterp/parse-tree/pt.cc b/libinterp/parse-tree/pt.cc
--- a/libinterp/parse-tree/pt.cc
+++ b/libinterp/parse-tree/pt.cc
@@ -84,16 +84,16 @@ tree::meets_bp_condition () const
                 warning ("Breakpoint condition must be a scalar, not size %s",
                   val(0).dims ().str ('x').c_str ());
               else
                 retval = val(0).bool_value ();
             }
           else
             warning ("Error parsing breakpoint condition");
         }
-      catch (const octave_execution_exception& e)
+      catch (const octave::execution_exception& e)
         {
           warning ("Error evaluating breakpoint condition:\n    %s",
                    last_error_message ().c_str ());
         }
     }
   return retval;
 }
diff --git a/liboctave/array/Array-util.cc b/liboctave/array/Array-util.cc
--- a/liboctave/array/Array-util.cc
+++ b/liboctave/array/Array-util.cc
@@ -171,69 +171,69 @@ any_ones (const Array<octave_idx_type>& 
     }
   return retval;
 }
 
 octave_idx_type
 compute_index (octave_idx_type n, const dim_vector& dims)
 {
   if (n < 0)
-    err_invalid_index (n, 1, 1);
+    octave::err_invalid_index (n, 1, 1);
   if (n >= dims.numel ())
-    err_index_out_of_range (1, 1, n+1, dims.numel (), dims);
+    octave::err_index_out_of_range (1, 1, n+1, dims.numel (), dims);
 
   return n;
 }
 
 octave_idx_type
 compute_index (octave_idx_type i, octave_idx_type j, const dim_vector& dims)
 {
   if (i < 0)
-    err_invalid_index (i, 2, 1);
+    octave::err_invalid_index (i, 2, 1);
   if (j < 0)
-    err_invalid_index (j, 2, 2);
+    octave::err_invalid_index (j, 2, 2);
   if (i >= dims(0))
-    err_index_out_of_range (2, 1, i+1, dims(0), dims);
+    octave::err_index_out_of_range (2, 1, i+1, dims(0), dims);
   if (j >= dims.numel (1))
-    err_index_out_of_range (2, 2, j+1, dims.numel (1), dims);
+    octave::err_index_out_of_range (2, 2, j+1, dims.numel (1), dims);
 
   return j*dims(0) + i;
 }
 
 octave_idx_type
 compute_index (octave_idx_type i, octave_idx_type j, octave_idx_type k,
                const dim_vector& dims)
 {
   if (i < 0)
-    err_invalid_index (i, 3, 1);
+    octave::err_invalid_index (i, 3, 1);
   if (j < 0)
-    err_invalid_index (j, 3, 2);
+    octave::err_invalid_index (j, 3, 2);
   if (k < 0)
-    err_invalid_index (k, 3, 3);
+    octave::err_invalid_index (k, 3, 3);
   if (i >= dims(0))
-    err_index_out_of_range (3, 1, i+1, dims(0), dims);
+    octave::err_index_out_of_range (3, 1, i+1, dims(0), dims);
   if (j >= dims(1))
-    err_index_out_of_range (3, 2, j+1, dims(1), dims);
+    octave::err_index_out_of_range (3, 2, j+1, dims(1), dims);
   if (k >= dims.numel (2))
-    err_index_out_of_range (3, 3, k+1, dims.numel (2), dims);
+    octave::err_index_out_of_range (3, 3, k+1, dims.numel (2), dims);
 
   return (k*dims(1) + j)*dims(0) + i;
 }
 
 octave_idx_type
 compute_index (const Array<octave_idx_type>& ra_idx, const dim_vector& dims)
 {
   int nd = ra_idx.numel ();
   const dim_vector dv = dims.redim (nd);
   for (int d = 0; d < nd; d++)
     {
       if (ra_idx(d) < 0)
-        err_invalid_index (ra_idx(d), nd, d+1);
+        octave::err_invalid_index (ra_idx(d), nd, d+1);
       if (ra_idx(d) >= dv(d))
-        err_index_out_of_range (nd, d+1, ra_idx(d)+1, dv(d), dims);
+        octave::err_index_out_of_range (nd, d+1, ra_idx(d)+1, dv(d), dims);
     }
 
   return dv.compute_index (ra_idx.data ());
 }
 
 Array<octave_idx_type>
 conv_to_int_array (const Array<idx_vector>& a)
 {
@@ -553,19 +553,19 @@ sub2ind (const dim_vector& dv, const Arr
           all_ranges = all_ranges && idx.is_range ();
           if (clen < 0)
             clen = idx.length (n);
           else if (clen != idx.length (n))
             (*current_liboctave_error_handler)
               ("sub2ind: lengths of indices must match");
 
           if (idx.extent (n) > n)
-              err_index_out_of_range (len, i+1, idx.extent (n), n);
+              octave::err_index_out_of_range (len, i+1, idx.extent (n), n);
         }
-      catch (index_exception& e)
+      catch (octave::index_exception& e)
         {
           e.set_pos_if_unset (len, i+1);
           e.set_var ();
           std::string msg = e.message ();
           (*current_liboctave_error_with_id_handler)
             (e.err_id (), msg.c_str ());
         }
     }
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -196,19 +196,19 @@ Array<T>::compute_index (const Array<oct
 }
 
 template <typename T>
 T&
 Array<T>::checkelem (octave_idx_type n)
 {
   // Do checks directly to avoid recomputing slice_len.
   if (n < 0)
-    err_invalid_index (n);
+    octave::err_invalid_index (n);
   if (n >= slice_len)
-    err_index_out_of_range (1, 1, n+1, slice_len, dimensions);
+    octave::err_index_out_of_range (1, 1, n+1, slice_len, dimensions);
 
   return elem (n);
 }
 
 template <typename T>
 T&
 Array<T>::checkelem (octave_idx_type i, octave_idx_type j)
 {
@@ -230,19 +230,19 @@ Array<T>::checkelem (const Array<octave_
 }
 
 template <typename T>
 typename Array<T>::crefT
 Array<T>::checkelem (octave_idx_type n) const
 {
   // Do checks directly to avoid recomputing slice_len.
   if (n < 0)
-    err_invalid_index (n);
+    octave::err_invalid_index (n);
   if (n >= slice_len)
-    err_index_out_of_range (1, 1, n+1, slice_len, dimensions);
+    octave::err_index_out_of_range (1, 1, n+1, slice_len, dimensions);
 
   return elem (n);
 }
 
 template <typename T>
 typename Array<T>::crefT
 Array<T>::checkelem (octave_idx_type i, octave_idx_type j) const
 {
@@ -266,46 +266,46 @@ Array<T>::checkelem (const Array<octave_
 
 template <typename T>
 Array<T>
 Array<T>::column (octave_idx_type k) const
 {
   octave_idx_type r = dimensions(0);
 #if defined (OCTAVE_ENABLE_BOUNDS_CHECK)
   if (k < 0 || k > dimensions.numel (1))
-    err_index_out_of_range (2, 2, k+1, dimensions.numel (1), dimensions);
+    octave::err_index_out_of_range (2, 2, k+1, dimensions.numel (1), dimensions);
 #endif
 
   return Array<T> (*this, dim_vector (r, 1), k*r, k*r + r);
 }
 
 template <typename T>
 Array<T>
 Array<T>::page (octave_idx_type k) const
 {
   octave_idx_type r = dimensions(0);
   octave_idx_type c = dimensions(1);
   octave_idx_type p = r*c;
 #if defined (OCTAVE_ENABLE_BOUNDS_CHECK)
   if (k < 0 || k > dimensions.numel (2))
-    err_index_out_of_range (3, 3, k+1, dimensions.numel (2), dimensions);
+    octave::err_index_out_of_range (3, 3, k+1, dimensions.numel (2), dimensions);
 #endif
 
   return Array<T> (*this, dim_vector (r, c), k*p, k*p + p);
 }
 
 template <typename T>
 Array<T>
 Array<T>::linear_slice (octave_idx_type lo, octave_idx_type up) const
 {
 #if defined (OCTAVE_ENABLE_BOUNDS_CHECK)
   if (lo < 0)
-    err_index_out_of_range (1, 1, lo+1, numel (), dimensions);
+    octave::err_index_out_of_range (1, 1, lo+1, numel (), dimensions);
   if (up > numel ())
-    err_index_out_of_range (1, 1, up, numel (), dimensions);
+    octave::err_index_out_of_range (1, 1, up, numel (), dimensions);
 #endif
   if (up < lo) up = lo;
   return Array<T> (*this, dim_vector (up - lo, 1), lo, up);
 }
 
 // Helper class for multi-d dimension permuting (generalized transpose).
 class rec_permute_helper
 {
@@ -723,17 +723,17 @@ Array<T>::index (const idx_vector& i) co
   if (i.is_colon ())
     {
       // A(:) produces a shallow copy as a column vector.
       retval = Array<T> (*this, dim_vector (n, 1));
     }
   else
     {
       if (i.extent (n) != n)
-        err_index_out_of_range (1, 1, i.extent (n), n, dimensions); // throws
+        octave::err_index_out_of_range (1, 1, i.extent (n), n, dimensions); // throws
 
       // FIXME: this is the only place where orig_dimensions are used.
       dim_vector rd = i.orig_dimensions ();
       octave_idx_type il = i.length (n);
 
       // FIXME: this is for Matlab compatibility.  Matlab 2007 given
       //
       //   b = ones (3,1)
@@ -790,19 +790,19 @@ Array<T>::index (const idx_vector& i, co
   if (i.is_colon () && j.is_colon ())
     {
       // A(:,:) produces a shallow copy.
       retval = Array<T> (*this, dv);
     }
   else
     {
       if (i.extent (r) != r)
-        err_index_out_of_range (2, 1, i.extent (r), r, dimensions); // throws
+        octave::err_index_out_of_range (2, 1, i.extent (r), r, dimensions); // throws
       if (j.extent (c) != c)
-        err_index_out_of_range (2, 2, j.extent (c), c, dimensions); // throws
+        octave::err_index_out_of_range (2, 2, j.extent (c), c, dimensions); // throws
 
       octave_idx_type n = numel ();
       octave_idx_type il = i.length (r);
       octave_idx_type jl = j.length (c);
 
       idx_vector ii (i);
 
       if (ii.maybe_reduce (r, j, c))
@@ -852,17 +852,17 @@ Array<T>::index (const Array<idx_vector>
       // Get dimensions, allowing Fortran indexing in the last dim.
       dim_vector dv = dimensions.redim (ial);
 
       // Check for out of bounds conditions.
       bool all_colons = true;
       for (int i = 0; i < ial; i++)
         {
           if (ia(i).extent (dv(i)) != dv(i))
-            err_index_out_of_range (ial, i+1, ia(i).extent (dv(i)), dv(i), dimensions); // throws
+            octave::err_index_out_of_range (ial, i+1, ia(i).extent (dv(i)), dv(i), dimensions); // throws
 
           all_colons = all_colons && ia(i).is_colon ();
         }
 
       if (all_colons)
         {
           // A(:,:,...,:) produces a shallow copy.
           dv.chop_trailing_singletons ();
@@ -909,17 +909,17 @@ Array<T>::resize_fill_value (void) const
 // Yes, we could do resize using index & assign.  However, that would
 // possibly involve a lot more memory traffic than we actually need.
 
 template <typename T>
 void
 Array<T>::resize1 (octave_idx_type n, const T& rfv)
 {
   if (n < 0 || ndims () != 2)
-    err_invalid_resize ();
+    octave::err_invalid_resize ();
 
   dim_vector dv;
   // This is driven by Matlab's behavior of giving a *row* vector
   // on some out-of-bounds assignments.  Specifically, Matlab
   // allows a(i) with out-of-bouds i when a is either of 0x0, 1x0,
   // 1x1, 0xN, and gives a row vector in all cases (yes, even the
   // last one, search me why).  Giving a column vector would make
   // much more sense (given the way trailing singleton dims are
@@ -928,17 +928,17 @@ Array<T>::resize1 (octave_idx_type n, co
   if (rows () == 0 || rows () == 1)
     dv = dim_vector (1, n);
   else if (columns () == 1)
     dv = dim_vector (n, 1);
   else
     invalid = true;
 
   if (invalid)
-    err_invalid_resize ();
+    octave::err_invalid_resize ();
 
   octave_idx_type nx = numel ();
   if (n == nx - 1 && n > 0)
     {
       // Stack "pop" operation.
       if (rep->count == 1)
         slice_data[slice_len-1] = T ();
       slice_len--;
@@ -980,17 +980,17 @@ Array<T>::resize1 (octave_idx_type n, co
     }
 }
 
 template <typename T>
 void
 Array<T>::resize2 (octave_idx_type r, octave_idx_type c, const T& rfv)
 {
   if (r < 0 || c < 0 || ndims () != 2)
-    err_invalid_resize ();
+    octave::err_invalid_resize ();
 
   octave_idx_type rx = rows ();
   octave_idx_type cx = columns ();
   if (r != rx || c != cx)
     {
       Array<T> tmp = Array<T> (dim_vector (r, c));
       T *dest = tmp.fortran_vec ();
 
@@ -1027,17 +1027,17 @@ void
 Array<T>::resize (const dim_vector& dv, const T& rfv)
 {
   int dvl = dv.ndims ();
   if (dvl == 2)
     resize2 (dv(0), dv(1), rfv);
   else if (dimensions != dv)
     {
       if (dimensions.ndims () > dvl || dv.any_neg ())
-        err_invalid_resize ();
+        octave::err_invalid_resize ();
 
       Array<T> tmp (dv);
       // Prepare for recursive resizing.
       rec_resize_helper rh (dv, dimensions.redim (dvl));
 
       // Do it.
       rh.resize_fill (data (), tmp.fortran_vec (), rfv);
       *this = tmp;
@@ -1130,17 +1130,17 @@ Array<T>::index (const Array<idx_vector>
 template <typename T>
 void
 Array<T>::assign (const idx_vector& i, const Array<T>& rhs, const T& rfv)
 {
   octave_idx_type n = numel ();
   octave_idx_type rhl = rhs.numel ();
 
   if (rhl != 1 && i.length (n) != rhl)
-    err_nonconformant ("=", dim_vector(i.length(n),1), rhs.dims());
+    octave::err_nonconformant ("=", dim_vector(i.length(n),1), rhs.dims());
 
   octave_idx_type nx = i.extent (n);
   bool colon = i.is_colon_equiv (nx);
   // Try to resize first if necessary.
   if (nx != n)
     {
       // Optimize case A = []; A(1:n) = X with A empty.
       if (dimensions.zero_by_zero () && colon)
@@ -1269,17 +1269,17 @@ Array<T>::assign (const idx_vector& i, c
                   for (octave_idx_type k = 0; k < jl; k++)
                     src += i.assign (src, r, dest + r * j.xelem (k));
                 }
             }
         }
     }
   // any empty RHS can be assigned to an empty LHS
   else if ((il != 0 && jl != 0) || (rhdv(0) != 0 && rhdv(1) != 0))
-    err_nonconformant ("=", il, jl, rhs.dim1 (), rhs.dim2 ());
+    octave::err_nonconformant ("=", il, jl, rhs.dim1 (), rhs.dim2 ());
 }
 
 // Assignment to a multi-dimensional array
 template <typename T>
 void
 Array<T>::assign (const Array<idx_vector>& ia,
                   const Array<T>& rhs, const T& rfv)
 {
@@ -1383,17 +1383,17 @@ Array<T>::assign (const Array<idx_vector
           lhsempty = rhsempty = false;
           for (int i = 0; i < ial; i++)
             {
               octave_idx_type l = ia(i).length (rdv(i));
               lhsempty = lhsempty || (l == 0);
               rhsempty = rhsempty || (rhdv(j++) == 0);
             }
           if (! lhsempty || ! rhsempty)
-            err_nonconformant ("=", dv, rhdv);
+            octave::err_nonconformant ("=", dv, rhdv);
         }
     }
 }
 
 /*
 %!shared a
 %! a = [1 2; 3 4];
 %!error <op1 is 1x2, op2 is 1x3> a(1,:) = [1 2 3]
@@ -1408,17 +1408,17 @@ Array<T>::delete_elements (const idx_vec
   octave_idx_type n = numel ();
   if (i.is_colon ())
     {
       *this = Array<T> ();
     }
   else if (i.length (n) != 0)
     {
       if (i.extent (n) != n)
-        err_del_index_out_of_range (true, i.extent (n), n);
+        octave::err_del_index_out_of_range (true, i.extent (n), n);
 
       octave_idx_type l, u;
       bool col_vec = ndims () == 2 && columns () == 1 && rows () != 1;
       if (i.is_scalar () && i(0) == n-1 && dimensions.is_vector ())
         {
           // Stack "pop" operation.
           resize1 (n-1);
         }
@@ -1451,17 +1451,17 @@ Array<T>::delete_elements (int dim, cons
   octave_idx_type n = dimensions(dim);
   if (i.is_colon ())
     {
       *this = Array<T> ();
     }
   else if (i.length (n) != 0)
     {
       if (i.extent (n) != n)
-        err_del_index_out_of_range (false, i.extent (n), n);
+        octave::err_del_index_out_of_range (false, i.extent (n), n);
 
       octave_idx_type l, u;
 
       if (i.is_cont_range (n, l, u))
         {
           // Special case deleting a contiguous range.
           octave_idx_type nd = n + l - u;
           octave_idx_type dl = 1;
diff --git a/liboctave/array/CColVector.cc b/liboctave/array/CColVector.cc
--- a/liboctave/array/CColVector.cc
+++ b/liboctave/array/CColVector.cc
@@ -252,17 +252,17 @@ ComplexColumnVector::extract_n (octave_i
 ComplexColumnVector&
 ComplexColumnVector::operator += (const ColumnVector& a)
 {
   octave_idx_type len = numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
-    err_nonconformant ("operator +=", len, a_len);
+    octave::err_nonconformant ("operator +=", len, a_len);
 
   if (len == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
   mx_inline_add2 (len, d, a.data ());
   return *this;
@@ -271,17 +271,17 @@ ComplexColumnVector::operator += (const 
 ComplexColumnVector&
 ComplexColumnVector::operator -= (const ColumnVector& a)
 {
   octave_idx_type len = numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
-    err_nonconformant ("operator -=", len, a_len);
+    octave::err_nonconformant ("operator -=", len, a_len);
 
   if (len == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
   mx_inline_sub2 (len, d, a.data ());
   return *this;
@@ -302,17 +302,17 @@ operator * (const ComplexMatrix& m, cons
   ComplexColumnVector retval;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
-    err_nonconformant ("operator *", nr, nc, a_len, 1);
+    octave::err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   retval.clear (nr);
 
   if (nr != 0)
     {
       if (nc == 0)
         retval.fill (0.0);
       else
@@ -346,17 +346,17 @@ ComplexColumnVector
 operator * (const DiagMatrix& m, const ComplexColumnVector& a)
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
-    err_nonconformant ("operator *", nr, nc, a_len, 1);
+    octave::err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
 
   ComplexColumnVector result (nr);
 
   for (octave_idx_type i = 0; i < a_len; i++)
     result.elem (i) = a.elem (i) * m.elem (i, i);
@@ -371,17 +371,17 @@ ComplexColumnVector
 operator * (const ComplexDiagMatrix& m, const ColumnVector& a)
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
-    err_nonconformant ("operator *", nr, nc, a_len, 1);
+    octave::err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
 
   ComplexColumnVector result (nr);
 
   for (octave_idx_type i = 0; i < a_len; i++)
     result.elem (i) = a.elem (i) * m.elem (i, i);
@@ -396,17 +396,17 @@ ComplexColumnVector
 operator * (const ComplexDiagMatrix& m, const ComplexColumnVector& a)
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
-    err_nonconformant ("operator *", nr, nc, a_len, 1);
+    octave::err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
 
   ComplexColumnVector result (nr);
 
   for (octave_idx_type i = 0; i < a_len; i++)
     result.elem (i) = a.elem (i) * m.elem (i, i);
diff --git a/liboctave/array/CDiagMatrix.cc b/liboctave/array/CDiagMatrix.cc
--- a/liboctave/array/CDiagMatrix.cc
+++ b/liboctave/array/CDiagMatrix.cc
@@ -365,17 +365,17 @@ ComplexDiagMatrix::operator += (const Di
 {
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (r != a_nr || c != a_nc)
-    err_nonconformant ("operator +=", r, c, a_nr, a_nc);
+    octave::err_nonconformant ("operator +=", r, c, a_nr, a_nc);
 
   if (r == 0 || c == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
   mx_inline_add2 (length (), d, a.data ());
   return *this;
@@ -386,17 +386,17 @@ operator * (const ComplexDiagMatrix& a, 
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nr)
-    err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
+    octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   ComplexDiagMatrix c (a_nr, b_nc);
 
   octave_idx_type len = c.length ();
   octave_idx_type lenm = len < a_nc ? len : a_nc;
 
   for (octave_idx_type i = 0; i < lenm; i++)
     c.dgxelem (i) = a.dgelem (i) * b.dgelem (i);
@@ -411,17 +411,17 @@ operator * (const DiagMatrix& a, const C
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nr)
-    err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
+    octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     return ComplexDiagMatrix (a_nr, a_nc, 0.0);
 
   ComplexDiagMatrix c (a_nr, b_nc);
 
   octave_idx_type len = a_nr < b_nc ? a_nr : b_nc;
 
@@ -441,17 +441,17 @@ operator * (const ComplexDiagMatrix& a, 
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nr)
-    err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
+    octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     return ComplexDiagMatrix (a_nr, a_nc, 0.0);
 
   ComplexDiagMatrix c (a_nr, b_nc);
 
   octave_idx_type len = a_nr < b_nc ? a_nr : b_nc;
 
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -1705,17 +1705,17 @@ ComplexMatrix::utsolve (MatrixType &matt
 
           if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
             {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
-                warn_singular_matrix (rcon);
+                octave::warn_singular_matrix (rcon);
             }
         }
     }
 
   return retval;
 }
 
 ComplexMatrix
@@ -1795,17 +1795,17 @@ ComplexMatrix::ltsolve (MatrixType &matt
 
           if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
             {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
-                warn_singular_matrix (rcon);
+                octave::warn_singular_matrix (rcon);
             }
         }
     }
 
   return retval;
 }
 
 ComplexMatrix
@@ -1876,17 +1876,17 @@ ComplexMatrix::fsolve (MatrixType &matty
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        warn_singular_matrix (rcon);
+                        octave::warn_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   Complex *result = retval.fortran_vec ();
 
@@ -1936,17 +1936,17 @@ ComplexMatrix::fsolve (MatrixType &matty
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
-                warn_singular_matrix ();
+                octave::warn_singular_matrix ();
 
               mattype.mark_as_rectangular ();
             }
           else
             {
               if (calc_cond)
                 {
                   // Now calculate the condition number for
@@ -1964,17 +1964,17 @@ ComplexMatrix::fsolve (MatrixType &matty
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        warn_singular_matrix (rcon);
+                        octave::warn_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   Complex *result = retval.fortran_vec ();
 
@@ -2694,17 +2694,17 @@ ComplexMatrix::operator += (const DiagMa
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = rows ();
   octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
-    err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
+    octave::err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) += a.elem (i, i);
 
   return *this;
 }
 
 ComplexMatrix&
@@ -2712,17 +2712,17 @@ ComplexMatrix::operator -= (const DiagMa
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = rows ();
   octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
-    err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
+    octave::err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) -= a.elem (i, i);
 
   return *this;
 }
 
 ComplexMatrix&
@@ -2730,17 +2730,17 @@ ComplexMatrix::operator += (const Comple
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = rows ();
   octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
-    err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
+    octave::err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) += a.elem (i, i);
 
   return *this;
 }
 
 ComplexMatrix&
@@ -2748,17 +2748,17 @@ ComplexMatrix::operator -= (const Comple
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = rows ();
   octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
-    err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
+    octave::err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) -= a.elem (i, i);
 
   return *this;
 }
 
 // matrix by matrix -> matrix operations
@@ -2768,17 +2768,17 @@ ComplexMatrix::operator += (const Matrix
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
-    err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
+    octave::err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
 
   if (nr == 0 || nc == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
   mx_inline_add2 (numel (), d, a.data ());
   return *this;
@@ -2789,17 +2789,17 @@ ComplexMatrix::operator -= (const Matrix
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
-    err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
+    octave::err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
 
   if (nr == 0 || nc == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
   mx_inline_sub2 (numel (), d, a.data ());
   return *this;
@@ -3380,17 +3380,17 @@ xgemm (const ComplexMatrix& a, const Com
 
   octave_idx_type a_nr = tra ? a.cols () : a.rows ();
   octave_idx_type a_nc = tra ? a.rows () : a.cols ();
 
   octave_idx_type b_nr = trb ? b.cols () : b.rows ();
   octave_idx_type b_nc = trb ? b.rows () : b.cols ();
 
   if (a_nc != b_nr)
-    err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
+    octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     retval = ComplexMatrix (a_nr, b_nc, 0.0);
   else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
     {
       octave_idx_type lda = a.rows ();
 
       // FIXME: looking at the reference BLAS, it appears that it
diff --git a/liboctave/array/CNDArray.cc b/liboctave/array/CNDArray.cc
--- a/liboctave/array/CNDArray.cc
+++ b/liboctave/array/CNDArray.cc
@@ -480,17 +480,17 @@ ComplexNDArray::ifourierNd (void) const
 #endif
 
 // unary operations
 
 boolNDArray
 ComplexNDArray::operator ! (void) const
 {
   if (any_element_is_nan ())
-    err_nan_to_logical_conversion ();
+    octave::err_nan_to_logical_conversion ();
 
   return do_mx_unary_op<bool, Complex> (*this, mx_inline_not);
 }
 
 // FIXME: this is not quite the right thing.
 
 bool
 ComplexNDArray::any_element_is_nan (void) const
diff --git a/liboctave/array/CRowVector.cc b/liboctave/array/CRowVector.cc
--- a/liboctave/array/CRowVector.cc
+++ b/liboctave/array/CRowVector.cc
@@ -240,17 +240,17 @@ ComplexRowVector::extract_n (octave_idx_
 ComplexRowVector&
 ComplexRowVector::operator += (const RowVector& a)
 {
   octave_idx_type len = numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
-    err_nonconformant ("operator +=", len, a_len);
+    octave::err_nonconformant ("operator +=", len, a_len);
 
   if (len == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
   mx_inline_add2 (len, d, a.data ());
   return *this;
@@ -259,17 +259,17 @@ ComplexRowVector::operator += (const Row
 ComplexRowVector&
 ComplexRowVector::operator -= (const RowVector& a)
 {
   octave_idx_type len = numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
-    err_nonconformant ("operator -=", len, a_len);
+    octave::err_nonconformant ("operator -=", len, a_len);
 
   if (len == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
   mx_inline_sub2 (len, d, a.data ());
   return *this;
@@ -283,17 +283,17 @@ operator * (const ComplexRowVector& v, c
   ComplexRowVector retval;
 
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != len)
-    err_nonconformant ("operator *", 1, len, a_nr, a_nc);
+    octave::err_nonconformant ("operator *", 1, len, a_nr, a_nc);
 
   if (len == 0)
     retval.resize (a_nc, 0.0);
   else
     {
       // Transpose A to form A'*x == (x'*A)'
 
       octave_idx_type ld = a_nr;
@@ -406,17 +406,17 @@ operator * (const ComplexRowVector& v, c
 {
   Complex retval (0.0, 0.0);
 
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
-    err_nonconformant ("operator *", len, a_len);
+    octave::err_nonconformant ("operator *", len, a_len);
   if (len != 0)
     F77_FUNC (xzdotu, XZDOTU) (len, F77_CONST_DBLE_CMPLX_ARG (v.data ()), 1, F77_CONST_DBLE_CMPLX_ARG (a.data ()), 1, F77_DBLE_CMPLX_ARG (&retval));
 
   return retval;
 }
 
 // other operations
 
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -1695,32 +1695,32 @@ SparseComplexMatrix::utsolve (MatrixType
       if (err != 0)
         {
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
       if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::utsolve (MatrixType &mattype, const SparseMatrix& b,
@@ -1977,32 +1977,32 @@ SparseComplexMatrix::utsolve (MatrixType
       if (err != 0)
         {
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
       if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
     }
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::utsolve (MatrixType &mattype, const ComplexMatrix& b,
                               octave_idx_type& err, double& rcond,
@@ -2206,32 +2206,32 @@ SparseComplexMatrix::utsolve (MatrixType
       if (err != 0)
         {
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
       if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::utsolve (MatrixType &mattype, const SparseComplexMatrix& b,
@@ -2488,32 +2488,32 @@ SparseComplexMatrix::utsolve (MatrixType
       if (err != 0)
         {
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
       if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::ltsolve (MatrixType &mattype, const Matrix& b,
@@ -2737,32 +2737,32 @@ SparseComplexMatrix::ltsolve (MatrixType
       if (err != 0)
         {
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
       if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::ltsolve (MatrixType &mattype, const SparseMatrix& b,
@@ -3038,32 +3038,32 @@ SparseComplexMatrix::ltsolve (MatrixType
       if (err != 0)
         {
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
       if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::ltsolve (MatrixType &mattype, const ComplexMatrix& b,
@@ -3290,32 +3290,32 @@ SparseComplexMatrix::ltsolve (MatrixType
       if (err != 0)
         {
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
       if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::ltsolve (MatrixType &mattype, const SparseComplexMatrix& b,
@@ -3590,32 +3590,32 @@ SparseComplexMatrix::ltsolve (MatrixType
       if (err != 0)
         {
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
       if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::trisolve (MatrixType &mattype, const Matrix& b,
@@ -3750,17 +3750,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                warn_singular_matrix ();
+                octave::warn_singular_matrix ();
 
             }
           else
             rcond = 1.;
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -3848,17 +3848,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                warn_singular_matrix ();
+                octave::warn_singular_matrix ();
             }
           else
             {
               char job = 'N';
               volatile octave_idx_type x_nz = b.nnz ();
               octave_idx_type b_nc = b.cols ();
               retval = SparseComplexMatrix (nr, b_nc, x_nz);
               retval.xcidx (0) = 0;
@@ -4051,17 +4051,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                warn_singular_matrix ();
+                octave::warn_singular_matrix ();
             }
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -4147,17 +4147,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                warn_singular_matrix ();
+                octave::warn_singular_matrix ();
             }
           else
             {
               rcond = 1.;
               char job = 'N';
               octave_idx_type b_nr = b.rows ();
               octave_idx_type b_nc = b.cols ();
               OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
@@ -4319,17 +4319,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        warn_singular_matrix (rcond);
+                        octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.0;
 
               if (err == 0)
                 {
                   retval = ComplexMatrix (b);
@@ -4405,17 +4405,17 @@ SparseComplexMatrix::bsolve (MatrixType 
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                warn_singular_matrix ();
+                octave::warn_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
@@ -4438,17 +4438,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        warn_singular_matrix (rcond);
+                        octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   retval = ComplexMatrix (b);
@@ -4563,17 +4563,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        warn_singular_matrix (rcond);
+                        octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.0;
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
@@ -4682,17 +4682,17 @@ SparseComplexMatrix::bsolve (MatrixType 
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                warn_singular_matrix ();
+                octave::warn_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
@@ -4715,17 +4715,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        warn_singular_matrix (rcond);
+                        octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
@@ -4879,17 +4879,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        warn_singular_matrix (rcond);
+                        octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.0;
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
@@ -4963,17 +4963,17 @@ SparseComplexMatrix::bsolve (MatrixType 
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                warn_singular_matrix ();
+                octave::warn_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
@@ -4996,17 +4996,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        warn_singular_matrix (rcond);
+                        octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
@@ -5123,17 +5123,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        warn_singular_matrix (rcond);
+                        octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.0;
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
@@ -5247,17 +5247,17 @@ SparseComplexMatrix::bsolve (MatrixType 
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                warn_singular_matrix ();
+                octave::warn_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
@@ -5280,17 +5280,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        warn_singular_matrix (rcond);
+                        octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
@@ -5435,17 +5435,17 @@ SparseComplexMatrix::factorize (octave_i
         {
           UMFPACK_ZNAME (report_numeric) (Numeric, control);
 
           err = -2;
 
           if (sing_handler)
             sing_handler (rcond);
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
       else if (status < 0)
         {
           UMFPACK_ZNAME (report_status) (control, status);
           UMFPACK_ZNAME (report_info) (control, info);
 
           // FIXME: Should this be a warning?
           (*current_liboctave_error_handler)
@@ -5595,17 +5595,17 @@ SparseComplexMatrix::fsolve (MatrixType 
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    warn_singular_matrix (rcond);
+                    octave::warn_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -5855,17 +5855,17 @@ SparseComplexMatrix::fsolve (MatrixType 
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    warn_singular_matrix (rcond);
+                    octave::warn_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_sparse *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -6143,17 +6143,17 @@ SparseComplexMatrix::fsolve (MatrixType 
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    warn_singular_matrix (rcond);
+                    octave::warn_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -6382,17 +6382,17 @@ SparseComplexMatrix::fsolve (MatrixType 
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    warn_singular_matrix (rcond);
+                    octave::warn_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_sparse *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -6513,17 +6513,17 @@ SparseComplexMatrix::fsolve (MatrixType 
               if (status == UMFPACK_WARNING_singular_matrix
                   || rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                 {
                   err = -2;
 
                   if (sing_handler)
                     sing_handler (rcond);
                   else
-                    warn_singular_matrix (rcond);
+                    octave::warn_singular_matrix (rcond);
                 }
 
               UMFPACK_ZNAME (report_info) (control, info);
 
               UMFPACK_ZNAME (free_numeric) (&Numeric);
             }
           else
             mattype.mark_as_rectangular ();
@@ -7055,17 +7055,17 @@ SparseComplexMatrix::solve (const Comple
                 sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 // unary operations
 SparseBoolMatrix
 SparseComplexMatrix::operator ! (void) const
 {
   if (any_element_is_nan ())
-    err_nan_to_logical_conversion ();
+    octave::err_nan_to_logical_conversion ();
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nz1 = nnz ();
   octave_idx_type nz2 = nr*nc - nz1;
 
   SparseBoolMatrix r (nr, nc, nz2);
 
@@ -7617,17 +7617,17 @@ min (const SparseComplexMatrix& a, const
     }
   else
     {
       if (a_nr == 0 || a_nc == 0)
         r.resize (a_nr, a_nc);
       else if (b_nr == 0 || b_nc == 0)
         r.resize (b_nr, b_nc);
       else
-        err_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
+        octave::err_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
     }
 
   return r;
 }
 
 SparseComplexMatrix
 max (const Complex& c, const SparseComplexMatrix& m)
 {
@@ -7734,17 +7734,17 @@ max (const SparseComplexMatrix& a, const
     }
   else
     {
       if (a_nr == 0 || a_nc == 0)
         r.resize (a_nr, a_nc);
       else if (b_nr == 0 || b_nc == 0)
         r.resize (b_nr, b_nc);
       else
-        err_nonconformant ("max", a_nr, a_nc, b_nr, b_nc);
+        octave::err_nonconformant ("max", a_nr, a_nc, b_nr, b_nc);
     }
 
   return r;
 }
 
 SPARSE_SMS_CMP_OPS (SparseComplexMatrix, 0.0, real, Complex,
                     0.0, real)
 SPARSE_SMS_BOOL_OPS (SparseComplexMatrix, Complex, 0.0)
diff --git a/liboctave/array/DiagArray2.cc b/liboctave/array/DiagArray2.cc
--- a/liboctave/array/DiagArray2.cc
+++ b/liboctave/array/DiagArray2.cc
@@ -133,15 +133,15 @@ DiagArray2<T>::array_value (void) const
 
 template <typename T>
 bool
 DiagArray2<T>::check_idx (octave_idx_type r, octave_idx_type c) const
 {
   bool ok = true;
 
   if (r < 0 || r >= dim1 ())
-    err_index_out_of_range (2, 1, r+1, dim1 (), dims ());
+    octave::err_index_out_of_range (2, 1, r+1, dim1 (), dims ());
 
   if (c < 0 || c >= dim2 ())
-    err_index_out_of_range (2, 2, c+1, dim2 (), dims ());
+    octave::err_index_out_of_range (2, 2, c+1, dim2 (), dims ());
 
   return ok;
 }
diff --git a/liboctave/array/MDiagArray2.cc b/liboctave/array/MDiagArray2.cc
--- a/liboctave/array/MDiagArray2.cc
+++ b/liboctave/array/MDiagArray2.cc
@@ -76,17 +76,17 @@ operator * (const T& s, const MDiagArray
 // Element by element MDiagArray2 by MDiagArray2 ops.
 
 #define MARRAY_DADA_OP(FCN, OP, FN)                                     \
   template <typename T>                                                 \
   MDiagArray2<T>                                                        \
   FCN (const MDiagArray2<T>& a, const MDiagArray2<T>& b)                \
   {                                                                     \
     if (a.d1 != b.d1 || a.d2 != b.d2)                                   \
-      err_nonconformant (#FCN, a.d1, a.d2, b.d1, b.d2);                 \
+      octave::err_nonconformant (#FCN, a.d1, a.d2, b.d1, b.d2);                 \
                                                                         \
     return MDiagArray2<T> (do_mm_binary_op<T, T, T> (a, b, FN, FN, FN, #FCN), a.d1, a.d2); \
   }
 
 MARRAY_DADA_OP (operator +, +, mx_inline_add)
 MARRAY_DADA_OP (operator -, -, mx_inline_sub)
 MARRAY_DADA_OP (product,    *, mx_inline_mul)
 
diff --git a/liboctave/array/MSparse.cc b/liboctave/array/MSparse.cc
--- a/liboctave/array/MSparse.cc
+++ b/liboctave/array/MSparse.cc
@@ -33,17 +33,17 @@ plus_or_minus (MSparse<T>& a, const MSpa
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nr != b_nr || a_nc != b_nc)
-    err_nonconformant (op_name , a_nr, a_nc, b_nr, b_nc);
+    octave::err_nonconformant (op_name , a_nr, a_nc, b_nr, b_nc);
 
   r = MSparse<T> (a_nr, a_nc, (a.nnz () + b.nnz ()));
 
   octave_idx_type jx = 0;
   for (octave_idx_type i = 0 ; i < a_nc ; i++)
     {
       octave_idx_type ja = a.cidx (i);
       octave_idx_type ja_max = a.cidx (i+1);
@@ -297,17 +297,17 @@ plus_or_minus (const MSparse<T>& a, cons
                   octave_quit ();
                   r.data (idxj + a.ridx (i)) = op (a.data (i), b.data (0));
                 }
             }
           r.maybe_compress ();
         }
     }
   else if (a_nr != b_nr || a_nc != b_nc)
-    err_nonconformant (op_name, a_nr, a_nc, b_nr, b_nc);
+    octave::err_nonconformant (op_name, a_nr, a_nc, b_nr, b_nc);
   else
     {
       r = MSparse<T> (a_nr, a_nc, (a.nnz () + b.nnz ()));
 
       octave_idx_type jx = 0;
       r.cidx (0) = 0;
       for (octave_idx_type i = 0 ; i < a_nc ; i++)
         {
@@ -418,17 +418,17 @@ product (const MSparse<T>& a, const MSpa
             {
               octave_quit ();
               r.data (i) = r.data (i) * b.data (0);
             }
           r.maybe_compress ();
         }
     }
   else if (a_nr != b_nr || a_nc != b_nc)
-    err_nonconformant ("product", a_nr, a_nc, b_nr, b_nc);
+    octave::err_nonconformant ("product", a_nr, a_nc, b_nr, b_nc);
   else
     {
       r = MSparse<T> (a_nr, a_nc, (a.nnz () > b.nnz () ? a.nnz () : b.nnz ()));
 
       octave_idx_type jx = 0;
       r.cidx (0) = 0;
       for (octave_idx_type i = 0 ; i < a_nc ; i++)
         {
@@ -538,17 +538,17 @@ quotient (const MSparse<T>& a, const MSp
                   octave_quit ();
                   r.data (idxj + a.ridx (i)) = a.data (i) / val;
                 }
             }
           r.maybe_compress ();
         }
     }
   else if (a_nr != b_nr || a_nc != b_nc)
-    err_nonconformant ("quotient", a_nr, a_nc, b_nr, b_nc);
+    octave::err_nonconformant ("quotient", a_nr, a_nc, b_nr, b_nc);
   else
     {
       r = MSparse<T> (a_nr, a_nc, (Zero / Zero));
 
       for (octave_idx_type i = 0 ; i < a_nc ; i++)
         {
           octave_idx_type ja = a.cidx (i);
           octave_idx_type ja_max = a.cidx (i+1);
diff --git a/liboctave/array/PermMatrix.cc b/liboctave/array/PermMatrix.cc
--- a/liboctave/array/PermMatrix.cc
+++ b/liboctave/array/PermMatrix.cc
@@ -222,14 +222,14 @@ operator *(const PermMatrix& a, const Pe
   PermMatrix r;
 
   const Array<octave_idx_type> ia = a.col_perm_vec ();
   const Array<octave_idx_type> ib = b.col_perm_vec ();
 
   octave_idx_type n = a.columns ();
 
   if (n != b.rows ())
-    err_nonconformant ("operator *", n, n, b.rows (), b.rows ());
+    octave::err_nonconformant ("operator *", n, n, b.rows (), b.rows ());
 
   r = PermMatrix (ia.index (idx_vector (ib)), true, false);
 
   return r;
 }
diff --git a/liboctave/array/Range.cc b/liboctave/array/Range.cc
--- a/liboctave/array/Range.cc
+++ b/liboctave/array/Range.cc
@@ -69,17 +69,17 @@ Range::matrix_value (void) const
 
   return cache;
 }
 
 double
 Range::checkelem (octave_idx_type i) const
 {
   if (i < 0 || i >= rng_numel)
-    err_index_out_of_range (1, 1, i+1, rng_numel);
+    octave::err_index_out_of_range (1, 1, i+1, rng_numel);
 
   if (i == 0)
     return rng_base;
   else if (i < rng_numel - 1)
     return rng_base + i * rng_inc;
   else
     return rng_limit;
 }
@@ -132,17 +132,17 @@ Range::index (const idx_vector& i) const
 
   if (i.is_colon ())
     {
       retval = matrix_value ().reshape (dim_vector (rng_numel, 1));
     }
   else
     {
       if (i.extent (n) != n)
-        err_index_out_of_range (1, 1, i.extent (n), n); // throws
+        octave::err_index_out_of_range (1, 1, i.extent (n), n); // throws
 
       dim_vector rd = i.orig_dimensions ();
       octave_idx_type il = i.length (n);
 
       // taken from Array.cc.
       if (n != 1 && rd.is_vector ())
         rd = dim_vector (1, il);
 
diff --git a/liboctave/array/Sparse.cc b/liboctave/array/Sparse.cc
--- a/liboctave/array/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -923,17 +923,17 @@ Sparse<T>::resize1 (octave_idx_type n)
     resize (1, std::max (nc, n));
   else if (nc == 0)
     resize (nr, (n + nr - 1) / nr); // Ain't it wicked?
   else if (nr == 1)
     resize (1, n);
   else if (nc == 1)
     resize (n, 1);
   else
-    err_invalid_resize ();
+    octave::err_invalid_resize ();
 }
 
 template <typename T>
 void
 Sparse<T>::resize (const dim_vector& dv)
 {
   octave_idx_type n = dv.ndims ();
 
@@ -1153,17 +1153,17 @@ Sparse<T>::delete_elements (const idx_ve
   octave_idx_type nc = dim2 ();
   octave_idx_type nz = nnz ();
 
   octave_idx_type nel = numel (); // Can throw.
 
   const dim_vector idx_dims = idx.orig_dimensions ();
 
   if (idx.extent (nel) > nel)
-    err_del_index_out_of_range (true, idx.extent (nel), nel);
+    octave::err_del_index_out_of_range (true, idx.extent (nel), nel);
 
   if (nc == 1)
     {
       // Sparse column vector.
       const Sparse<T> tmp = *this; // constant copy to prevent COW.
 
       octave_idx_type lb, ub;
 
@@ -1252,17 +1252,17 @@ Sparse<T>::delete_elements (const idx_ve
   octave_idx_type nc = dim2 ();
   octave_idx_type nz = nnz ();
 
   if (idx_i.is_colon ())
     {
       // Deleting columns.
       octave_idx_type lb, ub;
       if (idx_j.extent (nc) > nc)
-        err_del_index_out_of_range (false, idx_j.extent (nc), nc);
+        octave::err_del_index_out_of_range (false, idx_j.extent (nc), nc);
       else if (idx_j.is_cont_range (nc, lb, ub))
         {
           if (lb == 0 && ub == nc)
             {
               // Delete all rows and columns.
               *this = Sparse<T> (nr, 0);
             }
           else if (nz == 0)
@@ -1290,17 +1290,17 @@ Sparse<T>::delete_elements (const idx_ve
       else
         *this = index (idx_i, idx_j.complement (nc));
     }
   else if (idx_j.is_colon ())
     {
       // Deleting rows.
       octave_idx_type lb, ub;
       if (idx_i.extent (nr) > nr)
-        err_del_index_out_of_range (false, idx_i.extent (nr), nr);
+        octave::err_del_index_out_of_range (false, idx_i.extent (nr), nr);
       else if (idx_i.is_cont_range (nr, lb, ub))
         {
           if (lb == 0 && ub == nr)
             {
               // Delete all rows and columns.
               *this = Sparse<T> (0, nc);
             }
           else if (nz == 0)
@@ -1409,17 +1409,17 @@ Sparse<T>::index (const idx_vector& idx,
 
           retval.xcidx (0) = 0;
           retval.xcidx (1) = nz;
         }
     }
   else if (idx.extent (nel) > nel)
     {
       if (! resize_ok)
-        err_index_out_of_range (1, 1, idx.extent (nel), nel, dims ());
+        octave::err_index_out_of_range (1, 1, idx.extent (nel), nel, dims ());
 
       // resize_ok is completely handled here.
       octave_idx_type ext = idx.extent (nel);
       Sparse<T> tmp = *this;
       tmp.resize1 (ext);
       retval = tmp.index (idx);
     }
   else if (nr == 1 && nc == 1)
@@ -1597,19 +1597,19 @@ Sparse<T>::index (const idx_vector& idx_
         {
           octave_idx_type ext_i = idx_i.extent (nr);
           octave_idx_type ext_j = idx_j.extent (nc);
           Sparse<T> tmp = *this;
           tmp.resize (ext_i, ext_j);
           retval = tmp.index (idx_i, idx_j);
         }
       else if (idx_i.extent (nr) > nr)
-        err_index_out_of_range (2, 1, idx_i.extent (nr), nr, dims ());
+        octave::err_index_out_of_range (2, 1, idx_i.extent (nr), nr, dims ());
       else
-        err_index_out_of_range (2, 2, idx_j.extent (nc), nc, dims ());
+        octave::err_index_out_of_range (2, 2, idx_j.extent (nc), nc, dims ());
     }
   else if (nr == 1 && nc == 1)
     {
       // Scalars stored as sparse matrices occupy more memory than
       // a scalar, so let's just convert the matrix to full, index,
       // and sparsify the result.
 
       retval = Sparse<T> (array_value ().index (idx_i, idx_j));
@@ -1961,17 +1961,17 @@ Sparse<T>::assign (const idx_vector& idx
     {
       rhl = idx.length (n);
       if (rhs.nnz () != 0)
         assign (idx, Sparse<T> (rhl, 1, rhs.data (0)));
       else
         assign (idx, Sparse<T> (rhl, 1));
     }
   else
-    err_nonconformant ("=", dim_vector(idx.length (n),1), rhs.dims());
+    octave::err_nonconformant ("=", dim_vector(idx.length (n),1), rhs.dims());
 }
 
 template <typename T>
 void
 Sparse<T>::assign (const idx_vector& idx_i,
                    const idx_vector& idx_j, const Sparse<T>& rhs)
 {
   Sparse<T> retval;
@@ -2201,17 +2201,17 @@ Sparse<T>::assign (const idx_vector& idx
       else
         assign (idx_i, idx_j, Sparse<T> (n, m));
     }
   else if (idx_i.length (nr) == m && idx_j.length (nc) == n && (n==1 || m==1))
     {
       assign (idx_i, idx_j, rhs.transpose ());
     }
   else
-    err_nonconformant  ("=", idx_i.length (nr), idx_j.length (nc), n, m);
+    octave::err_nonconformant  ("=", idx_i.length (nr), idx_j.length (nc), n, m);
 }
 
 // Can't use versions of these in Array.cc due to duplication of the
 // instantiations for Array<double and Sparse<double>, etc
 template <typename T>
 bool
 sparse_ascending_compare (typename ref_param<T>::type a,
                           typename ref_param<T>::type b)
diff --git a/liboctave/array/dColVector.cc b/liboctave/array/dColVector.cc
--- a/liboctave/array/dColVector.cc
+++ b/liboctave/array/dColVector.cc
@@ -180,17 +180,17 @@ operator * (const Matrix& m, const Colum
   ColumnVector retval;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
-    err_nonconformant ("operator *", nr, nc, a_len, 1);
+    octave::err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   retval.clear (nr);
 
   if (nr != 0)
     {
       if (nc == 0)
         retval.fill (0.0);
       else
@@ -215,17 +215,17 @@ operator * (const DiagMatrix& m, const C
   ColumnVector retval;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
-    err_nonconformant ("operator *", nr, nc, a_len, 1);
+    octave::err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   if (nr == 0 || nc == 0)
     retval.resize (nr, 0.0);
   else
     {
       retval.resize (nr);
 
       for (octave_idx_type i = 0; i < a_len; i++)
diff --git a/liboctave/array/dDiagMatrix.cc b/liboctave/array/dDiagMatrix.cc
--- a/liboctave/array/dDiagMatrix.cc
+++ b/liboctave/array/dDiagMatrix.cc
@@ -282,17 +282,17 @@ operator * (const DiagMatrix& a, const D
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nr)
-    err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
+    octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   DiagMatrix c (a_nr, b_nc);
 
   octave_idx_type len = c.length ();
   octave_idx_type lenm = len < a_nc ? len : a_nc;
 
   for (octave_idx_type i = 0; i < lenm; i++)
     c.dgxelem (i) = a.dgelem (i) * b.dgelem (i);
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -1393,17 +1393,17 @@ Matrix::utsolve (MatrixType &mattype, co
 
           if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
             {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
-                warn_singular_matrix (rcon);
+                octave::warn_singular_matrix (rcon);
             }
         }
     }
 
   return retval;
 }
 
 Matrix
@@ -1482,17 +1482,17 @@ Matrix::ltsolve (MatrixType &mattype, co
 
           if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
             {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
-                warn_singular_matrix (rcon);
+                octave::warn_singular_matrix (rcon);
             }
         }
     }
 
   return retval;
 }
 
 Matrix
@@ -1562,17 +1562,17 @@ Matrix::fsolve (MatrixType &mattype, con
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        warn_singular_matrix (rcon);
+                        octave::warn_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   double *result = retval.fortran_vec ();
 
@@ -1615,17 +1615,17 @@ Matrix::fsolve (MatrixType &mattype, con
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
-                warn_singular_matrix ();
+                octave::warn_singular_matrix ();
 
               mattype.mark_as_rectangular ();
             }
           else
             {
               if (calc_cond)
                 {
                   // Now calculate the condition number for
@@ -1643,17 +1643,17 @@ Matrix::fsolve (MatrixType &mattype, con
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        warn_singular_matrix (rcon);
+                        octave::warn_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   double *result = retval.fortran_vec ();
 
@@ -2339,17 +2339,17 @@ Matrix::operator += (const DiagMatrix& a
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
-    err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
+    octave::err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) += a.elem (i, i);
 
   return *this;
 }
 
 Matrix&
@@ -2357,17 +2357,17 @@ Matrix::operator -= (const DiagMatrix& a
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
-    err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
+    octave::err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) -= a.elem (i, i);
 
   return *this;
 }
 
 // unary operations
@@ -2841,17 +2841,17 @@ xgemm (const Matrix& a, const Matrix& b,
 
   octave_idx_type a_nr = tra ? a.cols () : a.rows ();
   octave_idx_type a_nc = tra ? a.rows () : a.cols ();
 
   octave_idx_type b_nr = trb ? b.cols () : b.rows ();
   octave_idx_type b_nc = trb ? b.rows () : b.cols ();
 
   if (a_nc != b_nr)
-    err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
+    octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     retval = Matrix (a_nr, b_nc, 0.0);
   else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
     {
       octave_idx_type lda = a.rows ();
 
       retval = Matrix (a_nr, b_nc);
diff --git a/liboctave/array/dNDArray.cc b/liboctave/array/dNDArray.cc
--- a/liboctave/array/dNDArray.cc
+++ b/liboctave/array/dNDArray.cc
@@ -521,17 +521,17 @@ NDArray::ifourierNd (void) const
 #endif
 
 // unary operations
 
 boolNDArray
 NDArray::operator ! (void) const
 {
   if (any_element_is_nan ())
-    err_nan_to_logical_conversion ();
+    octave::err_nan_to_logical_conversion ();
 
   return do_mx_unary_op<bool, double> (*this, mx_inline_not);
 }
 
 bool
 NDArray::any_element_is_negative (bool neg_zero) const
 {
   return (neg_zero ? test_all (octave::math::negative_sign)
diff --git a/liboctave/array/dRowVector.cc b/liboctave/array/dRowVector.cc
--- a/liboctave/array/dRowVector.cc
+++ b/liboctave/array/dRowVector.cc
@@ -171,17 +171,17 @@ operator * (const RowVector& v, const Ma
   RowVector retval;
 
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != len)
-    err_nonconformant ("operator *", 1, len, a_nr, a_nc);
+    octave::err_nonconformant ("operator *", 1, len, a_nr, a_nc);
 
   if (len == 0)
     retval.resize (a_nc, 0.0);
   else
     {
       // Transpose A to form A'*x == (x'*A)'
 
       octave_idx_type ld = a_nr;
@@ -292,17 +292,17 @@ operator * (const RowVector& v, const Co
 {
   double retval = 0.0;
 
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
-    err_nonconformant ("operator *", len, a_len);
+    octave::err_nonconformant ("operator *", len, a_len);
 
   if (len != 0)
     F77_FUNC (xddot, XDDOT) (len, v.data (), 1, a.data (), 1, retval);
 
   return retval;
 }
 
 Complex
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -673,17 +673,17 @@ atan2 (const SparseMatrix& x, const Spar
 
   octave_idx_type x_nr = x.rows ();
   octave_idx_type x_nc = x.cols ();
 
   octave_idx_type y_nr = y.rows ();
   octave_idx_type y_nc = y.cols ();
 
   if (x_nr != y_nr || x_nc != y_nc)
-    err_nonconformant ("atan2", x_nr, x_nc, y_nr, y_nc);
+    octave::err_nonconformant ("atan2", x_nr, x_nc, y_nr, y_nc);
 
   SparseMatrix r;
 
   r = SparseMatrix (x_nr, x_nc, (x.nnz () + y.nnz ()));
 
   octave_idx_type jx = 0;
   r.cidx (0) = 0;
   for (octave_idx_type i = 0 ; i < x_nc ; i++)
@@ -1764,32 +1764,32 @@ SparseMatrix::utsolve (MatrixType &matty
       if (err != 0)
         {
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
       if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 SparseMatrix
 SparseMatrix::utsolve (MatrixType &mattype, const SparseMatrix& b,
@@ -2046,32 +2046,32 @@ SparseMatrix::utsolve (MatrixType &matty
       if (err != 0)
         {
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
       if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
     }
   return retval;
 }
 
 ComplexMatrix
 SparseMatrix::utsolve (MatrixType &mattype, const ComplexMatrix& b,
                        octave_idx_type& err, double& rcond,
@@ -2277,32 +2277,32 @@ SparseMatrix::utsolve (MatrixType &matty
       if (err != 0)
         {
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
       if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::utsolve (MatrixType &mattype, const SparseComplexMatrix& b,
@@ -2561,32 +2561,32 @@ SparseMatrix::utsolve (MatrixType &matty
       if (err != 0)
         {
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
       if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 Matrix
 SparseMatrix::ltsolve (MatrixType &mattype, const Matrix& b,
@@ -2814,32 +2814,32 @@ SparseMatrix::ltsolve (MatrixType &matty
       if (err != 0)
         {
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
       if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 SparseMatrix
 SparseMatrix::ltsolve (MatrixType &mattype, const SparseMatrix& b,
@@ -3114,32 +3114,32 @@ SparseMatrix::ltsolve (MatrixType &matty
       if (err != 0)
         {
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
       if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseMatrix::ltsolve (MatrixType &mattype, const ComplexMatrix& b,
@@ -3368,32 +3368,32 @@ SparseMatrix::ltsolve (MatrixType &matty
       if (err != 0)
         {
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
       if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::ltsolve (MatrixType &mattype, const SparseComplexMatrix& b,
@@ -3670,32 +3670,32 @@ SparseMatrix::ltsolve (MatrixType &matty
       if (err != 0)
         {
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
       if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
     }
 
   return retval;
 }
 
 Matrix
 SparseMatrix::trisolve (MatrixType &mattype, const Matrix& b,
@@ -3830,17 +3830,17 @@ SparseMatrix::trisolve (MatrixType &matt
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                warn_singular_matrix ();
+                octave::warn_singular_matrix ();
             }
           else
             rcond = 1.;
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -3927,17 +3927,17 @@ SparseMatrix::trisolve (MatrixType &matt
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                warn_singular_matrix ();
+                octave::warn_singular_matrix ();
             }
           else
             {
               rcond = 1.0;
               char job = 'N';
               volatile octave_idx_type x_nz = b.nnz ();
               octave_idx_type b_nc = b.cols ();
               retval = SparseMatrix (nr, b_nc, x_nz);
@@ -4130,17 +4130,17 @@ SparseMatrix::trisolve (MatrixType &matt
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                warn_singular_matrix ();
+                octave::warn_singular_matrix ();
             }
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -4225,17 +4225,17 @@ SparseMatrix::trisolve (MatrixType &matt
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                warn_singular_matrix ();
+                octave::warn_singular_matrix ();
             }
           else
             {
               rcond = 1.;
               char job = 'N';
               octave_idx_type b_nr = b.rows ();
               octave_idx_type b_nc = b.cols ();
               OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
@@ -4418,17 +4418,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        warn_singular_matrix (rcond);
+                        octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   retval = b;
@@ -4504,17 +4504,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                warn_singular_matrix ();
+                octave::warn_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
@@ -4537,17 +4537,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        warn_singular_matrix (rcond);
+                        octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   retval = b;
@@ -4662,17 +4662,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        warn_singular_matrix (rcond);
+                        octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
@@ -4781,17 +4781,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                warn_singular_matrix ();
+                octave::warn_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
@@ -4814,17 +4814,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        warn_singular_matrix (rcond);
+                        octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
@@ -4978,17 +4978,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        warn_singular_matrix (rcond);
+                        octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
@@ -5094,17 +5094,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                warn_singular_matrix ();
+                octave::warn_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
@@ -5127,17 +5127,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        warn_singular_matrix (rcond);
+                        octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
@@ -5275,17 +5275,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        warn_singular_matrix (rcond);
+                        octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
@@ -5421,17 +5421,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                warn_singular_matrix ();
+                octave::warn_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
@@ -5454,17 +5454,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        warn_singular_matrix (rcond);
+                        octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
@@ -5618,17 +5618,17 @@ SparseMatrix::factorize (octave_idx_type
         {
           UMFPACK_DNAME (report_numeric) (Numeric, control);
 
           err = -2;
 
           if (sing_handler)
             sing_handler (rcond);
           else
-            warn_singular_matrix (rcond);
+            octave::warn_singular_matrix (rcond);
         }
       else if (status < 0)
         {
           UMFPACK_DNAME (report_status) (control, status);
           UMFPACK_DNAME (report_info) (control, info);
 
           // FIXME: Should this be a warning?
           (*current_liboctave_error_handler)
@@ -5780,17 +5780,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    warn_singular_matrix (rcond);
+                    octave::warn_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -6013,17 +6013,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    warn_singular_matrix (rcond);
+                    octave::warn_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_sparse *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -6272,17 +6272,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    warn_singular_matrix (rcond);
+                    octave::warn_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -6523,17 +6523,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    warn_singular_matrix (rcond);
+                    octave::warn_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_sparse *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -7312,17 +7312,17 @@ SparseMatrix::too_large_for_float (void)
 {
   return test_any (xtoo_large_for_float);
 }
 
 SparseBoolMatrix
 SparseMatrix::operator ! (void) const
 {
   if (any_element_is_nan ())
-    err_nan_to_logical_conversion ();
+    octave::err_nan_to_logical_conversion ();
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nz1 = nnz ();
   octave_idx_type nz2 = nr*nc - nz1;
 
   SparseBoolMatrix r (nr, nc, nz2);
 
@@ -7716,17 +7716,17 @@ min (const SparseMatrix& a, const Sparse
     }
   else
     {
       if (a_nr == 0 || a_nc == 0)
         r.resize (a_nr, a_nc);
       else if (b_nr == 0 || b_nc == 0)
         r.resize (b_nr, b_nc);
       else
-        err_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
+        octave::err_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
     }
 
   return r;
 }
 
 SparseMatrix
 max (double d, const SparseMatrix& m)
 {
@@ -7866,17 +7866,17 @@ max (const SparseMatrix& a, const Sparse
     }
   else
     {
       if (a_nr == 0 || a_nc == 0)
         r.resize (a_nr, a_nc);
       else if (b_nr == 0 || b_nc == 0)
         r.resize (b_nr, b_nc);
       else
-        err_nonconformant ("max", a_nr, a_nc, b_nr, b_nc);
+        octave::err_nonconformant ("max", a_nr, a_nc, b_nr, b_nc);
     }
 
   return r;
 }
 
 SPARSE_SMS_CMP_OPS (SparseMatrix, 0.0, , double, 0.0, )
 SPARSE_SMS_BOOL_OPS (SparseMatrix, double, 0.0)
 
diff --git a/liboctave/array/fCColVector.cc b/liboctave/array/fCColVector.cc
--- a/liboctave/array/fCColVector.cc
+++ b/liboctave/array/fCColVector.cc
@@ -255,17 +255,17 @@ FloatComplexColumnVector::extract_n (oct
 FloatComplexColumnVector&
 FloatComplexColumnVector::operator += (const FloatColumnVector& a)
 {
   octave_idx_type len = numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
-    err_nonconformant ("operator +=", len, a_len);
+    octave::err_nonconformant ("operator +=", len, a_len);
 
   if (len == 0)
     return *this;
 
   FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
   mx_inline_add2 (len, d, a.data ());
   return *this;
@@ -274,17 +274,17 @@ FloatComplexColumnVector::operator += (c
 FloatComplexColumnVector&
 FloatComplexColumnVector::operator -= (const FloatColumnVector& a)
 {
   octave_idx_type len = numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
-    err_nonconformant ("operator -=", len, a_len);
+    octave::err_nonconformant ("operator -=", len, a_len);
 
   if (len == 0)
     return *this;
 
   FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
   mx_inline_sub2 (len, d, a.data ());
   return *this;
@@ -305,17 +305,17 @@ operator * (const FloatComplexMatrix& m,
   FloatComplexColumnVector retval;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
-    err_nonconformant ("operator *", nr, nc, a_len, 1);
+    octave::err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   retval.clear (nr);
 
   if (nr != 0)
     {
       if (nc == 0)
         retval.fill (0.0);
       else
@@ -347,17 +347,17 @@ FloatComplexColumnVector
 operator * (const FloatDiagMatrix& m, const FloatComplexColumnVector& a)
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
-    err_nonconformant ("operator *", nr, nc, a_len, 1);
+    octave::err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   if (nc == 0 || nr == 0)
     return FloatComplexColumnVector (0);
 
   FloatComplexColumnVector result (nr);
 
   for (octave_idx_type i = 0; i < a_len; i++)
     result.elem (i) = a.elem (i) * m.elem (i, i);
@@ -372,17 +372,17 @@ FloatComplexColumnVector
 operator * (const FloatComplexDiagMatrix& m, const FloatColumnVector& a)
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
-    err_nonconformant ("operator *", nr, nc, a_len, 1);
+    octave::err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   if (nc == 0 || nr == 0)
     return FloatComplexColumnVector (0);
 
   FloatComplexColumnVector result (nr);
 
   for (octave_idx_type i = 0; i < a_len; i++)
     result.elem (i) = a.elem (i) * m.elem (i, i);
@@ -397,17 +397,17 @@ FloatComplexColumnVector
 operator * (const FloatComplexDiagMatrix& m, const FloatComplexColumnVector& a)
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
-    err_nonconformant ("operator *", nr, nc, a_len, 1);
+    octave::err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   if (nc == 0 || nr == 0)
     return FloatComplexColumnVector (0);
 
   FloatComplexColumnVector result (nr);
 
   for (octave_idx_type i = 0; i < a_len; i++)
     result.elem (i) = a.elem (i) * m.elem (i, i);
diff --git a/liboctave/array/fCDiagMatrix.cc b/liboctave/array/fCDiagMatrix.cc
--- a/liboctave/array/fCDiagMatrix.cc
+++ b/liboctave/array/fCDiagMatrix.cc
@@ -369,17 +369,17 @@ FloatComplexDiagMatrix::operator += (con
 {
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (r != a_nr || c != a_nc)
-    err_nonconformant ("operator +=", r, c, a_nr, a_nc);
+    octave::err_nonconformant ("operator +=", r, c, a_nr, a_nc);
 
   if (r == 0 || c == 0)
     return *this;
 
   FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
   mx_inline_add2 (length (), d, a.data ());
   return *this;
@@ -390,17 +390,17 @@ operator * (const FloatComplexDiagMatrix
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nr)
-    err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
+    octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   FloatComplexDiagMatrix c (a_nr, b_nc);
 
   octave_idx_type len = c.length ();
   octave_idx_type lenm = len < a_nc ? len : a_nc;
 
   for (octave_idx_type i = 0; i < lenm; i++)
     c.dgxelem (i) = a.dgelem (i) * b.dgelem (i);
@@ -415,17 +415,17 @@ operator * (const FloatDiagMatrix& a, co
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nr)
-    err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
+    octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     return FloatComplexDiagMatrix (a_nr, a_nc, 0.0);
 
   FloatComplexDiagMatrix c (a_nr, b_nc);
 
   octave_idx_type len = a_nr < b_nc ? a_nr : b_nc;
 
@@ -445,17 +445,17 @@ operator * (const FloatComplexDiagMatrix
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nr)
-    err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
+    octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     return FloatComplexDiagMatrix (a_nr, a_nc, 0.0);
 
   FloatComplexDiagMatrix c (a_nr, b_nc);
 
   octave_idx_type len = a_nr < b_nc ? a_nr : b_nc;
 
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -1708,17 +1708,17 @@ FloatComplexMatrix::utsolve (MatrixType 
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        warn_singular_matrix (rcon);
+                        octave::warn_singular_matrix (rcon);
                     }
                 }
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -1802,17 +1802,17 @@ FloatComplexMatrix::ltsolve (MatrixType 
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        warn_singular_matrix (rcon);
+                        octave::warn_singular_matrix (rcon);
                     }
                 }
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -1887,17 +1887,17 @@ FloatComplexMatrix::fsolve (MatrixType &
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        warn_singular_matrix (rcon);
+                        octave::warn_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   FloatComplex *result = retval.fortran_vec ();
 
@@ -1947,17 +1947,17 @@ FloatComplexMatrix::fsolve (MatrixType &
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
-                warn_singular_matrix ();
+                octave::warn_singular_matrix ();
 
               mattype.mark_as_rectangular ();
             }
           else
             {
               if (calc_cond)
                 {
                   // Now calculate the condition number for
@@ -1975,17 +1975,17 @@ FloatComplexMatrix::fsolve (MatrixType &
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        warn_singular_matrix (rcon);
+                        octave::warn_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   FloatComplex *result = retval.fortran_vec ();
 
@@ -2720,17 +2720,17 @@ FloatComplexMatrix::operator += (const F
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = rows ();
   octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
-    err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
+    octave::err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) += a.elem (i, i);
 
   return *this;
 }
 
 FloatComplexMatrix&
@@ -2738,17 +2738,17 @@ FloatComplexMatrix::operator -= (const F
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = rows ();
   octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
-    err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
+    octave::err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) -= a.elem (i, i);
 
   return *this;
 }
 
 FloatComplexMatrix&
@@ -2756,17 +2756,17 @@ FloatComplexMatrix::operator += (const F
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = rows ();
   octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
-    err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
+    octave::err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) += a.elem (i, i);
 
   return *this;
 }
 
 FloatComplexMatrix&
@@ -2774,17 +2774,17 @@ FloatComplexMatrix::operator -= (const F
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = rows ();
   octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
-    err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
+    octave::err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) -= a.elem (i, i);
 
   return *this;
 }
 
 // matrix by matrix -> matrix operations
@@ -2794,17 +2794,17 @@ FloatComplexMatrix::operator += (const F
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
-    err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
+    octave::err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
 
   if (nr == 0 || nc == 0)
     return *this;
 
   FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
   mx_inline_add2 (numel (), d, a.data ());
   return *this;
@@ -2815,17 +2815,17 @@ FloatComplexMatrix::operator -= (const F
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
-    err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
+    octave::err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
 
   if (nr == 0 || nc == 0)
     return *this;
 
   FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
   mx_inline_sub2 (numel (), d, a.data ());
   return *this;
@@ -3411,17 +3411,17 @@ xgemm (const FloatComplexMatrix& a, cons
 
   octave_idx_type a_nr = tra ? a.cols () : a.rows ();
   octave_idx_type a_nc = tra ? a.rows () : a.cols ();
 
   octave_idx_type b_nr = trb ? b.cols () : b.rows ();
   octave_idx_type b_nc = trb ? b.rows () : b.cols ();
 
   if (a_nc != b_nr)
-    err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
+    octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     retval = FloatComplexMatrix (a_nr, b_nc, 0.0);
   else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
     {
       octave_idx_type lda = a.rows ();
 
       // FIXME: looking at the reference BLAS, it appears that it
diff --git a/liboctave/array/fCNDArray.cc b/liboctave/array/fCNDArray.cc
--- a/liboctave/array/fCNDArray.cc
+++ b/liboctave/array/fCNDArray.cc
@@ -480,17 +480,17 @@ FloatComplexNDArray::ifourierNd (void) c
 #endif
 
 // unary operations
 
 boolNDArray
 FloatComplexNDArray::operator ! (void) const
 {
   if (any_element_is_nan ())
-    err_nan_to_logical_conversion ();
+    octave::err_nan_to_logical_conversion ();
 
   return do_mx_unary_op<bool, FloatComplex> (*this, mx_inline_not);
 }
 
 // FIXME: this is not quite the right thing.
 
 bool
 FloatComplexNDArray::any_element_is_nan (void) const
diff --git a/liboctave/array/fCRowVector.cc b/liboctave/array/fCRowVector.cc
--- a/liboctave/array/fCRowVector.cc
+++ b/liboctave/array/fCRowVector.cc
@@ -241,17 +241,17 @@ FloatComplexRowVector::extract_n (octave
 FloatComplexRowVector&
 FloatComplexRowVector::operator += (const FloatRowVector& a)
 {
   octave_idx_type len = numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
-    err_nonconformant ("operator +=", len, a_len);
+    octave::err_nonconformant ("operator +=", len, a_len);
 
   if (len == 0)
     return *this;
 
   FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
   mx_inline_add2 (len, d, a.data ());
   return *this;
@@ -260,17 +260,17 @@ FloatComplexRowVector::operator += (cons
 FloatComplexRowVector&
 FloatComplexRowVector::operator -= (const FloatRowVector& a)
 {
   octave_idx_type len = numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
-    err_nonconformant ("operator -=", len, a_len);
+    octave::err_nonconformant ("operator -=", len, a_len);
 
   if (len == 0)
     return *this;
 
   FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
   mx_inline_sub2 (len, d, a.data ());
   return *this;
@@ -284,17 +284,17 @@ operator * (const FloatComplexRowVector&
   FloatComplexRowVector retval;
 
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != len)
-    err_nonconformant ("operator *", 1, len, a_nr, a_nc);
+    octave::err_nonconformant ("operator *", 1, len, a_nr, a_nc);
 
   if (len == 0)
     retval.resize (a_nc, 0.0);
   else
     {
       // Transpose A to form A'*x == (x'*A)'
 
       octave_idx_type ld = a_nr;
@@ -407,17 +407,17 @@ operator * (const FloatComplexRowVector&
 {
   FloatComplex retval (0.0, 0.0);
 
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
-    err_nonconformant ("operator *", len, a_len);
+    octave::err_nonconformant ("operator *", len, a_len);
 
   if (len != 0)
     F77_FUNC (xcdotu, XCDOTU) (len, F77_CONST_CMPLX_ARG (v.data ()), 1, F77_CONST_CMPLX_ARG (a.data ()), 1, F77_CMPLX_ARG (&retval));
 
   return retval;
 }
 
 // other operations
diff --git a/liboctave/array/fColVector.cc b/liboctave/array/fColVector.cc
--- a/liboctave/array/fColVector.cc
+++ b/liboctave/array/fColVector.cc
@@ -180,17 +180,17 @@ operator * (const FloatMatrix& m, const 
   FloatColumnVector retval;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
-    err_nonconformant ("operator *", nr, nc, a_len, 1);
+    octave::err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   retval.clear (nr);
 
   if (nr != 0)
     {
       if (nc == 0)
         retval.fill (0.0);
       else
@@ -215,17 +215,17 @@ operator * (const FloatDiagMatrix& m, co
   FloatColumnVector retval;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
-    err_nonconformant ("operator *", nr, nc, a_len, 1);
+    octave::err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   if (nr == 0 || nc == 0)
     retval.resize (nr, 0.0);
   else
     {
       retval.resize (nr);
 
       for (octave_idx_type i = 0; i < a_len; i++)
diff --git a/liboctave/array/fDiagMatrix.cc b/liboctave/array/fDiagMatrix.cc
--- a/liboctave/array/fDiagMatrix.cc
+++ b/liboctave/array/fDiagMatrix.cc
@@ -282,17 +282,17 @@ operator * (const FloatDiagMatrix& a, co
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nr)
-    err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
+    octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   FloatDiagMatrix c (a_nr, b_nc);
 
   octave_idx_type len = c.length ();
   octave_idx_type lenm = len < a_nc ? len : a_nc;
 
   for (octave_idx_type i = 0; i < lenm; i++)
     c.dgxelem (i) = a.dgelem (i) * b.dgelem (i);
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -1402,17 +1402,17 @@ FloatMatrix::utsolve (MatrixType &mattyp
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        warn_singular_matrix (rcon);
+                        octave::warn_singular_matrix (rcon);
                     }
                 }
 
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -1497,17 +1497,17 @@ FloatMatrix::ltsolve (MatrixType &mattyp
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        warn_singular_matrix (rcon);
+                        octave::warn_singular_matrix (rcon);
                     }
                 }
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -1582,17 +1582,17 @@ FloatMatrix::fsolve (MatrixType &mattype
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        warn_singular_matrix (rcon);
+                        octave::warn_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   float *result = retval.fortran_vec ();
 
@@ -1635,17 +1635,17 @@ FloatMatrix::fsolve (MatrixType &mattype
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
-                warn_singular_matrix ();
+                octave::warn_singular_matrix ();
 
               mattype.mark_as_rectangular ();
             }
           else
             {
               if (calc_cond)
                 {
                   // Now calculate the condition number for
@@ -1663,17 +1663,17 @@ FloatMatrix::fsolve (MatrixType &mattype
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        warn_singular_matrix (rcon);
+                        octave::warn_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   float *result = retval.fortran_vec ();
 
@@ -2369,17 +2369,17 @@ FloatMatrix::operator += (const FloatDia
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
-    err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
+    octave::err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) += a.elem (i, i);
 
   return *this;
 }
 
 FloatMatrix&
@@ -2387,17 +2387,17 @@ FloatMatrix::operator -= (const FloatDia
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
-    err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
+    octave::err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) -= a.elem (i, i);
 
   return *this;
 }
 
 // column vector by row vector -> matrix operations
@@ -2851,17 +2851,17 @@ xgemm (const FloatMatrix& a, const Float
 
   octave_idx_type a_nr = tra ? a.cols () : a.rows ();
   octave_idx_type a_nc = tra ? a.rows () : a.cols ();
 
   octave_idx_type b_nr = trb ? b.cols () : b.rows ();
   octave_idx_type b_nc = trb ? b.rows () : b.cols ();
 
   if (a_nc != b_nr)
-    err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
+    octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     retval = FloatMatrix (a_nr, b_nc, 0.0);
   else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
     {
       octave_idx_type lda = a.rows ();
 
       retval = FloatMatrix (a_nr, b_nc);
diff --git a/liboctave/array/fNDArray.cc b/liboctave/array/fNDArray.cc
--- a/liboctave/array/fNDArray.cc
+++ b/liboctave/array/fNDArray.cc
@@ -479,17 +479,17 @@ FloatNDArray::ifourierNd (void) const
 #endif
 
 // unary operations
 
 boolNDArray
 FloatNDArray::operator ! (void) const
 {
   if (any_element_is_nan ())
-    err_nan_to_logical_conversion ();
+    octave::err_nan_to_logical_conversion ();
 
   return do_mx_unary_op<bool, float> (*this, mx_inline_not);
 }
 
 bool
 FloatNDArray::any_element_is_negative (bool neg_zero) const
 {
   return (neg_zero ? test_all (octave::math::negative_sign)
diff --git a/liboctave/array/fRowVector.cc b/liboctave/array/fRowVector.cc
--- a/liboctave/array/fRowVector.cc
+++ b/liboctave/array/fRowVector.cc
@@ -171,17 +171,17 @@ operator * (const FloatRowVector& v, con
   FloatRowVector retval;
 
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != len)
-    err_nonconformant ("operator *", 1, len, a_nr, a_nc);
+    octave::err_nonconformant ("operator *", 1, len, a_nr, a_nc);
 
   if (len == 0)
     retval.resize (a_nc, 0.0);
   else
     {
       // Transpose A to form A'*x == (x'*A)'
 
       octave_idx_type ld = a_nr;
@@ -292,17 +292,17 @@ operator * (const FloatRowVector& v, con
 {
   float retval = 0.0;
 
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
-    err_nonconformant ("operator *", len, a_len);
+    octave::err_nonconformant ("operator *", len, a_len);
 
   if (len != 0)
     F77_FUNC (xsdot, XSDOT) (len, v.data (), 1, a.data (), 1, retval);
 
   return retval;
 }
 
 FloatComplex
diff --git a/liboctave/array/idx-vector.cc b/liboctave/array/idx-vector.cc
--- a/liboctave/array/idx-vector.cc
+++ b/liboctave/array/idx-vector.cc
@@ -115,44 +115,44 @@ idx_vector::idx_colon_rep::print (std::o
 idx_vector::idx_range_rep::idx_range_rep (octave_idx_type _start,
                                           octave_idx_type _limit,
                                           octave_idx_type _step)
   : start(_start), len (_step ? std::max ((_limit - _start) / _step, static_cast<octave_idx_type> (0)) : -1), step (_step)
 {
   if (len < 0)
     err_invalid_range ();
   if (start < 0)
-    err_invalid_index (start);
+    octave::err_invalid_index (start);
   if (step < 0 && start + (len-1)*step < 0)
-    err_invalid_index (start + (len-1)*step);
+    octave::err_invalid_index (start + (len-1)*step);
 }
 
 idx_vector::idx_range_rep::idx_range_rep (const Range& r)
   : start (0), len (r.numel ()), step (1)
 {
   if (len < 0)
     err_invalid_range ();
 
   if (len > 0)
     {
       if (r.all_elements_are_ints ())
         {
           start = static_cast<octave_idx_type> (r.base ()) - 1;
           step = static_cast<octave_idx_type> (r.inc ());
           if (start < 0)
-            err_invalid_index (start);
+            octave::err_invalid_index (start);
           if (step < 0 && start + (len - 1)*step < 0)
-            err_invalid_index (start + (len - 1)*step);
+            octave::err_invalid_index (start + (len - 1)*step);
         }
       else
         {
           // find first non-integer, then gripe about it
           double b = r.base ();
           double inc = r.inc ();
-          err_invalid_index (b != std::floor (b) ? b : b + inc);
+          octave::err_invalid_index (b != std::floor (b) ? b : b + inc);
         }
     }
 }
 
 octave_idx_type
 idx_vector::idx_range_rep::checkelem (octave_idx_type i) const
 {
   if (i < 0 || i >= len)
@@ -217,31 +217,31 @@ idx_vector::idx_range_rep::as_array (voi
   return retval;
 }
 
 inline octave_idx_type
 convert_index (octave_idx_type i, bool& conv_error,
                octave_idx_type& ext)
 {
   if (i <= 0 && ! conv_error)
-    err_invalid_index (i-1);
+    octave::err_invalid_index (i-1);
 
   if (ext < i)
     ext = i;
 
   return i - 1;
 }
 
 inline octave_idx_type
 convert_index (double x, bool& conv_error, octave_idx_type& ext)
 {
   octave_idx_type i = static_cast<octave_idx_type> (x);
 
   if (static_cast<double> (i) != x)
-    err_invalid_index (x-1);
+    octave::err_invalid_index (x-1);
 
   return convert_index (i, conv_error, ext);
 }
 
 inline octave_idx_type
 convert_index (float x, bool& conv_error, octave_idx_type& ext)
 {
   return convert_index (static_cast<double> (x), conv_error, ext);
@@ -265,17 +265,17 @@ idx_vector::idx_scalar_rep::idx_scalar_r
 
   data = convert_index (x, err, dummy);
 }
 
 idx_vector::idx_scalar_rep::idx_scalar_rep (octave_idx_type i)
   : data (i)
 {
   if (data < 0)
-    err_invalid_index (data);
+    octave::err_invalid_index (data);
 }
 
 octave_idx_type
 idx_vector::idx_scalar_rep::checkelem (octave_idx_type i) const
 {
   if (i != 0)
     err_index_out_of_range ();
 
@@ -333,17 +333,17 @@ idx_vector::idx_vector_rep::idx_vector_r
     {
       octave_idx_type max = -1;
       for (octave_idx_type i = 0; i < len; i++)
         {
           octave_idx_type k = inda.xelem (i);
           if (k < 0)
             {
               if (! err)
-                err_invalid_index (k);
+                octave::err_invalid_index (k);
             }
           else if (k > max)
             max = k;
         }
 
       ext = max + 1;
     }
 }
@@ -442,17 +442,17 @@ idx_vector::idx_vector_rep::~idx_vector_
   else
     delete [] data;
 }
 
 octave_idx_type
 idx_vector::idx_vector_rep::checkelem (octave_idx_type n) const
 {
   if (n < 0 || n >= len)
-    err_invalid_index (n);
+    octave::err_invalid_index (n);
 
   return xelem (n);
 }
 
 idx_vector::idx_base_rep *
 idx_vector::idx_vector_rep::sort_uniq_clone (bool uniq)
 {
   if (len == 0)
@@ -690,17 +690,17 @@ idx_vector::idx_mask_rep::xelem (octave_
     }
   return lste;
 }
 
 octave_idx_type
 idx_vector::idx_mask_rep::checkelem (octave_idx_type n) const
 {
   if (n < 0 || n >= len)
-    err_invalid_index (n);
+    octave::err_invalid_index (n);
 
   return xelem (n);
 }
 
 std::ostream&
 idx_vector::idx_mask_rep::print (std::ostream& os) const
 {
   os << '[';
diff --git a/liboctave/cruft/misc/quit.cc b/liboctave/cruft/misc/quit.cc
--- a/liboctave/cruft/misc/quit.cc
+++ b/liboctave/cruft/misc/quit.cc
@@ -48,36 +48,36 @@ octave_handle_signal (void)
     }
 }
 
 extern OCTAVE_API void
 clean_up_and_exit (int exit_status, bool safe_to_return)
 {
   octave_exception_state = octave_quit_exception;
 
-  throw octave_exit_exception (exit_status, safe_to_return);
+  throw octave::exit_exception (exit_status, safe_to_return);
 }
 
 void
 octave_throw_interrupt_exception (void)
 {
   if (octave_interrupt_hook)
     octave_interrupt_hook ();
 
-  throw octave_interrupt_exception ();
+  throw octave::interrupt_exception ();
 }
 
 void
 octave_throw_execution_exception (void)
 {
   // FIXME: would a hook function be useful here?
 
   octave_exception_state = octave_exec_exception;
 
-  throw octave_execution_exception ();
+  throw octave::execution_exception ();
 }
 
 void
 octave_throw_bad_alloc (void)
 {
   if (octave_bad_alloc_hook)
     octave_bad_alloc_hook ();
 
diff --git a/liboctave/cruft/misc/quit.h b/liboctave/cruft/misc/quit.h
--- a/liboctave/cruft/misc/quit.h
+++ b/liboctave/cruft/misc/quit.h
@@ -55,97 +55,109 @@ OCTAVE_API extern octave_jmp_buf current
 OCTAVE_API extern void octave_save_current_context (void *);
 
 OCTAVE_API extern void octave_restore_current_context (void *);
 
 OCTAVE_NORETURN OCTAVE_API extern void octave_jump_to_enclosing_context (void);
 
 #if defined (__cplusplus)
 
-class
-octave_execution_exception
+namespace octave
 {
-public:
+  class
+  execution_exception
+  {
+  public:
 
-  octave_execution_exception (void) : m_stack_trace () { }
-
-  octave_execution_exception (const octave_execution_exception& x)
-    : m_stack_trace (x.m_stack_trace) { }
+    execution_exception (void) : m_stack_trace () { }
 
-  octave_execution_exception& operator = (const octave_execution_exception& x)
-  {
-    if (&x != this)
-      m_stack_trace = x.m_stack_trace;
+    execution_exception (const execution_exception& x)
+      : m_stack_trace (x.m_stack_trace) { }
 
-    return *this;
-  }
+    execution_exception& operator = (const execution_exception& x)
+    {
+      if (&x != this)
+        m_stack_trace = x.m_stack_trace;
 
-  ~octave_execution_exception (void) { }
+      return *this;
+    }
+
+    ~execution_exception (void) { }
 
-  virtual void set_stack_trace (const std::string& st)
-  {
-    m_stack_trace = st;
-  }
+    virtual void set_stack_trace (const std::string& st)
+    {
+      m_stack_trace = st;
+    }
 
-  virtual void set_stack_trace (void)
-  {
-    m_stack_trace = "";
-  }
+    virtual void set_stack_trace (void)
+    {
+      m_stack_trace = "";
+    }
 
-  virtual std::string info (void) const
-  {
-    return m_stack_trace;
-  }
+    virtual std::string info (void) const
+    {
+      return m_stack_trace;
+    }
+
+  private:
 
-private:
+    std::string m_stack_trace;
+  };
 
-  std::string m_stack_trace;
-};
+  class
+  exit_exception
+  {
+  public:
 
-class
-octave_exit_exception
-{
-public:
+    exit_exception (int exit_status = 0, bool safe_to_return = false)
+      : m_exit_status (exit_status), m_safe_to_return (safe_to_return)
+    { }
 
-  octave_exit_exception (int exit_status = 0, bool safe_to_return = false)
-    : m_exit_status (exit_status), m_safe_to_return (safe_to_return)
-  { }
+    exit_exception (const exit_exception& ex)
+      : m_exit_status (ex.m_exit_status), m_safe_to_return (ex.m_safe_to_return)
+    { }
 
-  octave_exit_exception (const octave_exit_exception& ex)
-    : m_exit_status (ex.m_exit_status), m_safe_to_return (ex.m_safe_to_return)
-  { }
+    exit_exception& operator = (exit_exception& ex)
+    {
+      if (this != &ex)
+        {
+          m_exit_status = ex.m_exit_status;
+          m_safe_to_return = ex.m_safe_to_return;
+        }
 
-  octave_exit_exception& operator = (octave_exit_exception& ex)
-  {
-    if (this != &ex)
-      {
-        m_exit_status = ex.m_exit_status;
-        m_safe_to_return = ex.m_safe_to_return;
-      }
+      return *this;
+    }
+
+    ~exit_exception (void) { }
+
+    int exit_status (void) const { return m_exit_status; }
 
-    return *this;
-  }
+    bool safe_to_return (void) const { return m_safe_to_return; }
+
+  private:
 
-  ~octave_exit_exception (void) { }
+    int m_exit_status;
 
-  int exit_status (void) const { return m_exit_status; }
-
-  bool safe_to_return (void) const { return m_safe_to_return; }
+    bool m_safe_to_return;
+  };
 
-private:
-
-  int m_exit_status;
+  class
+  interrupt_exception
+  {
+  };
+}
 
-  bool m_safe_to_return;
-};
+OCTAVE_DEPRECATED ("use 'octave::execution_exception' instead")
+typedef octave::exit_exception octave_execution_exception;
 
-class
-octave_interrupt_exception
-{
-};
+OCTAVE_DEPRECATED ("use 'octave::exit_exception' instead")
+typedef octave::exit_exception octave_exit_exception;
+
+OCTAVE_DEPRECATED ("use 'octave::interrupt_exception' instead")
+typedef octave::interrupt_exception octave_interrupt_exception;
 
 #endif
 
 enum octave_exception
 {
   octave_no_exception = 0,
   octave_exec_exception = 1,
   octave_alloc_exception = 3,
@@ -260,34 +272,34 @@ inline void octave_quit (void)
   sig_atomic_t saved_octave_interrupt_immediately = octave_interrupt_immediately; \
                                                                         \
   try                                                                   \
     {                                                                   \
       octave_interrupt_immediately = 0;
 
 #define END_INTERRUPT_WITH_EXCEPTIONS                                   \
     }                                                                   \
-  catch (const octave_interrupt_exception&)                             \
+  catch (const octave::interrupt_exception&)                            \
     {                                                                   \
       octave_interrupt_immediately = saved_octave_interrupt_immediately; \
       octave_jump_to_enclosing_context ();                              \
     }                                                                   \
-  catch (const octave_execution_exception&)                             \
+  catch (const octave::execution_exception&)                            \
     {                                                                   \
       octave_interrupt_immediately = saved_octave_interrupt_immediately; \
       octave_exception_state = octave_exec_exception;                   \
       octave_jump_to_enclosing_context ();                              \
     }                                                                   \
   catch (const std::bad_alloc&)                                         \
     {                                                                   \
       octave_interrupt_immediately = saved_octave_interrupt_immediately; \
       octave_exception_state = octave_alloc_exception;                  \
       octave_jump_to_enclosing_context ();                              \
     }                                                                   \
-  catch (const octave_exit_exception& ex)                               \
+  catch (const octave::exit_exception& ex)                              \
     {                                                                   \
       octave_interrupt_immediately = saved_octave_interrupt_immediately; \
       octave_exception_state = octave_quit_exception;                   \
       octave_exit_exception_status = ex.exit_status ();                 \
       octave_exit_exception_safe_to_return = ex.safe_to_return ();      \
       octave_jump_to_enclosing_context ();                              \
     }                                                                   \
                                                                         \
diff --git a/liboctave/numeric/gepbalance.cc b/liboctave/numeric/gepbalance.cc
--- a/liboctave/numeric/gepbalance.cc
+++ b/liboctave/numeric/gepbalance.cc
@@ -47,17 +47,17 @@ gepbalance<Matrix>::init (const Matrix& 
                           const std::string& balance_job)
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     (*current_liboctave_error_handler) ("GEPBALANCE requires square matrix");
 
   if (a.dims () != b.dims ())
-    err_nonconformant ("GEPBALANCE", n, n, b.rows(), b.cols());
+    octave::err_nonconformant ("GEPBALANCE", n, n, b.rows(), b.cols());
 
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
 
   OCTAVE_LOCAL_BUFFER (double, plscale, n);
   OCTAVE_LOCAL_BUFFER (double, prscale, n);
   OCTAVE_LOCAL_BUFFER (double, pwork, 6 * n);
@@ -112,17 +112,17 @@ gepbalance<FloatMatrix>::init (const Flo
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     (*current_liboctave_error_handler)
       ("FloatGEPBALANCE requires square matrix");
 
   if (a.dims () != b.dims ())
-    err_nonconformant ("FloatGEPBALANCE", n, n, b.rows(), b.cols());
+    octave::err_nonconformant ("FloatGEPBALANCE", n, n, b.rows(), b.cols());
 
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
 
   OCTAVE_LOCAL_BUFFER (float, plscale, n);
   OCTAVE_LOCAL_BUFFER (float, prscale, n);
   OCTAVE_LOCAL_BUFFER (float, pwork, 6 * n);
@@ -178,17 +178,17 @@ gepbalance<ComplexMatrix>::init (const C
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     (*current_liboctave_error_handler)
       ("ComplexGEPBALANCE requires square matrix");
 
   if (a.dims () != b.dims ())
-    err_nonconformant ("ComplexGEPBALANCE", n, n, b.rows(), b.cols());
+    octave::err_nonconformant ("ComplexGEPBALANCE", n, n, b.rows(), b.cols());
 
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
 
   OCTAVE_LOCAL_BUFFER (double, plscale, n);
   OCTAVE_LOCAL_BUFFER (double, prscale,  n);
   OCTAVE_LOCAL_BUFFER (double, pwork, 6 * n);
@@ -247,17 +247,17 @@ gepbalance<FloatComplexMatrix>::init (co
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler)
         ("FloatComplexGEPBALANCE requires square matrix");
       return -1;
     }
 
   if (a.dims () != b.dims ())
-    err_nonconformant ("FloatComplexGEPBALANCE", n, n, b.rows(), b.cols());
+    octave::err_nonconformant ("FloatComplexGEPBALANCE", n, n, b.rows(), b.cols());
 
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
 
   OCTAVE_LOCAL_BUFFER (float, plscale, n);
   OCTAVE_LOCAL_BUFFER (float, prscale, n);
   OCTAVE_LOCAL_BUFFER (float, pwork, 6 * n);
diff --git a/liboctave/operators/Sparse-diag-op-defs.h b/liboctave/operators/Sparse-diag-op-defs.h
--- a/liboctave/operators/Sparse-diag-op-defs.h
+++ b/liboctave/operators/Sparse-diag-op-defs.h
@@ -32,17 +32,17 @@ RT do_mul_dm_sm (const DM& d, const SM& 
 {
   const octave_idx_type nr = d.rows ();
   const octave_idx_type nc = d.cols ();
 
   const octave_idx_type a_nr = a.rows ();
   const octave_idx_type a_nc = a.cols ();
 
   if (nc != a_nr)
-    err_nonconformant ("operator *", nr, nc, a_nr, a_nc);
+    octave::err_nonconformant ("operator *", nr, nc, a_nr, a_nc);
 
   RT r (nr, a_nc, a.nnz ());
 
   octave_idx_type l = 0;
 
   for (octave_idx_type j = 0; j < a_nc; j++)
     {
       r.xcidx (j) = l;
@@ -68,17 +68,17 @@ RT do_mul_sm_dm (const SM& a, const DM& 
 {
   const octave_idx_type nr = d.rows ();
   const octave_idx_type nc = d.cols ();
 
   const octave_idx_type a_nr = a.rows ();
   const octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nc)
-    err_nonconformant ("operator *", a_nr, a_nc, nr, nc);
+    octave::err_nonconformant ("operator *", a_nr, a_nc, nr, nc);
 
   const octave_idx_type mnc = nc < a_nc ? nc: a_nc;
   RT r (a_nr, nc, a.cidx (mnc));
 
   for (octave_idx_type j = 0; j < mnc; ++j)
     {
       const typename DM::element_type s = d.dgelem (j);
       const octave_idx_type colend = a.cidx (j+1);
@@ -172,44 +172,44 @@ RT do_commutative_add_dm_sm (const DM& d
                                  identity_val<typename SM::element_type> (),
                                  identity_val<typename DM::element_type> ());
 }
 
 template <typename RT, typename DM, typename SM>
 RT do_add_dm_sm (const DM& d, const SM& a)
 {
   if (a.rows () != d.rows () || a.cols () != d.cols ())
-    err_nonconformant ("operator +", d.rows (), d.cols (), a.rows (), a.cols ());
+    octave::err_nonconformant ("operator +", d.rows (), d.cols (), a.rows (), a.cols ());
   else
     return do_commutative_add_dm_sm<RT> (d, a);
 }
 
 template <typename RT, typename DM, typename SM>
 RT do_sub_dm_sm (const DM& d, const SM& a)
 {
   if (a.rows () != d.rows () || a.cols () != d.cols ())
-    err_nonconformant ("operator -", d.rows (), d.cols (), a.rows (), a.cols ());
+    octave::err_nonconformant ("operator -", d.rows (), d.cols (), a.rows (), a.cols ());
 
   return inner_do_add_sm_dm<RT> (a, d, std::negate<typename SM::element_type> (),
                                  identity_val<typename DM::element_type> ());
 }
 
 template <typename RT, typename SM, typename DM>
 RT do_add_sm_dm (const SM& a, const DM& d)
 {
   if (a.rows () != d.rows () || a.cols () != d.cols ())
-    err_nonconformant ("operator +", a.rows (), a.cols (), d.rows (), d.cols ());
+    octave::err_nonconformant ("operator +", a.rows (), a.cols (), d.rows (), d.cols ());
 
   return do_commutative_add_dm_sm<RT> (d, a);
 }
 
 template <typename RT, typename SM, typename DM>
 RT do_sub_sm_dm (const SM& a, const DM& d)
 {
   if (a.rows () != d.rows () || a.cols () != d.cols ())
-    err_nonconformant ("operator -", a.rows (), a.cols (), d.rows (), d.cols ());
+    octave::err_nonconformant ("operator -", a.rows (), a.cols (), d.rows (), d.cols ());
 
   return inner_do_add_sm_dm<RT> (a, d,
                                  identity_val<typename SM::element_type> (),
                                  std::negate<typename DM::element_type> ());
 }
 
 #endif
diff --git a/liboctave/operators/Sparse-op-defs.h b/liboctave/operators/Sparse-op-defs.h
--- a/liboctave/operators/Sparse-op-defs.h
+++ b/liboctave/operators/Sparse-op-defs.h
@@ -366,17 +366,17 @@ along with Octave; see the file COPYING.
                     octave_quit ();                                     \
                     r.data (idxj + m1.ridx (i)) = m1.data (i) OP m2.data (0); \
                   }                                                     \
               }                                                         \
             r.maybe_compress ();                                        \
           }                                                             \
       }                                                                 \
     else if (m1_nr != m2_nr || m1_nc != m2_nc)                          \
-      err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);               \
+      octave::err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);               \
     else                                                                \
       {                                                                 \
         r = R (m1_nr, m1_nc, (m1.nnz () + m2.nnz ()));                  \
                                                                         \
         octave_idx_type jx = 0;                                         \
         r.cidx (0) = 0;                                                 \
         for (octave_idx_type i = 0 ; i < m1_nc ; i++)                   \
           {                                                             \
@@ -474,17 +474,17 @@ along with Octave; see the file COPYING.
               {                                                         \
                 octave_quit ();                                         \
                 r.data (i) = r.data (i) OP m2.data (0);                 \
               }                                                         \
             r.maybe_compress ();                                        \
           }                                                             \
       }                                                                 \
     else if (m1_nr != m2_nr || m1_nc != m2_nc)                          \
-      err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);               \
+      octave::err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);               \
     else                                                                \
       {                                                                 \
         r = R (m1_nr, m1_nc, (m1.nnz () > m2.nnz () ? m1.nnz () : m2.nnz ())); \
                                                                         \
         octave_idx_type jx = 0;                                         \
         r.cidx (0) = 0;                                                 \
         for (octave_idx_type i = 0 ; i < m1_nc ; i++)                   \
           {                                                             \
@@ -590,17 +590,17 @@ along with Octave; see the file COPYING.
                     octave_quit ();                                     \
                     r.data (idxj + m1.ridx (i)) = m1.data (i) OP m2.elem (0,0); \
                   }                                                     \
               }                                                         \
             r.maybe_compress ();                                        \
           }                                                             \
       }                                                                 \
     else if (m1_nr != m2_nr || m1_nc != m2_nc)                          \
-      err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);               \
+      octave::err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);               \
     else                                                                \
       {                                                                 \
                                                                         \
         /* FIXME: Kludge... Always double/Complex, so Complex () */     \
         r = R (m1_nr, m1_nc, (Complex () OP Complex ()));               \
                                                                         \
         for (octave_idx_type i = 0 ; i < m1_nc ; i++)                   \
           {                                                             \
@@ -813,17 +813,17 @@ along with Octave; see the file COPYING.
                   }                                                     \
                 r.maybe_compress (false);                               \
               }                                                         \
           }                                                             \
       }                                                                 \
     else                                                                \
       {                                                                 \
         if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0))   \
-          err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);           \
+          octave::err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);           \
       }                                                                 \
     return r;                                                           \
   }
 
 #define SPARSE_SMSM_CMP_OPS(M1, Z1, C1, M2, Z2, C2)             \
   SPARSE_SMSM_CMP_OP (mx_el_lt, <,  M1, Z1,   , M2, Z2,   )     \
   SPARSE_SMSM_CMP_OP (mx_el_le, <=, M1, Z1,   , M2, Z2,   )     \
   SPARSE_SMSM_CMP_OP (mx_el_ge, >=, M1, Z1,   , M2, Z2,   )     \
@@ -961,17 +961,17 @@ along with Octave; see the file COPYING.
                 r.cidx (j + 1) = nel;                                   \
               }                                                         \
             r.maybe_compress (false);                                   \
           }                                                             \
       }                                                                 \
     else                                                                \
       {                                                                 \
         if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0))   \
-          err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);           \
+          octave::err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);           \
       }                                                                 \
     return r;                                                           \
   }
 
 #define SPARSE_SMSM_BOOL_OPS2(M1, M2, LHS_ZERO, RHS_ZERO)               \
   SPARSE_SMSM_BOOL_OP (mx_el_and, &&, M1, M2, LHS_ZERO, RHS_ZERO)       \
   SPARSE_SMSM_BOOL_OP (mx_el_or,  ||, M1, M2, LHS_ZERO, RHS_ZERO)
 
@@ -990,17 +990,17 @@ along with Octave; see the file COPYING.
     octave_idx_type m1_nc = m1.cols ();                         \
                                                                 \
     octave_idx_type m2_nr = m2.rows ();                         \
     octave_idx_type m2_nc = m2.cols ();                         \
                                                                 \
     if (m2_nr == 1 && m2_nc == 1)                               \
       r = R (m1 OP m2.elem (0,0));                              \
     else if (m1_nr != m2_nr || m1_nc != m2_nc)                  \
-      err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);       \
+      octave::err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);       \
     else                                                        \
       {                                                         \
         r = R (F (m1, m2.matrix_value ()));                     \
       }                                                         \
     return r;                                                   \
   }
 
 #define SPARSE_MSM_BIN_OP_2(R, F, OP, M1, M2)                           \
@@ -1013,17 +1013,17 @@ along with Octave; see the file COPYING.
     octave_idx_type m1_nc = m1.cols ();                                 \
                                                                         \
     octave_idx_type m2_nr = m2.rows ();                                 \
     octave_idx_type m2_nc = m2.cols ();                                 \
                                                                         \
     if (m2_nr == 1 && m2_nc == 1)                                       \
       r = R (m1 OP m2.elem (0,0));                                      \
     else if (m1_nr != m2_nr || m1_nc != m2_nc)                          \
-      err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);               \
+      octave::err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);               \
     else                                                                \
       {                                                                 \
         if (do_mx_check (m1, mx_inline_all_finite<M1::element_type>))   \
           {                                                             \
             /* Sparsity pattern is preserved. */                        \
             octave_idx_type m2_nz = m2.nnz ();                          \
             r = R (m2_nr, m2_nc, m2_nz);                                \
             for (octave_idx_type j = 0, k = 0; j < m2_nc; j++)          \
@@ -1101,17 +1101,17 @@ along with Octave; see the file COPYING.
                   }                                                     \
                 r.cidx (j+1) = ii;                                      \
               }                                                         \
           }                                                             \
       }                                                                 \
     else                                                                \
       {                                                                 \
         if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0))   \
-          err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);           \
+          octave::err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);           \
       }                                                                 \
     return r;                                                           \
   }
 
 #define SPARSE_MSM_CMP_OPS(M1, Z1, C1, M2, Z2, C2)      \
   SPARSE_MSM_CMP_OP (mx_el_lt, <,  M1,   , M2,   )      \
   SPARSE_MSM_CMP_OP (mx_el_le, <=, M1,   , M2,   )      \
   SPARSE_MSM_CMP_OP (mx_el_ge, >=, M1,   , M2,   )      \
@@ -1167,17 +1167,17 @@ along with Octave; see the file COPYING.
                   }                                                     \
                 r.cidx (j+1) = ii;                                      \
               }                                                         \
           }                                                             \
       }                                                                 \
     else                                                                \
       {                                                                 \
         if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0))   \
-          err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);           \
+          octave::err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);           \
       }                                                                 \
     return r;                                                           \
   }
 
 #define SPARSE_MSM_BOOL_OPS2(M1, M2, LHS_ZERO, RHS_ZERO)                \
   SPARSE_MSM_BOOL_OP (mx_el_and, &&, M1, M2, LHS_ZERO, RHS_ZERO)        \
   SPARSE_MSM_BOOL_OP (mx_el_or,  ||, M1, M2, LHS_ZERO, RHS_ZERO)
 
@@ -1196,17 +1196,17 @@ along with Octave; see the file COPYING.
     octave_idx_type m1_nc = m1.cols ();                         \
                                                                 \
     octave_idx_type m2_nr = m2.rows ();                         \
     octave_idx_type m2_nc = m2.cols ();                         \
                                                                 \
     if (m1_nr == 1 && m1_nc == 1)                               \
       r = R (m1.elem (0,0) OP m2);                              \
     else if (m1_nr != m2_nr || m1_nc != m2_nc)                  \
-      err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);       \
+      octave::err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);       \
     else                                                        \
       {                                                         \
         r = R (m1.matrix_value () OP m2);                       \
       }                                                         \
     return r;                                                   \
   }
 
 // sm .* m preserves sparsity if m contains no Infs nor Nans.
@@ -1227,17 +1227,17 @@ along with Octave; see the file COPYING.
     octave_idx_type m1_nc = m1.cols ();                                 \
                                                                         \
     octave_idx_type m2_nr = m2.rows ();                                 \
     octave_idx_type m2_nc = m2.cols ();                                 \
                                                                         \
     if (m1_nr == 1 && m1_nc == 1)                                       \
       r = R (m1.elem (0,0) OP m2);                                      \
     else if (m1_nr != m2_nr || m1_nc != m2_nc)                          \
-      err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);               \
+      octave::err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);               \
     else                                                                \
       {                                                                 \
         if (SPARSE_SMM_BIN_OP_2_CHECK_ ## F(M2::element_type))          \
           {                                                             \
             /* Sparsity pattern is preserved. */                        \
             octave_idx_type m1_nz = m1.nnz ();                          \
             r = R (m1_nr, m1_nc, m1_nz);                                \
             for (octave_idx_type j = 0, k = 0; j < m1_nc; j++)          \
@@ -1314,17 +1314,17 @@ along with Octave; see the file COPYING.
                   }                                                     \
                 r.cidx (j+1) = ii;                                      \
               }                                                         \
           }                                                             \
       }                                                                 \
     else                                                                \
       {                                                                 \
         if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0))   \
-          err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);           \
+          octave::err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);           \
       }                                                                 \
     return r;                                                           \
   }
 
 #define SPARSE_SMM_CMP_OPS(M1, Z1, C1, M2, Z2, C2)      \
   SPARSE_SMM_CMP_OP (mx_el_lt, <,  M1,   , M2,   )      \
   SPARSE_SMM_CMP_OP (mx_el_le, <=, M1,   , M2,   )      \
   SPARSE_SMM_CMP_OP (mx_el_ge, >=, M1,   , M2,   )      \
@@ -1380,17 +1380,17 @@ along with Octave; see the file COPYING.
                   }                                                     \
                 r.cidx (j+1) = ii;                                      \
               }                                                         \
           }                                                             \
       }                                                                 \
     else                                                                \
       {                                                                 \
         if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0))   \
-          err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);           \
+          octave::err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc);           \
       }                                                                 \
     return r;                                                           \
   }
 
 #define SPARSE_SMM_BOOL_OPS2(M1, M2, LHS_ZERO, RHS_ZERO)                \
   SPARSE_SMM_BOOL_OP (mx_el_and, &&, M1, M2, LHS_ZERO, RHS_ZERO)        \
   SPARSE_SMM_BOOL_OP (mx_el_or,  ||, M1, M2, LHS_ZERO, RHS_ZERO)
 
@@ -1736,17 +1736,17 @@ along with Octave; see the file COPYING.
           octave_quit ();                                               \
           r.cidx (i) = m.cidx (i);                                      \
         }                                                               \
                                                                         \
       r.maybe_compress (true);                                          \
       return r;                                                         \
     }                                                                   \
   else if (nc != a_nr)                                                  \
-    err_nonconformant ("operator *", nr, nc, a_nr, a_nc);               \
+    octave::err_nonconformant ("operator *", nr, nc, a_nr, a_nc);               \
   else                                                                  \
     {                                                                   \
       OCTAVE_LOCAL_BUFFER (octave_idx_type, w, nr);                     \
       RET_TYPE retval (nr, a_nc, static_cast<octave_idx_type> (0));     \
       for (octave_idx_type i = 0; i < nr; i++)                          \
         w[i] = 0;                                                       \
       retval.xcidx (0) = 0;                                             \
                                                                         \
@@ -1865,17 +1865,17 @@ along with Octave; see the file COPYING.
   octave_idx_type a_nc = a.cols ();                                     \
                                                                         \
   if (nr == 1 && nc == 1)                                               \
     {                                                                   \
       RET_TYPE retval = m.elem (0,0) * a;                               \
       return retval;                                                    \
     }                                                                   \
   else if (nc != a_nr)                                                  \
-    err_nonconformant ("operator *", nr, nc, a_nr, a_nc);               \
+    octave::err_nonconformant ("operator *", nr, nc, a_nr, a_nc);               \
   else                                                                  \
     {                                                                   \
       RET_TYPE retval (nr, a_nc, ZERO);                                 \
                                                                         \
       for (octave_idx_type i = 0; i < a_nc ; i++)                       \
         {                                                               \
           for (octave_idx_type j = 0; j < a_nr; j++)                    \
             {                                                           \
@@ -1897,17 +1897,17 @@ along with Octave; see the file COPYING.
   octave_idx_type a_nc = a.cols ();                                     \
                                                                         \
   if (nr == 1 && nc == 1)                                               \
     {                                                                   \
       RET_TYPE retval = CONJ_OP (m.elem (0,0)) * a;                     \
       return retval;                                                    \
     }                                                                   \
   else if (nr != a_nr)                                                  \
-    err_nonconformant ("operator *", nc, nr, a_nr, a_nc);               \
+    octave::err_nonconformant ("operator *", nc, nr, a_nr, a_nc);               \
   else                                                                  \
     {                                                                   \
       RET_TYPE retval (nc, a_nc);                                       \
                                                                         \
       for (octave_idx_type i = 0; i < a_nc ; i++)                       \
         {                                                               \
           for (octave_idx_type j = 0; j < nc; j++)                      \
             {                                                           \
@@ -1930,17 +1930,17 @@ along with Octave; see the file COPYING.
   octave_idx_type a_nc = a.cols ();                                     \
                                                                         \
   if (a_nr == 1 && a_nc == 1)                                           \
     {                                                                   \
       RET_TYPE retval = m * a.elem (0,0);                               \
       return retval;                                                    \
     }                                                                   \
   else if (nc != a_nr)                                                  \
-    err_nonconformant ("operator *", nr, nc, a_nr, a_nc);               \
+    octave::err_nonconformant ("operator *", nr, nc, a_nr, a_nc);               \
   else                                                                  \
     {                                                                   \
       RET_TYPE retval (nr, a_nc, ZERO);                                 \
                                                                         \
       for (octave_idx_type i = 0; i < a_nc ; i++)                       \
         {                                                               \
           octave_quit ();                                               \
           for (octave_idx_type j = a.cidx (i); j < a.cidx (i+1); j++)   \
@@ -1963,17 +1963,17 @@ along with Octave; see the file COPYING.
   octave_idx_type a_nc = a.cols ();                                     \
                                                                         \
   if (a_nr == 1 && a_nc == 1)                                           \
     {                                                                   \
       RET_TYPE retval = m * CONJ_OP (a.elem (0,0));                     \
       return retval;                                                    \
     }                                                                   \
   else if (nc != a_nc)                                                  \
-    err_nonconformant ("operator *", nr, nc, a_nc, a_nr);               \
+    octave::err_nonconformant ("operator *", nr, nc, a_nc, a_nr);               \
   else                                                                  \
     {                                                                   \
       RET_TYPE retval (nr, a_nr, ZERO);                                 \
                                                                         \
       for (octave_idx_type i = 0; i < a_nc ; i++)                       \
         {                                                               \
           octave_quit ();                                               \
           for (octave_idx_type j = a.cidx (i); j < a.cidx (i+1); j++)   \
diff --git a/liboctave/operators/Sparse-perm-op-defs.h b/liboctave/operators/Sparse-perm-op-defs.h
--- a/liboctave/operators/Sparse-perm-op-defs.h
+++ b/liboctave/operators/Sparse-perm-op-defs.h
@@ -59,17 +59,17 @@ SM octinternal_do_mul_colpm_sm (const oc
   return r;
 }
 
 template <typename SM>
 SM octinternal_do_mul_pm_sm (const PermMatrix& p, const SM& a)
 {
   const octave_idx_type nr = a.rows ();
   if (p.cols () != nr)
-    err_nonconformant ("operator *", p.rows (), p.cols (), a.rows (), a.cols ());
+    octave::err_nonconformant ("operator *", p.rows (), p.cols (), a.rows (), a.cols ());
 
   return octinternal_do_mul_colpm_sm (p.col_perm_vec ().data (), a);
 }
 
 template <typename SM>
 SM octinternal_do_mul_sm_rowpm (const SM& a, const octave_idx_type *prow)
 // For a row permutation, iterate across the source a and stuff the
 // results into the correct destination column in r.
@@ -142,14 +142,14 @@ SM octinternal_do_mul_sm_colpm (const SM
   return r;
 }
 
 template <typename SM>
 SM octinternal_do_mul_sm_pm (const SM& a, const PermMatrix& p)
 {
   const octave_idx_type nc = a.cols ();
   if (p.rows () != nc)
-    err_nonconformant ("operator *", a.rows (), a.cols (), p.rows (), p.cols ());
+    octave::err_nonconformant ("operator *", a.rows (), a.cols (), p.rows (), p.cols ());
 
   return octinternal_do_mul_sm_colpm (a, p.col_perm_vec ().data ());
 }
 
 #endif
diff --git a/liboctave/operators/mx-inlines.cc b/liboctave/operators/mx-inlines.cc
--- a/liboctave/operators/mx-inlines.cc
+++ b/liboctave/operators/mx-inlines.cc
@@ -471,17 +471,17 @@ do_mm_binary_op (const Array<X>& x, cons
       op (r.numel (), r.fortran_vec (), x.data (), y.data ());
       return r;
     }
   else if (is_valid_bsxfun (opname, dx, dy))
     {
       return do_bsxfun_op (x, y, op, op1, op2);
     }
   else
-    err_nonconformant (opname, dx, dy);
+    octave::err_nonconformant (opname, dx, dy);
 }
 
 template <typename R, typename X, typename Y>
 inline Array<R>
 do_ms_binary_op (const Array<X>& x, const Y& y,
                  void (*op) (size_t, R *, const X *, Y) throw ())
 {
   Array<R> r (x.dims ());
@@ -508,17 +508,17 @@ do_mm_inplace_op (Array<R>& r, const Arr
 {
   dim_vector dr = r.dims ();
   dim_vector dx = x.dims ();
   if (dr == dx)
     op (r.numel (), r.fortran_vec (), x.data ());
   else if (is_valid_inplace_bsxfun (opname, dr, dx))
     do_inplace_bsxfun_op (r, x, op, op1);
   else
-    err_nonconformant (opname, dr, dx);
+    octave::err_nonconformant (opname, dr, dx);
 
   return r;
 }
 
 template <typename R, typename X>
 inline Array<R>&
 do_ms_inplace_op (Array<R>& r, const X& x,
                   void (*op) (size_t, R *, X) throw ())
diff --git a/liboctave/operators/mx-op-defs.h b/liboctave/operators/mx-op-defs.h
--- a/liboctave/operators/mx-op-defs.h
+++ b/liboctave/operators/mx-op-defs.h
@@ -28,21 +28,21 @@ along with Octave; see the file COPYING.
 #include "octave-config.h"
 
 #include "lo-array-errwarn.h"
 #include "mx-op-decl.h"
 #include "mx-inlines.cc"
 
 #define SNANCHK(s)                              \
   if (octave::math::isnan (s))                  \
-    err_nan_to_logical_conversion ()
+    octave::err_nan_to_logical_conversion ()
 
 #define MNANCHK(m, MT)                          \
   if (do_mx_check (m, mx_inline_any_nan<MT>))   \
-    err_nan_to_logical_conversion ()
+    octave::err_nan_to_logical_conversion ()
 
 // vector by scalar operations.
 
 #define VS_BIN_OP(R, F, OP, V, S)                                       \
   R                                                                     \
   F (const V& v, const S& s)                                            \
   {                                                                     \
     return do_ms_binary_op<R::element_type, V::element_type, S> (v, s, OP); \
@@ -399,17 +399,17 @@ along with Octave; see the file COPYING.
                                                                 \
     octave_idx_type m_nr = m.rows ();                           \
     octave_idx_type m_nc = m.cols ();                           \
                                                                 \
     octave_idx_type dm_nr = dm.rows ();                         \
     octave_idx_type dm_nc = dm.cols ();                         \
                                                                 \
     if (m_nr != dm_nr || m_nc != dm_nc)                         \
-      err_nonconformant (#OP, m_nr, m_nc, dm_nr, dm_nc);        \
+      octave::err_nonconformant (#OP, m_nr, m_nc, dm_nr, dm_nc);        \
                                                                 \
     r.resize (m_nr, m_nc);                                      \
                                                                 \
     if (m_nr > 0 && m_nc > 0)                                   \
       {                                                         \
         r = R (m);                                              \
                                                                 \
         octave_idx_type len = dm.length ();                     \
@@ -429,17 +429,17 @@ along with Octave; see the file COPYING.
                                                                         \
     octave_idx_type m_nr = m.rows ();                                   \
     octave_idx_type m_nc = m.cols ();                                   \
                                                                         \
     octave_idx_type dm_nr = dm.rows ();                                 \
     octave_idx_type dm_nc = dm.cols ();                                 \
                                                                         \
     if (m_nc != dm_nr)                                                  \
-      err_nonconformant ("operator *", m_nr, m_nc, dm_nr, dm_nc);       \
+      octave::err_nonconformant ("operator *", m_nr, m_nc, dm_nr, dm_nc);       \
                                                                         \
     r = R (m_nr, dm_nc);                                                \
     R::element_type *rd = r.fortran_vec ();                             \
     const M::element_type *md = m.data ();                              \
     const DM::element_type *dd = dm.data ();                            \
                                                                         \
     octave_idx_type len = dm.length ();                                 \
     for (octave_idx_type i = 0; i < len; i++)                           \
@@ -467,17 +467,17 @@ along with Octave; see the file COPYING.
                                                                 \
     octave_idx_type dm_nr = dm.rows ();                         \
     octave_idx_type dm_nc = dm.cols ();                         \
                                                                 \
     octave_idx_type m_nr = m.rows ();                           \
     octave_idx_type m_nc = m.cols ();                           \
                                                                 \
     if (dm_nr != m_nr || dm_nc != m_nc)                         \
-      err_nonconformant (#OP, dm_nr, dm_nc, m_nr, m_nc);        \
+      octave::err_nonconformant (#OP, dm_nr, dm_nc, m_nr, m_nc);        \
     else                                                        \
       {                                                         \
         if (m_nr > 0 && m_nc > 0)                               \
           {                                                     \
             r = R (PREOP m);                                    \
                                                                 \
             octave_idx_type len = dm.length ();                 \
                                                                 \
@@ -499,17 +499,17 @@ along with Octave; see the file COPYING.
                                                                         \
     octave_idx_type dm_nr = dm.rows ();                                 \
     octave_idx_type dm_nc = dm.cols ();                                 \
                                                                         \
     octave_idx_type m_nr = m.rows ();                                   \
     octave_idx_type m_nc = m.cols ();                                   \
                                                                         \
     if (dm_nc != m_nr)                                                  \
-      err_nonconformant ("operator *", dm_nr, dm_nc, m_nr, m_nc);       \
+      octave::err_nonconformant ("operator *", dm_nr, dm_nc, m_nr, m_nc);       \
                                                                         \
     r = R (dm_nr, m_nc);                                                \
     R::element_type *rd = r.fortran_vec ();                             \
     const M::element_type *md = m.data ();                              \
     const DM::element_type *dd = dm.data ();                            \
                                                                         \
     octave_idx_type len = dm.length ();                                 \
     for (octave_idx_type i = 0; i < m_nc; i++)                          \
@@ -538,17 +538,17 @@ along with Octave; see the file COPYING.
                                                                         \
     octave_idx_type dm1_nr = dm1.rows ();                               \
     octave_idx_type dm1_nc = dm1.cols ();                               \
                                                                         \
     octave_idx_type dm2_nr = dm2.rows ();                               \
     octave_idx_type dm2_nc = dm2.cols ();                               \
                                                                         \
     if (dm1_nr != dm2_nr || dm1_nc != dm2_nc)                           \
-      err_nonconformant (#OP, dm1_nr, dm1_nc, dm2_nr, dm2_nc);          \
+      octave::err_nonconformant (#OP, dm1_nr, dm1_nc, dm2_nr, dm2_nc);          \
                                                                         \
     r.resize (dm1_nr, dm1_nc);                                          \
                                                                         \
     if (dm1_nr > 0 && dm1_nc > 0)                                       \
       F (dm1.length (), r.fortran_vec (), dm1.data (), dm2.data ());    \
                                                                         \
     return r;                                                           \
   }
@@ -593,34 +593,34 @@ along with Octave; see the file COPYING.
 
 #define PMM_MULTIPLY_OP(PM, M)                                          \
   M operator * (const PM& p, const M& x)                                \
   {                                                                     \
     octave_idx_type nr = x.rows ();                                     \
     octave_idx_type nc = x.columns ();                                  \
     M result;                                                           \
     if (p.columns () != nr)                                             \
-      err_nonconformant ("operator *", p.rows (), p.columns (), nr, nc); \
+      octave::err_nonconformant ("operator *", p.rows (), p.columns (), nr, nc); \
     else                                                                \
       {                                                                 \
         result = M (nr, nc);                                            \
         result.assign (p.col_perm_vec (), idx_vector::colon, x);        \
       }                                                                 \
                                                                         \
     return result;                                                      \
   }
 
 #define MPM_MULTIPLY_OP(M, PM)                                          \
   M operator * (const M& x, const PM& p)                                \
   {                                                                     \
     octave_idx_type nr = x.rows ();                                     \
     octave_idx_type nc = x.columns ();                                  \
     M result;                                                           \
     if (p.rows () != nc)                                                \
-      err_nonconformant ("operator *", nr, nc, p.rows (), p.columns ()); \
+      octave::err_nonconformant ("operator *", nr, nc, p.rows (), p.columns ()); \
                                                                         \
     result = x.index (idx_vector::colon, p.col_perm_vec ());            \
                                                                         \
     return result;                                                      \
   }
 
 #define PMM_BIN_OPS(R, PM, M)                   \
   PMM_MULTIPLY_OP(PM, M);
diff --git a/liboctave/util/cmd-edit.cc b/liboctave/util/cmd-edit.cc
--- a/liboctave/util/cmd-edit.cc
+++ b/liboctave/util/cmd-edit.cc
@@ -1792,17 +1792,17 @@ namespace octave
 
               case 'w':
               case 'W':
                 {
                   try
                     {
                       tmpstr = octave::sys::env::get_current_directory ();
                     }
-                  catch (const octave_execution_exception&)
+                  catch (const octave::execution_exception&)
                     {
                       tmpstr = "";
                     }
 
                   std::string home_dir = octave::sys::env::get_home_directory ();
 
                   if (c == 'W' && (home_dir.empty () || tmpstr != home_dir))
                     {
diff --git a/liboctave/util/lo-array-errwarn.cc b/liboctave/util/lo-array-errwarn.cc
--- a/liboctave/util/lo-array-errwarn.cc
+++ b/liboctave/util/lo-array-errwarn.cc
@@ -35,293 +35,296 @@ static const char *error_id_nonconforman
 static const char *error_id_index_out_of_bounds = "Octave:index-out-of-bounds";
 
 static const char *error_id_invalid_index = "Octave:invalid-index";
 
 static const char *warning_id_nearly_singular_matrix = "Octave:nearly-singular-matrix";
 
 static const char *warning_id_singular_matrix = "Octave:singular-matrix";
 
-void
-err_nan_to_logical_conversion (void)
-{
-  (*current_liboctave_error_handler)
-    ("invalid conversion from NaN to logical");
-}
-
-void
-err_nan_to_character_conversion (void)
+namespace octave
 {
-  (*current_liboctave_error_handler)
-    ("invalid conversion from NaN to character");
-}
+  void
+  err_nan_to_logical_conversion (void)
+  {
+    (*current_liboctave_error_handler)
+      ("invalid conversion from NaN to logical");
+  }
+
+  void
+  err_nan_to_character_conversion (void)
+  {
+    (*current_liboctave_error_handler)
+      ("invalid conversion from NaN to character");
+  }
+
+  void
+  err_nonconformant (const char *op,
+                     octave_idx_type op1_len, octave_idx_type op2_len)
+  {
+    const char *err_id = error_id_nonconformant_args;
 
-void
-err_nonconformant (const char *op,
-                   octave_idx_type op1_len, octave_idx_type op2_len)
-{
-  const char *err_id = error_id_nonconformant_args;
+    (*current_liboctave_error_with_id_handler)
+      (err_id, "%s: nonconformant arguments (op1 len: %d, op2 len: %d)",
+       op, op1_len, op2_len);
+  }
+
+  void
+  err_nonconformant (const char *op,
+                     octave_idx_type op1_nr, octave_idx_type op1_nc,
+                     octave_idx_type op2_nr, octave_idx_type op2_nc)
+  {
+    const char *err_id = error_id_nonconformant_args;
+
+    (*current_liboctave_error_with_id_handler)
+      (err_id, "%s: nonconformant arguments (op1 is %dx%d, op2 is %dx%d)",
+       op, op1_nr, op1_nc, op2_nr, op2_nc);
+  }
+
+  void
+  err_nonconformant (const char *op,
+                     const dim_vector& op1_dims, const dim_vector& op2_dims)
+  {
+    const char *err_id = error_id_nonconformant_args;
+
+    std::string op1_dims_str = op1_dims.str ();
+    std::string op2_dims_str = op2_dims.str ();
 
-  (*current_liboctave_error_with_id_handler)
-    (err_id, "%s: nonconformant arguments (op1 len: %d, op2 len: %d)",
-     op, op1_len, op2_len);
-}
+    (*current_liboctave_error_with_id_handler)
+      (err_id, "%s: nonconformant arguments (op1 is %s, op2 is %s)",
+       op, op1_dims_str.c_str (), op2_dims_str.c_str ());
+  }
 
-void
-err_nonconformant (const char *op,
-                   octave_idx_type op1_nr, octave_idx_type op1_nc,
-                   octave_idx_type op2_nr, octave_idx_type op2_nc)
-{
-  const char *err_id = error_id_nonconformant_args;
+  void
+  err_del_index_out_of_range (bool is1d, octave_idx_type idx,
+                              octave_idx_type ext)
+  {
+    const char *err_id = error_id_index_out_of_bounds;
+
+    (*current_liboctave_error_with_id_handler)
+      (err_id, "A(%s) = []: index out of bounds: value %d out of bound %d",
+       is1d ? "I" : "..,I,..", idx, ext);
+  }
+
+  // Common procedures of base class index_exception, thrown whenever an
+  // object is indexed incorrectly, such as by an index that is out of
+  // range, negative, fractional, complex, or of a non-numeric type.
 
-  (*current_liboctave_error_with_id_handler)
-    (err_id, "%s: nonconformant arguments (op1 is %dx%d, op2 is %dx%d)",
-     op, op1_nr, op1_nc, op2_nr, op2_nc);
-}
+  std::string
+  index_exception::message (void) const
+  {
+    std::string msg = expression () + ": " + details ();
+    return msg.c_str ();
+  }
+
+  // Show the expression that caused the error, e.g.,  "A(-1,_)",
+  // "A(0+1i)", "A(_,3)".  Show how many indices come before/after the
+  // offending one, e.g., (<error>), (<error>,_), or (_,<error>,...[x5]...)
 
-void
-err_nonconformant (const char *op,
-                   const dim_vector& op1_dims, const dim_vector& op2_dims)
-{
-  const char *err_id = error_id_nonconformant_args;
+  std::string
+  index_exception::expression (void) const
+  {
+    std::ostringstream buf;
 
-  std::string op1_dims_str = op1_dims.str ();
-  std::string op2_dims_str = op2_dims.str ();
+    if (var.empty () || var == "<unknown>")
+      buf << "index ";
+    else
+      buf << var;
+
+    bool show_parens = dim > 0;
+
+    if (show_parens)
+      {
+        if (dim < 5)
+          {
+            buf << "(";
 
-  (*current_liboctave_error_with_id_handler)
-    (err_id, "%s: nonconformant arguments (op1 is %s, op2 is %s)",
-     op, op1_dims_str.c_str (), op2_dims_str.c_str ());
-}
+            for (octave_idx_type i = 1; i < dim; i++)
+              buf << "_,";
+          }
+        else
+          buf << "(...[x" << dim - 1 << "]...";
+      }
+
+    buf << idx ();
+
+    if (show_parens)
+      {
+        if (nd - dim < 5)
+          {
+            for (octave_idx_type i = 0; i < nd - dim; i++)
+              buf << ",_";
+
+            if (nd >= dim)
+              buf << ")";
+          }
+        else
+          buf << "...[x" << nd - dim << "]...)";
+      }
 
-void
-err_del_index_out_of_range (bool is1d, octave_idx_type idx,
-                            octave_idx_type ext)
-{
-  const char *err_id = error_id_index_out_of_bounds;
+    return buf.str ();
+  }
+
+  class invalid_index : public index_exception
+  {
+  public:
+
+    invalid_index (const std::string& value, octave_idx_type ndim,
+                   octave_idx_type dimen)
+      : index_exception (value, ndim, dimen)
+    { }
 
-  (*current_liboctave_error_with_id_handler)
-    (err_id, "A(%s) = []: index out of bounds: value %d out of bound %d",
-     is1d ? "I" : "..,I,..", idx, ext);
-}
+    std::string details (void) const
+    {
+#if defined (OCTAVE_ENABLE_64)
+      return "subscripts must be either integers 1 to (2^63)-1 or logicals";
+#else
+      return "subscripts must be either integers 1 to (2^31)-1 or logicals";
+#endif
+    }
 
-// Common procedures of base class index_exception, thrown whenever an
-// object is indexed incorrectly, such as by an index that is out of
-// range, negative, fractional, complex, or of a non-numeric type.
+    // ID of error to throw
+    const char *err_id (void) const
+    {
+      return error_id_invalid_index;
+    }
+  };
 
-std::string
-index_exception::message (void) const
-{
-  std::string msg = expression () + ": " + details ();
-  return msg.c_str ();
-}
+  // Complain if an index is negative, fractional, or too big.
+
+  void
+  err_invalid_index (const std::string& idx, octave_idx_type nd,
+                     octave_idx_type dim, const std::string&)
+  {
+    invalid_index e (idx, nd, dim);
 
-// Show the expression that caused the error, e.g.,  "A(-1,_)",
-// "A(0+1i)", "A(_,3)".  Show how many indices come before/after the
-// offending one, e.g., (<error>), (<error>,_), or (_,<error>,...[x5]...)
+    throw e;
+  }
 
-std::string
-index_exception::expression (void) const
-{
-  std::ostringstream buf;
+  void
+  err_invalid_index (octave_idx_type n, octave_idx_type nd,
+                     octave_idx_type dim, const std::string& var)
+  {
+    std::ostringstream buf;
+    buf << n + 1;
+    err_invalid_index (buf.str (), nd, dim, var);
+  }
 
-  if (var.empty () || var == "<unknown>")
-    buf << "index ";
-  else
-    buf << var;
+  void
+  err_invalid_index (double n, octave_idx_type nd, octave_idx_type dim,
+                     const std::string& var)
+  {
+    std::ostringstream buf;
+    buf << n + 1;
+    err_invalid_index (buf.str (), nd, dim, var);
+  }
 
-  bool show_parens = dim > 0;
+  // Complain for read access beyond the bounds of an array.
+
+  class out_of_range : public index_exception
+  {
+  public:
 
-  if (show_parens)
+    out_of_range (const std::string& value, octave_idx_type nd_in,
+                  octave_idx_type dim_in)
+      : index_exception (value, nd_in, dim_in), extent (0)
+    { }
+
+    std::string details (void) const
     {
-      if (dim < 5)
+      std::string expl;
+
+      if (nd >= size.ndims ())   // if not an index slice
         {
-          buf << "(";
+          if (var != "")
+            expl = "but " + var + " has size ";
+          else
+            expl = "but object has size ";
 
-          for (octave_idx_type i = 1; i < dim; i++)
-            buf << "_,";
+          expl = expl + size.str ('x');
         }
       else
-        buf << "(...[x" << dim - 1 << "]...";
+        {
+          std::ostringstream buf;
+          buf << extent;
+          expl = "out of bound " + buf.str ();
+        }
+
+      return expl;
     }
 
-  buf << idx ();
-
-  if (show_parens)
+    // ID of error to throw.
+    const char *err_id (void) const
     {
-      if (nd - dim < 5)
-        {
-          for (octave_idx_type i = 0; i < nd - dim; i++)
-            buf << ",_";
-
-          if (nd >= dim)
-            buf << ")";
-        }
-      else
-        buf << "...[x" << nd - dim << "]...)";
+      return error_id_index_out_of_bounds;
     }
 
-  return buf.str ();
-}
+    void set_size (const dim_vector& size_in) { size = size_in; }
+
+    void set_extent (octave_idx_type ext) { extent = ext; }
+
+  private:
 
-class invalid_index : public index_exception
-{
-public:
+    // Dimension of object being accessed.
+    dim_vector size;
+
+    // Length of dimension being accessed.
+    octave_idx_type extent;
+  };
 
-  invalid_index (const std::string& value, octave_idx_type ndim,
-                 octave_idx_type dimen)
-    : index_exception (value, ndim, dimen)
-  { }
+  // Complain of an index that is out of range, but we don't know matrix size
+  void
+  err_index_out_of_range (int nd, int dim, octave_idx_type idx,
+                          octave_idx_type ext)
+  {
+    std::ostringstream buf;
+    buf << idx;
+    out_of_range e (buf.str (), nd, dim);
 
-  std::string details (void) const
-  {
-#if defined (OCTAVE_ENABLE_64)
-    return "subscripts must be either integers 1 to (2^63)-1 or logicals";
-#else
-    return "subscripts must be either integers 1 to (2^31)-1 or logicals";
-#endif
+    e.set_extent (ext);
+    // ??? Make details method give extent not size.
+    e.set_size (dim_vector (1, 1, 1, 1, 1, 1,1));
+
+    throw e;
   }
 
-  // ID of error to throw
-  const char *err_id (void) const
+  // Complain of an index that is out of range
+  void
+  err_index_out_of_range (int nd, int dim, octave_idx_type idx,
+                          octave_idx_type ext, const dim_vector& d)
   {
-    return error_id_invalid_index;
-  }
-};
-
-// Complain if an index is negative, fractional, or too big.
+    std::ostringstream buf;
+    buf << idx;
+    out_of_range e (buf.str (), nd, dim);
 
-void
-err_invalid_index (const std::string& idx, octave_idx_type nd,
-                   octave_idx_type dim, const std::string&)
-{
-  invalid_index e (idx, nd, dim);
-
-  throw e;
-}
+    e.set_extent (ext);
+    e.set_size (d);
 
-void
-err_invalid_index (octave_idx_type n, octave_idx_type nd,
-                   octave_idx_type dim, const std::string& var)
-{
-  std::ostringstream buf;
-  buf << n + 1;
-  err_invalid_index (buf.str (), nd, dim, var);
-}
+    throw e;
+  }
 
-void
-err_invalid_index (double n, octave_idx_type nd, octave_idx_type dim,
-                   const std::string& var)
-{
-  std::ostringstream buf;
-  buf << n + 1;
-  err_invalid_index (buf.str (), nd, dim, var);
-}
-
-// Complain for read access beyond the bounds of an array.
-
-class out_of_range : public index_exception
-{
-public:
+  void
+  err_invalid_resize (void)
+  {
+    (*current_liboctave_error_with_id_handler)
+      ("Octave:invalid-resize",
+       "Invalid resizing operation or ambiguous assignment to an out-of-bounds array element");
+  }
 
-  out_of_range (const std::string& value, octave_idx_type nd_in,
-                octave_idx_type dim_in)
-    : index_exception (value, nd_in, dim_in), extent (0)
-  { }
-
-  std::string details (void) const
+  void
+  warn_singular_matrix (double rcond)
   {
-    std::string expl;
-
-    if (nd >= size.ndims ())   // if not an index slice
+    if (rcond == 0.0)
       {
-        if (var != "")
-          expl = "but " + var + " has size ";
-        else
-          expl = "but object has size ";
-
-        expl = expl + size.str ('x');
+        (*current_liboctave_warning_with_id_handler)
+          (warning_id_singular_matrix,
+           "matrix singular to machine precision");
       }
     else
       {
-        std::ostringstream buf;
-        buf << extent;
-        expl = "out of bound " + buf.str ();
+        (*current_liboctave_warning_with_id_handler)
+          (warning_id_nearly_singular_matrix,
+           "matrix singular to machine precision, rcond = %g", rcond);
       }
-
-    return expl;
-  }
-
-  // ID of error to throw.
-  const char *err_id (void) const
-  {
-    return error_id_index_out_of_bounds;
   }
-
-  void set_size (const dim_vector& size_in) { size = size_in; }
-
-  void set_extent (octave_idx_type ext) { extent = ext; }
-
-private:
-
-  // Dimension of object being accessed.
-  dim_vector size;
-
-  // Length of dimension being accessed.
-  octave_idx_type extent;
-};
-
-// Complain of an index that is out of range, but we don't know matrix size
-void
-err_index_out_of_range (int nd, int dim, octave_idx_type idx,
-                        octave_idx_type ext)
-{
-  std::ostringstream buf;
-  buf << idx;
-  out_of_range e (buf.str (), nd, dim);
-
-  e.set_extent (ext);
-  // ??? Make details method give extent not size.
-  e.set_size (dim_vector (1, 1, 1, 1, 1, 1,1));
-
-  throw e;
-}
-
-// Complain of an index that is out of range
-void
-err_index_out_of_range (int nd, int dim, octave_idx_type idx,
-                        octave_idx_type ext, const dim_vector& d)
-{
-  std::ostringstream buf;
-  buf << idx;
-  out_of_range e (buf.str (), nd, dim);
-
-  e.set_extent (ext);
-  e.set_size (d);
-
-  throw e;
-}
-
-void
-err_invalid_resize (void)
-{
-  (*current_liboctave_error_with_id_handler)
-    ("Octave:invalid-resize",
-     "Invalid resizing operation or ambiguous assignment to an out-of-bounds array element");
-}
-
-void
-warn_singular_matrix (double rcond)
-{
-  if (rcond == 0.0)
-    {
-      (*current_liboctave_warning_with_id_handler)
-        (warning_id_singular_matrix,
-         "matrix singular to machine precision");
-    }
-  else
-    {
-      (*current_liboctave_warning_with_id_handler)
-        (warning_id_nearly_singular_matrix,
-         "matrix singular to machine precision, rcond = %g", rcond);
-    }
 }
 
 /* Tests in test/index.tst */
diff --git a/liboctave/util/lo-array-errwarn.h b/liboctave/util/lo-array-errwarn.h
--- a/liboctave/util/lo-array-errwarn.h
+++ b/liboctave/util/lo-array-errwarn.h
@@ -23,134 +23,245 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_lo_array_errwarn_h)
 #define octave_lo_array_errwarn_h 1
 
 #include "octave-config.h"
 
 #include "dim-vector.h"
 #include "quit.h"
 
-// Exception thrown by err_invalid_index
-// This is thrown when the invalid index is detected, at which point nd and dim
-// are usually not known.  It is caught at the place they are known, where a
-// new err_invalid_index  is called.
-//
-// Typically, this should be caught after any call to
-// octave_value_list::index_vector()
-class index_exception : public octave_execution_exception
+namespace octave
 {
-public:
-
-  index_exception (const std::string& index_arg, octave_idx_type nd_arg = 0,
-                   octave_idx_type dim_arg = -1, const char *var_arg = "")
-    : index (index_arg), nd (nd_arg), dim (dim_arg), var (var_arg)
-  { }
-
-  ~index_exception (void) { }
+  // Exception thrown by err_invalid_index
+  // This is thrown when the invalid index is detected, at which point nd and dim
+  // are usually not known.  It is caught at the place they are known, where a
+  // new err_invalid_index  is called.
+  //
+  // Typically, this should be caught after any call to
+  // octave_value_list::index_vector()
 
-  // Erroneous index value.  Called in what, and by external code
-  // (e.g., nth_element) to make a custom error message.
-  std::string idx (void) const { return index; }
-
-  // details set by subclass.
-  virtual std::string details (void) const = 0;
-
-  // ID of error to throw.
-  virtual const char *err_id (void) const = 0;
-
-  virtual std::string message (void) const;
-
-  // Position of error: dimension in error, and number of dimensions.
-  void set_pos (octave_idx_type nd_arg, octave_idx_type dim_arg)
-  {
-    nd = nd_arg;
-    dim = dim_arg;
-  }
-
-  void set_pos_if_unset (octave_idx_type nd_arg, octave_idx_type dim_arg)
+  class index_exception : public execution_exception
   {
-    if (nd == 0)
-      {
-        nd  = nd_arg;
-        dim = dim_arg;
-      }
-  }
+  public:
+
+    index_exception (const std::string& index_arg, octave_idx_type nd_arg = 0,
+                     octave_idx_type dim_arg = -1, const char *var_arg = "")
+      : index (index_arg), nd (nd_arg), dim (dim_arg), var (var_arg)
+    { }
+
+    ~index_exception (void) { }
+
+    // Erroneous index value.  Called in what, and by external code
+    // (e.g., nth_element) to make a custom error message.
+    std::string idx (void) const { return index; }
+
+    // details set by subclass.
+    virtual std::string details (void) const = 0;
+
+    // ID of error to throw.
+    virtual const char *err_id (void) const = 0;
+
+    virtual std::string message (void) const;
+
+    // Position of error: dimension in error, and number of dimensions.
+    void set_pos (octave_idx_type nd_arg, octave_idx_type dim_arg)
+    {
+      nd = nd_arg;
+      dim = dim_arg;
+    }
 
-  // Name of variable being indexed.  eye(2)(1,1) gives "<unknown>".
-  void set_var (const std::string& var_arg = "")
-  {
-    var = var_arg;
-  }
+    void set_pos_if_unset (octave_idx_type nd_arg, octave_idx_type dim_arg)
+    {
+      if (nd == 0)
+        {
+          nd  = nd_arg;
+          dim = dim_arg;
+        }
+    }
 
-private:
+    // Name of variable being indexed.  eye(2)(1,1) gives "<unknown>".
+    void set_var (const std::string& var_arg = "")
+    {
+      var = var_arg;
+    }
+
+  private:
+
+    // Value of invalid index.
+    std::string index;
 
-  // Value of invalid index.
-  std::string index;
+  protected:
+
+    // Show what's wrong, e.g.,  A(-1,_), A(0+1i).
+    std::string expression (void) const;
+
+    // Number of dimensions of indexed object.
+    octave_idx_type nd;
+
+    // Dimension number in which invalid index occurred.
+    octave_idx_type dim;
 
-protected:
+    // Name of variable being indexed.
+    std::string var;
+
+  };
 
-  // Show what's wrong, e.g.,  A(-1,_), A(0+1i).
-  std::string expression (void) const;
+  OCTAVE_NORETURN OCTAVE_API extern void
+  err_nan_to_logical_conversion (void);
+
+  OCTAVE_NORETURN OCTAVE_API extern void
+  err_nan_to_character_conversion (void);
 
-  // Number of dimensions of indexed object.
-  octave_idx_type nd;
+  OCTAVE_NORETURN OCTAVE_API extern void
+  err_nonconformant (const char *op, octave_idx_type op1_len,
+                     octave_idx_type op2_len);
+
+  OCTAVE_NORETURN OCTAVE_API extern void
+  err_nonconformant (const char *op,
+                     octave_idx_type op1_nr, octave_idx_type op1_nc,
+                     octave_idx_type op2_nr, octave_idx_type op2_nc);
+
+  OCTAVE_NORETURN OCTAVE_API extern void
+  err_nonconformant (const char *op,
+                     const dim_vector& op1_dims, const dim_vector& op2_dims);
+
+  OCTAVE_NORETURN OCTAVE_API extern void
+  err_index_out_of_range (int nd, int dim, octave_idx_type iext,
+                          octave_idx_type ext, const dim_vector& d);
 
-  // Dimension number in which invalid index occurred.
-  octave_idx_type dim;
+  OCTAVE_NORETURN OCTAVE_API extern void
+  err_index_out_of_range (int nd, int dim, octave_idx_type iext,
+                          octave_idx_type ext);
+
+  OCTAVE_NORETURN OCTAVE_API extern void
+  err_del_index_out_of_range (bool is1d, octave_idx_type iext,
+                              octave_idx_type ext);
 
-  // Name of variable being indexed.
-  std::string var;
+  OCTAVE_NORETURN OCTAVE_API extern void
+  err_invalid_index (double n, octave_idx_type nd = 0,
+                     octave_idx_type dim = 0,
+                     const std::string& var = "");
 
-};
+  OCTAVE_NORETURN OCTAVE_API extern void
+  err_invalid_index (octave_idx_type n, octave_idx_type nd = 0,
+                     octave_idx_type dim = 0,
+                     const std::string& var = "");
 
-OCTAVE_NORETURN OCTAVE_API extern void
-err_nan_to_logical_conversion (void);
+  OCTAVE_NORETURN OCTAVE_API extern void
+  err_invalid_index (const std::string& idx, octave_idx_type nd = 0,
+                     octave_idx_type dim = 0,
+                     const std::string& var = "");
 
-OCTAVE_NORETURN OCTAVE_API extern void
-err_nan_to_character_conversion (void);
+  OCTAVE_NORETURN OCTAVE_API extern void
+  err_invalid_resize (void);
+
+  OCTAVE_API extern void
+  warn_singular_matrix (double rcond = 0.0);
+}
+
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-OCTAVE_NORETURN OCTAVE_API extern void
+OCTAVE_DEPRECATED ("use 'octave::err_nan_to_logical_conversion' instead")
+OCTAVE_NORETURN inline void
+err_nan_to_logical_conversion (void)
+{
+  octave::err_nan_to_logical_conversion ();
+}
+
+OCTAVE_DEPRECATED ("use 'octave::err_nan_to_character_conversion' instead")
+OCTAVE_NORETURN inline void
+err_nan_to_character_conversion (void)
+{
+  octave::err_nan_to_character_conversion ();
+}
+
+OCTAVE_DEPRECATED ("use 'octave::err_nonconformant' instead")
+OCTAVE_NORETURN inline void
 err_nonconformant (const char *op, octave_idx_type op1_len,
-                   octave_idx_type op2_len);
+                   octave_idx_type op2_len)
+{
+  octave::err_nonconformant (op, op1_len, op2_len);
+}
 
-OCTAVE_NORETURN OCTAVE_API extern void
+OCTAVE_DEPRECATED ("use 'octave::err_nonconformant' instead")
+OCTAVE_NORETURN inline void
 err_nonconformant (const char *op,
                    octave_idx_type op1_nr, octave_idx_type op1_nc,
-                   octave_idx_type op2_nr, octave_idx_type op2_nc);
-
-OCTAVE_NORETURN OCTAVE_API extern void
-err_nonconformant (const char *op,
-                   const dim_vector& op1_dims, const dim_vector& op2_dims);
+                   octave_idx_type op2_nr, octave_idx_type op2_nc)
+{
+  octave::err_nonconformant (op, op1_nr, op1_nc, op2_nr, op2_nc);
+}
 
-OCTAVE_NORETURN OCTAVE_API extern void
+OCTAVE_DEPRECATED ("use 'octave::err_nonconformant' instead")
+OCTAVE_NORETURN inline void
+err_nonconformant (const char *op,
+                   const dim_vector& op1_dims, const dim_vector& op2_dims)
+{
+  octave::err_nonconformant (op, op1_dims, op2_dims);
+}
+
+OCTAVE_DEPRECATED ("use 'octave::err_index_out_of_range' instead")
+OCTAVE_NORETURN inline void
 err_index_out_of_range (int nd, int dim, octave_idx_type iext,
-                        octave_idx_type ext, const dim_vector& d);
+                        octave_idx_type ext, const dim_vector& d)
+{
+  octave::err_index_out_of_range (nd, dim, iext, ext, d);
+}
 
-OCTAVE_NORETURN OCTAVE_API extern void
+OCTAVE_DEPRECATED ("use 'octave::err_index_out_of_range' instead")
+OCTAVE_NORETURN inline void
 err_index_out_of_range (int nd, int dim, octave_idx_type iext,
-                        octave_idx_type ext);
-
-OCTAVE_NORETURN OCTAVE_API extern void
-err_del_index_out_of_range (bool is1d, octave_idx_type iext,
-                            octave_idx_type ext);
+                        octave_idx_type ext)
+{
+  octave::err_index_out_of_range (nd, dim, iext, ext);
+}
 
-OCTAVE_NORETURN OCTAVE_API extern void
-err_invalid_index (double, octave_idx_type nd = 0,
+OCTAVE_DEPRECATED ("use 'octave::err_del_index_out_of_range' instead")
+OCTAVE_NORETURN inline void
+err_del_index_out_of_range (bool is1d, octave_idx_type iext,
+                            octave_idx_type ext)
+{
+  octave::err_del_index_out_of_range (is1d, iext, ext);
+}
+
+OCTAVE_NORETURN inline void
+err_invalid_index (double n, octave_idx_type nd = 0,
                    octave_idx_type dim = 0,
-                   const std::string& var = "");
+                   const std::string& var = "")
+{
+  octave::err_invalid_index (n, nd, dim, var);
+}
 
-OCTAVE_NORETURN OCTAVE_API extern void
+OCTAVE_DEPRECATED ("use 'octave::err_invalid_index' instead")
+OCTAVE_NORETURN inline void
 err_invalid_index (octave_idx_type n, octave_idx_type nd = 0,
                    octave_idx_type dim = 0,
-                   const std::string& var = "");
+                   const std::string& var = "")
+{
+  octave::err_invalid_index (n, nd, dim, var);
+}
 
-OCTAVE_NORETURN OCTAVE_API extern void
+OCTAVE_DEPRECATED ("use 'octave::err_invalid_index' instead")
+OCTAVE_NORETURN inline void
 err_invalid_index (const std::string& idx, octave_idx_type nd = 0,
                    octave_idx_type dim = 0,
-                   const std::string& var = "");
+                   const std::string& var = "")
+{
+  octave::err_invalid_index (idx, nd, dim, var);
+}
 
-OCTAVE_NORETURN OCTAVE_API extern void
-err_invalid_resize (void);
+OCTAVE_DEPRECATED ("use 'octave::err_invalid_resize' instead")
+OCTAVE_NORETURN inline void
+err_invalid_resize (void)
+{
+  octave::err_invalid_resize ();
+}
 
-OCTAVE_API extern void
-warn_singular_matrix (double rcond = 0.0);
+OCTAVE_DEPRECATED ("use 'octave::warn_singular_matrix' instead")
+inline void
+warn_singular_matrix (double rcond = 0.0)
+{
+  return octave::warn_singular_matrix (rcond);
+}
 
 #endif
+
+#endif
diff --git a/liboctave/util/lo-array-gripes.cc b/liboctave/util/lo-array-gripes.cc
--- a/liboctave/util/lo-array-gripes.cc
+++ b/liboctave/util/lo-array-gripes.cc
@@ -100,50 +100,53 @@ gripe_del_index_out_of_range (bool is1d,
 {
   const char *err_id = error_id_index_out_of_bounds;
 
   (*current_liboctave_error_with_id_handler)
     (err_id, "A(%s) = []: index out of bounds: value %d out of bound %d",
      is1d ? "I" : "..,I,..", idx, ext);
 }
 
-class invalid_index : public index_exception
+namespace octave
 {
-public:
+  class invalid_index : public index_exception
+  {
+  public:
 
-  invalid_index (const std::string& value, octave_idx_type ndim,
-                 octave_idx_type dimen)
-    : index_exception (value, ndim, dimen)
-  { }
+    invalid_index (const std::string& value, octave_idx_type ndim,
+                   octave_idx_type dimen)
+      : index_exception (value, ndim, dimen)
+    { }
 
-  std::string details (void) const
-  {
+    std::string details (void) const
+    {
 #if defined (OCTAVE_ENABLE_64)
-    return "subscripts must be either integers 1 to (2^63)-1 or logicals";
+      return "subscripts must be either integers 1 to (2^63)-1 or logicals";
 #else
-    return "subscripts must be either integers 1 to (2^31)-1 or logicals";
+      return "subscripts must be either integers 1 to (2^31)-1 or logicals";
 #endif
-  }
+    }
 
-  // ID of error to throw
-  const char *err_id (void) const
-  {
-    return error_id_invalid_index;
-  }
-};
+    // ID of error to throw
+    const char *err_id (void) const
+    {
+      return error_id_invalid_index;
+    }
+  };
+}
 
 // Complain if an index is negative, fractional, or too big.
 
 void
 gripe_invalid_index (const std::string& idx, octave_idx_type nd,
                      octave_idx_type dim, const std::string&)
 {
-    invalid_index e (idx, nd, dim);
+  octave::invalid_index e (idx, nd, dim);
 
-    throw e;
+  throw e;
 }
 
 void
 gripe_invalid_index (octave_idx_type n, octave_idx_type nd,
                      octave_idx_type dim, const std::string& var)
 {
   std::ostringstream buf;
   buf << n + 1;
@@ -174,93 +177,96 @@ gripe_invalid_index (double n, octave_id
 
   gripe_invalid_index (buf.str (), nd, dim, var);
 
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 #  pragma GCC diagnostic pop
 #endif
 }
 
-// Gripe and exception for read access beyond the bounds of an array.
-
-class out_of_range : public index_exception
+namespace octave
 {
-public:
+  // Gripe and exception for read access beyond the bounds of an array.
 
-  out_of_range (const std::string& value, octave_idx_type nd_in,
-                octave_idx_type dim_in)
-    : index_exception (value, nd_in, dim_in), extent (0)
-  { }
+  class out_of_range : public index_exception
+  {
+  public:
 
-  std::string details (void) const
-  {
-    std::string expl;
+    out_of_range (const std::string& value, octave_idx_type nd_in,
+                  octave_idx_type dim_in)
+      : index_exception (value, nd_in, dim_in), extent (0)
+    { }
 
-    if (nd >= size.ndims ())   // if not an index slice
-      {
-        if (var != "")
-          expl = "but " + var + " has size ";
-        else
-          expl = "but object has size ";
+    std::string details (void) const
+    {
+      std::string expl;
+
+      if (nd >= size.ndims ())   // if not an index slice
+        {
+          if (var != "")
+            expl = "but " + var + " has size ";
+          else
+            expl = "but object has size ";
 
-        expl = expl + size.str ('x');
-      }
-    else
-      {
-        std::ostringstream buf;
-        buf << extent;
-        expl = "out of bound " + buf.str ();
-      }
+          expl = expl + size.str ('x');
+        }
+      else
+        {
+          std::ostringstream buf;
+          buf << extent;
+          expl = "out of bound " + buf.str ();
+        }
 
-    return expl;
-  }
+      return expl;
+    }
 
-  // ID of error to throw.
-  const char *err_id (void) const
-  {
-    return error_id_index_out_of_bounds;
-  }
+    // ID of error to throw.
+    const char *err_id (void) const
+    {
+      return error_id_index_out_of_bounds;
+    }
 
-  void set_size (const dim_vector& size_in) { size = size_in; }
+    void set_size (const dim_vector& size_in) { size = size_in; }
+
+    void set_extent (octave_idx_type ext) { extent = ext; }
 
-  void set_extent (octave_idx_type ext) { extent = ext; }
+  private:
 
-private:
+    // Dimension of object being accessed.
+    dim_vector size;
 
-  // Dimension of object being accessed.
-  dim_vector size;
-
-  // Length of dimension being accessed.
-  octave_idx_type extent;
-};
+    // Length of dimension being accessed.
+    octave_idx_type extent;
+  };
+}
 
 // Complain of an index that is out of range, but we don't know matrix size
 void
 gripe_index_out_of_range (int nd, int dim, octave_idx_type idx,
                           octave_idx_type ext)
 {
   std::ostringstream buf;
   buf << idx;
-  out_of_range e (buf.str (), nd, dim);
+  octave::out_of_range e (buf.str (), nd, dim);
 
   e.set_extent (ext);
   // ??? Make details method give extent not size.
   e.set_size (dim_vector (1, 1, 1, 1, 1, 1,1));
 
   throw e;
 }
 
 // Complain of an index that is out of range
 void
 gripe_index_out_of_range (int nd, int dim, octave_idx_type idx,
                           octave_idx_type ext, const dim_vector& d)
 {
   std::ostringstream buf;
   buf << idx;
-  out_of_range e (buf.str (), nd, dim);
+  octave::out_of_range e (buf.str (), nd, dim);
 
   e.set_extent (ext);
   e.set_size (d);
 
   throw e;
 }
 
 void
diff --git a/liboctave/util/lo-array-gripes.h b/liboctave/util/lo-array-gripes.h
--- a/liboctave/util/lo-array-gripes.h
+++ b/liboctave/util/lo-array-gripes.h
@@ -26,76 +26,76 @@ along with Octave; see the file COPYING.
 #define octave_lo_array_gripes_h 1
 
 #include "octave-config.h"
 
 #include "lo-array-errwarn.h"
 #include "dim-vector.h"
 #include "quit.h"
 
-OCTAVE_DEPRECATED ("use 'err_nan_to_logical_conversion' instead")
+OCTAVE_DEPRECATED ("use 'octave::err_nan_to_logical_conversion' instead")
 OCTAVE_NORETURN OCTAVE_API extern void
 gripe_nan_to_logical_conversion (void);
 
-OCTAVE_DEPRECATED ("use 'err_nan_to_character_conversion' instead")
+OCTAVE_DEPRECATED ("use 'octave::err_nan_to_character_conversion' instead")
 OCTAVE_NORETURN OCTAVE_API extern void
 gripe_nan_to_character_conversion (void);
 
-OCTAVE_DEPRECATED ("use 'err_nonconformant' instead")
+OCTAVE_DEPRECATED ("use 'octave::err_nonconformant' instead")
 OCTAVE_NORETURN OCTAVE_API extern void
 gripe_nonconformant (const char *op,
                      octave_idx_type op1_len,
                      octave_idx_type op2_len);
 
-OCTAVE_DEPRECATED ("use 'err_nonconformant' instead")
+OCTAVE_DEPRECATED ("use 'octave::err_nonconformant' instead")
 OCTAVE_NORETURN OCTAVE_API extern void
 gripe_nonconformant (const char *op,
                      octave_idx_type op1_nr, octave_idx_type op1_nc,
                      octave_idx_type op2_nr, octave_idx_type op2_nc);
 
-OCTAVE_DEPRECATED ("use 'err_nonconformant' instead")
+OCTAVE_DEPRECATED ("use 'octave::err_nonconformant' instead")
 OCTAVE_NORETURN OCTAVE_API extern void
 gripe_nonconformant (const char *op, const dim_vector& op1_dims,
                      const dim_vector& op2_dims);
 
-OCTAVE_DEPRECATED ("use 'err_index_out_of_range' instead")
+OCTAVE_DEPRECATED ("use 'octave::err_index_out_of_range' instead")
 OCTAVE_NORETURN OCTAVE_API extern void
 gripe_index_out_of_range (int nd, int dim,
                           octave_idx_type iext, octave_idx_type ext,
                           const dim_vector& d);
 
-OCTAVE_DEPRECATED ("use 'err_index_out_of_range' instead")
+OCTAVE_DEPRECATED ("use 'octave::err_index_out_of_range' instead")
 OCTAVE_NORETURN OCTAVE_API extern void
 gripe_index_out_of_range (int nd, int dim,
                           octave_idx_type iext, octave_idx_type ext);
 
-OCTAVE_DEPRECATED ("use 'err_del_index_out_of_range' instead")
+OCTAVE_DEPRECATED ("use 'octave::err_del_index_out_of_range' instead")
 OCTAVE_NORETURN OCTAVE_API extern void
 gripe_del_index_out_of_range (bool is1d, octave_idx_type iext,
                               octave_idx_type ext);
 
-OCTAVE_DEPRECATED ("use 'err_invalid_index' instead")
+OCTAVE_DEPRECATED ("use 'octave::err_invalid_index' instead")
 OCTAVE_NORETURN OCTAVE_API extern void
 gripe_invalid_index (double, octave_idx_type nd = 0,
                      octave_idx_type dim = 0,
                      const std::string& var = "");
 
-OCTAVE_DEPRECATED ("use 'err_invalid_index' instead")
+OCTAVE_DEPRECATED ("use 'octave::err_invalid_index' instead")
 OCTAVE_NORETURN OCTAVE_API extern void
 gripe_invalid_index (octave_idx_type n, octave_idx_type nd = 0,
                      octave_idx_type dim = 0,
                      const std::string& var = "");
 
-OCTAVE_DEPRECATED ("use 'err_invalid_index' instead")
+OCTAVE_DEPRECATED ("use 'octave::err_invalid_index' instead")
 OCTAVE_NORETURN OCTAVE_API extern void
 gripe_invalid_index (const std::string& idx, octave_idx_type nd = 0,
                      octave_idx_type dim = 0,
                      const std::string& var = "");
 
-OCTAVE_DEPRECATED ("use 'err_invalid_resize' instead")
+OCTAVE_DEPRECATED ("use 'octave::err_invalid_resize' instead")
 OCTAVE_NORETURN OCTAVE_API extern void
 gripe_invalid_resize (void);
 
-OCTAVE_DEPRECATED ("use 'err_singular_matrix' instead")
+OCTAVE_DEPRECATED ("use 'octave::err_singular_matrix' instead")
 OCTAVE_API extern void
 gripe_singular_matrix (double rcond = 0.0);
 
 #endif
diff --git a/liboctave/util/oct-binmap.h b/liboctave/util/oct-binmap.h
--- a/liboctave/util/oct-binmap.h
+++ b/liboctave/util/oct-binmap.h
@@ -172,17 +172,17 @@ binmap (const Array<T>& xa, const Array<
   dim_vector yad = ya.dims ();
   if (xa.numel () == 1)
     return binmap<U, T, R, F> (xa(0), ya, fcn);
   else if (ya.numel () == 1)
     return binmap<U, T, R, F> (xa, ya(0), fcn);
   else if (xad != yad)
     {
       if (! is_valid_bsxfun (name, xad, yad))
-        err_nonconformant (name, xad, yad);
+        octave::err_nonconformant (name, xad, yad);
 
       bsxfun_wrapper<U, T, R, F>::set_f(fcn);
       return do_bsxfun_op (xa, ya,
                            bsxfun_wrapper<U, T, R, F>::op_mm,
                            bsxfun_wrapper<U, T, R, F>::op_sm,
                            bsxfun_wrapper<U, T, R, F>::op_ms);
     }
 
@@ -280,17 +280,17 @@ template <typename U, typename T, typena
 Sparse<U>
 binmap (const Sparse<T>& xs, const Sparse<R>& ys, F fcn, const char *name)
 {
   if (xs.rows () == 1 && xs.cols () == 1)
     return binmap<U, T, R, F> (xs(0,0), ys, fcn);
   else if (ys.rows () == 1 && ys.cols () == 1)
     return binmap<U, T, R, F> (xs, ys(0,0), fcn);
   else if (xs.dims () != ys.dims ())
-    err_nonconformant (name, xs.dims (), ys.dims ());
+    octave::err_nonconformant (name, xs.dims (), ys.dims ());
 
   T xzero = T ();
   R yzero = R ();
   U fz = fcn (xzero, yzero);
 
   if (fz == U ())
     {
       // Sparsity-preserving function.  Do it efficiently.
