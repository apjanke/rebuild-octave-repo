# HG changeset patch
# User jwe
# Date 1150434582 0
#      Fri Jun 16 05:09:42 2006 +0000
# Node ID 2a6cb4ed8f1ec746fdcd20add6fde8b7b00ea8ff
# Parent  b645066d40ada3afc9c6f4d197119683e8efa59e
[project @ 2006-06-16 05:09:41 by jwe]

diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,115 @@
+2006-06-16  John W. Eaton  <jwe@octave.org>
+
+	* parse.y (%union): New type, anon_fcn_handle_type.
+	(anon_fcn_handle): Now anon_fcn_handle_type, not tree_constant_type.
+	(make_anon_fcn_handle):	Return tree_anon_fcn_handle, not tree_constant.
+
+	* comment-list.cc (octave_comment_list::dup): New function.
+	* comment-list.h: Provide decl.
+
+	* pt-cmd.cc (tree_no_op_command::dup): New function.
+	* pt-cmd.h: Provide decl.
+	(tree_command::dup): New pure virtual function.
+
+	* pt-loop.cc (tree_while_command::dup, tree_do_until_command::dup,
+	tree_simple_for_command::dup, tree_complex_for_command::dup):
+	New functions.
+	* pt-loop.h: Provide decls.
+
+	* pt-jump.cc (tree_break_command::dup, tree_continue_command::dup,
+	tree_return_command::dup): New functions.
+	* pt-jump.h: Provide decls.
+
+	* pt-except.cc (tree_try_catch_command::dup,
+	tree_unwind_protect_command::dup): New functions.
+	* pt-except.h: Provide decls.
+
+	* pt-select.cc (tree_if_clause::dup, tree_if_command_list::dup,
+	tree_if_command::dup, tree_switch_case::dup,
+	tree_switch_case_list::dup, tree_switch_command::dup):
+	New functions.
+	* pt-select.h: Provide decls.
+
+	* pt-decl.cc (tree_decl_elt::dup, tree_decl_init_list::dup,
+	tree_global_command::dup, tree_static_command::dup): New functions.
+	* pt-decl.h: Provide decls.
+	
+	* pt-exp.h (tree_expression::copy_base): New function.
+	(tree_expression::dup): New pure virtual function.
+	
+	* pt-fcn-handle.cc, pt-fcn-handle.h (tree_anon_fcn_handle): New class.
+
+	* pt-fcn-handle.cc (tree_function_handle::dup): New function.
+	* pt-fcn-handle.h: Provide decl.
+
+	* pt-colon.cc (tree_colon_expression::dup): New function.
+	* pt-colon.h: Provide decl.
+	(tree_colon_expression::tree_colon_expression (tree_expression *,
+	tree_expression *, tree_expression *, int, int)): New constructor.
+	
+	* pt-const.cc (tree_constant::dup): New function.
+	(tree_constant::tree_constant (const octave_value&, const
+	std::string&, int, int)): New constructor.
+	* pt-const.h: Provide decls.
+
+	* pt-idx.cc (tree_index_expression::dup): New functoin.
+	(tree_index_expression::tree_index_expression (int, int)):
+	New constructor.
+	* pt-idx.h: Provide decls.
+
+	* pt-arg-list.cc (tree_argument_list::dup): New function.
+	* pt-arg-list.h: Provide decl.
+
+	* pt-id.cc (tree_identifier::dup): New function.
+	* pt-id.h: Provide decl.
+
+	* pt-cell.cc (tree_cell::dup): New function.
+	* pt-cell.h: Provide decl.
+
+	* pt-mat.cc (tree_matrix::dup): New function.
+	* pt-mat.h: Provide decl.
+
+	* pt-assign.cc (tree_simple_assignment::dup,
+	tree_multi_assignment::dup): New functions.
+	* pt-assign.h: Provide decls.
+
+	* pt-binop.cc (tree_binary_expression::dup,
+	tree_boolean_expression::dup): New functions.
+	* pt-binop.h: Provide decls.
+	
+	* pt-unop.cc (tree_prefix_expression::dup,
+	tree_postfix_expression::dup): New functions.
+	* pt-unop.h: Provide decls.
+
+	* pt-stmt.cc (tree_statement::dup, tree_statement_list::dup):
+	New functions.
+	* pt-stmt.h: Provide decls.
+
+	* pt-misc.cc (tree_parameter_list::dup,
+	tree_return_list::dup): New functions.
+	* pt-misc.h: Provide decls.
+
+	* symtab.cc (symbol_table::dup, symbol_table::inherit,
+	symbol_record:is_automatic_variable): New functions.
+	* symtab.h: Provide decls.
+	(symbol_record::automatic_variable): New data member.
+	(symbol_record::symbol_record): Initialize it.
+	(symbol_record::mark_as_automatic_variable): New function.
+
+	* pt-walk.h (tree_walker::visit_anon_fcn_handle):
+	New pure virtual function.
+	* pt-pr-code.cc (tree_print_code::visit_anon_fcn_handle): New function.
+	* pt-pr-code.h: Provide decl.
+	* pt-bp.cc (tree_breakpoint::visit_anon_fcn_handle): New function.
+	* pt-bp.h: Provide decl.
+	* pt-check.cc (tree_checker::visit_anon_fcn_handle): New function.
+	* pt-check.h: Provide decl.
+
 2006-06-13  John W. Eaton  <jwe@octave.org>
 
 	* pt-stmt.cc (tree_statement_list::eval): Revise previous change
 	to preserve return-last-value-computed semantics.
 
 	* DLD-FUNCTIONS/fsolve.cc (hybrd_info_to_fsolve_info):
 	Warn about invalid values of INFO from MINPACK instead of calling
 	panic_impossible.
diff --git a/src/comment-list.cc b/src/comment-list.cc
--- a/src/comment-list.cc
+++ b/src/comment-list.cc
@@ -27,16 +27,31 @@ 02110-1301, USA.
 
 #include "lo-utils.h"
 
 #include "comment-list.h"
 #include "error.h"
 
 octave_comment_buffer *octave_comment_buffer::instance = 0;
 
+octave_comment_list *
+octave_comment_list::dup (void)
+{
+  octave_comment_list *new_cl = new octave_comment_list ();
+
+  for (iterator p = begin (); p != end (); p++)
+    {
+      octave_comment_elt elt = *p;
+
+      new_cl->append (elt);
+    }
+
+  return new_cl;
+}
+
 bool
 octave_comment_buffer::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
     instance = new octave_comment_buffer ();
 
diff --git a/src/comment-list.h b/src/comment-list.h
--- a/src/comment-list.h
+++ b/src/comment-list.h
@@ -81,31 +81,35 @@ private:
   comment_type typ;
 };
 
 class
 octave_comment_list : public octave_base_list<octave_comment_elt>
 {
 public:
 
+  octave_comment_list (void) { }
+
   void append (const octave_comment_elt& elt)
     { octave_base_list<octave_comment_elt>::append (elt); }
 
   void append (const std::string& s,
 	       octave_comment_elt::comment_type t = octave_comment_elt::unknown)
     { append (octave_comment_elt (s, t)); }
+
+  octave_comment_list *dup (void);
 };
 
 class
 octave_comment_buffer
 {
 public:
 
   octave_comment_buffer (void)
-    : comment_list (new octave_comment_list) { }
+    : comment_list (new octave_comment_list ()) { }
   
   static bool instance_ok (void);
 
   static void append
     (const std::string& s,
      octave_comment_elt::comment_type t = octave_comment_elt::unknown);
 
   static octave_comment_list *get_comment (void);
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -153,17 +153,17 @@ finish_colon_expression (tree_colon_expr
 static tree_constant *
 make_constant (int op, token *tok_val);
 
 // Build a function handle.
 static tree_fcn_handle *
 make_fcn_handle (token *tok_val);
 
 // Build an anonymous function handle.
-static tree_constant *
+static tree_anon_fcn_handle *
 make_anon_fcn_handle (tree_parameter_list *param_list, tree_statement *stmt);
 
 // Build a binary expression.
 static tree_expression *
 make_binary_op (int op, tree_expression *op1, token *tok_val,
 		tree_expression *op2);
 
 // Build a boolean expression.
@@ -342,16 +342,17 @@ set_stmt_print_flag (tree_statement_list
   // Types for the nonterminals we generate.
   char sep_type;
   tree *tree_type;
   tree_matrix *tree_matrix_type;
   tree_cell *tree_cell_type;
   tree_expression *tree_expression_type;
   tree_constant *tree_constant_type;
   tree_fcn_handle *tree_fcn_handle_type;
+  tree_anon_fcn_handle *tree_anon_fcn_handle_type;
   tree_identifier *tree_identifier_type;
   tree_index_expression *tree_index_expression_type;
   tree_colon_expression *tree_colon_expression_type;
   tree_argument_list *tree_argument_list_type;
   tree_parameter_list *tree_parameter_list_type;
   tree_command *tree_command_type;
   tree_if_command *tree_if_command_type;
   tree_if_clause *tree_if_clause_type;
@@ -396,17 +397,18 @@ set_stmt_print_flag (tree_statement_list
 %token END_OF_INPUT LEXICAL_ERROR
 %token FCN VARARGIN VARARGOUT
 %token CLOSE_BRACE
 
 // Nonterminals we construct.
 %type <comment_type> stash_comment function_beg
 %type <sep_type> sep_no_nl opt_sep_no_nl sep opt_sep
 %type <tree_type> input
-%type <tree_constant_type> string constant magic_colon anon_fcn_handle
+%type <tree_constant_type> string constant magic_colon
+%type <tree_anon_fcn_handle_type> anon_fcn_handle
 %type <tree_fcn_handle_type> fcn_handle
 %type <tree_matrix_type> matrix_rows matrix_rows1
 %type <tree_cell_type> cell_rows cell_rows1
 %type <tree_expression_type> matrix cell
 %type <tree_expression_type> primary_expr postfix_expr prefix_expr binary_expr
 %type <tree_expression_type> simple_expr colon_expr assign_expr expression
 %type <tree_identifier_type> identifier fcn_name
 %type <octave_user_function_type> function1 function2 function3
@@ -1751,29 +1753,38 @@ make_fcn_handle (token *tok_val)
 
   tree_fcn_handle *retval = new tree_fcn_handle (tok_val->text (), l, c);
 
   return retval;
 }
 
 // Make an anonymous function handle.
 
-static tree_constant *
+static tree_anon_fcn_handle *
 make_anon_fcn_handle (tree_parameter_list *param_list, tree_statement *stmt)
 {
   // FIXME -- need to get these from the location of the @ symbol.
 
   int l = -1;
   int c = -1;
 
   tree_parameter_list *ret_list = 0;
 
+  symbol_table *fcn_sym_tab = curr_sym_tab;
+
+  if (symtab_context.empty ())
+    panic_impossible ();
+
+  curr_sym_tab = symtab_context.top ();
+
+  symtab_context.pop ();
+
   if (stmt && stmt->is_expression ())
     {
-      symbol_record *sr = curr_sym_tab->lookup ("__retval__", true);
+      symbol_record *sr = fcn_sym_tab->lookup ("__retval__", true);
 
       tree_expression *e = stmt->expression ();
 
       tree_identifier *id = new tree_identifier (sr);
 
       tree_simple_assignment *asn = new tree_simple_assignment (id, e);
 
       stmt->set_expression (asn);
@@ -1788,28 +1799,18 @@ make_anon_fcn_handle (tree_parameter_lis
 
       ret_list = new tree_parameter_list (id);
     }
 
   tree_statement_list *body = new tree_statement_list (stmt);
 
   body->mark_as_function_body ();
 
-  octave_value fcn (new octave_user_function (param_list, ret_list,
-					      body, curr_sym_tab));
-
-  if (symtab_context.empty ())
-    panic_impossible ();
-
-  curr_sym_tab = symtab_context.top ();
-  symtab_context.pop ();
-
-  octave_value fh (new octave_fcn_handle (fcn, "@<anonymous>"));
-
-  tree_constant *retval = new tree_constant (fh, l, c);
+  tree_anon_fcn_handle *retval
+    = new tree_anon_fcn_handle (param_list, ret_list, body, fcn_sym_tab, l, c);
 
   return retval;
 }
 
 static void
 maybe_warn_associativity_change (tree_expression *op)
 {
   if (op->paren_count () == 0 && op->is_binary_expression ())
diff --git a/src/pt-arg-list.cc b/src/pt-arg-list.cc
--- a/src/pt-arg-list.cc
+++ b/src/pt-arg-list.cc
@@ -248,16 +248,34 @@ tree_argument_list::get_arg_names (void)
       tree_expression *elt = *p;
 
       retval(k++) = elt->str_print_code ();
     }
 
   return retval;
 }
 
+tree_argument_list *
+tree_argument_list::dup (symbol_table *sym_tab)
+{
+  tree_argument_list *new_list = new tree_argument_list ();
+
+  new_list->list_includes_magic_end = list_includes_magic_end;
+  new_list->simple_assign_lhs = simple_assign_lhs;
+
+  for (iterator p = begin (); p != end (); p++)
+    {
+      tree_expression *elt = *p;
+
+      new_list->append (elt ? elt->dup (sym_tab) : 0);
+    }
+
+  return new_list;
+}
+
 void
 tree_argument_list::accept (tree_walker& tw)
 {
   tw.visit_argument_list (*this);
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/pt-arg-list.h b/src/pt-arg-list.h
--- a/src/pt-arg-list.h
+++ b/src/pt-arg-list.h
@@ -73,16 +73,18 @@ public:
   bool all_elements_are_constant (void) const;
 
   octave_value_list convert_to_const_vector (const octave_value *object = 0);
 
   std::list<octave_lvalue> lvalue_list (void);
 
   string_vector get_arg_names (void) const;
 
+  tree_argument_list *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   bool list_includes_magic_end;
 
   bool simple_assign_lhs;
 
diff --git a/src/pt-assign.cc b/src/pt-assign.cc
--- a/src/pt-assign.cc
+++ b/src/pt-assign.cc
@@ -153,16 +153,29 @@ tree_simple_assignment::eval_error (void
 }
 
 std::string
 tree_simple_assignment::oper (void) const
 {
   return octave_value::assign_op_as_string (etype);
 }
 
+tree_expression *
+tree_simple_assignment::dup (symbol_table *sym_tab)
+{
+  tree_simple_assignment *new_sa
+    = new tree_simple_assignment (lhs ? lhs->dup (sym_tab) : 0,
+				  rhs ? rhs->dup (sym_tab) : 0,
+				  preserve, etype);
+
+  new_sa->copy_base (*this);
+
+  return new_sa;
+}
+
 void
 tree_simple_assignment::accept (tree_walker& tw)
 {
   tw.visit_simple_assignment (*this);
 }
 
 // Multi-valued assignment expressions.
 
@@ -354,16 +367,29 @@ tree_multi_assignment::eval_error (void)
 }
 
 std::string
 tree_multi_assignment::oper (void) const
 {
   return octave_value::assign_op_as_string (etype);
 }
 
+tree_expression *
+tree_multi_assignment::dup (symbol_table *sym_tab)
+{
+  tree_multi_assignment *new_ma
+    = new tree_multi_assignment (lhs ? lhs->dup (sym_tab) : 0,
+				 rhs ? rhs->dup (sym_tab) : 0,
+				 preserve, etype);
+
+  new_ma->copy_base (*this);
+
+  return new_ma;
+}
+
 void
 tree_multi_assignment::accept (tree_walker& tw)
 {
   tw.visit_multi_assignment (*this);
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/pt-assign.h b/src/pt-assign.h
--- a/src/pt-assign.h
+++ b/src/pt-assign.h
@@ -69,16 +69,18 @@ public:
   void eval_error (void);
 
   std::string oper (void) const;
 
   tree_expression *left_hand_side (void) { return lhs; }
 
   tree_expression *right_hand_side (void) { return rhs; }
 
+  tree_expression *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   void do_assign (octave_lvalue& ult, const octave_value_list& args,
 		  const octave_value& rhs_val);
 
   void do_assign (octave_lvalue& ult, const octave_value& rhs_val);
@@ -137,16 +139,18 @@ public:
   void eval_error (void);
 
   std::string oper (void) const;
 
   tree_argument_list *left_hand_side (void) { return lhs; }
 
   tree_expression *right_hand_side (void) { return rhs; }
 
+  tree_expression *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   // The left hand side of the assignment.
   tree_argument_list *lhs;
 
   // The right hand side of the assignment.
diff --git a/src/pt-binop.cc b/src/pt-binop.cc
--- a/src/pt-binop.cc
+++ b/src/pt-binop.cc
@@ -100,16 +100,29 @@ tree_binary_expression::eval_error (void
 }
 
 std::string
 tree_binary_expression::oper (void) const
 {
   return octave_value::binary_op_as_string (etype);
 }
 
+tree_expression *
+tree_binary_expression::dup (symbol_table *sym_tab)
+{
+  tree_binary_expression *new_be
+    = new tree_binary_expression (op_lhs ? op_lhs->dup (sym_tab) : 0,
+				  op_rhs ? op_rhs->dup (sym_tab) : 0,
+				  line (), column (), etype);
+
+  new_be->copy_base (*this);
+
+  return new_be;
+}
+
 void
 tree_binary_expression::accept (tree_walker& tw)
 {
   tw.visit_binary_expression (*this);
 }
 
 // Boolean expressions.
  
@@ -214,13 +227,26 @@ tree_boolean_expression::oper (void) con
 
     default:
       break;
     }
 
   return retval;
 }
 
+tree_expression *
+tree_boolean_expression::dup (symbol_table *sym_tab)
+{
+  tree_boolean_expression *new_be
+    = new tree_boolean_expression (op_lhs ? op_lhs->dup (sym_tab) : 0,
+				   op_rhs ? op_rhs->dup (sym_tab) : 0,
+				   line (), column (), etype);
+
+  new_be->copy_base (*this);
+
+  return new_be;
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pt-binop.h b/src/pt-binop.h
--- a/src/pt-binop.h
+++ b/src/pt-binop.h
@@ -77,16 +77,18 @@ public:
 
   std::string oper (void) const;
 
   octave_value::binary_op op_type (void) const { return etype; }
 
   tree_expression *lhs (void) { return op_lhs; }
   tree_expression *rhs (void) { return op_rhs; }
 
+  tree_expression *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 protected:
 
   // The operands for the expression.
   tree_expression *op_lhs;
   tree_expression *op_rhs;
 
@@ -132,16 +134,18 @@ public:
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   std::string oper (void) const;
 
   type op_type (void) const { return etype; }
 
+  tree_expression *dup (symbol_table *sym_tab);
+
 private:
 
   // The type of the expression.
   type etype;
 
   // No copying!
 
   tree_boolean_expression (const tree_boolean_expression&);
diff --git a/src/pt-bp.cc b/src/pt-bp.cc
--- a/src/pt-bp.cc
+++ b/src/pt-bp.cc
@@ -425,16 +425,26 @@ tree_breakpoint::visit_no_op_command (tr
 {
   if (found)
     return;
 
   if (cmd.line () >= line)
     take_action (cmd);
 }
 
+void
+tree_breakpoint::visit_anon_fcn_handle (tree_anon_fcn_handle& afh)
+{
+  if (found)
+    return;
+
+  if (afh.line () >= line)
+    take_action (afh);
+}
+
 void 
 tree_breakpoint::visit_constant (tree_constant& cmd)
 {
   if (found)
     return;
 
   if (cmd.line () >= line)
     take_action (cmd);
diff --git a/src/pt-bp.h b/src/pt-bp.h
--- a/src/pt-bp.h
+++ b/src/pt-bp.h
@@ -89,16 +89,18 @@ tree_breakpoint : public tree_walker
   void visit_matrix (tree_matrix&);
 
   void visit_cell (tree_cell&);
 
   void visit_multi_assignment (tree_multi_assignment&);
 
   void visit_no_op_command (tree_no_op_command&);
 
+  void visit_anon_fcn_handle (tree_anon_fcn_handle&);
+
   void visit_constant (tree_constant&);
 
   void visit_fcn_handle (tree_fcn_handle&);
 
   void visit_parameter_list (tree_parameter_list&);
 
   void visit_postfix_expression (tree_postfix_expression&);
 
diff --git a/src/pt-cell.cc b/src/pt-cell.cc
--- a/src/pt-cell.cc
+++ b/src/pt-cell.cc
@@ -96,16 +96,33 @@ tree_cell::rvalue (int nargout)
   if (nargout > 1)
     error ("invalid number of output arguments for cell array");
   else
     retval = rvalue ();
 
   return retval;
 }
 
+tree_expression *
+tree_cell::dup (symbol_table *sym_tab)
+{
+  tree_cell *new_cell = new tree_cell (0, line (), column ());
+
+  for (iterator p = begin (); p != end (); p++)
+    {
+      tree_argument_list *elt = *p;
+
+      append (elt ? elt->dup (sym_tab) : 0);
+    }
+
+  new_cell->copy_base (*this);
+
+  return new_cell;
+}
+
 void
 tree_cell::accept (tree_walker& tw)
 {
   tw.visit_cell (*this);
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/pt-cell.h b/src/pt-cell.h
--- a/src/pt-cell.h
+++ b/src/pt-cell.h
@@ -47,16 +47,18 @@ public:
   ~tree_cell (void) { }
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int);
 
+  tree_expression *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_cell (const tree_cell&);
 
diff --git a/src/pt-check.cc b/src/pt-check.cc
--- a/src/pt-check.cc
+++ b/src/pt-check.cc
@@ -301,16 +301,21 @@ tree_checker::visit_multi_assignment (tr
 }
 
 void
 tree_checker::visit_no_op_command (tree_no_op_command& /* cmd */)
 {
 }
 
 void
+tree_checker::visit_anon_fcn_handle (tree_anon_fcn_handle& /* afh */)
+{
+}
+
+void
 tree_checker::visit_constant (tree_constant& /* val */)
 {
 }
 
 void
 tree_checker::visit_fcn_handle (tree_fcn_handle& /* fh */)
 {
 }
diff --git a/src/pt-check.h b/src/pt-check.h
--- a/src/pt-check.h
+++ b/src/pt-check.h
@@ -73,16 +73,18 @@ public:
   void visit_matrix (tree_matrix&);
 
   void visit_cell (tree_cell&);
 
   void visit_multi_assignment (tree_multi_assignment&);
 
   void visit_no_op_command (tree_no_op_command&);
 
+  void visit_anon_fcn_handle (tree_anon_fcn_handle&);
+
   void visit_constant (tree_constant&);
 
   void visit_fcn_handle (tree_fcn_handle&);
 
   void visit_parameter_list (tree_parameter_list&);
 
   void visit_postfix_expression (tree_postfix_expression&);
 
diff --git a/src/pt-cmd.cc b/src/pt-cmd.cc
--- a/src/pt-cmd.cc
+++ b/src/pt-cmd.cc
@@ -25,16 +25,22 @@ 02110-1301, USA.
 #include <config.h>
 #endif
 
 #include "pt-cmd.h"
 #include "pt-walk.h"
 
 // No-op.
 
+tree_command *
+tree_no_op_command::dup (symbol_table *sym_tab)
+{
+  return new tree_no_op_command (orig_cmd, line (), column ());
+}
+
 void
 tree_no_op_command::accept (tree_walker& tw)
 {
   tw.visit_no_op_command (*this);
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/pt-cmd.h b/src/pt-cmd.h
--- a/src/pt-cmd.h
+++ b/src/pt-cmd.h
@@ -22,16 +22,17 @@ 02110-1301, USA.
 */
 
 #if !defined (octave_tree_cmd_h)
 #define octave_tree_cmd_h 1
 
 #include <string>
 
 class tree_walker;
+class symbol_table;
 
 #include "pt.h"
 #include "pt-bp.h"
 
 // A base class for commands.
 
 class
 tree_command : public tree
@@ -40,16 +41,18 @@ public:
 
   tree_command (int l = -1, int c = -1)
     : tree (l, c) { }
 
   virtual ~tree_command (void) { }
 
   virtual void eval (void) = 0;
 
+  virtual tree_command *dup (symbol_table *) = 0;
+
 private:
 
   // No copying!
 
   tree_command (const tree_command&);
 
   tree_command& operator = (const tree_command&);
 };
@@ -63,16 +66,18 @@ public:
 
   tree_no_op_command (const std::string& cmd = "no_op", int l = -1, int c = -1)
     : tree_command (l, c), orig_cmd (cmd) { }
 
   ~tree_no_op_command (void) { }
 
   void eval (void) { MAYBE_DO_BREAKPOINT; }
 
+  tree_command *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
   std::string original_command (void) { return orig_cmd; }
 
 private:
 
   std::string orig_cmd;
 
diff --git a/src/pt-colon.cc b/src/pt-colon.cc
--- a/src/pt-colon.cc
+++ b/src/pt-colon.cc
@@ -204,16 +204,30 @@ int
 tree_colon_expression::column (void) const
 {
   return (op_base ? op_base->column ()
 	  : (op_increment ? op_increment->column ()
 	     : (op_limit ? op_limit->column ()
 		: -1)));
 }
 
+tree_expression *
+tree_colon_expression::dup (symbol_table *sym_tab)
+{
+  tree_colon_expression *new_ce
+    = new tree_colon_expression (op_base ? op_base->dup (sym_tab) : 0,
+				 op_limit ? op_limit->dup (sym_tab) : 0,
+				 op_increment ? op_increment->dup (sym_tab) : 0,
+				 line (), column ());
+
+  new_ce->copy_base (*new_ce);
+
+  return new_ce;
+}
+
 void
 tree_colon_expression::accept (tree_walker& tw)
 {
   tw.visit_colon_expression (*this);
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/pt-colon.h b/src/pt-colon.h
--- a/src/pt-colon.h
+++ b/src/pt-colon.h
@@ -44,16 +44,21 @@ public:
   tree_colon_expression (int l = -1, int c = -1)
     : tree_expression (l, c), op_base (0), op_limit (0),
       op_increment (0), save_base (false) { }
 
   tree_colon_expression (tree_expression *e, int l = -1, int c = -1)
     : tree_expression (l, c), op_base (e), op_limit (0),
       op_increment (0), save_base (false) { }
 
+  tree_colon_expression (tree_expression *bas, tree_expression *lim,
+			 tree_expression *inc, int l = -1, int c = -1)
+    : tree_expression (l, c), op_base (bas), op_limit (lim),
+      op_increment (inc), save_base (false) { }
+
   ~tree_colon_expression (void)
     {
       if (! save_base)
 	delete op_base;
 
       delete op_limit;
       delete op_increment;
     }
@@ -81,16 +86,18 @@ public:
 
   tree_expression *limit (void) { return op_limit; }
 
   tree_expression *increment (void) { return op_increment; }
 
   int line (void) const;
   int column (void) const;
 
+  tree_expression *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   // The components of the expression.
   tree_expression *op_base;
   tree_expression *op_limit;
   tree_expression *op_increment;
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -65,16 +65,27 @@ tree_constant::rvalue (int nargout)
   if (nargout > 1)
     error ("invalid number of output arguments for constant expression");
   else
     retval = rvalue ();
 
   return retval;
 }
 
+tree_expression *
+tree_constant::dup (symbol_table *sym_tab)
+{
+  tree_constant *new_tc
+    = new tree_constant (val, orig_text, line (), column ());
+
+  new_tc->copy_base (*this);
+
+  return new_tc;
+}
+
 void
 tree_constant::accept (tree_walker& tw)
 {
   tw.visit_constant (*this);
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/pt-const.h b/src/pt-const.h
--- a/src/pt-const.h
+++ b/src/pt-const.h
@@ -44,16 +44,20 @@ tree_constant : public tree_expression
 public:
 
   tree_constant (int l = -1, int c = -1)
     : tree_expression (l, c), val (), orig_text () { }
 
   tree_constant (const octave_value& v, int l = -1, int c = -1)
     : tree_expression (l, c), val (v), orig_text () { }
 
+  tree_constant (const octave_value& v, const std::string& ot,
+		 int l = -1, int c = -1)
+    : tree_expression (l, c), val (v), orig_text (ot) { }
+
   ~tree_constant (void) { }
 
   bool has_magic_end (void) const { return false; }
 
   void *operator new (size_t size) { return allocator.alloc (size); }
 
   void operator delete (void *p, size_t size) { allocator.free (p, size); }
 
@@ -74,16 +78,18 @@ public:
   octave_value rvalue (void)
     {
       MAYBE_DO_BREAKPOINT;
       return val;
     }
 
   octave_value_list rvalue (int nargout);
 
+  tree_expression *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
   // Store the original text corresponding to this constant for later
   // pretty printing.
 
   void stash_original_text (const std::string& s) { orig_text = s; }
 
   std::string original_text (void) const { return orig_text; }
diff --git a/src/pt-decl.cc b/src/pt-decl.cc
--- a/src/pt-decl.cc
+++ b/src/pt-decl.cc
@@ -40,16 +40,23 @@ 02110-1301, USA.
 // Declarations (global, static, etc.).
 
 tree_decl_elt::~tree_decl_elt (void)
 {
   delete id;
   delete expr;
 }
 
+tree_decl_elt *
+tree_decl_elt::dup (symbol_table *sym_tab)
+{
+  return new tree_decl_elt (id ? id->dup (sym_tab) : 0,
+			    expr ? expr->dup (sym_tab) : 0);
+}
+
 void
 tree_decl_elt::accept (tree_walker& tw)
 {
   tw.visit_decl_elt (*this);
 }
 
 // Initializer lists for declaration statements.
 
@@ -62,16 +69,31 @@ tree_decl_init_list::eval (tree_decl_elt
 
       f (*elt);
 
       if (error_state)
 	break;
     }
 }
 
+tree_decl_init_list *
+tree_decl_init_list::dup (symbol_table *sym_tab)
+{
+  tree_decl_init_list *new_dil = new tree_decl_init_list ();
+
+  for (iterator p = begin (); p != end (); p++)
+    {
+      tree_decl_elt *elt = *p;
+
+      new_dil->append (elt ? elt->dup (sym_tab) : 0);
+    }
+  
+  return new_dil;
+}
+
 void
 tree_decl_init_list::accept (tree_walker& tw)
 {
   tw.visit_decl_init_list (*this);
 }
 
 // Base class for declaration commands (global, static).
 
@@ -128,16 +150,23 @@ tree_global_command::eval (void)
       initialized = true;
     }
 
   if (error_state)
     ::error ("evaluating global command near line %d, column %d",
 	     line (), column ());
 }
 
+tree_command *
+tree_global_command::dup (symbol_table *sym_tab)
+{
+  return new tree_global_command (init_list ? init_list->dup (sym_tab) : 0,
+				  line (), column ());
+}
+
 // Static.
 
 void
 tree_static_command::do_init (tree_decl_elt& elt)
 {
   tree_identifier *id = elt.ident ();
 
   if (id)
@@ -174,13 +203,20 @@ tree_static_command::eval (void)
       initialized = true;
 
       if (error_state)
 	::error ("evaluating static command near line %d, column %d",
 		 line (), column ());
     }
 }
 
+tree_command *
+tree_static_command::dup (symbol_table *sym_tab)
+{
+  return new tree_static_command (init_list ? init_list->dup (sym_tab) : 0,
+				  line (), column ());
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pt-decl.h b/src/pt-decl.h
--- a/src/pt-decl.h
+++ b/src/pt-decl.h
@@ -49,16 +49,18 @@ public:
   ~tree_decl_elt (void);
 
   void eval (void);
 
   tree_identifier *ident (void) { return id; }
 
   tree_expression *expression (void) { return expr; }
 
+  tree_decl_elt *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   // An identifier to tag with the declared property.
   tree_identifier *id;
 
   // An initializer expression (may be zero);
@@ -87,16 +89,18 @@ public:
 	  iterator p = begin ();
 	  delete *p;
 	  erase (p);
 	}
     }
 
   void eval (tree_decl_elt::eval_fcn);
 
+  tree_decl_init_list *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_decl_init_list (const tree_decl_init_list&);
 
@@ -157,16 +161,18 @@ public:
 
   tree_global_command (tree_decl_init_list *t, int l = -1, int c = -1)
     : tree_decl_command ("global", t, l, c) { }
 
   ~tree_global_command (void) { }
 
   void eval (void);
 
+  tree_command *dup (symbol_table *sym_tab);
+
 private:
 
   static void do_init (tree_decl_elt& elt);
 
   // No copying!
 
   tree_global_command (const tree_global_command&);
 
@@ -185,16 +191,18 @@ public:
 
   tree_static_command (tree_decl_init_list *t, int l = -1, int c = -1)
     : tree_decl_command ("static", t, l, c) { }
 
   ~tree_static_command (void) { }
 
   void eval (void);
 
+  tree_command *dup (symbol_table *sym_tab);
+
 private:
 
   static void do_init (tree_decl_elt& elt);
 
   // No copying!
 
   tree_static_command (const tree_static_command&);
 
diff --git a/src/pt-except.cc b/src/pt-except.cc
--- a/src/pt-except.cc
+++ b/src/pt-except.cc
@@ -121,16 +121,27 @@ tree_try_catch_command::eval (void)
       // For restoring buffer_error_messages.
       unwind_protect::run ();
 
       // Also clear the frame marker.
       unwind_protect::discard ();
     }
 }
 
+tree_command *
+tree_try_catch_command::dup (symbol_table *sym_tab)
+{
+  return new tree_try_catch_command (try_code ? try_code->dup (sym_tab) : 0,
+				     catch_code ? catch_code->dup (sym_tab) : 0,
+				     lead_comm ? lead_comm->dup () : 0,
+				     mid_comm ? mid_comm->dup () : 0,
+				     trail_comm ? trail_comm->dup () : 0,
+				     line (), column ());
+}
+
 void
 tree_try_catch_command::accept (tree_walker& tw)
 {
   tw.visit_try_catch_command (*this);
 }
 
 // Simple exception handling.
 
@@ -226,16 +237,28 @@ tree_unwind_protect_command::eval (void)
   MAYBE_DO_BREAKPOINT;
 
   if (unwind_protect_code)
     unwind_protect_code->eval ();
 
   unwind_protect::run ();
 }
 
+tree_command *
+tree_unwind_protect_command::dup (symbol_table *sym_tab)
+{
+  return new tree_unwind_protect_command
+    (unwind_protect_code ? unwind_protect_code->dup (sym_tab) : 0,
+     cleanup_code ? cleanup_code->dup (sym_tab) : 0,
+     lead_comm ? lead_comm->dup () : 0,
+     mid_comm ? mid_comm->dup () : 0,
+     trail_comm ? trail_comm->dup () : 0,
+     line (), column ());
+}
+
 void
 tree_unwind_protect_command::accept (tree_walker& tw)
 {
   tw.visit_unwind_protect_command (*this);
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/pt-except.h b/src/pt-except.h
--- a/src/pt-except.h
+++ b/src/pt-except.h
@@ -59,16 +59,18 @@ public:
   tree_statement_list *cleanup (void) { return catch_code; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *middle_comment (void) { return mid_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
+  tree_command *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   // The first block of code to attempt to execute.
   tree_statement_list *try_code;
 
   // The code to execute if an error occurs in the first block.
@@ -119,16 +121,18 @@ public:
   tree_statement_list *cleanup (void) { return cleanup_code; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *middle_comment (void) { return mid_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
+  tree_command *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   // The first body of code to attempt to execute.
   tree_statement_list *unwind_protect_code;
 
   // The body of code to execute no matter what happens in the first
diff --git a/src/pt-exp.h b/src/pt-exp.h
--- a/src/pt-exp.h
+++ b/src/pt-exp.h
@@ -23,16 +23,17 @@ 02110-1301, USA.
 
 #if !defined (octave_tree_expr_h)
 #define octave_tree_expr_h 1
 
 #include <string>
 
 class octave_value;
 class octave_lvalue;
+class symbol_table;
 
 #include "pt.h"
 
 // A base class for expressions.
 
 class
 tree_expression : public tree
 {
@@ -41,16 +42,18 @@ public:
   tree_expression (int l = -1, int c = -1)
     : tree (l, c), num_parens (0), postfix_indexed (false),
       print_flag (false) { }
 
   virtual ~tree_expression (void) { }
 
   virtual bool has_magic_end (void) const = 0;
 
+  virtual tree_expression *dup (symbol_table *) = 0;
+
   virtual bool is_constant (void) const { return false; }
 
   virtual bool is_matrix_constant (void) const { return false; }
 
   virtual bool is_identifier (void) const { return false; }
 
   virtual bool is_index_expression (void) const { return false; }
 
@@ -99,16 +102,23 @@ public:
     }
 
   tree_expression *set_print_flag (bool print)
     {
       print_flag = print;
       return this;
     }
 
+  virtual void copy_base (tree_expression& e)
+    {
+      num_parens = e.num_parens;
+      postfix_indexed = e.postfix_indexed;
+      print_flag = e.print_flag;
+    }
+
 protected:
 
   // A count of the number of times this expression appears directly
   // inside a set of parentheses.
   //
   //   (((e1)) + e2)  ==> 2 for expression e1
   //                  ==> 1 for expression ((e1)) + e2
   //                  ==> 0 for expression e2
diff --git a/src/pt-fcn-handle.cc b/src/pt-fcn-handle.cc
--- a/src/pt-fcn-handle.cc
+++ b/src/pt-fcn-handle.cc
@@ -28,16 +28,17 @@ 02110-1301, USA.
 #include <iostream>
 
 #include "error.h"
 #include "oct-obj.h"
 #include "ov-fcn-handle.h"
 #include "pt-fcn-handle.h"
 #include "pager.h"
 #include "pt-walk.h"
+#include "variables.h"
 
 void
 tree_fcn_handle::print (std::ostream& os, bool pr_as_read_syntax,
 			bool pr_orig_text)
 {
   print_raw (os, pr_as_read_syntax, pr_orig_text);
 }
 
@@ -65,19 +66,103 @@ tree_fcn_handle::rvalue (int nargout)
   if (nargout > 1)
     error ("invalid number of output arguments for function handle expression");
   else
     retval = rvalue ();
 
   return retval;
 }
 
+tree_expression *
+tree_fcn_handle::dup (symbol_table *sym_tab)
+{
+  tree_fcn_handle *new_fh = new tree_fcn_handle (nm, line (), column ());
+
+  new_fh->copy_base (*this);
+
+  return new_fh;
+}
+
 void
 tree_fcn_handle::accept (tree_walker& tw)
 {
   tw.visit_fcn_handle (*this);
 }
 
+tree_anon_fcn_handle::~tree_anon_fcn_handle (void)
+{
+  delete param_list;
+  delete cmd_list;
+  delete ret_list;
+  delete sym_tab;
+}
+
+octave_value
+tree_anon_fcn_handle::rvalue (void)
+{
+  MAYBE_DO_BREAKPOINT;
+
+  symbol_table *new_sym_tab = sym_tab ? sym_tab->dup () : 0;
+
+  if (new_sym_tab)
+    new_sym_tab->inherit (curr_sym_tab);
+
+  tree_parameter_list *new_param_list
+    = param_list ? param_list->dup (new_sym_tab) : 0;
+
+  tree_statement_list *new_cmd_list
+    = cmd_list ? cmd_list->dup (new_sym_tab) : 0;
+
+  tree_parameter_list *new_ret_list
+    = ret_list ? ret_list->dup (new_sym_tab) : 0;
+
+  octave_user_function *uf
+    = new octave_user_function (new_param_list, new_ret_list,
+				new_cmd_list, new_sym_tab);
+
+  octave_value fcn (uf);
+
+  octave_value fh (new octave_fcn_handle (fcn, "@<anonymous>"));
+
+  return fh;
+}
+
+octave_value_list
+tree_anon_fcn_handle::rvalue (int nargout)
+{
+  octave_value_list retval;
+
+  if (nargout > 1)
+    error ("invalid number of output arguments for anonymous function handle expression");
+  else
+    retval = rvalue ();
+
+  return retval;
+}
+
+tree_expression *
+tree_anon_fcn_handle::dup (symbol_table *st)
+{
+  tree_anon_fcn_handle *new_afh
+    = new tree_anon_fcn_handle (param_list ? param_list->dup (st) : 0,
+				ret_list ? ret_list->dup (st) : 0,
+				cmd_list ? cmd_list->dup (st) : 0,
+				sym_tab ? sym_tab->dup () : 0,
+				line (), column ());
+
+  new_afh->copy_base (*this);
+
+  return new_afh;
+}
+
+void
+tree_anon_fcn_handle::accept (tree_walker& tw)
+{
+  tw.visit_anon_fcn_handle (*this);
+}
+
+
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pt-fcn-handle.h b/src/pt-fcn-handle.h
--- a/src/pt-fcn-handle.h
+++ b/src/pt-fcn-handle.h
@@ -24,16 +24,18 @@ 02110-1301, USA.
 #if !defined (octave_tree_fcn_handle_h)
 #define octave_fcn_handle_h 1
 
 #include <iostream>
 #include <string>
 
 #include "pt-bp.h"
 #include "pt-exp.h"
+#include "pt-misc.h"
+#include "pt-stmt.h"
 
 class octave_value_list;
 
 class tree_walker;
 
 #include "ov.h"
 
 class
@@ -60,29 +62,85 @@ public:
   std::string name (void) const { return nm; }
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
+  tree_expression *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   // The name of this function handle.
   std::string nm;
 
   // No copying!
 
   tree_fcn_handle (const tree_fcn_handle&);
 
   tree_fcn_handle& operator = (const tree_fcn_handle&);
 };
 
+class
+tree_anon_fcn_handle : public tree_expression
+{
+public:
+
+  tree_anon_fcn_handle (int l = -1, int c = -1)
+    : tree_expression (l, c), param_list (0), cmd_list (0),
+      ret_list (0), sym_tab (0) { }
+
+  tree_anon_fcn_handle (tree_parameter_list *p, tree_parameter_list *r,
+			tree_statement_list *cl, symbol_table *st,
+			int l = -1, int c = -1)
+    : tree_expression (l, c), param_list (p), cmd_list (cl),
+      ret_list (r), sym_tab (st) { }
+
+  ~tree_anon_fcn_handle (void);
+
+  bool has_magic_end (void) const { return false; }
+
+  bool rvalue_ok (void) const { return true; }
+
+  octave_value rvalue (void);
+
+  octave_value_list rvalue (int nargout);
+
+  tree_parameter_list *parameter_list (void) { return param_list; }
+
+  tree_statement_list *body (void) { return cmd_list; }
+
+  tree_expression *dup (symbol_table *sym_tab);
+
+  void accept (tree_walker& tw);
+
+private:
+
+  // The parameter list.
+  tree_parameter_list *param_list;
+
+  // The statement that makes up the body of the function.
+  tree_statement_list *cmd_list;
+
+  // The list of return values.
+  tree_parameter_list *ret_list;
+
+  // The symbol table.
+  symbol_table *sym_tab;
+
+  // No copying!
+
+  tree_anon_fcn_handle (const tree_anon_fcn_handle&);
+
+  tree_anon_fcn_handle& operator = (const tree_anon_fcn_handle&);
+};
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pt-id.cc b/src/pt-id.cc
--- a/src/pt-id.cc
+++ b/src/pt-id.cc
@@ -207,16 +207,28 @@ tree_identifier::rvalue (void)
 octave_lvalue
 tree_identifier::lvalue (void)
 {
   MAYBE_DO_BREAKPOINT;
 
   return sym->variable_reference ();
 }
 
+tree_identifier *
+tree_identifier::dup (symbol_table *sym_tab)
+{
+  symbol_record *sr = (sym_tab && sym) ? sym_tab->lookup (sym->name ()) : 0;
+
+  tree_identifier *new_id = new tree_identifier (sr, line (), column ());
+
+  new_id->copy_base (*this);
+
+  return new_id;
+}
+
 void
 tree_identifier::accept (tree_walker& tw)
 {
   tw.visit_identifier (*this);
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/pt-id.h b/src/pt-id.h
--- a/src/pt-id.h
+++ b/src/pt-id.h
@@ -84,16 +84,18 @@ public:
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   octave_lvalue lvalue (void);
 
   void eval_undefined_error (void);
 
+  tree_identifier *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   // The symbol record that this identifier references.
   symbol_record *sym;
 
   // No copying!
diff --git a/src/pt-idx.cc b/src/pt-idx.cc
--- a/src/pt-idx.cc
+++ b/src/pt-idx.cc
@@ -36,16 +36,20 @@ 02110-1301, USA.
 #include "pt-bp.h"
 #include "pt-idx.h"
 #include "pt-walk.h"
 #include "utils.h"
 #include "variables.h"
 
 // Index expressions.
 
+tree_index_expression::tree_index_expression (int l, int c)
+  : tree_expression (l, c), expr (), args (), type (),
+    arg_nm (), dyn_field () { }
+
 tree_index_expression::tree_index_expression (tree_expression *e,
 					      tree_argument_list *lst,
 					      int l, int c, char t)
   : tree_expression (l, c), expr (e), args (), type (),
     arg_nm (), dyn_field ()
 {
   append (lst, t);
 }
@@ -514,16 +518,59 @@ tree_index_expression::eval_error (void)
     type_str = "expression";
 
   if (l != -1 && c != -1)
     ::error ("evaluating %s near line %d, column %d", type_str, l, c);
   else
     ::error ("evaluating %s", type_str);
 }
 
+tree_index_expression *
+tree_index_expression::dup (symbol_table *sym_tab)
+{
+  tree_index_expression *new_idx_expr
+    = new tree_index_expression (line (), column ());
+
+  new_idx_expr->expr = expr ? expr->dup (sym_tab) : 0;
+
+  std::list<tree_argument_list *> new_args;
+
+  for (std::list<tree_argument_list *>::iterator p = args.begin ();
+       p != args.end ();
+       p++)
+    {
+      tree_argument_list *elt = *p;
+
+      new_args.push_back (elt ? elt->dup (sym_tab) : 0);
+    }
+
+  new_idx_expr->args = new_args;
+  
+  new_idx_expr->type = type;
+
+  new_idx_expr->arg_nm = arg_nm;
+
+  std::list<tree_expression *> new_dyn_field;
+
+  for (std::list<tree_expression *>::iterator p = dyn_field.begin ();
+       p != dyn_field.end ();
+       p++)
+    {
+      tree_expression *elt = *p;
+
+      new_dyn_field.push_back (elt ? elt->dup (sym_tab) : 0);
+    }
+
+  new_idx_expr->dyn_field = new_dyn_field;
+
+  new_idx_expr->copy_base (*this);
+  
+  return new_idx_expr;
+}
+
 void
 tree_index_expression::accept (tree_walker& tw)
 {
   tw.visit_index_expression (*this);
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/pt-idx.h b/src/pt-idx.h
--- a/src/pt-idx.h
+++ b/src/pt-idx.h
@@ -84,16 +84,18 @@ public:
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   octave_lvalue lvalue (void);
 
   void eval_error (void) const;
 
+  tree_index_expression *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   // The LHS of this index expression.
   tree_expression *expr;
 
   // The indices (only valid if type == paren || type == brace).
@@ -104,16 +106,18 @@ private:
 
   // The names of the arguments.  Used for constant struct element
   // references.
   std::list<string_vector> arg_nm;
 
   // The list of dynamic field names, if any.
   std::list<tree_expression *> dyn_field;
 
+  tree_index_expression (int l = -1, int c = -1);
+
   Octave_map make_arg_struct (void) const;
 
   std::string
   get_struct_index
     (std::list<string_vector>::const_iterator p_arg_nm,
      std::list<tree_expression *>::const_iterator p_dyn_field) const; 
 
   // No copying!
diff --git a/src/pt-jump.cc b/src/pt-jump.cc
--- a/src/pt-jump.cc
+++ b/src/pt-jump.cc
@@ -43,16 +43,22 @@ tree_break_command::eval (void)
 {
   // Even if we have an error we should still enter debug mode.
   MAYBE_DO_BREAKPOINT;
 
   if (! error_state)
     breaking = 1;
 }
 
+tree_command *
+tree_break_command::dup (symbol_table *)
+{
+  return new tree_break_command (line (), column ());
+}
+
 void
 tree_break_command::accept (tree_walker& tw)
 {
   tw.visit_break_command (*this);
 }
 
 // Continue.
 
@@ -63,16 +69,22 @@ void
 tree_continue_command::eval (void)
 {
   MAYBE_DO_BREAKPOINT;
 
   if (! error_state)
     continuing = 1;
 }
 
+tree_command *
+tree_continue_command::dup (symbol_table *)
+{
+  return new tree_continue_command (line (), column ());
+}
+
 void
 tree_continue_command::accept (tree_walker& tw)
 {
   tw.visit_continue_command (*this);
 }
 
 // Return.
 
@@ -83,16 +95,22 @@ void
 tree_return_command::eval (void)
 {
   MAYBE_DO_BREAKPOINT;
 
   if (! error_state)
     returning = 1;
 }
 
+tree_command *
+tree_return_command::dup (symbol_table *)
+{
+  return new tree_return_command (line (), column ());
+}
+
 void
 tree_return_command::accept (tree_walker& tw)
 {
   tw.visit_return_command (*this);
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/pt-jump.h b/src/pt-jump.h
--- a/src/pt-jump.h
+++ b/src/pt-jump.h
@@ -37,16 +37,18 @@ public:
 
   tree_break_command (int l = -1, int c = -1)
     : tree_command (l, c) { }
 
   ~tree_break_command (void) { }
 
   void eval (void);
 
+  tree_command *dup (symbol_table *);
+
   void accept (tree_walker& tw);
 
   static int breaking;
 
 private:
 
   // No copying!
 
@@ -64,16 +66,18 @@ public:
 
   tree_continue_command (int l = -1, int c = -1)
     : tree_command (l, c) { }
 
   ~tree_continue_command (void) { }
 
   void eval (void);
 
+  tree_command *dup (symbol_table *);
+
   void accept (tree_walker& tw);
 
   static int continuing;
 
 private:
 
   // No copying!
 
@@ -91,16 +95,18 @@ public:
 
   tree_return_command (int l = -1, int c = -1)
     : tree_command (l, c) { }
 
   ~tree_return_command (void) { }
 
   void eval (void);
 
+  tree_command *dup (symbol_table *);
+
   void accept (tree_walker& tw);
 
   static int returning;
 
 private:
 
   // No copying!
 
diff --git a/src/pt-loop.cc b/src/pt-loop.cc
--- a/src/pt-loop.cc
+++ b/src/pt-loop.cc
@@ -120,16 +120,26 @@ tree_while_command::eval (void)
 
 void
 tree_while_command::eval_error (void)
 {
   ::error ("evaluating while command near line %d, column %d",
 	   line (), column ());
 }
 
+tree_command *
+tree_while_command::dup (symbol_table *sym_tab)
+{
+  return new tree_while_command (expr ? expr->dup (sym_tab) : 0,
+				 list ? list->dup (sym_tab) : 0,
+				 lead_comm ? lead_comm->dup () : 0,
+				 trail_comm ? trail_comm->dup (): 0,
+				 line (), column ());
+}
+
 void
 tree_while_command::accept (tree_walker& tw)
 {
   tw.visit_while_command (*this);
 }
 
 // Do-Until
 
@@ -173,16 +183,26 @@ tree_do_until_command::eval (void)
 
 void
 tree_do_until_command::eval_error (void)
 {
   ::error ("evaluating do-until command near line %d, column %d",
 	   line (), column ());
 }
 
+tree_command *
+tree_do_until_command::dup (symbol_table *sym_tab)
+{
+  return new tree_do_until_command (expr ? expr->dup (sym_tab) : 0,
+				    list ? list->dup (sym_tab) : 0,
+				    lead_comm ? lead_comm->dup () : 0,
+				    trail_comm ? trail_comm->dup (): 0,
+				    line (), column ());
+}
+
 void
 tree_do_until_command::accept (tree_walker& tw)
 {
   tw.visit_do_until_command (*this);
 }
 
 // For.
 
@@ -457,16 +477,27 @@ tree_simple_for_command::eval (void)
 
 void
 tree_simple_for_command::eval_error (void)
 {
   ::error ("evaluating for command near line %d, column %d",
 	   line (), column ());
 }
 
+tree_command *
+tree_simple_for_command::dup (symbol_table *sym_tab)
+{
+  return new tree_simple_for_command (lhs ? lhs->dup (sym_tab) : 0,
+				      expr ? expr->dup (sym_tab) : 0,
+				      list ? list->dup (sym_tab) : 0,
+				      lead_comm ? lead_comm->dup () : 0,
+				      trail_comm ? trail_comm->dup () : 0,
+				      line (), column ());
+}
+
 void
 tree_simple_for_command::accept (tree_walker& tw)
 {
   tw.visit_simple_for_command (*this);
 }
 
 tree_complex_for_command::~tree_complex_for_command (void)
 {
@@ -567,16 +598,27 @@ tree_complex_for_command::eval (void)
 
 void
 tree_complex_for_command::eval_error (void)
 {
   ::error ("evaluating for command near line %d, column %d",
 	   line (), column ());
 }
 
+tree_command *
+tree_complex_for_command::dup (symbol_table *sym_tab)
+{
+  return new tree_complex_for_command (lhs ? lhs->dup (sym_tab) : 0,
+				      expr ? expr->dup (sym_tab) : 0,
+				      list ? list->dup (sym_tab) : 0,
+				      lead_comm ? lead_comm->dup () : 0,
+				      trail_comm ? trail_comm->dup () : 0,
+				      line (), column ());
+}
+
 void
 tree_complex_for_command::accept (tree_walker& tw)
 {
   tw.visit_complex_for_command (*this);
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/pt-loop.h b/src/pt-loop.h
--- a/src/pt-loop.h
+++ b/src/pt-loop.h
@@ -73,16 +73,18 @@ public:
   tree_expression *condition (void) { return expr; }
 
   tree_statement_list *body (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
+  tree_command *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 protected:
 
   // Expression to test.
   tree_expression *expr;
 
   // List of commands to execute.
@@ -126,16 +128,18 @@ public:
     : tree_while_command (e, lst, lc, tc, l, c) { }
 
   ~tree_do_until_command (void) { }
 
   void eval (void);
 
   void eval_error (void);
 
+  tree_command *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_do_until_command (const tree_do_until_command&);
 
@@ -172,16 +176,18 @@ public:
   tree_expression *control_expr (void) { return expr; }
 
   tree_statement_list *body (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
+  tree_command *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   // Expression to modify.
   tree_expression *lhs;
 
   // Expression to evaluate.
@@ -234,16 +240,18 @@ public:
   tree_expression *control_expr (void) { return expr; }
 
   tree_statement_list *body (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
+  tree_command *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   // Expression to modify.
   tree_argument_list *lhs;
 
   // Expression to evaluate.
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -928,16 +928,33 @@ tree_matrix::rvalue (void)
 	    }
 	}
     }
 
 done:
   return retval;
 }
 
+tree_expression *
+tree_matrix::dup (symbol_table *sym_tab)
+{
+  tree_matrix *new_matrix = new tree_matrix (0, line (), column ());
+
+  for (iterator p = begin (); p != end (); p++)
+    {
+      tree_argument_list *elt = *p;
+
+      append (elt ? elt->dup (sym_tab) : 0);
+    }
+
+  new_matrix->copy_base (*this);
+
+  return new_matrix;
+}
+
 void
 tree_matrix::accept (tree_walker& tw)
 {
   tw.visit_matrix (*this);
 }
 
 DEFUN (string_fill_char, args, nargout,
   "-*- texinfo -*-\n\
diff --git a/src/pt-mat.h b/src/pt-mat.h
--- a/src/pt-mat.h
+++ b/src/pt-mat.h
@@ -58,16 +58,18 @@ public:
   bool all_elements_are_constant (void) const;
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
+  tree_expression *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_matrix (const tree_matrix&);
 
diff --git a/src/pt-misc.cc b/src/pt-misc.cc
--- a/src/pt-misc.cc
+++ b/src/pt-misc.cc
@@ -182,16 +182,34 @@ tree_parameter_list::is_defined (void)
 	  status = false;
 	  break;
 	}
     }
 
   return status;
 }
 
+tree_parameter_list *
+tree_parameter_list::dup (symbol_table *sym_tab)
+{
+  tree_parameter_list *new_list = new tree_parameter_list ();
+
+  if (takes_varargs ())
+    new_list->mark_varargs ();
+
+  for (iterator p = begin (); p != end (); p++)
+    {
+      tree_identifier *elt = *p;
+
+      new_list->append (elt->dup (sym_tab));
+    }
+
+  return new_list;
+}
+
 void
 tree_parameter_list::accept (tree_walker& tw)
 {
   tw.visit_parameter_list (*this);
 }
 
 // Return lists.
 
@@ -200,16 +218,31 @@ tree_return_list::~tree_return_list (voi
   while (! empty ())
     {
       iterator p = begin ();
       delete *p;
       erase (p);
     }
 }
 
+tree_return_list *
+tree_return_list::dup (symbol_table *sym_tab)
+{
+  tree_return_list *new_list = new tree_return_list ();
+
+  for (iterator p = begin (); p != end (); p++)
+    {
+      tree_index_expression *elt = *p;
+
+      new_list->append (elt->dup (sym_tab));
+    }
+
+  return new_list;
+}
+
 void
 tree_return_list::accept (tree_walker& tw)
 {
   tw.visit_return_list (*this);
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/pt-misc.h b/src/pt-misc.h
--- a/src/pt-misc.h
+++ b/src/pt-misc.h
@@ -70,16 +70,18 @@ public:
   void define_from_arg_vector (const octave_value_list& args);
 
   void undefine (void);
 
   bool is_defined (void);
 
   octave_value_list convert_to_const_vector (const Cell& varargout);
 
+  tree_parameter_list *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   int marked_for_varargs;
 
   // No copying!
 
@@ -97,16 +99,18 @@ tree_return_list : public octave_base_li
 public:
 
   tree_return_list (void) { }
 
   tree_return_list (tree_index_expression *t) { append (t); }
 
   ~tree_return_list (void);
 
+  tree_return_list *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_return_list (const tree_return_list&);
 
diff --git a/src/pt-pr-code.cc b/src/pt-pr-code.cc
--- a/src/pt-pr-code.cc
+++ b/src/pt-pr-code.cc
@@ -31,16 +31,40 @@ 02110-1301, USA.
 
 #include "comment-list.h"
 #include "error.h"
 #include "ov-usr-fcn.h"
 #include "pr-output.h"
 #include "pt-all.h"
 
 void
+tree_print_code::visit_anon_fcn_handle (tree_anon_fcn_handle& afh)
+{
+  indent ();
+
+  print_parens (afh, "(");
+
+  os << "@(";
+
+  tree_parameter_list *param_list = afh.parameter_list ();
+
+  if (param_list)
+    param_list->accept (*this);
+
+  os << ") ";
+
+  tree_statement_list *body = afh.body ();
+
+  if (body)
+    body->accept (*this);
+
+  print_parens (afh, ")");
+}
+
+void
 tree_print_code::visit_argument_list (tree_argument_list& lst)
 {
   tree_argument_list::iterator p = lst.begin ();
 
   while (p != lst.end ())
     {
       tree_expression *elt = *p++;
 
diff --git a/src/pt-pr-code.h b/src/pt-pr-code.h
--- a/src/pt-pr-code.h
+++ b/src/pt-pr-code.h
@@ -48,16 +48,18 @@ public:
       printing_newlines (true)
   {
     // For "none".
     nesting.push ('n');
   }
 
   ~tree_print_code (void) { }
 
+  void visit_anon_fcn_handle (tree_anon_fcn_handle&);
+
   void visit_argument_list (tree_argument_list&);
 
   void visit_binary_expression (tree_binary_expression&);
 
   void visit_break_command (tree_break_command&);
 
   void visit_colon_expression (tree_colon_expression&);
 
diff --git a/src/pt-select.cc b/src/pt-select.cc
--- a/src/pt-select.cc
+++ b/src/pt-select.cc
@@ -54,16 +54,24 @@ tree_if_clause::eval (void)
 	list->eval ();
 
       return 1;
     }
 
   return 0;
 }
 
+tree_if_clause *
+tree_if_clause::dup (symbol_table *sym_tab)
+{
+  return new tree_if_clause (expr ? expr->dup (sym_tab) : 0,
+			     list ? list->dup (sym_tab) : 0,
+			     lead_comm ? lead_comm->dup () : 0);
+}
+
 void
 tree_if_clause::accept (tree_walker& tw)
 {
   tw.visit_if_clause (*this);
 }
 
 // List of if commands.
 
@@ -74,16 +82,31 @@ tree_if_command_list::eval (void)
     {
       tree_if_clause *t = *p;
 
       if (t->eval () || error_state)
 	break;
     }
 }
 
+tree_if_command_list *
+tree_if_command_list::dup (symbol_table *sym_tab)
+{
+  tree_if_command_list *new_icl = new tree_if_command_list ();
+
+  for (iterator p = begin (); p != end (); p++)
+    {
+      tree_if_clause *elt = *p;
+
+      new_icl->append (elt ? elt->dup (sym_tab) : 0);
+    }
+
+  return new_icl;
+}
+
 void
 tree_if_command_list::accept (tree_walker& tw)
 {
   tw.visit_if_command_list (*this);
 }
 
 // If.
 
@@ -100,16 +123,25 @@ tree_if_command::eval (void)
   if (list)
     list->eval ();
 
   if (error_state)
     ::error ("evaluating if command near line %d, column %d",
 	     line (), column ());
 }
 
+tree_command *
+tree_if_command::dup (symbol_table *sym_tab)
+{
+  return new tree_if_command (list ? list->dup (sym_tab) : 0,
+			      lead_comm ? lead_comm->dup () : 0,
+			      trail_comm ? trail_comm->dup () : 0,
+			      line (), column ());
+}
+
 void
 tree_if_command::accept (tree_walker& tw)
 {
   tw.visit_if_command (*this);
 }
 
 // Switch cases.
 
@@ -205,16 +237,24 @@ tree_switch_case::eval (const octave_val
 }
 
 void
 tree_switch_case::eval_error (void)
 {
   ::error ("evaluating switch case label");
 }
 
+tree_switch_case *
+tree_switch_case::dup (symbol_table *sym_tab)
+{
+  return new tree_switch_case (label ? label->dup (sym_tab) : 0,
+			       list ? list->dup (sym_tab) : 0,
+			       lead_comm ? lead_comm->dup () : 0);
+}
+
 void
 tree_switch_case::accept (tree_walker& tw)
 {
   tw.visit_switch_case (*this);
 }
 
 // List of switch cases.
 
@@ -225,16 +265,31 @@ tree_switch_case_list::eval (const octav
     {
       tree_switch_case *t = *p;
 
       if (t->eval (val) || error_state)
 	break;
     }
 }
 
+tree_switch_case_list *
+tree_switch_case_list::dup (symbol_table *sym_tab)
+{
+  tree_switch_case_list *new_scl = new tree_switch_case_list ();
+
+  for (iterator p = begin (); p != end (); p++)
+    {
+      tree_switch_case *elt = *p;
+
+      new_scl->append (elt ? elt->dup (sym_tab) : 0);
+    }
+  
+  return new_scl;
+}
+
 void
 tree_switch_case_list::accept (tree_walker& tw)
 {
   tw.visit_switch_case_list (*this);
 }
 
 // Switch.
 
@@ -271,16 +326,26 @@ tree_switch_command::eval (void)
 
 void
 tree_switch_command::eval_error (void)
 {
   ::error ("evaluating switch command near line %d, column %d",
 	   line (), column ());
 }
 
+tree_command *
+tree_switch_command::dup (symbol_table *sym_tab)
+{
+  return new tree_switch_command (expr ? expr->dup (sym_tab) : 0,
+				  list ? list->dup (sym_tab) : 0,
+				  lead_comm ? lead_comm->dup () : 0,
+				  trail_comm ? trail_comm->dup () : 0,
+				  line (), column ());
+}
+
 void
 tree_switch_command::accept (tree_walker& tw)
 {
   tw.visit_switch_command (*this);
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/pt-select.h b/src/pt-select.h
--- a/src/pt-select.h
+++ b/src/pt-select.h
@@ -58,16 +58,18 @@ public:
   int eval (void);
 
   tree_expression *condition (void) { return expr; }
 
   tree_statement_list *commands (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
+  tree_if_clause *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   // The condition to test.
   tree_expression *expr;
 
   // The list of statements to evaluate if expr is true.
@@ -99,16 +101,18 @@ public:
 	  iterator p = begin ();
 	  delete *p;
 	  erase (p);
 	}
     }
 
   void eval (void);
 
+  tree_if_command_list *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_if_command_list (const tree_if_command_list&);
 
@@ -132,16 +136,18 @@ public:
   void eval (void);
 
   tree_if_command_list *cmd_list (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
+  tree_command *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   // List of if commands (if, elseif, elseif, ... else, endif)
   tree_if_command_list *list;
 
   // Comment preceding IF token.
@@ -185,16 +191,18 @@ public:
   void eval_error (void);
 
   tree_expression *case_label (void) { return label; }
 
   tree_statement_list *commands (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
+  tree_switch_case *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   // The case label.
   tree_expression *label;
 
   // The list of statements to evaluate if the label matches.
@@ -226,16 +234,18 @@ public:
 	  iterator p = begin ();
 	  delete *p;
 	  erase (p);
 	}
     }
 
   void eval (const octave_value& val);
 
+  tree_switch_case_list *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_switch_case_list (const tree_switch_case_list&);
 
@@ -266,16 +276,18 @@ public:
   tree_expression *switch_value (void) { return expr; }
 
   tree_switch_case_list *case_list (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
+  tree_command *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   // Value on which to switch.
   tree_expression *expr;
 
   // List of cases (case 1, case 2, ..., default)
diff --git a/src/pt-stmt.cc b/src/pt-stmt.cc
--- a/src/pt-stmt.cc
+++ b/src/pt-stmt.cc
@@ -138,16 +138,32 @@ tree_statement::eval (bool silent, int n
 	}
 
       unwind_protect::run ();
     }
 
   return retval;
 }
 
+tree_statement *
+tree_statement::dup (symbol_table *sym_tab)
+{
+  tree_statement *new_stmt = new tree_statement ();
+
+  new_stmt->cmd = cmd ? cmd->dup (sym_tab) : 0;
+
+  new_stmt->expr = expr ? expr->dup (sym_tab) : 0;
+
+  new_stmt->comm = comm ? comm->dup () : 0;
+
+  new_stmt->print_flag = print_flag;
+
+  return new_stmt;
+}
+
 void
 tree_statement::accept (tree_walker& tw)
 {
   tw.visit_statement (*this);
 }
 
 octave_value_list
 tree_statement_list::eval (bool silent, int nargout)
@@ -246,16 +262,33 @@ octave_value_list
 tree_statement_list::list_breakpoints (void)
 {
   tree_breakpoint tbp (0, tree_breakpoint::list);
   accept (tbp);
 
   return tbp.get_list ();
 }
 
+tree_statement_list *
+tree_statement_list::dup (symbol_table *sym_tab)
+{
+  tree_statement_list *new_list = new tree_statement_list ();
+
+  new_list->function_body = function_body;
+
+  for (iterator p = begin (); p != end (); p++)
+    {
+      tree_statement *elt = *p;
+
+      new_list->append (elt ? elt->dup (sym_tab) : 0);
+    }
+
+  return new_list;
+}
+
 void
 tree_statement_list::accept (tree_walker& tw)
 {
   tw.visit_statement_list (*this);
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/pt-stmt.h b/src/pt-stmt.h
--- a/src/pt-stmt.h
+++ b/src/pt-stmt.h
@@ -77,16 +77,18 @@ public:
   // Allow modification of this statement.  Note that there is no
   // checking.  If you use these, are you sure you knwo what you are
   // doing?
 
   void set_command (tree_command *c) { cmd = c; }
 
   void set_expression (tree_expression *e) { expr = e; }
 
+  tree_statement *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   // Only one of cmd or expr can be valid at once.
 
   // Command to execute.
   tree_command *cmd;
@@ -134,16 +136,18 @@ public:
   octave_value_list eval (bool silent = false, int nargout = 0);
 
   int set_breakpoint (int line);
 
   void delete_breakpoint (int line);
 
   octave_value_list list_breakpoints (void);
 
+  tree_statement_list *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   // Does this list of statements make up the body of a function?
   bool function_body;
 
   // No copying!
diff --git a/src/pt-unop.cc b/src/pt-unop.cc
--- a/src/pt-unop.cc
+++ b/src/pt-unop.cc
@@ -115,16 +115,28 @@ tree_prefix_expression::rvalue (void)
 
 void
 tree_prefix_expression::eval_error (void)
 {
   ::error ("evaluating prefix operator `%s' near line %d, column %d",
 	   oper () . c_str (), line (), column ());
 }
 
+tree_expression *
+tree_prefix_expression::dup (symbol_table *sym_tab)
+{
+  tree_prefix_expression *new_pe
+    = new tree_prefix_expression (op ? op->dup (sym_tab) : 0,
+				  line (), column (), etype);
+
+  new_pe->copy_base (*this);
+
+  return new_pe;
+}
+
 void
 tree_prefix_expression::accept (tree_walker& tw)
 {
   tw.visit_prefix_expression (*this);
 }
 
 // Postfix expressions.
 
@@ -200,16 +212,28 @@ tree_postfix_expression::rvalue (void)
 
 void
 tree_postfix_expression::eval_error (void)
 {
   ::error ("evaluating postfix operator `%s' near line %d, column %d",
 	   oper () . c_str (), line (), column ());
 }
 
+tree_expression *
+tree_postfix_expression::dup (symbol_table *sym_tab)
+{
+  tree_postfix_expression *new_pe
+    = new tree_postfix_expression (op ? op->dup (sym_tab) : 0,
+				   line (), column (), etype);
+
+  new_pe->copy_base (*this);
+
+  return new_pe;
+}
+
 void
 tree_postfix_expression::accept (tree_walker& tw)
 {
   tw.visit_postfix_expression (*this);
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/pt-unop.h b/src/pt-unop.h
--- a/src/pt-unop.h
+++ b/src/pt-unop.h
@@ -96,16 +96,18 @@ public:
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   void eval_error (void);
 
+  tree_expression *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_prefix_expression (const tree_prefix_expression&);
 
@@ -132,16 +134,18 @@ public:
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   void eval_error (void);
 
+  tree_expression *dup (symbol_table *sym_tab);
+
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_postfix_expression (const tree_postfix_expression&);
 
diff --git a/src/pt-walk.h b/src/pt-walk.h
--- a/src/pt-walk.h
+++ b/src/pt-walk.h
@@ -19,16 +19,17 @@ along with Octave; see the file COPYING.
 Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 02110-1301, USA.
 
 */
 
 #if !defined (octave_tree_walker_h)
 #define octave_tree_walker_h 1
 
+class tree_anon_fcn_handle;
 class tree_argument_list;
 class tree_binary_expression;
 class tree_break_command;
 class tree_colon_expression;
 class tree_continue_command;
 class tree_decl_command;
 class tree_decl_elt;
 class tree_decl_init_list;
@@ -63,16 +64,19 @@ class tree_while_command;
 class tree_do_until_command;
 
 class
 tree_walker
 {
 public:
 
   virtual void
+  visit_anon_fcn_handle (tree_anon_fcn_handle&) = 0;
+
+  virtual void
   visit_argument_list (tree_argument_list&) = 0;
 
   virtual void
   visit_binary_expression (tree_binary_expression&) = 0;
 
   virtual void
   visit_break_command (tree_break_command&) = 0;
 
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -290,16 +290,29 @@ symbol_record::mark_as_formal_parameter 
   else if (is_static ())
     error ("can't mark static variable `%s' as function paraemter",
 	   nm.c_str ());
   else
     formal_param = 1;
 }
 
 void
+symbol_record::mark_as_automatic_variable (void)
+{
+  if (is_linked_to_global ())
+    error ("can't mark global variable `%s' as automatic variable",
+	   nm.c_str ());
+  else if (is_static ())
+    error ("can't mark static variable `%s' as automatic variable",
+	   nm.c_str ());
+  else
+    automatic_variable = 1;
+}
+
+void
 symbol_record::mark_as_linked_to_global (void)
 {
   if (is_formal_parameter ())
     error ("can't make function parameter `%s' global", nm.c_str ());
   else if (is_static ())
     error ("can't make static variable `%s' global", nm.c_str ());
   else
     linked_to_global = 1;
@@ -1646,16 +1659,83 @@ symbol_table::pop_context (void)
       while (ptr)
 	{
 	  ptr->pop_context ();
 	  ptr = ptr->next ();
 	}
     }
 }
 
+// Create a new symbol table with the same entries.  Only the symbol
+// names and some attributes are copied, not values.
+
+symbol_table *
+symbol_table::dup (void)
+{
+  symbol_table *new_sym_tab = new symbol_table (table_size);
+
+  for (unsigned int i = 0; i < table_size; i++)
+    {
+      symbol_record *ptr = table[i].next ();
+
+      while (ptr)
+	{
+	  std::string nm = ptr->name ();
+
+	  symbol_record *sr = new_sym_tab->lookup (nm, true);
+
+	  if (sr)
+	    {
+	      if (ptr->is_formal_parameter ())
+		sr->mark_as_formal_parameter ();
+
+	      if (ptr->is_automatic_variable ())
+		sr->mark_as_automatic_variable ();
+
+	      if (ptr->is_static ())
+		sr->mark_as_static ();
+	    }
+
+	  ptr = ptr->next ();
+	}
+    }
+
+  return new_sym_tab;
+}
+
+void
+symbol_table::inherit (symbol_table *parent_sym_tab)
+{
+  for (unsigned int i = 0; i < table_size; i++)
+    {
+      symbol_record *ptr = table[i].next ();
+
+      while (ptr)
+	{
+	  std::string nm = ptr->name ();
+
+	  if (! (nm == "__retval__"
+		 || ptr->is_automatic_variable ()
+		 || ptr->is_formal_parameter ()))
+	    {
+	      symbol_record *sr = parent_sym_tab->lookup (nm);
+
+	      if (sr)
+		{
+		  ptr->define (sr->variable_value ());
+
+		  ptr->mark_as_static ();
+		}
+	    }
+
+	  ptr = ptr->next ();
+	}
+    }
+}
+
 void
 symbol_table::print_info (std::ostream& os) const
 {
   int count = 0;
   int empty_chains = 0;
   int max_chain_length = 0;
   int min_chain_length = INT_MAX;
 
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -251,29 +251,29 @@ private:
     symbol_def& operator = (const symbol_def& sd);
   };
 
 public:
 
   typedef int (*change_function) (void);
 
   symbol_record (void)
-    : formal_param (false), linked_to_global (false),
-      tagged_static (false), can_hide_function (true),
-      visible (true), nm (), chg_fcn (0),
+    : formal_param (false), automatic_variable (false),
+      linked_to_global (false), tagged_static (false),
+      can_hide_function (true), visible (true), nm (), chg_fcn (0),
       definition (new symbol_def ()), next_elem (0) { }
 
   // FIXME -- kluge alert!  We obviously need a better way of
   // handling allow_shadow!
 
   symbol_record (const std::string& n, symbol_record *nxt)
-    : formal_param (false), linked_to_global (false),
-      tagged_static (false), can_hide_function (n != "__end__"),
-      visible (true), nm (n), chg_fcn (0),
-      definition (new symbol_def ()), next_elem (nxt) { }
+    : formal_param (false), automatic_variable (false),
+      linked_to_global (false), tagged_static (false),
+      can_hide_function (n != "__end__"), visible (true), nm (n),
+      chg_fcn (0), definition (new symbol_def ()), next_elem (nxt) { }
 
   ~symbol_record (void)
     {
       if (--definition->count <= 0)
 	delete definition;
     }
 
   std::string name (void) const { return nm; }
@@ -354,16 +354,19 @@ public:
 
   void clear (void);
 
   void alias (symbol_record *s, bool mark_to_clear = false);
 
   void mark_as_formal_parameter (void);
   bool is_formal_parameter (void) const { return formal_param; }
 
+  void mark_as_automatic_variable (void);
+  bool is_automatic_variable (void) const { return automatic_variable; }
+
   void mark_as_linked_to_global (void);
   bool is_linked_to_global (void) const { return linked_to_global; }
 
   void mark_as_static (void);
   bool is_static (void) const { return tagged_static; }
   void unmark_static (void) { tagged_static = false; }
 
   bool is_matrix_type (void) const 
@@ -428,16 +431,17 @@ public:
 			       std::list<whos_parameter>& params) const;
 
   void print_info (std::ostream& os,
 		   const std::string& prefix = std::string ()) const;
 
 private:
 
   unsigned int formal_param : 1;
+  unsigned int automatic_variable : 1;
   unsigned int linked_to_global : 1;
   unsigned int tagged_static : 1;
   unsigned int can_hide_function : 1;
   unsigned int visible : 1;
 
   std::string nm;
   change_function chg_fcn;
   symbol_def *definition;
@@ -576,16 +580,23 @@ public:
   Array<symbol_record *> glob (const std::string& pat = std::string ("*"),
 			       unsigned int type = SYMTAB_ALL_TYPES,
 			       unsigned int scope = SYMTAB_ALL_SCOPES) const;
 
   void push_context (void);
 
   void pop_context (void);
 
+  // Create a new symbol table with the same entries.  Only the symbol
+  // names and some attributes are copied, not values.
+  symbol_table *dup (void);
+
+  // Inherit some values from the parent_sym_tab.
+  void inherit (symbol_table *parent_sym_tab);
+
   void print_info (std::ostream& os) const;
 
 private:
 
   unsigned int table_size;
 
   symbol_record *table;
 
