# HG changeset patch
# User Jordi Guti√©rrez Hermoso <jordigh@octave.org>
# Date 1351796480 14400
#      Thu Nov 01 15:01:20 2012 -0400
# Branch classdef
# Node ID 6ea536cb73603a1b0c7741ba6fe8ad6d98b486e8
# Parent  947cf10c94dada052f7659a910f39870d8e70b9f
# Parent  859c8bf6d1343d2f5c8e6fda47e180fbbfbf2654
maint: periodic merge of default to classdef

diff --git a/.hgignore b/.hgignore
--- a/.hgignore
+++ b/.hgignore
@@ -1,39 +1,43 @@
 syntax: regexp
 # The recurrent (^|/) idiom in the regexps below should be understood
 # to mean "at any directory" while the ^ idiom means "from the
 # project's top-level directory".
 
-# This one gets created by gnulib during the build, contains no Octave
-# files.
+# gnulib makes these silly backup files
+.~$
+
+# This directory gets created by gnulib during the build. 
+# It contains no Octave files.
 ^gnulib/
 
 # These directories mostly contain cruft during build time, but they
-# do contain some Octave code.
-^libgnu/
-^m4/
+# do contain some Octave code, so we gotta be a bit more careful about
+# what we ignore here
+^libgnu/.*\.([hc]$|sin$|valgrind$|charset$|mk$)
+^m4/(?!ax_).+\.m4$
 
 # Emacs tools create these
 (^|/)TAGS$
 (^|/)semantic.cache$
 
 (/|^)Makefile\.in$
 ^INSTALL$
 
-^aclocal\.m4
+^aclocal\.m4$
 ^build-.*($|/)
 ^configure$
 ^autom4te\.cache($|/)
 ^config\.h\.in$
 
 # e.g. doc/faq/OctaveFAQ.info
 #      doc/interpreter/octave.info-4
 ^doc/.*\.info(-\d)?$
 
 ^doc/\w*/stamp-vti$
 ^doc/\w*/version\.texi$
 ^doc/interpreter/images\.mk$
 
-# e.g. liboctave/smx-op-inc.mk
-^liboctave/[\w-]*\.mk$
+# e.g. liboctave/operators/smx-op-inc.mk
+^liboctave/operators/\w+-op-\w+\.mk$
 
 ^libinterp/dldfcn/module\.mk$
diff --git a/.hgsubstate b/.hgsubstate
--- a/.hgsubstate
+++ b/.hgsubstate
@@ -1,2 +1,2 @@
-0e3af50c9e20938bd1cea0182bf749ce61cb6782 gnulib
-0f7cc1d7ef5c34b146ff71207ada3ec87a24097c libgui/qterminal
+1af55d85d9762a679b4302d5995f05ccd883e956 gnulib
+0820083f7fe95d0088971b1233540c7827218e7c libgui/qterminal
diff --git a/.hgtags b/.hgtags
--- a/.hgtags
+++ b/.hgtags
@@ -62,8 +62,10 @@ 704f7895eef03008dd79848eb9da4bfb40787d73
 95c43fc8dbe1a07a46fefb3372df5b2309d874fd rc-3-6-1-0
 0000000000000000000000000000000000000000 release-3-2-4
 e320928eeb3aa2370b792e83dafc3e0ddecdc871 release-3-2-4
 ba4d6343524b406b0d15aee34579f80783581c54 release-3-6-1
 704f7895eef03008dd79848eb9da4bfb40787d73 release-3-6-0
 f947d2922febf12dcd1fb6e21b356756ecb54e55 rc-3-6-2-0
 4460c4fb20e6a5d3b1972fa737d4e00eb921545a rc-3-6-2-2
 551566201318bf615b27c60ccf9368f4844008bd release-3-6-2
+a95432e7309ca6fc776c02939264bb6d443f3525 release-3-6-3
+2e8eb9ac43a5f8cfaf0423814a312ed47cb80485 rc-3-6-4-0
diff --git a/Makefile.am b/Makefile.am
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,9 +1,9 @@
-# Makefile for octave
+# Makefile for Octave
 #
 # Copyright (C) 1993-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
@@ -32,19 +32,19 @@ EXTRA_DIST = \
   AUTHORS \
   BUGS \
   COPYING \
   ChangeLog \
   INSTALL \
   INSTALL.OCTAVE \
   NEWS \
   README \
-  autogen.sh \
-  build-aux/bootstrap \
-  build-aux/bootstrap.conf \
+  bootstrap \
+  build-aux/bootstrap_gnulib \
+  build-aux/bootstrap_gnulib.conf \
   build-aux/mk-opts.pl \
   build-aux/mkinstalldirs \
   build-aux/move-if-change \
   etc/NEWS.1 \
   etc/NEWS.2 \
   etc/NEWS.3 \
   etc/OLD-ChangeLogs/ChangeLog \
   etc/OLD-ChangeLogs/ChangeLog.1 \
@@ -62,24 +62,18 @@ EXTRA_DIST = \
   etc/README.Windows \
   etc/README.gnuplot \
   etc/README.kpathsea \
   etc/gdbinit \
   run-octave.in
 
 include m4/module.mk
 
-if AMCOND_BUILD_GUI
-GUIDIR = libgui
-else
-GUIDIR =
-endif
-
 # Subdirectories in which to run `make all'.
-SUBDIRS = libgnu libcruft liboctave libinterp $(GUIDIR) src scripts @DOCDIR@ examples test
+SUBDIRS = libgnu liboctave libinterp @GUIDIR@ src scripts @DOCDIR@ examples test
 
 if ! AMCOND_BUILD_DOCS
 dist-hook:
 	echo "Documentation disabled.  Cannot package distribution!" ; exit 1;
 endif
 
 BUILT_SOURCES = run-octave
 
diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -1,13 +1,24 @@
 Summary of important user-visible changes for version 4.0:
 ---------------------------------------------------------
 
  ** A new GUI is now available with Octave.
 
+ ** Warning states may now be set temporarily, until the end of the
+    current function, using the syntax
+
+      warning STATE ID "local"
+
+    in which STATE may be "on", "off", or "error".  Changes to warning
+    states that are set locally affect the current function and all
+    functions called from the current scope.  The previous warning state
+    is restored on return from the current function.  The "local"
+    option is ignored if used in the top-level workspace.
+
 Summary of important user-visible changes for version 3.8:
 ---------------------------------------------------------
 
  ** Octave now supports nested functions with scoping rules that are
     compatible with Matlab.  A nested function is one declared and defined
     within the body of another function.  The nested function is only
     accessible from within the enclosing function which makes it one
     method for making private functions whose names do not conflict with those
@@ -40,19 +51,26 @@ Summary of important user-visible change
     characters.  For example, 
 
     regexprep ('World', '^', 'Hello ', 'emptymatch')
       => Hello World
 
     where the pattern is actually the assertion '^' or start-of-line.
 
  ** For compatibility with Matlab, the regexp, regexpi, and regexprep
-    functions now process backslash escapes in single-quoted pattern
+    functions now process backslash escape sequences in single-quoted pattern
     strings.  In addition, the regexprep function now processes backslash
-    escapes in single-quoted replacement strings.
+    escapes in single-quoted replacement strings.  For example,
+    
+    regexprep (str, '\t', '\n')
+
+    would search the variable str for a TAB character (escape sequence \t)
+    and replace it with a NEWLINE (escape sequence \n).  Previously the
+    expression would have searched for a literal '\' followed by 't' and
+    replaced the two characters with the sequence '\', 'n'.
 
  ** Redundant terminal comma accepted by parser
 
     A redundant terminal comma is now accepted in matrix
     definitions which allows writing code such as 
 
     [a,...
      b,...
@@ -77,20 +95,21 @@ Summary of important user-visible change
     January 1st of the current year.  The previous default was the current day,
     month, and year.  This may produce changes in existing scripts.
 
  ** The default name of the Octave crash dump file is now called
     octave-workspace instead of octave-core.
       
  ** Other new functions added in 3.8.0:
 
-      betaincinv   erfcinv      polyeig      shrinkfaces 
-      cmpermute    findfigs     splinefit
-      cmunique     fminsearch   tetramesh
-      colorcube    lines        rgbplot     
+      betaincinv   erfcinv      lines      rgbplot
+      cmpermute    findfigs     polyeig    shrinkfaces
+      cmunique     fminsearch   splinefit
+      colorcube    iscolormap   tetramesh
+
  ** Deprecated functions.
 
     The following functions were deprecated in Octave 3.4 and have been
     removed from Octave 3.8.
                                            
       autocor    dispatch              is_global    strerror
       autocov    fstat                 krylovb      values  
       betai      gammai                perror               
diff --git a/README b/README
--- a/README
+++ b/README
@@ -61,19 +61,19 @@ or contributing patches.
 
 Documentation
 -------------
 
 Octave's manual has been revised for version 3.4, but it is lagging a
 bit behind the development of the software.  In particular, there is
 currently no complete documentation of the C++ class libraries.  If
 you notice omissions or inconsistencies, please report them on the
-bug tracker at http://savannah.gnu.org/bugs/?group=octave.  Specific
-suggestions for ways to improve Octave and its documentation are
-always welcome.  Reports with patches are even more welcome.
+bug tracker at http://bugs.octave.org.  Specific suggestions for ways
+to improve Octave and its documentation are always welcome.  Reports
+with patches are even more welcome.
 
 Additional Information
 ----------------------
 
 Up to date information about Octave is available on the WWW at the
 URL http://www.octave.org, including archives of the help, bug, and
 maintainers mailing lists.
 
diff --git a/autogen.sh b/bootstrap
rename from autogen.sh
rename to bootstrap
--- a/autogen.sh
+++ b/bootstrap
@@ -1,10 +1,10 @@
 #! /bin/sh
-# autogen.sh
+# bootstrap
 # Run this to generate all the initial makefiles, etc.
 
 set -e
 
 ## Use --foreign since we auto-generate the AUTHORS file and the default
 ## --gnu strictness level doesn't like it if the AUTHORS file is missing.
 
 AUTOMAKE="automake --foreign --warnings=no-portability"
@@ -17,31 +17,31 @@ export AUTOMAKE
 
 for f in NEWS README COPYING; do
   if ! test -f $f; then
     echo "required file $f is missing" 2>&1
     exit 1
   fi
 done
 
-echo "generating source lists for liboctave/Makefile..."
+echo "generating source lists for liboctave/operators/module.mk..."
 
-(cd liboctave; ./config-ops.sh)
+(cd liboctave/operators; ./config-ops.sh)
 
 echo "generating doc/interpreter/images.mk..."
 
 (cd doc/interpreter; ./config-images.sh)
 
 echo "generating libinterp/dldfcn/module.mk..."
 
 (cd libinterp/dldfcn; ./config-module.sh)
 
 echo "bootstrapping..."
 
-build-aux/bootstrap "$@"
+build-aux/bootstrap_gnulib "$@"
 
 ## G77 is obsolete, but it is still the first option in the autoconf Fortran
 ## macros.  We should avoid it, because mixing old versions of g77 with modern
 ## gcc and g++ causes trouble.  The following will make it harder (but not
 ## impossible) for users to make this mistake.
 ##
 ## FIXME -- we should really work to fix autoconf so that it prefers gfortran
 ## over g77 even when searching for a Fortran 77 compiler.
diff --git a/build-aux/bootstrap b/build-aux/bootstrap_gnulib
rename from build-aux/bootstrap
rename to build-aux/bootstrap_gnulib
diff --git a/build-aux/bootstrap.conf b/build-aux/bootstrap_gnulib.conf
rename from build-aux/bootstrap.conf
rename to build-aux/bootstrap_gnulib.conf
--- a/build-aux/bootstrap.conf
+++ b/build-aux/bootstrap_gnulib.conf
@@ -14,61 +14,72 @@
 
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 
 # gnulib modules used by this package.
 gnulib_modules="
   base64
-  c-strcase
+  canonicalize
+  chdir
+  close
+  closedir
   copysign
   copysignf
-  closedir
   crypto/md5
+  dup2
   fclose
   fcntl
+  fflush
   filemode
+  float
+  floor
+  floorf
   fnmatch
   fopen
-  fflush
   fseek
   ftell
   getcwd
   gethostname
   getopt-gnu
   gettimeofday
   glob
   isatty
   link
   lstat
+  malloc-gnu
   mkdir
   mkfifo
   mkostemp
-  mkstemp
   mktime
   nanosleep
   nproc
+  open
   opendir
   pathmax
+  putenv
   progname
   readdir
   readlink
+  realloc-gnu
   rename
-  rewinddir
   rmdir
   round
   roundf
+  select
   sigaction
   signal
   sigprocmask
   sleep
   stat
+  stddef
   stdint
   stdio
+  strerror
   strftime
   strptime
   symlink
   sys_stat
   sys_time
   sys_times
   time
   times
diff --git a/build-aux/common.mk b/build-aux/common.mk
--- a/build-aux/common.mk
+++ b/build-aux/common.mk
@@ -77,195 +77,184 @@ SHLLIBPRE = @SHLLIBPRE@
 SHLBINPRE = @SHLBINPRE@
 
 # Fortran compiler flags.
 
 FC = @FC@
 F77 = @F77@
 AM_FFLAGS = @FFLAGS@
 FPICFLAG = @FPICFLAG@
-ALL_FFLAGS = $(FFLAGS)
 F77_FLOAT_STORE_FLAG = @F77_FLOAT_STORE_FLAG@
 F77_INTEGER_8_FLAG = @F77_INTEGER_8_FLAG@
+ALL_FFLAGS = $(FFLAGS)
 
 F77_TOLOWER=@F77_TOLOWER@
 F77_APPEND_UNDERSCORE=@F77_TOLOWER@
 F77_APPEND_EXTRA_UNDERSCORE=@F77_TOLOWER@
 
 F77_ISNAN_MACRO=@F77_ISNAN_MACRO@
 
-X11_INCFLAGS = @X11_INCFLAGS@
-X11_LIBS = @X11_LIBS@
-
-CARBON_LIBS = @CARBON_LIBS@
-
-MAGICK_CPPFLAGS = @MAGICK_CPPFLAGS@
-MAGICK_LDFLAGS = @MAGICK_LDFLAGS@
-MAGICK_LIBS = @MAGICK_LIBS@
-
-PTHREAD_CFLAGS = @PTHREAD_CFLAGS@
-PTHREAD_LIBS = @PTHREAD_LIBS@
-
-LIBFLAGS = -L$(top_builddir)
-
-DEFS = @DEFS@
-
-UGLY_DEFS = @UGLY_DEFS@
+# C compiler flags.
 
 CC = @CC@
 ## FIXME: CC_VERSION is deprecated and should be removed in version 3.12
 CC_VERSION = @CC_VERSION@
 GCC_VERSION = @GCC_VERSION@
-CONFIGURE_CFLAGS = @CFLAGS@
 CPICFLAG = @CPICFLAG@
 XTRA_CFLAGS = @XTRA_CFLAGS@
 WARN_CFLAGS = @WARN_CFLAGS@
-AM_CFLAGS = $(CONFIGURE_CFLAGS) \
-  $(XTRA_CFLAGS) $(WARN_CFLAGS)
-BUG_CFLAGS = $(XTRA_CFLAGS) $(WARN_CFLAGS) $(CFLAGS)
+AM_CFLAGS = $(XTRA_CFLAGS)
+ALL_CPPFLAGS = $(CPPFLAGS) $(HDF5_CPPFLAGS) $(Z_CPPFLAGS) $(LLVM_CPPFLAGS)
 
 BUILD_CC = @BUILD_CC@
 BUILD_CFLAGS = @BUILD_CFLAGS@
 
 DEPEND_FLAGS = @DEPEND_FLAGS@
 DEPEND_EXTRA_SED_PATTERN = @DEPEND_EXTRA_SED_PATTERN@
 INCLUDE_DEPS = @INCLUDE_DEPS@
 # ifeq ($(INCLUDE_DEPS),false)
 #   omit_deps = true;
 # endif
 
-GRAPHICS_CFLAGS = @GRAPHICS_CFLAGS@
+DEFS = @DEFS@
+UGLY_DEFS = @UGLY_DEFS@
+
+# C++ compiler flags.
 
 CXX = @CXX@
 ## FIXME: CXX_VERSION is deprecated and should be removed in version 3.12
 CXX_VERSION = @CXX_VERSION@
 GXX_VERSION = @GXX_VERSION@
 CXXCPP = @CXXCPP@
-CONFIGURE_CXXFLAGS = @CXXFLAGS@
 CXXPICFLAG = @CXXPICFLAG@
 XTRA_CXXFLAGS = @XTRA_CXXFLAGS@
 WARN_CXXFLAGS = @WARN_CXXFLAGS@
-AM_CXXFLAGS = $(CONFIGURE_CXXFLAGS) \
-  $(XTRA_CXXFLAGS) $(WARN_CXXFLAGS)
-BUG_CXXFLAGS = $(XTRA_CXXFLAGS) $(WARN_CXXFLAGS) $(CXXFLAGS)
+AM_CXXFLAGS = $(XTRA_CXXFLAGS)
 
 BUILD_CXX = @BUILD_CXX@
 BUILD_CXXFLAGS = @BUILD_CXXFLAGS@
 
-NO_UNDEFINED_LDFLAG = @NO_UNDEFINED_LDFLAG@
+# Linker and library flags
 
 LD_CXX = @LD_CXX@
 LD_STATIC_FLAG = @LD_STATIC_FLAG@
+LIBFLAGS = -L$(top_builddir)
 #ALL_LDFLAGS = $(LIBFLAGS) $(LD_STATIC_FLAG) $(CPICFLAG) $(LDFLAGS)
 
 BUILD_LDFLAGS = @BUILD_LDFLAGS@
 
 SH_LD = @SH_LD@
 SH_LDFLAGS = @SH_LDFLAGS@
 
 DL_LD = @DL_LD@
 DL_LDFLAGS = @DL_LDFLAGS@
 
 SONAME_FLAGS = @SONAME_FLAGS@
 
 RDYNAMIC_FLAG = @RDYNAMIC_FLAG@
 
-FLIBS = @FLIBS@
+NO_UNDEFINED_LDFLAG = @NO_UNDEFINED_LDFLAG@
+
+# List of libraries and their special compilation flags
 
 LIBOCTINTERP = @LIBOCTINTERP@
 LIBOCTAVE = @LIBOCTAVE@
-LIBCRUFT = @LIBCRUFT@
 
-FT2_CFLAGS = @FT2_CFLAGS@
-FT2_LIBS = @FT2_LIBS@
-
-HDF5_CPPFLAGS = @HDF5_CPPFLAGS@
-HDF5_LDFLAGS = @HDF5_LDFLAGS@
-HDF5_LIBS = @HDF5_LIBS@
-
-Z_CPPFLAGS = @Z_CPPFLAGS@
-Z_LDFLAGS = @Z_LDFLAGS@
-Z_LIBS = @Z_LIBS@
-
-LLVM_CPPFLAGS = @LLVM_CPPFLAGS@
-LLVM_LDFLAGS = @LLVM_LDFLAGS@
-LLVM_LIBS = @LLVM_LIBS@
-
-GRAPHICS_LIBS = @GRAPHICS_LIBS@
-
-QHULL_CPPFLAGS = @QHULL_CPPFLAGS@
-QHULL_LDFLAGS = @QHULL_LDFLAGS@
-QHULL_LIBS = @QHULL_LIBS@
-
-REGEX_LIBS = @REGEX_LIBS@
-
-LAPACK_LIBS = @LAPACK_LIBS@
-BLAS_LIBS = @BLAS_LIBS@
-
-FFTW3_CPPFLAGS = @FFTW3_CPPFLAGS@
-FFTW3_LDFLAGS = @FFTW3_LDFLAGS@
-FFTW3_LIBS = @FFTW3_LIBS@
-
-FFTW3F_CPPFLAGS = @FFTW3F_CPPFLAGS@
-FFTW3F_LDFLAGS = @FFTW3F_LDFLAGS@
-FFTW3F_LIBS = @FFTW3F_LIBS@
-
-GLPK_CPPFLAGS = @GLPK_CPPFLAGS@
-GLPK_LDFLAGS = @GLPK_LDFLAGS@
-GLPK_LIBS = @GLPK_LIBS@
-
-CURL_CPPFLAGS = @CURL_CPPFLAGS@
-CURL_LDFLAGS = @CURL_LDFLAGS@
-CURL_LIBS = @CURL_LIBS@
+DL_LIBS = @DL_LIBS@
+FLIBS = @FLIBS@
+LIBS = @LIBS@
 
 AMD_CPPFLAGS = @AMD_CPPFLAGS@
 AMD_LDFLAGS = @AMD_LDFLAGS@
 AMD_LIBS = @AMD_LIBS@
 
+ARPACK_CPPFLAGS = @ARPACK_CPPFLAGS@
+ARPACK_LDFLAGS = @ARPACK_LDFLAGS@
+ARPACK_LIBS = @ARPACK_LIBS@
+
+BLAS_LIBS = @BLAS_LIBS@
+
 CAMD_CPPFLAGS = @CAMD_CPPFLAGS@
 CAMD_LDFLAGS = @CAMD_LDFLAGS@
 CAMD_LIBS = @CAMD_LIBS@
 
+CARBON_LIBS = @CARBON_LIBS@
+
 COLAMD_CPPFLAGS = @COLAMD_CPPFLAGS@
 COLAMD_LDFLAGS = @COLAMD_LDFLAGS@
 COLAMD_LIBS = @COLAMD_LIBS@
 
 CCOLAMD_CPPFLAGS = @CCOLAMD_CPPFLAGS@
 CCOLAMD_LDFLAGS = @CCOLAMD_LDFLAGS@
 CCOLAMD_LIBS = @CCOLAMD_LIBS@
 
 CHOLMOD_CPPFLAGS = @CHOLMOD_CPPFLAGS@
 CHOLMOD_LDFLAGS = @CHOLMOD_LDFLAGS@
 CHOLMOD_LIBS = @CHOLMOD_LIBS@
 
+CURL_CPPFLAGS = @CURL_CPPFLAGS@
+CURL_LDFLAGS = @CURL_LDFLAGS@
+CURL_LIBS = @CURL_LIBS@
+
 CXSPARSE_CPPFLAGS = @CXSPARSE_CPPFLAGS@
 CXSPARSE_LDFLAGS = @CXSPARSE_LDFLAGS@
 CXSPARSE_LIBS = @CXSPARSE_LIBS@
 
-UMFPACK_CPPFLAGS = @UMFPACK_CPPFLAGS@
-UMFPACK_LDFLAGS = @UMFPACK_LDFLAGS@
-UMFPACK_LIBS = @UMFPACK_LIBS@
+FFTW3_CPPFLAGS = @FFTW3_CPPFLAGS@
+FFTW3_LDFLAGS = @FFTW3_LDFLAGS@
+FFTW3_LIBS = @FFTW3_LIBS@
+
+FFTW3F_CPPFLAGS = @FFTW3F_CPPFLAGS@
+FFTW3F_LDFLAGS = @FFTW3F_LDFLAGS@
+FFTW3F_LIBS = @FFTW3F_LIBS@
+
+FFTW_XCPPFLAGS = $(FFTW3_CPPFLAGS) $(FFTW3F_CPPFLAGS)
+FFTW_XLDFLAGS = $(FFTW3_LDFLAGS) $(FFTW3F_LDFLAGS)
+FFTW_XLIBS = $(FFTW3_LIBS) $(FFTW3F_LIBS)
+
+FT2_CFLAGS = @FT2_CFLAGS@
+FT2_LIBS = @FT2_LIBS@
+
+GLPK_CPPFLAGS = @GLPK_CPPFLAGS@
+GLPK_LDFLAGS = @GLPK_LDFLAGS@
+GLPK_LIBS = @GLPK_LIBS@
+
+GRAPHICS_CFLAGS = @GRAPHICS_CFLAGS@
+GRAPHICS_LIBS = @GRAPHICS_LIBS@
+
+HDF5_CPPFLAGS = @HDF5_CPPFLAGS@
+HDF5_LDFLAGS = @HDF5_LDFLAGS@
+HDF5_LIBS = @HDF5_LIBS@
+
+LAPACK_LIBS = @LAPACK_LIBS@
+
+LLVM_CPPFLAGS = @LLVM_CPPFLAGS@
+LLVM_LDFLAGS = @LLVM_LDFLAGS@
+LLVM_LIBS = @LLVM_LIBS@
+
+MAGICK_CPPFLAGS = @MAGICK_CPPFLAGS@
+MAGICK_LDFLAGS = @MAGICK_LDFLAGS@
+MAGICK_LIBS = @MAGICK_LIBS@
 
 OPENGL_LIBS = @OPENGL_LIBS@
 
+PTHREAD_CFLAGS = @PTHREAD_CFLAGS@
+PTHREAD_LIBS = @PTHREAD_LIBS@
+
+QHULL_CPPFLAGS = @QHULL_CPPFLAGS@
+QHULL_LDFLAGS = @QHULL_LDFLAGS@
+QHULL_LIBS = @QHULL_LIBS@
+
 QRUPDATE_CPPFLAGS = @QRUPDATE_CPPFLAGS@
 QRUPDATE_LDFLAGS = @QRUPDATE_LDFLAGS@
 QRUPDATE_LIBS = @QRUPDATE_LIBS@
 
-READLINE_LIBS = @READLINE_LIBS@
-TERM_LIBS = @TERM_LIBS@
+REGEX_LIBS = @REGEX_LIBS@
 
-ARPACK_CPPFLAGS = @ARPACK_CPPFLAGS@
-ARPACK_LDFLAGS = @ARPACK_LDFLAGS@
-ARPACK_LIBS = @ARPACK_LIBS@
-
-DL_LIBS = @DL_LIBS@
-LIBS = @LIBS@
-
-ALL_CPPFLAGS = $(CPPFLAGS) $(HDF5_CPPFLAGS) $(Z_CPPFLAGS) $(LLVM_CPPFLAGS)
+READLINE_LIBS = @READLINE_LIBS@
 
 SPARSE_XCPPFLAGS = \
   $(CHOLMOD_CPPFLAGS) $(UMFPACK_CPPFLAGS) \
   $(AMD_CPPFLAGS) $(CAMD_CPPFLAGS) $(COLAMD_CPPFLAGS) \
   $(CCOLAMD_CPPFLAGS) $(CXSPARSE_CPPFLAGS)
 
 SPARSE_XLDFLAGS = \
   $(CHOLMOD_LDFLAGS) $(UMFPACK_LDFLAGS) \
@@ -273,21 +262,30 @@ SPARSE_XLDFLAGS = \
   $(CCOLAMD_LDFLAGS) $(CXSPARSE_LDFLAGS)
 
 ## Order matters, at least on some systems (Cygwin, for example).
 SPARSE_XLIBS = \
     $(CHOLMOD_LIBS) $(UMFPACK_LIBS) \
     $(AMD_LIBS) $(CAMD_LIBS) $(COLAMD_LIBS) \
     $(CCOLAMD_LIBS) $(CXSPARSE_LIBS)
 
-FFTW_XCPPFLAGS = $(FFTW3_CPPFLAGS) $(FFTW3F_CPPFLAGS)
+TERM_LIBS = @TERM_LIBS@
+
+UMFPACK_CPPFLAGS = @UMFPACK_CPPFLAGS@
+UMFPACK_LDFLAGS = @UMFPACK_LDFLAGS@
+UMFPACK_LIBS = @UMFPACK_LIBS@
 
-FFTW_XLDFLAGS = $(FFTW3_LDFLAGS) $(FFTW3F_LDFLAGS)
+X11_INCFLAGS = @X11_INCFLAGS@
+X11_LIBS = @X11_LIBS@
 
-FFTW_XLIBS = $(FFTW3_LIBS) $(FFTW3F_LIBS)
+Z_CPPFLAGS = @Z_CPPFLAGS@
+Z_LDFLAGS = @Z_LDFLAGS@
+Z_LIBS = @Z_LIBS@
+
+# Miscellaneous
 
 USE_64_BIT_IDX_T = @USE_64_BIT_IDX_T@
 OCTAVE_IDX_TYPE = @OCTAVE_IDX_TYPE@
 
 TEXINFO_COLAMD = @TEXINFO_COLAMD@
 TEXINFO_CHOLMOD = @TEXINFO_CHOLMOD@
 TEXINFO_UMFPACK = @TEXINFO_UMFPACK@
 TEXINFO_QHULL = @TEXINFO_QHULL@
@@ -324,17 +322,17 @@ datarootdir = @datarootdir@
 # and ${localfcnfiledir} are subdirectories of this.
 datadir = @datadir@
 
 libdir = @libdir@
 
 # Where to install and expect extra files like NEWS and doc-cache.
 octetcdir = @octetcdir@
 
-# Where to install and expect libraries like libcruft.a, liboctave.a,
+# Where to install and expect libraries like liboctave.a, liboctinterp.a,
 # and other architecture-dependent data.
 octlibdir = @octlibdir@
 
 # Where to install and expect executable programs to be run by Octave
 # rather than directly by users.
 libexecdir = @libexecdir@
 
 # The prefix for Octave's include file directory.  The default is
@@ -426,16 +424,18 @@ library_path_var = @library_path_var@
 
 # The separator used for elements of the LD_PRELOAD variable (might be
 # a space, so protect with $(null))
 null =
 ldpreloadsep = $(null)@ldpreloadsep@$(null)
 
 NO_OCT_FILE_STRIP = @NO_OCT_FILE_STRIP@
 
+# ==================== Octave-specific Makefile rules ====================
+
 # The following pattern rules and the substitution functions require
 # GNU make.  If you don't have it, get it!
 
 define simple_move_if_change_rule
 if [ -s $@-t ]; then \
   $(top_srcdir)/build-aux/move-if-change $@-t $@; \
 else \
   echo "$@-t is empty!" 1>&2; \
@@ -505,63 +505,65 @@ echo "making $@ from $<"
   -e "s|%OCTAVE_CONF_CXXPICFLAG%|\"${CXXPICFLAG}\"|" \
   -e "s|%OCTAVE_CONF_CXX_VERSION%|\"${CXX_VERSION}\"|" \
   -e "s|%OCTAVE_CONF_DEFAULT_PAGER%|\"${DEFAULT_PAGER}\"|" \
   -e "s|%OCTAVE_CONF_DEPEND_FLAGS%|\"${DEPEND_FLAGS}\"|" \
   -e "s|%OCTAVE_CONF_DEPEND_EXTRA_SED_PATTERN%|\"${DEPEND_EXTRA_SED_PATTERN}\"|" \
   -e "s|%OCTAVE_CONF_DL_LD%|\"${DL_LD}\"|" \
   -e "s|%OCTAVE_CONF_DL_LDFLAGS%|\"${DL_LDFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_DL_LIBS%|\"${DL_LIBS}\"|" \
+  -e "s|%OCTAVE_CONF_ENABLE_DYNAMIC_LINKING%|\"${ENABLE_DYNAMIC_LINKING}\"|" \
+  -e "s|%OCTAVE_CONF_EXEEXT%|\"${EXEEXT}\"|" \
   -e "s|%OCTAVE_CONF_GCC_VERSION%|\"${GCC_VERSION}\"|" \
   -e "s|%OCTAVE_CONF_GXX_VERSION%|\"${GXX_VERSION}\"|" \
-  -e "s|%OCTAVE_CONF_EXEEXT%|\"${EXEEXT}\"|" \
   -e "s|%OCTAVE_CONF_F77%|\"${F77}\"|" \
   -e "s|%OCTAVE_CONF_F77_FLOAT_STORE_FLAG%|\"${F77_FLOAT_STORE_FLAG}\"|" \
   -e "s|%OCTAVE_CONF_F77_INTEGER_8_FLAG%|\"${F77_INTEGER_8_FLAG}\"|" \
   -e "s|%OCTAVE_CONF_FC%|\"${FC}\"|" \
   -e "s|%OCTAVE_CONF_FFLAGS%|\"${FFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_FFTW3_CPPFLAGS%|\"${FFTW3_CPPFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_FFTW3_LDFLAGS%|\"${FFTW3_LDFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_FFTW3_LIBS%|\"${FFTW3_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_FFTW3F_CPPFLAGS%|\"${FFTW3F_CPPFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_FFTW3F_LDFLAGS%|\"${FFTW3F_LDFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_FFTW3F_LIBS%|\"${FFTW3F_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_FLIBS%|\"${FLIBS}\"|" \
   -e "s|%OCTAVE_CONF_FPICFLAG%|\"${FPICFLAG}\"|" \
+  -e "s|%OCTAVE_CONF_FT2_CFLAGS%|\"${FT2_CFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_FT2_LIBS%|\"${FT2_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_GLPK_CPPFLAGS%|\"${GLPK_CPPFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_GLPK_LDFLAGS%|\"${GLPK_LDFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_GLPK_LIBS%|\"${GLPK_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_GNUPLOT%|\"${GNUPLOT}\"|" \
+  -e "s|%OCTAVE_CONF_GRAPHICS_CFLAGS%|\"${GRAPHICS_CFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_GRAPHICS_LIBS%|\"${GRAPHICS_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_HDF5_CPPFLAGS%|\"${HDF5_CPPFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_HDF5_LDFLAGS%|\"${HDF5_LDFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_HDF5_LIBS%|\"${HDF5_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_INCLUDEDIR%|\"${includedir}\"|" \
   -e "s|%OCTAVE_CONF_LAPACK_LIBS%|\"${LAPACK_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_LD_CXX%|\"${LD_CXX}\"|" \
   -e "s|%OCTAVE_CONF_LDFLAGS%|\"${LDFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_LD_STATIC_FLAG%|\"${LD_STATIC_FLAG}\"|" \
   -e "s|%OCTAVE_CONF_LEX%|\"${LEX}\"|" \
   -e "s|%OCTAVE_CONF_LEXLIB%|\"${LEXLIB}\"|" \
   -e "s|%OCTAVE_CONF_LFLAGS%|\"${LFLAGS}\"|" \
-  -e "s|%OCTAVE_CONF_LIBCRUFT%|\"${LIBCRUFT}\"|" \
   -e "s|%OCTAVE_CONF_LIBDIR%|\"${libdir}\"|" \
   -e "s|%OCTAVE_CONF_LIBEXT%|\"${LIBEXT}\"|" \
   -e "s|%OCTAVE_CONF_LIBFLAGS%|\"${LIBFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_LIBOCTAVE%|\"${LIBOCTAVE}\"|" \
   -e "s|%OCTAVE_CONF_LIBOCTINTERP%|\"${LIBOCTINTERP}\"|" \
   -e "s|%OCTAVE_CONF_LIBS%|\"${LIBS}\"|" \
+  -e "s|%OCTAVE_CONF_LLVM_CPPFLAGS%|\"${LLVM_CPPFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_LLVM_LDFLAGS%|\"${LLVM_LDFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_LLVM_LIBS%|\"${LLVM_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_LN_S%|\"${LN_S}\"|" \
   -e "s|%OCTAVE_CONF_MAGICK_CPPFLAGS%|\"${MAGICK_CPPFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_MAGICK_LDFLAGS%|\"${MAGICK_LDFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_MAGICK_LIBS%|\"${MAGICK_LIBS}\"|" \
-  -e "s|%OCTAVE_CONF_LLVM_CPPFLAGS%|\"${LLVM_CPPFLAGS}\"|" \
-  -e "s|%OCTAVE_CONF_LLVM_LDFLAGS%|\"${LLVM_LDFLAGS}\"|" \
-  -e "s|%OCTAVE_CONF_LLVM_LIBS%|\"${LLVM_LIBS}\"|" \
   -e 's|%OCTAVE_CONF_MKOCTFILE_DL_LDFLAGS%|\"@MKOCTFILE_DL_LDFLAGS@\"|' \
   -e "s|%OCTAVE_CONF_OCTAVE_LINK_DEPS%|\"${OCTAVE_LINK_DEPS}\"|" \
   -e "s|%OCTAVE_CONF_OCTAVE_LINK_OPTS%|\"${OCTAVE_LINK_OPTS}\"|" \
   -e "s|%OCTAVE_CONF_OCTINCLUDEDIR%|\"${octincludedir}\"|" \
   -e "s|%OCTAVE_CONF_OCTLIBDIR%|\"${octlibdir}\"|" \
   -e "s|%OCTAVE_CONF_OCT_LINK_DEPS%|\"${OCT_LINK_DEPS}\"|" \
   -e "s|%OCTAVE_CONF_OCT_LINK_OPTS%|\"${OCT_LINK_OPTS}\"|" \
   -e "s|%OCTAVE_CONF_OPENGL_LIBS%|\"${OPENGL_LIBS}\"|" \
@@ -591,17 +593,18 @@ echo "making $@ from $<"
   -e "s|%OCTAVE_CONF_STATIC_LIBS%|\"${STATIC_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_TERM_LIBS%|\"${TERM_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_UGLY_DEFS%|\"${UGLY_DEFS}\"|" \
   -e "s|%OCTAVE_CONF_UMFPACK_CPPFLAGS%|\"${UMFPACK_CPPFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_UMFPACK_LDFLAGS%|\"${UMFPACK_LDFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_UMFPACK_LIBS%|\"${UMFPACK_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_USE_64_BIT_IDX_T%|\"${USE_64_BIT_IDX_T}\"|" \
   -e "s|%OCTAVE_CONF_VERSION%|\"${version}\"|" \
-  -e "s|%OCTAVE_CONF_ENABLE_DYNAMIC_LINKING%|\"${ENABLE_DYNAMIC_LINKING}\"|" \
+  -e "s|%OCTAVE_CONF_WARN_CFLAGS%|\"${WARN_CFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_WARN_CXXFLAGS%|\"${WARN_CXXFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_X11_INCFLAGS%|\"${X11_INCFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_X11_LIBS%|\"${X11_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_XTRA_CFLAGS%|\"${XTRA_CFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_XTRA_CXXFLAGS%|\"${XTRA_CXXFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_YACC%|\"${YACC}\"|" \
   -e "s|%OCTAVE_CONF_YFLAGS%|\"${YFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_Z_CPPFLAGS%|\"${Z_CPPFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_Z_LDFLAGS%|\"${Z_LDFLAGS}\"|" \
@@ -660,17 +663,16 @@ define do_subst_script_vals
 echo "making $@ from $<"
 $(SED) < $< \
   -e "s|%AWK%|${AWK}|g" \
   -e "s|%FIND%|${FIND}|g" \
   -e "s|%SED%|${SED}|g" \
   -e "s|%library_path_var%|${library_path_var}|g" \
   -e "s|%liboctinterp%|${SHLPRE}octinterp.${SHLEXT}|g" \
   -e "s|%liboctave%|${SHLPRE}octave.${SHLEXT}|g" \
-  -e "s|%libcruft%|${SHLPRE}cruft.${SHLEXT}|g" \
   -e "s|%ldpreloadsep%|${ldpreloadsep}|g" \
   -e "s|%srcdir%|${srcdir}|" \
   -e "s|%top_srcdir%|${top_srcdir}|" \
   -e "s|%abs_top_srcdir%|${abs_top_srcdir}|" \
   -e "s|%builddir%|$(shell pwd)|" > $@-t
 $(simple_move_if_change_rule)
 endef
 
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -53,129 +53,128 @@ AM_INIT_AUTOMAKE([1.11 tar-ustar])
 OCTAVE_HOST_TYPE
 
 AC_DEFINE(OCTAVE_SOURCE, 1, [Define to 1 if this is Octave.])
   
 AC_USE_SYSTEM_EXTENSIONS
 
 ### Path separator.
 
-sepchar=:
-AC_ARG_WITH(sepchar,
+sepchar=':'
+AC_ARG_WITH([sepchar],
   [AS_HELP_STRING([--with-sepchar=<char>],
     [use <char> as the path separation character])])
 case $with_sepchar in
   yes | "")
-    case "$canonical_host_type" in
+    case $canonical_host_type in
       *-*-mingw* | *-*-msdosmsvc)
-        sepchar=';'
-        ;;
-      esac
+        sepchar=';' ;;
+    esac
     ;;
   no)
     AC_MSG_ERROR([You are required to define a path separation character])
     ;;
   *)
     sepchar=$with_sepchar
     ;;
 esac
 AC_SUBST(sepchar)
 AC_DEFINE_UNQUOTED(SEPCHAR, ['$sepchar'],
   [Define this to be the path separator for your system, as a character constant.])
 AC_DEFINE_UNQUOTED(SEPCHAR_STR, ["$sepchar"],
   [Define this to be the path separator for your system, as a string.])
 
 ### Set default file locations
 
-OCTAVE_SET_DEFAULT(man1dir, '$(mandir)/man1')
-OCTAVE_SET_DEFAULT(man1ext, '.1')
-OCTAVE_SET_DEFAULT(doc_cache_file, '$(octetcdir)/doc-cache')
-OCTAVE_SET_DEFAULT(texi_macros_file, '$(octetcdir)/macros.texi')
-OCTAVE_SET_DEFAULT(infofile, '$(infodir)/octave.info')
-OCTAVE_SET_DEFAULT(octincludedir, '$(includedir)/octave-$(version)/octave')
-OCTAVE_SET_DEFAULT(fcnfiledir, '$(datadir)/octave/$(version)/m')
-OCTAVE_SET_DEFAULT(localfcnfiledir, '$(datadir)/octave/site/m')
-OCTAVE_SET_DEFAULT(localapifcnfiledir,
+OCTAVE_SET_DEFAULT([man1dir], '$(mandir)/man1')
+OCTAVE_SET_DEFAULT([man1ext], '.1')
+OCTAVE_SET_DEFAULT([doc_cache_file], '$(octetcdir)/doc-cache')
+OCTAVE_SET_DEFAULT([texi_macros_file], '$(octetcdir)/macros.texi')
+OCTAVE_SET_DEFAULT([infofile], '$(infodir)/octave.info')
+OCTAVE_SET_DEFAULT([octincludedir], '$(includedir)/octave-$(version)/octave')
+OCTAVE_SET_DEFAULT([fcnfiledir], '$(datadir)/octave/$(version)/m')
+OCTAVE_SET_DEFAULT([localfcnfiledir], '$(datadir)/octave/site/m')
+OCTAVE_SET_DEFAULT([localapifcnfiledir],
   '$(datadir)/octave/site/$(api_version)/m')
-OCTAVE_SET_DEFAULT(localverfcnfiledir, '$(datadir)/octave/$(version)/site/m')
-OCTAVE_SET_DEFAULT(octetcdir, '$(datadir)/octave/$(version)/etc')
-OCTAVE_SET_DEFAULT(octlibdir, '$(libdir)/octave/$(version)')
-OCTAVE_SET_DEFAULT(archlibdir,
+OCTAVE_SET_DEFAULT([localverfcnfiledir], '$(datadir)/octave/$(version)/site/m')
+OCTAVE_SET_DEFAULT([octetcdir], '$(datadir)/octave/$(version)/etc')
+OCTAVE_SET_DEFAULT([octlibdir], '$(libdir)/octave/$(version)')
+OCTAVE_SET_DEFAULT([archlibdir],
   '$(libexecdir)/octave/$(version)/exec/$(canonical_host_type)')
-OCTAVE_SET_DEFAULT(localarchlibdir,
+OCTAVE_SET_DEFAULT([localarchlibdir],
   '$(libexecdir)/octave/site/exec/$(canonical_host_type)')
-OCTAVE_SET_DEFAULT(localapiarchlibdir,
+OCTAVE_SET_DEFAULT([localapiarchlibdir],
   '$(libexecdir)/octave/$(api_version)/site/exec/$(canonical_host_type)')
-OCTAVE_SET_DEFAULT(localverarchlibdir,
+OCTAVE_SET_DEFAULT([localverarchlibdir],
   '$(libexecdir)/octave/$(version)/site/exec/$(canonical_host_type)')
-OCTAVE_SET_DEFAULT(octfiledir,
+OCTAVE_SET_DEFAULT([octfiledir],
   '$(libdir)/octave/$(version)/oct/$(canonical_host_type)')
-OCTAVE_SET_DEFAULT(localoctfiledir,
+OCTAVE_SET_DEFAULT([localoctfiledir],
   '$(libdir)/octave/site/oct/$(canonical_host_type)')
-OCTAVE_SET_DEFAULT(localapioctfiledir,
+OCTAVE_SET_DEFAULT([localapioctfiledir],
   '$(libdir)/octave/site/oct/$(api_version)/$(canonical_host_type)')
-OCTAVE_SET_DEFAULT(localveroctfiledir,
+OCTAVE_SET_DEFAULT([localveroctfiledir],
   '$(libdir)/octave/$(version)/site/oct/$(canonical_host_type)')
-OCTAVE_SET_DEFAULT(imagedir, '$(datadir)/octave/$(version)/imagelib')
+OCTAVE_SET_DEFAULT([imagedir], '$(datadir)/octave/$(version)/imagelib')
 
 ### Find pkg-config executable (sets $PKG_CONFIG)
 
 PKG_PROG_PKG_CONFIG
 
 ### Make configure args available for other uses.
 
 config_opts=$ac_configure_args
 AC_SUBST(config_opts)
 
 ### Enable bounds checking on element references within Octave's array and
 ### matrix classes.  This slows down some operations a bit, so it is turned off
 ### by default.
 
 BOUNDS_CHECKING=false
-AC_ARG_ENABLE(bounds-check,
+AC_ARG_ENABLE([bounds-check],
   [AS_HELP_STRING([--enable-bounds-check],
-    [bounds checking for indexing in internal array classes (default is no)])],
+    [enable bounds checking for indexing in internal array classes])],
   [if test "$enableval" = yes; then BOUNDS_CHECKING=true; fi], [])
 if $BOUNDS_CHECKING; then
   AC_DEFINE(BOUNDS_CHECKING, 1, [Define to 1 to use internal bounds checking.])
 fi
 
 ### Use Octave's built-in memory allocator rather than straightforward malloc.
 ### Disabled by default.
 
 USE_OCTAVE_ALLOCATOR=false
-AC_ARG_ENABLE(octave-allocator,
+AC_ARG_ENABLE([octave-allocator],
   [AS_HELP_STRING([--enable-octave-allocator],
-    [use the obsolete octave_allocator class for many of Octave's objects (mostly octave_value types).  You probably do NOT want to enable this feature.  (default is no)])],
+    [use the obsolete octave_allocator class for many of Octave's objects (mostly octave_value types).  You probably do NOT want to enable this feature.])],
   [if test "$enableval" = yes; then USE_OCTAVE_ALLOCATOR=true; fi], [])
 if $USE_OCTAVE_ALLOCATOR; then
   AC_DEFINE(USE_OCTAVE_ALLOCATOR, 1,
     [Define to 1 to use octave_allocator class.])
 fi
 
 ### Use atomic operations for internal reference counting.  This is required
 ### for thread-safe behavior but incurs a significant slowdown, and is thus
 ### disabled by default.
 
 USE_ATOMIC_REFCOUNT=false
-AC_ARG_ENABLE(atomic-refcount,
+AC_ARG_ENABLE([atomic-refcount],
   [AS_HELP_STRING([--enable-atomic-refcount],
-    [use atomic operations for internal reference counting.  This is required for thread-safe behavior.  (default is no)])],
+    [use atomic operations for internal reference counting.  This is required for thread-safe behavior but does not by itself make Octave internals thread safe.])],
   [if test "$enableval" = yes; then USE_ATOMIC_REFCOUNT=true; fi], [])
 if $USE_ATOMIC_REFCOUNT; then
   AC_DEFINE(USE_ATOMIC_REFCOUNT, 1,
     [Define to 1 to use atomic operations for reference counting.])
 fi
 
 ### Disable running Make in the doc directory.
 ### This is useful, for example, when building Octave on systems without TeX.
 
 DOCDIR=doc
-AC_ARG_ENABLE(docs,
-  [AS_HELP_STRING([--enable-docs], [build documentation (default is yes)])],
+AC_ARG_ENABLE([docs],
+  [AS_HELP_STRING([--disable-docs], [don't build documentation files])],
   [if test "$enableval" = no; then
      DOCDIR=
      warn_docs="building documentation disabled; make dist will fail"
      OCTAVE_CONFIGURE_WARNING([warn_docs])
    fi],
   [])
 AC_SUBST(DOCDIR)
 
@@ -183,19 +182,19 @@ AC_SUBST(DOCDIR)
 
 USE_64_BIT_IDX_T=false
 OCTAVE_IDX_TYPE=int
 AC_ARG_ENABLE(64,
   [AS_HELP_STRING([--enable-64],
     [(EXPERIMENTAL) use 64-bit integers for array dimensions and indexing])],
   [if test "$enableval" = yes; then USE_64_BIT_IDX_T=true; fi], [])
 if $USE_64_BIT_IDX_T; then
-  AC_CHECK_SIZEOF(void *)
-  AC_CHECK_SIZEOF(int)
-  AC_CHECK_SIZEOF(long)
+  AC_CHECK_SIZEOF([void *])
+  AC_CHECK_SIZEOF([int])
+  AC_CHECK_SIZEOF([long])
   if test $ac_cv_sizeof_void_p -eq 8; then
     if test $ac_cv_sizeof_int -eq 8; then
       OCTAVE_IDX_TYPE=int
     elif test $ac_cv_sizeof_long -eq 8; then
       OCTAVE_IDX_TYPE=long
       AC_DEFINE(IDX_TYPE_LONG, 1, [Define to 1 if octave index type is long.])
     else
       warn_64_bit="no suitable type found for octave_idx_type so disabling 64-bit features"
@@ -204,17 +203,17 @@ if $USE_64_BIT_IDX_T; then
     fi
   else
     warn_64_bit="pointers are not 64-bits wide; disabling 64-bit features"
     OCTAVE_CONFIGURE_WARNING([warn_64_bit])
     USE_64_BIT_IDX_T=false
   fi
 fi
 AC_SUBST(OCTAVE_IDX_TYPE)
-AC_DEFINE_UNQUOTED(OCTAVE_IDX_TYPE, $OCTAVE_IDX_TYPE,
+AC_DEFINE_UNQUOTED(OCTAVE_IDX_TYPE, [$OCTAVE_IDX_TYPE],
   [Define to the type of octave_idx_type (64 or 32 bit signed integer).])
 if $USE_64_BIT_IDX_T; then
   AC_DEFINE(USE_64_BIT_IDX_T, 1,
     [Define to 1 if using 64-bit integers for array dimensions and indexing.])
 fi
 AC_SUBST(USE_64_BIT_IDX_T)
 
 ### It seems that there are some broken inline assembly functions in
@@ -235,33 +234,33 @@ AC_PROG_CXXCPP
 GXX_VERSION=
 if test "$GXX" = yes; then
   gxx_version=`$CXX -v 2>&1 | grep "^.*g.. version" | \
     sed -e 's/^.*g.. version *//' -e 's/cygnus-//' -e 's/egcs-//' -e 's/ .*//'`
 
   AX_COMPARE_VERSION([$gxx_version], [lt], [3.5],
     [AC_MSG_ERROR([g++ version $gxx_version will probably fail to compile Octave])])
 
-  GXX_VERSION="$gxx_version"
+  GXX_VERSION=$gxx_version
 fi
 AC_SUBST(GXX_VERSION)
 
-## FIXME: CXX_VERSION is deprecated and should be removed in version 3.12
-CXX_VERSION="$gxx_version"
+## FIXME: CXX_VERSION is deprecated and should be removed in Octave version 3.12
+CXX_VERSION=$gxx_version
 AC_SUBST(CXX_VERSION)
 
 ### Determine which C compiler to use (we expect to find gcc).
 
 AC_PROG_CC
 AC_PROG_CPP
 AC_PROG_GCC_TRADITIONAL
 
 ## Check for MSVC
 have_msvc=no
-case "$canonical_host_type" in
+case $canonical_host_type in
   *-*-msdosmsvc)
     have_msvc=yes
   ;;
   *-*-mingw*)
     AC_MSG_CHECKING([for MSVC compiler])
     AC_PREPROC_IFELSE([AC_LANG_SOURCE([[
         #ifndef _MSC_VER
         #error "Not MSVC compiler"
@@ -283,42 +282,40 @@ GCC_VERSION=
 if test "$GCC" = yes; then
   gcc_version=`$CC -v 2>&1 | grep "^.*gcc version" | \
     sed -e 's/^.*g.. version *//' -e 's/cygnus-//' -e 's/egcs-//' -e 's/ .*//'`
 
   AX_COMPARE_VERSION([$gcc_version], [lt], [3],
     [warn_gcc_version="gcc version $gcc_version is likely to cause problems"
      OCTAVE_CONFIGURE_WARNING([warn_gcc_version])])
 
-  GCC_VERSION="$gcc_version"
+  GCC_VERSION=$gcc_version
 fi
 AC_SUBST(CC_VERSION)
 
-## FIXME: CC_VERSION is deprecated and should be removed in version 3.12
-CC_VERSION="$gcc_version"
+## FIXME: CC_VERSION is deprecated and should be removed in Octave version 3.12
+CC_VERSION=$gcc_version
 AC_SUBST(GCC_VERSION)
 
 ### Determine the compiler flag necessary to create dependencies
 
 ## Assume GCC.
 INCLUDE_DEPS=true
 DEPEND_FLAGS="-M"
 DEPEND_EXTRA_SED_PATTERN=""
-if test "$GCC" = yes; then
-  true
-else
-  case "$canonical_host_type" in
+if test "$GCC" != yes; then
+  case $canonical_host_type in
     sparc-sun-solaris2* | i386-pc-solaris2*)
       DEPEND_FLAGS="-xM1"
       DEPEND_EXTRA_SED_PATTERN="-e '/\/opt\/SUNWspro/d'"
     ;;
     *-*-msdosmsvc)
     ;;
     *-*-mingw*)
-      if test "$have_msvc" = "no"; then
+      if test $have_msvc = no; then
         INCLUDE_DEPS=false
       fi
     ;;
     *)
       INCLUDE_DEPS=false
     ;;
   esac
 fi
@@ -337,98 +334,98 @@ CXXFLAGS="$CXXFLAGS $PTHREAD_CFLAGS"
 
 ### When compiling math for x87, problems may arise in some code comparing
 ### floating-point intermediate results.
 ### Generally, it helps to store the result in a local volatile variable,
 ### but it also degrades performance.
 ### Thus, we provide a FLOAT_TRUNCATE macro that may be defined to "volatile"
 ### when compiling for x87 target, or left empty for modern SSE math, that
 ### doesn't suffer from this problem at all.
-AC_ARG_ENABLE(float-truncate,
+AC_ARG_ENABLE([float-truncate],
   [AS_HELP_STRING([--enable-float-truncate],
     [enables truncating intermediate FP results.])],
   [if test "$enableval" = yes; then
-     ac_float_truncate=volatile;
+     ac_float_truncate=volatile
    else
-     ac_float_truncate=;
+     ac_float_truncate=
    fi],
   [ac_float_truncate=])
 
-AC_DEFINE_UNQUOTED(FLOAT_TRUNCATE, $ac_float_truncate, 
+AC_DEFINE_UNQUOTED(FLOAT_TRUNCATE, [$ac_float_truncate], 
   [Define to volatile if you need to truncate intermediate FP results.])
 
 ### Determine extra CFLAGS that may be necessary for Octave.
 
 ## On Intel systems with gcc, we may need to compile with -mieee-fp
 ## to get full support for IEEE floating point.
 ##
 ## On Alpha/OSF systems, we need -mieee.
 
 ieee_fp_flag=
-case "$canonical_host_type" in
+case $canonical_host_type in
   i[[3456789]]86-*-*)
     if test "$GCC" = yes; then
-      OCTAVE_CC_FLAG(-mieee-fp, [
+      OCTAVE_CC_FLAG([-mieee-fp], [
         ieee_fp_flag=-mieee-fp
         XTRA_CFLAGS="$XTRA_CFLAGS -mieee-fp"
         AC_MSG_NOTICE([adding -mieee-fp to XTRA_CFLAGS])])
     fi
     if test "$GXX" = yes; then
-      OCTAVE_CXX_FLAG(-mieee-fp, [
+      OCTAVE_CXX_FLAG([-mieee-fp], [
         ieee_fp_flag=-mieee-fp
         XTRA_CXXFLAGS="$XTRA_CXXFLAGS -mieee-fp"
         AC_MSG_NOTICE([adding -mieee-fp to XTRA_CXXFLAGS])])
     fi
   ;;
   alpha*-*-*)
     if test "$GCC" = yes; then
-      OCTAVE_CC_FLAG(-mieee, [
+      OCTAVE_CC_FLAG([-mieee], [
         ieee_fp_flag=-mieee
         XTRA_CFLAGS="$XTRA_CFLAGS -mieee"
         AC_MSG_NOTICE([adding -mieee to XTRA_CFLAGS])])
     else
-      OCTAVE_CC_FLAG(-ieee, [
+      OCTAVE_CC_FLAG([-ieee], [
         ieee_fp_flag=-ieee
         XTRA_CFLAGS="$XTRA_CFLAGS -ieee"
         AC_MSG_NOTICE([adding -ieee to XTRA_CFLAGS])])
     fi
     if test "$GXX" = yes; then
-      OCTAVE_CXX_FLAG(-mieee, [
+      OCTAVE_CXX_FLAG([-mieee], [
         ieee_fp_flag=-mieee
         XTRA_CXXFLAGS="$XTRA_CXXFLAGS -mieee"
         AC_MSG_NOTICE([adding -mieee to XTRA_CXXFLAGS])])
     else
-      OCTAVE_CXX_FLAG(-ieee, [
+      OCTAVE_CXX_FLAG([-ieee], [
         ieee_fp_flag=-ieee
         XTRA_CXXFLAGS="$XTRA_CXXFLAGS -ieee"
         AC_MSG_NOTICE([adding -ieee to XTRA_CXXFLAGS])])
     fi
   ;;
   *ibm-aix4*)
-    OCTAVE_CC_FLAG(-mminimal-toc, [
+    OCTAVE_CC_FLAG([-mminimal-toc], [
       XTRA_CFLAGS="$XTRA_CFLAGS -mminimal-toc"])
 
-    OCTAVE_CXX_FLAG(-mminimal-toc, [
+    OCTAVE_CXX_FLAG([-mminimal-toc], [
       XTRA_CXXFLAGS="$XTRA_CXXFLAGS -mminimal-toc"])
   ;;
 esac
 
 AC_SUBST(XTRA_CFLAGS)
 AC_SUBST(XTRA_CXXFLAGS)
 
 ### Test whether the compiler supports OpenMP.  This is experimental so disable
 ### it by default.  Enable it with the flag --enable-openmp.
 
 USE_OPENMP=false
-AC_ARG_ENABLE(openmp,
+AC_ARG_ENABLE([openmp],
   [AS_HELP_STRING([--enable-openmp],
     [(EXPERIMENTAL) use OpenMP SMP multi-threading])],
   [if test "$enableval" = yes; then USE_OPENMP=true; fi], [])
 if $USE_OPENMP; then
-  case "$canonical_host_type" in
+  case $canonical_host_type in
     *-*-mingw* | *-*-cygwin* | *-*-gnu*)
       OCTAVE_CHECK_OPENMP(-fopenmp)
     ;;
     *-*-msdosmsvc)
       ## FIXME: is this the right flag for MSVC?
       OCTAVE_CHECK_OPENMP(-openmp)
     ;;
     ## Add other compilers supporting OpenMP here
@@ -448,98 +445,86 @@ if test "$cross_compiling" = yes; then
   BUILD_LDFLAGS=""
   BUILD_EXEEXT=""
 else
   BUILD_CC='$(CC)'
   BUILD_CFLAGS='$(CFLAGS)'
   BUILD_CXX='$(CXX)'
   BUILD_CXXFLAGS='$(CXXFLAGS)'
   BUILD_LDFLAGS='$(LDFLAGS)'
-  ## 2012/07/31: Commented out special build requirements
-  ## for Sun compiler now that gendoc.cc is no longer part of build.
-  ##################################################################
-  #case "$canonical_host_type" in
-  #  sparc-sun-solaris2*)
-  #    if test "$GCC" != yes; then
-  #      ## The Sun C++ compiler never seems to complete compiling
-  #      ## gendoc.cc unless we reduce the optimization level...
-  #      ## BUILD_CXXFLAGS="-g -O1"
-  #    fi
-  #  ;;
-  #esac
   BUILD_EXEEXT='$(EXEEXT)'
 fi
 
-AC_ARG_VAR(BUILD_CC,
+AC_ARG_VAR([BUILD_CC],
   [build system C compiler (used if cross compiling)])
-AC_ARG_VAR(BUILD_CFLAGS,
+AC_ARG_VAR([BUILD_CFLAGS],
   [build system C compiler flags (used if cross compiling)])
-AC_ARG_VAR(BUILD_CXX,
+AC_ARG_VAR([BUILD_CXX],
   [build system C++ compiler (used if cross compiling)])
-AC_ARG_VAR(BUILD_CXXFLAGS,
+AC_ARG_VAR([BUILD_CXXFLAGS],
   [build system C++ compiler flags (used if cross compiling)])
-AC_ARG_VAR(BUILD_LDFLAGS,
+AC_ARG_VAR([BUILD_LDFLAGS],
   [build system C++ compiler link flags (used if cross compiling)])
-AC_ARG_VAR(BUILD_EXEEXT,
+AC_ARG_VAR([BUILD_EXEEXT],
   [build system executable extension (used if cross compiling)])
 
 dnl This is bogus.  We shouldn't have to explicitly add libc too!
 dnl Keep this check before the check for the Fortran compiler,
 dnl in case -lm is needed to compile Fortran programs.
 
 ### Look for math library.  If found, this will add -lm to LIBS.
 
-case "$canonical_host_type" in
+case $canonical_host_type in
   *-*-linux*)
     AC_CHECK_LIB(m, sin, , , -lc)
   ;;
   *)
     AC_CHECK_LIB(m, sin)
   ;;
 esac
 
 ### Determine the Fortran compiler and how to invoke it
 
 ## Default FFLAGS is -O.
-if test "x$FFLAGS" = x; then
+if test x"$FFLAGS" = x""; then
   FFLAGS="-O"
 fi
 
 ## the F77 variable, if set, overrides AC_PROG_F77 automatically
 AC_PROG_F77
 AC_F77_LIBRARY_LDFLAGS
 AC_F77_DUMMY_MAIN
 AC_F77_WRAPPERS
 
 F77_TOLOWER=true
 F77_APPEND_UNDERSCORE=true
 F77_APPEND_EXTRA_UNDERSCORE=true
 
-case "$ac_cv_f77_mangling" in
+case $ac_cv_f77_mangling in
   "upper case") F77_TOLOWER=false ;;
 esac
-case "$ac_cv_f77_mangling" in
+case $ac_cv_f77_mangling in
   "no underscore") F77_APPEND_UNDERSCORE=false ;;
 esac
-case "$ac_cv_f77_mangling" in
+case $ac_cv_f77_mangling in
   "no extra underscore") F77_APPEND_EXTRA_UNDERSCORE=false ;;
 esac
 
-case "$canonical_host_type" in
+case $canonical_host_type in
   i[[3456789]]86-*-*)
-    if test "$ac_cv_f77_compiler_gnu" = yes; then
-      OCTAVE_F77_FLAG(-mieee-fp)
+    if test $ac_cv_f77_compiler_gnu = yes; then
+      OCTAVE_F77_FLAG([-mieee-fp])
     fi
   ;;
   alpha*-*-*)
-    if test "$ac_cv_f77_compiler_gnu" = yes; then
-      OCTAVE_F77_FLAG(-mieee)
+    if test $ac_cv_f77_compiler_gnu = yes; then
+      OCTAVE_F77_FLAG([-mieee])
     else
-      OCTAVE_F77_FLAG(-ieee)
-      OCTAVE_F77_FLAG(-fpe1)
+      OCTAVE_F77_FLAG([-ieee])
+      OCTAVE_F77_FLAG([-fpe1])
     fi
   ;;
   powerpc-apple-machten*)
     FFLAGS=
   ;;
 esac
 
 if test -n "$FFLAGS"; then
@@ -551,32 +536,32 @@ AC_SUBST(F77_APPEND_UNDERSCORE)
 AC_SUBST(F77_APPEND_EXTRA_UNDERSCORE)
 
 if test -z "$F77"; then
   AC_MSG_ERROR([in order to build Octave, you must have a compatible Fortran compiler or wrapper script for f2c that functions as a Fortran compiler installed and in your path.  See the file INSTALL for more information.])
 fi
 
 OCTAVE_CHECK_FUNC_FORTRAN_ISNAN
 F77_ISNAN_MACRO=
-if test "x$octave_cv_func_fortran_isnan" = xno; then
+if test $octave_cv_func_fortran_isnan = no; then
   AC_MSG_NOTICE([substituting ISNAN(X) with X.NE.X in Fortran sources])
   F77_ISNAN_MACRO="s|ISNAN(\(@<:@^)@:>@*\))|(\1.NE.\1)|"
 fi
 AC_SUBST(F77_ISNAN_MACRO)
 
 OCTAVE_CHECK_SIZEOF_FORTRAN_INTEGER
-if test "x$octave_cv_sizeof_fortran_integer" = xno; then
+if test $octave_cv_sizeof_fortran_integer = no; then
   if $USE_64_BIT_IDX_T; then
-    case "$F77" in
+    case $F77 in
       *gfortran*)
-        case "$F77_INTEGER_8_FLAG" in
+        case $F77_INTEGER_8_FLAG in
           *-fdefault-integer-8*)
           ;;
           *)
-            case "$FFLAGS" in
+            case $FFLAGS in
               *-fdefault-integer-8*)
                 AC_MSG_NOTICE([setting -fdefault-integer-8 in F77_INTEGER_8_FLAG instead of FFLAGS])
                 FFLAGS=`echo $FFLAGS | sed 's/-fdefault-integer-8//g'`
                 F77_INTEGER_8_FLAG="-fdefault-integer-8"
               ;;
               *)
                 AC_MSG_NOTICE([adding -fdefault-integer-8 to F77_INTEGER_8_FLAG])
                 F77_INTEGER_8_FLAG="-fdefault-integer-8"
@@ -586,29 +571,30 @@ if test "x$octave_cv_sizeof_fortran_inte
             esac
           ;;
         esac
       ;;
     esac
     if test -z "$octave_cv_sizeof_fortran_integer"; then
       OCTAVE_CHECK_SIZEOF_FORTRAN_INTEGER
     fi
-    if test "x$octave_cv_sizeof_fortran_integer" = xno; then
+    if test $octave_cv_sizeof_fortran_integer = no; then
       AC_MSG_ERROR([in order to build Octave with 64-bit indexing support your Fortran compiler must have an option for setting the default integer size to 8 bytes.  See the file INSTALL for more information.])
     fi
   else
     AC_MSG_ERROR([your Fortran compiler must have an option to make integers the same size as octave_idx_type ($OCTAVE_IDX_TYPE).  See the file INSTALL for more information.])
   fi
 fi
 AC_SUBST(F77_INTEGER_8_FLAG)
 
+## FIXME: Is this really used?  Makefile seems to use $F77 for compiler
 FC=$F77
 AC_SUBST(FC)
 
-OCTAVE_F77_FLAG(-ffloat-store, [
+OCTAVE_F77_FLAG([-ffloat-store], [
   AC_MSG_RESULT([setting F77_FLOAT_STORE_FLAG to -ffloat-store])
   F77_FLOAT_STORE_FLAG=-ffloat-store
   AC_SUBST(F77_FLOAT_STORE_FLAG)
 ])
 
 ### Check for the Qhull library
 
 OCTAVE_CHECK_LIB(qhull, QHull,
@@ -631,156 +617,147 @@ pcre_fail_msg="to build Octave, you must
 AC_CHECK_HEADERS([pcre.h pcre/pcre.h])
 
 AC_CACHE_CHECK([whether pcre.h defines the macros we need],
   [ac_cv_pcre_h_macros_present],
   [AC_EGREP_CPP([PCRE_HAS_MACROS_WE_NEED], [
     #if defined (HAVE_PCRE_H)
     # include <pcre.h>
     #elif defined (HAVE_PCRE_PCRE_H)
-    # include <pcre.h>
+    # include <pcre/pcre.h>
     #error "NO PCRE HEADER"
     #endif
     #if defined (PCRE_INFO_NAMECOUNT) \
       && defined (PCRE_INFO_NAMEENTRYSIZE) \
       && defined (PCRE_INFO_NAMETABLE)
       PCRE_HAS_MACROS_WE_NEED
     #endif],
     ac_cv_pcre_h_macros_present=yes, ac_cv_pcre_h_macros_present=no)])
 
 if test $ac_cv_pcre_h_macros_present = yes; then
   ## check for pcre-config, and if so, set XTRA_CXXFLAGS appropriately
   AC_CHECK_PROG(HAVE_PCRE_CONFIG, pcre-config, [yes], [no])
   if test $HAVE_PCRE_CONFIG = yes; then
     XTRA_CXXFLAGS="$XTRA_CXXFLAGS `pcre-config --cflags`"
-    REGEX_LIBS="`pcre-config --libs`"
+    REGEX_LIBS=`pcre-config --libs`
   else
     REGEX_LIBS="-lpcre"
   fi
   save_LIBS="$LIBS"
   LIBS="$REGEX_LIBS $LIBS"
-  AC_CHECK_FUNCS(pcre_compile,
+  AC_CHECK_FUNCS([pcre_compile],
     [AC_SUBST(REGEX_LIBS)],
     [AC_MSG_ERROR([$pcre_fail_msg])])
   LIBS="$save_LIBS"
 else
   AC_MSG_ERROR([$pcre_fail_msg])
 fi
 
 ### Check for ZLIB library.
 
 OCTAVE_CHECK_LIB(z, ZLIB,
   [ZLIB library not found.  Octave will not be able to save or load compressed data files or HDF5 files.],
   [zlib.h], [gzclearerr])
 
 ### Check for the LLVM library
-dnl
-dnl LLVM is odd and has its own pkg-config like script.  We should probably
-dnl check for existence and ???.
-dnl
-save_CPPFLAGS="$CPPFLAGS"
-save_CXXFLAGS="$CXXFLAGS"
-save_LIBS="$LIBS"
-save_LDFLAGS="$LDFLAGS"
 
-warn_llvm="LLVM library fails tests.  JIT compilation will be disabled."
-
-AC_ARG_VAR(LLVM_CONFIG, [path to llvm-config utility])
-
-AC_ARG_ENABLE([jit-debug],
-  AS_HELP_STRING([--enable-jit-debug], [enable debug printing of JIT IRs]))
-
-AS_IF([test "x$enable_jit_debug" = "xyes"], [
-  AC_DEFINE(OCTAVE_JIT_DEBUG, 1, [Define to 1 for JIT debug printing.])
-])
+build_jit=false
+AC_ARG_ENABLE([jit],
+  [AS_HELP_STRING([--enable-jit],
+    [(EXPERIMENTAL) enable JIT compiler])],
+  [if test "$enableval" = yes; then
+     build_jit=true
+   fi],
+  [])
 
 LLVM_CXXFLAGS=
 LLVM_CPPFLAGS=
 LLVM_LDFLAGS=
 LLVM_LIBS=
 
-if test "x$ac_cv_env_LLVM_CONFIG_set" = "xset"; then
-  ## We use -isystem if available because we do not want to see warnings in LLVM
-  LLVM_INCLUDE_FLAG=-I
-  OCTAVE_CC_FLAG(-isystem ., [
-    LLVM_INCLUDE_FLAG=-isystem
-    AC_MSG_NOTICE([using -isystem for llvm headers])])
+if test $build_jit = true; then
+
+  ## Find llvm-config program from environment variable or by searching
+  AC_ARG_VAR([LLVM_CONFIG], [path to llvm-config utility])
+  AC_CHECK_PROG([LLVM_CONFIG], llvm-config, llvm-config, [])
+
+  if test -z "$LLVM_CONFIG"; then
+    warn_llvm="llvm-config utility not found.  JIT compiler is disabled."
+  else
+    dnl Preset warning message in case compile fails
+    warn_llvm="LLVM was not found or is to old.  JIT compiler is disabled."
 
-  LLVM_LDFLAGS="-L`$LLVM_CONFIG --libdir`"
-  LLVM_LIBS=`$LLVM_CONFIG --libs`
-  dnl Use -isystem so we don't get warnings from llvm headers
-  LLVM_CPPFLAGS="$LLVM_INCLUDE_FLAG `$LLVM_CONFIG --includedir`"
-  LLVM_CXXFLAGS=
+    save_CPPFLAGS="$CPPFLAGS"
+    save_CXXFLAGS="$CXXFLAGS"
+
+    ## Use -isystem if available because we don't want to see warnings in LLVM
+    LLVM_INCLUDE_FLAG=-I
+    OCTAVE_CC_FLAG([-isystem .], [
+      LLVM_INCLUDE_FLAG=-isystem
+      AC_MSG_NOTICE([using -isystem for LLVM headers])])
+
+    dnl Use -isystem so we don't get warnings from llvm headers
+    LLVM_CPPFLAGS="$LLVM_INCLUDE_FLAG `$LLVM_CONFIG --includedir`"
+    LLVM_CXXFLAGS=
+    LLVM_LDFLAGS="-L`$LLVM_CONFIG --libdir`"
+    LLVM_LIBS=`$LLVM_CONFIG --libs`
 
-  dnl
-  dnl We define some extra flags that LLVM requires in order to include headers.
-  dnl Ideally we should get these from llvm-config, but llvm-config isn't very
-  dnl helpful.
-  dnl
-  CPPFLAGS="-D__STDC_CONSTANT_MACROS -D__STDC_LIMIT_MACROS $LLVM_CPPFLAGS $CPPFLAGS"
-  CXXFLAGS="$LLVM_CXXFLAGS $CXXFLAGS"
-  LIBS="$LLVM_LIBS $LIBS"
-  LDFLAGS="$LLVM_LDFLAGS $LDFLAGS"
+    dnl
+    dnl Define some extra flags that LLVM requires in order to include headers.
+    dnl Ideally we should get these from llvm-config, but llvm-config isn't
+    dnl very helpful.
+    dnl
+    CPPFLAGS="-D__STDC_CONSTANT_MACROS -D__STDC_LIMIT_MACROS $LLVM_CPPFLAGS $CPPFLAGS"
+    CXXFLAGS="$LLVM_CXXFLAGS $CXXFLAGS"
+    AC_LANG_PUSH(C++)
+    AC_CHECK_HEADER([llvm/Support/TargetSelect.h], [
+      warn_llvm=
+      XTRA_CXXFLAGS="$XTRA_CXXFLAGS $LLVM_CXXFLAGS $LLVM_CPPFLAGS"])
+    AC_LANG_POP(C++)
+    CPPFLAGS="$save_CPPFLAGS"
+    CXXFLAGS="$save_CXXFLAGS"
+  fi
 
-  AC_LANG_PUSH(C++)
-    AC_CHECK_HEADER([llvm/LLVMContext.h], [
-      AC_MSG_CHECKING([for llvm::getGlobalContext in llvm/LLVMContext.h])
-        AC_COMPILE_IFELSE(
-          [AC_LANG_PROGRAM([[
-            #include <llvm/LLVMContext.h>
-            ]], [[
-            llvm::LLVMContext& ctx = llvm::getGlobalContext ();
-            ]])],
-          [AC_MSG_RESULT([yes])
-           warn_llvm=
-           XTRA_CXXFLAGS="$XTRA_CXXFLAGS $LLVM_CXXFLAGS $LLVM_CPPFLAGS"],
-          [AC_MSG_RESULT([no])
-      ])
-    ])
-  AC_LANG_POP(C++)
-  
-else
-  warn_llvm="LLVM_CONFIG not set.  JIT compilation will be disabled."
+  if test -z "$warn_llvm"; then
+    AC_DEFINE(HAVE_LLVM, 1, [Define to 1 if LLVM is available.])
+  else
+    build_jit=false
+    LLVM_CPPFLAGS=
+    LLVM_CXXFLAGS=
+    LLVM_LDFLAGS=
+    LLVM_LIBS=
+    OCTAVE_CONFIGURE_WARNING([warn_llvm])
+  fi
+dnl FIXME: Re-instate when JIT is enabled by default
+dnl else
+dnl   ## JIT build disabled
+dnl   warn_llvm="JIT compiler disabled, some performance loss for loops"
+dnl   OCTAVE_CONFIGURE_WARNING([warn_llvm])
 fi
 
-if test -z "$warn_llvm"; then
-  AC_DEFINE(HAVE_LLVM, 1, [Define to 1 if LLVM is available.])
-else
-  LLVM_CXXFLAGS=
-  LLVM_CPPFLAGS=
-  LLVM_LDFLAGS=
-  LLVM_LIBS=
-  OCTAVE_CONFIGURE_WARNING([warn_llvm])
-fi
-
+AC_SUBST(LLVM_CPPFLAGS)
 AC_SUBST(LLVM_CXXFLAGS)
-AC_SUBST(LLVM_CPPFLAGS)
 AC_SUBST(LLVM_LDFLAGS)
 AC_SUBST(LLVM_LIBS)
 
-CPPFLAGS="$save_CPPFLAGS"
-CXXFLAGS="$save_CXXFLAGS"
-LIBS="$save_LIBS"
-LDFLAGS="$save_LDFLAGS"
-
 ### Check for HDF5 library.
 
 save_CPPFLAGS="$CPPFLAGS"
+save_LIBS="$LIBS"
 CPPFLAGS="$Z_CPPFLAGS $CPPFLAGS"
-save_LIBS="$LIBS"
 LIBS="$Z_LDFLAGS $Z_LIBS $LIBS"
 OCTAVE_CHECK_LIB(hdf5, HDF5,
   [HDF5 library not found.  Octave will not be able to save or load HDF5 data files.],
   [hdf5.h], [H5Gget_num_objs], [], [],
   [warn_hdf5=
    OCTAVE_CHECK_HDF5_HAS_VER_16_API
    TEXINFO_HDF5="@set HAVE_HDF5"
    AC_DEFINE(HAVE_HDF5, 1,
      [Define to 1 if HDF5 is available and newer than version 1.6.])
-   if test "$have_msvc" = "yes"; then
+   if test $have_msvc = yes; then
      OCTAVE_CHECK_LIB_HDF5_DLL
    fi
   ])
 CPPFLAGS="$save_CPPFLAGS"
 LIBS="$save_LIBS"
 
 ### Check for FFTW library.  Default to Fortran FFTPACK if it is not available.
 
@@ -791,41 +768,58 @@ OCTAVE_CHECK_LIB(fftw3, FFTW3,
 
 OCTAVE_CHECK_LIB(fftw3f, FFTW3F,
   [FFTW3F library not found.  The slower FFTPACK library will be used instead.],
   [fftw3.h], [fftwf_plan_dft_1d])
 
 AM_CONDITIONAL([AMCOND_HAVE_FFTW],
   [test -n "$FFTW3_LIBS" && test -n "$FFTW3F_LIBS"])
 
-## Subdirectory of libcruft to build if FFTW is not found.
+## Subdirectory of liboctave/cruft to build if FFTW is not found.
 FFT_DIR="fftpack"
 AC_SUBST(FFT_DIR)
 
 ### Check for GLPK library and header.
 
 save_CPPFLAGS="$CPPFLAGS"
+save_LIBS="$LIBS"
 CPPFLAGS="$Z_CPPFLAGS $CPPFLAGS"
-save_LIBS="$LIBS"
 LIBS="$Z_LDFLAGS $Z_LIBS $LIBS"
 OCTAVE_CHECK_LIB(glpk, GLPK,
   [GLPK library not found.  The glpk function for solving linear programs will be disabled.],
   [glpk/glpk.h glpk.h], [_glp_lpx_simplex])
 LIBS="$save_LIBS"
 CPPFLAGS="$save_CPPFLAGS"
 
 ### Checks for cURL header and library.
 
 save_CPPFLAGS="$CPPFLAGS"
+save_LIBS="$LIBS"
 CPPFLAGS="$Z_CPPFLAGS $CPPFLAGS"
-save_LIBS="$LIBS"
 LIBS="$Z_LDFLAGS $Z_LIBS $LIBS"
 OCTAVE_CHECK_LIB(curl, cURL,
   [cURL library not found.  The ftp objects, urlread and urlwrite functions will be disabled.],
   [curl/curl.h], [curl_easy_escape])
+if test -z "$warn_curl"; then
+  ## Additional check on cURL library that was found
+  AC_CACHE_CHECK([for CURLOPT_DIRLISTONLY in curl/curl.h],
+    [octave_cv_header_define_curlopt_dirlistonly],
+    [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+      #include <curl/curl.h>
+      ]], [[
+      curl_easy_setopt ((CURL*)NULL, CURLOPT_DIRLISTONLY, 0);
+      ]])],
+      [octave_cv_header_define_curlopt_dirlistonly=no],
+      [octave_cv_header_define_curlopt_dirlistonly=yes])
+    ])
+  if test $octave_cv_header_define_curlopt_dirlistonly = yes; then
+    AC_DEFINE(CURLOPT_DIRLISTONLY, CURLOPT_FTPLISTONLY,
+      [Define to the legacy option name if using an older version of cURL.])]
+  fi
+fi
 LIBS="$save_LIBS"
 CPPFLAGS="$save_CPPFLAGS"
 
 ### Check for either of Graphics/ImageMagick++ libraries
 
 AC_ARG_WITH([magick],
   [AS_HELP_STRING([--with-magick=LIB],
     [select library to use for image I/O (options: GraphicsMagick(default) or ImageMagick)])],
@@ -849,32 +843,37 @@ PKG_CHECK_EXISTS([$magick++], [
 
   warn_magick="$magick++ library fails tests.  The imread function for reading image files will not be fully functional."
 
   save_CPPFLAGS="$CPPFLAGS"
   save_LIBS="$LIBS"
   CPPFLAGS="$MAGICK_CPPFLAGS $CPPFLAGS"
   LIBS="$MAGICK_LDFLAGS $MAGICK_LIBS $LIBS"
   AC_LANG_PUSH(C++)
-    AC_CHECK_HEADER([Magick++.h], [
-      AC_MSG_CHECKING([for Magick::ColorRGB in Magick++.h])
-      AC_PREPROC_IFELSE(
-        [AC_LANG_SOURCE([[
-          #include <Magick++.h>
-          ]], [[
-          Magick::ColorRGB c;
-          ]])],
-        [AC_MSG_RESULT(yes)
-         warn_magick=],
-        [AC_MSG_RESULT(no)]
-      )
-    ])
+  AC_CHECK_HEADER([Magick++.h], [
+    AC_CACHE_CHECK([for Magick::ColorRGB in Magick++.h],
+      [octave_cv_func_magick_colorrgb],
+      [AC_PREPROC_IFELSE([AC_LANG_SOURCE([[
+        #include <Magick++.h>
+        ]], [[
+        Magick::ColorRGB c;
+        ]])],
+        octave_cv_func_magick_colorrgb=yes,
+        octave_cv_func_magick_colorrgb=no)
+      ])
+    if test $octave_cv_func_magick_colorrgb = yes; then
+      warn_magick=
+    fi
+  ])
   AC_LANG_POP(C++)
   CPPFLAGS="$save_CPPFLAGS"
   LIBS="$save_LIBS"
+
+  AC_CHECK_FUNCS([setlocale], [],
+                 [warn_magick="$magick++ requires setlocale function.  The imread function for reading image files will not be fully functional."])
 ])
 
 if test -z "$warn_magick"; then
   AC_DEFINE(HAVE_MAGICK, 1,
     [Define to 1 if Graphics/ImageMagick++ is available.])
 else
   MAGICK_CPPFLAGS=
   MAGICK_LDFLAGS=
@@ -882,76 +881,76 @@ else
 fi
 AC_SUBST(MAGICK_CPPFLAGS)
 AC_SUBST(MAGICK_LDFLAGS)
 AC_SUBST(MAGICK_LIBS)
 
 ### Check for X11 libraries
 
 AC_PATH_X
-if test "$have_x" = "yes"; then
+if test "$have_x" = yes; then
   AC_DEFINE(HAVE_X_WINDOWS, 1, [Define to 1 if you have X11.])
 
   if test "$x_includes" != "NONE"; then
     X11_INCFLAGS="$x_includes"
   fi
   AC_SUBST(X11_INCFLAGS)
 
-  if test -z $x_libraries; then
-    AC_CHECK_LIB(X11, XrmInitialize, [X11_LIBS=-lX11], [X11_LIBS=])
+  if test -z "$x_libraries"; then
+    AC_CHECK_LIB([X11], XrmInitialize, [X11_LIBS="-lX11"], [X11_LIBS=])
   elif test $x_libraries != "NONE"; then
-    AC_CHECK_LIB(X11, XrmInitialize, 
+    AC_CHECK_LIB([X11], XrmInitialize, 
       [X11_LIBS="-L$x_libraries -lX11"], [X11_LIBS=], "-L$x_libraries")
   fi
   AC_SUBST(X11_LIBS)
 fi
 
 ### Check for the Carbon framework on MacOSX systems
-OCTAVE_HAVE_FRAMEWORK(Carbon,
+OCTAVE_HAVE_FRAMEWORK([Carbon],
   [[#include <Carbon/Carbon.h>]], [[CGMainDisplayID ()]],
-  [have_framework_carbon="yes"], [have_framework_carbon="no"])
-if test $have_framework_carbon = "yes"; then
+  [have_framework_carbon=yes], [have_framework_carbon=no])
+if test $have_framework_carbon = yes; then
   AC_DEFINE(HAVE_FRAMEWORK_CARBON, 1,
     [Define to 1 if framework CARBON is available.])
   CARBON_LIBS="-Wl,-framework -Wl,Carbon"
   AC_MSG_NOTICE([adding -Wl,-framework -Wl,Carbon to CARBON_LIBS])
   AC_SUBST(CARBON_LIBS)
 fi
 
 ### Check for list of libraries needed for native graphics renderer.
 
+native_graphics=true
 warn_freetype=""
-native_graphics=true
 
 check_opengl=false
 AC_ARG_WITH([opengl],
   [AS_HELP_STRING([--without-opengl],
     [don't use OpenGL libraries, disable native graphics])],
-  [if test "x$withval" = xno; then
+  [if test x"$withval" = x"no"; then
+     native_graphics=false
      warn_opengl="--without-opengl specified.  Native graphics will be disabled."
      OCTAVE_CONFIGURE_WARNING([warn_opengl])
-     native_graphics=false
    else
      check_opengl=true
    fi],
   [check_opengl=true])
 
 ## Check for OpenGL library
 if $check_opengl; then
   OCTAVE_CHECK_LIB_OPENGL
 fi
 
 GRAPHICS_LIBS=
 GRAPHICS_CFLAGS=
 
 if test -z "$OPENGL_LIBS"; then
   if $check_opengl; then
+    native_graphics=false
     warn_fltk_opengl="OpenGL libs (GL and GLU) not found.  Native graphics will be disabled."
     OCTAVE_CONFIGURE_WARNING([warn_fltk_opengl])
-    native_graphics=false
   fi
 fi
 
 if test -n "$OPENGL_LIBS"; then
   AC_DEFINE(HAVE_OPENGL, 1, [Define to 1 if OpenGL is available.])
 
   ## Check for FreeType 2 library
 
@@ -974,95 +973,103 @@ if test -n "$OPENGL_LIBS"; then
        OPENGL_LIBS="$FONTCONFIG_LIBS $OPENGL_LIBS"
        XTRA_CXXFLAGS="$XTRA_CXXFLAGS $FONTCONFIG_CFLAGS"
        AC_DEFINE(HAVE_FONTCONFIG, 1, [Define to 1 if fontconfig is present.])],
       [have_fontconfig=no
        warn_fontconfig="Fontconfig library not found.  Native graphics will be disabled."])
   fi
 
   if test -n "$warn_fontconfig"; then
+    native_graphics=false
     OCTAVE_CONFIGURE_WARNING([warn_fontconfig])
-    native_graphics=false
   fi
 
   ## Check for FLTK (www.fltk.org) library
 
   AC_ARG_WITH([fltk-prefix], [
     AS_HELP_STRING([--with-fltk-prefix=PFX],
       [prefix where FLTK is installed (optional)])],
     [fltk_prefix="$withval"],
     [fltk_prefix=""])
 
   AC_ARG_WITH([fltk-exec-prefix], [
     AS_HELP_STRING([--with-fltk-exec-prefix=PFX],
       [exec prefix where FLTK is installed (optional)])],
     [fltk_exec_prefix="$withval"],
     [fltk_exec_prefix=""])
 
-  if test -n "$fltk_exec_prefix"; then
+  if test x"$fltk_exec_prefix" != x""; then
     fltk_args="$fltk_args --exec-prefix=$fltk_exec_prefix"
     if test "x${FLTK_CONFIG+set}" != xset ; then
       FLTK_CONFIG="$fltk_exec_prefix/bin/fltk-config"
     fi
   fi
 
-  if test -n "$fltk_prefix"; then
+  if test x"$fltk_prefix" != x""; then
     fltk_args="$fltk_args --prefix=$fltk_prefix"
     if test x${FLTK_CONFIG+set} != xset ; then
       FLTK_CONFIG="$fltk_prefix/bin/fltk-config"
     fi
   fi
 
   AC_PATH_PROG([FLTK_CONFIG], [fltk-config], [no])
 
   warn_fltk_config=""
   warn_fltk_opengl=""
 
-  if test "$FLTK_CONFIG" = "no" ; then
+  if test "$FLTK_CONFIG" = no; then
+    native_graphics=false
     warn_fltk_config="FLTK config script not found.  Native graphics will be disabled."
     OCTAVE_CONFIGURE_WARNING([warn_fltk_config])
-    native_graphics=false
   else
-    FLTK_CFLAGS="`$FLTK_CONFIG $fltkconf_args --use-gl --cflags`"
-    FLTK_LDFLAGS="`$FLTK_CONFIG $fltkconf_args --use-gl --ldflags`"
+    FLTK_CFLAGS=`$FLTK_CONFIG $fltkconf_args --use-gl --cflags`
+    FLTK_LDFLAGS=`$FLTK_CONFIG $fltkconf_args --use-gl --ldflags`
 
-    case "$canonical_host_type" in
+    case $canonical_host_type in
       *-*-mingw*)
-        FLTK_LDFLAGS="`echo $FLTK_LDFLAGS | sed -e 's/-mwindows//g'`"
+        FLTK_LDFLAGS=`echo $FLTK_LDFLAGS | sed -e 's/-mwindows//g'`
       ;;
     esac
 
-    AC_MSG_CHECKING([for OpenGL support in FLTK])
-    save_CFLAGS="$CFLAGS"
-    CFLAGS="$CFLAGS $FLTK_CFLAGS"
-    AC_COMPILE_IFELSE(
-      [AC_LANG_PROGRAM([[#include <FL/gl.h>]], [[int nothing = 0;]])],
-      [AC_MSG_RESULT([no])
-       warn_fltk_opengl="FLTK does not have OpenGL support.  Native graphics will be disabled."],
-      [AC_MSG_RESULT([yes])
-       AC_DEFINE(HAVE_FLTK, 1, [Define to 1 if FLTK is available.])])
-         
+    AC_CACHE_CHECK([for OpenGL support in FLTK],
+      [octave_cv_fltk_opengl_support],
+      [save_CFLAGS="$CFLAGS"
+      CFLAGS="$CFLAGS $FLTK_CFLAGS"
+      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+        #include <FL/gl.h>
+        ]], [[
+        int nothing = 0;
+        ]])],
+        octave_cv_fltk_opengl_support=no,
+        octave_cv_fltk_opengl_support=yes)
+      CFLAGS="$save_CFLAGS"
+      ])
+    if test $octave_cv_fltk_opengl_support = no; then
+      warn_fltk_opengl="FLTK does not have OpenGL support.  Native graphics will be disabled."
+    else
+      AC_DEFINE(HAVE_FLTK, 1, [Define to 1 if FLTK is available.])
+    fi 
+
     if test -z "$warn_fltk_opengl"; then
       GRAPHICS_CFLAGS="$FLTK_CFLAGS"
       GRAPHICS_LIBS="$FLTK_LDFLAGS"
     else
+      native_graphics=false
       OCTAVE_CONFIGURE_WARNING([warn_fltk_opengl])
-      native_graphics=false
     fi
-    CFLAGS="$save_CFLAGS"
   fi
 fi
 
 AC_SUBST(GRAPHICS_CFLAGS)
 AC_SUBST(GRAPHICS_LIBS)
 
 ### Start determination of shared vs. static libraries
 
 ## Use -static if compiling on Alpha OSF/1 1.3 systems.
-case "$canonical_host_type" in
+case $canonical_host_type in
   alpha*-dec-osf1.3)
     LD_STATIC_FLAG=-static
   ;;
 esac
 if test -n "$LD_STATIC_FLAG"; then
   AC_MSG_NOTICE([defining LD_STATIC_FLAG to be $LD_STATIC_FLAG])
 fi
 AC_SUBST(LD_STATIC_FLAG)
@@ -1072,30 +1079,30 @@ OCTAVE_PROG_AR
 ifdef([LT_INIT], [], [
   errprint([error: you must have libtool 2.2.2 or a more recent version
 ])
   m4exit([1])])
 
 LT_PREREQ([2.2.2])
 LT_INIT([disable-static dlopen win32-dll])
 
-if test x$enable_shared = xyes; then
+if test x"$enable_shared" = x"yes"; then
   SHARED_LIBS=true
 else
   SHARED_LIBS=false
 fi
 
-if test x$enable_static = xyes; then
+if test x"$enable_static" = x"yes"; then
   STATIC_LIBS=true
 else
   STATIC_LIBS=false
 fi
 
 XTRA_CRUFT_SH_LDFLAGS=
-if test "$have_msvc" = "yes"; then
+if test $have_msvc = yes; then
   FLIBS="$FLIBS -lkernel32"
   XTRA_CRUFT_SH_LDFLAGS="-Wl,-def:cruft.def"
 fi
 AC_SUBST(XTRA_CRUFT_SH_LDFLAGS)
 
 ### Check for BLAS and LAPACK libraries:
 
 ## Need to adjust FFLAGS to include correct integer size.
@@ -1103,111 +1110,112 @@ save_FFLAGS="$FFLAGS"
 FFLAGS="$FFLAGS $F77_INTEGER_8_FLAG"
 
 AX_BLAS_WITH_F77_FUNC([:], [:])
 AX_LAPACK([:], [:])
 
 ## Restore FFLAGS.
 FFLAGS="$save_FFLAGS"
 
-## Try again with -ff2c in FFLAGS
-if test "x$ax_blas_f77_func_ok" = "xno"; then
+## If necessary, try again with -ff2c in FFLAGS
+if test $ax_blas_f77_func_ok = no; then
   save_FFLAGS="$FFLAGS"
   FFLAGS="-ff2c $FFLAGS $F77_INTEGER_8_FLAG"
 
   AX_BLAS_WITH_F77_FUNC([:], [:])
   AX_LAPACK([:], [:])
 
   ## Restore FFLAGS, with -ff2c if that was helpful
 
-  if test "x$ax_blas_f77_func_ok" = "xno"; then
+  if test $ax_blas_f77_func_ok = no; then
     FFLAGS="$save_FFLAGS"
   else
     FFLAGS="-ff2c $save_FFLAGS"
   fi
 fi
 
 ## On OSX, try again with a wrapper library (without -ff2c!)
-if test "x$ax_blas_f77_func_ok" = "xno"; then
-  case "$canonical_host_type" in
+if test $ax_blas_f77_func_ok = no; then
+  case $canonical_host_type in
     *-*-darwin*)
       ## test if wrapper functions help
       octave_blaswrap_save_CFLAGS="$CFLAGS"
       CFLAGS="$CFLAGS -DUSE_BLASWRAP"
       AC_LANG_PUSH(C)
       AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
-          #include "libcruft/misc/blaswrap.c"
+          #include "liboctave/cruft/misc/blaswrap.c"
         ]])],
         [mv conftest.$ac_objext blaswrap.$ac_objext
          octave_blaswrap_save_BLAS_LIBS="$BLAS_LIBS"
          BLAS_LIBS="blaswrap.$ac_objext -framework vecLib"
 
          save_FFLAGS="$FFLAGS"
          FFLAGS="$FFLAGS $F77_INTEGER_8_FLAG"
 
          AX_BLAS_WITH_F77_FUNC([:], [:])
          AX_LAPACK([:], [:])
 
          ## Restore FFLAGS.
          FFLAGS="$save_FFLAGS"
 
          ## remove temp file
          rm -f blaswrap.$ac_objext],
-        [AC_MSG_FAILURE([cannot compile libcruft/misc/blaswrap.c])])
+        [AC_MSG_FAILURE([cannot compile liboctave/cruft/misc/blaswrap.c])])
       AC_LANG_POP(C)
       CFLAGS="$octave_blaswrap_save_CFLAGS"
 
-      if test "x$ax_blas_f77_func_ok" = "xno"; then
+      if test $ax_blas_f77_func_ok = no; then
         BLAS_LIBS="$octave_blaswrap_save_BLAS_LIBS"
       else
-        ## wrapper in libcruft, remove from BLAS_LIBS
-        BLAS_LIBS="`echo $BLAS_LIBS | sed -e 's/blaswrap.[[^ ]]* //g'`"
+        ## wrapper in cruft, remove from BLAS_LIBS
+        BLAS_LIBS=`echo $BLAS_LIBS | sed -e 's/blaswrap.[[^ ]]* //g'`
         AC_DEFINE(USE_BLASWRAP, 1,
           [Define to 1 if BLAS functions need to be wrapped (potentially needed for 64-bit OSX only).])
       fi
     ;;
   esac
 fi
 
-if test "x$ax_blas_f77_func_ok" = "xno"; then
-  if $USE_64_BIT_IDX_T && test "$ax_blas_integer_size_ok" = "no" ; then
+if test $ax_blas_f77_func_ok = no; then
+  if $USE_64_BIT_IDX_T && test $ax_blas_integer_size_ok = no; then
     ## Attempt to be more informative.
     AC_MSG_ERROR([BLAS doesn't seem to support 64-bit integers.  This is incompatible with --enable-64.])
   else
     AC_MSG_ERROR([A BLAS library was detected but found incompatible with your Fortran 77 compiler settings.])
   fi
 fi
 
-if test x$ax_blas_ok = xno || test x$ax_lapack_ok = xno; then
+if test $ax_blas_ok = no || test $ax_lapack_ok = no; then
   AC_MSG_ERROR([BLAS and LAPACK libraries are required])
 fi
 
 ### Check for the qrupdate library
 
 ## No need to adjust FFLAGS because only link is attempted. 
 ## Must supply proper LIBS, however.
 save_LIBS="$LIBS"
 LIBS="$LAPACK_LIBS $BLAS_LIBS $FLIBS $LIBS"
 OCTAVE_CHECK_LIB(qrupdate, qrupdate,
   [qrupdate not found.  The QR & Cholesky updating functions will be slow.],
   [],
   [sqr1up],
   [Fortran 77], [don't use qrupdate, disable QR & Cholesky updating functions])
 
-if test "$octave_qrupdate_ok" = yes; then
-  LIBS="$LIBS $QRUPDATE_LIBS"
-  AC_LANG_PUSH([Fortran 77])
-  AC_MSG_CHECKING([for slup1up in $QRUPDATE_LIBS])
-  octave_qrupdate_luu=no
-  AC_LINK_IFELSE([AC_LANG_CALL([], [slup1up])], [octave_qrupdate_luu=yes])
-  AC_MSG_RESULT([$octave_qrupdate_luu])
-  if test "$octave_qrupdate_luu" = yes; then
+if test $octave_cv_lib_qrupdate = yes; then
+  AC_CACHE_CHECK([for slup1up in $QRUPDATE_LIBS],
+    [octave_cv_func_slup1up],
+    [LIBS="$LIBS $QRUPDATE_LIBS"
+    AC_LANG_PUSH([Fortran 77])
+    AC_LINK_IFELSE([AC_LANG_CALL([], [slup1up])],
+      octave_cv_func_slup1up=yes, octave_cv_func_slup1up=no)
+    AC_LANG_POP([Fortran 77])
+  ])
+  if test $octave_cv_func_slup1up = yes; then
     AC_DEFINE(HAVE_QRUPDATE_LUU, 1, [Define to 1 if qrupdate supports LU updates.])
   fi
-  AC_LANG_POP([Fortran 77])
 fi
 LIBS="$save_LIBS"
 
 ### Check for AMD library
 
 OCTAVE_CHECK_LIB(amd, AMD,
   [AMD library not found.  This will result in some lack of functionality for sparse matrices.],
   [suitesparse/amd.h ufsparse/amd.h amd/amd.h amd.h],
@@ -1233,18 +1241,19 @@ OCTAVE_CHECK_LIB(colamd, COLAMD,
 ### Check for CCOLAMD library
 
 OCTAVE_CHECK_LIB(ccolamd, CCOLAMD,
   [CCOLAMD library not found.  This will result in some lack of functionality for sparse matrices.],
   [suitesparse/ccolamd.h ufsparse/ccolamd.h amd/ccolamd.h ccolamd.h],
   [ccolamd],
   [], [don't use CCOLAMD library, disable some sparse matrix functionality])
 
-### Check for CHOLMOD library.  If your cholmod library requires cblas,
-### then you will need to configure with --with-cholmod="-lcholmod -lcblas".
+### Check for CHOLMOD library.
+### If your cholmod library requires cblas, then you will need to
+### configure with --with-cholmod="-lcholmod -lcblas".
 
 save_LIBS="$LIBS"
 LIBS="$COLAMD_LDFLAGS $COLAMD_LIBS $AMD_LDFLAGS $AMD_LIBS $LAPACK_LIBS $BLAS_LIBS $FLIBS $LIBS"
 OCTAVE_CHECK_LIB(cholmod, CHOLMOD,
   [CHOLMOD library not found.  This will result in some lack of functionality for sparse matrices.],
   [suitesparse/cholmod.h ufsparse/cholmod.h cholmod/cholmod.h cholmod.h],
   [cholmod_start],
   [], [don't use CHOLMOD library, disable some sparse matrix functionality])
@@ -1259,52 +1268,83 @@ OCTAVE_CHECK_LIB(cxsparse, CXSparse,
   [C++], [don't use CXSparse library, disable some sparse matrix functionality])
 
 ### Check for UMFPACK library.
 
 save_LIBS="$LIBS"
 save_CPPFLAGS="$CPPFLAGS"
 LIBS="$AMD_LDFLAGS $AMD_LIBS $BLAS_LIBS $FLIBS $LIBS"
 CPPFLAGS="$AMD_CPPFLAGS $CPPFLAGS"
-OCTAVE_CHECK_LIB(umfpack, UMFPACK,
+OCTAVE_CHECK_LIB([umfpack], UMFPACK,
   [UMFPACK not found.  This will result in some lack of functionality for sparse matrices.],
   [suitesparse/umfpack.h ufsparse/umfpack.h umfpack/umfpack.h umfpack.h],
   [umfpack_zi_get_determinant],
   [], [don't use UMFPACK, disable some sparse matrix functionality])
 CPPFLAGS="$save_CPPFLAGS"
 LIBS="$save_LIBS"
 
 if test -z "$UMFPACK_LIBS"; then
   ## Invalidate the cache and try again with -lcblas.
   $as_unset ac_cv_lib_umfpack_umfpack_zi_get_determinant
+  $as_unset octave_cv_lib_umfpack
   save_LIBS="$LIBS"
   LIBS="-lcblas $AMD_LDFLAGS $AMD_LIBS $BLAS_LIBS $FLIBS $LIBS"
-  OCTAVE_CHECK_LIB(umfpack, UMFPACK,
+  OCTAVE_CHECK_LIB([umfpack], UMFPACK,
     [UMFPACK not found.  This will result in some lack of functionality for sparse matrices.],
     [suitesparse/umfpack.h ufsparse/umfpack.h umfpack/umfpack.h umfpack.h],
     [umfpack_zi_get_determinant],
     [], [don't use UMFPACK, disable some sparse matrix functionality])
   if test -n "$UMFPACK_LIBS"; then
     UMFPACK_LIBS="$UMFPACK_LIBS -lcblas"
   fi
   LIBS="$save_LIBS"
 fi
 
+## Test features of the installed UMFPACK library
+
 if test -n "$UMFPACK_LIBS"; then
+  ## SuiteSparse >= 4.0 needs additional link library for SuiteSparse_time()
   save_LIBS="$LIBS";
-  LIBS="$UMFPACK_LIBS $AMD_LIBS $BLAS_LIBS $FLIBS $LIBS"
-  OCTAVE_UMFPACK_SEPARATE_SPLIT
+  LIBS="$UMFPACK_LIBS $AMD_LDFLAGS $AMD_LIBS $BLAS_LIBS $FLIBS $LIBS"
+  xtra_libs=
+  OCTAVE_UMFPACK_NEED_SUITESPARSE_TIME
+  if test $octave_cv_umfpack_need_suitesparse_time = yes; then
+    AC_CHECK_LIB([rt], [clock_gettime], [xtra_libs="-lrt"], [xtra_libs=])
+    ## FIXME: This library list is only accurate for Linux, Mac OS X.
+    ##        Possibly need other library names for MinGW, Cygwin.
+    AC_SEARCH_LIBS([SuiteSparse_time],
+                   [suitesparseconfig SuiteSparse],
+                   [], [], [$xtra_libs])
+    case $ac_cv_search_SuiteSparse_time in
+      -l*)  
+        UMFPACK_LIBS="$UMFPACK_LIBS $ac_cv_search_SuiteSparse_time"
+      ;;
+      no)
+        UMFPACK_LIBS=
+        AC_MSG_WARN([UMFPACK library found but is missing SuiteSparse_time functionality.])
+        AC_MSG_WARN([UMFPACK library will be disabled.])
+      ;;
+    esac
+  fi
   LIBS="$save_LIBS"
+
+  ## Check for UMFPACK separately split complex matrix and RHS.
+  if test -n "$UMFPACK_LIBS"; then
+    save_LIBS="$LIBS";
+    LIBS="$UMFPACK_LIBS $CHOLMOD_LDFLAGS $CHOLMOD_LIBS $AMD_LDFLAGS $AMD_LIBS $COLAMD_LDFLAGS $COLAMD_LIBS $LAPACK_LIBS $BLAS_LIBS $FLIBS $LIBS $xtra_libs"
+    OCTAVE_UMFPACK_SEPARATE_SPLIT
+    LIBS="$save_LIBS"
+  fi
 fi
 
 ### Check for ARPACK library.
 
 save_LIBS="$LIBS"
 LIBS="$LAPACK_LIBS $BLAS_LIBS $FLIBS $LIBS"
-OCTAVE_CHECK_LIB(arpack, ARPACK,
+OCTAVE_CHECK_LIB([arpack], ARPACK,
   [ARPACK not found.  The eigs function will be disabled.],
   [],
   [dseupd],
   [Fortran 77], [don't use the ARPACK library, disable eigs function],
   [warn_arpack=
    OCTAVE_CHECK_LIB_ARPACK_OK(
      [AC_DEFINE(HAVE_ARPACK, 1, [Define to 1 if ARPACK is available.])],
      [warn_arpack="ARPACK library found, but does not seem to work properly -- disabling eigs function"])])
@@ -1315,22 +1355,22 @@ LIBS="$save_LIBS"
 OCTAVE_ENABLE_READLINE
 
 ### Enable dynamic linking.  --enable-shared implies this, so
 ### --enable-dl is only need if you are only building static libraries
 ### and want to try dynamic linking too (works on some systems, for
 ### example, OS X and Windows).
 
 AC_ARG_ENABLE([dl],
-  [AS_HELP_STRING([--enable-dl],
-    [allow loading of dynamically linked modules (not all systems)])],
-  [case "${enableval}" in
+  [AS_HELP_STRING([--disable-dl],
+    [disable loading of dynamically linked modules])],
+  [case $enableval in
      yes) ENABLE_DYNAMIC_LINKING=true ;;
      no) ENABLE_DYNAMIC_LINKING=false ;;
-     *) AC_MSG_ERROR([bad value ${enableval} for --enable-dl]) ;;
+     *) AC_MSG_ERROR([bad value $enableval for --enable-dl]) ;;
    esac],
   [ENABLE_DYNAMIC_LINKING=true])
 
 if $STATIC_LIBS || $SHARED_LIBS; then
   true
 else
   AC_MSG_ERROR([You can't disable building static AND shared libraries!])
 fi
@@ -1356,21 +1396,22 @@ DL_LDFLAGS='$(SH_LDFLAGS)'
 MKOCTFILE_DL_LDFLAGS='$(DL_LDFLAGS)'
 SONAME_FLAGS=
 NO_OCT_FILE_STRIP=false
 TEMPLATE_AR='$(AR)'
 TEMPLATE_ARFLAGS="$ARFLAGS"
 CRUFT_DLL_DEFS=
 OCTAVE_DLL_DEFS=
 OCTINTERP_DLL_DEFS=
+OCTGUI_DLL_DEFS=
 OCTGRAPHICS_DLL_DEFS=
 library_path_var=LD_LIBRARY_PATH
 ldpreloadsep=" "
 BUILD_COMPILED_AUX_PROGRAMS=false
-case "$canonical_host_type" in
+case $canonical_host_type in
   *-*-386bsd* | *-*-netbsd*)
     SH_LD=ld
     SH_LDFLAGS=-Bshareable
   ;;
   *-*-openbsd*)
     SH_LDFLAGS='-shared -fPIC'
   ;;
   *-*-freebsd*)
@@ -1381,17 +1422,17 @@ case "$canonical_host_type" in
     CXXPICFLAG=
     FPICFLAG=
     SH_LDFLAGS="-shared -Wl,-expect_unresolved -Wl,'*'"
   ;;
   *-*-darwin*)
     DL_LDFLAGS='-bundle -bundle_loader $(top_builddir)/libinterp/octave $(LDFLAGS)'
     MKOCTFILE_DL_LDFLAGS='-bundle -bundle_loader $$BINDIR/octave-$$OCTAVE_VERSION$$EXEEXT'
     SH_LDFLAGS='-dynamiclib -single_module $(LDFLAGS)'
-    case "$canonical_host_type" in
+    case $canonical_host_type in
       powerpc-*)
         CXXPICFLAG=
         CPICFLAG=
         FPICFLAG=
       ;;
     esac
     SHLEXT=dylib 
     SHLLIB='$(SHLEXT)'
@@ -1413,40 +1454,41 @@ case "$canonical_host_type" in
     SHLBIN=dll    
     DL_LDFLAGS="-shared -Wl,--export-all-symbols -Wl,--enable-auto-import -Wl,--enable-runtime-pseudo-reloc"
     SH_LDFLAGS="-shared -Wl,--export-all-symbols -Wl,--enable-auto-import -Wl,--enable-auto-image-base"
     SONAME_FLAGS='-Wl,--out-implib=$(patsubst $(SHLPRE)%,$(LIBPRE)%,$@).a'
     ldpreloadsep=":"
   ;;
   *-*-mingw*)
     BUILD_COMPILED_AUX_PROGRAMS=true
-    if test "$have_msvc" = "yes"; then
+    if test $have_msvc = yes; then
       DL_LDFLAGS="-shared"
       CPICFLAG=
       CXXPICFLAG=
       FPICFLAG=
       SHLEXT=dll
       SHLLIB=lib
       SHLBIN=dll
       LIBPRE=
       SHLPRE=
       SHLLIBPRE=
       SHLBINPRE=
       SH_LDFLAGS="-shared"
-      if test -n "`echo $CFLAGS | grep -e '-g'`" -o -n "`echo $CXXFLAGS | grep -e '-g'`"; then
+      if test -n "`echo $CFLAGS | grep -e '-g'`" || test -n "`echo $CXXFLAGS | grep -e '-g'`"; then
         DL_LDFLAGS="$DL_LDFLAGS -g"
         SH_LDFLAGS="$SH_LDFLAGS -g"
       fi
       NO_OCT_FILE_STRIP=true
       library_path_var=PATH
       NO_OCT_FILE_STRIP=true
       ## Extra compilation flags.
       CRUFT_DLL_DEFS="-DCRUFT_DLL"
       OCTAVE_DLL_DEFS="-DOCTAVE_DLL"
       OCTINTERP_DLL_DEFS="-DOCTINTERP_DLL"
+      OCTGUI_DLL_DEFS="-DOCTGUI_DLL"
       OCTGRAPHICS_DLL_DEFS="-DOCTGRAPHICS_DLL"
     else
       CPICFLAG=
       CXXPICFLAG=
       FPICFLAG=
       SHLEXT=dll
       SHLLIB=dll.a
       SHLBIN=dll
@@ -1466,27 +1508,27 @@ case "$canonical_host_type" in
     SHLEXT=dll
     SHLLIB=lib
     SHLBIN=dll
     LIBPRE=
     SHLPRE=
     SHLLIBPRE=
     SHLBINPRE=
     SH_LDFLAGS="-shared"
-    if test -n "`echo $CFLAGS | grep -e '-g'`" -o -n "`echo $CXXFLAGS | grep -e '-g'`"; then
+    if test -n "`echo $CFLAGS | grep -e '-g'`" || test -n "`echo $CXXFLAGS | grep -e '-g'`"; then
       DL_LDFLAGS="$DL_LDFLAGS -g"
       SH_LDFLAGS="$SH_LDFLAGS -g"
     fi
     NO_OCT_FILE_STRIP=true
     library_path_var=PATH
     NO_OCT_FILE_STRIP=true
     ## Extra compilation flags.
     CRUFT_DLL_DEFS="-DCRUFT_DLL"
     OCTAVE_DLL_DEFS="-DOCTAVE_DLL"
-    OCTINTERP_DLL_DEFS="-DOCTINTERP_DLL"
+    OCTGUI_DLL_DEFS="-DOCTGUI_DLL"
     OCTGRAPHICS_DLL_DEFS="-DOCTGRAPHICS_DLL"
   ;;
   *-*-linux* | *-*-gnu*)
     MKOCTFILE_DL_LDFLAGS="-shared -Wl,-Bsymbolic"
     SONAME_FLAGS='-Wl,-soname -Wl,$@'
   ;;
   i[[3456]]86-*-sco3.2v5*)
     SONAME_FLAGS='-Wl,-h -Wl,$@'
@@ -1494,49 +1536,49 @@ case "$canonical_host_type" in
   ;;
   rs6000-ibm-aix* | powerpc-ibm-aix*)
     CPICFLAG=
     CXXPICFLAG=
     FPICFLAG=
     library_path_var=LIBPATH
   ;;
   hppa*-hp-hpux*)
-    if test "$ac_cv_f77_compiler_gnu" = yes; then
+    if test $ac_cv_f77_compiler_gnu = yes; then
       FPICFLAG=-fPIC
     else
       FPICFLAG=+Z
     fi
     SHLEXT=sl
     SH_LDFLAGS="-shared -fPIC"
     library_path_var=SHLIB_PATH
   ;;
   ia64*-hp-hpux*)
-    if test "$ac_cv_f77_compiler_gnu" = yes; then
+    if test $ac_cv_f77_compiler_gnu = yes; then
       FPICFLAG=-fPIC
     else
       FPICFLAG=+Z
     fi
     SH_LDFLAGS="-shared -fPIC"
   ;;
   *-sgi-*)
     CPICFLAG=
     CXXPICFLAG=
     FPICFLAG=
   ;;
   sparc-sun-sunos4*)
-    if test "$ac_cv_f77_compiler_gnu" = yes; then
+    if test $ac_cv_f77_compiler_gnu = yes; then
       FPICFLAG=-fPIC
     else
       FPICFLAG=-PIC
     fi
     SH_LD=ld
     SH_LDFLAGS="-assert nodefinitions"
   ;;
   sparc-sun-solaris2* | i386-pc-solaris2*)
-    if test "$ac_cv_f77_compiler_gnu" = yes; then
+    if test $ac_cv_f77_compiler_gnu = yes; then
       FPICFLAG=-fPIC
     else
       FPICFLAG=-KPIC
     fi
     if test "$GCC" = yes; then
       CPICFLAG=-fPIC
     else
       CPICFLAG=-KPIC
@@ -1544,19 +1586,17 @@ case "$canonical_host_type" in
     if test "$GXX" = yes; then
       CXXPICFLAG=-fPIC
       SH_LDFLAGS=-shared
     else
       CXXPICFLAG=-KPIC
       SH_LDFLAGS=-G
     fi
     ## Template closures in archive libraries need a different mechanism.
-    if test "$GXX" = yes; then
-      true
-    else
+    if test "$GXX" != yes; then
       TEMPLATE_AR='$(CXX)'
       TEMPLATE_ARFLAGS="-xar -o"
     fi
   ;;
 esac
 
 AM_CONDITIONAL([AMCOND_BUILD_COMPILED_AUX_PROGRAMS],
   [test x$BUILD_COMPILED_AUX_PROGRAMS = xtrue])
@@ -1582,16 +1622,17 @@ AC_MSG_NOTICE([defining DL_LDFLAGS to be
 AC_MSG_NOTICE([defining MKOCTFILE_DL_LDFLAGS to be $MKOCTFILE_DL_LDFLAGS])
 AC_MSG_NOTICE([defining SONAME_FLAGS to be $SONAME_FLAGS])
 AC_MSG_NOTICE([defining NO_OCT_FILE_STRIP to be $NO_OCT_FILE_STRIP])
 AC_MSG_NOTICE([defining TEMPLATE_AR to be $TEMPLATE_AR])
 AC_MSG_NOTICE([defining TEMPLATE_ARFLAGS to be $TEMPLATE_ARFLAGS])
 AC_MSG_NOTICE([defining CRUFT_DLL_DEFS to be $CRUFT_DLL_DEFS])
 AC_MSG_NOTICE([defining OCTAVE_DLL_DEFS to be $OCTAVE_DLL_DEFS])
 AC_MSG_NOTICE([defining OCTINTERP_DLL_DEFS to be $OCTINTERP_DLL_DEFS])
+AC_MSG_NOTICE([defining OCTGUI_DLL_DEFS to be $OCTGUI_DLL_DEFS])
 AC_MSG_NOTICE([defining OCTGRAPHICS_DLL_DEFS to be $OCTGRAPHICS_DLL_DEFS])
 AC_MSG_NOTICE([defining library_path_var to be $library_path_var])
 AC_SUBST(FPICFLAG)
 AC_SUBST(CPICFLAG)
 AC_SUBST(CXXPICFLAG)
 AC_SUBST(SHLEXT)
 AC_SUBST(SHLLIB)
 AC_SUBST(SHLBIN)
@@ -1610,43 +1651,45 @@ AC_SUBST(DL_LDFLAGS)
 AC_SUBST(MKOCTFILE_DL_LDFLAGS)
 AC_SUBST(SONAME_FLAGS)
 AC_SUBST(NO_OCT_FILE_STRIP)
 AC_SUBST(TEMPLATE_AR)
 AC_SUBST(TEMPLATE_ARFLAGS)
 AC_SUBST(CRUFT_DLL_DEFS)
 AC_SUBST(OCTAVE_DLL_DEFS)
 AC_SUBST(OCTINTERP_DLL_DEFS)
+AC_SUBST(OCTGUI_DLL_DEFS)
 AC_SUBST(OCTGRAPHICS_DLL_DEFS)
 AC_SUBST(library_path_var)
 AC_SUBST(ldpreloadsep)
 
 ### More configure argument checking related to linking
 
 AC_ARG_ENABLE([no-undefined],
-  [AS_HELP_STRING([--enable-no-undefined],
-    [pass -no-undefined to libtool when linking Octave and its shared libraries (on by default)])],
-  [case "${enableval}" in
+  [AS_HELP_STRING([--disable-no-undefined],
+    [don't pass -no-undefined to libtool when linking Octave and its shared libraries])],
+  [case $enableval in
      yes) NO_UNDEFINED_LDFLAG="-no-undefined" ;;
      no)  NO_UNDEFINED_LDFLAG="" ;;
-     *) AC_MSG_ERROR([bad value ${enableval} for --enable-link-all-depenencies]) ;;
+     *) AC_MSG_ERROR([bad value $enableval for --disable-no-undefined]) ;;
    esac],
   [NO_UNDEFINED_LDFLAG="-no-undefined"])
 AC_SUBST(NO_UNDEFINED_LDFLAG)
 
 AC_ARG_ENABLE([link-all-dependencies],
   [AS_HELP_STRING([--enable-link-all-dependencies],
     [link Octave and its shared libraries with all dependencies, not just those immediately referenced (should not be needed on most systems)])],
-  [case "${enableval}" in
+  [case $enableval in
      yes) link_all_deps=true ;;
      no)  link_all_deps=false ;;
-     *) AC_MSG_ERROR([bad value ${enableval} for --enable-link-all-depenencies]) ;;
+     *) AC_MSG_ERROR([bad value $enableval for --enable-link-all-depenencies])
+     ;;
    esac],
   [link_all_deps=false])
-AM_CONDITIONAL([AMCOND_LINK_ALL_DEPS], [test x$link_all_deps = xtrue])
+AM_CONDITIONAL([AMCOND_LINK_ALL_DEPS], [test $link_all_deps = true])
 
 ## Dynamic linking is now enabled only if we are building shared
 ## libs and some API for dynamic linking has been detected.
 
 ## FIXME: A lot of the following duplicates the functionality of
 ## code generated by the dlopen option for LT_INIT.
 
 LD_CXX='$(CXX)'
@@ -1654,23 +1697,23 @@ RDYNAMIC_FLAG=
 DL_API_MSG=""
 dlopen_api=false
 shl_load_api=false
 loadlibrary_api=false
 dyld_api=false
 
 if $SHARED_LIBS || $ENABLE_DYNAMIC_LINKING; then
 
-  case "$lt_cv_dlopen" in
+  case $lt_cv_dlopen in
     dlopen)
       dlopen_api=true
       DL_API_MSG="(dlopen)"
       AC_DEFINE(HAVE_DLOPEN_API, 1,
         [Define to 1 if your system has dlopen, dlsym, dlerror, and dlclose for dynamic linking.])
-      OCTAVE_CXX_FLAG(-rdynamic, [RDYNAMIC_FLAG=-rdynamic])
+      OCTAVE_CXX_FLAG([-rdynamic], [RDYNAMIC_FLAG=-rdynamic])
     ;;
     shl_load)
       shl_load_api=true
       DL_API_MSG="(shl_load)"
       AC_DEFINE(HAVE_SHL_LOAD_API, 1,
         [Define to 1 if your system has shl_load and shl_findsym for dynamic linking.])
     ;;
     LoadLibrary)
@@ -1698,126 +1741,93 @@ if $SHARED_LIBS || $ENABLE_DYNAMIC_LINKI
   fi
 fi
 
 if $ENABLE_DYNAMIC_LINKING; then
   AC_DEFINE(ENABLE_DYNAMIC_LINKING, 1, [Define to 1 if using dynamic linking.])
 fi
 
 AM_CONDITIONAL([AMCOND_ENABLE_DYNAMIC_LINKING],
-  [test x$ENABLE_DYNAMIC_LINKING = xtrue])
+  [test x"$ENABLE_DYNAMIC_LINKING" = x"true"])
 
 if $SHARED_LIBS; then
-  LIBOCTINTERP=-loctinterp$SHLLINKEXT
-  LIBOCTAVE=-loctave$SHLLINKEXT
-  LIBCRUFT=-lcruft$SHLLINKEXT
+  LIBOCTINTERP="-loctinterp$SHLLINKEXT"
+  LIBOCTAVE="-loctave$SHLLINKEXT"
 else
   LIBOCTINTERP='$(top_builddir)/libinterp/liboctinterp.$(LIBEXT)'
   LIBOCTAVE='$(top_builddir)/liboctave/liboctave.$(LIBEXT)'
-  LIBCRUFT='$(top_builddir)/libcruft/libcruft.$(LIBEXT)'
 fi
 
 AC_SUBST(LD_CXX)
 AC_SUBST(RDYNAMIC_FLAG)
 AC_SUBST(ENABLE_DYNAMIC_LINKING)
 AC_SUBST(LIBOCTINTERP)
 AC_SUBST(LIBOCTAVE)
-AC_SUBST(LIBCRUFT)
 
 ### Check for existence of various libraries
 
 ## OS-specific test for dirent, opendir.
-case "$canonical_host_type" in
+case $canonical_host_type in
   *-*-mingw*)
-    if test "$have_msvc" = "yes"; then
-      AC_CHECK_LIB(dirent, opendir)
+    if test $have_msvc = yes; then
+      AC_CHECK_LIB([dirent], [opendir])
       LIBS="$LIBS -ladvapi32 -lgdi32 -lws2_32 -luser32 -lkernel32"
     else
       LIBS="$LIBS -lgdi32 -lws2_32 -luser32 -lkernel32"
     fi
     LIBS="$LIBS -lgdi32 -lws2_32 -luser32 -lkernel32"
   ;;
   *-*-msdosmsvc*)
-    AC_CHECK_LIB(dirent, opendir)
+    AC_CHECK_LIB([dirent], [opendir])
     LIBS="$LIBS -ladvapi32 -lgdi32 -lws2_32 -luser32 -lkernel32"
   ;;
 esac
 
 ## Find a termlib to use.
-octave_found_termlib=no
-for termlib in ncurses curses termcap terminfo termlib; do
-  AC_CHECK_LIB(${termlib}, tputs, [
-    TERM_LIBS="-l${termlib}"
-    octave_found_termlib=yes
-    break])
-done
-
-if test "$octave_found_termlib" = no; then
-  warn_termlibs="I couldn't find -ltermcap, -lterminfo, -lncurses, -lcurses, o\
-r -ltermlib!"
-  AC_MSG_WARN([$warn_termlibs])
-fi
-AC_SUBST(TERM_LIBS)
+OCTAVE_CHECK_LIB_TERMLIB
 
 ### Checks for header files.
 
 AC_HEADER_DIRENT
 AC_HEADER_SYS_WAIT
 
-dnl FIXME: We should probably only generate this file if it is missing.
-### Produce unistd.h for MSVC target, this simplifies changes in
-### Octave source tree and avoid problems with lex-generated code.
-case "$canonical_host_type" in
-  *-*-msdosmsvc)
-    AC_MSG_NOTICE([Generating replacement for <unistd.h> for MSVC])
-    cat << \EOF > unistd.h
-/* File generated by configure script. */
-#include <direct.h>
-#include <io.h>
-#include <process.h>
-EOF
-    CPPFLAGS="-I. $CPPFLAGS"
-    ;;
-esac
-
 ## C headers
 
-AC_CHECK_HEADERS(curses.h direct.h dlfcn.h floatingpoint.h grp.h \
-  ieeefp.h inttypes.h locale.h memory.h ncurses.h poll.h pthread.h \
-  pwd.h sunmath.h sys/ioctl.h sys/param.h sys/poll.h sys/resource.h \
-  sys/select.h sys/utsname.h termcap.h)
+dnl Use multiple AC_CHECKs to avoid line continuations '\' in list
+AC_CHECK_HEADERS([curses.h direct.h dlfcn.h floatingpoint.h grp.h])
+AC_CHECK_HEADERS([ieeefp.h inttypes.h locale.h memory.h ncurses.h])
+AC_CHECK_HEADERS([poll.h pthread.h pwd.h sunmath.h sys/ioctl.h])
+AC_CHECK_HEADERS([sys/param.h sys/poll.h sys/resource.h ])
+AC_CHECK_HEADERS([sys/select.h sys/utsname.h termcap.h])
 
 ## C++ headers
 
 AC_LANG_PUSH(C++)
 
-AC_CHECK_HEADERS(sstream)
+AC_CHECK_HEADERS([sstream])
 OCTAVE_UNORDERED_MAP_HEADERS
 
 AC_LANG_POP(C++)
 
 ## Find a termio header to include.
 
-have_termios_h=no
-AC_CHECK_HEADERS(termios.h, have_termios_h=yes)
-AC_CHECK_HEADERS(termio.h, have_termio_h=yes, have_termio_h=no)
-AC_CHECK_HEADERS(sgtty.h, have_sgtty_h=yes, have_sgtty_h=no)
-AC_CHECK_HEADERS(fnmatch.h, have_fnmatch_h=yes, have_fnmatch_h=no)
-AC_CHECK_HEADERS(conio.h, have_conio_h=yes, have_conio_h=no)
+AC_CHECK_HEADERS([termios.h], have_termios_h=yes, have_termios_h=no)
+AC_CHECK_HEADERS([termio.h], have_termio_h=yes, have_termio_h=no)
+AC_CHECK_HEADERS([sgtty.h], have_sgtty_h=yes, have_sgtty_h=no)
+AC_CHECK_HEADERS([fnmatch.h], have_fnmatch_h=yes, have_fnmatch_h=no)
+AC_CHECK_HEADERS([conio.h], have_conio_h=yes, have_conio_h=no)
 
-if test "$have_termios_h" = yes \
-    || test "$have_termio_h" = yes \
-    || test "$have_sgtty_h" = yes; then
-  true
-else
+if test $have_termios_h != yes \
+    && test $have_termio_h != yes \
+    && test $have_sgtty_h != yes; then
   AC_MSG_WARN([I couldn't find termios.h, termio.h, or sgtty.h!])
 fi
 
 ## For MSVC compilers, avoid #define of min/max from windows.h header
-if test "$have_msvc" = "yes"; then
+if test $have_msvc = yes; then
   AC_DEFINE(NOMINMAX, 1, [Define to 1 if you want to avoid min/max macro definition in Windows headers.])
 fi
 
 ### Determine types and size of types.
 
 AC_TYPE_INT64_T
 AC_TYPE_MODE_T
 AC_TYPE_OFF_T
@@ -1828,26 +1838,27 @@ AC_TYPE_UID_T
 AC_TYPE_UINT64_T
 AC_CHECK_TYPES([dev_t, ino_t])
 AC_CHECK_TYPES([long long int, unsigned long long int])
 AC_CHECK_TYPES([ptrdiff_t])
 
 ## How big are ints and how are they oriented?
 ## These could probably be eliminated in favor of run-time checks.
 
-AC_CHECK_SIZEOF(short)
-AC_CHECK_SIZEOF(int)
-AC_CHECK_SIZEOF(long)
-AC_CHECK_SIZEOF(long long)
+AC_CHECK_SIZEOF([short])
+AC_CHECK_SIZEOF([int])
+AC_CHECK_SIZEOF([long])
+AC_CHECK_SIZEOF([long long])
 ## Check for long double type (for 64-bit integers)
-AC_CHECK_SIZEOF(long double)
+AC_CHECK_SIZEOF([long double])
 
 ### Check structures and existence of necessary members
 
-AC_CHECK_MEMBERS([struct stat.st_blksize, struct stat.st_blocks, struct stat.st_rdev])
+AC_CHECK_MEMBERS([struct stat.st_blksize, struct stat.st_blocks,
+                  struct stat.st_rdev])
 AC_CHECK_MEMBERS([struct group.gr_passwd])
 
 AC_STRUCT_TIMEZONE
 
 ### Check compiler characteristics.
 
 ## Does compiler have support for new friend template declarations?
 OCTAVE_CXX_NEW_FRIEND_TEMPLATE_DECL
@@ -1888,27 +1899,34 @@ AM_PROG_CC_C_O
 ### gnulib initialization: part 2
 ### After all include and path modifications have taken place
 ### and at the same priority level as function checks.
 
 gl_INIT
 
 ### Checks for functions and variables.
 
-AC_CHECK_FUNCS(basename canonicalize_file_name \
-  chmod dup2 endgrent endpwent execvp expm1 expm1f fork \
-  getegid geteuid getgid getgrent getgrgid getgrnam getpgrp getpid \
-  getppid getpwent getpwuid getuid getwd _kbhit kill \
-  lgamma lgammaf lgamma_r lgammaf_r localtime_r log1p log1pf \
-  mkstemp pipe putenv \
-  realpath resolvepath rindex roundl select setgrent setlocale \
-  setpwent setvbuf siglongjmp \
-  strsignal tempnam tgammaf umask \
-  uname utime waitpid \
-  _chmod x_utime _utime32)
+dnl These checks define/undefine HAVE_FUNCNAME in config.h.
+dnl Code tests HAVE_FUNCNAME and either uses function or provides workaround.
+dnl Use multiple AC_CHECKs to avoid line continuations '\' in list
+AC_CHECK_FUNCS([canonicalize_file_name dup2])
+AC_CHECK_FUNCS([endgrent endpwent execvp expm1 expm1f fork])
+AC_CHECK_FUNCS([getegid geteuid getgid getgrent getgrgid getgrnam])
+AC_CHECK_FUNCS([getpgrp getpid getppid getpwent getpwuid getuid])
+AC_CHECK_FUNCS([kill lgamma lgammaf lgamma_r lgammaf_r])
+AC_CHECK_FUNCS([log1p log1pf pipe])
+AC_CHECK_FUNCS([realpath resolvepath roundl])
+AC_CHECK_FUNCS([select setgrent setpwent siglongjmp strsignal])
+AC_CHECK_FUNCS([tempnam tgammaf toascii])
+AC_CHECK_FUNCS([umask uname waitpid])
+AC_CHECK_FUNCS([_kbhit])
+
+dnl There are no workarounds in the code for missing these functions.
+AC_CHECK_FUNCS([modf pow sqrt sqrtf], [],
+               [AC_MSG_ERROR([Missing function required to build Octave])])
 
 ## exp2, round, tgamma function checks
 AC_LANG_PUSH(C++)
 AC_CHECK_DECLS([exp2, round, tgamma], [], [], [[#include <cmath>]])
 AC_CHECK_FUNCS([exp2 round tgamma])
 AH_VERBATIM([Z_FUNCS_AND_DECLS], [
 #if defined (__cplusplus)
 extern "C" {
@@ -1929,73 +1947,47 @@ double tgamma (double);
 AC_LANG_POP(C++)
 
 ## Look in <cmath> for the IEEE functions isnan, isinf, isfinite that we need.
 
 OCTAVE_CHECK_FUNC_CMATH(isnan)
 OCTAVE_CHECK_FUNC_CMATH(isinf)
 OCTAVE_CHECK_FUNC_CMATH(isfinite)
 
-dnl Would like to get rid of this cruft, and just have
+dnl Would like to get rid of this crap, and just have
 dnl
-dnl   AC_CHECK_FUNCS(finite isnan isinf)
+dnl   AC_CHECK_FUNCS([finite isnan isinf])
 dnl
 dnl instead, but that used to fail on some systems...
 dnl
 dnl Also just using AC_CHECK_FUNCS doesn't seem to work to find isinf
 dnl and isnan on Linux systems, so we use AC_CHECK_FUNC, and if that
 dnl fails, we try again by including math.h and invoking the function
 dnl with an argument. 
 
 ### I am told that Inf and NaN don't work on m68k HP sytems.
 
-case "$canonical_host_type" in
+case $canonical_host_type in
   m68k-hp-hpux*)
   ;;
   *)
-    AC_CHECK_FUNCS(finite isnan isinf signbit)
-    AC_CHECK_FUNCS(_finite _isnan)
-    AC_CHECK_DECLS(signbit, , , [#include <math.h>])
+    AC_CHECK_FUNCS([finite isnan isinf signbit])
+    AC_CHECK_FUNCS([_finite _isnan])
+    AC_CHECK_DECLS([signbit], , , [#include <math.h>])
   ;;
 esac
 
 ## Check for nonstandard, but common math functions, that we need.
 
-AC_CHECK_FUNCS(acosh acoshf asinh asinhf atanh atanhf cbrt cbrtf erf erff \
-  erfc erfcf exp2f hypotf _hypotf log2 log2f)
-
-## MinGW exception for mkstemp
-case "$canonical_host_type" in
-  *-*-mingw*)
-    ## MinGW does not provide a mkstemp function.  However, it provides
-    ## the mkstemps function in libiberty.
-    AC_MSG_CHECKING([for mkstemps in libiberty])
-    save_LIBS="$LIBS"
-    LIBS="-liberty $LIBS"
-    AC_LINK_IFELSE([
-      AC_LANG_PROGRAM([[
-        int mkstemps (char *pattern, int suffix_len);
-        ]], [[
-        mkstemps ("XXXXXX", 0);
-        ]]
-      )],
-    [AC_MSG_RESULT(yes)
-     HAVE_MKSTEMPS=yes
-     AC_DEFINE(HAVE_MKSTEMPS, 1,
-       [Define to 1 if mkstemps is available in libiberty.])
-    ],
-    [AC_MSG_RESULT(no)
-     HAVE_MKSTEMPS=no
-     LIBS="$save_LIBS"
-    ])
-   ;;
-esac
+dnl Use multiple AC_CHECKs to avoid line continuations '\' in list
+AC_CHECK_FUNCS([acosh acoshf asinh asinhf atanh atanhf cbrt cbrtf])
+AC_CHECK_FUNCS([erf erff erfc erfcf exp2f hypotf _hypotf log2 log2f])
 
 ## Windows-specific tests for extra #defines
-case "$canonical_host_type" in
+case $canonical_host_type in
   *-*-msdosmsvc | *-*-mingw*)
     AC_MSG_CHECKING([for required _WIN32_WINNT])
     AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
         #include <windows.h>
         #if _WIN32_WINNT < 0x0403
         #error "Wrong version"
         #endif
         ]], [])],
@@ -2010,48 +2002,56 @@ case "$canonical_host_type" in
         int x = M_LN2;]])],
       [AC_MSG_RESULT([no])],
       [AC_DEFINE(_USE_MATH_DEFINES, 1,
         [Define to 1 if your system needs to define math constants like M_LN2.])
         AC_MSG_RESULT([yes])])
   ;;
 esac
 
+## Windows-specific use of functions
+case $canonical_host_type in
+  *-*-mingw* | *-*-msdosmsvc*)
+    AC_CHECK_FUNCS([setvbuf], [],
+                   [AC_MSG_ERROR([Missing function required to build Octave])])
+    ;;
+esac
+
 ## Cygwin kluge for getrusage.
-AC_CHECK_FUNCS(getrusage)
-case "$canonical_host_type" in
+AC_CHECK_FUNCS([getrusage])
+case $canonical_host_type in
   *-*-cygwin*)
     AC_DEFINE(RUSAGE_TIMES_ONLY, 1,
       [Define to 1 if your struct rusage only has time information.])
   ;;
 esac
 
 ## Check for CGDisplayBitsPerPixel function on Mac OSX systems with Carbon
-if test $have_framework_carbon = "yes"; then
+if test $have_framework_carbon = yes; then
   OCTAVE_CARBON_CGDISPLAYBITSPERPIXEL
 fi
 
-AC_CHECK_FUNCS(getpwnam, [], [AC_CHECK_LIB(sun, getpwnam)])
+AC_CHECK_FUNCS([getpwnam], [], [AC_CHECK_LIB([sun], [getpwnam])])
 
 AC_FUNC_CLOSEDIR_VOID
 
 ## Check return type of matherr() 
 AC_CACHE_CHECK([for struct exception in math.h],
   [octave_cv_func_matherr_type],
   [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
       #include <math.h>
       ]], [[
       struct exception *x;
       x->type;
       x->name;
       ]])],
     octave_cv_func_matherr_type=yes,
     octave_cv_func_matherr_type=no)
   ])
-if test $octave_cv_func_matherr_type = "yes"; then
+if test $octave_cv_func_matherr_type = yes; then
   AC_DEFINE(EXCEPTION_IN_MATH, 1,
     [Define to 1 if math.h declares struct exception for matherr().])
 fi
  
 ## Signal stuff.
 
 AC_CHECK_DECLS([sys_siglist], [], [],
 [[#include <signal.h>
@@ -2120,106 +2120,165 @@ AC_SUBST(UGLY_DEFS)
 ### done feature testing. 
 
 GCC_EXTRA_FLAGS="-Wall -W -Wshadow -Wformat -Wpointer-arith -Wmissing-prototypes -Wstrict-prototypes -Wwrite-strings -Wcast-align -Wcast-qual"
 
 GXX_EXTRA_FLAGS="-Wall -W -Wshadow -Wold-style-cast -Wformat -Wpointer-arith -Wwrite-strings -Wcast-align -Wcast-qual"
 
 try_extra_warning_flags=true
 
-AC_ARG_ENABLE(extra-warning-flags,
-  [AS_HELP_STRING([--enable-extra-warning-flags],
-    [add -Wall, -W, -Wshadow, and -Wold-style-cast options to CFLAGS and CXXFLAGS  (on by default, but only if the compiler appears to accept them)])],
+AC_ARG_ENABLE([extra-warning-flags],
+  [AS_HELP_STRING([--disable-extra-warning-flags],
+    [don't add -Wall, -W, -Wshadow, and -Wold-style-cast options to CFLAGS and CXXFLAGS])],
   [if test "$enableval" = no; then
      try_extra_warning_flags=false
    fi],
   [])
 
 if $try_extra_warning_flags; then
   for flag in $GCC_EXTRA_FLAGS; do
-    OCTAVE_CC_FLAG($flag, [
+    OCTAVE_CC_FLAG([$flag], [
       WARN_CFLAGS="$WARN_CFLAGS $flag";
       AC_MSG_RESULT([adding $flag to WARN_CFLAGS])])
   done
   for flag in $GXX_EXTRA_FLAGS; do
-    OCTAVE_CXX_FLAG($flag, [
+    OCTAVE_CXX_FLAG([$flag], [
       WARN_CXXFLAGS="$WARN_CXXFLAGS $flag";
       AC_MSG_RESULT([adding $flag to WARN_CXXFLAGS])])
   done
 fi
 
 GCC_STRICT_FLAGS="-Wconversion"
 
 GXX_STRICT_FLAGS="-Wconversion -Weffc++"
 
 try_strict_warning_flags=false
 
-AC_ARG_ENABLE(strict-warning-flags,
+AC_ARG_ENABLE([strict-warning-flags],
   [AS_HELP_STRING([--enable-strict-warning-flags],
-    [add extra strict warning options to CFLAGS and CXXFLAGS (off by default)])],
+    [add extra strict warning options to CFLAGS and CXXFLAGS])],
   [if test "$enableval" = yes; then
      try_strict_warning_flags=true
    fi],
   [])
 
 if $try_strict_warning_flags; then
   for flag in $GCC_STRICT_FLAGS; do
-    OCTAVE_CC_FLAG($flag, [
+    OCTAVE_CC_FLAG([$flag], [
       WARN_CFLAGS="$WARN_CFLAGS $flag";
       AC_MSG_RESULT([adding $flag to WARN_CFLAGS])])
   done
   for flag in $GXX_STRICT_FLAGS; do
-    OCTAVE_CXX_FLAG($flag, [
+    OCTAVE_CXX_FLAG([$flag], [
       WARN_CXXFLAGS="$WARN_CXXFLAGS $flag";
       AC_MSG_RESULT([adding $flag to WARN_CXXFLAGS])])
   done
 fi
 
 AC_SUBST(WARN_CFLAGS)
 AC_SUBST(WARN_CXXFLAGS)
 
 ### GUI/Qt related tests.
 
 HAVE_QT=false
 QT_INCDIR=
 QT_LIBDIR=
-build_gui=yes
 win32_terminal=no
-AC_ARG_ENABLE(gui,
-  [AS_HELP_STRING([--disable-gui], [build GUI (default is yes)])],
-  [if test "$enableval" = no; then build_gui=no; fi], [build_gui=yes])
+build_gui=true
+GUIDIR=libgui
+AC_ARG_ENABLE([gui],
+  [AS_HELP_STRING([--disable-gui], [don't build the GUI])],
+  [if test "$enableval" = no; then build_gui=false; fi], [])
 
-if test $build_gui = yes; then
-  AC_CHECK_PROGS(QMAKE, [qmake qmake-qt4 qmake-qt5])
-  if test -n "$QMAKE"; then
-    QT_INCDIR=`$QMAKE -query | sed -n -e 's/^QT_INSTALL_HEADERS://p'`
-    QT_LIBDIR=`$QMAKE -query | sed -n -e 's/^QT_INSTALL_LIBS://p'`
-    AC_CHECK_PROGS(MOC, [moc moc-qt4 moc-qt5])
-    AC_CHECK_PROGS(UIC, [uic uic-qt4 uic-qt5])
-    AC_CHECK_PROGS(RCC, [rcc])
-    if test -n "$MOC" && test -n "$UIC" && test -n "$RCC"; then
-      HAVE_QT=true
-      AC_DEFINE(HAVE_QT, 1, 
-        [Define to 1 if Qt is available (must have moc, uic, and rcc programs and developer header files and libraries installed).])
-    fi
+if test $build_gui = true; then
+  ## Check for Qt libraries
+  PKG_CHECK_MODULES(QT, [QtCore, QtGui, QtNetwork],
+    [],
+    [AC_MSG_ERROR([Qt libraries are required to build the GUI])])
+
+  ## Check for Qt utility programs
+  AC_CHECK_PROGS(QMAKE, [qmake-qt5 qmake-qt4 qmake])
+  if test -z "$QMAKE"; then
+    AC_MSG_ERROR([qmake is required to build the GUI])
+  fi
+
+  QT_INCDIR=`$QMAKE -query QT_INSTALL_HEADERS | sed -e 's,\\\\,/,g'`
+  QT_LIBDIR=`$QMAKE -query QT_INSTALL_LIBS | sed -e 's,\\\\,/,g'`
+
+  if test "$QT_INCDIR" = "**Unknown**"; then
+    AC_MSG_ERROR([qmake >= Qt4 is required to build the GUI])
   fi
 
-  case "$canonical_host_type" in
-    *-*-mingw* | *-*-msdosmsvc*) win32_terminal=yes ;;
+  AC_CHECK_PROGS(MOC, [moc-qt5 moc-qt4 moc])
+  AC_CHECK_PROGS(UIC, [uic-qt5 uic-qt4 uic])
+  AC_CHECK_PROGS(RCC, [rcc])
+  if test -z "$MOC" || test -z "$UIC" || test -z "$RCC"; then
+    AC_MSG_ERROR([Qt utility programs moc, uic, and rcc are required to build the GUI])
+  fi 
+
+  HAVE_QT=true
+  AC_DEFINE(HAVE_QT, 1, 
+    [Define to 1 if Qt is available (libraries, developer header files, utility programs (qmake, moc, uic, and rcc))])
+
+  ## Check for Qscintilla library which is used in the GUI editor. 
+  AC_CACHE_CHECK([whether Qscintilla library is installed],
+    [octave_cv_lib_qscintilla],
+    [save_CPPFLAGS="$CPPFLAGS"
+    save_LDFLAGS="$LDFLAGS"
+    save_LIBS="$LIBS"
+    CPPFLAGS="-I$QT_INCDIR -I$QT_INCDIR/Qt $CPPFLAGS"
+    LDFLAGS="-L$QT_LIBDIR $LDFLAGS"
+    LIBS="-lqscintilla2"
+    AC_LANG_PUSH(C++)
+    AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+      #include <Qsci/qscilexersql.h>
+      ]], [[
+      QsciLexerSQL sqlLexer(0);
+      ]])],
+      octave_cv_lib_qscintilla=yes,
+      octave_cv_lib_qscintilla=no)
+    CPPFLAGS="$save_CPPFLAGS"
+    LDFLAGS="$save_LDFLAGS"
+    LIBS="$save_LIBS"
+    AC_LANG_POP([C++])
+  ])
+  if test $octave_cv_lib_qscintilla = no; then
+    AC_MSG_ERROR([Qscintilla library is required to build the GUI])
+  fi
+
+  ## Check for Qt functions which have changed their API over time
+  OCTAVE_CHECK_FUNC_FINDFIRST_MODERN
+  OCTAVE_CHECK_FUNC_SETPLACEHOLDERTEXT
+
+  AC_CHECK_FUNCS([setlocale], [],
+                 [AC_MSG_ERROR([Missing function required to build GUI])])
+
+  case $canonical_host_type in
+    *-*-mingw* | *-*-msdosmsvc*)
+      win32_terminal=yes
+      AC_CHECK_FUNCS([setvbuf], [],
+                     [AC_MSG_ERROR([Missing function required to build GUI])])
+      ;;
     *)
       AC_CHECK_HEADERS([pty.h libutil.h util.h])
       AC_SEARCH_LIBS([openpty], [util],
         [AC_DEFINE(HAVE_OPENPTY, [], [Define whether openpty exists])])
+      AC_CHECK_FUNCS([chmod chown ftruncate mmap munmap], [],
+                     [AC_MSG_ERROR([Missing function required to build GUI])])
       ;;
   esac
+else
+  ## GUI disabled.  Eliminate building GUIDIR directory
+  GUIDIR=
 fi
-AM_CONDITIONAL([AMCOND_BUILD_GUI], [test $build_gui = yes])
+AM_CONDITIONAL([AMCOND_BUILD_GUI], [test $build_gui = true])
 AM_CONDITIONAL([WIN32_TERMINAL], [test $win32_terminal = yes])
 AC_SUBST(QT_INCDIR)
 AC_SUBST(QT_LIBDIR)
+AC_SUBST(GUIDIR)
 
 ### Run configure in subdirectories.
 
 export CC
 export CXX
 export F77
 
 ### Some things to add to the bottom of config.h.
@@ -2249,21 +2308,21 @@ AH_BOTTOM([
 #define X_CAST(T, E) (T) (E)
 
 #if defined (CXX_BROKEN_REINTERPRET_CAST)
 #define FCN_PTR_CAST(T, E) (T) (E)
 #else
 #define FCN_PTR_CAST(T, E) reinterpret_cast<T> (E)
 #endif
 
-#if !defined(HAVE_DEV_T)
+#if ! defined (HAVE_DEV_T)
 typedef short dev_t;
 #endif
 
-#if !defined(HAVE_INO_T)
+#if ! defined (HAVE_INO_T)
 typedef unsigned long ino_t;
 #endif
 
 #if defined (_MSC_VER)
 #define __WIN32__
 #define WIN32
 /* missing parameters in macros */
 #pragma warning (disable: 4003)
@@ -2364,16 +2423,23 @@ typedef unsigned long ino_t;
 
 /* API macro for libinterp/graphics */
 #ifdef OCTGRAPHICS_DLL
 #define OCTGRAPHICS_API OCTAVE_EXPORT
 #else
 #define OCTGRAPHICS_API OCTAVE_IMPORT
 #endif
 
+/* API macro for libgui */
+#ifdef OCTGUI_DLL
+#define OCTGUI_API OCTAVE_EXPORT
+#else
+#define OCTGUI_API OCTAVE_IMPORT
+#endif
+
 /* oct-types.h */
 
 typedef OCTAVE_IDX_TYPE octave_idx_type;
 
 #include <stdint.h>
 
 /* Tag indicating Octave config.h has been included */
 #define OCTAVE_CONFIG_INCLUDED 1
@@ -2385,29 +2451,27 @@ dnl ------------------------------------
 ### Do the substitutions in all the Makefiles.
 
 AC_SUBST(ac_config_files)
 AC_SUBST(ac_config_headers)
 
 AC_CONFIG_FILES([
   Makefile 
   doc/Makefile
-  doc/faq/Makefile
   doc/icons/Makefile
   doc/interpreter/Makefile
   doc/liboctave/Makefile
   doc/refcard/Makefile
   examples/Makefile
-  libcruft/Makefile
-  libcruft/mkf77def
   libgnu/Makefile
   libgui/Makefile
-  libgui/src/Makefile
   libinterp/Makefile
   liboctave/Makefile
+  liboctave/cruft/Makefile
+  liboctave/cruft/mkf77def
   scripts/Makefile
   src/Makefile
   test/Makefile])
 
 AC_OUTPUT
 
 ### Print a summary so that important information isn't missed.
 
@@ -2477,49 +2541,53 @@ Octave is now configured for $canonical_
   Magick++ LDFLAGS:            $MAGICK_LDFLAGS
   Magick++ libraries:          $MAGICK_LIBS
   OPENGL libraries:            $OPENGL_LIBS
   PTHREAD flags:               $PTHREAD_CFLAGS
   PTHREAD libraries:           $PTHREAD_LIBS
   QHULL CPPFLAGS:              $QHULL_CPPFLAGS
   QHULL LDFLAGS:               $QHULL_LDFLAGS
   QHULL libraries:             $QHULL_LIBS
+  QRUPDATE CPPFLAGS:           $QRUPDATE_CPPFLAGS
+  QRUPDATE LDFLAGS:            $QRUPDATE_LDFLAGS
   QRUPDATE libraries:          $QRUPDATE_LIBS
   Qt headers:                  $QT_INCDIR
   Qt libraries:                $QT_LIBDIR
   READLINE libraries:          $READLINE_LIBS
   REGEX libraries:             $REGEX_LIBS
   TERM libraries:              $TERM_LIBS
+  UMFPACK CPPFLAGS:            $UMFPACK_CPPFLAGS
+  UMFPACK LDFLAGS:             $UMFPACK_LDFLAGS
   UMFPACK libraries:           $UMFPACK_LIBS
   X11 include flags:           $X11_INCFLAGS
   X11 libraries:               $X11_LIBS
   Z CPPFLAGS:                  $Z_CPPFLAGS
   Z LDFLAGS:                   $Z_LDFLAGS
   Z libraries:                 $Z_LIBS
 
   Default pager:               $DEFAULT_PAGER
   gnuplot:                     $GNUPLOT
 
+  Build Octave GUI:                   $build_gui
+  JIT compiler for loops:             $build_jit
   Do internal array bounds checking:  $BOUNDS_CHECKING
   Use octave_allocator:               $USE_OCTAVE_ALLOCATOR
   Build static libraries:             $STATIC_LIBS
   Build shared libraries:             $SHARED_LIBS
   Dynamic Linking:                    $ENABLE_DYNAMIC_LINKING $DL_API_MSG
   Include support for GNU readline:   $USE_READLINE
   64-bit array dims and indexing:     $USE_64_BIT_IDX_T
 ])
 
 warn_msg_printed=false
 
 OCTAVE_CONFIGURE_WARNING_SUMMARY
 
 if $ENABLE_DYNAMIC_LINKING; then
-  if $SHARED_LIBS; then
-    true
-  else
+  if test $SHARED_LIBS = false; then
     AC_MSG_WARN([You used --enable-dl but not --enable-shared.])
     AC_MSG_WARN([Are you sure that is what you want to do?])
     warn_msg_printed=true
   fi
 fi
 
 if $USE_64_BIT_IDX_T; then
   AC_MSG_WARN([])
@@ -2546,19 +2614,17 @@ if $USE_OPENMP; then
   AC_MSG_WARN([This option enables experimental SMP multithreding])
   AC_MSG_WARN([code that has had very little testing.  There is no])
   AC_MSG_WARN([certainity that the results returned by Octave with])
   AC_MSG_WARN([this option enabled will be correct.])
   AC_MSG_WARN([])
   warn_msg_printed=true
 fi
 
-if $native_graphics; then
-  true;
-else
+if test $native_graphics = false; then
   AC_MSG_WARN([])
   AC_MSG_WARN([I didn't find the necessary libraries to compile native])
   AC_MSG_WARN([graphics.  It isn't necessary to have native graphics,])
   AC_MSG_WARN([but you will need to have gnuplot installed or you won't])
   AC_MSG_WARN([be able to use any of Octave's plotting commands])
   AC_MSG_WARN([])
   warn_msg_printed=true
 fi
diff --git a/doc/Makefile.am b/doc/Makefile.am
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -1,9 +1,9 @@
-# Makefile for octave's doc/interpreter directory
+# Makefile for Octave's doc directory
 #
 # Copyright (C) 1993-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
@@ -15,19 +15,19 @@
 # for more details.
 # 
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
-## Avoid making multiple subdirs in parallel which can lead 
-## to a confusing error message stream
+## Avoid making multiple subdirs in parallel
+## which can lead to a confusing error message stream.
 .NOTPARALLEL:
 
 EXTRA_DIST = \
   Makefile.am \
   texinfo.tex \
   texmf.cnf
 
-SUBDIRS = faq icons interpreter liboctave refcard
+SUBDIRS = icons interpreter liboctave refcard
 
diff --git a/doc/faq/Makefile.am b/doc/faq/Makefile.am
deleted file mode 100644
--- a/doc/faq/Makefile.am
+++ /dev/null
@@ -1,34 +0,0 @@
-# Makefile for octave's doc/faq directory
-#
-# Copyright (C) 1996-2012 John W. Eaton
-#
-# This file is part of Octave.
-# 
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 3 of the License, or (at
-# your option) any later version.
-# 
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-# 
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, see
-# <http://www.gnu.org/licenses/>.
-
-include $(top_srcdir)/build-aux/common.mk
-
-## Automake generated rules for documentation are not parallel-safe.
-## Restrict current directory to run serially
-.NOTPARALLEL:
-
-TEXINFO_TEX = ../texinfo.tex
-
-info_TEXINFOS = OctaveFAQ.texi
-
-all-local: dvi html pdf ps
-
-EXTRA_DIST = OctaveFAQ.dvi OctaveFAQ.html OctaveFAQ.pdf OctaveFAQ.ps
-
diff --git a/doc/faq/OctaveFAQ.texi b/doc/faq/OctaveFAQ.texi
deleted file mode 100644
--- a/doc/faq/OctaveFAQ.texi
+++ /dev/null
@@ -1,1314 +0,0 @@
-% Copyright (C) 1997-2012 John W. Eaton
-%
-% This file is part of Octave.
-%
-% Octave is free software; you can redistribute it and/or modify it
-% under the terms of the GNU General Public License as published by the
-% Free Software Foundation; either version 3 of the License, or (at
-% your option) any later version.
-%
-% Octave is distributed in the hope that it will be useful, but WITHOUT
-% ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-% FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-% for more details.
-%
-% You should have received a copy of the GNU General Public License
-% along with Octave; see the file COPYING.  If not, see
-% <http://www.gnu.org/licenses/>.
-
-\input texinfo.tex      @c -*-texinfo-*-
-
-@setfilename OctaveFAQ.info
-@settitle Frequently asked questions about Octave (with answers)
-
-@setchapternewpage off
-@direntry
-* OctaveFAQ: (OctaveFAQ).  Frequently asked questions about Octave
-@end direntry
-@titlepage
-@title Octave FAQ
-@subtitle Frequently asked questions about Octave
-@subtitle @today{}
-@sp 1
-@author John W. Eaton and David Bateman
-@page
-@end titlepage
-
-@ifnottex
-@node Top
-@top
-@unnumbered Preface
-@cindex FAQ for Octave, latest version
-@end ifnottex
-
-This is a list of frequently asked questions (FAQ) for Octave users.
-
-We are always looking for new questions (@emph{with} answers), better
-answers, or both. Please send suggestions to
-@url{http://bugs.octave.org}. If you have general questions about
-Octave, or need help for something that is not covered by the Octave
-manual or the FAQ, please use the @email{help@@octave.org} mailing list.
-
-This FAQ is intended to supplement, not replace, the Octave manual.
-Before posting a question to the @email{help@@octave.org} mailing list,
-you should first check to see if the topic is covered in the manual.
-
-@menu
-* What is Octave?::
-* Licensing Issues::
-* How can I cite Octave?::
-* Series 3.4.N::
-* Octave Features::
-* Learning more about Octave::
-* Getting Octave::
-* Installation::
-* Common problems::
-* Using Octave::
-* @sc{Matlab} compatibility::
-* Index::
-@end menu
-
-@node What is Octave?
-@chapter What is Octave?
-
-Octave is a high-level interactive language, primarily intended for
-numerical computations that is mostly compatible with
-@sc{Matlab}.@footnote{@sc{Matlab} is a registered trademark of The
-MathWorks, Inc.}
-
-Octave can do arithmetic for real, complex or integer-valued scalars
-and matrices, solve sets of nonlinear algebraic equations, integrate
-functions over finite and infinite intervals, and integrate systems of
-ordinary differential and differential-algebraic equations.
-
-Octave uses the GNU readline library to handle reading and editing
-input.  By default, the line editing commands are similar to the
-cursor movement commands used by GNU Emacs, and a vi-style line
-editing interface is also available.  At the end of each session, the
-command history is saved, so that commands entered during previous
-sessions are not lost.
-
-The Octave distribution includes a 650+ page Texinfo manual. Access to
-the complete text of the manual is available via the @code{doc} command
-at the Octave prompt.
-
-@menu
-* Who develops Octave?::
-* Why GNU Octave?::
-* What version should I use?::
-* On what platforms does Octave run?::
-@end menu
-
-@node Who develops Octave?
-@section Who develops Octave?
-
-Discussions about writing the software that would eventually become
-Octave started in about 1988 with James B. Rawlings and John W. Eaton at
-the University of Texas. John W. Eaton was the original author of
-Octave, starting full-time development in February 1992. He is still the
-primary maintainer. The community of users/developers has in addition
-contributed some code and fuels the discussion on the mailing lists
-@email{help@@octave.org} (user forum), @email{maintainers@@octave.org}
-(development issues), and @email{octave-dev@@lists.sourceforge.net} (all
-things related to the Octave Forge repository of user-contributed
-functions).
-
-@node Why GNU Octave?
-@section Why GNU Octave?
-
-The GNU Project was launched in 1984 to develop a complete Unix-like
-operating system which is free software: the GNU system.
-
-GNU is a recursive acronym for ``GNU's Not Unix''; it is pronounced
-guh-noo, approximately like canoe.
-
-The Free Software Foundation (FSF) is the principal organizational
-sponsor of the GNU Project.
-
-Octave became GNU Octave in 1997 (beginning with version 2.0.6).  This
-meant agreeing to consider Octave a part of the GNU Project and support
-the efforts of the FSF.  However, Octave is not and has never been
-developed by the FSF.
-
-For more information about the GNU project, see @url{www.gnu.org}.
-
-@cindex FSF [Free Software Foundation]
-@cindex GNU [GNU's not unix]
-
-@node What version should I use?
-@section What version should I use?
-
-In general, you will find the latest version on
-@url{http://www.octave.org/download.html}. It is recommended to use the
-``stable'' version of octave for general use, and the ``development''
-version if you want the latest features.
-
-A list of user-visible changes since the last release is available in
-the file @file{NEWS}.  The file @file{ChangeLog} in the source
-distribution contains a more detailed record of changes made since the
-last release.
-
-@node On what platforms does Octave run?
-@section On what platforms does Octave run?
-
-Octave runs on various Unices---at least Linux and Solaris, Mac OS X,
-Windows and anything you can compile it on.  Binary distributions exist
-at least for Debian, Suse, Fedora and RedHat Linuxes (Intel and AMD
-@c Does Vista work? I get the feeling that even Windows users are trying
-@c to forget Vista like a bad nightmare. Tatsuro only confirmed XP and
-@c 7. I am tentatively assuming that Vista also works.
-CPUs, at least), for Mac OS X and Windows' 98, 2000, XP, Vista, and 7.
-
-Two and three dimensional plotting is fully supported using gnuplot and
-an experimental OpenGL backend.
-
-The underlying numerical solvers are currently standard Fortran ones
-like LAPACK, LINPACK, ODEPACK, the BLAS, etc., packaged in a library
-of C++ classes.  If possible, the Fortran subroutines are compiled
-with the system's Fortran compiler, and called directly from the C++
-functions.  If that's not possible, you can still compile Octave if
-you have the free Fortran to C translator f2c.
-
-Octave is also free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License, version 3, as
-published by the Free Software Foundation, or at your option any later
-version.
-
-@node Licensing Issues
-@chapter Licensing Issues
-
-@menu
-* If I write code using Octave do I have to release it under the GPL?: GPL
-* Since the MEX interface allows plugins to be distributed under terms that are incompatible with the GPL, does this mean that you are encouraging people to to write non-free software for Octave?: Licensing MEX Files
-* I wrote a program that links with Octave libraries and I don't want to release it under the terms of the GPL.  Will you change the license of the Octave libraries for me?: Requesting License Changes
-@end menu
-
-@node GPL
-@section If I write code using Octave do I have to release it under the GPL?
-
-The answer depends on precisely how the code is written and how it works.
-
-Code written entirely in the scripting language of Octave
-(interpreted code in .m files) may be released under the terms of
-whatever license you choose.
-
-Code written using Octave's native plug-in interface (also known
-as a .oct file) necessarily links with Octave internals and is
-considered a derivative work of Octave and therefore must be
-released under terms that are compatible with the GPL.
-
-Code written using Octave's implementation of the @sc{Matlab} MEX
-interface may be released under the terms of whatever license you
-choose, provided that the following conditions are met:
-
-@enumerate
-@item
-The plugin should not use any bindings that are specific to Octave.  In
-other words, the MEX file must use the MEX interface only, and not also
-call on other Octave internals.  It should be possible in principle to
-use the MEX file with other programs that implement the MEX interface
-(e.g., @sc{Matlab}).
-
-@item
-The MEX file should not be distributed together with Octave in such a
-way that they effectively create a single work.  For example, you should
-not distribute the MEX file and Octave together in a single package such
-that Octave automatically loads and runs the MEX file when it starts up.
-There are other possible ways that you might effectively create a single
-work; this is just one example.
-@end enumerate
-
-A program that embeds the Octave interpreter (e.g., by calling the
-"octave_main" function), or that calls functions from Octave's
-libraries (e.g., liboctinterp, liboctave, or libcruft) is
-considered a derivative work of Octave and therefore must be
-released under terms that are compatible with the GPL.
-
-@node Licensing MEX Files
-@section Since the MEX interface allows plugins to be distributed under terms that are incompatible with the GPL, does this mean that you are encouraging people to to write non-free software for Octave?
-
-No.  The original reason for implementing the MEX interface for Octave
-was to allow Octave to run free software that uses MEX files (the
-particular goal was to run SundialsTB in Octave).  The intent was to
-liberate that software from @sc{Matlab} and increase the amount of free
-software available to Octave users, not to enable people to write
-proprietary code for Octave.  For the good of the community, we strongly
-encourage users of Octave to release the code they write for Octave
-under terms that are compatible with the GPL.
-
-@node Requesting License Changes
-@section I wrote a program that links with Octave libraries and I don't want to release it under the terms of the GPL.  Will you change the license of the Octave libraries for me?
-
-No.  Instead of asking us to change the licensing terms for Octave, we
-recommend that you release your program under terms that are compatible
-with the GPL so that the free software community can benefit from your
-work the same as you have benefited from the work of all the people who
-have contributed to Octave.
-
-@node How can I cite Octave?
-@chapter How can I cite Octave?
-
-Pointing to @url{http://www.octave.org} is good, because that gives
-people a direct way to find out more.  If citation of a URL is not
-allowed by a publisher, or if you also want to point to a traditional
-reference, then you can cite the Octave manual:
-
-@example
-@group
-@@BOOK@{eaton:2008,
-  author =     "John W. Eaton and David Bateman and S√∏ren Hauberg",
-  title =      "GNU Octave Manual Version 3",
-  publisher =  "Network Theory Limited",
-  year =       "2008",
-  isbn =       "0-9546120-6-X"
-@}
-@end group
-@end example
-
-@node Series 3.4.N
-@chapter What's new in version series 3.4.N and 3.5.N of Octave
-
-The 3.4.N series has enough new features to justify a minor version
-number change. The full details are in the @file{NEWS} file, but in
-brief 3.4.N series brings:
-
-@c This list is distilled from the NEWS file. Does it have enough
-@c things? Does it have too many?
-@itemize @bullet
-
-@item ARPACK now distributed with Octave
-
-@item Indexing optimisations
-
-@item FTP object using @file{libcurl}
-
-@item Better consistency with ismatrix, issquare, and issymetric
-
-@item Function handles aware of overloaded functions
-
-@item More efficient matrix division by making a single LAPACK call
-
-@item Other optimisations in matrix operations
-
-@item @code{bsxfun} optimised for basic arithmetic functions
-
-@item @sc{Matlab}-style ignoring of output arguments using @samp{~}
-
-@item Many optimisations of the @code{accumarray} function
-
-@item Sparse matrix indexing has been rewritten for speed
-
-@item Configuration pseudo-variables like @code{page_screen_output}
-accept a ``local'' option argument to limit their scope to function
-scope
-
-@item The @code{pkg} command now accepts a @code{-forge} option to pull
-packages directly from Octave-forge
-
-@item Several @code{dlmread} improvements
-
-@item Octave now uses gnulib for better cross-platform compatibility
-
-@end itemize
-
-Here are some features that have been around since 3.2.N
-
-@itemize @bullet
-
-@item integer types
-
-@item fixed point arithmetic
-
-@item sparse matrices
-
-@item Linear programming code based on GLPK
-
-@item 64-bit compilation support
-
-@item gzipped files and stream and consequently support of @sc{Matlab} v7 files
-
-@item better support for both msvc and mingw
-
-@item a fully compatible MEX interface
-
-@item many many other minor features and compatibility changes
-
-@item OpenGL graphics toolkit
-
-An experimental OpenGL graphics toolkit to replace gnuplot.
-
-@item Object Orient Programming
-
-@item Block comments
-
-@item imwrite and imread
-
-The functions are based on the GraphicsMagick library.
-
-@item Lazy transpose
-
-Special treatment in the parser of things like "a' * b", where the
-transpose is never explicitly formed but a flag is rather passed to the
-underlying LAPACK code.
-
-@item Single precision type
-
-@item Improved array indexing
-The underlying code used for indexing of arrays has been completely
-rewritten and so the indexing of arrays is now significantly faster.
-
-@end itemize
-
-Here are some older features that have been around since 2.1.N:
-
-@itemize @bullet
-
-@item NDarrays
-
-@item cells
-
-@end itemize
-
-The 3.5.N series is the current development release and will become a
-3.6.N release in the future. This series brings the following new
-features:
-
-@itemize
-@item Perl-compatible regular expressions are now part of Octave
-@end itemize
-
-
-@node Octave Features
-@chapter What features are unique to Octave?
-
-@menu
-* Functions defined on the command-line::
-* Comments with #::
-* Strings delimited by double quotes "::
-* Line continuation by backslash::
-* Informative block closing::
-* Coherent syntax::
-* Exclamation mark as not operator::
-* Increment and decrement operators::
-* Unwind-protect::
-* Built-in ODE and DAE solvers::
-@end menu
-
-This section refers to @sc{Matlab} R2010b and Octave 3.4.0.
-
-@node Functions defined on the command-line
-@section Functions defined on the command-line
-
-Functions can be defined by entering code on the command line, a feature
-not supported by @sc{Matlab}. For example, you may type:
-
-@example
-@group
-octave:1> function s = hello_string (to_who)
-> ## Say hello
-> if nargin<1, to_who = "World"; end
-> s = ["Hello ",\
->      to_who];
-> endfunction
-octave:2> hello_string ("Moon")
-ans = Hello Moon
-@end group
-@end example
-
-@node Comments with #
-@section Comments with #
-
-The pound character, @samp{#}, may be used to start comments, in
-addition to @samp{%}. See the previous example. The major advantage of
-this is that as @samp{#} is also a comment character for unix script
-files, any file that starts with a string like @samp{#! /usr/bin/octave
--q} will be treated as an octave script and be executed by octave.
-
-@node Strings delimited by double quotes "
-@section Strings delimited by double quotes "
-The double quote, @samp{"}, may be used to delimit strings, in addition
-to the single quote @samp{'}. See the previous example. Also,
-double-quoted strings include backslash interpretation (like C++, C, and
-Perl) while single quoted are uninterpreted (like @sc{Matlab} and Perl).
-
-@node Line continuation by backslash
-@section Line continuation by backslash
-
-Lines can be continued with a backslash, @samp{\}, in addition to three
-points @samp{@dots{}}.  See the previous example.
-
-@node Informative block closing
-@section Informative block closing
-
-You may close @code{function}, @code{for}, @code{while}, @code{if},
-@dots{} blocks with @code{endfunction}, @code{endfor}, @code{endwhile},
-@dots{} keywords in addition to using @code{end}.  As with @sc{Matlab}, the
-@code{end} (or @code{endfunction}) keyword that marks the end of a
-function defined in a @file{.m} file is optional.
-
-@node Coherent syntax
-@section Coherent syntax
-
-Indexing other things than variables is possible, as in:
-@example
-@group
-octave:1> [3 1 4 1 5 9](3)
-ans = 4
-octave:2> cos ([0 pi pi/4 7])(3)
-ans = 0.70711
-@end group
-@end example
-
-@node Exclamation mark as not operator
-@section Exclamation mark as not operator
-
-The exclamation mark @samp{!} (aka ``Bang!'') is a negation operator, just
-like the tilde @samp{~}:
-
-@example
-@group
-octave:1> if ! strcmp (program_name, "octave"),
->   "It's an error"
-> else
->   "It works!"
-> end
-ans = It works!
-@end group
-@end example
-
-@noindent
-Note however that @sc{Matlab} uses the @samp{!} operator for shell
-escapes, for which Octave requires using the @code{system} command.
-
-@node Increment and decrement operators
-@section Increment and decrement operators
-
-@cindex Increment operators
-@cindex Decrement operators
-@cindex Operators, increment
-@cindex Operators, decrement
-
-If you like the @samp{++}, @samp{+=} etc operators, rejoice!
-Octave includes the C-like increment and decrement operators @samp{++}
-and @samp{--} in both their prefix and postfix forms, in addition to
-@samp{+=}, @samp{-=}, @samp{*=}, @samp{/=}, @samp{^=}, @samp{.*=},
-@samp{./=}, and @samp{.^=}.
-
-For example, to pre-increment the variable @var{x}, you would write
-@code{++@var{x}}.  This would add one to @var{x} and then return the new
-value of @var{x} as the result of the expression.  It is exactly the
-same as the expression @code{@var{x} = @var{x} + 1}.
-
-To post-increment a variable @var{x}, you would write @code{x++}.
-This adds one to the variable @var{x}, but returns the value that
-@var{x} had prior to incrementing it.  For example, if @var{x} is equal
-to 2, the result of the expression @code{x++} is 2, and the new
-value of @var{x} is 3.
-
-For matrix and vector arguments, the increment and decrement operators
-work on each element of the operand.
-
-@node Unwind-protect
-@section Unwind-protect
-
-@cindex Unwind-protect
-
-Octave supports a limited form of exception handling modeled after the
-unwind-protect form of Lisp.  The general form of an
-@code{unwind_protect} block looks like this:
-
-@example
-@group
-unwind_protect
-  @var{body}
-unwind_protect_cleanup
-  @var{cleanup}
-end_unwind_protect
-@end group
-@end example
-
-@noindent
-Where @var{body} and @var{cleanup} are both optional and may contain any
-Octave expressions or commands.  The statements in @var{cleanup} are
-guaranteed to be executed regardless of how control exits @var{body}.
-
-The @code{unwind_protect} statement is often used to reliably restore
-the values of global variables that need to be temporarily changed.
-
-@sc{Matlab} can be made to do something similar with their
-@code{OnCleanUp} function that was introduced in 2008a. Octave also has
-@code{onCleanup} since version 3.4.0.
-
-@node Built-in ODE and DAE solvers
-@section Built-in ODE and DAE solvers
-
-@cindex DASSL
-@cindex LSODE
-
-Octave includes LSODE and DASSL for solving systems of stiff ordinary
-differential and differential-algebraic equations.  These functions are
-built in to the interpreter.
-
-@node Learning more about Octave
-@chapter What documentation exists for Octave?
-
-@menu
-* Documentation::
-* Getting additional help::
-* User community::
-* Bug reports::
-@end menu
-
-@node Documentation
-@section What documentation exists for Octave?
-
-@cindex Octave, documentation
-
-The Octave distribution includes a 650+ page manual that is also
-distributed under the terms of the GNU GPL.
-It is available on the web at
-@url{http://www.octave.org/docs.html} and you will also
-find there instructions on how to order a paper version.
-
-The complete text of the Octave manual is also available using the GNU
-Info system via the GNU Emacs, info, or xinfo programs, or by using
-the @samp{doc} command to start the GNU info browser directly from
-the Octave prompt.
-
-If you have problems using this documentation, or find that some topic
-is not adequately explained, indexed, or cross-referenced, please report
-it on @url{http://bugs.octave.org}.
-
-@node Getting additional help
-@section Getting additional help
-
-@cindex Additional help
-@cindex Mailing lists, help-octave
-
-If you can't find an answer to your question, the
-@email{help@@octave.org} mailing list is available for questions related
-to using, installing, and porting Octave that are not adequately
-answered by the Octave manual or by this document.
-
-@node User community
-@section User community
-
-To subscribe to the list, go to @url{http://www.octave.org/archive.html}
-and follow the link to the subscription page for the list.
-
-@strong{Please do not} send requests to be added or removed from the
-mailing list, or other administrative trivia to the list itself.
-
-An archive of old postings to the help-octave mailing list is maintained
-on @url{http://www.octave.org/archive.html}.
-
-You will also find some user advice and code spread over the web.  Good
-starting points are the Octave Wiki @url{http://wiki.octave.org} and
-Octave-Forge @url{http://octave.sourceforge.net}
-
-@node Bug reports
-@section I think I have found a bug in Octave.
-
-@cindex Bug in Octave, newly found
-
-``I think I have found a bug in Octave, but I'm not sure.  How do I know,
-and who should I tell?''
-
-@cindex Manual, for Octave
-
-First, see the section on bugs and bug reports in the Octave manual.
-When you report a bug, make sure to describe the type of computer you
-are using, the version of the operating system it is running, and the
-version of Octave that you are using. Also provide enough code and
-configuration details of your operating system so that the Octave
-maintainers can duplicate your bug.
-
-@node Getting Octave
-@chapter Getting Octave
-
-@menu
-* Source code::
-* Pre-compiled binary packages::
-* Octave for other platforms::
-@end menu
-
-@node Source code
-@section Source code
-@cindex Source code
-
-Source code is available on the Octave development site, where you are
-sure to get the latest version.
-
-@itemize @bullet
-@item @url{http://www.octave.org/download.html}
-@item @url{ftp://ftp.octave.org/pub/octave/}
-@end itemize
-
-Since Octave is distributed under the terms of the GPL, you can get
-Octave from a friend who has a copy, or from the Octave website.
-
-@node Pre-compiled binary packages
-@section Pre-compiled binary packages
-@cindex  Pre-compiled binary packages
-@cindex  Binaries
-
-The Octave project does not distribute binary packages, but other
-projects do.  For an up-to-date listing of packagers, see:
-
-@itemize @bullet
-@item @url{http://www.octave.org/download.html}
-@item @url{http://wiki.octave.org/wiki.pl?CategoryInstall}
-@end itemize
-
-As of today, Octave binaries are available at least on Debian, Ubuntu,
-RedHat, Suse and Fedora GNU/Linuxen, Mac OS X, Windows' 98, 2000 and XP,
-Vista, and 7.
-
-@node Octave for other platforms
-@section How do I get a copy of Octave for (some other platform)?
-
-@cindex VMS support
-@cindex VAX
-@cindex MS-DOS support
-@cindex Windows support
-@cindex DJGPP
-@cindex EMX
-@cindex OS/2 support
-
-Octave currently runs on Unix-like systems, Mac OS X, and Windows.
-It should be possible to make Octave work on other systems as well.
-If you are interested in porting Octave to other systems, please contact
-@email{maintainers@@octave.org}.
-
-@c @menu
-@c * Octave for Unix::
-@c * Octave for other platforms::
-@c * latest versions::
-@c @end menu
-
-@c @cindex Octave, ordering
-@c @cindex Octave, getting a copy
-
-@node Installation
-@chapter Installation Issues and Problems
-
-@cindex Octave, building
-
-Octave 3.4 require approximately 1.3 GB of disk storage to unpack and
-compile from source (considerably less if you don't compile with
-debugging symbols). Once installed, Octave requires approximately 355 MB
-of disk space (again, considerably less if you don't compile with
-debugging symbols, approximately 50 MB).
-
-@menu
-* What else do I need?::
-* Other C++ compilers?::
-@end menu
-
-@node What else do I need?
-@section What else do I need?
-
-@cindex GNU gcc
-@cindex GNU g++
-@cindex libg++
-@cindex GNU Make
-@cindex Flex
-@cindex GNU Bison
-
-To compile Octave, you will need a recent version of GNU Make.  You
-will also need GCC 4.3  or later, although GCC 4.4 or later is
-recommended.
-
-@strong{You must have GNU Make to compile octave}.  Octave's Makefiles
-use features of GNU Make that are not present in other versions of make.
-GNU Make is very portable and easy to install.
-
-@node Other C++ compilers?
-@section Can I compile Octave with another C++ compiler?
-
-Yes, but development is done primarily with GCC, so you may hit some
-incompatibilities. Octave is intended to be portable to any standard
-conforming compiler. If you have difficulties that you think are bugs,
-please report them to the @url{http://bugs.octave.org} bug tracker, or
-ask for help on the @email{help@@octave.org} mailing list.
-
-@node Common problems
-@chapter Common problems
-
-This list is probably far too short.  Feel free to suggest additional
-questions (preferably with answers!)
-
-@itemize @bullet
-@item
-Octave takes a long time to find symbols.
-
-Octave uses the @code{genpath} function to recursively add directories
-to the list of directories searched for function files.  Check the list
-of directories with the @code{path} command. If the path list is very
-long check your use of the @code{genpath} function.
-
-@item
-When plotting Octave occasionally gives me errors like @samp{gnuplot> 9
-0.735604 line 26317: invalid command}.
-
-There is a known bug in gnuplot 4.2 that can cause an off by one error
-while piping data to gnuplot. It has been fixed in gnuplot 4.4.
-
-If you have obtained your copy of Octave from a distribution please file
-a bug report requesting that the fix reported in the above bug report be
-included.
-
-@item
-I cannot install a package. Octave complains about a missing
-@code{mkoctfile}.
-
-Most distributions split Octave into several packages. The script
-@code{mkoctfile} is then part of a separate package:
-@itemize @minus
-@item
-Debian/Ubuntu
-
-@c This will work once we upload the Octave packages without a version
-@c in their name to Debian.
-@code{aptitude install octave-headers}
-
-@item
-Fedora
-
-@code{yum install octave-devel}
-
-@end itemize
-@end itemize
-
-@node Using Octave
-@chapter  Using Octave
-
-@menu
-* How do I set the number of displayed decimals?::
-* How does Octave solve linear systems?::
-@end menu
-
-@cindex Tips and tricks
-@cindex Using Octave
-
-@node How do I set the number of displayed decimals?
-@section How do I set the number of displayed decimals?
-
-@example
-@group
-octave:1> format long
-octave:2> pi
-pi = 3.14159265358979
-octave:3> format short
-octave:4> pi
-pi = 3.1416
-@end group
-@end example
-
-@node How does Octave solve linear systems?
-@section How does Octave solve linear systems?
-
-@cindex backslash operator
-
-In addition to consulting Octave's source for the precise details, the
-Octave manual contains a complete high-level description of the
-algorithm that Octave uses to decide how to solve a particular linear
-system, e.g. how the backslash operator @code{A\x} will be interpreted.
-Sections ``Techniques Used for Linear Algebra'' and ``Linear Algebra on
-Sparse Matrices'' from the manual describe this procedure.
-
-@node @sc{Matlab} compatibility
-@chapter Porting programs from @sc{Matlab} to Octave
-
-@cindex @sc{Matlab} compatibility
-@cindex Compatibility with @sc{Matlab}
-
-People often ask
-
-@quotation
-I wrote some code for @sc{Matlab}, and I want to get it running under
-Octave.  Is there anything I should watch out for?
-@end quotation
-
-@noindent
-or alternatively
-
-@quotation
-I wrote some code in Octave, and want to share it with @sc{Matlab}
-users.  Is there anything I should watch out for?
-@end quotation
-
-@noindent
-which is not quite the same thing.  There are still a number of
-differences between Octave and @sc{Matlab}, however in general
-differences between the two are considered as bugs.  Octave might
-consider that the bug is in @sc{Matlab} and do nothing about it, but
-generally functionality is almost identical.  If you find a difference
-between Octave behavior and @sc{Matlab}, then you should send a
-description of this difference (with code illustrating the difference,
-if possible) to @url{http://bugs.octave.org}.
-
-Furthermore, Octave adds a few syntactical extensions to @sc{Matlab}
-that might cause some issues when exchanging files between @sc{Matlab}
-and Octave users. As both Octave and @sc{Matlab} are under constant
-development the information in this section is subject to change at
-anytime.
-
-You should also look at the page
-@url{http://octave.sourceforge.net/packages.html} and
-@url{http://octave.sourceforge.net/doc/} that has a function reference
-that is up to date. You can use this function reference to see the
-number of octave function that are available and their @sc{Matlab}
-compatibility.
-
-The major differences between Octave 3.4.N and  @sc{Matlab} R2010b are:
-
-@itemize @bullet
-@item Nested Functions
-
-Octave has limited support for nested functions. That is
-
-@example
-@group
-function y = foo (x)
-  y = bar (x)
-  function y = bar (x)
-    y = @dots{};
-  end
-end
-@end group
-@end example
-
-is equivalent to
-
-@example
-@group
-function y = foo (x)
-   y = bar (x)
-end
-function y = bar (x)
-   y = @dots{};
-end
-@end group
-@end example
-
-The main difference with @sc{Matlab} is a matter of scope. While nested
-functions have access to the parent function's scope in @sc{Matlab}, no
-such thing is available in Octave, due to how Octave essentially
-``un-nests'' nested functions.
-
-The authors of Octave consider the nested function scoping rules of
-@sc{Matlab} to be more problems than they are worth as they introduce
-difficult to find bugs as inadvertently modifying a variable in a
-nested function that is also used in the parent is particularly easy.
-
-@item Differences in core syntax
-There a few core @sc{Matlab} syntaxes that are not accepted by Octave,
-these being
-
-@itemize @bullet
-@item
-Some limitations on the use of function handles. The major difference is
-related to nested function scoping rules (as above) and their use with
-function handles.
-
-@item
-Some limitations of variable argument lists on the LHS of an expression,
-though the most common types are accepted.
-
-@item
-@sc{Matlab} classdef object oriented programming is not yet supported,
-though work is underway and when development more on to Octave 3.5 this
-will be included in the development tree.
-@end itemize
-
-@item Differences in core functions
-A large number of the @sc{Matlab} core functions (ie those that are in
-the core and not a toolbox) are implemented, and certainly all of the
-commonly used ones. There are a few functions that aren't implemented,
-usually to do with specific missing Octave functionality (GUI, DLL,
-Java, ActiveX, DDE, web, and serial functions). Some of the core
-functions have limitations that aren't in the @sc{Matlab} version. For
-example the @code{sprandn} function can not force a particular condition
-number for the matrix like @sc{Matlab} can.
-
-@item Just-In-Time compiler
-@sc{Matlab} includes a "Just-In-Time" compiler. This compiler allows the
-acceleration of for-loops in @sc{Matlab} to almost native performance
-with certain restrictions. The JIT must know the return type of all
-functions called in the loops and so you can't include user functions in
-the loop of JIT optimized loops. Octave doesn't have a JIT and so to
-some might seem slower than @sc{Matlab}. For this reason you must
-vectorize your code as much as possible. The MathWorks themselves have a
-good document discussing vectorization at
-@c It would be nice if we had our own guide for this instead of relying
-@c on Matlab documentation.
-@url{http://www.mathworks.com/support/tech-notes/1100/1109.html}.
-
-@item Compiler
-On a related point, there is no Octave compiler, and so you can't
-convert your Octave code into a binary for additional speed or
-distribution. There have been several aborted attempts at creating an
-Octave compiler. Should the JIT compiler above ever be implemented, an
-Octave compiler should be more feasible.
-@c Should we mention here any of the efforts to create a compiler? There
-@c used to be a dead link here to http://www.stud.tu-ilmenau.de/~rueckn/
-
-@item Graphic Handles
-Up to Octave 2.9.9 there was no support for graphic handles in Octave
-itself. In the 3.2.N versions of Octave and beyond the support for
-graphics handles is converging towards full compatibility. The
-@code{patch} function is currently limited to 2-D patches, due to an
-underlying limitation in gnuplot, but the experimental OpenGL backend is
-starting to see an implementation of 3-D patches.
-
-@item GUI
-There are no @sc{Matlab} compatible GUI functions. There are a number of
-bindings from Octave to Tcl/Tk, VTK and Zenity included in the Octave
-@c Is it too early to mention here the nascent fltk UI buttons?
-Forge project (@url{http://octave.sourceforge.net}) for example that can
-be used for a GUI, but these are not @sc{Matlab} compatible. Work on a
-@sc{Matlab} compatible GUI is in an alpha stage in the JHandles package
-@c Is Jhandles still usable? I thought Michael Goffioul had more or less
-@c already disowned it.
-(@url{http://octave.sourceforge.net/jhandles/index.html}). This might be
-an issue if you intend to exchange Octave code with @sc{Matlab} users.
-
-@item Simulink
-Octave itself includes no Simulink support. Typically the simulink
-models lag research and are less flexible, so shouldn't really be used
-in a research environment.  However, some @sc{Matlab} users that try to
-use Octave complain about this lack.  There is a similar package to
-simulink for the Octave and R projects available at
-@c is this project in any state of usability?
-@url{http://www.scicraft.org/}
-
-@item Mex-Files
-Octave includes an API to the @sc{Matlab} MEX interface. However, as MEX
-is an API to the internals of @sc{Matlab} and the internals of Octave
-differ from @sc{Matlab}, there is necessarily a manipulation of the data
-to convert from a MEX interface to the Octave equivalent. This is
-notable for all complex matrices, where @sc{Matlab} stores complex
-arrays as real and imaginary parts, whereas Octave respects the C99/C++
-standards of co-locating the real/imag parts in memory. Also due to the
-way @sc{Matlab} allows access to the arrays passed through a pointer,
-the MEX interface might require copies of arrays (even non complex
-ones).
-
-@item Block comments
-Block comments denoted by "%@{" and "%@}" markers are supported by
-Octave with some limitations. The major limitation is that block
-comments are not supported within [] or @{@}.
-
-@item Mat-File format
-There are some differences in the mat v5 file format accepted by Octave.
-@sc{Matlab} recently introduced the "-V7.3" save option which is an HDF5
-format which is particularly useful for 64-bit platforms where the
-standard @sc{Matlab} format can not correctly save variables. Octave
-accepts HDF5 files, but is not yet compatible with the "-v7.3" versions
-produced by @sc{Matlab}.
-
-Although Octave can load inline function handles saved by @sc{Matlab},
-it can not yet save them.
-
-Finally, Some multi-byte Unicode characters aren't yet treated in
-mat-files.
-
-@item Profiler
-Octave doesn't have a profiler. Though there is a patch for a flat
-profiler, that might become a real profiler sometime in the future. See
-the thread
-
-@c Did this idea go anywhere? Should it be mentioned?
-@url{http://octave.1599824.n4.nabble.com/Octave-profiler-td1641945.html#a1641947}
-
-for more details.
-
-@item Toolboxes
-Octave is a community project and so the toolboxes that exist are
-donated by those interested in them through the Octave Forge website
-(@url{http://octave.sourceforge.net}). These might be lacking in certain
-functionality relative to the @sc{Matlab} toolboxes, and might not
-exactly duplicate the @sc{Matlab} functionality or interface.
-
-@item Short-circuit & and | operators
-The @code{&} and @code{|} operators in @sc{Matlab} short-circuit when
-included in an if statement and not otherwise.  In Octave only the
-@code{&&} and @code{||} short circuit.  Note that this means that
-
-@example
-@group
-  if (a | b)
-    @dots{}
-  end
-@end group
-@end example
-
-and
-
-@example
-@group
-  t = a | b;
-  if t
-    @dots{}
-  end
-@end group
-@end example
-
-@noindent
-are different in @sc{Matlab}. This is really a @sc{Matlab} bug, but
-there is too much code out there that relies on this behaviour to change
-it. Prefer the || and && operators in if statements if possible. If you
-need to use code written for @sc{Matlab} that depends on this buggy
-behaviour, you can enable it since Octave 3.4.0 with the following
-command:
-
-@example
-@group
-  do_braindead_shortcircuit_evaluation (1)
-@end group
-@end example
-
-Note that the difference with @sc{Matlab} is also significant when
-either argument is a function with side effects or if the first argument
-is a scalar and the second argument is an empty matrix. For example,
-note the difference between
-
-@example
-@group
-  t = 1 | [];          ## results in [], so...
-  if (t) 1, end        ## in if ([]), this is false.
-@end group
-@end example
-
-and
-
-@example
-  if (1 | []) 1, end   ## short circuits so condition is true.
-@end example
-
-Another case that is documented in the @sc{Matlab} manuals is that
-
-@example
-@group
-  t = [1, 1] | [1, 2, 3];          ## error
-  if ([1, 1] | [1, 2, 3]) 1, end   ## OK
-@end group
-@end example
-
-Also @sc{Matlab} requires the operands of && and || to be scalar values
-but Octave does not (it just applies the rule that for an operand to be
-considered true, every element of the object must be nonzero or
-logically true).
-
-Finally, note the inconsistence of thinking of the condition of an if
-statement as being equivalent to @code{all (X(:))} when @var{X} is a
-matrix.  This is true for all cases EXCEPT empty matrices:
-
-@example
-@group
-  if ([0, 1]) == if (all ([0, 1]))   ==>  i.e., condition is false.
-  if ([1, 1]) == if (all ([1, 1]))   ==>  i.e., condition is true.
-@end group
-@end example
-
-However,
-
-@example
-  if ([]) != if (all ([]))
-@end example
-
-because @code{samp ([]) == 1} because, despite the name, it is really
-returning true if none of the elements of the matrix are zero, and since
-there are no elements, well, none of them are zero. This is an example
-of vacuous truth. But, somewhere along the line, someone decided that if
-@code{([])} should be false. Mathworks probably thought it just looks
-wrong to have @code{[]} be true in this context even if you can use
-logical gymnastics to convince yourself that "all" the elements of a
-matrix that doesn't actually have any elements are nonzero. Octave
-however duplicates this behavior for if statements containing empty
-matrices.
-
-@item Solvers for singular, under- and over-determined matrices
-
-@sc{Matlab}'s solvers as used by the operators mldivide (\) and mrdivide
-(/), use a different approach than Octave's in the case of singular,
-under-, or over-determined matrices. In the case of a singular matrix,
-@sc{Matlab} returns the result given by the LU decomposition, even
-though the underlying solver has flagged the result as erroneous. Octave
-has made the choice of falling back to a minimum norm solution of
-matrices that have been flagged as singular which arguably is a better
-result for these cases.
-
-In the case of under- or over-determined matrices, Octave continues to
-use a minimum norm solution, whereas @sc{Matlab} uses an approach that
-is equivalent to
-
-@example
-@group
-function x = mldivide (A, b)
-  [Q, R, E] = qr (A);
-  x = [A \ b, E(:, 1:m) * (R(:, 1:m) \ (Q' * b))]
-end
-@end group
-@end example
-
-@noindent
-While this approach is certainly faster and uses less memory than
-Octave's minimum norm approach, this approach seems to be inferior in
-other ways.
-
-A numerical question arises: how big can the null space component
-become, relative to the minimum-norm solution? Can it be nicely bounded,
-or can it be arbitrarily big? Consider this example:
-OctaveFAQ.texi
-@example
-@group
-m = 10;
-n = 10000;
-A = ones (m, n) + 1e-6 * randn (m,n);
-b = ones (m, 1) + 1e-6 * randn (m,1);
-norm (A \ b)
-@end group
-@end example
-
-@noindent
-while Octave's minimum-norm values are around 3e-2, @sc{Matlab}'s
-results are 50-times larger. For another issue, try this code:
-
-@example
-@group
-m = 5;
-n = 100;
-j = floor (m * rand (1, n)) + 1;
-b = ones (m, 1);
-A = zeros (m, n);
-A(sub2ind (size (A),j,1:n)) = 1;
-x = A \ b;
-[dummy,p] = sort (rand (1,n));
-y = A(:,p) \ b;
-norm (x(p)-y)
-@end group
-@end example
-
-@noindent
-It shows that unlike in Octave, mldivide in @sc{Matlab} is not invariant
-with respect to column permutations. If there are multiple columns of
-the same norm, permuting columns of the matrix gets you different
-result than permuting the solution vector. This will surprise many
-users.
-
-Since the mldivide (\) and mrdivide (/) operators are often part of a
-more complex expression, where there is no room to react to warnings or
-flags, it should prefer intelligence (robustness) to speed, and so the
-Octave developers are firmly of the opinion that Octave's approach for
-singular, under- and over-determined matrices is a better choice that
-@sc{Matlab}'s
-
-@item Octave extensions
-The extensions in Octave over @sc{Matlab} syntax are
-very useful, but might cause issues when sharing with @sc{Matlab} users.
-A list of the major extensions that should be avoided to be compatible
-with @sc{Matlab} are
-
-@itemize @bullet
-@item
-Comments in octave can be marked with @samp{#}. This allows POSIX
-systems to have the first line as @samp{#! octave -q} and mark the
-script itself executable. @sc{Matlab} doesn't have this feature due to
-the absence of comments starting with @samp{#}".
-
-@item
-Code blocks like @code{if}, @code{for}, @code{while}, etc can be
-terminated with block specific terminations like @code{endif}.
-@sc{Matlab} doesn't have this and all blocks must be terminated with
-@code{end}.
-
-@item
-Octave has a lisp like @code{unwind_protect} block that allows blocks of
-code that terminate in an error to ensure that the variables that are
-touched are restored. You can do something similar with
-@code{try}/@code{catch} combined with @samp{rethrow (lasterror ())} in
-@sc{Matlab}, however rethrow and lasterror are only available in Octave
-2.9.10 and later. @sc{Matlab} 2008a also introduced @code{OnCleanUp}
-that is similar to @code{unwind_protect}, except that the object created
-by this function has to be explicitly cleared in order for the cleanup
-code to run.
-
-Note that using @code{try}/@code{catch} combined with @samp{rethrow
-(lasterror ())} can not guarantee that global variables will be
-correctly reset, as it won't catch user interrupts with Ctrl-C. For
-example
-
-@example
-@group
-  global a
-  a = 1;
-  try
-    _a = a;
-    a = 2
-    while true
-    end
-  catch
-    fprintf ('caught interrupt\n');
-    a = _a;
-    rethrow (lasterror());
-  end
-@end group
-@end example
-
-@noindent
-compared to
-
-@example
-@group
-  global a
-  a = 1;
-  unwind_protect
-    _a = a;
-    a = 2
-    while true
-    end
-  unwind_protect_cleanup
-    fprintf ('caught interrupt\n');
-    a = _a;
-  end
-@end group
-@end example
-
-Typing Ctrl-C in the first case returns the user directly to the
-prompt, and the variable "a" is not reset to the saved value. In the
-second case the variable "a" is reset correctly.  Therefore @sc{Matlab}
-gives no safe way of temporarily changing global variables.
-
-@item
-Indexing can be applied to all objects in Octave and not just a
-variable. Therefore @code{sin(x)(1:10);} for example is perfectly valid
-in Octave but not @sc{Matlab}. To do the same in @sc{Matlab} you must do
-@code{y = sin (x); y = y([1:10]);}
-
-@item
-Octave has the operators "++", "--", "-=", "+=", "*=", etc.  As
-@sc{Matlab} doesn't, if you are sharing code these should be avoided.
-
-@item
-Character strings in Octave can be denoted with double or single
-quotes. There is a subtle difference between the two in that escaped
-characters like @code{\n} (newline), @code{\t} (tab), etc are
-interpreted in double quoted strings but not single quoted strings. This
-difference is important on Windows platforms where the "\" character is
-used in path names, and so single quoted strings should be used in
-paths. @sc{Matlab} doesn't have double quoted strings and so they should
-be avoided if the code will be transferred to a @sc{Matlab} user.
-@end itemize
-
-@end itemize
-
-@node Index
-@appendix Concept Index
-
-@printindex cp
-
-@page
-@contents
-@bye
diff --git a/doc/icons/Makefile.am b/doc/icons/Makefile.am
--- a/doc/icons/Makefile.am
+++ b/doc/icons/Makefile.am
@@ -1,9 +1,9 @@
-# Makefile for octave's doc/icons directory
+# Makefile for Octave's doc/icons directory
 #
 # Copyright (C) 2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
diff --git a/doc/interpreter/Makefile.am b/doc/interpreter/Makefile.am
--- a/doc/interpreter/Makefile.am
+++ b/doc/interpreter/Makefile.am
@@ -1,9 +1,9 @@
-# Makefile for octave's doc/interpreter directory
+# Makefile for Octave's doc/interpreter directory
 #
 # Copyright (C) 1993-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
@@ -15,20 +15,16 @@
 # for more details.
 # 
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
-## Automake generated rules for documentation are not parallel-safe.
-## Restrict current directory to run serially
-## .NOTPARALLEL:
-
 TEXINFO_TEX = ../texinfo.tex
 
 ## Leading PATH_SEPARATOR required due to weak parsing by dvips (12/04/09)
 TEXINPUTS := "$(PATH_SEPARATOR)$(srcdir)$(PATH_SEPARATOR)$(TEXINPUTS)$(PATH_SEPARATOR)"
 export TEXINPUTS
 
 ## Include custom texmf.cnf necessary to run @seealso macro 
 TEXMFCNF := "..$(PATH_SEPARATOR)$(srcdir)/..$(PATH_SEPARATOR)$(TEXMFCNF)$(PATH_SEPARATOR)"
@@ -86,18 +82,19 @@ include images.mk
 
 $(srcdir)/images.mk: $(srcdir)/config-images.sh $(srcdir)/images.awk $(srcdir)/images
 	$(srcdir)/config-images.sh $(top_srcdir)
 
 IMAGES = \
   $(IMAGES_EPS) \
   $(IMAGES_PDF) \
   $(IMAGES_PNG) \
-  $(IMAGES_TXT) \
-  $(HTMLDIR_IMAGES)
+  $(IMAGES_TXT)
+
+HTMLDIR_IMAGES = $(addprefix octave.html/, $(IMAGES_PNG))
 
 LOGOS = \
   octave_logo.eps \
   octave_logo.pdf
 
 MUNGED_TEXI_SRC = \
   arith.texi \
   audio.texi \
@@ -148,42 +145,41 @@ MUNGED_TEXI_SRC = \
   system.texi \
   testfun.texi \
   tips.texi \
   var.texi \
   vectorize.texi
 
 TXI_SRC = $(MUNGED_TEXI_SRC:.texi=.txi)
 
-info_TEXINFOS = octave.texi
-
-octave_TEXINFOS = \
+BUILT_TEXINFOS = \
   contributors.texi \
   $(MUNGED_TEXI_SRC)
 
-octave.info octave.dvi octave.html/index.html octave.pdf: $(srcdir)/version.texi $(octave_TEXINFOS) $(EXAMPLE_FILES) $(srcdir)/images.mk
-
-octave.info: $(IMAGES_TXT)
-
-octave.dvi octave.ps: $(IMAGES_EPS) octave_logo.eps
+info_TEXINFOS = octave.texi
 
-octave.html/index.html: $(IMAGES_PNG)
+octave_TEXINFOS = \
+  $(BUILT_TEXINFOS) \
+  $(EXAMPLE_FILES) \
+  $(IMAGES) \
+  $(LOGOS) \
+  $(srcdir)/images.mk
 
-octave.html:
-	if [ -d octave.html ]; then true; else mkdir octave.html; fi
+all-local: dvi html pdf ps doc-cache
 
-octave.pdf: $(IMAGES_PDF) octave_logo.pdf
+html: $(HTMLDIR_IMAGES)
+
+$(HTMLDIR_IMAGES): $(IMAGES_PNG) | octave.html
+	cp $(@F) octave.html
 
 ## The texi2dvi script (used to create both PDF and DVI output formats)
-## uses some fixed temporary file names, so wait for DVI file to be
-## generated before creating PDF file to avoid conflicts.
+## uses some fixed temporary file names.  In order to avoid a race condition
+## the DVI and PDF builds are forced to run serially through a Makefile rule.
 octave.pdf: octave.dvi
 
-all-local: dvi html pdf ps doc-cache $(HTMLDIR_IMAGES)
-
 # Prevent packaging of distribution unless all libraries 
 # necessary to create documentation are present
 dist-hook:
 	@$(GREP) '#define HAVE_COLAMD 1' $(top_builddir)/config.h > /dev/null || { echo "Documentation creation requires missing COLAMD library.  Cannot package distribution!" ; exit 1; }
 	@$(GREP) '#define HAVE_CHOLMOD 1' $(top_builddir)/config.h > /dev/null || { echo "Documentation creation requires missing CHOLMOD library.  Cannot package distribution!" ; exit 1; }
 	@$(GREP) '#define HAVE_UMFPACK 1' $(top_builddir)/config.h > /dev/null || { echo "Documentation creation requires missing UMFPACK library.  Cannot package distribution!" ; exit 1; }
 	@$(GREP) '#define HAVE_QHULL 1' $(top_builddir)/config.h > /dev/null || { echo "Documentation creation requires missing QHULL library.  Cannot package distribution!" ; exit 1; }
 
@@ -221,22 +217,22 @@ contributors.texi: contributors.in
 	mv BUGS ../../BUGS
 
 ../../INSTALL.OCTAVE: install.texi
 	rm -f INSTALL
 	-$(MAKEINFO) -D INSTALLONLY \
 	  --no-validate --no-headers --no-split --output INSTALL $<
 	mv INSTALL ../../INSTALL.OCTAVE
 
+
 undocumented_list:
 	rm -f $@
 	-$(PERL) $(srcdir)/doccheck/mk_undocumented_list > $@
 .PHONY: undocumented_list
 
-
 SPELLCHECK_FILES = $(MUNGED_TEXI_SRC:.texi=.scheck)
 
 %.scheck: %.texi
 	$(srcdir)/doccheck/spellcheck $< > $@-t
 	mv $@-t $@
 	[ -s $@ ] || rm -f $@
 
 spellcheck: $(SPELLCHECK_FILES) 
@@ -248,16 +244,17 @@ spellcheck: $(SPELLCHECK_FILES)
 	else \
 		echo "Spellcheck passed"; \
 	fi
 .PHONY: spellcheck
 
 EXTRA_DIST = \
   config-images.sh \
   contributors.in \
+  doc-cache \
   find-docstring-files.sh \
   images \
   images.awk \
   images.mk \
   macros.texi \
   mk_doc_cache.m \
   mkcontrib.awk \
   munge-texi.pl \
@@ -265,12 +262,15 @@ EXTRA_DIST = \
   octave.html \
   octave.pdf \
   octave.ps \
   $(IMAGES) \
   $(IMAGES_SRC) \
   $(LOGOS) \
   $(TXI_SRC)
 
-DISTCLEANFILES = $(octave_TEXINFOS) doc-cache
+clean-local:
+	rm -rf t2d_cache
+
+DISTCLEANFILES = $(BUILT_TEXINFOS) doc-cache
 
 MAINTAINERCLEANFILES = $(IMAGES)
 
diff --git a/doc/interpreter/arith.txi b/doc/interpreter/arith.txi
--- a/doc/interpreter/arith.txi
+++ b/doc/interpreter/arith.txi
@@ -113,16 +113,34 @@ specified in radians.  To convert from d
 @end ifnottex
 (e.g., @code{sin (30 * pi/180)} returns the sine of 30 degrees).  As
 an alternative, Octave provides a number of trigonometric functions
 which work directly on an argument specified in degrees.  These functions
 are named after the base trigonometric function with a @samp{d} suffix.  For
 example, @code{sin} expects an angle in radians while @code{sind} expects an
 angle in degrees.
 
+Octave uses the C library trigonometric functions.  It is expected that these
+functions are defined by the ISO/IEC 9899 Standard.  This Standard is available
+at: @url{http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf}.
+Section F.9.1 deals with the trigonometric functions.  The behavior of most of
+the functions is relatively straightforward.  However, there are some
+exceptions to the standard behavior.  Many of the exceptions involve the
+behavior for -0.  The most complex case is atan2.  Octave exactly implements
+the behavior given in the Standard.  Including
+@tex
+$atan2(\pm0, -0)$ returns $\pm \pi$.
+@end tex
+@ifnottex
+@code{atan2(+- 0, 0)} returns @code{+- pi}.
+@end ifnottex
+
+It should be noted that @sc{matlab} uses different definitions which apparently
+do not distinguish -0.
+
 @DOCSTRING(sin)
 @DOCSTRING(cos)
 @DOCSTRING(tan)
 @DOCSTRING(sec)
 @DOCSTRING(csc)
 @DOCSTRING(cot)
 
 @DOCSTRING(asin)
@@ -239,16 +257,18 @@ cos (pi/2)
 @DOCSTRING(mod)
 
 @DOCSTRING(primes)
 
 @DOCSTRING(list_primes)
 
 @DOCSTRING(sign)
 
+@DOCSTRING(signbit)
+
 @node Special Functions
 @section Special Functions
 
 @DOCSTRING(airy)
 
 @DOCSTRING(besselj)
 
 @DOCSTRING(beta)
diff --git a/doc/interpreter/basics.txi b/doc/interpreter/basics.txi
--- a/doc/interpreter/basics.txi
+++ b/doc/interpreter/basics.txi
@@ -96,16 +96,20 @@ specified.
 @item --exec-path @var{path}
 @cindex @code{--exec-path @var{path}}
 Specify the path to search for programs to run.  The value of @var{path}
 specified on the command line will override any value of
 @w{@env{OCTAVE_EXEC_PATH}} found in the environment, but not any commands
 in the system or user startup files that set the built-in variable
 @w{@env{EXEC_PATH}}.
 
+@item --force-gui
+@cindex @code{--force-gui}
+Force the graphical user interface (GUI) to start.
+
 @item  --help
 @itemx -h
 @itemx -?
 @cindex @code{--help}
 @cindex @code{-h}
 @cindex @code{-?}
 Print short help message and exit.
 
@@ -136,43 +140,61 @@ commands in the system or user startup f
 @item  --interactive
 @itemx -i
 @cindex @code{--interactive}
 @cindex @code{-i}
 Force interactive behavior.  This can be useful for running Octave via a
 remote shell command or inside an Emacs shell buffer.  For another way
 to run Octave within Emacs, see @ref{Emacs Octave Support}.
 
+@item --jit-debug
+@cindex @code{--jit-debug}
+Enable JIT compiler debugging and tracing.
+
 @item --line-editing
 @cindex @code{--line-editing}
 Force readline use for command-line editing.
 
+@item --no-gui
+@cindex @code{--no-gui}
+Disable the graphical user interface (GUI) and use the command line
+interface (CLI) instead.
+
 @item  --no-history
 @itemx -H
 @cindex @code{--no-history}
 @cindex @code{-H}
 Disable recording of command-line history.
 
 @item --no-init-file
 @cindex @code{--no-init-file}
 Don't read the initialization files @file{~/.octaverc} and @file{.octaverc}.
 
 @item --no-init-path
 @cindex @code{--no-init-path}
 Don't initialize the search path for function files to include default 
 locations.
 
+@item --no-jit-compiler
+@cindex @code{--no-jit-compiler}
+Disable the JIT compiler used for accelerating loops.
+
 @item --no-line-editing
 @cindex @code{--no-line-editing}
 Disable command-line editing.
 
 @item --no-site-file
 @cindex @code{--no-site-file}
 Don't read the site-wide @file{octaverc} initialization files.
 
+@item --no-window-system
+@cindex @code{--no-window-system}
+Disable use of a windowing system including graphics.  This forces a
+strictly terminal-only environment.
+
 @item  --norc
 @itemx -f
 @cindex @code{--norc}
 @cindex @code{-f}
 Don't read any of the system or user initialization files at startup.
 This is equivalent to using both of the options @option{--no-init-file}
 and @option{--no-site-file}.
 
@@ -194,16 +216,20 @@ named on the command line.
 @item  --silent
 @itemx --quiet
 @itemx -q
 @cindex @code{--silent}
 @cindex @code{--quiet}
 @cindex @code{-q}
 Don't print the usual greeting and version message at startup.
 
+@item --texi-macros-file @var{filename}
+@cindex @code{--texi-macros-file @var{filename}}
+Specify the name of the file containing Texinfo macros for use by makeinfo.
+
 @item  --traditional
 @itemx --braindead
 @cindex @code{--traditional}
 @cindex @code{--braindead}
 For compatibility with @sc{matlab}, set initial values for
 user preferences to the following values
 
 @example
@@ -348,18 +374,18 @@ to Octave are possible and which are in 
 @cindex quitting octave
 
 @DOCSTRING(quit)
 
 @DOCSTRING(atexit)
 
 @node Getting Help
 @section Commands for Getting Help
-@cindex on-line help
-@cindex help, on-line
+@cindex online help
+@cindex help, online
 
 The entire text of this manual is available from the Octave prompt
 via the command @kbd{doc}.  In addition, the documentation for
 individual user-written functions and variables is also available via
 the @kbd{help} command.  This section describes the commands used for
 reading the manual and the documentation strings for user-supplied
 functions and variables.  @xref{Function Files}, for more information
 about how to document the functions you write.
diff --git a/doc/interpreter/contrib.txi b/doc/interpreter/contrib.txi
--- a/doc/interpreter/contrib.txi
+++ b/doc/interpreter/contrib.txi
@@ -36,17 +36,17 @@ This chapter is dedicated to those who w
 
 @node How to Contribute
 @section How to Contribute
 The mailing list for Octave development discussion and sending
 contributions is @email{maintainers@@octave.org}.  This concerns the
 development of Octave core, i.e., code that goes to Octave directly.
 You may consider developing and publishing a package instead; a great
 place for this is the allied Octave-Forge project
-(@url{http://octave.sf.net}).  Note that the Octave project is
+(@url{http://octave.sourceforge.net}).  Note that the Octave project is
 inherently more conservative and follows narrower rules.
 
 @node Building the Development Sources
 @section Building the Development Sources
 
 In addition to all the tools (both optional and required) that are
 listed in @ref{Build Dependencies} you will need:
 
@@ -63,31 +63,31 @@ gnulib sources that Octave depends on ar
 Once you have the required tools installed, you can build Octave by
 doing
 
 @itemize @bullet
 @item
 Check out a copy of the Octave sources:
 
 @example
-hg clone http://hg.savannah.gnu.org/hgweb/octave
+hg clone http://www.octave.org/hg/octave
 @end example
 
 @item
 Change to the top-level directory of the newly checked out sources:
 
 @example
 cd octave
 @end example
 
 @item
 Generate the necessary configuration files:
 
 @example
-./autogen.sh
+./bootstrap
 @end example
 
 @item
 Create a build directory and change to it:
 
 @example
 @group
 mkdir build
diff --git a/doc/interpreter/contributors.in b/doc/interpreter/contributors.in
--- a/doc/interpreter/contributors.in
+++ b/doc/interpreter/contributors.in
@@ -43,16 +43,17 @@ Martin Dalecki
 Jorge Barros de Abreu
 Carlo de Falco
 Jacob Dawid
 Thomas D. Dean
 Philippe Defert
 Bill Denney
 Fabian Deutsch
 Christos Dimitrakakis
+Pantxo Diribarne
 Vivek Dogra
 David M. Doolin
 Carn√´ Draug
 Pascal A. Dupuis
 John W. Eaton
 Dirk Eddelbuettel
 Pieter Eendebak
 Paul Eggert
@@ -92,16 +93,17 @@ Dave Hawthorne
 Daniel Heiserer
 Martin Helm
 Stefan Hepp
 Jordi Guti√©rrez Hermoso
 Yozo Hida
 Ryan Hinton
 Roman Hodek
 A. Scottedward Hodel
+J√∫lio Hoffimann
 Richard Allan Holcombe
 Tom Holroyd
 David Hoover
 Kurt Hornik
 Christopher Hulbert
 Cyril Humbert
 John Hunt
 Teemu Ikonen
@@ -184,16 +186,17 @@ Rick Niles
 Takuji Nishimura
 Kai Noda
 Eric Norum
 Krzesimir Nowak
 Michael O'Brien
 Peter O'Gorman
 Thorsten Ohl
 Arno Onken
+Valentin Ortega-Clavero
 Luis F. Ortiz
 Scott Pakin
 Gabriele Pannocchia
 Sylvain Pelissier
 Per Persson
 Primozz Peterlin
 Jim Peterson
 Danilo Piazzalunga
@@ -290,11 +293,8 @@ Andreas Weingessel
 Martin Weiser
 Michael Weitzel
 David Wells
 Fook Fah Yap
 Sean Young
 Michael Zeising
 Federico Zenith
 Alex Zvoleff
-Valentin Ortega-Clavero
-Jacob Dawid
-J√∫lio Hoffimann
diff --git a/doc/interpreter/doccheck/aspell-octave.en.pws b/doc/interpreter/doccheck/aspell-octave.en.pws
--- a/doc/interpreter/doccheck/aspell-octave.en.pws
+++ b/doc/interpreter/doccheck/aspell-octave.en.pws
@@ -333,17 +333,17 @@ genvarname
 geocdf
 geoinv
 geopdf
 geornd
 GEP
 geq
 gesdd
 gesvd
-gfortan
+gfortran
 Ghostscript
 Ghostscript's
 gif
 GIF
 glibc
 globbing
 glpk
 GLS
@@ -451,16 +451,17 @@ isreal
 issparse
 isvector
 iter
 ith
 iy
 Jacobian
 Jacobians
 ji
+JIT
 jpeg
 JPEG
 jpg
 jvm
 keybindings
 keypress
 Kolmogorov
 kolmogorov
@@ -488,30 +489,31 @@ leftarrow
 Leftrightarrow
 leftrightarrow
 Lehoucq
 leq
 Levinson
 LF
 lfloor
 li
-libcruft
 libcurl
 liblapack
 liboctave
+liboctinterp
 Libtool
 licensors
 lineanchors
 linefeeds
 linesearch
 linespec
 linespoints
 linkprop
 literalspacing
 Liu
+LLVM
 LM
 lm
 loadpath
 Lobatto
 logit
 logncdf
 logninv
 lognormal
@@ -695,16 +697,17 @@ png
 PNG
 pnm
 PointJet
 poisscdf
 poissinv
 poisspdf
 poissrnd
 polyderiv
+polyeig
 polyfit
 polyval
 POSIX
 postorder
 PostScript
 Pothen
 pre
 preconditioner
@@ -729,16 +732,17 @@ PWS
 Pxx
 Qci
 Qhull
 qhull
 QP
 QQ
 qrupdate
 QRUPDATE
+QScintilla
 quadcc
 quadgk
 quadl
 quadpack
 quadv
 quantile
 Quantile
 quantiles
@@ -1024,16 +1028,17 @@ Voronoi
 Wa
 waitbar
 waitbars
 wallis
 wblcdf
 wblinv
 wblpdf
 wblrnd
+WebKit
 Weibull
 Welch
 welch
 WestOutside
 whitespace
 Whitespace
 whos
 wienrnd
diff --git a/doc/interpreter/errors.txi b/doc/interpreter/errors.txi
--- a/doc/interpreter/errors.txi
+++ b/doc/interpreter/errors.txi
@@ -110,17 +110,17 @@ error.
 f ()
 
 @print{}  error: Invalid call to f.  Correct usage is:
 @print{}  
 @print{}   -- Function File: f (ARG1)
 @print{}  
 @print{}  
 @print{}  Additional help for built-in functions and operators is
-@print{}  available in the on-line version of the manual.  Use the command
+@print{}  available in the online version of the manual.  Use the command
 @print{}  `doc <topic>' to search the manual index.
 @print{}  
 @print{}  Help and information about Octave is also available on the WWW
 @print{}  at http://www.octave.org and via the help@@octave.org
 @print{}  mailing list.
 @end group
 @end example
 
@@ -291,17 +291,20 @@ Since warnings aren't fatal to a running
 to catch a warning using the @code{try} statement or something similar.
 It is however possible to access the last warning as a string using the
 @code{lastwarn} function.
 
 It is also possible to assign an identification string to a warning.
 If a warning has such an ID the user can enable and disable this warning
 as will be described in the next section.  To assign an ID to a warning,
 simply call @code{warning} with two string arguments, where the first
-is the identification string, and the second is the actual warning.
+is the identification string, and the second is the actual warning.  Note
+that warning IDs are in the format "NAMESPACE:WARNING-NAME".  The namespace
+"Octave" is used for Octave's own warnings.  Any other string is available
+as a namespace for user's own warnings.
 
 @DOCSTRING(warning)
 
 @DOCSTRING(lastwarn)
 
 @node Enabling and Disabling Warnings
 @subsection Enabling and Disabling Warnings
 
@@ -310,28 +313,28 @@ are actually printed to the screen.  If 
 is called with a string argument that is either @code{"on"} or @code{"off"}
 all warnings will be enabled or disabled.
 
 It is also possible to enable and disable individual warnings through
 their string identifications.  The following code will issue a warning
 
 @example
 @group
-warning ("non-negative-variable", 
+warning ("example:non-negative-variable", 
          "'a' must be non-negative.  Setting 'a' to zero.");
 @end group
 @end example
 
 @noindent
 while the following won't issue a warning
 
 @example
 @group
-warning ("off", "non-negative-variable");
-warning ("non-negative-variable", 
+warning ("off", "example:non-negative-variable");
+warning ("example:non-negative-variable", 
          "'a' must be non-negative.  Setting 'a' to zero.");
 @end group
 @end example
 
 The functions distributed with Octave can issue one of the following
 warnings.
 
 @DOCSTRING(warning_ids)
diff --git a/doc/interpreter/image.txi b/doc/interpreter/image.txi
--- a/doc/interpreter/image.txi
+++ b/doc/interpreter/image.txi
@@ -112,16 +112,18 @@ A pixel in a binary image is black if it
 if it is @code{true}.
 
 An indexed image consists of an M-by-N matrix of integers
 and a C-by-3 color map.  Each integer corresponds to an
 index in the color map, and each row in the color map corresponds to
 an RGB color.  The color map must be of class @code{double} with values
 between 0 and 1.
 
+@DOCSTRING(iscolormap)
+
 @DOCSTRING(gray2ind)
 
 @DOCSTRING(ind2gray)
 
 @DOCSTRING(rgb2ind)
 
 @DOCSTRING(ind2rgb)
 
diff --git a/doc/interpreter/images.awk b/doc/interpreter/images.awk
--- a/doc/interpreter/images.awk
+++ b/doc/interpreter/images.awk
@@ -1,15 +1,14 @@
 BEGIN {
   exts[1] = "eps";
   exts[2] = "pdf";
   exts[3] = "png";
   exts[4] = "txt";
   printf ("IMAGES_SRC =\n");
-  printf ("HTMLDIR_IMAGES =\n");
   for (i = 1; i <= 4; i++) {
     printf ("IMAGES_%s =\n", toupper (exts[i]));
   }
 } {
   script = $1;
   basename = script;
   sub (/\.m$/, "", basename);
   ubasename = toupper (basename);
@@ -20,26 +19,15 @@ BEGIN {
 
     printf ("%s_%s =", ubasename, uext);
     for (j = 2; j <= NF; j++)
       printf (" %s.%s", $j, ext);
     printf ("\n");
 
     printf ("IMAGES_%s += $(%s_%s)\n", uext, ubasename, uext);
 
-    if (ext == "png") {
-      printf ("HTMLDIR_IMAGES += ");
-      for (j = 2; j <= NF; j++)
-        printf (" octave.html/%s.png", $j);
-      printf ("\n");
-    }
-
     for (j = 2; j <= NF; j++) {
-      if (ext == "png") {
-	printf ("octave.html/%s.png: %s.png octave.html\n", $j, $j);
-	printf ("\tcp $< $@\n");
-      }
       printf ("%s.%s: %s\n", $j, ext, script);
       printf ("\t$(top_builddir)/run-octave -f -q -H -p $(srcdir) --eval \"%s ('%s', '%s');\"\n",
 	      basename, $j, ext);
     }
   }
 }
diff --git a/doc/interpreter/install.txi b/doc/interpreter/install.txi
--- a/doc/interpreter/install.txi
+++ b/doc/interpreter/install.txi
@@ -279,17 +279,17 @@ provide improved performance for the fun
 Source code highlighter and manipulator; a Qt  port of Scintilla
 (@url{http://www.riverbankcomputing.co.uk/software/qscintilla}).
 QScintilla is used for syntax highlighting and code completion in the
 GUI.
 
 @item Qt
 GUI and utility libraries (@url{}). Qt is required for building the GUI.
 It is a large framework, but the only components required are the GUI,
-core, Webkit, and network modules.
+core, WebKit, and network modules.
 
 @item SuiteSparse
 Sparse matrix factorization library
 (@url{http://www.cise.ufl.edu/research/sparse/SuiteSparse}).
 SuiteSparse is required to provide sparse matrix factorizations and
 solution of linear equations for sparse systems.
 
 @item zlib
@@ -534,17 +534,17 @@ the following directories.  In the table
 of the interpreter, and @var{arch} is the type of computer on which
 Octave is installed (for example, @samp{i586-unknown-gnu}).
 
 @table @file
 @item @var{prefix}/bin
 Octave and other binaries that people will want to run directly.
 
 @item @var{prefix}/lib/octave-@var{version}
-Libraries like libcruft.a and liboctave.a.
+Libraries like liboctave.a and liboctinterp.a.
 
 @item @var{prefix}/octave-@var{version}/include/octave
 Include files distributed with Octave.
 
 @item @var{prefix}/share
 Architecture-independent data files.
 
 @item @var{prefix}/share/man/man1
@@ -791,22 +791,22 @@ Octave's 64-bit index support is activat
 ./configure \
   LD_LIBRARY_PATH="$prefix64/lib" \
   CPPFLAGS="-I$prefix64/include" LDFLAGS="-L$prefix64/lib" \
   --enable-64
 @end group
 @end example
 
 You must ensure that all Fortran sources except those in the
-@file{libcruft/ranlib} directory are compiled such that INTEGERS are
-8-bytes wide.  If you are using gfortan, the configure script should
+@file{liboctave/cruft/ranlib} directory are compiled such that INTEGERS are
+8-bytes wide.  If you are using gfortran, the configure script should
 automatically set the Makefile variable @w{@env{F77_INTEGER_8_FLAG}} to 
 @option{-fdefault-integer-8}.  If you are using another compiler, you
 must set this variable yourself.  You should NOT set this flag in
-@env{FFLAGS}, otherwise the files in @file{libcruft/ranlib} will be
+@env{FFLAGS}, otherwise the files in @file{liboctave/cruft/ranlib} will be
 miscompiled.
 
 @item Other dependencies
 
 Probably nothing special needs to be done for the following
 dependencies.  If you discover that something does need to be done,
 please submit a bug report.
 
@@ -971,17 +971,17 @@ warning: unexpected parent of complex ex
 zgemm.f, line 327: warning: unexpected parent of complex
   expression subtree
 pcc_binval: missing IR_CONV in complex op
 make[2]: *** [zgemm.o] Error 1
 @end group
 @end example
 
 @noindent
-when compiling the Fortran subroutines in the @file{libcruft}
+when compiling the Fortran subroutines in the @file{liboctave/cruft}
 subdirectory, you should either upgrade your compiler or try compiling
 with optimization turned off.
 
 @item
 On NeXT systems, if you get errors like this:
 
 @example
 @group
diff --git a/doc/interpreter/intro.txi b/doc/interpreter/intro.txi
--- a/doc/interpreter/intro.txi
+++ b/doc/interpreter/intro.txi
@@ -519,17 +519,17 @@ printf ("foo %s\n", "bar")
 
 Some examples signal errors.  This normally displays an error message
 on your terminal.  Error messages are shown on a line beginning with
 @code{error:}.
 
 @example
 @group
 fieldnames ([1, 2; 3, 4])
-error: fieldnames: wrong type argument `matrix'
+error: fieldnames: wrong type argument 'matrix'
 @end group
 @end example
 
 @node Format of Descriptions
 @subsection Format of Descriptions
 @cindex description format
 
 Functions, commands, and variables are described in this manual in a 
diff --git a/doc/interpreter/io.txi b/doc/interpreter/io.txi
--- a/doc/interpreter/io.txi
+++ b/doc/interpreter/io.txi
@@ -225,16 +225,21 @@ separated lists.
 @DOCSTRING(csvread)
 
 Formatted data from can be read from, or written to, text files as well.
 
 @DOCSTRING(textread)
 
 @DOCSTRING(textscan)
 
+The @code{importdata} function has the ability to work with a wide
+variety of data.
+
+@DOCSTRING(importdata)
+
 @menu
 * Saving Data on Unexpected Exits::
 @end menu
 
 @node Saving Data on Unexpected Exits
 @subsubsection Saving Data on Unexpected Exits
 
 If Octave for some reason exits unexpectedly it will by default save the
@@ -403,27 +408,27 @@ output stream as-is, while @dfn{conversi
 a @samp{%} character in the template cause subsequent arguments to be
 formatted and written to the output stream.  For example,
 @cindex conversion specifications (@code{printf})
 
 @example
 @group
 pct = 37;
 filename = "foo.txt";
-printf ("Processed %d%% of `%s'.\nPlease be patient.\n",
+printf ("Processed %d%% of '%s'.\nPlease be patient.\n",
         pct, filename);
 @end group
 @end example
 
 @noindent
 produces output like
 
 @example
 @group
-Processed 37% of `foo.txt'.
+Processed 37% of 'foo.txt'.
 Please be patient.
 @end group
 @end example
 
 This example shows the use of the @samp{%d} conversion to specify that a
 scalar argument should be printed in decimal notation, the @samp{%s}
 conversion to specify printing of a string argument, and the @samp{%%}
 conversion to print a literal @samp{%} character.
@@ -693,17 +698,17 @@ The @samp{%g} and @samp{%G} conversions 
 of @samp{%e} or @samp{%E} (respectively) if the exponent would be less
 than -4 or greater than or equal to the precision; otherwise they use the
 @samp{%f} style.  Trailing zeros are removed from the fractional portion
 of the result and a decimal-point character appears only if it is
 followed by a digit.
 
 The following flags can be used to modify the behavior:
 
-@c Not @samp so we can have ` ' as an item.
+@c Not @samp so we can have ' ' as an item.
 @table @asis
 @item @samp{-}
 Left-justify the result in the field.  Normally the result is
 right-justified.
 
 @item @samp{+}
 Always include a plus or minus sign in the result.
 
diff --git a/doc/interpreter/mk_doc_cache.m b/doc/interpreter/mk_doc_cache.m
--- a/doc/interpreter/mk_doc_cache.m
+++ b/doc/interpreter/mk_doc_cache.m
@@ -116,9 +116,10 @@ for i = 2:n
   cache{1,k} = symbol;
   cache{2,k} = doc;
   cache{3,k} = first_sentence;
   k++;
 endfor
 
 cache(:,k:end) = [];    # delete unused pre-allocated entries
 
+save_header_format_string (["# doc-cache created by Octave " OCTAVE_VERSION ", %a %b %d %H:%M:%S %Y %Z"]);
 save ("-text", output_file, "cache");
diff --git a/doc/interpreter/mkoctfile.1 b/doc/interpreter/mkoctfile.1
--- a/doc/interpreter/mkoctfile.1
+++ b/doc/interpreter/mkoctfile.1
@@ -99,29 +99,29 @@ Print configuration variable \fIVAR\fP. 
     ALL_CXXFLAGS              FLIBS
     ALL_FFLAGS                FPICFLAG
     ALL_LDFLAGS               INCFLAGS
     BLAS_LIBS                 LAPACK_LIBS
     CC                        LDFLAGS
     CFLAGS                    LD_CXX
     CPICFLAG                  LD_STATIC_FLAG
     CPPFLAGS                  LFLAGS
-    CXX                       LIBCRUFT
-    CXXFLAGS                  LIBOCTAVE
-    CXXPICFLAG                LIBOCTINTERP
-    DEPEND_EXTRA_SED_PATTERN  LIBS
-    DEPEND_FLAGS              OCTAVE_LIBS
-    DL_LD                     OCTAVE_LINK_DEPS
-    DL_LDFLAGS                OCT_LINK_DEPS
-    EXEEXT                    RDYNAMIC_FLAG
-    F77                       READLINE_LIBS
-    F77_INTEGER_8_FLAG        SED
-    FFLAGS                    XTRA_CFLAGS
-    FFTW3_LDFLAGS             XTRA_CXXFLAGS
-    FFTW3_LIBS
+    CXX                       LIBOCTAVE
+    CXXFLAGS                  LIBOCTINTERP    
+    CXXPICFLAG                LIBS            
+    DEPEND_EXTRA_SED_PATTERN  OCTAVE_LIBS     
+    DEPEND_FLAGS              OCTAVE_LINK_DEPS
+    DL_LD                     OCT_LINK_DEPS   
+    DL_LDFLAGS                RDYNAMIC_FLAG   
+    EXEEXT                    READLINE_LIBS   
+    F77                       SED             
+    F77_INTEGER_8_FLAG        XTRA_CFLAGS     
+    FFLAGS                    XTRA_CXXFLAGS   
+    FFTW3_LDFLAGS                             
+    FFTW3_LIBS                                
     FFTW3F_LDFLAGS
 .Ve
 .RE
 .TP
 .B \-v\fR,\fB --verbose
 Echo commands as they are executed.
 .TP
 .B file
diff --git a/doc/interpreter/octave.1 b/doc/interpreter/octave.1
--- a/doc/interpreter/octave.1
+++ b/doc/interpreter/octave.1
@@ -20,17 +20,17 @@
 .ft CW
 .nf
 ..
 .de Ve \" (V)erbatim (e)nd.  Return to regular font and justification
 .ft R
 .fi
 ..
 .\" --------------------------------------------------------------------
-.TH OCTAVE 1 "4 February 2011" "GNU Octave"
+.TH OCTAVE 1 "19 October 2012" "GNU Octave"
 .SH NAME
 octave \- A high-level interactive language for numerical computations.
 .SH SYNOPSIS
 \fBoctave\fP [\fIoptions\fP]... [\fIfile\fP]
 .SH DESCRIPTION
 Octave is a high-level language, primarily intended for numerical
 computations.  It provides a convenient command line interface for
 solving linear and nonlinear problems numerically.
@@ -39,19 +39,19 @@ The complete set of command-line options
 running the following command from the shell.
 .Vb
 
     octave \-\-help
 .Ve
 .SH DOCUMENTATION
 The primary documentation for Octave is written using Texinfo, the GNU
 documentation system, which allows the same source files to be used to
-produce on-line and printed versions of the manual.
+produce online and printed versions of the manual.
 .PP
-You can read the on-line copy of the Octave documentation by issuing
+You can read the online copy of the Octave documentation by issuing
 the following command from within \fBoctave\fP.
 .Vb
 
     octave:1> doc
 
 .Ve
 The Info files may also be read with a stand-alone program such as
 \fBinfo\fP or \fBxinfo\fP.  HTML, Postscript, or PDF versions of the
diff --git a/doc/interpreter/oop.txi b/doc/interpreter/oop.txi
--- a/doc/interpreter/oop.txi
+++ b/doc/interpreter/oop.txi
@@ -490,16 +490,23 @@ in the use of methods of other classes w
 @cindex quotient
 @cindex relational operators
 @cindex subtraction
 @cindex tests for equality
 @cindex transpose
 @cindex transpose, complex-conjugate
 @cindex unary minus
 
+@c Need at least one plaintext sentence here between the @node and @float
+@c table below or the two will overlap due to a bug in Texinfo. 
+@c This is not our fault; this *is* a ridiculous kluge.
+The following table shows, for each built-in numerical operation, the
+corresponding function name to use when providing an overloaded method for a
+user class.
+
 @float Table,tab:overload_ops
 @opindex +
 @opindex -
 @opindex .*
 @opindex *
 @opindex ./
 @opindex /
 @opindex .\
diff --git a/doc/interpreter/package.txi b/doc/interpreter/package.txi
--- a/doc/interpreter/package.txi
+++ b/doc/interpreter/package.txi
@@ -19,17 +19,17 @@
 @node Packages
 @chapter Packages
 
 Since Octave is Free Software users are encouraged to share their
 programs amongst each other.  To aid this sharing Octave supports the
 installation of extra packages.  The `Octave-Forge' project is a
 community-maintained set of packages that can be downloaded and
 installed in Octave.  At the time of writing the `Octave-Forge' project
-can be found on-line at @uref{http://octave.sourceforge.net}, but
+can be found online at @uref{http://octave.sourceforge.net}, but
 since the Internet is an ever-changing place this may not be true at
 the time of reading.  Therefore it is recommended to see the Octave
 website for an updated reference.
 
 @menu
 * Installing and Removing Packages::  
 * Using Packages::              
 * Administrating Packages::     
@@ -206,16 +206,17 @@ automatically from the functions in the 
 @item package/NEWS
 This is an optional file describing all user-visible changes worth
 mentioning.  As this file increases on size, old entries can be moved
 into @file{package/ONEWS}.
 
 @item package/ONEWS
 This is an optional file describing old entries from the @file{NEWS} file.
 
+@cindex PKG_ADD
 @anchor{doc-PKG_ADD}
 @item package/PKG_ADD
 An optional file that includes commands that are run when the package
 is added to the users path.  Note that @w{@code{PKG_ADD}} directives in the
 source code of the package will also be added to this file by the
 Octave package manager.  Note that symbolic links are to be avoided in
 packages, as symbolic links do not exist on some file systems, and so
 a typical use for this file is the replacement of the symbolic link
@@ -230,16 +231,18 @@ with an autoload directive like
 @example
 autoload ('bar', which ('foo'));
 @end example
 
 @noindent
 @xref{PKG_ADD and PKG_DEL Directives}, for details on @w{@code{PKG_ADD}}
 directives.
 
+@cindex PKG_DEL
+@anchor{doc-PKG_DEL}
 @item package/PKG_DEL
 An optional file that includes commands that are run when the package
 is removed from the users path.  Note that @w{@code{PKG_DEL}} directives in
 the source code of the package will also be added to this file by the
 Octave package manager. 
 @xref{PKG_ADD and PKG_DEL Directives}, for details on @w{@code{PKG_DEL}}
 directives.
 
diff --git a/doc/liboctave/Makefile.am b/doc/liboctave/Makefile.am
--- a/doc/liboctave/Makefile.am
+++ b/doc/liboctave/Makefile.am
@@ -1,9 +1,9 @@
-# Makefile for octave's doc/liboctave directory
+# Makefile for Octave's doc/liboctave directory
 #
 # Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
 #               2005, 2006, 2007 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
@@ -16,20 +16,16 @@
 # for more details.
 # 
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
-## Automake generated rules for documentation are not parallel-safe.
-## Restrict current directory to run serially
-.NOTPARALLEL:
-
 TEXINFO_TEX = ../texinfo.tex
 
 info_TEXINFOS = liboctave.texi
 
 liboctave_TEXINFOS = \
   array.texi \
   bugs.texi \
   cp-idx.texi \
@@ -47,12 +43,18 @@ liboctave_TEXINFOS = \
   ode.texi \
   optim.texi \
   preface.texi \
   quad.texi \
   range.texi
 
 all-local: dvi html pdf ps
 
-liboctave.info liboctave.dvi liboctave.html liboctave.pdf: $(srcdir)/version.texi
+## The texi2dvi script (used to create both PDF and DVI output formats)
+## uses some fixed temporary file names.  In order to avoid a race condition
+## the DVI and PDF builds are forced to run serially through a Makefile rule.
+liboctave.pdf: liboctave.dvi
 
 EXTRA_DIST = liboctave.dvi liboctave.html liboctave.pdf liboctave.ps
 
+clean-local:
+	rm -rf t2d_cache
+
diff --git a/doc/refcard/Makefile.am b/doc/refcard/Makefile.am
--- a/doc/refcard/Makefile.am
+++ b/doc/refcard/Makefile.am
@@ -1,9 +1,9 @@
-# Makefile for octave's doc/refcard directory
+# Makefile for Octave's doc/refcard directory
 #
 # Copyright (C) 1996-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
diff --git a/etc/HACKING b/etc/HACKING
--- a/etc/HACKING
+++ b/etc/HACKING
@@ -36,21 +36,21 @@ Later, after synchronizing from the repo
 be sufficient.
 
 ** First clone
 
 If you are reading these notes, you may have already managed to clone
 this package from the repository.  For the record, you will find all the
 relevant information on downloading sources at:
 
-  http://www.gnu.org/software/octave/download.html
+  http://www.octave.org/download.html
 
-After cloning Octave, you will need to run the autogen.sh script:
+After cloning Octave, you will need to run the bootstrap script:
 
-  $ ./autogen.sh
+  $ ./bootstrap
 
 This script will examine the source tree and generate some Makefile
 fragments and then runs the bootstrap script.  The bootstrap script comes
 from gnulib, but is kept in the Octave source archive.  It should be
 updated from the gnulib sources as necssary.  The bootstrap script takes
 care of running the autotools and generating the configure script.
 
 If you have a copy of gnulib in some directory apart from the Octave
@@ -65,20 +65,20 @@ manager, DIRNAME is likely to be /usr/bi
 gnulib-tool script resides).
 
 By using an external gnulib directory, you can share a single gnulib source
 tree among several projects.  Since 2011, the gnulib sources are a Mercurial
 subrepository, so they will be automatically updated to the
 corresponding Mercurial revision if you update the working directory to
 a past revision not too far in the past.
 
-Additional options besides --gnulib-srcdir can be passed to autogen.sh and
-they will be forwarded without modification to the bootstrap script.
+Additional options besides --gnulib-srcdir can be passed to bootstrap and
+they will be forwarded without modification to the gnulib bootstrap script.
 
-Once the autogen.sh and bootstrap scripts complete successfully, you may
+Once the bootstrap and bootstrap_gnulib scripts complete successfully, you may
 run
 
   $ ./configure
   $ make
   $ make check
 
 At this point, there should be no difference between your working tree
 and the currently visited hg revision:
@@ -110,62 +110,72 @@ An overview of the directory layout of O
 
 
   gnulib        -- gnulib subrepo.  This is the actual gnulib source
                    tree, checked out with git.
 
 
   libgnu        -- gnulib sources that we use.  The files here are
                    copied here from the gnulib directory by the
-                   build-aux/bootstrap script that is run by the
-                   autogen.sh script.
+                   build-aux/bootstrap_gnulib script that is run by the
+                   bootstrap script.
 
 
-  libcruft      -- various numerical libraries (mostly Fortran)
-
-    amos             bessel functions
+  liboctave     -- C++ interfaces to the numerical libraries, Fortran
+                   numerical libraries, various OS facilities, and utility
+                   functions
 
-    blas-xtra        wrappers for blas functions used in Octave
+    array       the base Array, NDArray, Matrix, and Sparse classes
 
-    daspk            large scale differential algebraic equation solver
+    cruft       various numerical libraries (mostly Fortran)
+
+      amos             bessel functions
 
-    dasrt            differential algebraic equation solver with root finding
+      blas-xtra        wrappers for blas functions used in Octave
 
-    dassl            differential-algebraic system solver
+      daspk            large scale differential algebraic equation solver
+
+      dasrt            differential algebraic equation solver with root finding
 
-    fftpack          subroutines for fast fourier transforms
+      dassl            differential-algebraic system solver
 
-    lapack-xtra      wrappers for lapack functions used in Octave
+      fftpack          subroutines for fast fourier transforms
+
+      lapack-xtra      wrappers for lapack functions used in Octave
 
-    misc             miscellaneous utilities
+      misc             miscellaneous utilities
 
-    odepack          ordinary differential equation solver
+      odepack          ordinary differential equation solver
 
-    ordered-qz       code for ordering eigenvalues for QZ factorization
+      ordered-qz       code for ordering eigenvalues for QZ factorization
 
-    quadpack         subroutines for numerical integration
+      quadpack         subroutines for numerical integration
+
+      ranlib           random number generators
 
-    ranlib           random number generators
+      slatec-err       slatec error handling library
 
-    slatec-err       slatec error handling library
+      slatec-fn        various special function subroutines
 
-    slatec-fn        various special function subroutines
-
+    numeric     C++ numerical algorithms and interfaces to the Fortran
+                algorithms
 
-  liboctave     -- The C++ interfaces to the numerical libraries and
-                   various OS facilities.
+    operators   code for operators that act on base classes such as Array
 
+    system      OS-related functions
+ 
+    util        utility and miscellaneous functions
 
   libinterp     -- The interpreter itself plus lots of infrastructure
                    around it.  Octave's extensive octave_value class
                    hierarchy for polymorphically handling all Octave
                    types is defined here.  The built-in functions are
                    also defined here.
 
-    octave-value     the octave_value class hierarchy.  These are the
+    octave-value     The octave_value class hierarchy.  These are the
                      container classes that hold various Octave data
                      types like struct numerical arrays, structure
                      arrays, and cell arrays.
 
     parse-tree       Classes that define the parse tree for the
                      interpreter.
 
     interp-core      Core utilities for the interpreter.  There are no
diff --git a/etc/PROJECTS b/etc/PROJECTS
--- a/etc/PROJECTS
+++ b/etc/PROJECTS
@@ -1,11 +1,11 @@
 Octave PROJECTS
 ===============
 
 A list of proposed projects is maintained at: 
              
-             http://wiki.octave.org/wiki.pl?Projects
+             http://wiki.octave.org/Projects
 
 If you start working steadily on a project, please let
 maintainers@octave.org know.  We might have information that could help
 you.  You should also read the Contributing Guidelines chapter in the
 Octave manual.
diff --git a/etc/README.MacOS b/etc/README.MacOS
--- a/etc/README.MacOS
+++ b/etc/README.MacOS
@@ -26,17 +26,17 @@ Development snapshots, intended for test
 below.
 
   ftp://alpha.gnu.org/gnu/octave
 
 Links to the stable releases, snap shots, and instructions for obtaining
 the current development sources using mercurial can be found on Octave's 
 web-site below.
 
-  http://www.gnu.org/software/octave/download.html
+  http://www.octave.org/download.html
 
 Building on MacOS can vary significantly between versions.  These
 instructions document the procedure for MacOS 10.6.X.
 
 
 2.1 Developer's Tools
 ---------------------
 
@@ -72,17 +72,17 @@ as well.  However, care must be taken.
       Date: April 11, 2010 at 12:04 AM
 
 
 2.2 Manual Package Management
 -----------------------------
 
 Instructions for building Octave are available on the web at the link below.
 
-    http://wiki.octave.org/wiki.pl?BuildFromSource
+    http://wiki.octave.org/Build_from_source
 
 In addition, those wishing to build on MacOS X (10.6.x) should read section
 2.1 above.
 
 2.2.1 Critical Dependencies
 ---------------------------
 
 The minimal dependencies needed to build Octave's snap-shots are listed below.
@@ -138,17 +138,17 @@ A fully functional Octave requires addit
       sudo make install
       make clean
       ./configure --enable-float --disable-dependency-tracking
       make
       sudo make install
 
 See the link below for additional details about optional dependencies.
 
-    http://wiki.octave.org/wiki.pl?BuildFromSource
+    http://wiki.octave.org/Build_from_source
 
 TODO - Modify the configure script to test for 64 bit vecLib bug.  When the bug
        is present, apply the wrapper solution.
 
 
 2.2.2 Building Octave as a 32-bit Application
 --------------------------------------------
 
@@ -265,18 +265,18 @@ be installed.
 
 
 2.3.2 Building With Dependencies Satisfied by Fink
 --------------------------------------------------
 
 After installing each of the dependencies, the sources are compiled by
 setting the proper environment variables and then following the standard build
 sequence.  The following is an example set of variables for a 32-bit build
-using gcc-4.2.  When building from the sources obtained from the mercurial
-archive, ./autogen.sh must be run prior to ./configure.
+using gcc-4.2.  When building from the sources obtained from the Mercurial
+archive, ./bootstrap must be run prior to ./configure.
 
   export FINK_PREFIX="/sw"
   export PREFIX="/usr/local/bin"
 
   export OPTFLAGS="-O2 -g"
   export LDFLAGS="-L$FINK_PREFIX/lib -L/usr/lib -m32"
   export CFLAGS="-I$FINK_PREFIX/include $OPTFLAGS -m32"
   export CXXFLAGS=$CFLAGS
@@ -380,17 +380,17 @@ Now uninstall the Octave port.
 This will remove Octave and leave its dependencies in place. Some additional
 dependencies may be needed.
 
   sudo port install epstools epstoedit transfig
 
 Octave may now be built from a local mercurial archive by typing the commands
 below (these assume gcc-4.4 is installed by macports).
 
-  ./autogen.sh
+  ./bootstrap
   export PREFIX=/opt/local
   export CC=/opt/local/bin/gcc-mp-4.4
   export CXX=/opt/local/bin/g++-mp-4.4
   export CXXCPP="/opt/local/bin/g++-mp-4.4 -E"
   export F77=/opt/local/bin/gfortran-mp-4.4
   export FC=/opt/local/bin/gfortran-mp-4.4
   export CXXFLAGS="-pipe -O2 -m64"
   export FFLAGS="$CXXFLAGS -D_THREAD_SAFE -pthread"
diff --git a/etc/README.MinGW b/etc/README.MinGW
--- a/etc/README.MinGW
+++ b/etc/README.MinGW
@@ -68,17 +68,17 @@ Additional information beyond the tutori
 
   Please read Howto.txt carefully on how to build them.  The Howto.txt is old
   so some revisions will be required when using GCC-4.5.0
 
  2.3 Download Octave source
  ----------------------
 
   The source for testing snapshots can be downloaded from the official Octave
-  web site.  http://www.gnu.org/software/octave/download.html 
+  web site.  http://www.octave.org/download.html 
 
   The very latest development code is also available via anonymous access to a
   read-only Mercurial archive.  The method of download is described on the web
   site.  You will also need to install gnulib as another dependency.  Please
   visit http://www.gnu.org/software/gnulib/ and download sources using git.
 
  2.4 Configure and compile source
  ----------------------
@@ -89,17 +89,17 @@ Additional information beyond the tutori
   When using GCC-4.5.0, remove flags for shared libstdc++ because a shared
   build is already the default.
 
   When running './configure', you must add '--enable-float-truncate' option. 
   Please see the following thread for more information: 
   http://thread.gmane.org/gmane.comp.gnu.octave.bugs/12361/focus=12404
 
   To build development sources from the Mercurial repository you must run
-  'autogen.sh' (bootstrap) before running configure and make.  This requires
+  bootstrap before running configure and make.  This requires
   that automake and autoconf tools be installed.
 
 
 Tatsuro MATSUOKA
 tmacchant@yahoo.co.jp
 
 Benjamin Lindner
 bjmldn@gmail.com 
diff --git a/examples/Makefile.am b/examples/Makefile.am
--- a/examples/Makefile.am
+++ b/examples/Makefile.am
@@ -1,9 +1,9 @@
-# Makefile for octave's examples directory
+# Makefile for Octave's examples directory
 #
 # Copyright (C) 1996-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
diff --git a/examples/mysparse.c b/examples/mysparse.c
--- a/examples/mysparse.c
+++ b/examples/mysparse.c
@@ -51,17 +51,17 @@ mexFunction (int nlhs, mxArray *plhs[], 
       for (i = 0; i < n + 1; i++)
         jc2[i] = jc[i];
 
       if (nlhs > 0)
         plhs[0] = v;
     }
   else if (mxIsLogical (prhs[0]))
     {
-      bool *pbr, *pbr2;
+      mxLogical *pbr, *pbr2;
       mexPrintf ("Matrix is %d-by-%d logical",
                  " sparse matrix", m, n);
       mexPrintf (" with %d elements\n", nz);
 
       pbr = mxGetLogicals (prhs[0]);
       ir = mxGetIr (prhs[0]);
       jc = mxGetJc (prhs[0]);
 
diff --git a/libcruft/link-deps.mk b/libcruft/link-deps.mk
deleted file mode 100644
--- a/libcruft/link-deps.mk
+++ /dev/null
@@ -1,30 +0,0 @@
-## The following libraries may be needed to satisfy gnulib dependencies:
-##
-##   $(COPYSIGN_LIBM)
-##   $(FLOOR_LIBM)
-##   $(GETHOSTNAME_LIB)
-##   $(LIBSOCKET)
-##   $(LIB_NANOSLEEP)
-##   $(LTLIBINTL)
-##   $(ROUNDF_LIBM)
-##   $(ROUND_LIBM)
-##   $(TRUNCF_LIBM)
-##   $(TRUNC_LIBM)
-
-LIBCRUFT_LINK_DEPS = \
-  $(COPYSIGN_LIBM) \
-  $(FLOOR_LIBM) \
-  $(GETHOSTNAME_LIB) \
-  $(LIBSOCKET) \
-  $(LIB_NANOSLEEP) \
-  $(LTLIBINTL) \
-  $(ROUNDF_LIBM) \
-  $(ROUND_LIBM) \
-  $(TRUNCF_LIBM) \
-  $(TRUNC_LIBM) \
-  $(LAPACK_LIBS) \
-  $(BLAS_LIBS) \
-  $(FLIBS) \
-  $(LIBS)
-
-LIBCRUFT_LINK_OPTS =
diff --git a/libgnu/Makefile.am b/libgnu/Makefile.am
--- a/libgnu/Makefile.am
+++ b/libgnu/Makefile.am
@@ -16,17 +16,17 @@
 # along with this file.  If not, see <http://www.gnu.org/licenses/>.
 #
 # As a special exception to the GNU General Public License,
 # this file may be distributed as part of a program that
 # contains a configuration script generated by Autoconf, under
 # the same distribution terms as the rest of that program.
 #
 # Generated by gnulib-tool.
-# Reproduce by: gnulib-tool --import --dir=. --local-dir=gl --lib=libgnu --source-base=libgnu --m4-base=m4 --doc-base=doc --tests-base=tests --aux-dir=build-aux --no-conditional-dependencies --libtool --macro-prefix=gl base64 c-strcase closedir copysign copysignf crypto/md5 fclose fcntl fflush filemode fnmatch fopen fseek ftell getcwd gethostname getopt-gnu gettimeofday glob isatty link lstat mkdir mkfifo mkostemp mkstemp mktime nanosleep nproc opendir pathmax progname readdir readlink rename rewinddir rmdir round roundf sigaction signal sigprocmask sleep stat stdint stdio strftime strptime symlink sys_stat sys_time sys_times time times tmpfile trunc truncf unistd unlink vasprintf
+# Reproduce by: gnulib-tool --import --dir=. --local-dir=gl --lib=libgnu --source-base=libgnu --m4-base=m4 --doc-base=doc --tests-base=tests --aux-dir=build-aux --no-conditional-dependencies --libtool --macro-prefix=gl base64 canonicalize chdir close closedir copysign copysignf crypto/md5 dup2 fclose fcntl fflush filemode float floor floorf fnmatch fopen fseek ftell getcwd gethostname getopt-gnu gettimeofday glob isatty link lstat malloc-gnu mkdir mkfifo mkostemp mktime nanosleep nproc open opendir pathmax progname putenv readdir readlink realloc-gnu rename rmdir round roundf select sigaction signal sigprocmask sleep stat stddef stdint stdio strerror strftime strptime symlink sys_stat sys_time sys_times time times tmpfile trunc truncf unistd unlink vasprintf
 
 AUTOMAKE_OPTIONS = 1.5 gnits
 
 SUBDIRS =
 noinst_HEADERS =
 noinst_LIBRARIES =
 noinst_LTLIBRARIES =
 EXTRA_DIST =
@@ -46,16 +46,17 @@ noinst_LTLIBRARIES += libgnu.la
 libgnu_la_SOURCES =
 libgnu_la_LIBADD = $(gl_LTLIBOBJS)
 libgnu_la_DEPENDENCIES = $(gl_LTLIBOBJS)
 EXTRA_libgnu_la_SOURCES =
 libgnu_la_LDFLAGS = $(AM_LDFLAGS)
 libgnu_la_LDFLAGS += -no-undefined
 libgnu_la_LDFLAGS += $(COPYSIGNF_LIBM)
 libgnu_la_LDFLAGS += $(COPYSIGN_LIBM)
+libgnu_la_LDFLAGS += $(FLOORF_LIBM)
 libgnu_la_LDFLAGS += $(FLOOR_LIBM)
 libgnu_la_LDFLAGS += $(GETHOSTNAME_LIB)
 libgnu_la_LDFLAGS += $(LIBSOCKET)
 libgnu_la_LDFLAGS += $(LIB_NANOSLEEP)
 libgnu_la_LDFLAGS += $(LIB_SELECT)
 libgnu_la_LDFLAGS += $(LTLIBINTL)
 libgnu_la_LDFLAGS += $(ROUNDF_LIBM)
 libgnu_la_LDFLAGS += $(ROUND_LIBM)
@@ -91,42 +92,58 @@ alloca.h: $(top_builddir)/config.status
 	rm -f $@
 endif
 MOSTLYCLEANFILES += alloca.h alloca.h-t
 
 EXTRA_DIST += alloca.in.h
 
 ## end   gnulib module alloca-opt
 
+## begin gnulib module areadlink-with-size
+
+libgnu_la_SOURCES += areadlink-with-size.c
+
+EXTRA_DIST += areadlink.h
+
+## end   gnulib module areadlink-with-size
+
 ## begin gnulib module at-internal
 
 
 EXTRA_DIST += openat-priv.h openat-proc.c
 
 EXTRA_libgnu_la_SOURCES += openat-proc.c
 
 ## end   gnulib module at-internal
 
 ## begin gnulib module base64
 
 libgnu_la_SOURCES += base64.h base64.c
 
 ## end   gnulib module base64
 
+## begin gnulib module bitrotate
+
+libgnu_la_SOURCES += bitrotate.h
+
+## end   gnulib module bitrotate
+
 ## begin gnulib module c-ctype
 
 libgnu_la_SOURCES += c-ctype.h c-ctype.c
 
 ## end   gnulib module c-ctype
 
-## begin gnulib module c-strcase
-
-libgnu_la_SOURCES += c-strcase.h c-strcasecmp.c c-strncasecmp.c
-
-## end   gnulib module c-strcase
+## begin gnulib module canonicalize
+
+libgnu_la_SOURCES += canonicalize.c
+
+EXTRA_DIST += canonicalize.h
+
+## end   gnulib module canonicalize
 
 ## begin gnulib module canonicalize-lgpl
 
 
 EXTRA_DIST += canonicalize-lgpl.c
 
 EXTRA_libgnu_la_SOURCES += canonicalize-lgpl.c
 
@@ -289,16 +306,26 @@ EXTRA_DIST += dirent.in.h
 
 
 EXTRA_DIST += dirfd.c
 
 EXTRA_libgnu_la_SOURCES += dirfd.c
 
 ## end   gnulib module dirfd
 
+## begin gnulib module dirname
+
+libgnu_la_SOURCES += dirname.c basename.c
+
+EXTRA_DIST += stripslash.c
+
+EXTRA_libgnu_la_SOURCES += stripslash.c
+
+## end   gnulib module dirname
+
 ## begin gnulib module dirname-lgpl
 
 libgnu_la_SOURCES += dirname-lgpl.c basename-lgpl.c stripslash.c
 
 EXTRA_DIST += dirname.h
 
 ## end   gnulib module dirname-lgpl
 
@@ -461,16 +488,24 @@ EXTRA_libgnu_la_SOURCES += fdopendir.c
 
 
 EXTRA_DIST += fflush.c stdio-impl.h
 
 EXTRA_libgnu_la_SOURCES += fflush.c
 
 ## end   gnulib module fflush
 
+## begin gnulib module file-set
+
+libgnu_la_SOURCES += file-set.c
+
+EXTRA_DIST += file-set.h
+
+## end   gnulib module file-set
+
 ## begin gnulib module filemode
 
 libgnu_la_SOURCES += filemode.c
 
 EXTRA_DIST += filemode.h
 
 ## end   gnulib module filemode
 
@@ -524,16 +559,25 @@ EXTRA_libgnu_la_SOURCES += float.c itold
 
 
 EXTRA_DIST += floor.c
 
 EXTRA_libgnu_la_SOURCES += floor.c
 
 ## end   gnulib module floor
 
+## begin gnulib module floorf
+
+
+EXTRA_DIST += floor.c floorf.c
+
+EXTRA_libgnu_la_SOURCES += floor.c floorf.c
+
+## end   gnulib module floorf
+
 ## begin gnulib module fnmatch
 
 BUILT_SOURCES += $(FNMATCH_H)
 
 # We need the following in order to create <fnmatch.h> when the system
 # doesn't have one that supports the required API.
 if GL_GENERATE_FNMATCH_H
 fnmatch.h: fnmatch.in.h $(top_builddir)/config.status $(ARG_NONNULL_H)
@@ -746,16 +790,38 @@ endif
 MOSTLYCLEANFILES += glob.h glob.h-t
 
 EXTRA_DIST += glob-libc.h glob.c glob.in.h
 
 EXTRA_libgnu_la_SOURCES += glob.c
 
 ## end   gnulib module glob
 
+## begin gnulib module hash
+
+libgnu_la_SOURCES += hash.c
+
+EXTRA_DIST += hash.h
+
+## end   gnulib module hash
+
+## begin gnulib module hash-pjw
+
+libgnu_la_SOURCES += hash-pjw.h hash-pjw.c
+
+## end   gnulib module hash-pjw
+
+## begin gnulib module hash-triple
+
+libgnu_la_SOURCES += hash-triple.c
+
+EXTRA_DIST += hash-triple.h
+
+## end   gnulib module hash-triple
+
 ## begin gnulib module intprops
 
 
 EXTRA_DIST += intprops.h
 
 ## end   gnulib module intprops
 
 ## begin gnulib module isatty
@@ -890,16 +956,25 @@ EXTRA_libgnu_la_SOURCES += lseek.c
 
 
 EXTRA_DIST += lstat.c
 
 EXTRA_libgnu_la_SOURCES += lstat.c
 
 ## end   gnulib module lstat
 
+## begin gnulib module malloc-gnu
+
+
+EXTRA_DIST += malloc.c
+
+EXTRA_libgnu_la_SOURCES += malloc.c
+
+## end   gnulib module malloc-gnu
+
 ## begin gnulib module malloc-posix
 
 
 EXTRA_DIST += malloc.c
 
 EXTRA_libgnu_la_SOURCES += malloc.c
 
 ## end   gnulib module malloc-posix
@@ -1271,25 +1346,16 @@ EXTRA_libgnu_la_SOURCES += mkfifo.c
 
 
 EXTRA_DIST += mkostemp.c
 
 EXTRA_libgnu_la_SOURCES += mkostemp.c
 
 ## end   gnulib module mkostemp
 
-## begin gnulib module mkstemp
-
-
-EXTRA_DIST += mkstemp.c
-
-EXTRA_libgnu_la_SOURCES += mkstemp.c
-
-## end   gnulib module mkstemp
-
 ## begin gnulib module mktime
 
 
 EXTRA_DIST += mktime-internal.h mktime.c
 
 EXTRA_libgnu_la_SOURCES += mktime.c
 
 ## end   gnulib module mktime
@@ -1377,16 +1443,25 @@ EXTRA_DIST += pathmax.h
 ## end   gnulib module pathmax
 
 ## begin gnulib module progname
 
 libgnu_la_SOURCES += progname.h progname.c
 
 ## end   gnulib module progname
 
+## begin gnulib module putenv
+
+
+EXTRA_DIST += putenv.c
+
+EXTRA_libgnu_la_SOURCES += putenv.c
+
+## end   gnulib module putenv
+
 ## begin gnulib module raise
 
 
 EXTRA_DIST += raise.c
 
 EXTRA_libgnu_la_SOURCES += raise.c
 
 ## end   gnulib module raise
@@ -1404,16 +1479,25 @@ EXTRA_libgnu_la_SOURCES += readdir.c
 
 
 EXTRA_DIST += readlink.c
 
 EXTRA_libgnu_la_SOURCES += readlink.c
 
 ## end   gnulib module readlink
 
+## begin gnulib module realloc-gnu
+
+
+EXTRA_DIST += realloc.c
+
+EXTRA_libgnu_la_SOURCES += realloc.c
+
+## end   gnulib module realloc-gnu
+
 ## begin gnulib module realloc-posix
 
 
 EXTRA_DIST += realloc.c
 
 EXTRA_libgnu_la_SOURCES += realloc.c
 
 ## end   gnulib module realloc-posix
@@ -1458,16 +1542,24 @@ EXTRA_libgnu_la_SOURCES += round.c
 
 
 EXTRA_DIST += round.c roundf.c
 
 EXTRA_libgnu_la_SOURCES += round.c roundf.c
 
 ## end   gnulib module roundf
 
+## begin gnulib module same
+
+libgnu_la_SOURCES += same.c
+
+EXTRA_DIST += same.h
+
+## end   gnulib module same
+
 ## begin gnulib module same-inode
 
 
 EXTRA_DIST += same-inode.h
 
 ## end   gnulib module same-inode
 
 ## begin gnulib module save-cwd
@@ -2225,16 +2317,34 @@ strings.h: strings.in.h $(top_builddir)/
 	} > $@-t && \
 	mv $@-t $@
 MOSTLYCLEANFILES += strings.h strings.h-t
 
 EXTRA_DIST += strings.in.h
 
 ## end   gnulib module strings
 
+## begin gnulib module strndup
+
+
+EXTRA_DIST += strndup.c
+
+EXTRA_libgnu_la_SOURCES += strndup.c
+
+## end   gnulib module strndup
+
+## begin gnulib module strnlen
+
+
+EXTRA_DIST += strnlen.c
+
+EXTRA_libgnu_la_SOURCES += strnlen.c
+
+## end   gnulib module strnlen
+
 ## begin gnulib module strnlen1
 
 libgnu_la_SOURCES += strnlen1.h strnlen1.c
 
 ## end   gnulib module strnlen1
 
 ## begin gnulib module strptime
 
@@ -2965,22 +3075,57 @@ wctype.h: wctype.in.h $(top_builddir)/co
 	} > $@-t && \
 	mv $@-t $@
 MOSTLYCLEANFILES += wctype.h wctype.h-t
 
 EXTRA_DIST += wctype.in.h
 
 ## end   gnulib module wctype-h
 
+## begin gnulib module xalloc
+
+libgnu_la_SOURCES += xmalloc.c
+
+EXTRA_DIST += xalloc.h
+
+## end   gnulib module xalloc
+
+## begin gnulib module xalloc-die
+
+libgnu_la_SOURCES += xalloc-die.c
+
+## end   gnulib module xalloc-die
+
+## begin gnulib module xalloc-oversized
+
+
+EXTRA_DIST += xalloc-oversized.h
+
+## end   gnulib module xalloc-oversized
+
+## begin gnulib module xgetcwd
+
+libgnu_la_SOURCES += xgetcwd.c
+
+EXTRA_DIST += xgetcwd.h
+
+## end   gnulib module xgetcwd
+
 ## begin gnulib module xsize
 
 libgnu_la_SOURCES += xsize.h
 
 ## end   gnulib module xsize
 
+## begin gnulib module xstrndup
+
+libgnu_la_SOURCES += xstrndup.h xstrndup.c
+
+## end   gnulib module xstrndup
+
 
 mostlyclean-local: mostlyclean-generic
 	@for dir in '' $(MOSTLYCLEANDIRS); do \
 	  if test -n "$$dir" && test -d $$dir; then \
 	    echo "rmdir $$dir"; rmdir $$dir; \
 	  fi; \
 	done; \
 	:
diff --git a/libgui/Makefile.am b/libgui/Makefile.am
--- a/libgui/Makefile.am
+++ b/libgui/Makefile.am
@@ -1,8 +1,10 @@
+# Makefile for Octave's libgui directory
+#
 # Copyright (C) 2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
@@ -13,13 +15,75 @@
 # for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
-SUBDIRS = src
+AUTOMAKE_OPTIONS = subdir-objects
+
+QT_INCDIR = @QT_INCDIR@
+
+QT_LIBDIR = @QT_LIBDIR@
+
+QT_LIBS = -lQtCore -lQtGui -lQtNetwork -lqscintilla2
+
+QT_LDFLAGS = -L$(QT_LIBDIR)
+
+MOC_CPPFLAGS =
+
+octlib_LTLIBRARIES = liboctgui.la
+
+EXTRA_DIST = default-qt-settings
+
+CLEANFILES =
+
+BUILT_SOURCES =
+
+noinst_HEADERS =
+
+noinst_LTLIBRARIES =
+
+include src/module.mk
+include qterminal-module.mk
+
+## liboctgui merely collects a bunch of compiled convenience libraries.
+## It has no source code itself.
+liboctgui_la_SOURCES = 
+
+include link-deps.mk
+
+# Dummy C++ source to force C++ linking.
+nodist_EXTRA_liboctgui_la_SOURCES = dummy.cc
+
+liboctgui_la_LIBADD = \
+  qterminal/libqterminal.la \
+  src/libgui-src.la \
+  $(top_builddir)/libinterp/liboctinterp.la \
+  $(top_builddir)/liboctave/liboctave.la \
+  $(LIBOCTGUI_LINK_DEPS)
+
+# Increment these as needed and according to the rules in the libtool manual:
+liboctgui_current = 0
+liboctgui_revision = 0
+liboctgui_age = 0
+
+liboctgui_version_info = $(liboctgui_current):$(liboctgui_revision):$(liboctgui_age)
+
+liboctgui_la_LDFLAGS = \
+  -version-info $(liboctgui_version_info) \
+  $(NO_UNDEFINED_LDFLAG) \
+  -bindir $(bindir) \
+  $(LIBOCTGUI_LINK_OPTS)
 
 octetc_DATA = default-qt-settings
 
-EXTRA_DIST = default-qt-settings
+moc-%.cc: %.h
+	@MOC@ -o$@ $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(MOC_CPPFLAGS) $(liboctgui_la_CPPFLAGS) $<
+
+ui-%.h: %.ui
+	@UIC@ -o $@ $<
+
+qrc-%.cc: %.qrc
+	@RCC@ -o $@ $<
+
diff --git a/libgui/src/link-deps.mk b/libgui/link-deps.mk
rename from libgui/src/link-deps.mk
rename to libgui/link-deps.mk
diff --git a/libgui/qterminal-module.mk b/libgui/qterminal-module.mk
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal-module.mk
@@ -0,0 +1,94 @@
+EXTRA_DIST += \
+  qterminal-module.mk
+
+noinst_HEADERS += \
+  qterminal/libqterminal/QTerminal.h \
+  qterminal/libqterminal/QTerminalInterface.h \
+  qterminal/libqterminal/win32/QTerminalColors.h \
+  qterminal/libqterminal/win32/QWinTerminalImpl.h \
+  qterminal/libqterminal/unix/BlockArray.h \
+  qterminal/libqterminal/unix/Character.h \
+  qterminal/libqterminal/unix/CharacterColor.h \
+  qterminal/libqterminal/unix/Emulation.h \
+  qterminal/libqterminal/unix/ExtendedDefaultTranslator.h \
+  qterminal/libqterminal/unix/Filter.h \
+  qterminal/libqterminal/unix/History.h \
+  qterminal/libqterminal/unix/KeyboardTranslator.h \
+  qterminal/libqterminal/unix/konsole_wcwidth.h \
+  qterminal/libqterminal/unix/kpty.h \
+  qterminal/libqterminal/unix/kpty_p.h \
+  qterminal/libqterminal/unix/LineFont.h \
+  qterminal/libqterminal/unix/QUnixTerminalImpl.h \
+  qterminal/libqterminal/unix/Screen.h \
+  qterminal/libqterminal/unix/ScreenWindow.h \
+  qterminal/libqterminal/unix/TerminalCharacterDecoder.h \
+  qterminal/libqterminal/unix/Vt102Emulation.h \
+  qterminal/libqterminal/unix/SelfListener.h \
+  qterminal/libqterminal/unix/TerminalModel.h \
+  qterminal/libqterminal/unix/TerminalView.h
+
+qterminal_libqterminal_la_MOC = \
+  qterminal/libqterminal/moc-QTerminal.cc \
+  qterminal/libqterminal/moc-QTerminalInterface.cc
+
+nodist_qterminal_libqterminal_la_SOURCES = $(qterminal_libqterminal_la_MOC)
+
+qterminal_libqterminal_la_CPPFLAGS = \
+  $(AM_CPPFLAGS) \
+  -I$(QT_INCDIR) \
+  -I$(QT_INCDIR)/QtCore \
+  -I$(QT_INCDIR)/QtGui \
+  -I$(srcdir)/qterminal/libqterminal
+
+qterminal_libqterminal_la_CFLAGS = $(AM_CFLAGS)
+
+qterminal_libqterminal_la_CXXFLAGS = $(AM_CXXFLAGS)
+
+if WIN32_TERMINAL
+
+qterminal_libqterminal_la_SOURCES = \
+  qterminal/libqterminal/win32/QTerminalColors.cpp \
+  qterminal/libqterminal/win32/QWinTerminalImpl.cpp
+
+qterminal_libqterminal_la_MOC += \
+  qterminal/libqterminal/win32/moc-QWinTerminalImpl.cc
+
+qterminal_libqterminal_la_CPPFLAGS += -DUNICODE
+
+# This flag is required to let MOC know about Q_OS_WIN32.
+MOC_CPPFLAGS += -DWIN32
+
+else
+
+qterminal_libqterminal_la_SOURCES = \
+  qterminal/libqterminal/unix/BlockArray.cpp \
+  qterminal/libqterminal/unix/Emulation.cpp \
+  qterminal/libqterminal/unix/Filter.cpp \
+  qterminal/libqterminal/unix/History.cpp \
+  qterminal/libqterminal/unix/KeyboardTranslator.cpp \
+  qterminal/libqterminal/unix/konsole_wcwidth.cpp \
+  qterminal/libqterminal/unix/kpty.cpp \
+  qterminal/libqterminal/unix/QUnixTerminalImpl.cpp \
+  qterminal/libqterminal/unix/Screen.cpp \
+  qterminal/libqterminal/unix/ScreenWindow.cpp \
+  qterminal/libqterminal/unix/TerminalCharacterDecoder.cpp \
+  qterminal/libqterminal/unix/Vt102Emulation.cpp \
+  qterminal/libqterminal/unix/SelfListener.cpp \
+  qterminal/libqterminal/unix/TerminalModel.cpp \
+  qterminal/libqterminal/unix/TerminalView.cpp
+
+qterminal_libqterminal_la_MOC += \
+  qterminal/libqterminal/unix/moc-Emulation.cc \
+  qterminal/libqterminal/unix/moc-Filter.cc \
+  qterminal/libqterminal/unix/moc-QUnixTerminalImpl.cc \
+  qterminal/libqterminal/unix/moc-ScreenWindow.cc \
+  qterminal/libqterminal/unix/moc-SelfListener.cc \
+  qterminal/libqterminal/unix/moc-TerminalModel.cc \
+  qterminal/libqterminal/unix/moc-TerminalView.cc \
+  qterminal/libqterminal/unix/moc-Vt102Emulation.cc
+
+endif
+
+noinst_LTLIBRARIES += qterminal/libqterminal.la
+
+CLEANFILES += $(qterminal_libqterminal_la_MOC)
diff --git a/libgui/src/Makefile.am b/libgui/src/Makefile.am
deleted file mode 100644
--- a/libgui/src/Makefile.am
+++ /dev/null
@@ -1,308 +0,0 @@
-# Copyright (C) 2012 John W. Eaton
-#
-# This file is part of Octave.
-#
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 3 of the License, or (at
-# your option) any later version.
-#
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, see
-# <http://www.gnu.org/licenses/>.
-
-include $(top_srcdir)/build-aux/common.mk
-
-QT_INCDIR = @QT_INCDIR@
-
-QT_LIBDIR = @QT_LIBDIR@
-
-QT_LIBS = -lQtCore -lQtGui -lQtNetwork -lqscintilla2
-
-QT_LDFLAGS = -L$(QT_LIBDIR)
-
-SRCDIRS = \
-  m-editor \
-  qtinfo \
-  octave-adapter \
-  ../qterminal/libqterminal/unix \
-  ../qterminal/libqterminal/win32 \
-  ../qterminal/libqterminal \
-  ../qterminal
-
-octave_gui_MOC = \
-  m-editor/moc-file-editor-interface.cc \
-  m-editor/moc-file-editor-tab.cc \
-  m-editor/moc-file-editor.cc \
-  m-editor/moc-find-dialog.cc \
-  m-editor/moc-lexer-octave-gui.cc \
-  moc-documentation-dockwidget.cc \
-  moc-files-dockwidget.cc \
-  moc-history-dockwidget.cc \
-  moc-main-window.cc \
-  moc-octave-qt-event-listener.cc \
-  moc-settings-dialog.cc \
-  moc-terminal-dockwidget.cc \
-  moc-welcome-wizard.cc \
-  moc-workspace-model.cc \
-  moc-workspace-view.cc \
-  octave-adapter/moc-octave-main-thread.cc \
-  qtinfo/moc-parser.cc \
-  qtinfo/moc-webinfo.cc
-
-octave_gui_UI = \
-  settings-dialog.ui \
-  welcome-wizard.ui
-
-octave_gui_UI_H = $(patsubst %.ui, ui-%.h, $(octave_gui_UI))
-
-octave_gui_RC = qrc-resource.cc
-
-octlib_LTLIBRARIES = liboctgui.la
-
-liboctgui_la_SOURCES = \
-  documentation-dockwidget.cc \
-  files-dockwidget.cc \
-  history-dockwidget.cc \
-  m-editor/file-editor-tab.cc \
-  m-editor/file-editor.cc \
-  m-editor/find-dialog.cc \
-  m-editor/lexer-octave-gui.cc \
-  main-window.cc \
-  octave-adapter/octave-event.cc \
-  octave-adapter/octave-link.cc \
-  octave-adapter/octave-main-thread.cc \
-  octave-gui.cc \
-  octave-qt-event-listener.cc \
-  qtinfo/parser.cc \
-  qtinfo/webinfo.cc \
-  resource-manager.cc \
-  settings-dialog.cc \
-  symbol-information.cc \
-  terminal-dockwidget.cc \
-  welcome-wizard.cc \
-  workspace-model.cc \
-  workspace-view.cc
-
-nodist_liboctgui_la_SOURCES = $(octave_gui_MOC) $(octave_gui_RC)
-
-liboctgui_la_CPPFLAGS = \
-  -I$(QT_INCDIR) \
-  -I$(QT_INCDIR)/QtCore \
-  -I$(QT_INCDIR)/QtGui \
-  -I$(QT_INCDIR)/QtNetwork \
-  -I$(srcdir)/../qterminal/libqterminal \
-  -I$(srcdir)/m-editor \
-  -I$(srcdir)/octave-adapter \
-  -I$(srcdir)/qtinfo \
-  -I$(srcdir)/../../libcruft/misc \
-  -I../../liboctave \
-  -I$(srcdir)/../../liboctave \
-  -I../../libinterp \
-  -I../../libinterp/interp-core \
-  -I../../libinterp/interpfcn \
-  -I../../libinterp/parse-tree \
-  -I$(srcdir)/../../libinterp \
-  -I$(srcdir)/../../libinterp/interp-core \
-  -I$(srcdir)/../../libinterp/interpfcn \
-  -I$(srcdir)/../../libinterp/octave-value \
-  -I$(srcdir)/../../libtinerp/operators \
-  -I$(srcdir)/../../libinterp/parse-tree
-
-include link-deps.mk
-
-liboctgui_la_LIBADD = \
-  libqterminal.la \
-  ../../libinterp/liboctinterp.la \
-  ../../liboctave/liboctave.la \
-  ../../libcruft/libcruft.la \
-  $(LIBOCTGUI_LINK_DEPS)
-
-# Increment these as needed and according to the rules in the libtool manual:
-liboctgui_current = 0
-liboctgui_revision = 0
-liboctgui_age = 0
-
-liboctgui_version_info = $(liboctgui_current):$(liboctgui_revision):$(liboctgui_age)
-
-liboctgui_la_LDFLAGS = \
-  -version-info $(liboctgui_version_info) \
-  $(NO_UNDEFINED_LDFLAG) \
-  -bindir $(bindir) \
-  $(LIBOCTGUI_LINK_OPTS)
-
-noinst_HEADERS = \
-  documentation-dockwidget.h \
-  files-dockwidget.h \
-  history-dockwidget.h \
-  m-editor/file-editor-interface.h \
-  m-editor/file-editor-tab.h \
-  m-editor/file-editor.h \
-  m-editor/find-dialog.h \
-  m-editor/lexer-octave-gui.h \
-  main-window.h \
-  octave-adapter/octave-event-listener.h \
-  octave-adapter/octave-event-observer.h \
-  octave-adapter/octave-event.h \
-  octave-adapter/octave-link.h \
-  octave-adapter/octave-main-thread.h \
-  octave-gui.h \
-  octave-qt-event-listener.h \
-  qtinfo/parser.h \
-  qtinfo/webinfo.h \
-  resource-manager.h \
-  settings-dialog.h \
-  symbol-information.h \
-  terminal-dockwidget.h \
-  welcome-wizard.h \
-  workspace-model.h \
-  workspace-view.h
-
-CLEANFILES = $(octave_gui_MOC) $(octave_gui_UI_H) $(octave_gui_RC)
-
-clean-local:
-	-if test "$(srcdir)" != "."; then \
-	   for d in $(SRCDIRS); do test -d $$d && rmdir $$d; done \
-	 fi
-
-BUILT_SOURCES = $(octave_gui_UI_H)
-
-octave_gui_ICONS = \
-  icons/arrow_right.png \
-  icons/artsbuilderexecute.png \
-  icons/bookmark.png \
-  icons/bp_next.png \
-  icons/bp_prev.png \
-  icons/bp_rm_all.png \
-  icons/bp_toggle.png \
-  icons/chat.png \
-  icons/configure.png \
-  icons/db_cont.png \
-  icons/db_step_in.png \
-  icons/db_step_out.png \
-  icons/db_step.png \
-  icons/db_stop.png \
-  icons/editcopy.png \
-  icons/editcut.png \
-  icons/editpaste.png \
-  icons/filenew.png \
-  icons/fileopen.png \
-  icons/filesaveas.png \
-  icons/filesave.png \
-  icons/find.png \
-  icons/help_index.png \
-  icons/icons_license \
-  icons/jabber_protocol.png \
-  icons/logo.png \
-  icons/question.png \
-  icons/redled.png \
-  icons/redo.png \
-  icons/search.png \
-  icons/star.png \
-  icons/stop.png \
-  icons/terminal.png \
-  icons/undo.png \
-  icons/up.png \
-  icons/zoom-in.png \
-  icons/zoom-out.png
-
-EXTRA_DIST = \
-  $(octave_gui_UI) \
-  $(octave_gui_ICONS) \
-  resource.qrc
-
-noinst_LTLIBRARIES = libqterminal.la
-
-noinst_HEADERS += \
-  ../qterminal/libqterminal/QTerminal.h \
-  ../qterminal/libqterminal/QTerminalInterface.h \
-  ../qterminal/libqterminal/win32/QTerminalColors.h \
-  ../qterminal/libqterminal/win32/QWinTerminalImpl.h \
-  ../qterminal/libqterminal/unix/BlockArray.h \
-  ../qterminal/libqterminal/unix/Character.h \
-  ../qterminal/libqterminal/unix/CharacterColor.h \
-  ../qterminal/libqterminal/unix/Emulation.h \
-  ../qterminal/libqterminal/unix/ExtendedDefaultTranslator.h \
-  ../qterminal/libqterminal/unix/Filter.h \
-  ../qterminal/libqterminal/unix/History.h \
-  ../qterminal/libqterminal/unix/KeyboardTranslator.h \
-  ../qterminal/libqterminal/unix/konsole_wcwidth.h \
-  ../qterminal/libqterminal/unix/kpty.h \
-  ../qterminal/libqterminal/unix/kpty_p.h \
-  ../qterminal/libqterminal/unix/LineFont.h \
-  ../qterminal/libqterminal/unix/QUnixTerminalImpl.h \
-  ../qterminal/libqterminal/unix/Screen.h \
-  ../qterminal/libqterminal/unix/ScreenWindow.h \
-  ../qterminal/libqterminal/unix/TerminalCharacterDecoder.h \
-  ../qterminal/libqterminal/unix/Vt102Emulation.h \
-  ../qterminal/libqterminal/unix/SelfListener.h \
-  ../qterminal/libqterminal/unix/TerminalModel.h \
-  ../qterminal/libqterminal/unix/TerminalView.h
-
-libqterminal_la_CPPFLAGS = \
-  -I$(QT_INCDIR) \
-  -I$(QT_INCDIR)/QtCore \
-  -I$(QT_INCDIR)/QtGui \
-  -I$(srcdir)/../qterminal/libqterminal
-
-libqterminal_la_MOC = \
-  ../qterminal/libqterminal/moc-QTerminal.cc \
-  ../qterminal/libqterminal/moc-QTerminalInterface.cc
-
-nodist_libqterminal_la_SOURCES = $(libqterminal_la_MOC)
-
-if WIN32_TERMINAL
-
-libqterminal_la_SOURCES = \
-  ../qterminal/libqterminal/win32/QTerminalColors.cpp \
-  ../qterminal/libqterminal/win32/QWinTerminalImpl.cpp
-
-libqterminal_la_MOC += ../qterminal/libqterminal/win32/moc-QWinTerminalImpl.cc
-
-else
-
-libqterminal_la_SOURCES = \
-  ../qterminal/libqterminal/unix/BlockArray.cpp \
-  ../qterminal/libqterminal/unix/Emulation.cpp \
-  ../qterminal/libqterminal/unix/Filter.cpp \
-  ../qterminal/libqterminal/unix/History.cpp \
-  ../qterminal/libqterminal/unix/KeyboardTranslator.cpp \
-  ../qterminal/libqterminal/unix/konsole_wcwidth.cpp \
-  ../qterminal/libqterminal/unix/kpty.cpp \
-  ../qterminal/libqterminal/unix/QUnixTerminalImpl.cpp \
-  ../qterminal/libqterminal/unix/Screen.cpp \
-  ../qterminal/libqterminal/unix/ScreenWindow.cpp \
-  ../qterminal/libqterminal/unix/TerminalCharacterDecoder.cpp \
-  ../qterminal/libqterminal/unix/Vt102Emulation.cpp \
-  ../qterminal/libqterminal/unix/SelfListener.cpp \
-  ../qterminal/libqterminal/unix/TerminalModel.cpp \
-  ../qterminal/libqterminal/unix/TerminalView.cpp
-
-libqterminal_la_MOC += \
-  ../qterminal/libqterminal/unix/moc-Emulation.cc \
-  ../qterminal/libqterminal/unix/moc-Filter.cc \
-  ../qterminal/libqterminal/unix/moc-QUnixTerminalImpl.cc \
-  ../qterminal/libqterminal/unix/moc-ScreenWindow.cc \
-  ../qterminal/libqterminal/unix/moc-SelfListener.cc \
-  ../qterminal/libqterminal/unix/moc-TerminalModel.cc \
-  ../qterminal/libqterminal/unix/moc-TerminalView.cc \
-  ../qterminal/libqterminal/unix/moc-Vt102Emulation.cc
-
-endif
-
-moc-%.cc: %.h
-	test -d $(@D) || mkdir -p $(@D)
-	@MOC@ -o$@ $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(liboctgui_la_CPPFLAGS) $<
-
-ui-%.h: %.ui
-	@UIC@ -o $@ $<
-
-qrc-%.cc: %.qrc
-	@RCC@ -o $@ $<
-
-CLEANFILES += $(libqterminal_la_MOC)
diff --git a/libgui/src/documentation-dockwidget.cc b/libgui/src/documentation-dockwidget.cc
--- a/libgui/src/documentation-dockwidget.cc
+++ b/libgui/src/documentation-dockwidget.cc
@@ -15,36 +15,54 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include "documentation-dockwidget.h"
 
-documentation_dock_widget::documentation_dock_widget (QWidget *parent)
-  : QDockWidget (parent)
+documentation_dock_widget::documentation_dock_widget (QWidget *p)
+  : QDockWidget (p)
 {
   setObjectName ("DocumentationDockWidget");
+  setWindowIcon (QIcon(":/actions/icons/logo.png"));
   setWindowTitle (tr ("Documentation"));
 
   connect (this, SIGNAL (visibilityChanged (bool)),
            this, SLOT (handle_visibility_changed (bool)));
+  // topLevelChanged is emitted when floating property changes (floating = true)
+  connect (this, SIGNAL (topLevelChanged(bool)), this, SLOT(top_level_changed(bool)));
 
   _webinfo = new webinfo (this);
   setWidget (_webinfo);
 }
 
 void
 documentation_dock_widget::handle_visibility_changed (bool visible)
 {
   if (visible)
     emit active_changed (true);
 }
 
 void
-documentation_dock_widget::closeEvent (QCloseEvent *event)
+documentation_dock_widget::closeEvent (QCloseEvent *e)
 {
   emit active_changed (false);
-  QDockWidget::closeEvent (event);
+  QDockWidget::closeEvent (e);
 }
+
+// slot for signal that is emitted when floating property changes
+void
+documentation_dock_widget::top_level_changed (bool floating)
+{
+  if(floating)
+    {
+      setWindowFlags(Qt::Window);  // make a window from the widget when floating
+      show();                      // make it visible again since setWindowFlags hides it
+    }
+}
diff --git a/libgui/src/documentation-dockwidget.h b/libgui/src/documentation-dockwidget.h
--- a/libgui/src/documentation-dockwidget.h
+++ b/libgui/src/documentation-dockwidget.h
@@ -25,22 +25,24 @@ along with Octave; see the file COPYING.
 
 #include <QObject>
 #include <QDockWidget>
 #include "webinfo.h"
 
 class documentation_dock_widget : public QDockWidget
 {
   Q_OBJECT
-public:
+  public:
   documentation_dock_widget (QWidget *parent = 0);
 
 public slots:
   /** Slot to steer changing visibility from outside. */
   void handle_visibility_changed (bool visible);
+  /** Slot when floating property changes */
+  void top_level_changed (bool floating);
 
 signals:
   /** Custom signal that tells if a user has clicked away that dock widget. */
   void active_changed (bool active);
 
 protected:
   void closeEvent (QCloseEvent *event);
 
diff --git a/libgui/src/files-dockwidget.cc b/libgui/src/files-dockwidget.cc
--- a/libgui/src/files-dockwidget.cc
+++ b/libgui/src/files-dockwidget.cc
@@ -15,30 +15,36 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include "resource-manager.h"
 #include "files-dockwidget.h"
 
 #include <QApplication>
 #include <QFileInfo>
 #include <QCompleter>
 #include <QSettings>
 #include <QProcess>
 #include <QDebug>
+#include <QHeaderView>
 
-files_dock_widget::files_dock_widget (QWidget *parent)
-  : QDockWidget (parent)
+files_dock_widget::files_dock_widget (QWidget *p)
+  : QDockWidget (p)
 {
   setObjectName ("FilesDockWidget");
+  setWindowIcon (QIcon(":/actions/icons/logo.png"));
   setWindowTitle (tr ("Current Directory"));
   setWidget (new QWidget (this));
 
   // Create a toolbar
   _navigation_tool_bar = new QToolBar ("", widget ());
   _navigation_tool_bar->setAllowedAreas (Qt::TopToolBarArea);
   _navigation_tool_bar->setMovable (false);
   _navigation_tool_bar->setIconSize (QSize (20, 20));
@@ -72,55 +78,75 @@ files_dock_widget::files_dock_widget (QW
   _file_tree_view->setSortingEnabled (true);
   _file_tree_view->setAlternatingRowColors (true);
   _file_tree_view->setAnimated (true);
   _file_tree_view->setColumnHidden (1, true);
   _file_tree_view->setColumnHidden (2, true);
   _file_tree_view->setColumnHidden (3, true);
   _file_tree_view->setStatusTip (tr ("Doubleclick a file to open it."));
 
+  // get sort column and order as well as cloumn state (order and width)
+  QSettings *settings = resource_manager::get_settings ();
+  // FIXME -- what should happen if settings is 0?
+  _file_tree_view->sortByColumn (
+              settings->value ("filesdockwidget/sort_files_by_column",0).toInt (),
+              static_cast<Qt::SortOrder>(settings->value ("filesdockwidget/sort_files_by_order",Qt::AscendingOrder).toUInt ())
+  );
+  _file_tree_view->header ()->restoreState (settings->value ("filesdockwidget/column_state").toByteArray ());
+  
   _current_directory->setText(_file_system_model->fileInfo (rootPathIndex).
-                       absoluteFilePath ());
+                              absoluteFilePath ());
 
   connect (_file_tree_view, SIGNAL (doubleClicked (const QModelIndex &)), this,
            SLOT (item_double_clicked (const QModelIndex &)));
 
   // Layout the widgets vertically with the toolbar on top
-  QVBoxLayout *
-    layout = new QVBoxLayout ();
-  layout->setSpacing (0);
-  layout->addWidget (_navigation_tool_bar);
-  layout->addWidget (_file_tree_view);
-  layout->setMargin (1);
-  widget ()->setLayout (layout);
+  QVBoxLayout *vbox_layout = new QVBoxLayout ();
+  vbox_layout->setSpacing (0);
+  vbox_layout->addWidget (_navigation_tool_bar);
+  vbox_layout->addWidget (_file_tree_view);
+  vbox_layout->setMargin (1);
+  widget ()->setLayout (vbox_layout);
   // TODO: Add right-click contextual menus for copying, pasting, deleting files (and others)
 
   connect (_current_directory, SIGNAL (returnPressed ()),
            this, SLOT (handle_directory_entered ()));
 
   QCompleter *
     completer = new QCompleter (_file_system_model, this);
   _current_directory->setCompleter (completer);
 
   connect (this, SIGNAL (visibilityChanged (bool)),
            this, SLOT (handle_visibility_changed (bool)));
+  // topLevelChanged is emitted when floating property changes (floating = true)
+  connect (this, SIGNAL (topLevelChanged(bool)), this, SLOT(top_level_changed(bool)));
 
   setFocusProxy (_current_directory);
 }
 
+files_dock_widget::~files_dock_widget ()
+{
+  QSettings *settings = resource_manager::get_settings ();
+  int sort_column = _file_tree_view->header ()->sortIndicatorSection ();
+  Qt::SortOrder sort_order = _file_tree_view->header ()->sortIndicatorOrder ();
+  settings->setValue ("filesdockwidget/sort_files_by_column", sort_column);
+  settings->setValue ("filesdockwidget/sort_files_by_order", sort_order);
+  settings->setValue ("filesdockwidget/column_state", _file_tree_view->header ()->saveState ()); 
+}
+
 void
 files_dock_widget::item_double_clicked (const QModelIndex & index)
 {
   // Retrieve the file info associated with the model index.
   QFileInfo fileInfo = _file_system_model->fileInfo (index);
   display_directory (fileInfo.absoluteFilePath ());
 }
 
 void
-files_dock_widget::set_current_directory (QString currentDirectory)
+files_dock_widget::set_current_directory (const QString& currentDirectory)
 {
   display_directory (currentDirectory);
 }
 
 void
 files_dock_widget::handle_directory_entered ()
 {
   display_directory (_current_directory->text ());
@@ -130,25 +156,25 @@ void
 files_dock_widget::do_up_directory ()
 {
   QDir dir = QDir (_file_system_model->filePath (_file_tree_view->rootIndex ()));
   dir.cdUp ();
   display_directory (dir.absolutePath ());
 }
 
 void
-files_dock_widget::display_directory (QString directory)
+files_dock_widget::display_directory (const QString& directory)
 {
   QFileInfo fileInfo (directory);
   if (fileInfo.exists ())
     {
       if (fileInfo.isDir ())
         {
           _file_tree_view->setRootIndex (_file_system_model->
-                                        index (fileInfo.absoluteFilePath ()));
+                                         index (fileInfo.absoluteFilePath ()));
           _file_system_model->setRootPath (fileInfo.absoluteFilePath ());
           _current_directory->setText (fileInfo.absoluteFilePath ());
 
           if (_last_current_directory != fileInfo.absoluteFilePath ())
             {
               emit displayed_directory_changed (fileInfo.absoluteFilePath ());
             }
 
@@ -181,13 +207,24 @@ files_dock_widget::notice_settings ()
 void
 files_dock_widget::handle_visibility_changed (bool visible)
 {
   if (visible)
     emit active_changed (true);
 }
 
 void
-files_dock_widget::closeEvent (QCloseEvent *event)
+files_dock_widget::closeEvent (QCloseEvent *e)
 {
   emit active_changed (false);
-  QDockWidget::closeEvent (event);
+  QDockWidget::closeEvent (e);
 }
+
+// slot for signal that is emitted when floating property changes
+void
+files_dock_widget::top_level_changed (bool floating)
+{
+  if(floating)
+    {
+      setWindowFlags(Qt::Window);  // make a window from the widget when floating
+      show();                      // make it visible again since setWindowFlags hides it
+    }
+}
diff --git a/libgui/src/files-dockwidget.h b/libgui/src/files-dockwidget.h
--- a/libgui/src/files-dockwidget.h
+++ b/libgui/src/files-dockwidget.h
@@ -34,53 +34,57 @@ along with Octave; see the file COPYING.
 #include <QVBoxLayout>
 #include <QAction>
 #include <QTreeView>
 
 #include <QDockWidget>
 #include <QLineEdit>
 
 /**
-  \class files_dock_widget
-  \brief Dock widget to display files in the current directory.
-  */
+   \class files_dock_widget
+   \brief Dock widget to display files in the current directory.
+*/
 class files_dock_widget : public QDockWidget
 {
   Q_OBJECT
-public:
+  public:
   /** Constructs a new files_dock_widget. */
   files_dock_widget (QWidget *parent = 0);
+  ~files_dock_widget ();
 
 public slots:
   /** Slot for handling a change in directory via double click. */
   void item_double_clicked (const QModelIndex & index);
 
   /** Slot for handling the up-directory button in the toolbar. */
   void do_up_directory ();
 
   /** Sets the current directory being displayed. */
-  void set_current_directory (QString currentDirectory);
+  void set_current_directory (const QString& currentDirectory);
 
   /** Accepts user input a the line edit for the current directory. */
   void handle_directory_entered ();
 
-  void display_directory (QString directory);
+  void display_directory (const QString& directory);
 
   /** Tells the widget to react on changed settings. */
   void notice_settings ();
 
   /** Slot to steer changing visibility from outside. */
   void handle_visibility_changed (bool visible);
 
+  /** Slot when floating property changes */
+  void top_level_changed (bool floating);
+
 signals:
   /** Emitted, whenever the user requested to open a file. */
-  void open_file (QString fileName);
+  void open_file (const QString& fileName);
 
   /** Emitted, whenever the currently displayed directory changed. */
-  void displayed_directory_changed (QString directory);
+  void displayed_directory_changed (const QString& directory);
 
   /** Custom signal that tells if a user has clicke away that dock widget. */
   void active_changed (bool active);
 
 protected:
   void closeEvent (QCloseEvent *event);
 
 private:
diff --git a/libgui/src/history-dockwidget.cc b/libgui/src/history-dockwidget.cc
--- a/libgui/src/history-dockwidget.cc
+++ b/libgui/src/history-dockwidget.cc
@@ -19,138 +19,206 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include <QApplication>
+#include <QClipboard>
 #include <QVBoxLayout>
+#include <QMenu>
+
+#include "error.h"
 
 #include "cmd-hist.h"
 
 #include "history-dockwidget.h"
+#include "octave-link.h"
 
-history_dock_widget::history_dock_widget (QWidget * parent)
-  : QDockWidget (parent), octave_event_observer ()
+history_dock_widget::history_dock_widget (QWidget * p)
+  : QDockWidget (p)
 {
   setObjectName ("HistoryDockWidget");
   construct ();
 }
 
 void
-history_dock_widget::event_accepted (octave_event *e)
-{
-  if (dynamic_cast <octave_update_history_event*> (e))
-    {
-      // Determine the client's (our) history length and the one of the server.
-      int clientHistoryLength = _history_model->rowCount ();
-      int serverHistoryLength = command_history::length ();
-
-      // If were behind the server, iterate through all new entries and add
-      // them to our history.
-      if (clientHistoryLength < serverHistoryLength)
-        {
-          for (int i = clientHistoryLength; i < serverHistoryLength; i++)
-            {
-              _history_model->insertRow (0);
-              _history_model->setData (_history_model->index (0),
-                QString (command_history::get_entry (i).c_str ()));
-            }
-        }
-    }
-
-  // Post a new update event in a given time. This prevents flooding the
-  // event queue.
-  _update_history_model_timer.start ();
-  delete e;
-}
-
-void
-history_dock_widget::event_reject (octave_event *e)
-{
-  delete e;
-}
-
-void
 history_dock_widget::construct ()
 {
   _history_model = new QStringListModel ();
   _sort_filter_proxy_model.setSourceModel (_history_model);
   _history_list_view = new QListView (this);
   _history_list_view->setModel (&_sort_filter_proxy_model);
   _history_list_view->setAlternatingRowColors (true);
   _history_list_view->setEditTriggers (QAbstractItemView::NoEditTriggers);
   _history_list_view->setStatusTip (tr ("Doubleclick a command to transfer it to the terminal."));
+  _history_list_view->setSelectionMode (QAbstractItemView::ExtendedSelection);
+  _history_list_view->setContextMenuPolicy(Qt::CustomContextMenu);
+  connect(_history_list_view, SIGNAL(customContextMenuRequested(const QPoint &)), this, SLOT(ctxMenu(const QPoint &)));
+
   _filter_line_edit = new QLineEdit (this);
   _filter_line_edit->setStatusTip (tr ("Enter text to filter the command history."));
-  QVBoxLayout *layout = new QVBoxLayout ();
+  QVBoxLayout *vbox_layout = new QVBoxLayout ();
 
+  setWindowIcon (QIcon(":/actions/icons/logo.png"));
   setWindowTitle (tr ("Command History"));
   setWidget (new QWidget ());
 
-  layout->addWidget (_history_list_view);
-  layout->addWidget (_filter_line_edit);
-  layout->setMargin (2);
+  vbox_layout->addWidget (_history_list_view);
+  vbox_layout->addWidget (_filter_line_edit);
+  vbox_layout->setMargin (2);
 
-  widget ()->setLayout (layout);
+  widget ()->setLayout (vbox_layout);
 
   connect (_filter_line_edit,
            SIGNAL (textEdited (QString)),
            &_sort_filter_proxy_model,
            SLOT (setFilterWildcard (QString)));
 
   connect (_history_list_view,
            SIGNAL (doubleClicked (QModelIndex)),
            this,
            SLOT (handle_double_click (QModelIndex)));
 
   connect (this,
            SIGNAL (visibilityChanged (bool)),
            this,
            SLOT (handle_visibility_changed (bool)));
 
+  // topLevelChanged is emitted when floating property changes (floating = true)
+  connect (this, SIGNAL (topLevelChanged(bool)), this, SLOT(top_level_changed(bool)));
+
   _update_history_model_timer.setInterval (200);
   _update_history_model_timer.setSingleShot (true);
 
   connect (&_update_history_model_timer,
            SIGNAL (timeout ()),
            this,
            SLOT (request_history_model_update ()));
 
   _update_history_model_timer.start ();
 
   setFocusProxy (_filter_line_edit);
 }
 
+void history_dock_widget::ctxMenu(const QPoint &pos) {
+    QMenu *menu = new QMenu;
+    menu->addAction(tr("Copy"), this, SLOT(handle_contextmenu_copy(bool)));
+    menu->addAction(tr("Evaluate"), this, SLOT(handle_contextmenu_evaluate(bool)));
+    menu->exec(_history_list_view->mapToGlobal(pos));
+}
+
+void history_dock_widget::handle_contextmenu_copy(bool flag)
+{
+  QString text;
+  QItemSelectionModel *selectionModel = _history_list_view->selectionModel();
+  QModelIndexList rows = selectionModel->selectedRows();
+  QModelIndexList::iterator it;
+  for (it=rows.begin() ; it != rows.end(); it++) {
+    if ((*it).isValid()) {
+      text += (*it).data().toString()+"\n";
+    }
+  }
+  QApplication::clipboard()->setText(text);
+}
+
+void history_dock_widget::handle_contextmenu_evaluate(bool flag)
+{
+  QItemSelectionModel *selectionModel = _history_list_view->selectionModel();
+  QModelIndexList rows = selectionModel->selectedRows();
+  QModelIndexList::iterator it;
+  for (it=rows.begin() ; it != rows.end(); it++) {
+    if ((*it).isValid()) {
+      emit command_double_clicked ((*it).data().toString()+"\n");
+    }
+  }
+}
+
 void
 history_dock_widget::handle_double_click (QModelIndex modelIndex)
 {
-  emit command_double_clicked (modelIndex.data().toString());
+  emit command_double_clicked (modelIndex.data().toString()+"\n");
 }
 
 void
 history_dock_widget::handle_visibility_changed (bool visible)
 {
   if (visible)
     emit active_changed (true);
 }
 
 void
 history_dock_widget::request_history_model_update ()
 {
-  octave_link::instance ()
-      ->post_event (new octave_update_history_event (*this));
+  octave_link::post_event (this, &history_dock_widget::update_history_callback);
 }
 
 void
 history_dock_widget::reset_model ()
 {
   _history_model->setStringList (QStringList ());
 }
 
 void
-history_dock_widget::closeEvent (QCloseEvent *event)
+history_dock_widget::closeEvent (QCloseEvent *e)
 {
   emit active_changed (false);
-  QDockWidget::closeEvent (event);
+  QDockWidget::closeEvent (e);
+}
+
+// slot for signal that is emitted when floating property changes
+void
+history_dock_widget::top_level_changed (bool floating)
+{
+  if(floating)
+    {
+      setWindowFlags(Qt::Window);  // make a window from the widget when floating
+      show();                      // make it visible again since setWindowFlags hides it
+    }
 }
+
+void
+history_dock_widget::update_history_callback (void)
+{
+  static bool scroll_window = false;
+
+  // Determine the client's (our) history length and the one of the server.
+  int clientHistoryLength = _history_model->rowCount ();
+  int serverHistoryLength = command_history::length ();
+
+  // If were behind the server, iterate through all new entries and add
+  // them to our history.
+  if (clientHistoryLength < serverHistoryLength)
+    {
+      int elts_to_add = serverHistoryLength - clientHistoryLength;
+
+      _history_model->insertRows (clientHistoryLength, elts_to_add);
+
+      for (int i = clientHistoryLength; i < serverHistoryLength; i++)
+        {
+          std::string entry = command_history::get_entry (i);
+
+          _history_model->setData (_history_model->index (i),
+                                   QString::fromStdString (entry));
+        }
+
+      // FIXME -- does this behavior make sense?  Calling
+      // _history_list_view->scrollToBottom () here doesn't seem to
+      // have any effect.  Instead, we need to request that action
+      // and wait until the next event occurs in which no items
+      // are added to the history list.
+
+      scroll_window = true;
+    }
+  else if (scroll_window)
+    {
+      scroll_window = false;
+
+      _history_list_view->scrollToBottom ();
+    }
+
+  // Post a new update event in a given time. This prevents flooding the
+  // event queue.
+  _update_history_model_timer.start ();
+}
diff --git a/libgui/src/history-dockwidget.h b/libgui/src/history-dockwidget.h
--- a/libgui/src/history-dockwidget.h
+++ b/libgui/src/history-dockwidget.h
@@ -25,51 +25,52 @@ along with Octave; see the file COPYING.
 
 #include <QDockWidget>
 #include <QLineEdit>
 #include <QListView>
 #include <QSortFilterProxyModel>
 #include <QStringListModel>
 #include <QTimer>
 
-#include "octave-link.h"
-#include "octave-event-observer.h"
-
-class history_dock_widget : public QDockWidget, public octave_event_observer
+class history_dock_widget : public QDockWidget
 {
-Q_OBJECT
-public:
+  Q_OBJECT
+  public:
   history_dock_widget (QWidget *parent = 0);
 
-  void event_accepted (octave_event *e);
-  void event_reject (octave_event *e);
-
 public slots:
   void handle_visibility_changed (bool visible);
   void request_history_model_update ();
   void reset_model ();
+  /** Slot when floating property changes */
+  void top_level_changed (bool floating);
 
 signals:
-  void information (QString message);
+  void information (const QString& message);
 
   /** Emitted, whenever the user double-clicked a command in the history. */
-  void command_double_clicked (QString command);
+  void command_double_clicked (const QString& command);
 
   /** Custom signal that tells if a user has clicked away that dock widget. */
   void active_changed (bool active);
 protected:
   void closeEvent (QCloseEvent *event);
 private slots:
   void handle_double_click (QModelIndex modelIndex);
+  void handle_contextmenu_copy(bool flag);
+  void handle_contextmenu_evaluate(bool flag);
+  void ctxMenu(const QPoint &pos);
 
 private:
   void construct ();
   QListView *_history_list_view;
   QLineEdit *_filter_line_edit;
   QSortFilterProxyModel _sort_filter_proxy_model;
 
   /** Stores the current history_model. */
   QStringListModel *_history_model;
 
   QTimer _update_history_model_timer;
+
+  void update_history_callback (void);
 };
 
 #endif // HISTORYDOCKWIDGET_H
diff --git a/libgui/src/m-editor/file-editor-interface.h b/libgui/src/m-editor/file-editor-interface.h
--- a/libgui/src/m-editor/file-editor-interface.h
+++ b/libgui/src/m-editor/file-editor-interface.h
@@ -30,54 +30,54 @@ along with Octave; see the file COPYING.
 class QTerminal;
 class main_window;
 
 class file_editor_interface : public QDockWidget
 {
   Q_OBJECT
 
   public:
-    file_editor_interface (QTerminal *terminal, main_window *mainWindow)
-      : QDockWidget ((QWidget*)mainWindow) // QDockWidget constructor is explicit, hence the cast.
-    {
-      setObjectName ("FileEditor");
-      _terminal = terminal;
-      _main_window = mainWindow;
+  file_editor_interface (QTerminal *terminal, main_window *mainWindow)
+    : QDockWidget ((QWidget*)mainWindow) // QDockWidget constructor is explicit, hence the cast.
+  {
+    setObjectName ("FileEditor");
+    _terminal = terminal;
+    _main_window = mainWindow;
 
-      connect (this, SIGNAL (visibilityChanged (bool)), this,
-               SLOT (handle_visibility_changed (bool)));
-    }
+    connect (this, SIGNAL (visibilityChanged (bool)), this,
+             SLOT (handle_visibility_changed (bool)));
+  }
 
-    virtual ~file_editor_interface () { }
+  virtual ~file_editor_interface () { }
 
-    virtual QMenu *debug_menu () = 0;
-    virtual QToolBar *toolbar () = 0;
+  virtual QMenu *debug_menu () = 0;
+  virtual QToolBar *toolbar () = 0;
 
-    virtual void handle_entered_debug_mode () = 0;
-    virtual void handle_quit_debug_mode () = 0;
+  virtual void handle_entered_debug_mode () = 0;
+  virtual void handle_quit_debug_mode () = 0;
 
-  public slots:
-    virtual void request_new_file () = 0;
-    virtual void request_open_file () = 0;
-    virtual void request_open_file (QString fileName) = 0;
+public slots:
+  virtual void request_new_file () = 0;
+  virtual void request_open_file () = 0;
+  virtual void request_open_file (const QString& fileName, bool silent = false) = 0;
 
-  signals:
-      void active_changed (bool active);
+signals:
+  void active_changed (bool active);
 
-  protected:
-    QTerminal* _terminal;
-    main_window* _main_window;
+protected:
+  QTerminal* _terminal;
+  main_window* _main_window;
 
-    void closeEvent (QCloseEvent *event)
-    {
-      emit active_changed (false);
-      QDockWidget::closeEvent (event);
-    }
+  void closeEvent (QCloseEvent *e)
+  {
+    emit active_changed (false);
+    QDockWidget::closeEvent (e);
+  }
 
-  protected slots:
-    void handle_visibility_changed (bool visible)
-    {
-      if (visible)
-        emit active_changed (true);
-    }
+protected slots:
+  void handle_visibility_changed (bool visible)
+  {
+    if (visible)
+      emit active_changed (true);
+  }
 };
 
 #endif // FILEEDITORINTERFACE_H
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -15,42 +15,47 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
-#include "file-editor-tab.h"
-#include "file-editor.h"
-#include "find-dialog.h"
-#include "octave-link.h"
-
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
 
 #include <Qsci/qsciapis.h>
 // Not available in the Debian repos yet!
 // #include <Qsci/qscilexeroctave.h>
 #include "lexer-octave-gui.h"
 #include <Qsci/qscilexercpp.h>
 #include <Qsci/qscilexerbash.h>
 #include <Qsci/qscilexerperl.h>
 #include <Qsci/qscilexerbatch.h>
 #include <Qsci/qscilexerdiff.h>
 #include "resource-manager.h"
+#include <QApplication>
+#include <QFileDialog>
 #include <QMessageBox>
+#include <QTextStream>
 #include <QVBoxLayout>
 
+#include "file-editor-tab.h"
+#include "file-editor.h"
+#include "find-dialog.h"
+#include "octave-link.h"
+
+#include "debug.h"
+#include "oct-env.h"
+
 file_editor_tab::file_editor_tab(file_editor *fileEditor)
-  : QWidget ((QWidget*)fileEditor), octave_event_observer ()
+  : QWidget ((QWidget*)fileEditor)
 {
-  QSettings *settings = resource_manager::get_settings ();
-
-  // FIXME -- what should happen if settings is 0?
-
   _file_editor = fileEditor;
   _file_name = "";
   _edit_area = new QsciScintilla (this);
 
   // symbols
   _edit_area->setMarginType (1, QsciScintilla::SymbolMargin);
   _edit_area->setMarginSensitivity (1, true);
   _edit_area->markerDefine (QsciScintilla::RightTriangle, bookmark);
@@ -62,166 +67,121 @@ file_editor_tab::file_editor_tab(file_ed
   connect (_edit_area, SIGNAL (marginClicked (int, int,
                                               Qt::KeyboardModifiers)),
            this, SLOT (handle_margin_clicked (int, int,
                                               Qt::KeyboardModifiers)));
 
   // line numbers
   _edit_area->setMarginsForegroundColor(QColor(96,96,96));
   _edit_area->setMarginsBackgroundColor(QColor(232,232,220));
-  if (settings->value ("editor/showLineNumbers",true).toBool ())
-    {
-      QFont marginFont( settings->value ("editor/fontName","Courier").toString () ,
-                        settings->value ("editor/fontSize",10).toInt () );
-      _edit_area->setMarginsFont( marginFont );
-      QFontMetrics metrics(marginFont);
-      _edit_area->setMarginType (2, QsciScintilla::TextMargin);
-      _edit_area->setMarginWidth(2, metrics.width("9999"));
-      _edit_area->setMarginLineNumbers (2, true);
-    }
+  _edit_area->setMarginType (2, QsciScintilla::TextMargin);
 
   // code folding
   _edit_area->setMarginType (3, QsciScintilla::SymbolMargin);
   _edit_area->setFolding (QsciScintilla::BoxedTreeFoldStyle , 3);
 
+  //highlight current line color
+  _edit_area->setCaretLineBackgroundColor(QColor(245,245,245));
+
   // other features
-  if (settings->value ("editor/highlightCurrentLine",true).toBool ())
-    {
-      _edit_area->setCaretLineVisible(true);
-      _edit_area->setCaretLineBackgroundColor(QColor(245,245,245));
-    }
   _edit_area->setBraceMatching (QsciScintilla::StrictBraceMatch);
   _edit_area->setAutoIndent (true);
   _edit_area->setIndentationWidth (2);
   _edit_area->setIndentationsUseTabs (false);
-  if (settings->value ("editor/codeCompletion",true).toBool ())
-    {
-      _edit_area->autoCompleteFromAll ();
-      _edit_area->setAutoCompletionSource(QsciScintilla::AcsAll);
-      _edit_area->setAutoCompletionThreshold (1);
-    }
+
   _edit_area->setUtf8 (true);
 
-  QVBoxLayout *layout = new QVBoxLayout ();
-  layout->addWidget (_edit_area);
-  layout->setMargin (0);
-  setLayout (layout);
+  // auto completion
+  _edit_area->autoCompleteFromAll ();
+  _edit_area->setAutoCompletionSource(QsciScintilla::AcsAll);
+
+  QVBoxLayout *edit_area_layout = new QVBoxLayout ();
+  edit_area_layout->addWidget (_edit_area);
+  edit_area_layout->setMargin (0);
+  setLayout (edit_area_layout);
 
   // connect modified signal
   connect (_edit_area, SIGNAL (modificationChanged (bool)),
            this, SLOT (update_window_title (bool)));
   connect (_edit_area, SIGNAL (copyAvailable (bool)),
            this, SLOT (handle_copy_available (bool)));
   connect (&_file_system_watcher, SIGNAL (fileChanged (QString)),
            this, SLOT (file_has_changed (QString)));
 
   _file_name = "";
-  update_window_title (false);
+
+  notice_settings ();
 }
 
 bool
 file_editor_tab::copy_available ()
 {
   return _copy_available;
 }
 
 void
-file_editor_tab::event_accepted (octave_event *e)
-{
-  if (dynamic_cast<octave_run_file_event*> (e))
-    {
-      // File was run successfully.
-    }
-
-  if (octave_add_breakpoint_event *abe
-      = dynamic_cast<octave_add_breakpoint_event*> (e))
-    {
-      // TODO: Check file.
-      _edit_area->markerAdd (abe->get_line (), breakpoint);
-    }
-
-  if (octave_remove_breakpoint_event *rbe
-      = dynamic_cast<octave_remove_breakpoint_event*> (e))
-    {
-      // TODO: Check file.
-      _edit_area->markerDelete (rbe->get_line (), breakpoint);
-    }
-
-  if (octave_remove_all_breakpoints_event *rabe
-      = dynamic_cast<octave_remove_all_breakpoints_event*> (e))
-    {
-      Q_UNUSED (rabe);
-      _edit_area->markerDeleteAll (breakpoint);
-    }
-
-  delete e;
-}
-
-void
-file_editor_tab::event_reject (octave_event *e)
-{
-  if (dynamic_cast<octave_run_file_event*> (e))
-    {
-      // Running file failed.
-    }
-  delete e;
-}
-
-void
-file_editor_tab::closeEvent (QCloseEvent *event)
+file_editor_tab::closeEvent (QCloseEvent *e)
 {
   if (_file_editor->get_main_window ()->is_closing ())
     {
       // close whole application: save file or not if modified
       check_file_modified ("Closing Octave", 0); // no cancel possible
-      event->accept ();
+      e->accept ();
     }
   else
     {
       // ignore close event if file is not saved and user cancels
       // closing this window
       if (check_file_modified ("Close File",
                                QMessageBox::Cancel) == QMessageBox::Cancel)
         {
-          event->ignore ();
+          e->ignore ();
         }
       else
         {
-          event->accept();
+          e->accept();
         }
     }
 }
 
 void
-file_editor_tab::set_file_name (QString fileName)
+file_editor_tab::set_file_name (const QString& fileName)
 {
+  if (fileName != UNNAMED_FILE)
+    {
+      // update tracked file if wie really hae a file on disk
+      QStringList trackedFiles = _file_system_watcher.files ();
+      if (!trackedFiles.isEmpty ())
+        _file_system_watcher.removePath (_file_name);
+        _file_system_watcher.addPath (fileName);
+    }
   _file_name = fileName;
+
+  // update lexer after _file_name change
   update_lexer ();
-  update_tracked_file ();
 }
 
 void
 file_editor_tab::handle_margin_clicked(int margin, int line,
                                        Qt::KeyboardModifiers state)
 {
-  Q_UNUSED (state);
   if (margin == 1)
     {
-      unsigned int mask = _edit_area->markersAtLine (line);
+      unsigned int markers_mask = _edit_area->markersAtLine (line);
 
       if (state & Qt::ControlModifier)
         {
-          if (mask && (1 << bookmark))
+          if (markers_mask && (1 << bookmark))
             _edit_area->markerDelete(line,bookmark);
           else
             _edit_area->markerAdd(line,bookmark);
         }
       else
         {
-          if (mask && (1 << breakpoint))
+          if (markers_mask && (1 << breakpoint))
             {
               request_remove_breakpoint (line);
             }
           else
             {
               request_add_breakpoint (line);
             }
         }
@@ -232,51 +192,26 @@ void
 file_editor_tab::update_lexer ()
 {
   QsciLexer *lexer =  _edit_area->lexer ();
   delete lexer;
 
   if (_file_name.endsWith (".m") || _file_name.endsWith (".M"))
     {
       lexer = new lexer_octave_gui ();
-
-      // The API info that is used for auto completion
-      // TODO: Where to store a file with API info (raw or prepared?)?
-      // TODO: Also provide infos on octave-forge functions?
-      // TODO: Also provide infos on function parameters?
-      // By now, use the keywords-list from syntax highlighting
-
-      QsciAPIs *lexer_api = new QsciAPIs (lexer);
-
-      QString keyword;
-      QStringList keywordList;
-
-       // get whole string with all keywords
-      keyword = lexer->keywords (1);
-      // split into single strings
-      keywordList = keyword.split (QRegExp ("\\s+"));
-
-      int i;
-      for (i = 0; i < keywordList.size (); i++)
-        {
-           // add single strings to the API
-          lexer_api->add (keywordList.at (i));
-        }
-      // prepare API info ... this make take some time
-      lexer_api->prepare ();
     }
   else if (_file_name.endsWith (".c")
-        || _file_name.endsWith (".cc")
-        || _file_name.endsWith (".cpp")
-        || _file_name.endsWith (".cxx")
-        || _file_name.endsWith (".c++")
-        || _file_name.endsWith (".h")
-        || _file_name.endsWith (".hh")
-        || _file_name.endsWith (".hpp")
-        || _file_name.endsWith (".h++"))
+           || _file_name.endsWith (".cc")
+           || _file_name.endsWith (".cpp")
+           || _file_name.endsWith (".cxx")
+           || _file_name.endsWith (".c++")
+           || _file_name.endsWith (".h")
+           || _file_name.endsWith (".hh")
+           || _file_name.endsWith (".hpp")
+           || _file_name.endsWith (".h++"))
     {
       lexer = new QsciLexerCPP ();
     }
   else if (_file_name.endsWith (".pl"))
     {
       lexer = new QsciLexerPerl ();
     }
   else if (_file_name.endsWith (".bat"))
@@ -289,24 +224,23 @@ file_editor_tab::update_lexer ()
     }
   else // Default to bash lexer.
     {
       lexer = new QsciLexerBash ();
     }
 
   QSettings *settings = resource_manager::get_settings ();
 
-  // FIXME -- what should happen if settings is 0?
-
   // Editor font (default or from settings)
-  lexer->setDefaultFont (QFont (
-                                settings->value ("editor/fontName",
-                                                 "Courier").toString (),
-                                settings->value ("editor/fontSize",
-                                                 10).toInt ()));
+  if (settings)
+    lexer->setDefaultFont (QFont (
+                                  settings->value ("editor/fontName",
+                                                   "Courier").toString (),
+                                  settings->value ("editor/fontSize",
+                                                   10).toInt ()));
 
   // TODO: Autoindent not working as it should
   lexer->setAutoIndentStyle (QsciScintilla::AiMaintain ||
                              QsciScintilla::AiOpening  ||
                              QsciScintilla::AiClosing);
 
   _edit_area->setLexer (lexer);
 }
@@ -316,38 +250,36 @@ file_editor_tab::request_add_breakpoint 
 {
   QFileInfo file_info (_file_name);
   QString path = file_info.absolutePath ();
   QString function_name = file_info.fileName ();
 
   // We have to cut off the suffix, because octave appends it.
   function_name.chop (file_info.suffix ().length () + 1);
 
-  octave_link::instance ()->post_event
-      (new octave_add_breakpoint_event (*this,
-                                        path.toStdString (),
-                                        function_name.toStdString (),
-                                        line));
+  bp_info info (path, function_name, line);
+
+  octave_link::post_event
+    (this, &file_editor_tab::add_breakpoint_callback, info);
 }
 
 void
 file_editor_tab::request_remove_breakpoint (int line)
 {
   QFileInfo file_info (_file_name);
   QString path = file_info.absolutePath ();
   QString function_name = file_info.fileName ();
 
   // We have to cut off the suffix, because octave appends it.
   function_name.chop (file_info.suffix ().length () + 1);
 
-  octave_link::instance ()->post_event
-      (new octave_remove_breakpoint_event (*this,
-                                           path.toStdString (),
-                                           function_name.toStdString (),
-                                           line));
+  bp_info info (path, function_name, line);
+
+  octave_link::post_event
+    (this, &file_editor_tab::remove_breakpoint_callback, info);
 }
 
 void
 file_editor_tab::comment_selected_text ()
 {
   do_comment_selected_text (true);
 }
 
@@ -412,34 +344,23 @@ file_editor_tab::update_window_title (bo
 
 void
 file_editor_tab::handle_copy_available(bool enableCopy)
 {
   _copy_available = enableCopy;
   emit editor_state_changed ();
 }
 
-void
-file_editor_tab::update_tracked_file ()
-{
-  QStringList trackedFiles = _file_system_watcher.files ();
-  if (!trackedFiles.isEmpty ())
-    _file_system_watcher.removePaths (trackedFiles);
-
-  if (_file_name != UNNAMED_FILE)
-    _file_system_watcher.addPath (_file_name);
-}
-
 int
-file_editor_tab::check_file_modified (QString msg, int cancelButton)
+file_editor_tab::check_file_modified (const QString& msg, int cancelButton)
 {
   int decision = QMessageBox::Yes;
   if (_edit_area->isModified ())
     {
-      // file is modified but not saved, aks user what to do
+      // file is modified but not saved, ask user what to do
       decision = QMessageBox::warning (this,
                                        msg,
                                        tr ("The file %1\n"
                                            "has been modified. Do you want to save the changes?").
                                        arg (_file_name),
                                        QMessageBox::Save,
                                        QMessageBox::Discard, cancelButton );
       if (decision == QMessageBox::Save)
@@ -505,20 +426,20 @@ file_editor_tab::remove_all_breakpoints 
 {
   QFileInfo file_info (_file_name);
   QString path = file_info.absolutePath ();
   QString function_name = file_info.fileName ();
 
   // We have to cut off the suffix, because octave appends it.
   function_name.chop (file_info.suffix ().length () + 1);
 
-  octave_link::instance ()->post_event
-      (new octave_remove_all_breakpoints_event (*this,
-                                                path.toStdString (),
-                                                function_name.toStdString ()));
+  bp_info info (path, function_name, 0);
+
+  octave_link::post_event
+    (this, &file_editor_tab::remove_all_breakpoints_callback, info);
 }
 
 void
 file_editor_tab::toggle_breakpoint ()
 {
   int line, cur;
   _edit_area->getCursorPosition (&line, &cur);
   if ( _edit_area->markersAtLine (line) && (1 << breakpoint) )
@@ -591,66 +512,66 @@ file_editor_tab::set_debugger_position (
 
 void
 file_editor_tab::set_modified (bool modified)
 {
   _edit_area->setModified (modified);
 }
 
 bool
-file_editor_tab::open_file ()
+file_editor_tab::open_file (const QString& dir)
 {
   QString openFileName;
   QFileDialog fileDialog(this);
   fileDialog.setNameFilter(SAVE_FILE_FILTER);
   fileDialog.setAcceptMode(QFileDialog::AcceptOpen);
   fileDialog.setViewMode(QFileDialog::Detail);
+  fileDialog.setDirectory(dir);
   if (fileDialog.exec () == QDialog::Accepted)
     {
       openFileName = fileDialog.selectedFiles().at(0);
       if (openFileName.isEmpty ())
         return false;
 
-      load_file(openFileName);
-      return true;
+      return load_file(openFileName);
     }
   else
     {
       return false;
     }
 }
 
-void
-file_editor_tab::load_file (QString fileName)
+bool
+file_editor_tab::load_file(const QString& fileName, bool silent)
 {
   if (!_file_editor->isVisible ())
     {
       _file_editor->show ();
     }
 
   QFile file (fileName);
   if (!file.open (QFile::ReadOnly))
     {
-      QMessageBox::warning (this, tr ("Octave Editor"),
-                            tr ("Could not open file %1 for read:\n%2.").arg (fileName).
-                            arg (file.errorString ()));
-      return;
+      if (silent==false)
+        QMessageBox::warning (this, tr ("Octave Editor"),
+                              tr ("Could not open file %1 for read:\n%2.").arg (fileName).
+                              arg (file.errorString ()));
+      return false;
     }
 
   QTextStream in (&file);
   QApplication::setOverrideCursor (Qt::WaitCursor);
   _edit_area->setText (in.readAll ());
   QApplication::restoreOverrideCursor ();
 
   set_file_name (fileName);
-  update_tracked_file ();
-
-
   update_window_title (false); // window title (no modification)
   _edit_area->setModified (false); // loaded file is not modified yet
+
+  return true;
 }
 
 void
 file_editor_tab::new_file ()
 {
   if (!_file_editor->isVisible ())
     {
       _file_editor->show ();
@@ -663,67 +584,65 @@ file_editor_tab::new_file ()
 }
 
 bool file_editor_tab::save_file()
 {
   return save_file (_file_name);
 }
 
 bool
-file_editor_tab::save_file (QString saveFileName)
+file_editor_tab::save_file (const QString& saveFileName)
 {
   // it is a new file with the name "<unnamed>" -> call saveFielAs
   if (saveFileName == UNNAMED_FILE || saveFileName.isEmpty ())
     {
       return save_file_as();
     }
 
+  // remove the file to save from the tracker since we will change it on disk now
   QStringList watched_files = _file_system_watcher.files();
   if (!watched_files.isEmpty ())
-    _file_system_watcher.removePaths(watched_files);
-
+    _file_system_watcher.removePath(saveFileName);  
+    
   // open the file for writing
   QFile file (saveFileName);
   if (!file.open (QFile::WriteOnly))
     {
       QMessageBox::warning (this, tr ("Octave Editor"),
                             tr ("Could not open file %1 for write:\n%2.").
                             arg (saveFileName).arg (file.errorString ()));
-      _file_system_watcher.addPaths (watched_files);
       return false;
     }
 
   // save the contents into the file
   QTextStream out (&file);
   QApplication::setOverrideCursor (Qt::WaitCursor);
   out << _edit_area->text ();
   QApplication::restoreOverrideCursor ();
+  file.close();
 
-  // save file name for later use
-  _file_name = saveFileName;
+  // save file name after closing file otherwise tracker will notice file change
+  set_file_name (saveFileName);
   // set the window title to actual file name (not modified)
   update_window_title (false);
-   // files is save -> not modified
+  // files is save -> not modified
   _edit_area->setModified (false);
-  file.close();
 
-  if (!watched_files.isEmpty ())
-    _file_system_watcher.addPaths (watched_files);
   return true;
 }
 
 bool
 file_editor_tab::save_file_as ()
 {
   QString saveFileName(_file_name);
   QFileDialog fileDialog(this);
   if (saveFileName == UNNAMED_FILE || saveFileName.isEmpty ())
     {
       QString directory = QString::fromStdString
-          (octave_link::instance ()->get_last_working_directory ());
+        (octave_link::last_working_directory ());
 
       if (directory.isEmpty ())
         {
           directory = QDir::homePath ();
         }
 
       fileDialog.setDirectory (directory);
     }
@@ -751,71 +670,164 @@ file_editor_tab::save_file_as ()
 void
 file_editor_tab::run_file ()
 {
   if (_edit_area->isModified ())
     save_file(_file_name);
 
   QFileInfo file_info (_file_name);
   QString path = file_info.absolutePath ();
-  //QString current_path = QString::fromStdString
-      (octave_link::instance ()->get_last_working_directory ());
+  QString current_path
+    = QString::fromStdString (octave_link::last_working_directory ());
   QString function_name = file_info.fileName ();
 
   // We have to cut off the suffix, because octave appends it.
   function_name.chop (file_info.suffix ().length () + 1);
   _file_editor->terminal ()->sendText (QString ("cd \'%1\'\n%2\n")
-    .arg(path).arg (function_name));
+                                       .arg(path).arg (function_name));
   // TODO: Sending a run event crashes for long scripts. Find out why.
-  //  octave_link::instance ()
-  //      ->post_event (new octave_run_file_event (*this, _file_name.toStdString ()));
+  // octave_link::post_event
+  //   (this, &file_editor_tab::run_file_callback, _file_name.toStdString ()));
 }
 
 void
-file_editor_tab::file_has_changed (QString fileName)
+file_editor_tab::file_has_changed (const QString&)
 {
-  Q_UNUSED (fileName);
   if (QFile::exists (_file_name))
     {
       // Prevent popping up multiple message boxes when the file has
       // been changed multiple times.
       static bool alreadyAsking = false;
       if (!alreadyAsking)
         {
           alreadyAsking = true;
 
           int decision =
-          QMessageBox::warning (this, tr ("Octave Editor"),
-                                tr ("It seems that \'%1\' has been modified by another application. Do you want to reload it?").
-                                arg (_file_name), QMessageBox::Yes,
-                                QMessageBox::No);
+            QMessageBox::warning (this, tr ("Octave Editor"),
+                                  tr ("It seems that \'%1\' has been modified by another application. Do you want to reload it?").
+                                  arg (_file_name), QMessageBox::Yes,
+                                  QMessageBox::No);
 
           if (decision == QMessageBox::Yes)
             {
               load_file (_file_name);
             }
 
           alreadyAsking = false;
         }
     }
   else
     {
       int decision =
-      QMessageBox::warning (this, tr ("Octave Editor"),
-                            tr ("It seems that \'%1\' has been deleted or renamed. Do you want to save it now?").
-                            arg (_file_name), QMessageBox::Save,
-                            QMessageBox::Close);
+        QMessageBox::warning (this, tr ("Octave Editor"),
+                              tr ("It seems that \'%1\' has been deleted or renamed. Do you want to save it now?").
+                              arg (_file_name), QMessageBox::Save,
+                              QMessageBox::Close);
       if (decision == QMessageBox::Save)
         {
           if (!save_file_as ())
             {
               set_file_name (UNNAMED_FILE);
               update_window_title (true); // window title (no modification)
               set_modified (true);
-              update_tracked_file ();
             }
         }
       else
         {
           emit close_request ();
         }
     }
 }
+
+void
+file_editor_tab::notice_settings ()
+{
+  QSettings *settings = resource_manager::get_settings ();
+
+  if (settings==NULL)
+    return; // this shouldn't happen!
+
+  _edit_area->setCaretLineVisible(settings->value ("editor/highlightCurrentLine",true).toBool ());
+
+  if (settings->value ("editor/codeCompletion",true).toBool ())
+    _edit_area->setAutoCompletionThreshold (1);
+  else
+    _edit_area->setAutoCompletionThreshold (-1);
+
+  QFont font( settings->value ("editor/fontName","Courier").toString () ,
+              settings->value ("editor/fontSize",10).toInt () );
+  if (settings->value ("editor/showLineNumbers",true).toBool ())
+    {
+      _edit_area->setMarginLineNumbers (2, true);
+      _edit_area->setMarginsFont( font );
+      QFontMetrics metrics( font );
+      _edit_area->setMarginWidth(2, metrics.width("9999"));
+    }
+  else
+    {
+      _edit_area->setMarginLineNumbers (2, false);
+      _edit_area->setMarginWidth(2, 0);
+    }
+
+  update_lexer ();
+
+  _long_title = settings->value ("editor/longWindowTitle",false).toBool ();
+
+  update_window_title (false);
+}
+
+void
+file_editor_tab::run_file_callback (void)
+{
+  // Maybe someday we will do something here?
+}
+
+void
+file_editor_tab::add_breakpoint_callback (const bp_info& info)
+{
+  bp_table::intmap intmap;
+  intmap[0] = info.line + 1;
+
+  std::string previous_directory = octave_env::get_current_directory ();
+  octave_env::chdir (info.path);
+  intmap = bp_table::add_breakpoint (info.function_name, intmap);
+  octave_env::chdir (previous_directory);
+
+  if (intmap.size () > 0)
+    {
+    // FIXME -- Check file.
+      _edit_area->markerAdd (info.line, breakpoint);
+    }
+}
+
+void
+file_editor_tab::remove_breakpoint_callback (const bp_info& info)
+{
+  bp_table::intmap intmap;
+  intmap[0] = info.line;
+
+  std::string previous_directory = octave_env::get_current_directory ();
+  octave_env::chdir (info.path);
+  bp_table::remove_breakpoint (info.function_name, intmap);
+  octave_env::chdir (previous_directory);
+
+  // FIXME -- check result
+  bool success = true;
+
+  if (success)
+    {
+      // FIXME -- check file.
+      _edit_area->markerDelete (info.line, breakpoint);
+    }
+}
+
+void
+file_editor_tab::remove_all_breakpoints_callback (const bp_info& info)
+{
+  bp_table::intmap intmap;
+  std::string previous_directory = octave_env::get_current_directory ();
+  octave_env::chdir (info.path);
+  intmap = bp_table::remove_all_breakpoints_in_file (info.function_name, true);
+  octave_env::chdir (previous_directory);
+
+  if (intmap.size() > 0)
+    _edit_area->markerDeleteAll (breakpoint);
+}
diff --git a/libgui/src/m-editor/file-editor-tab.h b/libgui/src/m-editor/file-editor-tab.h
--- a/libgui/src/m-editor/file-editor-tab.h
+++ b/libgui/src/m-editor/file-editor-tab.h
@@ -22,29 +22,25 @@ along with Octave; see the file COPYING.
 
 #ifndef FILEEDITORTAB_H
 #define FILEEDITORTAB_H
 
 #include <Qsci/qsciscintilla.h>
 #include <QWidget>
 #include <QCloseEvent>
 #include <QFileSystemWatcher>
-#include "octave-event-observer.h"
 
 class file_editor;
-class file_editor_tab : public QWidget, public octave_event_observer
+class file_editor_tab : public QWidget
 {
   Q_OBJECT
-public:
+  public:
   file_editor_tab (file_editor *fileEditor);
   bool copy_available ();
 
-  void event_accepted (octave_event *e);
-  void event_reject (octave_event *e);
-
 public slots:
   void update_window_title(bool modified);
   void handle_copy_available(bool enableCopy);
   void handle_margin_clicked (int line, int margin, Qt::KeyboardModifiers state);
   void comment_selected_text ();
   void uncomment_selected_text ();
   void find ();
   void remove_bookmark ();
@@ -59,44 +55,64 @@ public slots:
   void copy ();
   void paste ();
   void undo ();
   void redo ();
   void set_debugger_position (int line);
 
   void set_modified (bool modified = true);
 
-  bool open_file ();
-  void load_file (QString fileName);
+  bool open_file (const QString& dir = QString ());
+  bool load_file (const QString& fileName, bool silent = false);
   void new_file ();
   bool save_file ();
-  bool save_file(QString saveFileName);
+  bool save_file (const QString& saveFileName);
   bool save_file_as();
   void run_file ();
 
-  void file_has_changed (QString fileName);
+  void file_has_changed (const QString& fileName);
+  QString get_file_name () const {return _file_name;}
+
+  /** Tells the editor tab to react on changed settings. */
+  void notice_settings ();
 
 signals:
-  void file_name_changed (QString fileName);
+  void file_name_changed (const QString& fileName);
   void editor_state_changed ();
   void close_request ();
 
 protected:
   void closeEvent (QCloseEvent *event);
-  void set_file_name (QString fileName);
+  void set_file_name (const QString& fileName);
 
 private:
+
+  struct bp_info
+  {
+    bp_info (const QString& p, const QString& fn, int l)
+      : path (p.toStdString ()), function_name (fn.toStdString ()), line (l)
+    { }
+
+    std::string path;
+    std::string function_name;
+    int line;
+  };
+
   void update_lexer ();
   void request_add_breakpoint (int line);
   void request_remove_breakpoint (int line);
 
-  void update_tracked_file ();
-  int check_file_modified (QString msg, int cancelButton);
+  int check_file_modified (const QString& msg, int cancelButton);
   void do_comment_selected_text (bool comment);
 
+  void run_file_callback (void);
+  void add_breakpoint_callback (const bp_info& info);
+  void remove_breakpoint_callback (const bp_info& info);
+  void remove_all_breakpoints_callback (const bp_info& info);
+
   file_editor *         _file_editor;
   QsciScintilla *       _edit_area;
 
   QString               _file_name;
   QString               _file_name_short;
 
   bool                  _long_title;
   bool                  _copy_available;
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -15,38 +15,57 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include "file-editor.h"
+#include "resource-manager.h"
 #include <QVBoxLayout>
 #include <QApplication>
 #include <QFile>
 #include <QFont>
 #include <QFileDialog>
 #include <QMessageBox>
 #include <QStyle>
 #include <QTextStream>
 
-file_editor::file_editor (QTerminal *terminal, main_window *m)
-  : file_editor_interface(terminal, m)
+file_editor::file_editor (QTerminal *t, main_window *m)
+  : file_editor_interface (t, m)
 {
   construct ();
 
-  _terminal = terminal;
+  _terminal = t;
   _main_window = m;
   setVisible (false);
 }
 
 file_editor::~file_editor ()
 {
+  QSettings *settings = resource_manager::get_settings ();
+  QStringList sessionFileNames;
+  if (settings->value ("editor/restoreSession",true).toBool ())
+    {
+      for (int n=0;n<_tab_widget->count();++n)
+        {
+          file_editor_tab* tab = dynamic_cast<file_editor_tab*> (_tab_widget->widget (n));
+          if (!tab)
+            continue;
+          sessionFileNames.append (tab->get_file_name ());
+        }
+    }
+  settings->setValue ("editor/savedSessionTabs", sessionFileNames);
+  settings->sync ();
 }
 
 QTerminal *
 file_editor::terminal ()
 {
   return _terminal;
 }
 
@@ -89,41 +108,57 @@ file_editor::request_new_file ()
       add_file_editor_tab (fileEditorTab);
       fileEditorTab->new_file ();
     }
 }
 
 void
 file_editor::request_open_file ()
 {
+  file_editor_tab *current_tab = active_editor_tab ();
+  int curr_tab_index = _tab_widget->currentIndex ();
   file_editor_tab *fileEditorTab = new file_editor_tab (this);
   if (fileEditorTab)
     {
       add_file_editor_tab (fileEditorTab);
-      if (!fileEditorTab->open_file ())
+      QString dir = QDir::currentPath ();
+      // get the filename of the last active tab to open a new file from there
+      if (current_tab)
+        dir = QDir::cleanPath (current_tab->get_file_name ());
+      if (!fileEditorTab->open_file (dir))
         {
           // If no file was loaded, remove the tab again.
           _tab_widget->removeTab (_tab_widget->indexOf (fileEditorTab));
+          // restore focus to previous tab
+          if (curr_tab_index>=0)
+            _tab_widget->setCurrentIndex (curr_tab_index);
         }
     }
 }
 
 void
-file_editor::request_open_file (QString fileName)
+file_editor::request_open_file (const QString& fileName, bool silent)
 {
   if (!isVisible ())
     {
       show ();
     }
 
   file_editor_tab *fileEditorTab = new file_editor_tab (this);
+  int curr_tab_index = _tab_widget->currentIndex ();
   if (fileEditorTab)
     {
       add_file_editor_tab (fileEditorTab);
-      fileEditorTab->load_file (fileName);
+      if (!fileEditorTab->load_file (fileName, silent))
+        {
+          // If no file was loaded, remove the tab again.
+          _tab_widget->removeTab (_tab_widget->indexOf (fileEditorTab));
+          // restore focus to previous tab
+          _tab_widget->setCurrentIndex (curr_tab_index);
+        }
     }
 }
 
 void
 file_editor::request_undo ()
 {
   file_editor_tab *_active_file_editor_tab = active_editor_tab ();
   if (_active_file_editor_tab)
@@ -270,17 +305,17 @@ void
 file_editor::request_find ()
 {
   file_editor_tab *_active_file_editor_tab = active_editor_tab ();
   if (_active_file_editor_tab)
     _active_file_editor_tab->find ();
 }
 
 void
-file_editor::handle_file_name_changed (QString fileName)
+file_editor::handle_file_name_changed (const QString& fileName)
 {
   QObject *senderObject = sender ();
   file_editor_tab *fileEditorTab
     = dynamic_cast<file_editor_tab*> (senderObject);
   if (fileEditorTab)
     {
       for(int i = 0; i < _tab_widget->count (); i++)
         {
@@ -312,20 +347,30 @@ file_editor::handle_tab_close_request ()
   if (fileEditorTab)
     if (fileEditorTab->close ())
       {
         _tab_widget->removeTab (_tab_widget->indexOf (fileEditorTab));
         delete fileEditorTab;
       }
 }
 
+// slot for signal that is emitted when floating property changes
 void
-file_editor::active_tab_changed (int index)
+file_editor::top_level_changed (bool floating)
 {
-  Q_UNUSED (index);
+  if(floating)
+    {
+      setWindowFlags(Qt::Window);  // make a window from the widget when floating
+      show();                      // make it visible again since setWindowFlag hides it
+    }
+}
+
+void
+file_editor::active_tab_changed (int)
+{
   handle_editor_state_changed ();
 }
 
 void
 file_editor::handle_editor_state_changed ()
 {
   file_editor_tab *f = active_editor_tab ();
   if (f)
@@ -333,80 +378,92 @@ file_editor::handle_editor_state_changed
       bool copy_available = f->copy_available ();
       _copy_action->setEnabled (copy_available);
       _cut_action->setEnabled (copy_available);
       setFocusProxy (f);
     }
 }
 
 void
+file_editor::notice_settings ()
+{
+  for(int i = 0; i < _tab_widget->count (); i++)
+    {
+      file_editor_tab *fileEditorTab
+        = dynamic_cast <file_editor_tab*> (_tab_widget->widget (i));
+      if (fileEditorTab)
+        fileEditorTab->notice_settings ();
+    }
+}
+
+void
 file_editor::construct ()
 {
-  QWidget *widget = new QWidget (this);
-  QStyle *style = QApplication::style ();
+  QWidget *editor_widget = new QWidget (this);
+  QStyle *editor_style = QApplication::style ();
 
-  _menu_bar = new QMenuBar (widget);
-  _tool_bar = new QToolBar (widget);
-  _tab_widget = new QTabWidget (widget);
+  _menu_bar = new QMenuBar (editor_widget);
+  _tool_bar = new QToolBar (editor_widget);
+  _tab_widget = new QTabWidget (editor_widget);
   _tab_widget->setTabsClosable (true);
 
   QAction *new_action = new QAction (QIcon(":/actions/icons/filenew.png"),
-        tr("&New File"), _tool_bar);
+                                     tr("&New File"), _tool_bar);
 
   QAction *open_action = new QAction (QIcon(":/actions/icons/fileopen.png"),
-        tr("&Open File"), _tool_bar);
+                                      tr("&Open File"), _tool_bar);
 
   QAction *save_action = new QAction (QIcon(":/actions/icons/filesave.png"),
-        tr("&Save File"), _tool_bar);
+                                      tr("&Save File"), _tool_bar);
 
   QAction *save_as_action
     = new QAction (QIcon(":/actions/icons/filesaveas.png"),
                    tr("Save File &As"), _tool_bar);
 
   QAction *undo_action = new QAction (QIcon(":/actions/icons/undo.png"),
-        tr("&Undo"), _tool_bar);
+                                      tr("&Undo"), _tool_bar);
 
   QAction *redo_action = new QAction (QIcon(":/actions/icons/redo.png"),
-        tr("&Redo"), _tool_bar);
+                                      tr("&Redo"), _tool_bar);
 
   _copy_action = new QAction (QIcon(":/actions/icons/editcopy.png"),
                               tr ("&Copy"), _tool_bar);
 
   _cut_action  = new QAction (QIcon(":/actions/icons/editcut.png"),
                               tr ("Cu&t"), _tool_bar);
 
   QAction *paste_action
-      = new QAction (QIcon (":/actions/icons/editpaste.png"),
-                     tr("Paste"), _tool_bar);
+    = new QAction (QIcon (":/actions/icons/editpaste.png"),
+                   tr("Paste"), _tool_bar);
   QAction *next_bookmark_action       = new QAction (tr ("&Next Bookmark"),_tool_bar);
   QAction *previous_bookmark_action   = new QAction (tr ("Pre&vious Bookmark"),_tool_bar);
   QAction *toggle_bookmark_action     = new QAction (tr ("Toggle &Bookmark"),_tool_bar);
   QAction *remove_bookmark_action     = new QAction (tr ("&Remove All Bookmarks"),_tool_bar);
 
   QAction *next_breakpoint_action
-      = new QAction (QIcon (":/actions/icons/bp_next.png"),
-                     tr ("&Next breakpoint"), _tool_bar);
+    = new QAction (QIcon (":/actions/icons/bp_next.png"),
+                   tr ("&Next breakpoint"), _tool_bar);
   QAction *previous_breakpoint_action
-      = new QAction (QIcon (":/actions/icons/bp_prev.png"),
-                     tr ("Pre&vious breakpoint"), _tool_bar);
+    = new QAction (QIcon (":/actions/icons/bp_prev.png"),
+                   tr ("Pre&vious breakpoint"), _tool_bar);
   QAction *toggle_breakpoint_action
-      = new QAction (QIcon (":/actions/icons/bp_toggle.png"),
-                     tr ("Toggle &breakpoint"), _tool_bar);
+    = new QAction (QIcon (":/actions/icons/bp_toggle.png"),
+                   tr ("Toggle &breakpoint"), _tool_bar);
   QAction *remove_all_breakpoints_action
-      = new QAction (QIcon (":/actions/icons/bp_rm_all.png"),
-                     tr ("&Remove All breakpoints"), _tool_bar);
+    = new QAction (QIcon (":/actions/icons/bp_rm_all.png"),
+                   tr ("&Remove All breakpoints"), _tool_bar);
 
   QAction *comment_selection_action   = new QAction (tr ("&Comment Selected Text"),_tool_bar);
   QAction *uncomment_selection_action = new QAction (tr ("&Uncomment Selected Text"),_tool_bar);
 
   QAction *find_action = new QAction (QIcon(":/actions/icons/find.png"),
                                       tr ("&Find and Replace"), _tool_bar);
 
   _run_action = new QAction (QIcon(":/actions/icons/artsbuilderexecute.png"),
-        tr("Save File And Run"), _tool_bar);
+                             tr("Save File And Run"), _tool_bar);
 
   // some actions are disabled from the beginning
   _copy_action->setEnabled(false);
   _cut_action->setEnabled(false);
   _run_action->setShortcut                      (Qt::ControlModifier+ Qt::Key_R);
   _run_action->setShortcutContext               (Qt::WindowShortcut);
   next_bookmark_action->setShortcut             (Qt::Key_F2);
   next_bookmark_action->setShortcutContext      (Qt::WindowShortcut);
@@ -477,27 +534,27 @@ file_editor::construct ()
   _debug_menu->addSeparator ();
   // The other debug actions will be added by the main window.
   _menu_bar->addMenu (_debug_menu);
 
   QMenu *_run_menu = new QMenu (tr ("&Run"), _menu_bar);
   _run_menu->addAction (_run_action);
   _menu_bar->addMenu (_run_menu);
 
-  QVBoxLayout *layout = new QVBoxLayout ();
-  layout->addWidget (_menu_bar);
-  layout->addWidget (_tool_bar);
-  layout->addWidget (_tab_widget);
-  layout->setMargin (0);
-  widget->setLayout (layout);
-  setWidget (widget);
+  QVBoxLayout *vbox_layout = new QVBoxLayout ();
+  vbox_layout->addWidget (_menu_bar);
+  vbox_layout->addWidget (_tool_bar);
+  vbox_layout->addWidget (_tab_widget);
+  vbox_layout->setMargin (0);
+  editor_widget->setLayout (vbox_layout);
+  setWidget (editor_widget);
 
   connect (new_action,
            SIGNAL (triggered ()), this, SLOT (request_new_file ()));
-  connect (open_action,              
+  connect (open_action,
            SIGNAL (triggered ()), this, SLOT (request_open_file ()));
   connect (undo_action,
            SIGNAL (triggered ()), this, SLOT (request_undo ()));
   connect (redo_action,
            SIGNAL (triggered ()), this, SLOT (request_redo ()));
   connect (_copy_action,
            SIGNAL (triggered ()), this, SLOT (request_copy ()));
   connect (_cut_action,
@@ -531,21 +588,32 @@ file_editor::construct ()
   connect (uncomment_selection_action,
            SIGNAL (triggered ()), this, SLOT (request_uncomment_selected_text ()));
   connect (find_action,
            SIGNAL (triggered ()), this, SLOT (request_find ()));
   connect (_tab_widget,
            SIGNAL (tabCloseRequested (int)), this, SLOT (handle_tab_close_request (int)));
   connect (_tab_widget,
            SIGNAL (currentChanged(int)), this, SLOT (active_tab_changed (int)));
+  // topLevelChanged is emitted when floating property changes (floating = true)
+  connect (this, SIGNAL (topLevelChanged(bool)), this, SLOT(top_level_changed(bool)));
 
   resize (500, 400);
-  setWindowIcon (QIcon::fromTheme ("accessories-text-editor",
-                                   style->standardIcon (QStyle::SP_FileIcon)));
-  setWindowTitle ("Octave Editor");
+  setWindowIcon (QIcon(":/actions/icons/logo.png"));
+  setWindowTitle ("Editor");
+
+  //restore previous session
+  QSettings *settings = resource_manager::get_settings ();
+  if (settings->value ("editor/restoreSession",true).toBool ())
+    {
+      QStringList sessionFileNames = settings->value("editor/savedSessionTabs", QStringList()).toStringList ();
+
+      for (int n=0; n < sessionFileNames.count (); ++n)
+        request_open_file (sessionFileNames.at (n), true);
+    }
 }
 
 void
 file_editor::add_file_editor_tab (file_editor_tab *f)
 {
   _tab_widget->addTab (f, "");
   connect (f, SIGNAL (file_name_changed(QString)),
            this, SLOT(handle_file_name_changed(QString)));
diff --git a/libgui/src/m-editor/file-editor.h b/libgui/src/m-editor/file-editor.h
--- a/libgui/src/m-editor/file-editor.h
+++ b/libgui/src/m-editor/file-editor.h
@@ -40,36 +40,36 @@ enum editor_markers
   {
     bookmark,
     breakpoint,
     debugger_position
   };
 
 class file_editor : public file_editor_interface
 {
-Q_OBJECT
+  Q_OBJECT
 
-public:
+  public:
   file_editor (QTerminal *terminal, main_window *m);
   ~file_editor ();
-  void loadFile (QString fileName);
+  void loadFile (const QString& fileName);
 
   QTerminal *       terminal ();
   main_window *     get_main_window ();
 
   QMenu *           debug_menu ();
   QToolBar *        toolbar ();
 
   void handle_entered_debug_mode ();
   void handle_quit_debug_mode ();
 
 public slots:
   void request_new_file ();
   void request_open_file ();
-  void request_open_file (QString fileName);
+  void request_open_file (const QString& fileName, bool silent = false);
 
   void request_undo ();
   void request_redo ();
   void request_copy ();
   void request_cut ();
   void request_paste ();
   void request_save_file ();
   void request_save_file_as ();
@@ -83,21 +83,26 @@ public slots:
   void request_next_breakpoint ();
   void request_previous_breakpoint ();
   void request_remove_breakpoint ();
 
   void request_comment_selected_text ();
   void request_uncomment_selected_text ();
   void request_find ();
 
-  void handle_file_name_changed (QString fileName);
+  void handle_file_name_changed (const QString& fileName);
   void handle_tab_close_request (int index);
   void handle_tab_close_request ();
   void active_tab_changed (int index);
   void handle_editor_state_changed ();
+  /** Slot when floating property changes */
+  void top_level_changed (bool floating);
+
+  /** Tells the editor to react on changed settings. */
+  void notice_settings ();
 
 private:
   void construct ();
   void add_file_editor_tab(file_editor_tab *f);
   file_editor_tab *active_editor_tab();
 
   QMenuBar *        _menu_bar;
   QToolBar *        _tool_bar;
diff --git a/libgui/src/m-editor/find-dialog.cc b/libgui/src/m-editor/find-dialog.cc
--- a/libgui/src/m-editor/find-dialog.cc
+++ b/libgui/src/m-editor/find-dialog.cc
@@ -34,22 +34,26 @@
 ** met: http://www.gnu.org/copyleft/gpl.html.
 **
 ** If you have questions regarding the use of this file, please contact
 ** Nokia at qt-info@nokia.com.
 ** $QT_END_LICENSE$
 **
 ****************************************************************************/
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include <QtGui>
 #include <QIcon>
 #include "find-dialog.h"
 
-find_dialog::find_dialog (QsciScintilla* edit_area, QWidget *parent)
-  : QDialog (parent)
+find_dialog::find_dialog (QsciScintilla* edit_area, QWidget *p)
+  : QDialog (p)
 {
   setWindowTitle ("Find and Replace");
   setWindowIcon (QIcon(":/actions/icons/logo.png"));
 
   _search_label = new QLabel (tr ("Find &what:"));
   _search_line_edit = new QLineEdit;
   _search_label->setBuddy (_search_line_edit);
   _replace_label = new QLabel (tr ("Re&place with:"));
@@ -134,25 +138,27 @@ find_dialog::search_next ()
     {
       line = 1;
       col  = 1;
     }
 
   if (_edit_area)
     {
       _find_result_available = _edit_area->findFirst (_search_line_edit->text (),
-                                      _regex_check_box->isChecked (),
-                                      _case_check_box->isChecked (),
-                                      _whole_words_check_box->isChecked (),
-                                      _wrap_check_box->isChecked (),
-                                      !_backward_check_box->isChecked (),
-                                      line,col,
-                                      true,
-                                      true
-                                      );
+                                                      _regex_check_box->isChecked (),
+                                                      _case_check_box->isChecked (),
+                                                      _whole_words_check_box->isChecked (),
+                                                      _wrap_check_box->isChecked (),
+                                                      !_backward_check_box->isChecked (),
+                                                      line,col,
+                                                      true
+#ifdef HAVE_FINDFIRST_MODERN
+                                                      , true
+#endif
+                                                      );
     }
 }
 
 
 void
 find_dialog::replace ()
 {
   if (_edit_area)
diff --git a/libgui/src/m-editor/find-dialog.h b/libgui/src/m-editor/find-dialog.h
--- a/libgui/src/m-editor/find-dialog.h
+++ b/libgui/src/m-editor/find-dialog.h
@@ -50,17 +50,17 @@ class QDialogButtonBox;
 class QGroupBox;
 class QLabel;
 class QLineEdit;
 class QPushButton;
 
 class find_dialog : public QDialog
 {
   Q_OBJECT
-public:
+  public:
   find_dialog (QsciScintilla* edit_area, QWidget *parent = 0);
 
 private slots:
   void search_next ();
   void replace ();
   void replace_all ();
 
 private:
diff --git a/libgui/src/m-editor/lexer-octave-gui.cc b/libgui/src/m-editor/lexer-octave-gui.cc
--- a/libgui/src/m-editor/lexer-octave-gui.cc
+++ b/libgui/src/m-editor/lexer-octave-gui.cc
@@ -15,30 +15,61 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include "lexer-octave-gui.h"
 #include <qcolor.h>
 #include <qfont.h>
 
 // -----------------------------------------------------
 // Some basic functions
 // -----------------------------------------------------
-lexer_octave_gui::lexer_octave_gui(QObject *parent)
-    : QsciLexer(parent)  // inherit from base lexer
+lexer_octave_gui::lexer_octave_gui (QObject *p)
+  : QsciLexer (p)
 {
+  // The API info that is used for auto completion
+  // TODO: Where to store a file with API info (raw or prepared?)?
+  // TODO: Also provide infos on octave-forge functions?
+  // TODO: Also provide infos on function parameters?
+  // By now, use the keywords-list from syntax highlighting
+
+  QString keyword;
+  QStringList keywordList;
+
+  // get whole string with all keywords
+  keyword = this->keywords (1);
+  // split into single strings
+  keywordList = keyword.split (QRegExp ("\\s+"));
+
+  lexer_api = new QsciAPIs (this);
+  if (lexer_api)
+    {
+      for (int i = 0; i < keywordList.size (); i++)
+        {
+          // add single strings to the API
+          lexer_api->add (keywordList.at (i));
+        }
+      // prepare API info ... this may take some time
+      lexer_api->prepare ();
+    }
 }
 
 lexer_octave_gui::~lexer_octave_gui()
 {
+  if (lexer_api)
+    delete lexer_api;
 }
 
 const char *lexer_octave_gui::language() const
 {
   return "Octave";  // return the name of the language
 }
 
 const char *lexer_octave_gui::lexer() const
@@ -46,101 +77,101 @@ const char *lexer_octave_gui::lexer() co
   return "octave";  // return the name of the lexer
 }
 
 // -----------------------------------------------------
 // The colors for syntax highlighting
 // -----------------------------------------------------
 QColor lexer_octave_gui::defaultColor(int style) const
 {
-    switch (style)
-      {
-        case Default:  // black
-          return QColor(0x00,0x00,0x00);
-        case Operator: // red
-          return QColor(0xef,0x00,0x00);
-        case Comment:  // gray
-          return QColor(0x7f,0x7f,0x7f);
-        case Command:  // blue-green
-          return QColor(0x00,0x7f,0x7f);
-        case Number:   // orange
-          return QColor(0x7f,0x7f,0x00);
-        case Keyword:  // blue
-          return QColor(0x00,0x00,0xbf);
-        case SingleQuotedString: // green
-          return QColor(0x00,0x7f,0x00);
-        case DoubleQuotedString: // green-yellow
-          return QColor(0x4f,0x7f,0x00);
-      }
-    return QsciLexer::defaultColor(style);
+  switch (style)
+    {
+    case Default:  // black
+      return QColor(0x00,0x00,0x00);
+    case Operator: // red
+      return QColor(0xef,0x00,0x00);
+    case Comment:  // gray
+      return QColor(0x7f,0x7f,0x7f);
+    case Command:  // blue-green
+      return QColor(0x00,0x7f,0x7f);
+    case Number:   // orange
+      return QColor(0x7f,0x7f,0x00);
+    case Keyword:  // blue
+      return QColor(0x00,0x00,0xbf);
+    case SingleQuotedString: // green
+      return QColor(0x00,0x7f,0x00);
+    case DoubleQuotedString: // green-yellow
+      return QColor(0x4f,0x7f,0x00);
+    }
+  return QsciLexer::defaultColor(style);
 }
 
 
 // -----------------------------------------------------
 // The font decorations for highlighting
 // -----------------------------------------------------
 QFont lexer_octave_gui::defaultFont(int style) const
 {
-    QFont f;
+  QFont f;
 
-    switch (style)
-      {
-        case Comment: // default but italic
-          f = QsciLexer::defaultFont(style);
-          f.setItalic(true);
-          break;
-        case Keyword: // default
-          f = QsciLexer::defaultFont(style);
-          break;
-        case Operator:  // default
-          f = QsciLexer::defaultFont(style);
-          break;
-        default:        // default
-          f = QsciLexer::defaultFont(style);
-          break;
-      }
-    return f;   // return the selected font
+  switch (style)
+    {
+    case Comment: // default but italic
+      f = QsciLexer::defaultFont(style);
+      f.setItalic(true);
+      break;
+    case Keyword: // default
+      f = QsciLexer::defaultFont(style);
+      break;
+    case Operator:  // default
+      f = QsciLexer::defaultFont(style);
+      break;
+    default:        // default
+      f = QsciLexer::defaultFont(style);
+      break;
+    }
+  return f;   // return the selected font
 }
 
 
 // -----------------------------------------------------
 // Style names
 // -----------------------------------------------------
 QString lexer_octave_gui::description(int style) const
 {
-    switch (style)
-      {
-        case Default:
-          return tr("Default");
-        case Comment:
-          return tr("Comment");
-        case Command:
-          return tr("Command");
-        case Number:
-          return tr("Number");
-        case Keyword:
-          return tr("Keyword");
-        case SingleQuotedString:
-          return tr("Single-quoted string");
-        case Operator:
-          return tr("Operator");
-        case Identifier:
-          return tr("Identifier");
-        case DoubleQuotedString:
-          return tr("Double-quoted string");
-      }
-    return QString();
+  switch (style)
+    {
+    case Default:
+      return tr("Default");
+    case Comment:
+      return tr("Comment");
+    case Command:
+      return tr("Command");
+    case Number:
+      return tr("Number");
+    case Keyword:
+      return tr("Keyword");
+    case SingleQuotedString:
+      return tr("Single-quoted string");
+    case Operator:
+      return tr("Operator");
+    case Identifier:
+      return tr("Identifier");
+    case DoubleQuotedString:
+      return tr("Double-quoted string");
+    }
+  return QString();
 }
 
 
 // -----------------------------------------------------
 // The set of keywords for highlighting
 // TODO: How to define a second set?
 // -----------------------------------------------------
 const char *lexer_octave_gui::keywords(int set) const
 {
-    if (set == 1)
-      {
-        return resource_manager::octave_keywords ();
-      }
-    return 0;
+  if (set == 1)
+    {
+      return resource_manager::octave_keywords ();
+    }
+  return 0;
 }
 
diff --git a/libgui/src/m-editor/lexer-octave-gui.h b/libgui/src/m-editor/lexer-octave-gui.h
--- a/libgui/src/m-editor/lexer-octave-gui.h
+++ b/libgui/src/m-editor/lexer-octave-gui.h
@@ -22,44 +22,45 @@ along with Octave; see the file COPYING.
 
 #ifndef LEXEROCTAVE_H
 #define LEXEROCTAVE_H
 
 #include "resource-manager.h"
 #include <QObject>
 #include <Qsci/qsciglobal.h>
 #include <Qsci/qscilexer.h>
-
+#include <Qsci/qsciapis.h>
 
 class lexer_octave_gui : public QsciLexer
 {
-    Q_OBJECT
+  Q_OBJECT
 
-public:
-    // the used styles
-    enum
-      {
-        Default = 0,
-        Comment = 1,
-        Command = 2,
-        Number = 3,
-        Keyword = 4,
-        SingleQuotedString = 5,
-        Operator = 6,
-        Identifier = 7,
-        DoubleQuotedString = 8
-      };
+  public:
+  // the used styles
+  enum
+    {
+      Default = 0,
+      Comment = 1,
+      Command = 2,
+      Number = 3,
+      Keyword = 4,
+      SingleQuotedString = 5,
+      Operator = 6,
+      Identifier = 7,
+      DoubleQuotedString = 8
+    };
 
-    lexer_octave_gui (QObject *parent = 0);
-    virtual ~lexer_octave_gui ();
-    const char *language () const;
-    const char *lexer () const;
-    QColor defaultColor (int style) const;
-    QFont defaultFont (int style) const;
-    const char *keywords (int set) const;
-    QString description (int style) const;
+  lexer_octave_gui (QObject *parent = 0);
+  ~lexer_octave_gui ();
+  const char *language () const;
+  const char *lexer () const;
+  QColor defaultColor (int style) const;
+  QFont defaultFont (int style) const;
+  const char *keywords (int set) const;
+  QString description (int style) const;
 
 private:
-    lexer_octave_gui (const lexer_octave_gui &);
-    lexer_octave_gui &operator= (const lexer_octave_gui &);
+  lexer_octave_gui (const lexer_octave_gui &);
+  lexer_octave_gui &operator= (const lexer_octave_gui &);
+  QsciAPIs *lexer_api;
 };
 
 #endif
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -15,131 +15,122 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <QApplication>
+#include <QLabel>
 #include <QMenuBar>
 #include <QMenu>
 #include <QAction>
 #include <QSettings>
 #include <QStyle>
 #include <QToolBar>
 #include <QDesktopServices>
 #include <QFileDialog>
 #include <QMessageBox>
 #include <QIcon>
 
+#include "file-editor.h"
 #include "main-window.h"
-#include "file-editor.h"
+#include "octave-link.h"
 #include "settings-dialog.h"
 
-main_window::main_window (QWidget * parent)
-  : QMainWindow (parent), octave_event_observer ()
+#include "builtins.h"
+#include "defaults.h"
+#include "load-save.h"
+#include "toplev.h"
+#include "version.h"
+
+#include "cmd-hist.h"
+#include "oct-env.h"
+
+main_window::main_window (QWidget *p)
+  : QMainWindow (p)
 {
   // We have to set up all our windows, before we finally launch octave.
   construct ();
-  octave_link::instance ()->launch_octave();
+  octave_link::launch_octave ();
 }
 
 main_window::~main_window ()
 {
 }
 
 void
-main_window::event_accepted (octave_event *e)
-{
-  if (dynamic_cast<octave_clear_history_event*> (e))
-    {
-      // After clearing the history, we need to reset the model.
-      _history_dock_widget->reset_model ();
-    }
-  delete e;
-}
-
-void
-main_window::event_reject (octave_event *e)
-{
-  delete e;
-}
-
-void
 main_window::new_file ()
 {
   _file_editor->request_new_file ();
   focus_editor ();
 }
 
 void
 main_window::open_file ()
 {
   _file_editor->request_open_file ();
   focus_editor ();
 }
 
 void
-main_window::open_file (QString file_name)
+main_window::open_file (const QString& file_name)
 {
   _file_editor->request_open_file (file_name);
   focus_editor ();
 }
 
 void
-main_window::report_status_message (QString statusMessage)
+main_window::report_status_message (const QString& statusMessage)
 {
   _status_bar->showMessage (statusMessage, 1000);
 }
 
 void
 main_window::handle_save_workspace_request ()
 {
   QString selectedFile =
-      QFileDialog::getSaveFileName (this, tr ("Save Workspace"),
-                                    resource_manager::get_home_path ());
+    QFileDialog::getSaveFileName (this, tr ("Save Workspace"),
+                                  resource_manager::get_home_path ());
   if (!selectedFile.isEmpty ())
-    {
-      octave_link::instance ()
-          ->post_event (new octave_save_workspace_event (*this,
-          selectedFile.toStdString()));
-    }
+    octave_link::post_event (this, &main_window::save_workspace_callback,
+                             selectedFile.toStdString ());
 }
 
 void
 main_window::handle_load_workspace_request ()
 {
   QString selectedFile =
-      QFileDialog::getOpenFileName (this, tr ("Load Workspace"),
-                                    resource_manager::get_home_path ());
+    QFileDialog::getOpenFileName (this, tr ("Load Workspace"),
+                                  resource_manager::get_home_path ());
   if (!selectedFile.isEmpty ())
-    {
-      octave_link::instance ()
-          ->post_event (new octave_load_workspace_event (*this,
-            selectedFile.toStdString()));
-    }
+    octave_link::post_event (this, &main_window::load_workspace_callback,
+                             selectedFile.toStdString ());
 }
 
 void
 main_window::handle_clear_workspace_request ()
 {
-  octave_link::instance ()
-      ->post_event (new octave_clear_workspace_event (*this));
+  octave_link::post_event (this, &main_window::clear_workspace_callback);
 }
 
 void
 main_window::handle_clear_history_request()
 {
-  octave_link::instance ()
-      ->post_event (new octave_clear_history_event (*this));
+  octave_link::post_event (this, &main_window::clear_history_callback);
 }
 
 void
-main_window::handle_command_double_clicked (QString command)
+main_window::handle_command_double_clicked (const QString& command)
 {
   _terminal->sendText (command);
   _terminal->setFocus ();
 }
 
 void
 main_window::open_bug_tracker_page ()
 {
@@ -157,33 +148,37 @@ main_window::open_octave_forge_page ()
 {
   QDesktopServices::openUrl (QUrl ("http://octave.sourceforge.net/"));
 }
 
 void
 main_window::process_settings_dialog_request ()
 {
   settings_dialog *settingsDialog = new settings_dialog (this);
-  settingsDialog->exec ();
+  int change_settings = settingsDialog->exec ();
+  if (change_settings == QDialog::Accepted)
+    {
+      settingsDialog->write_changed_settings ();
+      emit settings_changed ();
+    }
   delete settingsDialog;
-  emit settings_changed ();
 }
 
 void
 main_window::notice_settings ()
 {
   // Set terminal font:
   QSettings *settings = resource_manager::get_settings ();
 
   // FIXME -- what should happen if settings is 0?
 
-  QFont font = QFont();
-  font.setFamily(settings->value("terminal/fontName").toString());
-  font.setPointSize(settings->value("terminal/fontSize").toInt ());
-  _terminal->setTerminalFont(font);
+  QFont term_font = QFont();
+  term_font.setFamily(settings->value("terminal/fontName").toString());
+  term_font.setPointSize(settings->value("terminal/fontSize").toInt ());
+  _terminal->setTerminalFont (term_font);
 
   QString cursorType = settings->value ("terminal/cursorType").toString ();
   bool cursorBlinking = settings->value ("terminal/cursorBlinking").toBool ();
   if (cursorType == "ibeam")
     _terminal->setCursorType(QTerminalInterface::IBeamCursor, cursorBlinking);
   else if (cursorType == "block")
     _terminal->setCursorType(QTerminalInterface::BlockCursor, cursorBlinking);
   else if (cursorType == "underline")
@@ -201,49 +196,44 @@ main_window::prepare_for_quit ()
 
 void
 main_window::reset_windows ()
 {
   // TODO: Implement.
 }
 
 void
-main_window::current_working_directory_has_changed (QString directory)
+main_window::current_working_directory_has_changed (const QString& directory)
 {
-  if (_current_directory_combo_box->count () > 31)
-    {
-      _current_directory_combo_box->removeItem (0);
+  int index = _current_directory_combo_box->findText (directory);
+  if ( index >= 0 )  // directory already in list -> remove it
+    { 
+      _current_directory_combo_box->removeItem (index);
     }
-  _current_directory_combo_box->addItem (directory);
-  int index = _current_directory_combo_box->findText (directory);
-  _current_directory_combo_box->setCurrentIndex (index);
-
+  _current_directory_combo_box->insertItem (0,directory);  // add (on top)
+  _current_directory_combo_box->setCurrentIndex (0);  // top is actual
   _files_dock_widget->set_current_directory (directory);
 }
 
 void
 main_window::change_current_working_directory ()
 {
   QString selectedDirectory =
-      QFileDialog::getExistingDirectory(this, tr ("Set working direcotry"));
+    QFileDialog::getExistingDirectory(this, tr ("Set working direcotry"));
 
   if (!selectedDirectory.isEmpty ())
-    {
-      octave_link::instance ()
-          ->post_event (new octave_change_directory_event (*this,
-                        selectedDirectory.toStdString ()));
-    }
+    octave_link::post_event (this, &main_window::change_directory_callback,
+                             selectedDirectory.toStdString ());
 }
 
 void
-main_window::set_current_working_directory (QString directory)
+main_window::set_current_working_directory (const QString& directory)
 {
-  octave_link::instance ()
-      ->post_event (new octave_change_directory_event (*this,
-                    directory.toStdString ()));
+  octave_link::post_event (this, &main_window::change_directory_callback,
+                           directory.toStdString ());
 }
 
 void
 main_window::current_working_directory_up ()
 {
   set_current_working_directory ("..");
 }
 
@@ -351,99 +341,128 @@ main_window::handle_quit_debug_mode ()
   _debug_step_out->setEnabled (false);
   _debug_quit->setEnabled (false);
   _file_editor->handle_quit_debug_mode ();
 }
 
 void
 main_window::debug_continue ()
 {
-  octave_link::instance ()
-      ->post_event (new octave_debug_continue_event (*this));
+  octave_link::post_event (this, &main_window::debug_continue_callback);
 }
 
 void
 main_window::debug_step_into ()
 {
-  octave_link::instance ()
-      ->post_event (new octave_debug_step_into_event (*this));
+  octave_link::post_event (this, &main_window::debug_step_into_callback);
 }
 
 void
 main_window::debug_step_over ()
 {
-  octave_link::instance ()
-      ->post_event (new octave_debug_step_over_event (*this));
+  octave_link::post_event (this, &main_window::debug_step_over_callback);
 }
 
 void
 main_window::debug_step_out ()
 {
-  octave_link::instance ()
-      ->post_event (new octave_debug_step_out_event (*this));
+  octave_link::post_event (this, &main_window::debug_step_out_callback);
 }
 
 void
 main_window::debug_quit ()
 {
-  octave_link::instance ()
-      ->post_event (new octave_debug_quit_event (*this));
+  octave_link::post_event (this, &main_window::debug_quit_callback);
 }
 
 void
 main_window::show_about_octave ()
 {
-  QString message =
-      "GNU Octave\n"
-      "Copyright (C) 2009 John W. Eaton and others.\n"
-      "This is free software; see the source code for copying conditions."
-      "There is ABSOLUTELY NO WARRANTY; not even for MERCHANTABILITY or"
-      "FITNESS FOR A PARTICULAR PURPOSE.  For details, type `warranty'.\n"
-      "\n"
-      "Additional information about Octave is available at http://www.octave.org.\n"
-      "\n"
-      "Please contribute if you find this software useful."
-      "For more information, visit http://www.octave.org/help-wanted.html\n"
-      "\n"
-      "Report bugs to <bug@octave.org> (but first, please read"
-      "http://www.octave.org/bugs.html to learn how to write a helpful report).\n"
-      "\n"
-      "For information about changes from previous versions, type `news'.\n";
+  QString message = OCTAVE_STARTUP_MESSAGE;
 
   QMessageBox::about (this, tr ("About Octave"), message);
 }
 
 void
-main_window::closeEvent (QCloseEvent * closeEvent)
+main_window::closeEvent (QCloseEvent *e)
 {
-  closeEvent->ignore ();
-  octave_link::instance ()->post_event (new octave_exit_event (*this));
- }
+  e->ignore ();
+  octave_link::post_event (this, &main_window::exit_callback);
+}
 
 void
 main_window::read_settings ()
 {
   QSettings *settings = resource_manager::get_settings ();
 
   // FIXME -- what should happen if settings is 0?
 
+  restoreState (settings->value ("MainWindow/windowState").toByteArray ());
+  settings->beginGroup ("DockWidgets");
+  // restoring the geometry of all dock-widgets
+  foreach (QObject *obj, children ())
+    {
+      QString name = obj->objectName ();
+      if (obj->inherits("QDockWidget") && ! name.isEmpty ())
+        {
+          QDockWidget *widget = qobject_cast<QDockWidget *> (obj);
+          QVariant val = settings->value (name);
+          widget->restoreGeometry (val.toByteArray ());
+          bool floating = settings->value (name+"Floating",false).toBool ();
+          bool visible = settings->value (name+"Visible",true).toBool ();
+          if (floating)
+            widget->setWindowFlags (Qt::Window); // if floating, make window from widget
+          widget->setVisible (visible);          // make widget visible if desired (setWindowFlags hides widget)
+        }
+    }
+  settings->endGroup();
   restoreGeometry (settings->value ("MainWindow/geometry").toByteArray ());
-  restoreState (settings->value ("MainWindow/windowState").toByteArray ());
+  // restore the list of the last directories
+  QStringList curr_dirs = settings->value ("MainWindow/current_directory_list").toStringList ();
+  for (int i=0; i < curr_dirs.size (); i++)
+    {
+      _current_directory_combo_box->addItem (curr_dirs.at (i));
+    }
   emit settings_changed ();
 }
 
 void
 main_window::write_settings ()
 {
   QSettings *settings = resource_manager::get_settings ();
 
   // FIXME -- what should happen if settings is 0?
 
   settings->setValue ("MainWindow/geometry", saveGeometry ());
+  settings->beginGroup ("DockWidgets");
+  // saving the geometry of all widgets
+  foreach (QObject *obj, children())
+    {
+      QString name = obj->objectName ();
+      if (obj->inherits ("QDockWidget") && ! name.isEmpty ())
+        {
+          QDockWidget *widget = qobject_cast<QDockWidget *> (obj);
+          settings->setValue (name, widget->saveGeometry ());
+          bool floating = widget->isFloating ();
+          bool visible = widget->isVisible ();
+          settings->setValue (name+"Floating",floating);  // store floating state
+          settings->setValue (name+"Visible",visible);    // store visibility
+          if (floating)
+            widget->setWindowFlags(Qt::Widget); // if floating, recover the widget state such that the widget's
+        }                                       // state is correctly saved by the saveSate () below
+    }
+  settings->endGroup();
   settings->setValue ("MainWindow/windowState", saveState ());
+  // write the list of recent used directories
+  QStringList curr_dirs;
+  for (int i=0; i<_current_directory_combo_box->count (); i++)
+    {
+      curr_dirs.append (_current_directory_combo_box->itemText (i));
+    }
+  settings->setValue ("MainWindow/current_directory_list",curr_dirs);
   settings->sync ();
 }
 
 void
 main_window::construct ()
 {
   _closing = false;   // flag for editor files when closed
   setWindowIcon (QIcon(":/actions/icons/logo.png"));
@@ -458,17 +477,18 @@ main_window::construct ()
   _documentation_dock_widget= new documentation_dock_widget (this);
   _documentation_dock_widget->setStatusTip (tr ("See the documentation for help."));
   _status_bar               = new QStatusBar (this);
 
   _current_directory_combo_box = new QComboBox (this);
   _current_directory_combo_box->setFixedWidth (300);
   _current_directory_combo_box->setEditable (true);
   _current_directory_combo_box->setInsertPolicy (QComboBox::InsertAtTop);
-  _current_directory_combo_box->setMaxVisibleItems (14);
+  _current_directory_combo_box->setMaxVisibleItems (16);
+  _current_directory_combo_box->setMaxCount (16);
 
   _current_directory_tool_button = new QToolButton (this);
   _current_directory_tool_button->setIcon (QIcon(":/actions/icons/search.png"));
 
   _current_directory_up_tool_button = new QToolButton (this);
   _current_directory_up_tool_button->setIcon (QIcon(":/actions/icons/up.png"));
 
   // Octave Terminal subwindow.
@@ -487,17 +507,17 @@ main_window::construct ()
 
   _file_editor = new file_editor (_terminal, this);
 
   QMenu *file_menu = menuBar ()->addMenu (tr ("&File"));
 
   QMenu *new_menu = file_menu->addMenu(tr ("New"));
 
   QAction *new_script_action
-      = new_menu->addAction (QIcon(":/actions/icons/filenew.png"), tr ("Script"));
+    = new_menu->addAction (QIcon(":/actions/icons/filenew.png"), tr ("Script"));
   new_script_action->setShortcut (Qt::ControlModifier + Qt::Key_N);
 
   QAction *new_function_action = new_menu->addAction (tr ("Function"));
   new_function_action->setEnabled (false); // TODO: Make this work.
   QAction *new_class_action = new_menu->addAction (tr ("Class"));
   new_class_action->setEnabled (false); // TODO: Make this work.
   QAction *new_enumeration_action = new_menu->addAction (tr ("Enumeration"));
   new_enumeration_action->setEnabled (false); // TODO: Make this work.
@@ -506,107 +526,107 @@ main_window::construct ()
   QAction *new_variable_action = new_menu->addAction (tr ("Variable"));
   new_variable_action->setEnabled (false); // TODO: Make this work.
   QAction *new_model_action = new_menu->addAction (tr ("Model"));
   new_model_action->setEnabled (false); // TODO: Make this work.
   QAction *new_gui_action = new_menu->addAction (tr ("GUI"));
   new_gui_action->setEnabled (false); // TODO: Make this work.
 
   QAction *open_action
-      = file_menu->addAction (QIcon(":/actions/icons/fileopen.png"), tr ("Open..."));
+    = file_menu->addAction (QIcon(":/actions/icons/fileopen.png"), tr ("Open..."));
   open_action->setShortcut (Qt::ControlModifier + Qt::Key_O);
 
   QAction *close_command_window_action
-      = file_menu->addAction (tr ("Close Command Window"));
+    = file_menu->addAction (tr ("Close Command Window"));
   close_command_window_action->setShortcut (Qt::ControlModifier + Qt::Key_W);
   close_command_window_action->setEnabled (false); // TODO: Make this work.
 
   file_menu->addSeparator ();
   QAction *import_data_action
-      = file_menu->addAction (tr ("Import Data..."));
+    = file_menu->addAction (tr ("Import Data..."));
   import_data_action->setEnabled (false); // TODO: Make this work.
 
   QAction *save_workspace_action
-      = file_menu->addAction (tr ("Save Workspace..."));
+    = file_menu->addAction (tr ("Save Workspace..."));
   save_workspace_action->setShortcut (Qt::ControlModifier + Qt::Key_S);
   file_menu->addSeparator ();
 
   QAction *preferences_action
-      = file_menu->addAction (QIcon(":/actions/icons/configure.png"),
-                              tr ("Preferences..."));
+    = file_menu->addAction (QIcon(":/actions/icons/configure.png"),
+                            tr ("Preferences..."));
   file_menu->addSeparator ();
   QAction *page_setup_action
-      = file_menu->addAction (tr ("Page Setup..."));
+    = file_menu->addAction (tr ("Page Setup..."));
   page_setup_action->setEnabled (false); // TODO: Make this work.
   QAction *print_action
-      = file_menu->addAction (tr ("Print"));
+    = file_menu->addAction (tr ("Print"));
   print_action->setShortcut (Qt::ControlModifier + Qt::Key_P);
   print_action->setEnabled (false); // TODO: Make this work.
   QAction *print_selection_action
-      = file_menu->addAction (tr ("Print Selection..."));
+    = file_menu->addAction (tr ("Print Selection..."));
   print_selection_action->setEnabled (false); // TODO: Make this work.
 
   file_menu->addSeparator ();
   QAction *exit_action = file_menu->addAction (tr ("Exit"));
   exit_action->setShortcut (Qt::ControlModifier + Qt::Key_Q);
 
 
   QMenu *edit_menu = menuBar ()->addMenu (tr ("&Edit"));
   QAction *undo_action
-      = edit_menu->addAction (QIcon(":/actions/icons/undo.png"), tr ("Undo"));
+    = edit_menu->addAction (QIcon(":/actions/icons/undo.png"), tr ("Undo"));
   undo_action->setShortcut (QKeySequence::Undo);
 
   QAction *redo_action
-      = edit_menu->addAction (QIcon(":/actions/icons/redo.png"), tr ("Redo"));
+    = edit_menu->addAction (QIcon(":/actions/icons/redo.png"), tr ("Redo"));
   redo_action->setShortcut (QKeySequence::Redo);
   edit_menu->addSeparator ();
 
   QAction *cut_action
-      = edit_menu->addAction (QIcon(":/actions/icons/editcut.png"), tr ("Cut"));
+    = edit_menu->addAction (QIcon(":/actions/icons/editcut.png"), tr ("Cut"));
   cut_action->setShortcut (Qt::ControlModifier + Qt::ShiftModifier + Qt::Key_X);
 
   QAction *copy_action
-      = edit_menu->addAction (QIcon(":/actions/icons/editcopy.png"), tr ("Copy"));
+    = edit_menu->addAction (QIcon(":/actions/icons/editcopy.png"), tr ("Copy"));
   copy_action->setShortcut (Qt::ControlModifier + Qt::ShiftModifier + Qt::Key_C);
 
   QAction *paste_action
-      = edit_menu->addAction (QIcon(":/actions/icons/editpaste.png"), tr ("Paste"));
+    = edit_menu->addAction (QIcon(":/actions/icons/editpaste.png"), tr ("Paste"));
   paste_action->setShortcut (Qt::ControlModifier + Qt::ShiftModifier + Qt::Key_V);
 
   QAction *paste_to_workspace_action
-      = edit_menu->addAction (tr ("Paste To Workspace..."));
+    = edit_menu->addAction (tr ("Paste To Workspace..."));
   paste_to_workspace_action->setEnabled (false); // TODO: Make this work.
   edit_menu->addSeparator ();
 
   QAction *select_all_action
-      = edit_menu->addAction (tr ("Select All"));
+    = edit_menu->addAction (tr ("Select All"));
   select_all_action->setEnabled (false); // TODO: Make this work.
   QAction *delete_action
-      = edit_menu->addAction (tr ("Delete"));
+    = edit_menu->addAction (tr ("Delete"));
   delete_action->setShortcut (Qt::Key_Delete);
   delete_action->setEnabled (false); // TODO: Make this work.
   edit_menu->addSeparator ();
 
   QAction *find_action
-      = edit_menu->addAction (tr ("Find..."));
+    = edit_menu->addAction (tr ("Find..."));
   find_action->setEnabled (false); // TODO: Make this work.
   QAction *find_files_action
-      = edit_menu->addAction (tr ("Find Files..."));
+    = edit_menu->addAction (tr ("Find Files..."));
   find_files_action->setShortcut (Qt::ControlModifier + Qt::ShiftModifier
                                   + Qt::Key_F);
   find_files_action->setEnabled (false); // TODO: Make this work.
   edit_menu->addSeparator ();
 
   QAction *clear_command_window_action
-      = edit_menu->addAction (tr ("Clear Command Window"));
+    = edit_menu->addAction (tr ("Clear Command Window"));
   clear_command_window_action->setEnabled (false); // TODO: Make this work.
   QAction *clear_command_history
-      = edit_menu->addAction(tr ("Clear Command History"));
+    = edit_menu->addAction(tr ("Clear Command History"));
   QAction * clear_workspace_action
-      = edit_menu->addAction (tr ("Clear Workspace"));
+    = edit_menu->addAction (tr ("Clear Workspace"));
 
   _debug_menu = menuBar ()->addMenu (tr ("De&bug"));
 
   _debug_step_over = _debug_menu->addAction (QIcon (":/actions/icons/db_step.png"), tr ("Step"));
   _debug_step_over->setEnabled (false);
   _file_editor->debug_menu ()->addAction (_debug_step_over);
   _file_editor->toolbar ()->addAction (_debug_step_over);
   _debug_step_over->setShortcut (Qt::Key_F10);
@@ -672,17 +692,17 @@ main_window::construct ()
   QAction * show_editor_action = window_menu->addAction (tr ("Show Editor"));
   show_editor_action->setCheckable (true);
   show_editor_action->setShortcut (Qt::ControlModifier + Qt::ShiftModifier
                                    + Qt::Key_4);
 
   QAction * show_documentation_action = window_menu->addAction (tr ("Show Documentation"));
   show_documentation_action->setCheckable (true);
   show_documentation_action->setShortcut (Qt::ControlModifier + Qt::ShiftModifier
-                                   + Qt::Key_5);
+                                          + Qt::Key_5);
   window_menu->addSeparator ();
 
   QAction * command_window_action
     = window_menu->addAction (tr ("Command Window"));
   command_window_action->setShortcut (Qt::ControlModifier + Qt::Key_0);
 
   QAction * history_action
     = window_menu->addAction (tr ("Command History"));
@@ -719,29 +739,29 @@ main_window::construct ()
     = help_menu->addAction (tr ("Visit Octave Forge"));
   help_menu->addSeparator ();
 
   QAction * about_octave_action
     = help_menu->addAction (tr ("About Octave"));
 
   // Toolbars
   QToolBar *main_tool_bar = addToolBar ("Main");
-            main_tool_bar->addAction (new_script_action);
-            main_tool_bar->addAction (open_action);
-            main_tool_bar->addSeparator ();
-            main_tool_bar->addAction (cut_action);
-            main_tool_bar->addAction (copy_action);
-            main_tool_bar->addAction (paste_action);
-            main_tool_bar->addAction (undo_action);
-            main_tool_bar->addAction (redo_action);
-            main_tool_bar->addSeparator ();
-            main_tool_bar->addWidget (new QLabel (tr ("Current Directory:")));
-            main_tool_bar->addWidget (_current_directory_combo_box);
-            main_tool_bar->addWidget (_current_directory_tool_button);
-            main_tool_bar->addWidget (_current_directory_up_tool_button);
+  main_tool_bar->addAction (new_script_action);
+  main_tool_bar->addAction (open_action);
+  main_tool_bar->addSeparator ();
+  main_tool_bar->addAction (cut_action);
+  main_tool_bar->addAction (copy_action);
+  main_tool_bar->addAction (paste_action);
+  main_tool_bar->addAction (undo_action);
+  main_tool_bar->addAction (redo_action);
+  main_tool_bar->addSeparator ();
+  main_tool_bar->addWidget (new QLabel (tr ("Current Directory:")));
+  main_tool_bar->addWidget (_current_directory_combo_box);
+  main_tool_bar->addWidget (_current_directory_tool_button);
+  main_tool_bar->addWidget (_current_directory_up_tool_button);
 
   connect (qApp,                        SIGNAL (aboutToQuit ()),
            this,                        SLOT   (prepare_for_quit ()));
   connect (preferences_action,          SIGNAL (triggered ()),
            this,                        SLOT   (process_settings_dialog_request ()));
   connect (exit_action,                 SIGNAL (triggered ()),
            this,                        SLOT   (close ()));
   connect (new_script_action,           SIGNAL (triggered ()),
@@ -792,16 +812,18 @@ main_window::construct ()
   connect (editor_action,               SIGNAL (triggered ()),
            this,                        SLOT (focus_editor ()));
   connect (documentation_action,        SIGNAL (triggered ()),
            this,                        SLOT (focus_documentation ()));
 
   connect (reset_windows_action,        SIGNAL (triggered ()),
            this,                        SLOT   (reset_windows ()));
   connect (this,                        SIGNAL (settings_changed ()),
+           _file_editor,                SLOT   (notice_settings ()));
+  connect (this,                        SIGNAL (settings_changed ()),
            _files_dock_widget,          SLOT   (notice_settings ()));
   connect (this,                        SIGNAL (settings_changed ()),
            this,                        SLOT   (notice_settings ()));
   connect (_files_dock_widget,          SIGNAL (open_file (QString)),
            this,                        SLOT   (open_file (QString)));
   connect (_files_dock_widget,          SIGNAL (displayed_directory_changed(QString)),
            this,                        SLOT   (set_current_working_directory(QString)));
   connect (_history_dock_widget,        SIGNAL (information (QString)),
@@ -842,20 +864,19 @@ main_window::construct ()
   setDockOptions(QMainWindow::AnimatedDocks | QMainWindow::AllowNestedDocks | QMainWindow::AllowTabbedDocks);
   addDockWidget (Qt::LeftDockWidgetArea, _workspace_view);
   addDockWidget (Qt::LeftDockWidgetArea, _history_dock_widget);
   addDockWidget (Qt::RightDockWidgetArea, _files_dock_widget);
   addDockWidget (Qt::RightDockWidgetArea, _file_editor);
   addDockWidget (Qt::BottomDockWidgetArea, _terminal_dock_widget);
   addDockWidget (Qt::RightDockWidgetArea, _documentation_dock_widget);
   setStatusBar (_status_bar);
-  read_settings ();
 
   _octave_qt_event_listener = new octave_qt_event_listener ();
-  octave_link::instance ()->register_event_listener (_octave_qt_event_listener);
+  octave_link::register_event_listener (_octave_qt_event_listener);
 
   connect (_octave_qt_event_listener,
            SIGNAL (current_directory_has_changed_signal (QString)),
            this,
            SLOT (current_working_directory_has_changed (QString)));
 
   connect (_octave_qt_event_listener,
            SIGNAL (entered_debug_mode_signal ()),
@@ -863,8 +884,75 @@ main_window::construct ()
            SLOT(handle_entered_debug_mode ()));
 
   connect (_octave_qt_event_listener,
            SIGNAL (quit_debug_mode_signal ()),
            this,
            SLOT (handle_quit_debug_mode ()));
 }
 
+void
+main_window::save_workspace_callback (const std::string& file)
+{
+  Fsave (ovl (file));
+}
+
+void
+main_window::load_workspace_callback (const std::string& file)
+{
+  Fload (ovl (file));
+}
+
+void
+main_window::clear_workspace_callback (void)
+{
+  Fclear ();
+}
+
+void
+main_window::clear_history_callback (void)
+{
+  command_history::clear ();
+
+  _history_dock_widget->reset_model ();
+}
+
+void
+main_window::change_directory_callback (const std::string& directory)
+{
+  Fcd (ovl (directory));
+}
+
+void
+main_window::debug_continue_callback (void)
+{
+  Fdbcont ();
+}
+
+void
+main_window::debug_step_into_callback (void)
+{
+  Fdbstep (ovl ("in"));
+}
+
+void
+main_window::debug_step_over_callback (void)
+{
+  Fdbstep ();
+}
+
+void
+main_window::debug_step_out_callback (void)
+{
+  Fdbstep (ovl ("out"));
+}
+
+void
+main_window::debug_quit_callback (void)
+{
+  Fdbquit ();
+}
+
+void
+main_window::exit_callback (void)
+{
+  Fquit ();
+}
diff --git a/libgui/src/main-window.h b/libgui/src/main-window.h
--- a/libgui/src/main-window.h
+++ b/libgui/src/main-window.h
@@ -39,75 +39,69 @@ along with Octave; see the file COPYING.
 // Editor includes
 #include "file-editor-interface.h"
 
 // QTerminal includes
 #include "QTerminal.h"
 
 // Own includes
 #include "resource-manager.h"
-#include "octave-link.h"
 #include "workspace-view.h"
 #include "history-dockwidget.h"
 #include "files-dockwidget.h"
 #include "terminal-dockwidget.h"
 #include "documentation-dockwidget.h"
 #include "octave-qt-event-listener.h"
-#include "octave-event-observer.h"
 
 /**
-  * \class MainWindow
-  *
-  * Represents the main window.
-  */
-class main_window
-    : public QMainWindow, public octave_event_observer
+ * \class MainWindow
+ *
+ * Represents the main window.
+ */
+class main_window : public QMainWindow
 {
-Q_OBJECT public:
+  Q_OBJECT public:
   main_window (QWidget * parent = 0);
   ~main_window ();
 
-  void event_accepted (octave_event *e);
-  void event_reject (octave_event *e);
-
   QTerminal *get_terminal_view () { return _terminal; }
   history_dock_widget *get_history_dock_widget ()
   {
     return _history_dock_widget;
   }
   files_dock_widget *get_files_dock_widget ()
   {
     return _files_dock_widget;
   }
   bool is_closing () { return _closing; }
 
 signals:
   void settings_changed ();
 
 public slots:
-  void report_status_message (QString statusMessage);
+  void report_status_message (const QString& statusMessage);
   void handle_save_workspace_request ();
   void handle_load_workspace_request ();
   void handle_clear_workspace_request ();
   void handle_clear_history_request ();
-  void handle_command_double_clicked (QString command);
+  void handle_command_double_clicked (const QString& command);
   void new_file ();
   void open_file ();
-  void open_file (QString file_name);
+  void open_file (const QString& file_name);
   void open_bug_tracker_page ();
   void open_agora_page ();
   void open_octave_forge_page ();
   void process_settings_dialog_request ();
   void show_about_octave ();
   void notice_settings ();
   void prepare_for_quit ();
   void reset_windows ();
-  void current_working_directory_has_changed (QString directory);
+  void current_working_directory_has_changed (const QString& directory);
   void change_current_working_directory ();
-  void set_current_working_directory (QString directory);
+  void set_current_working_directory (const QString& directory);
   void current_working_directory_up ();
 
   void focus_command_window ();
   void focus_command_history ();
   void focus_current_directory ();
   void focus_workspace ();
   void focus_editor ();
   void focus_documentation ();
@@ -115,25 +109,48 @@ public slots:
   void handle_entered_debug_mode ();
   void handle_quit_debug_mode ();
   void debug_continue ();
   void debug_step_into ();
   void debug_step_over ();
   void debug_step_out ();
   void debug_quit ();
 
+  void read_settings ();
+  void write_settings ();
+
 protected:
   void closeEvent (QCloseEvent * closeEvent);
-  void read_settings ();
-  void write_settings ();
 
 private:
   void construct ();
   void establish_octave_link ();
 
+  void save_workspace_callback (const std::string& file);
+
+  void load_workspace_callback (const std::string& file);
+
+  void clear_workspace_callback (void);
+
+  void clear_history_callback (void);
+
+  void change_directory_callback (const std::string& directory);
+
+  void debug_continue_callback (void);
+
+  void debug_step_into_callback (void);
+
+  void debug_step_over_callback (void);
+
+  void debug_step_out_callback (void);
+
+  void debug_quit_callback (void);
+
+  void exit_callback (void);
+
   QTerminal *               _terminal;
   file_editor_interface *   _file_editor;
   QMenu *                   _debug_menu;
 
   QAction *                 _debug_continue;
   QAction *                 _debug_step_into;
   QAction *                 _debug_step_over;
   QAction *                 _debug_step_out;
diff --git a/libgui/src/module.mk b/libgui/src/module.mk
new file mode 100644
--- /dev/null
+++ b/libgui/src/module.mk
@@ -0,0 +1,160 @@
+EXTRA_DIST += \
+  src/module.mk \
+  src/resource.qrc \
+  $(octave_gui_UI) \
+  $(octave_gui_ICONS)
+
+octave_gui_ICONS = \
+  src/icons/arrow_right.png \
+  src/icons/artsbuilderexecute.png \
+  src/icons/bookmark.png \
+  src/icons/bp_next.png \
+  src/icons/bp_prev.png \
+  src/icons/bp_rm_all.png \
+  src/icons/bp_toggle.png \
+  src/icons/chat.png \
+  src/icons/configure.png \
+  src/icons/db_cont.png \
+  src/icons/db_step_in.png \
+  src/icons/db_step_out.png \
+  src/icons/db_step.png \
+  src/icons/db_stop.png \
+  src/icons/editcopy.png \
+  src/icons/editcut.png \
+  src/icons/editpaste.png \
+  src/icons/filenew.png \
+  src/icons/fileopen.png \
+  src/icons/filesaveas.png \
+  src/icons/filesave.png \
+  src/icons/find.png \
+  src/icons/help_index.png \
+  src/icons/icons_license \
+  src/icons/jabber_protocol.png \
+  src/icons/logo.png \
+  src/icons/question.png \
+  src/icons/redled.png \
+  src/icons/redo.png \
+  src/icons/search.png \
+  src/icons/star.png \
+  src/icons/stop.png \
+  src/icons/terminal.png \
+  src/icons/undo.png \
+  src/icons/up.png \
+  src/icons/zoom-in.png \
+  src/icons/zoom-out.png
+
+octave_gui_MOC = \
+  src/m-editor/moc-file-editor-interface.cc \
+  src/m-editor/moc-file-editor-tab.cc \
+  src/m-editor/moc-file-editor.cc \
+  src/m-editor/moc-find-dialog.cc \
+  src/m-editor/moc-lexer-octave-gui.cc \
+  src/moc-documentation-dockwidget.cc \
+  src/moc-files-dockwidget.cc \
+  src/moc-history-dockwidget.cc \
+  src/moc-main-window.cc \
+  src/moc-octave-qt-event-listener.cc \
+  src/moc-settings-dialog.cc \
+  src/moc-terminal-dockwidget.cc \
+  src/moc-welcome-wizard.cc \
+  src/moc-workspace-model.cc \
+  src/moc-workspace-view.cc \
+  src/octave-adapter/moc-octave-main-thread.cc \
+  src/qtinfo/moc-parser.cc \
+  src/qtinfo/moc-webinfo.cc
+
+octave_gui_RC = src/qrc-resource.cc
+
+octave_gui_UI = \
+  src/settings-dialog.ui \
+  src/welcome-wizard.ui
+
+octave_gui_UI_H = $(patsubst src/%.ui, src/ui-%.h, $(octave_gui_UI))
+
+BUILT_SOURCES += $(octave_gui_UI_H)
+
+noinst_HEADERS += \
+  src/documentation-dockwidget.h \
+  src/files-dockwidget.h \
+  src/history-dockwidget.h \
+  src/m-editor/file-editor-interface.h \
+  src/m-editor/file-editor-tab.h \
+  src/m-editor/file-editor.h \
+  src/m-editor/find-dialog.h \
+  src/m-editor/lexer-octave-gui.h \
+  src/main-window.h \
+  src/octave-adapter/octave-event-listener.h \
+  src/octave-adapter/octave-link.h \
+  src/octave-adapter/octave-main-thread.h \
+  src/octave-gui.h \
+  src/octave-qt-event-listener.h \
+  src/qtinfo/parser.h \
+  src/qtinfo/webinfo.h \
+  src/resource-manager.h \
+  src/settings-dialog.h \
+  src/symbol-information.h \
+  src/terminal-dockwidget.h \
+  src/welcome-wizard.h \
+  src/workspace-model.h \
+  src/workspace-view.h
+
+src_libgui_src_la_SOURCES = \
+  src/documentation-dockwidget.cc \
+  src/files-dockwidget.cc \
+  src/history-dockwidget.cc \
+  src/m-editor/file-editor-tab.cc \
+  src/m-editor/file-editor.cc \
+  src/m-editor/find-dialog.cc \
+  src/m-editor/lexer-octave-gui.cc \
+  src/main-window.cc \
+  src/octave-adapter/octave-link.cc \
+  src/octave-adapter/octave-main-thread.cc \
+  src/octave-gui.cc \
+  src/octave-qt-event-listener.cc \
+  src/qtinfo/parser.cc \
+  src/qtinfo/webinfo.cc \
+  src/resource-manager.cc \
+  src/settings-dialog.cc \
+  src/symbol-information.cc \
+  src/terminal-dockwidget.cc \
+  src/welcome-wizard.cc \
+  src/workspace-model.cc \
+  src/workspace-view.cc
+
+nodist_src_libgui_src_la_SOURCES = $(octave_gui_MOC) $(octave_gui_RC)
+
+src_libgui_src_la_CPPFLAGS = \
+  $(AM_CPPFLAGS) \
+  @OCTGUI_DLL_DEFS@ \
+  -I$(QT_INCDIR) \
+  -I$(QT_INCDIR)/QtCore \
+  -I$(QT_INCDIR)/QtGui \
+  -I$(QT_INCDIR)/QtNetwork \
+  -I$(srcdir)/qterminal/libqterminal \
+  -Isrc -I$(srcdir)/src \
+  -I$(srcdir)/src/m-editor \
+  -I$(srcdir)/src/octave-adapter \
+  -I$(srcdir)/src/qtinfo \
+  -I$(top_srcdir)/liboctave/cruft/misc \
+  -I$(top_srcdir)/liboctave/array \
+  -I$(top_builddir)/liboctave/numeric -I$(top_srcdir)/liboctave/numeric \
+  -I$(top_builddir)/liboctave/operators -I$(top_srcdir)/liboctave/operators \
+  -I$(top_srcdir)/liboctave/system \
+  -I$(top_srcdir)/liboctave/util \
+  -I$(top_builddir)/libinterp -I$(top_srcdir)/libinterp \
+  -I$(top_builddir)/libinterp/parse-tree -I$(top_srcdir)/libinterp/parse-tree \
+  -I$(top_builddir)/libinterp/interp-core -I$(top_srcdir)/libinterp/interp-core \
+  -I$(top_builddir)/libinterp/interpfcn -I$(top_srcdir)/libinterp/interpfcn \
+  -I$(top_srcdir)/libinterp/octave-value
+
+src_libgui_src_la_CFLAGS = $(AM_CFLAGS) $(WARN_CFLAGS)
+
+src_libgui_src_la_CXXFLAGS = $(AM_CXXFLAGS) $(WARN_CXXFLAGS)
+
+noinst_LTLIBRARIES += src/libgui-src.la
+
+CLEANFILES += \
+  $(octave_gui_MOC) \
+  $(octave_gui_UI_H) \
+  $(octave_gui_RC)
+
diff --git a/libgui/src/octave-adapter/octave-event-listener.h b/libgui/src/octave-adapter/octave-event-listener.h
--- a/libgui/src/octave-adapter/octave-event-listener.h
+++ b/libgui/src/octave-adapter/octave-event-listener.h
@@ -26,16 +26,18 @@ along with Octave; see the file COPYING.
 #include <string>
 
 class octave_event_listener
 {
   public:
     octave_event_listener () { }
     virtual ~octave_event_listener () { }
 
-    virtual void current_directory_has_changed (std::string directory) = 0;
+    virtual void
+    current_directory_has_changed (const std::string& directory) = 0;
+
     virtual void about_to_exit () = 0;
 
     virtual void entered_debug_mode () = 0;
     virtual void quit_debug_mode () = 0;
 };
 
 #endif // OCTAVEEVENTLISTENER_H
diff --git a/libgui/src/octave-adapter/octave-event-observer.h b/libgui/src/octave-adapter/octave-event-observer.h
deleted file mode 100644
--- a/libgui/src/octave-adapter/octave-event-observer.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
-
-Copyright (C) 2011-2012 Jacob Dawid
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef OCTAVEEVENTOBSERVER_H
-#define OCTAVEEVENTOBSERVER_H
-
-class octave_event;
-
-/**
-  * \class octave_event_observer
-  * \brief Implements the observer part for the observer pattern.
-  */
-class octave_event_observer
-{
-  public:
-    octave_event_observer () { }
-    virtual ~octave_event_observer () { }
-
-    /**
-      * This will be called when an event has been accepted. Operations
-      * in this routine will be processed in the octave thread.
-      */
-    virtual void event_accepted (octave_event *e) = 0;
-
-    /**
-      * This will be called when an event has been rejected. Operations
-      * in this routine will be processed in the octave thread.
-      */
-    virtual void event_reject (octave_event *e) = 0;
-};
-
-#include "octave-event.h"
-
-#endif // OCTAVEEVENTOBSERVER_H
diff --git a/libgui/src/octave-adapter/octave-event.cc b/libgui/src/octave-adapter/octave-event.cc
deleted file mode 100644
--- a/libgui/src/octave-adapter/octave-event.cc
+++ /dev/null
@@ -1,176 +0,0 @@
-/*
-
-Copyright (C) 2011-2012 Jacob Dawid
-Copyright (C) 2011-2012 John P. Swensen
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <string>
-
-#include "cmd-hist.h"
-#include "oct-env.h"
-
-#include "debug.h"
-#include "oct-obj.h"
-#include "parse.h"
-#include "symtab.h"
-#include "toplev.h"
-
-#include "octave-event.h"
-
-#include <readline/readline.h>
-
-void
-octave_event::call_octave_function (std::string name)
-{
-  call_octave_function (name, octave_value_list ());
-}
-
-void
-octave_event::call_octave_function (std::string name,
-                                    const octave_value_list& args,
-                                    int nargout)
-{
-  try
-    {
-      feval (name, args, nargout);
-    } catch (...) { } // Ignore exceptions. Crashes without that.
-}
-
-void
-octave_event::finish_readline_event () const
-{
-  rl_line_buffer[0] = '\0';
-  rl_point = rl_end = 0;
-  rl_done = 1;
-  //rl_forced_update_display ();
-}
-
-bool
-octave_clear_history_event::perform ()
-{
-  int i;
-  while ((i = command_history::length ()) > 0) {
-    command_history::remove (i - 1);
-  }
-  return true;
-}
-
-bool
-octave_debug_step_into_event::perform ()
-{
-  octave_value_list args;
-  args.append (octave_value ("in"));
-  call_octave_function ("dbstep", args);
-  finish_readline_event ();
-  return true;
-}
-
-bool
-octave_debug_step_out_event::perform ()
-{
-  octave_value_list args;
-  args.append (octave_value ("out"));
-  call_octave_function ("dbstep", args);
-  finish_readline_event ();
-  return true;
-}
-
-
-bool
-octave_exit_event::perform ()
-{
-  clean_up_and_exit (0);
-  return true;
-}
-
-bool
-octave_run_file_event::perform ()
-{
-  octave_value_list args;
-  args.append (octave_value (_file));
-  call_octave_function ("run", args);
-  finish_readline_event ();
-  return true;
-}
-
-bool
-octave_change_directory_event::perform ()
-{
-  return octave_env::chdir (_directory);
-}
-
-bool
-octave_load_workspace_event::perform ()
-{
-  octave_value_list args;
-  args.append (octave_value (_file));
-  call_octave_function ("load", args);
-  return true;
-}
-
-bool
-octave_save_workspace_event::perform ()
-{
-  octave_value_list args;
-  args.append (octave_value (_file));
-  call_octave_function ("save", args);
-  return true;
-}
-
-bool
-octave_add_breakpoint_event::perform ()
-{
-  bp_table::intmap intmap;
-  intmap[0] = _line + 1;
-
-  std::string previous_directory = octave_env::get_current_directory ();
-  octave_env::chdir (_path);
-  intmap = bp_table::add_breakpoint (_function_name, intmap);
-  octave_env::chdir (previous_directory);
-  return intmap.size () > 0;
-}
-
-bool
-octave_remove_breakpoint_event::perform ()
-{
-  bp_table::intmap intmap;
-  intmap[0] = _line;
-
-  std::string previous_directory = octave_env::get_current_directory ();
-  octave_env::chdir (_path);
-  bp_table::remove_breakpoint (_function_name, intmap);
-  octave_env::chdir (previous_directory);
-  return true; // TODO: Check result.
-}
-
-bool
-octave_remove_all_breakpoints_event::perform ()
-{
-  bp_table::intmap intmap;
-  std::string previous_directory = octave_env::get_current_directory ();
-  octave_env::chdir (_path);
-  intmap = bp_table::remove_all_breakpoints_in_file (_function_name, true);
-  octave_env::chdir (previous_directory);
-  return intmap.size() > 0;
-}
diff --git a/libgui/src/octave-adapter/octave-event.h b/libgui/src/octave-adapter/octave-event.h
deleted file mode 100644
--- a/libgui/src/octave-adapter/octave-event.h
+++ /dev/null
@@ -1,383 +0,0 @@
-/*
-
-Copyright (C) 2011-2012 Jacob Dawid
-Copyright (C) 2011-2012 John P. Swensen
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef OCTAVEEVENT_H
-#define OCTAVEEVENT_H
-
-#include <string>
-
-class octave_value_list;
-
-#include "octave-event-observer.h"
-
-/**
-  * \class octave_event
-  * \brief Base class for an octave event.
-  * In order to make communication with octave threadsafe, comunication is
-  * implemented via events. An application may create events and post them,
-  * however there is no guarantee events will be processed in a given time.
-  *
-  * In order to create an event, there must be an event observer. The event
-  * observer will be given the opportunity to react on the event as soon as
-  * it has been processed in the octave thread. Accepting and ignoring takes
-  * places in the octave thread.
-  */
-class octave_event
-{
-  public:
-    octave_event (octave_event_observer& o)
-      : _octave_event_observer (o)
-    { }
-
-    virtual ~octave_event ()
-    { }
-
-    /** Performs what is necessary to make this event happen. This
-      * code is thread-safe since it will be executed in the octave
-      * thread. However, you should take care to keep this code as
-      * short as possible. */
-    virtual bool perform () = 0;
-
-    /**
-      * Accepts this event. This allows the event observer to react properly
-      * onto the event.
-      */
-    void accept ()
-    { _octave_event_observer.event_accepted (this); }
-
-    /**
-      * Rejects this event. This allows the event observer to react properly
-      * onto the event.
-      */
-    void reject ()
-    { _octave_event_observer.event_reject (this); }
-
-  protected:
-    void call_octave_function (std::string name);
-
-    void call_octave_function (std::string name,
-                               const octave_value_list& args,
-                               int nargout = 0);
-
-    void finish_readline_event () const;
-
-  private:
-    octave_event_observer& _octave_event_observer;
-};
-
-class octave_update_history_event : public octave_event
-{
-  public:
-    /** Creates a new octave_exit_event. */
-    octave_update_history_event (octave_event_observer& o)
-      : octave_event (o)
-    { }
-
-    bool perform ()
-    { return true; /* Always grant. */ }
-};
-
-class octave_update_workspace_event : public octave_event
-{
-  public:
-    /** Creates a new octave_exit_event. */
-    octave_update_workspace_event (octave_event_observer& o)
-      : octave_event (o)
-    { }
-
-    bool perform ()
-    { return true; /* Always grant. */ }
-};
-
-/** Implements an octave exit event. */
-class octave_exit_event : public octave_event
-{
-  public:
-    /** Creates a new octave_exit_event. */
-    octave_exit_event (octave_event_observer& o)
-      : octave_event (o)
-    { }
-
-    bool perform ();
-};
-
-/** Implements an octave run file event. */
-class octave_run_file_event : public octave_event
-{
-  public:
-    /** Creates a new octave_run_file_event. */
-    octave_run_file_event (octave_event_observer& o,
-                           std::string file)
-      : octave_event (o)
-    { _file = file; }
-
-    bool perform ();
-
-  private:
-    std::string _file;
-};
-
-/** Implements a change directory event. */
-class octave_change_directory_event : public octave_event
-{
-  public:
-    /** Creates a new octave_change_directory_event. */
-    octave_change_directory_event (octave_event_observer& o,
-                                   std::string directory)
-      : octave_event (o)
-    { _directory = directory; }
-
-    bool perform ();
-
-  private:
-    std::string _directory;
-};
-
-/** Implements a clear workspace event. */
-class octave_clear_workspace_event : public octave_event
-{
-  public:
-    /** Creates a new octave_run_file_event. */
-    octave_clear_workspace_event (octave_event_observer& o)
-      : octave_event (o)
-    { }
-
-    bool perform ()
-    {
-      call_octave_function ("clear");
-      return true;
-    }
-};
-
-/** Implements a load workspace event. */
-class octave_load_workspace_event : public octave_event
-{
-  public:
-    /** Creates a new octave_change_directory_event. */
-    octave_load_workspace_event (octave_event_observer& o,
-                                 std::string file)
-      : octave_event (o)
-    { _file = file; }
-
-    bool perform ();
-
-  private:
-    std::string _file;
-};
-
-/** Implements a save workspace event. */
-class octave_save_workspace_event : public octave_event
-{
-  public:
-    /** Creates a new octave_change_directory_event. */
-    octave_save_workspace_event (octave_event_observer& o,
-                                 std::string file)
-      : octave_event (o)
-    { _file = file; }
-
-    bool perform ();
-
-  private:
-    std::string _file;
-};
-
-class octave_clear_history_event : public octave_event
-{
-  public:
-    /** Creates a new octave_clear_history_event. */
-    octave_clear_history_event (octave_event_observer& o)
-      : octave_event (o)
-    { }
-
-  bool perform ();
-};
-
-class octave_add_breakpoint_event : public octave_event
-{
-  public:
-    octave_add_breakpoint_event (octave_event_observer& o,
-                                 std::string path,
-                                 std::string function_name,
-                                 int line)
-      : octave_event (o)
-    {
-      _path = path;
-      _function_name = function_name;
-      _line = line;
-    }
-
-    bool perform ();
-
-    std::string get_path ()
-    {
-      return _path;
-    }
-
-    std::string get_function_name ()
-    {
-      return _function_name;
-    }
-
-    int get_line ()
-    {
-      return _line;
-    }
-
-  private:
-    std::string _path;
-    std::string _function_name;
-    int _line;
-};
-
-class octave_remove_breakpoint_event : public octave_event
-{
-  public:
-    octave_remove_breakpoint_event (octave_event_observer& o,
-                                    std::string path,
-                                    std::string function_name,
-                                    int line)
-      : octave_event (o)
-    {
-      _path = path;
-      _function_name = function_name;
-      _line = line;
-    }
-
-    bool perform ();
-
-    std::string get_path ()
-    {
-      return _path;
-    }
-
-    std::string get_function_name ()
-    {
-      return _function_name;
-    }
-
-    int get_line ()
-    {
-      return _line;
-    }
-
-  private:
-    std::string _path;
-    std::string _function_name;
-    int _line;
-};
-
-class octave_remove_all_breakpoints_event : public octave_event
-{
-  public:
-    octave_remove_all_breakpoints_event (octave_event_observer& o,
-                                         std::string path,
-                                         std::string function_name)
-      : octave_event (o)
-    {
-      _path = path;
-      _function_name = function_name;
-    }
-
-    bool perform ();
-
-    std::string get_path ()
-    {
-      return _path;
-    }
-
-    std::string get_function_name ()
-    {
-      return _function_name;
-    }
-
-  private:
-    std::string _path;
-    std::string _function_name;
-};
-
-class octave_debug_step_into_event : public octave_event
-{
-  public:
-    /** Creates a new octave_debug_step_into_event. */
-    octave_debug_step_into_event (octave_event_observer& o)
-      : octave_event (o) { }
-
-    bool perform ();
-};
-
-class octave_debug_step_over_event : public octave_event
-{
-  public:
-    /** Creates a new octave_debug_step_over_event. */
-    octave_debug_step_over_event (octave_event_observer& o)
-      : octave_event (o) { }
-
-    bool perform ()
-    {
-      call_octave_function ("dbnext");
-      finish_readline_event ();
-      return true;
-    }
-};
-
-class octave_debug_step_out_event : public octave_event
-{
-  public:
-    /** Creates a new octave_debug_step_out_event. */
-    octave_debug_step_out_event (octave_event_observer& o)
-      : octave_event (o) { }
-
-    bool perform ();
-};
-
-class octave_debug_continue_event : public octave_event
-{
-  public:
-    /** Creates a new octave_debug_step_out_event. */
-    octave_debug_continue_event (octave_event_observer& o)
-      : octave_event (o) { }
-
-    bool perform ()
-    {
-      call_octave_function ("dbcont");
-      finish_readline_event ();
-      return true;
-    }
-};
-
-class octave_debug_quit_event : public octave_event
-{
-  public:
-    /** Creates a new octave_debug_step_out_event. */
-    octave_debug_quit_event (octave_event_observer& o)
-      : octave_event (o) { }
-
-    bool perform ()
-    {
-      call_octave_function ("dbquit");
-      finish_readline_event ();
-      return true;
-    }
-};
-
-#endif // OCTAVEEVENT_H
diff --git a/libgui/src/octave-adapter/octave-link.cc b/libgui/src/octave-adapter/octave-link.cc
--- a/libgui/src/octave-adapter/octave-link.cc
+++ b/libgui/src/octave-adapter/octave-link.cc
@@ -23,145 +23,136 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "cmd-edit.h"
 #include "oct-env.h"
 #include "oct-mutex.h"
+#include "singleton-cleanup.h"
 #include "symtab.h"
 #include "toplev.h"
 
 #include "octave-link.h"
 
-int octave_readline_hook ()
+static int
+octave_readline_hook (void)
 {
-  octave_link::instance ()->entered_readline_hook ();
-  octave_link::instance ()->generate_events ();
-  octave_link::instance ()->process_events ();
-  octave_link::instance ()->finished_readline_hook ();
+  octave_link::entered_readline_hook ();
+  octave_link::generate_events ();
+  octave_link::process_events ();
+  octave_link::finished_readline_hook ();
+
   return 0;
 }
 
-void octave_exit_hook (int status)
+static void
+octave_exit_hook (int)
 {
-  (void) status;
-  octave_link::instance ()->about_to_exit ();
+  octave_link::about_to_exit ();
 }
 
-octave_link octave_link::_singleton;
+octave_link *octave_link::instance = 0;
 
-octave_link::octave_link ()
+octave_link::octave_link (void)
+  : event_listener (0), event_queue_mutex (new octave_mutex ()),
+    gui_event_queue (), last_cwd (), debugging (false)
+{ }
+
+void
+octave_link::do_launch_octave (void)
 {
-  _event_queue_mutex = new octave_mutex ();
-  _last_working_directory = "";
-  _debugging_mode_active = false;
-}
+  // Create both threads.
+  main_thread = new octave_main_thread ();
+
+  command_editor::add_event_hook (octave_readline_hook);
 
-octave_link::~octave_link ()
-{
+  octave_exit = octave_exit_hook;
+
+  // Start the first one.
+  main_thread->start ();
 }
 
 void
-octave_link::launch_octave ()
+octave_link::do_register_event_listener (octave_event_listener *el)
 {
-  // Create both threads.
-  _octave_main_thread = new octave_main_thread ();
-  command_editor::add_event_hook (octave_readline_hook);
-  octave_exit = octave_exit_hook;
-
-  // Start the first one.
-  _octave_main_thread->start ();
+  event_listener = el;
 }
 
 void
-octave_link::register_event_listener (octave_event_listener *oel)
-{ _octave_event_listener = oel; }
-
-void
-octave_link::generate_events ()
+octave_link::do_generate_events (void)
 {
   std::string current_working_directory = octave_env::get_current_directory ();
-  if (current_working_directory != _last_working_directory)
+
+  if (current_working_directory != last_cwd)
     {
-      _last_working_directory = current_working_directory;
-      if (_octave_event_listener)
-        _octave_event_listener
-            ->current_directory_has_changed (_last_working_directory);
+      last_cwd = current_working_directory;
+
+      if (event_listener)
+        event_listener->current_directory_has_changed (last_cwd);
     }
 
-  if (_debugging_mode_active != Vdebugging)
+  if (debugging != Vdebugging)
     {
-      _debugging_mode_active = Vdebugging;
-      if (_octave_event_listener)
+      debugging = Vdebugging;
+
+      if (event_listener)
         {
-          if (_debugging_mode_active)
-            _octave_event_listener->entered_debug_mode ();
+          if (debugging)
+            event_listener->entered_debug_mode ();
           else
-            _octave_event_listener->quit_debug_mode ();
+            event_listener->quit_debug_mode ();
         }
     }
 }
 
 void
-octave_link::process_events ()
+octave_link::do_process_events (void)
 {
-  _event_queue_mutex->lock ();
+  event_queue_mutex->lock ();
 
-  while (_event_queue.size () > 0)
-    {
-      octave_event * e = _event_queue.front ();
-      _event_queue.pop ();
-      if (e->perform ())
-        e->accept ();
-      else
-        e->reject ();
-    }
-  _event_queue_mutex->unlock ();
-}
+  gui_event_queue.run ();
 
-void
-octave_link::post_event (octave_event *e)
-{
-  if (e)
-    {
-      _event_queue_mutex->lock ();
-      _event_queue.push (e);
-      _event_queue_mutex->unlock ();
-    }
+  event_queue_mutex->unlock ();
 }
 
 void
-octave_link::event_accepted (octave_event *e)
-{ delete e; }
-
-void
-octave_link::event_reject (octave_event *e)
-{ delete e; }
-
-void
-octave_link::about_to_exit ()
+octave_link::do_about_to_exit (void)
 {
-  _event_queue_mutex->lock ();
-  while (!_event_queue.empty ())
-    _event_queue.pop ();
+  event_queue_mutex->lock ();
 
-  _event_queue_mutex->unlock ();
-
-  if (_octave_event_listener)
-    _octave_event_listener->about_to_exit ();
-}
+  gui_event_queue.discard ();
 
-void
-octave_link::entered_readline_hook ()
-{ }
+  event_queue_mutex->unlock ();
 
-void
-octave_link::finished_readline_hook ()
-{
+  if (event_listener)
+    event_listener->about_to_exit ();
 }
 
 std::string
-octave_link::get_last_working_directory ()
+octave_link::do_last_working_directory (void)
+{
+  return last_cwd;
+}
+
+bool
+octave_link::instance_ok (void)
 {
-  return _last_working_directory;
+  bool retval = true;
+
+  if (! instance)
+    {
+      instance = new octave_link ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
+
+  if (! instance)
+    {
+      ::error ("unable to create octave_link object!");
+
+      retval = false;
+    }
+
+  return retval;
 }
diff --git a/libgui/src/octave-adapter/octave-link.h b/libgui/src/octave-adapter/octave-link.h
--- a/libgui/src/octave-adapter/octave-link.h
+++ b/libgui/src/octave-adapter/octave-link.h
@@ -19,76 +19,167 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifndef OCTAVELINK_H
 #define OCTAVELINK_H
 
-#include <queue>
 #include <string>
 
 class octave_mutex;
 
+#include "event-queue.h"
+
 #include "octave-main-thread.h"
-#include "octave-event.h"
-#include "octave-event-observer.h"
 #include "octave-event-listener.h"
 
-/**
-  * \class OctaveLink
-  * \brief Provides threadsafe access to octave.
-  * \author Jacob Dawid
-  * This class is a wrapper around octave and provides threadsafety by
-  * buffering access operations to octave and executing them in the readline
-  * event hook, which lives in the octave thread.
-  */
-class octave_link : public octave_event_observer
+// \class OctaveLink
+// \brief Provides threadsafe access to octave.
+// \author Jacob Dawid
+//
+// This class is a wrapper around octave and provides thread safety by
+// buffering access operations to octave and executing them in the
+// readline event hook, which lives in the octave thread.
+
+class octave_link
 {
+protected:
+
+  octave_link (void);
+
 public:
-  /** Provides a way to access the unique octave_link object. */
-  static octave_link * instance () { return &_singleton; }
+
+  ~octave_link (void) { }
+
+  static void launch_octave (void)
+  {
+    if (instance_ok ())
+      instance->do_launch_octave ();
+  }
+
+  static void register_event_listener (octave_event_listener *el)
+  {
+    if (instance_ok ())
+      instance->do_register_event_listener (el);
+  }
+
+  static void generate_events (void)
+  {
+    if (instance_ok ())
+      instance->do_generate_events ();
+  }
+
+  static void process_events (void)
+  {
+    if (instance_ok ())
+      instance->do_process_events ();
+  }
 
-  /** Starts octave. */
-  void launch_octave ();
-  void register_event_listener (octave_event_listener *oel);
+  template <class T>
+  static void post_event (T *obj, void (T::*method) (void))
+  {
+    if (instance_ok ())
+      instance->do_post_event (obj, method);
+  }
+
+  template <class T, class A>
+  static void post_event (T *obj, void (T::*method) (A), A arg)
+  {
+    if (instance_ok ())
+      instance->do_post_event (obj, method, arg);
+  }
+
+  template <class T, class A>
+  static void post_event (T *obj, void (T::*method) (const A&), const A& arg)
+  {
+    if (instance_ok ())
+      instance->do_post_event (obj, method, arg);
+  }
 
-  void generate_events ();
-  void process_events ();
-  void post_event (octave_event *e);
-  void event_accepted (octave_event *e);
-  void event_reject (octave_event *e);
+  static void about_to_exit (void)
+  {
+    if (instance_ok ())
+      instance->do_about_to_exit ();
+  }
+
+  static void entered_readline_hook (void)
+  {
+    if (instance_ok ())
+      instance->do_entered_readline_hook ();
+  }
 
-  void about_to_exit ();
+  static void finished_readline_hook (void)
+  {
+    if (instance_ok ())
+      instance->do_finished_readline_hook ();
+  }
 
-  void entered_readline_hook ();
-  void finished_readline_hook ();
-
-  std::string get_last_working_directory ();
+  static std::string last_working_directory (void)
+  {
+    return instance_ok ()
+      ? instance->do_last_working_directory () : std::string ();
+  }
 
 private:
-  /** Singleton. */
-  octave_link ();
-  ~octave_link ();
+
+  static octave_link *instance;
+
+  static void cleanup_instance (void) { delete instance; instance = 0; }
 
-  octave_event_listener *_octave_event_listener;
+  // No copying!
+
+  octave_link (const octave_link&);
+
+  octave_link& operator = (const octave_link&);
+
+  static bool instance_ok (void);
 
-  /** Thread running octave_main. */
-  octave_main_thread *_octave_main_thread;
+  octave_event_listener *event_listener;
+
+  // Thread running octave_main.
+  octave_main_thread *main_thread;
+
+  // Semaphore to lock access to the event queue.
+  octave_mutex *event_queue_mutex;
 
-  /** Semaphore to lock access to the event queue. */
-  octave_mutex *_event_queue_mutex;
+  // Event Queue.
+  event_queue gui_event_queue;
+
+  // Stores the last known current working directory of octave.
+  std::string last_cwd;
+
+  bool debugging;
 
-  /** Buffer for queueing events until they will be processed. */
-  std::queue <octave_event *> _event_queue;
+  void do_launch_octave (void);
+  void do_register_event_listener (octave_event_listener *oel);
+
+  void do_generate_events (void);
+  void do_process_events (void);
 
-  /** Stores the last known current working directory of octave. */
-  std::string _last_working_directory;
-  bool _debugging_mode_active;
+  template <class T>
+  void do_post_event (T *obj, void (T::*method) (void))
+  {
+    gui_event_queue.add_method (obj, method);
+  }
 
-  /** Semaphore to lock access to the performance information. */
-  octave_mutex *_performance_information_mutex;
+  template <class T, class A>
+  void do_post_event (T *obj, void (T::*method) (A), A arg)
+  {
+    gui_event_queue.add_method (obj, method, arg);
+  }
 
-  /** Unique instance. Singelton! */
-  static octave_link _singleton;
+  template <class T, class A>
+  void do_post_event (T *obj, void (T::*method) (const A&), const A& arg)
+  {
+    gui_event_queue.add_method (obj, method, arg);
+  }
+
+  void do_about_to_exit (void);
+
+  void do_entered_readline_hook (void) { }
+  void do_finished_readline_hook (void) { }
+
+  std::string do_last_working_directory (void);
 };
+
 #endif // OCTAVELINK_H
diff --git a/libgui/src/octave-gui.cc b/libgui/src/octave-gui.cc
--- a/libgui/src/octave-gui.cc
+++ b/libgui/src/octave-gui.cc
@@ -25,17 +25,18 @@ along with Octave; see the file COPYING.
 #endif
 
 #include <QtGui/QApplication>
 #include <QTranslator>
 #include <QSettings>
 
 #include <iostream>
 
-#include <syswait.h>
+#include "lo-utils.h"
+#include "syswait.h"
 
 #include "welcome-wizard.h"
 #include "resource-manager.h"
 #include "main-window.h"
 #include "octave-gui.h"
 
 // Dissociate from the controlling terminal, if any.
 
@@ -64,27 +65,30 @@ dissociate_terminal (void)
   else
     {
       // Parent
 
       int status;
 
       waitpid (pid, &status, 0);
 
-      exit (WIFEXITED (status) ? WEXITSTATUS (status) : 127);
+      exit (octave_wait::ifexited (status)
+            ? octave_wait::exitstatus (status) : 127);
     }
 
 #endif
 }
 
 int
 octave_start_gui (int argc, char *argv[])
 {
   dissociate_terminal ();
 
+  setenv ("GNUTERM", "qt", 1);
+
   QApplication application (argc, argv);
 
   while (true)
     {
       if (resource_manager::is_first_run ())
         {
           welcome_wizard welcomeWizard;
           welcomeWizard.exec ();
@@ -101,15 +105,16 @@ octave_start_gui (int argc, char *argv[]
           QString translatorFile = resource_manager::find_translator_file (language);
           QTranslator translator;
           translator.load (translatorFile);
           application.installTranslator (&translator);
 
           resource_manager::update_network_settings ();
 
           main_window w;
+          w.read_settings ();  // Get the widget settings after construction and before showing
           w.show ();
           w.focus_command_window ();
 
           return application.exec ();
         }
     }
 }
diff --git a/libgui/src/octave-gui.h b/libgui/src/octave-gui.h
--- a/libgui/src/octave-gui.h
+++ b/libgui/src/octave-gui.h
@@ -18,11 +18,11 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_octave_gui_h)
 #define octave_octave_gui_h 1
 
-extern int octave_start_gui (int argc, char **argv);
+extern OCTGUI_API int octave_start_gui (int argc, char **argv);
 
 #endif
diff --git a/libgui/src/octave-qt-event-listener.cc b/libgui/src/octave-qt-event-listener.cc
--- a/libgui/src/octave-qt-event-listener.cc
+++ b/libgui/src/octave-qt-event-listener.cc
@@ -15,29 +15,33 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include "octave-qt-event-listener.h"
 #include <QApplication>
 
-octave_qt_event_listener::octave_qt_event_listener (QObject *parent)
-  : QObject (parent), octave_event_listener ()
+octave_qt_event_listener::octave_qt_event_listener (QObject *p)
+  : QObject (p), octave_event_listener ()
 {
 }
 
 void
-octave_qt_event_listener::current_directory_has_changed (std::string directory)
+octave_qt_event_listener::current_directory_has_changed (const std::string& directory)
 {
   emit current_directory_has_changed_signal
-      (QString::fromStdString (directory));
+    (QString::fromStdString (directory));
 }
 
 void
 octave_qt_event_listener::about_to_exit ()
 {
   qApp->quit ();
 }
 
diff --git a/libgui/src/octave-qt-event-listener.h b/libgui/src/octave-qt-event-listener.h
--- a/libgui/src/octave-qt-event-listener.h
+++ b/libgui/src/octave-qt-event-listener.h
@@ -23,27 +23,27 @@ along with Octave; see the file COPYING.
 #ifndef OCTAVEQTEVENTLISTENER_H
 #define OCTAVEQTEVENTLISTENER_H
 
 #include <QObject>
 #include <QString>
 #include "octave-event-listener.h"
 
 class octave_qt_event_listener
-    : public QObject, public octave_event_listener
+  : public QObject, public octave_event_listener
 {
-    Q_OBJECT
+  Q_OBJECT
   public:
-    octave_qt_event_listener (QObject *parent = 0);
+  octave_qt_event_listener (QObject *parent = 0);
 
-    void current_directory_has_changed (std::string directory);
-    void about_to_exit ();
+  void current_directory_has_changed (const std::string& directory);
+  void about_to_exit ();
 
-    void entered_debug_mode ();
-    void quit_debug_mode ();
+  void entered_debug_mode ();
+  void quit_debug_mode ();
 
-  signals:
-    void current_directory_has_changed_signal (QString directory);
-    void entered_debug_mode_signal ();
-    void quit_debug_mode_signal ();
+signals:
+  void current_directory_has_changed_signal (const QString& directory);
+  void entered_debug_mode_signal ();
+  void quit_debug_mode_signal ();
 };
 
 #endif // OCTAVEQTEVENTLISTENER_H
diff --git a/libgui/src/qtinfo/parser.cc b/libgui/src/qtinfo/parser.cc
--- a/libgui/src/qtinfo/parser.cc
+++ b/libgui/src/qtinfo/parser.cc
@@ -12,37 +12,41 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330,
  * Boston, MA 02111-1307, USA.
  */
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include "parser.h"
 #include <QFileInfo>
 #include <QDir>
 #include <QFile>
 #include <QUrl>
 #include <QRegExp>
 #include <QProcess>
 #include <QBuffer>
 
-parser::parser(QObject *parent)
-  : QObject(parent)
+parser::parser(QObject *p)
+  : QObject(p)
 {
   _compressors_map.insert ("bz2",  "bzip2 -dc \"%1\"");
   _compressors_map.insert ("gz",   "gzip -dc \"%1\"");
   _compressors_map.insert ("lzma", "lzma -dc \"%1\"");
   _compressors_map.insert ("xz",   "xz -dc \"%1\"");
   _compressors_map.insert ("Z",    "gunzip -c \"%1\"");
 }
 
 void
-parser::set_info_path (QString infoPath)
+parser::set_info_path (const QString& infoPath)
 {
   this->_info_path = infoPath;
 
   _info_files.clear ();
 
   QFileInfo info (infoPath);
 
   QString path = info.absolutePath ();
@@ -91,30 +95,32 @@ parser::open_file (QFileInfo & file_info
         return NULL;
       iodevice = io;
     }
 
   return iodevice;
 }
 
 int
-parser::is_ref (QString node)
+parser::is_ref (const QString& node)
 {
   if (_ref_map.contains (node))
     {
       node_position ref = _ref_map [node];
 
       return ref.pos-_node_map [ref._node_name].pos;
     }
   return -1;
 }
 
 QString
-parser::search_node (QString node)
+parser::search_node (const QString& node_arg)
 {
+  QString node = node_arg;
+
   QFileInfo file_info;
   QString ref;
 
   if (_ref_map.contains (node))
     {
       ref = node;
       node = _ref_map [ref]._node_name;
     }
@@ -143,17 +149,17 @@ parser::search_node (QString node)
       io->close ();
       delete io;
     }
 
   return QString ();
 }
 
 QString
-parser::search_node (QString node, QIODevice *io)
+parser::search_node (const QString& node, QIODevice *io)
 {
   while (!io->atEnd ())
     {
       QString text = get_next_node (io);
       if(node == get_node_name (text))
         {
           return text;
         }
@@ -177,72 +183,72 @@ parser::get_next_node (QIODevice *io)
         {
           text.append (line);
         }
     }
   return text;
 }
 
 static QString
-get_first_line (QString text)
+get_first_line (const QString& text)
 {
   int n = text.indexOf ("\n");
 
   if (n < 0)
     {
       return QString ();
     }
 
   QString first_line = text.left (n);
   return first_line;
 }
 
 static QString
-parser_node (QString text, QString node_name)
+parser_node (const QString& text, const QString& node_name)
 {
   QString firstLine = get_first_line (text);
   QStringList nodes = firstLine.split (",");
   for (int i = 0;i < nodes.size (); i++)
     {
       QString node = nodes.at (i).trimmed ();
 
       if (node.startsWith (node_name))
         {
           return node.remove (0, node_name.size ()).trimmed ();
         }
     }
   return QString ();
 }
 
 QString
-parser::get_node_name (QString text)
+parser::get_node_name (const QString& text)
 {
   return parser_node (text, "Node:");
 }
 
 QString
-parser::get_node_up (QString text)
+parser::get_node_up (const QString& text)
 {
   return parser_node (text, "Up:");
 }
 
 QString
-parser::get_node_next (QString text)
+parser::get_node_next (const QString& text)
 {
   return parser_node (text, "Next:");
 }
 
 QString
-parser::get_node_prev (QString text)
+parser::get_node_prev (const QString& text)
 {
   return parser_node (text, "Prev:");
 }
 
 static void
-replace_links (QString &text)
+replace_links (QString& text)
 {
   QRegExp re ("(\\*[N|n]ote|\n\\*)([ |\n]+)([^:]+):([^:\\.,]*)([:,\\.])");
   int i = 0, f;
 
   while ( (i = re.indexIn (text,i)) != -1)
     {
       QString type     = re.cap (1);
       QString note     = re.cap (3);
@@ -273,47 +279,50 @@ replace_links (QString &text)
       href += re.cap (2) + "<a href='" + url_link + "'>" + note + ":" + link + re.cap (5) + "</a>";
       f = re.matchedLength ();
       text.replace (i,f,href);
       i += href.size ();
     }
 }
 
 static void
-replace_colons (QString &text)
+replace_colons (QString& text)
 {
   QRegExp re ("`([^']+)'");
   int i = 0, f;
   while ( (i = re.indexIn (text, i)) != -1)
     {
       QString t = re.cap (1);
       QString bold = "<b>`" + t + "</b>'";
 
       f = re.matchedLength ();
       text.replace (i,f,bold);
       i += bold.size ();
     }
 }
 
 static void
-info_to_html (QString &text)
+info_to_html (QString& text)
 {
   text.replace ("&", "&amp;");
   text.replace ("<", "&lt;");
   text.replace (">", "&gt;");
 
   text.replace ("\n* Menu:", "\n<b>Menu:</b>");
   text.replace ("*See also:*", "<b>See also:</b>");
   replace_colons (text);
   replace_links (text);
 }
 
 QString
-parser::node_text_to_html (QString text, int anchorPos, QString anchor)
+parser::node_text_to_html (const QString& text_arg, int anchorPos,
+                           const QString& anchor)
 {
+  QString text = text_arg;
+
   QString nodeName = get_node_name (text);
   QString nodeUp   = get_node_up (text);
   QString nodeNext = get_node_next (text);
   QString nodePrev = get_node_prev (text);
 
   if (anchorPos > -1)
     {
       QString text1 = text.left (anchorPos);
@@ -470,33 +479,33 @@ parser::seek (QIODevice *io, int pos)
   while (!io->atEnd () && pos > 0)
     {
       io->getChar (&ch);
       pos--;
     }
 }
 
 static void
-replace (QString &text, QRegExp re, QString after)
+replace (QString& text, const QRegExp& re, const QString& after)
 {
   int pos = 0;
 
   while ( (pos = re.indexIn (text, pos)) != -1)
     {
       QString cap = text.mid (pos,re.matchedLength ());
       QString a (after);
       a = a.arg (cap);
       text.remove (pos, re.matchedLength ());
       text.insert (pos, a);
       pos += a.size ();
     }
 }
 
 QString
-parser::global_search (QString text, int max_founds)
+parser::global_search (const QString& text, int max_founds)
 {
   QString results;
   QStringList words = text.split (" ",QString::SkipEmptyParts);
 
   QString re_program ("(" + words.at (0));
   for (int i = 1; i < words.size (); i++)
     {
       re_program += "|" + words.at (i);
diff --git a/libgui/src/qtinfo/parser.h b/libgui/src/qtinfo/parser.h
--- a/libgui/src/qtinfo/parser.h
+++ b/libgui/src/qtinfo/parser.h
@@ -19,17 +19,17 @@
 
 #include <QStringList>
 #include <QIODevice>
 #include <QFileInfoList>
 #include <QHash>
 
 /**
  * \class parser
- * This class gets nodes and searchs inside of `info files'.
+ * This class gets nodes and searchs inside of 'info files'.
  * <p>Each info file has nodes. Every node has the documentation.
  * Info files contains a map with position of each node.</p>
  * <p>What is position?
  * There is a simple answer:
  * If you make a queue with info files, position will be the number of bytes
  * from begining to node position.</p>
  * <p>
  * But is not so easy. There is headers, and qtinfo must not take these headers into account.
@@ -40,30 +40,31 @@
  */
 class parser
     : public QObject
 {
   Q_OBJECT
 
 public:
   parser (QObject *parent = 0);
-  void set_info_path (QString _info_path);
+  void set_info_path (const QString& _info_path);
   QString get_info_path ();
-  QString search_node (QString node);
-  QString global_search (QString text, int maxFounds);
+  QString search_node (const QString& node);
+  QString global_search (const QString& text, int maxFounds);
 
   /** Checks if this node is reference. If node is reference, it will be returned its position
     * in text, else  it will be returned -1.
     */
-  int is_ref (QString node);
+  int is_ref (const QString& node);
 
   /**Translates text of node to Html. If anchorPos is not -1, then anchor is inserted in that
     * position.
     */
-  QString node_text_to_html (QString text, int anchorPos=-1, QString anchor=QString());
+  QString node_text_to_html (const QString& text, int anchorPos = -1,
+                             const QString& anchor = QString ());
 
 private:
   struct node_position
   {
     QString _node_name;
     int pos;
   };
 
@@ -73,22 +74,22 @@ private:
   };
 
   struct info_file_item
   {
     QFileInfo file_info;
     int real_size;
   };
 
-  QString search_node (QString node, QIODevice * io);
+  QString search_node (const QString& node, QIODevice * io);
   QString get_next_node (QIODevice * io);
-  QString get_node_name (QString text);
-  QString get_node_up (QString text);
-  QString get_node_next (QString text);
-  QString get_node_prev (QString text);
+  QString get_node_name (const QString& text);
+  QString get_node_up (const QString& text);
+  QString get_node_next (const QString& text);
+  QString get_node_prev (const QString& text);
 
   /** Parses info files and gets map of node positions.*/
   void parse_info_map();
 
   /** Open info files and uncompress them. */
   QIODevice *open_file(QFileInfo & fileInfo);
 
   /** Calculates real position of nodes.
diff --git a/libgui/src/qtinfo/webinfo.cc b/libgui/src/qtinfo/webinfo.cc
--- a/libgui/src/qtinfo/webinfo.cc
+++ b/libgui/src/qtinfo/webinfo.cc
@@ -12,87 +12,97 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330,
  * Boston, MA 02111-1307, USA.
  */
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include "webinfo.h"
 #include <QVBoxLayout>
 #include <QHBoxLayout>
 
+#include "file-ops.h"
+#include "help.h"
+#include "defaults.h"
 
-webinfo::webinfo (QWidget *parent)
-  :QWidget (parent)
+
+webinfo::webinfo (QWidget *p)
+  : QWidget (p)
 {
   _font_web = font ();
 
-  QVBoxLayout *layout = new QVBoxLayout ();
-  layout->setMargin (0);
-  setLayout (layout);
+  QVBoxLayout *vbox_layout = new QVBoxLayout ();
+  vbox_layout->setMargin (0);
+  setLayout (vbox_layout);
 
-  QHBoxLayout *hboxLayout = new QHBoxLayout ();
-  hboxLayout->setMargin (2);
-  layout->addLayout (hboxLayout);
+  QHBoxLayout *hbox_layout = new QHBoxLayout ();
+  hbox_layout->setMargin (2);
+  vbox_layout->addLayout (hbox_layout);
 
   _close_tab_button = new QPushButton (this);
   _close_tab_button->setSizePolicy (QSizePolicy::Fixed,QSizePolicy::Preferred);
   _close_tab_button->setIcon (QIcon (":/actions/icons/stop.png"));
-  hboxLayout->addWidget (_close_tab_button);
+  hbox_layout->addWidget (_close_tab_button);
 
   _tab_bar = new QTabBar (this);
   _tab_bar->setSizePolicy (QSizePolicy::Preferred,QSizePolicy::Preferred);
   _tab_bar->setExpanding (false);
-  hboxLayout->addWidget (_tab_bar);
+  hbox_layout->addWidget (_tab_bar);
 
   _zoom_in_button = new QToolButton (this);
   _zoom_in_button->setSizePolicy (QSizePolicy::Fixed,QSizePolicy::Preferred);
   _zoom_in_button->setIcon (QIcon (":/actions/icons/zoom-in.png"));
-  hboxLayout->addWidget (_zoom_in_button);
+  hbox_layout->addWidget (_zoom_in_button);
 
   _zoom_out_button = new QToolButton (this);
   _zoom_out_button->setSizePolicy (QSizePolicy::Fixed,QSizePolicy::Preferred);
   _zoom_out_button->setIcon (QIcon (":/actions/icons/zoom-out.png"));
-  hboxLayout->addWidget (_zoom_out_button);
+  hbox_layout->addWidget (_zoom_out_button);
 
   _stacked_widget = new QStackedWidget (this);
-  layout->addWidget (_stacked_widget);
+  vbox_layout->addWidget (_stacked_widget);
 
-  hboxLayout = new QHBoxLayout ();
-  layout->addLayout (hboxLayout);
+  hbox_layout = new QHBoxLayout ();
+  vbox_layout->addLayout (hbox_layout);
 
   _search_line_edit = new QLineEdit(this);
+#ifdef HAVE_SETPLACEHOLDERTEXT
   _search_line_edit->setPlaceholderText (tr ("Type here and press \'Return\' to search"));
-  hboxLayout->addWidget (_search_line_edit);
+#endif
+  hbox_layout->addWidget (_search_line_edit);
 
   _search_check_box = new QCheckBox (tr ("Global search"));
-  hboxLayout->addWidget (_search_check_box);
+  hbox_layout->addWidget (_search_check_box);
 
   connect (_close_tab_button, SIGNAL (clicked ()), this, SLOT (close_tab ()));
   connect (_tab_bar, SIGNAL (currentChanged (int)), this, SLOT (current_tab_changed (int)));
   connect (_zoom_in_button, SIGNAL (clicked ()), this, SLOT (zoom_in ()));
   connect (_zoom_out_button, SIGNAL (clicked ()), this, SLOT (zoom_out ()));
   connect (_search_line_edit, SIGNAL (returnPressed ()), this, SLOT (search ()));
 
   resize (500, 300);
 
-  set_info_path ("../../doc/interpreter/octave.info");
+  set_info_path (QString::fromStdString (Vinfo_file));
 }
 
 void
-webinfo::set_info_path (QString info_path)
+webinfo::set_info_path (const QString& info_path)
 {
   _parser.set_info_path (info_path);
   load_node ("Top");
 }
 
 void
-webinfo::load_node (QString node_name)
+webinfo::load_node (const QString& node_name)
 {
   //Check if node has been already opened.
   for (int i = 0;i < _tab_bar->count (); i++)
     {
       if (node_name == _tab_bar->tabText (i))
         {
           _tab_bar->setCurrentIndex (i);
           return;
@@ -115,45 +125,45 @@ webinfo::link_clicked (const QUrl & link
 {
   QString node = link.toString ();
   load_node (node);
 }
 
 void
 webinfo::current_tab_changed (int index)
 {
-  QVariant data = _tab_bar->tabData (index);
-  _text_browser = (QTextBrowser*) (data.value<void*> ());
+  QVariant tab_data = _tab_bar->tabData (index);
+  _text_browser = static_cast<QTextBrowser*> (tab_data.value<void*> ());
 
   _stacked_widget->setCurrentIndex (_stacked_widget->indexOf (_text_browser));
 
   if (_text_browser->font () != _font_web)
     {
       _text_browser->setFont (_font_web);
     }
 }
 
 QTextBrowser *
-webinfo::addNewTab(QString name)
+webinfo::addNewTab (const QString& name)
 {
   _text_browser = new QTextBrowser (this);
   _text_browser->setOpenLinks (false);
   _text_browser->show ();
 
   connect (_text_browser, SIGNAL (anchorClicked (const QUrl &)), this, SLOT (link_clicked (const QUrl &)) );
   disconnect(_tab_bar, SIGNAL (currentChanged(int)), this, SLOT (current_tab_changed (int)));
 
   int ns = _stacked_widget->addWidget (_text_browser);
   _stacked_widget->setCurrentIndex (ns);
 
   int nt = _tab_bar->addTab (name);
   _tab_bar->setCurrentIndex (nt);
-  QVariant data;
-  data.setValue ( (void*)_text_browser);
-  _tab_bar->setTabData (nt, data);
+  QVariant tab_data;
+  tab_data.setValue (static_cast<void*> (_text_browser));
+  _tab_bar->setTabData (nt, tab_data);
 
   connect (_tab_bar, SIGNAL (currentChanged (int)), this, SLOT (current_tab_changed (int)));
 
   if (_text_browser->font () != _font_web)
     {
       _text_browser->setFont (_font_web);
     }
   return _text_browser;
@@ -165,18 +175,18 @@ webinfo::close_tab ()
   int index = _tab_bar->currentIndex ();
   if (_tab_bar->tabText (index) != "Top")
     closeTab (index);
 }
 
 void
 webinfo::closeTab (int index)
 {
-  QVariant data = _tab_bar->tabData (index);
-  QWidget *w = (QWidget*) (data.value<void*> ());
+  QVariant tab_data = _tab_bar->tabData (index);
+  QWidget *w = static_cast<QWidget*> (tab_data.value<void*> ());
   _stacked_widget->removeWidget (w);
   delete w;
 
   _tab_bar->removeTab (index);
 }
 
 void
 webinfo::search ()
diff --git a/libgui/src/qtinfo/webinfo.h b/libgui/src/qtinfo/webinfo.h
--- a/libgui/src/qtinfo/webinfo.h
+++ b/libgui/src/qtinfo/webinfo.h
@@ -26,21 +26,21 @@
 #include <QCheckBox>
 #include <QToolButton>
 
 class webinfo : public QWidget
 {
   Q_OBJECT
 public:
   webinfo (QWidget *parent = 0);
-  void set_info_path (QString info_path);
-  void load_node (QString node_name);
+  void set_info_path (const QString& info_path);
+  void load_node (const QString& node_name);
 
 public slots:
-  void link_clicked (const QUrl &link);
+  void link_clicked (const QUrl& link);
   void current_tab_changed (int index);
   void close_tab ();
   void search ();
   void zoom_in ();
   void zoom_out ();
 
 private:
   QTextBrowser        *_text_browser;
@@ -50,11 +50,11 @@ private:
   QLineEdit           *_search_line_edit;
   QCheckBox           *_search_check_box;
   QToolButton         *_zoom_in_button;
   QToolButton         *_zoom_out_button;
 
   parser              _parser;
   QFont               _font_web;
 
-  QTextBrowser *addNewTab (QString name);
+  QTextBrowser *addNewTab (const QString& name);
   void closeTab(int index);
 };
diff --git a/libgui/src/resource-manager.cc b/libgui/src/resource-manager.cc
--- a/libgui/src/resource-manager.cc
+++ b/libgui/src/resource-manager.cc
@@ -48,17 +48,17 @@ resource_manager::resource_manager (void
 }
 
 resource_manager::~resource_manager (void)
 {
   delete settings;
 }
 
 QString
-resource_manager::find_translator_file (QString language)
+resource_manager::find_translator_file (const QString& language)
 {
   // TODO: Quick hack to be able to test language files.
   return QString ("../languages/%1.qm").arg (language);
 }
 
 bool
 resource_manager::instance_ok (void)
 {
@@ -109,30 +109,30 @@ void
 resource_manager::do_reload_settings (void)
 {
   QDesktopServices desktopServices;
   home_path = desktopServices.storageLocation (QDesktopServices::HomeLocation);
   QString settings_path = home_path + "/.config/octave/";
   QString settings_file = settings_path + "qt-settings";
 
   if (!QFile::exists (settings_file))
-   {
-     QDir("/").mkpath (settings_path);
-     QFile::copy (QString::fromStdString (default_qt_settings_file ()),
-                  settings_file);
-     first_run = true;
-   }
+    {
+      QDir("/").mkpath (settings_path);
+      QFile::copy (QString::fromStdString (default_qt_settings_file ()),
+                   settings_file);
+      first_run = true;
+    }
   else
-     first_run = false;
+    first_run = false;
 
   do_set_settings (settings_file);
 }
 
 void
-resource_manager::do_set_settings (QString file)
+resource_manager::do_set_settings (const QString& file)
 {
   delete settings;
   settings = new QSettings (file, QSettings::IniFormat);
 }
 
 bool
 resource_manager::do_is_first_run (void)
 {
@@ -306,16 +306,17 @@ resource_manager::octave_keywords (void)
       "__pchip_deriv__ "
       "__plt_get_axis_arg__ "
       "__print_parse_opts__ "
       "__qp__ "
       "__request_drawnow__ "
       "__sort_rows_idx__ "
       "__strip_html_tags__ "
       "__token_count__ "
+      "__unimplemented__ "
       "__varval__ "
       "__version_info__ "
       "__voronoi__ "
       "__which__ "
       "abs "
       "accumarray "
       "accumdim "
       "acos "
@@ -1633,17 +1634,16 @@ resource_manager::octave_keywords (void)
       "unidcdf "
       "unidinv "
       "unidpdf "
       "unidrnd "
       "unifcdf "
       "unifinv "
       "unifpdf "
       "unifrnd "
-      "unimplemented "
       "union "
       "unique "
       "unix "
       "unlink "
       "unmark_command "
       "unmark_rawcommand "
       "unmkpp "
       "unpack "
diff --git a/libgui/src/resource-manager.h b/libgui/src/resource-manager.h
--- a/libgui/src/resource-manager.h
+++ b/libgui/src/resource-manager.h
@@ -49,23 +49,23 @@ public:
   }
 
   static void reload_settings (void)
   {
     if (instance_ok ())
       instance->do_reload_settings ();
   }
 
-  static void set_settings (QString file)
+  static void set_settings (const QString& file)
   {
     if (instance_ok ())
       instance->do_set_settings (file);
   }
 
-  static QString find_translator_file (QString language);
+  static QString find_translator_file (const QString& language);
 
   static void update_network_settings (void)
   {
     if (instance_ok ())
       instance->do_update_network_settings ();
   }
 
   static bool is_first_run (void)
@@ -96,16 +96,16 @@ private:
   bool first_run;
 
   QSettings *do_get_settings (void);
 
   QString do_get_home_path (void);
 
   void do_reload_settings (void);
 
-  void do_set_settings (QString file);
+  void do_set_settings (const QString& file);
 
   void do_update_network_settings (void);
 
   bool do_is_first_run (void);
 };
 
 #endif // RESOURCEMANAGER_H
diff --git a/libgui/src/settings-dialog.cc b/libgui/src/settings-dialog.cc
--- a/libgui/src/settings-dialog.cc
+++ b/libgui/src/settings-dialog.cc
@@ -15,38 +15,43 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include "resource-manager.h"
 #include "settings-dialog.h"
 #include "ui-settings-dialog.h"
 #include <QSettings>
 
-settings_dialog::settings_dialog (QWidget * parent):
-QDialog (parent), ui (new Ui::settings_dialog)
+settings_dialog::settings_dialog (QWidget *p):
+  QDialog (p), ui (new Ui::settings_dialog)
 {
   ui->setupUi (this);
 
   QSettings *settings = resource_manager::get_settings ();
 
   // FIXME -- what should happen if settings is 0?
 
   ui->useCustomFileEditor->setChecked (settings->value ("useCustomFileEditor").toBool ());
   ui->customFileEditor->setText (settings->value ("customFileEditor").toString ());
   ui->editor_showLineNumbers->setChecked (settings->value ("editor/showLineNumbers",true).toBool () );
   ui->editor_highlightCurrentLine->setChecked (settings->value ("editor/highlightCurrentLine",true).toBool () );
   ui->editor_codeCompletion->setChecked (settings->value ("editor/codeCompletion",true).toBool () );
   ui->editor_fontName->setCurrentFont (QFont (settings->value ("editor/fontName","Courier").toString()) );
   ui->editor_fontSize->setValue (settings->value ("editor/fontSize",10).toInt ());
-  ui->editor_longWindowTitle->setChecked (settings->value ("editor/longWindowTitle",true).toBool ());
+  ui->editor_longWindowTitle->setChecked (settings->value ("editor/longWindowTitle",false).toBool ());
+  ui->editor_restoreSession->setChecked (settings->value ("editor/restoreSession",true).toBool ());
   ui->terminal_fontName->setCurrentFont (QFont (settings->value ("terminal/fontName","Courier").toString()) );
   ui->terminal_fontSize->setValue (settings->value ("terminal/fontSize",10).toInt ());
   ui->showFilenames->setChecked (settings->value ("showFilenames").toBool());
   ui->showFileSize->setChecked (settings->value ("showFileSize").toBool());
   ui->showFileType->setChecked (settings->value ("showFileType").toBool());
   ui->showLastModified->setChecked (settings->value ("showLastModified").toBool());
   ui->showHiddenFiles->setChecked (settings->value ("showHiddenFiles").toBool());
   ui->useAlternatingRowColors->setChecked (settings->value ("useAlternatingRowColors").toBool());
@@ -80,28 +85,35 @@ QDialog (parent), ui (new Ui::settings_d
 
   ui->proxyPort->setText (settings->value ("proxyPort").toString ());
   ui->proxyUserName->setText (settings->value ("proxyUserName").toString ());
   ui->proxyPassword->setText (settings->value ("proxyPassword").toString ());
 }
 
 settings_dialog::~settings_dialog ()
 {
+  delete ui;
+}
+
+void
+settings_dialog::write_changed_settings ()
+{
   QSettings *settings = resource_manager::get_settings ();
 
   // FIXME -- what should happen if settings is 0?
 
   settings->setValue ("useCustomFileEditor", ui->useCustomFileEditor->isChecked ());
   settings->setValue ("customFileEditor", ui->customFileEditor->text ());
   settings->setValue ("editor/showLineNumbers", ui->editor_showLineNumbers->isChecked ());
   settings->setValue ("editor/highlightCurrentLine", ui->editor_highlightCurrentLine->isChecked ());
   settings->setValue ("editor/codeCompletion", ui->editor_codeCompletion->isChecked ());
   settings->setValue ("editor/fontName", ui->editor_fontName->currentFont().family());
   settings->setValue ("editor/fontSize", ui->editor_fontSize->value());
   settings->setValue ("editor/longWindowTitle", ui->editor_longWindowTitle->isChecked());
+  settings->setValue ("editor/restoreSession", ui->editor_restoreSession->isChecked ());
   settings->setValue ("terminal/fontSize", ui->terminal_fontSize->value());
   settings->setValue ("terminal/fontName", ui->terminal_fontName->currentFont().family());
   settings->setValue ("showFilenames", ui->showFilenames->isChecked ());
   settings->setValue ("showFileSize", ui->showFileSize->isChecked ());
   settings->setValue ("showFileType", ui->showFileType->isChecked ());
   settings->setValue ("showLastModified", ui->showLastModified->isChecked ());
   settings->setValue ("showHiddenFiles", ui->showHiddenFiles->isChecked ());
   settings->setValue ("useAlternatingRowColors", ui->useAlternatingRowColors->isChecked ());
@@ -117,10 +129,9 @@ settings_dialog::~settings_dialog ()
   switch (ui->terminal_cursorType->currentIndex ())
     {
     case 0: cursorType = "ibeam"; break;
     case 1: cursorType = "block"; break;
     case 2: cursorType = "underline";  break;
     }
   settings->setValue ("terminal/cursorType", cursorType);
   settings->sync ();
-  delete ui;
 }
diff --git a/libgui/src/settings-dialog.h b/libgui/src/settings-dialog.h
--- a/libgui/src/settings-dialog.h
+++ b/libgui/src/settings-dialog.h
@@ -27,17 +27,18 @@ along with Octave; see the file COPYING.
 
 namespace Ui
 {
   class settings_dialog;
 }
 
 class settings_dialog:public QDialog
 {
-Q_OBJECT public:
+  Q_OBJECT public:
   explicit settings_dialog (QWidget * parent);
   ~settings_dialog ();
+  void write_changed_settings ();
 
 private:
   Ui::settings_dialog * ui;
 };
 
 #endif // SETTINGSDIALOG_H
diff --git a/libgui/src/settings-dialog.ui b/libgui/src/settings-dialog.ui
--- a/libgui/src/settings-dialog.ui
+++ b/libgui/src/settings-dialog.ui
@@ -98,32 +98,26 @@
          <item>
           <widget class="QCheckBox" name="editor_showLineNumbers">
            <property name="enabled">
             <bool>true</bool>
            </property>
            <property name="text">
             <string>Show line numbers</string>
            </property>
-           <property name="checked">
-            <bool>false</bool>
-           </property>
           </widget>
          </item>
          <item>
           <widget class="QCheckBox" name="editor_highlightCurrentLine">
            <property name="enabled">
             <bool>true</bool>
            </property>
            <property name="text">
             <string>Highlight current line</string>
            </property>
-           <property name="checked">
-            <bool>false</bool>
-           </property>
           </widget>
          </item>
          <item>
           <widget class="QCheckBox" name="editor_codeCompletion">
            <property name="enabled">
             <bool>true</bool>
            </property>
            <property name="text">
@@ -136,16 +130,23 @@
          </item>
          <item>
           <widget class="QCheckBox" name="editor_longWindowTitle">
            <property name="text">
             <string>Show complete path in window title</string>
            </property>
           </widget>
          </item>
+         <item>
+          <widget class="QCheckBox" name="editor_restoreSession">
+           <property name="text">
+            <string>Restore tabs from previous session on startup</string>
+           </property>
+          </widget>
+         </item>
         </layout>
        </item>
        <item>
         <spacer name="verticalSpacer">
          <property name="orientation">
           <enum>Qt::Vertical</enum>
          </property>
          <property name="sizeHint" stdset="0">
@@ -482,16 +483,23 @@
           </widget>
          </item>
         </layout>
        </item>
       </layout>
      </widget>
     </widget>
    </item>
+   <item>
+    <widget class="QDialogButtonBox" name="buttonBox">
+     <property name="standardButtons">
+      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
+     </property>
+    </widget>
+   </item>
   </layout>
  </widget>
  <resources/>
  <connections>
   <connection>
    <sender>useProxyServer</sender>
    <signal>toggled(bool)</signal>
    <receiver>label_4</receiver>
@@ -615,48 +623,16 @@
     </hint>
     <hint type="destinationlabel">
      <x>67</x>
      <y>212</y>
     </hint>
    </hints>
   </connection>
   <connection>
-   <sender>editor_showLineNumbers</sender>
-   <signal>toggled(bool)</signal>
-   <receiver>editor_showLineNumbers</receiver>
-   <slot>setEnabled(bool)</slot>
-   <hints>
-    <hint type="sourcelabel">
-     <x>249</x>
-     <y>87</y>
-    </hint>
-    <hint type="destinationlabel">
-     <x>249</x>
-     <y>87</y>
-    </hint>
-   </hints>
-  </connection>
-  <connection>
-   <sender>editor_highlightCurrentLine</sender>
-   <signal>toggled(bool)</signal>
-   <receiver>editor_highlightCurrentLine</receiver>
-   <slot>setEnabled(bool)</slot>
-   <hints>
-    <hint type="sourcelabel">
-     <x>249</x>
-     <y>112</y>
-    </hint>
-    <hint type="destinationlabel">
-     <x>249</x>
-     <y>112</y>
-    </hint>
-   </hints>
-  </connection>
-  <connection>
    <sender>useProxyServer</sender>
    <signal>toggled(bool)</signal>
    <receiver>proxyUserName</receiver>
    <slot>setEnabled(bool)</slot>
    <hints>
     <hint type="sourcelabel">
      <x>249</x>
      <y>59</y>
@@ -695,25 +671,41 @@
     </hint>
     <hint type="destinationlabel">
      <x>68</x>
      <y>182</y>
     </hint>
    </hints>
   </connection>
   <connection>
-   <sender>editor_codeCompletion</sender>
-   <signal>toggled(bool)</signal>
-   <receiver>editor_codeCompletion</receiver>
-   <slot>setEnabled(bool)</slot>
+   <sender>buttonBox</sender>
+   <signal>accepted()</signal>
+   <receiver>settings_dialog</receiver>
+   <slot>accept()</slot>
    <hints>
     <hint type="sourcelabel">
-     <x>249</x>
-     <y>137</y>
+     <x>299</x>
+     <y>366</y>
     </hint>
     <hint type="destinationlabel">
-     <x>249</x>
-     <y>137</y>
+     <x>299</x>
+     <y>199</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>buttonBox</sender>
+   <signal>rejected()</signal>
+   <receiver>settings_dialog</receiver>
+   <slot>reject()</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>299</x>
+     <y>366</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>299</x>
+     <y>199</y>
     </hint>
    </hints>
   </connection>
  </connections>
 </ui>
diff --git a/libgui/src/symbol-information.cc b/libgui/src/symbol-information.cc
--- a/libgui/src/symbol-information.cc
+++ b/libgui/src/symbol-information.cc
@@ -26,45 +26,59 @@ along with Octave; see the file COPYING.
 
 #include <QString>
 
 #include "ov.h"
 #include "symtab.h"
 
 #include "symbol-information.h"
 
-bool
-symbol_information::from_symbol_record
-  (const symbol_table::symbol_record& symbol_record)
+symbol_information::symbol_information (const symbol_table::symbol_record& sr)
 {
-  if (symbol_record.is_local () && !symbol_record.is_global () && !symbol_record.is_hidden ())
+  if (sr.is_local () && !sr.is_global () && !sr.is_hidden ())
     _scope = local;
-  else if (symbol_record.is_global ())
+  else if (sr.is_global ())
     _scope = global;
-  else if (symbol_record.is_persistent ())
+  else if (sr.is_persistent ())
     _scope = persistent;
-  else if (symbol_record.is_hidden ())
-    _scope = hidden;
+  else
+    _scope = unknown;
 
-  _symbol = QString (symbol_record.name ().c_str ());
-  _type   = QString (symbol_record.varval ().type_name ().c_str ());
-  octave_value ov = symbol_record.varval ();
+  _symbol = QString (sr.name ().c_str ());
+  _class_name = QString (sr.varval ().class_name ().c_str ());
+  octave_value ov = sr.varval ();
+  dim_vector dv = ov.dims ();
 
   // In case we have really large matrices or strings, cut them down
   // for performance reasons.
   QString short_value_string;
   bool use_short_value_string = false;
-  if (ov.is_matrix_type () || ov.is_cell ())
+  if (ov.is_range ())
     {
-      if (ov.rows () * ov.columns () > 10)
-        {
-          use_short_value_string = true;
-          short_value_string
-            = QString ("%1x%2 items").arg (ov.rows ()).arg (ov.columns ());
-        }
+      use_short_value_string = true;
+
+      Range r = ov.range_value ();
+
+      double base = r.base ();
+      double increment = r.base ();
+      double limit = r.base ();
+
+      std::stringstream buffer;
+
+      buffer << base << ":";
+      if (increment != 1 )
+        buffer << increment << ":";
+      buffer << limit;
+
+      short_value_string = QString::fromStdString (buffer.str ());
+    }
+  else if (ov.is_matrix_type () || ov.is_cell ())
+    {
+      if (ov.numel () > 10)
+        use_short_value_string = true;
     }
   else if (ov.is_string ())
     {
       if (ov.string_value ().length () > 40)
         {
           use_short_value_string = true;
           short_value_string
             = QString::fromStdString (ov.string_value ().substr (0, 40));
@@ -78,28 +92,13 @@ symbol_information::from_symbol_record
   else
     {
       std::stringstream buffer;
       ov.print (buffer, true);
       _value  = QString::fromStdString (buffer.str ());
     }
   _value.replace("\n", " ");
 
-  if (ov.is_string ())
-    _dimension = QString ("%1").arg (ov.string_value ().length ());
-  else if (ov.is_range ())
-    _dimension =  QString ("%1 : %2 : %3").arg (ov.range_value ().base ())
-      .arg (ov.range_value ().inc ())
-      .arg (ov.range_value ().limit ());
-  else if (ov.is_matrix_type () || ov.is_cell ())
-    _dimension = QString ("%1x%2").arg (ov.rows ())
-      .arg (ov.columns ());
-  else if (ov.is_function_handle ())
-    // See code for func2str for a possible solution
-    _dimension = QString ("func handle");
-  else if (ov.is_inline_function ())
-    // See code for formula for a possible solution
-    _dimension = QString ("inline func");
-  else
-    _dimension = "1";
+  _dimension = QString::fromStdString (dv.str ());
 
-  return true;
+  _hash = _scope + qHash (_symbol) + qHash (_class_name) + qHash (_value)
+    + qHash (_dimension);
 }
diff --git a/libgui/src/symbol-information.h b/libgui/src/symbol-information.h
--- a/libgui/src/symbol-information.h
+++ b/libgui/src/symbol-information.h
@@ -21,71 +21,94 @@ along with Octave; see the file COPYING.
 */
 
 #ifndef SYMBOLINFORMATION_H
 #define SYMBOLINFORMATION_H
 
 // FIXME -- we should not be including config.h in header files.
 
 #ifdef HAVE_CONFIG_H
-#include "config.h"
+#include <config.h>
 #endif
 
 #include <QString>
 #include <QHash>
 
-#include <sstream>
-
 #include "symtab.h"
 
 /**
-  * \struct symbol_information
-  * \brief Meta-information over a symbol-table entry.
-  * \author Jacob Dawid
-  * This struct is used to store meta information over a symbol entry.
-  * It reduces memory consumption, since it only stores relevant data
-  * about a symbol-table entry that will be used in the model for the
-  * graphical user interface.
-  */
-struct symbol_information
+ * \struct symbol_information
+ * \brief Meta-information over a symbol-table entry.
+ * \author Jacob Dawid
+ * This struct is used to store meta information over a symbol entry.
+ * It reduces memory consumption, since it only stores relevant data
+ * about a symbol-table entry that will be used in the model for the
+ * graphical user interface.
+ */
+class symbol_information
 {
+public:
+
   enum Scope
+    {
+      unknown     = 0,
+      local       = 1,
+      global      = 2,
+      persistent  = 3
+    };
+
+  symbol_information (const symbol_table::symbol_record& symbol_record);
+
+  symbol_information (const symbol_information& x)
+    : _scope (x._scope), _symbol (x._symbol), _class_name (x._class_name),
+      _value (x._value), _dimension (x._dimension), _hash (x._hash)
+  { }
+
+  symbol_information operator = (const symbol_information& x)
   {
-    local       = 0,
-    global      = 1,
-    persistent  = 2,
-    hidden      = 3
-  };
+    if (this != &x)
+      {
+        _scope = x._scope;
+        _symbol = x._symbol;
+        _class_name = x._class_name;
+        _value = x._value;
+        _dimension = x._dimension;
+        _hash = x._hash;
+      }
+
+    return *this;
+  }
+
+  ~symbol_information (void) { }
+
+  QString symbol (void) const { return _symbol; }
+  QString class_name (void) const { return _class_name; }
+  QString value (void) const { return _value; }
+  QString dimension (void) const { return _dimension; }
+  Scope scope (void) const { return _scope; }
+
+  friend bool
+  operator == (const symbol_information& a, const symbol_information& b)
+  {
+    return (a.hash () == b.hash ()
+            && a.scope () == b.scope ()
+            && a.symbol () == b.symbol ()
+            && a.class_name () == b.class_name ()
+            && a.value () == b.value ()
+            && a.dimension () == b.dimension ());
+  }
+
+private:
+
+  // FIXME -- this is not really the scope of the symbol.
+  Scope _scope;
 
   QString _symbol;
-  QString _type;
+  QString _class_name;
   QString _value;
   QString _dimension;
-  Scope   _scope;
-
-  /** Hashes the symbol information for quickly comparing it. */
-  int
-  hash () const
-  {
-    return qHash (_symbol) + qHash (_type) + qHash (_value)
-      + qHash (_dimension) + (int)_scope;
-  }
 
-  /** Compares two symbol information objects. */
-  bool
-  equals (const symbol_information& other) const
-  {
-    if (hash () == other.hash ())
-      {
-        return _symbol == other._symbol
-            && _type   == other._type
-            && _value  == other._value
-            && _scope  == other._scope
-            && _dimension == other._dimension;
-      }
-  }
+  int _hash;
 
-  /** Extracts meta information from a given symbol record. */
-  bool
-  from_symbol_record (const symbol_table::symbol_record& symbol_record);
+  int hash (void) const { return _hash; }
 };
 
 #endif // SYMBOLINFORMATION_H
diff --git a/libgui/src/terminal-dockwidget.cc b/libgui/src/terminal-dockwidget.cc
--- a/libgui/src/terminal-dockwidget.cc
+++ b/libgui/src/terminal-dockwidget.cc
@@ -15,19 +15,37 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include "terminal-dockwidget.h"
 
-terminal_dock_widget::terminal_dock_widget (QTerminal *terminal, QWidget *parent)
-  : QDockWidget (parent)
+terminal_dock_widget::terminal_dock_widget (QTerminal *terminal, QWidget *p)
+  : QDockWidget (p)
 {
   setObjectName ("TerminalDockWidget");
+  setWindowIcon (QIcon(":/actions/icons/logo.png"));
   setWindowTitle (tr ("Command Window"));
   setWidget (terminal);
 
   connect (this, SIGNAL (visibilityChanged (bool)), this, SLOT (handle_visibility_changed (bool)));
+  // topLevelChanged is emitted when floating property changes (floating = true)
+  connect (this, SIGNAL (topLevelChanged(bool)), this, SLOT(top_level_changed(bool)));
 }
+
+// slot for signal that is emitted when floating property changes
+void
+terminal_dock_widget::top_level_changed (bool floating)
+{
+  if(floating)
+    {
+      setWindowFlags(Qt::Window);  // make a window from the widget when floating
+      show();                      // make it visible again since setWindowFlags hides it
+    }
+}
diff --git a/libgui/src/terminal-dockwidget.h b/libgui/src/terminal-dockwidget.h
--- a/libgui/src/terminal-dockwidget.h
+++ b/libgui/src/terminal-dockwidget.h
@@ -24,23 +24,25 @@ along with Octave; see the file COPYING.
 #define TERMINALDOCKWIDGET_H
 
 #include <QDockWidget>
 #include "QTerminal.h"
 
 class terminal_dock_widget : public QDockWidget
 {
   Q_OBJECT
-public:
+  public:
   terminal_dock_widget (QTerminal *terminal, QWidget *parent = 0);
 
 signals:
-    void active_changed (bool active);
+  void active_changed (bool active);
 
 public slots:
-    void handle_visibility_changed (bool visible)
-    {
-      if (visible)
-        emit active_changed (true);
-    }
+  void handle_visibility_changed (bool visible)
+  {
+    if (visible)
+      emit active_changed (true);
+  }
+  /** Slot when floating property changes */
+  void top_level_changed (bool floating);
 };
 
 #endif // TERMINALDOCKWIDGET_H
diff --git a/libgui/src/welcome-wizard.cc b/libgui/src/welcome-wizard.cc
--- a/libgui/src/welcome-wizard.cc
+++ b/libgui/src/welcome-wizard.cc
@@ -15,22 +15,25 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include "welcome-wizard.h"
 #include "ui-welcome-wizard.h"
 
-welcome_wizard::welcome_wizard (QWidget *parent) :
-  QDialog (parent),
-  _ui (new Ui::welcome_wizard)
+welcome_wizard::welcome_wizard (QWidget *p)
+  : QDialog (p), _ui (new Ui::welcome_wizard)
 {
   _ui->setupUi (this);
   connect (_ui->nextButton1, SIGNAL (clicked ()), this, SLOT (next ()));
   connect (_ui->nextButton2, SIGNAL (clicked ()), this, SLOT (next ()));
   connect (_ui->nextButton3, SIGNAL (clicked ()), this, SLOT (next ()));
   connect (_ui->nextButton4, SIGNAL (clicked ()), this, SLOT (next ()));
 
   connect (_ui->previousButton2, SIGNAL (clicked ()), this, SLOT (previous ()));
diff --git a/libgui/src/welcome-wizard.h b/libgui/src/welcome-wizard.h
--- a/libgui/src/welcome-wizard.h
+++ b/libgui/src/welcome-wizard.h
@@ -21,24 +21,24 @@ along with Octave; see the file COPYING.
 */
 
 #ifndef WELCOMEWIZARD_H
 #define WELCOMEWIZARD_H
 
 #include <QDialog>
 
 namespace Ui {
-    class welcome_wizard;
+  class welcome_wizard;
 }
 
 class welcome_wizard : public QDialog
 {
   Q_OBJECT
 
-public:
+  public:
   explicit welcome_wizard (QWidget *parent = 0);
   ~welcome_wizard ();
 
 public slots:
   void next ();
   void previous ();
 
 private:
diff --git a/libgui/src/workspace-model.cc b/libgui/src/workspace-model.cc
--- a/libgui/src/workspace-model.cc
+++ b/libgui/src/workspace-model.cc
@@ -24,32 +24,32 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include <QTreeWidget>
 #include <QTime>
 
 #include <list>
 
-#include <symtab.h>
+#include "symtab.h"
+#include "variables.h"
 
 #include "workspace-model.h"
 #include "octave-link.h"
 
-workspace_model::workspace_model(QObject *parent)
-  : QAbstractItemModel(parent), octave_event_observer ()
+workspace_model::workspace_model(QObject *p)
+  : QAbstractItemModel (p)
 {
   QList<QVariant> rootData;
-  rootData << tr ("Name") << tr ("Type") << tr("Dimension") << tr ("Value");
+  rootData << tr ("Name") << tr ("Class") << tr("Dimension") << tr ("Value");
   _rootItem = new tree_item(rootData);
 
   insert_top_level_item(0, new tree_item ("Local"));
   insert_top_level_item(1, new tree_item ("Global"));
   insert_top_level_item(2, new tree_item ("Persistent"));
-  insert_top_level_item(3, new tree_item ("Hidden"));
 
   connect(&_update_workspace_model_timer,
           SIGNAL (timeout ()),
           this,
           SLOT (request_update_workspace()));
 
   _update_workspace_model_timer.setInterval (500);
   _update_workspace_model_timer.setSingleShot (true);
@@ -59,131 +59,80 @@ workspace_model::workspace_model(QObject
 workspace_model::~workspace_model()
 {
   delete _rootItem;
 }
 
 void
 workspace_model::request_update_workspace ()
 {
-  octave_link::instance ()
-      ->post_event (new octave_update_workspace_event (*this));
-}
-
-void
-workspace_model::event_accepted (octave_event *e)
-{
-  if (dynamic_cast <octave_update_workspace_event*> (e))
-    {
-      std::list < symbol_table::symbol_record > symbolTable = symbol_table::all_variables ();
-
-      _symbol_information.clear ();
-      for (std::list < symbol_table::symbol_record > ::iterator iterator = symbolTable.begin ();
-         iterator != symbolTable.end (); iterator++)
-      {
-        symbol_information symbolInformation;
-        symbolInformation.from_symbol_record (*iterator);
-        _symbol_information.push_back (symbolInformation);
-      }
-
-      beginResetModel();
-      top_level_item (0)->delete_child_items ();
-      top_level_item (1)->delete_child_items ();
-      top_level_item (2)->delete_child_items ();
-      top_level_item (3)->delete_child_items ();
-
-      foreach (const symbol_information& s, _symbol_information)
-        {
-          tree_item *child = new tree_item ();
-
-          child->set_data (0, s._symbol);
-          child->set_data (1, s._type);
-          child->set_data (2, s._dimension);
-          child->set_data (3, s._value);
-
-          switch (s._scope)
-            {
-              case symbol_information::local:       top_level_item (0)->add_child (child); break;
-              case symbol_information::global:      top_level_item (1)->add_child (child); break;
-              case symbol_information::persistent:  top_level_item (2)->add_child (child); break;
-              case symbol_information::hidden:      top_level_item (3)->add_child (child); break;
-            }
-        }
-
-      endResetModel();
-      emit model_changed();
-    }
-
-  // Post a new event in a given time.
-  // This prevents flooding the event queue when no events are being processed.
-  _update_workspace_model_timer.start ();
-  delete e;
-}
-
-void
-workspace_model::event_reject (octave_event *e)
-{
-  delete e;
+  octave_link::post_event (this, &workspace_model::update_workspace_callback);
 }
 
 QModelIndex
-workspace_model::index(int row, int column, const QModelIndex &parent) const
+workspace_model::index(int row, int column, const QModelIndex &p) const
 {
-  if (!hasIndex(row, column, parent))
+  if (!hasIndex(row, column, p))
     return QModelIndex();
 
   tree_item *parentItem;
 
-  if (!parent.isValid())
+  if (!p.isValid())
     parentItem = _rootItem;
   else
-    parentItem = static_cast<tree_item*>(parent.internalPointer());
+    parentItem = static_cast<tree_item*>(p.internalPointer());
 
   tree_item *childItem = parentItem->child(row);
   if (childItem)
     return createIndex(row, column, childItem);
   else
     return QModelIndex();
 }
 
 QModelIndex
-workspace_model::parent(const QModelIndex &index) const
+workspace_model::parent(const QModelIndex &idx) const
 {
-  if (!index.isValid())
+  if (!idx.isValid())
     return QModelIndex();
 
-  tree_item *childItem = static_cast<tree_item*>(index.internalPointer());
-  tree_item *parentItem = childItem->parent();
+  tree_item *childItem = static_cast<tree_item*>(idx.internalPointer());
+
+  if (childItem)
+    {
+      tree_item *parentItem = childItem->parent();
 
-  if (parentItem == _rootItem)
-    return QModelIndex();
+      if (! parentItem || parentItem == _rootItem)
+        return QModelIndex();
 
-  return createIndex(parentItem->row(), 0, parentItem);
+      return createIndex(parentItem->row(), 0, parentItem);
+    }
+  else
+    return QModelIndex ();
 }
 
 int
-workspace_model::rowCount(const QModelIndex &parent) const
+workspace_model::rowCount(const QModelIndex &p) const
 {
   tree_item *parentItem;
-  if (parent.column() > 0)
+  if (p.column() > 0)
     return 0;
 
-  if (!parent.isValid())
+  if (!p.isValid())
     parentItem = _rootItem;
   else
-    parentItem = static_cast<tree_item*>(parent.internalPointer());
+    parentItem = static_cast<tree_item*>(p.internalPointer());
 
   return parentItem->child_count();
 }
 
 int
-workspace_model::columnCount(const QModelIndex &parent) const
+workspace_model::columnCount(const QModelIndex &p) const
 {
-  if (parent.isValid())
-    return static_cast<tree_item*>(parent.internalPointer())->column_count();
+  if (p.isValid())
+    return static_cast<tree_item*>(p.internalPointer())->column_count();
   else
     return _rootItem->column_count();
 }
 
 void
 workspace_model::insert_top_level_item(int at, tree_item *treeItem)
 {
   _rootItem->insert_child_item(at, treeItem);
@@ -191,39 +140,90 @@ workspace_model::insert_top_level_item(i
 
 tree_item *
 workspace_model::top_level_item (int at)
 {
   return _rootItem->child(at);
 }
 
 Qt::ItemFlags
-workspace_model::flags(const QModelIndex &index) const
+workspace_model::flags(const QModelIndex &idx) const
 {
-  if (!index.isValid())
+  if (!idx.isValid())
     return 0;
 
   return Qt::ItemIsEnabled | Qt::ItemIsSelectable;
 }
 
 QVariant
 workspace_model::headerData(int section, Qt::Orientation orientation, int role) const
 {
   if (orientation == Qt::Horizontal && role == Qt::DisplayRole)
     return _rootItem->data(section);
 
   return QVariant();
 }
 
 QVariant
-workspace_model::data(const QModelIndex &index, int role) const
+workspace_model::data(const QModelIndex &idx, int role) const
 {
-  if (!index.isValid())
+  if (!idx.isValid())
     return QVariant();
 
   if (role != Qt::DisplayRole)
     return QVariant();
 
-  tree_item *item = static_cast<tree_item*>(index.internalPointer());
+  tree_item *item = static_cast<tree_item*>(idx.internalPointer());
 
-  return item->data(index.column());
+  return item->data(idx.column());
 }
 
+void
+workspace_model::update_workspace_callback (void)
+{
+  std::list < symbol_table::symbol_record > symbolTable = symbol_table::all_variables ();
+
+  _symbol_information.clear ();
+  for (std::list < symbol_table::symbol_record > ::iterator iterator = symbolTable.begin ();
+       iterator != symbolTable.end (); iterator++)
+    _symbol_information.push_back (symbol_information (*iterator));
+
+  beginResetModel();
+  top_level_item (0)->delete_child_items ();
+  top_level_item (1)->delete_child_items ();
+  top_level_item (2)->delete_child_items ();
+
+  foreach (const symbol_information& s, _symbol_information)
+    {
+      tree_item *child = new tree_item ();
+
+      child->set_data (0, s.symbol ());
+      child->set_data (1, s.class_name ());
+      child->set_data (2, s.dimension ());
+      child->set_data (3, s.value ());
+
+      switch (s.scope ())
+        {
+        case symbol_information::local:
+          top_level_item (0)->add_child (child);
+          break;
+
+        case symbol_information::global:
+          top_level_item (1)->add_child (child);
+          break;
+
+        case symbol_information::persistent:
+          top_level_item (2)->add_child (child);
+          break;
+
+        default:
+          break;
+        }
+    }
+
+  endResetModel();
+  emit model_changed();
+
+  // Post a new event in a given time.
+  // This prevents flooding the event queue when no events are being processed.
+  _update_workspace_model_timer.start ();
+}
+
diff --git a/libgui/src/workspace-model.h b/libgui/src/workspace-model.h
--- a/libgui/src/workspace-model.h
+++ b/libgui/src/workspace-model.h
@@ -25,68 +25,67 @@ along with Octave; see the file COPYING.
 
 // Qt includes
 #include <QAbstractItemModel>
 #include <QVector>
 #include <QSemaphore>
 #include <QTimer>
 
 #include "symbol-information.h"
-#include "octave-event-observer.h"
 
 class tree_item
 {
 public:
-  tree_item (const QList<QVariant> &data, tree_item *parent = 0) {
-    _parent_item = parent;
-    _item_data = data;
+  tree_item (const QList<QVariant> &d, tree_item *p = 0) {
+    _parent_item = p;
+    _item_data = d;
   }
 
-  tree_item (QVariant data = QVariant(), tree_item *parent = 0) {
+  tree_item (QVariant d = QVariant(), tree_item *p = 0) {
     QList<QVariant> variantList;
-    variantList << data << QVariant () << QVariant () << QVariant ();
-    _parent_item = parent;
+    variantList << d << QVariant () << QVariant () << QVariant ();
+    _parent_item = p;
     _item_data = variantList;
   }
 
   ~tree_item () {
-     qDeleteAll (_child_items);
+    qDeleteAll (_child_items);
   }
 
   void insert_child_item (int at, tree_item *item) {
     item->_parent_item = this;
     _child_items.insert (at, item);
   }
 
   void add_child (tree_item *item) {
     item->_parent_item = this;
     _child_items.append (item);
   }
 
   void delete_child_items () {
-      qDeleteAll (_child_items);
-      _child_items.clear ();
+    qDeleteAll (_child_items);
+    _child_items.clear ();
   }
 
   void remove_child (tree_item *item) {
     _child_items.removeAll (item);
   }
 
   QVariant data (int column) const
   {
     return _item_data[column];
   }
 
-  void set_data (int column, QVariant data)
+  void set_data (int column, QVariant d)
   {
-    _item_data[column] = data;
+    _item_data[column] = d;
   }
 
-  tree_item *child (int row) {
-    return _child_items[row];
+  tree_item *child (int r) {
+    return _child_items[r];
   }
 
   int child_count () const {
     return _child_items.count();
   }
 
   int column_count () const
   {
@@ -107,49 +106,49 @@ public:
 
 private:
   QList<tree_item*> _child_items;
   QList<QVariant> _item_data;
   tree_item *_parent_item;
 };
 
 class workspace_model
-    : public QAbstractItemModel, public octave_event_observer
+  : public QAbstractItemModel
 {
   Q_OBJECT
 
-public:
+  public:
   workspace_model (QObject *parent = 0);
   ~workspace_model ();
 
-  void event_accepted (octave_event *e);
-  void event_reject (octave_event *e);
-
   QVariant data (const QModelIndex &index, int role) const;
   Qt::ItemFlags flags (const QModelIndex &index) const;
   QVariant headerData (int section, Qt::Orientation orientation,
                        int role = Qt::DisplayRole) const;
   QModelIndex index (int row, int column,
-                    const QModelIndex &parent = QModelIndex ()) const;
+                     const QModelIndex &parent = QModelIndex ()) const;
   QModelIndex parent (const QModelIndex &index) const;
   int rowCount (const QModelIndex &parent = QModelIndex ()) const;
   int columnCount (const QModelIndex &parent = QModelIndex ()) const;
 
   void insert_top_level_item (int at, tree_item *treeItem);
   tree_item *top_level_item (int at);
 
 public slots:
   void request_update_workspace ();
 
 signals:
   void model_changed ();
 
 private:
+
+  void update_workspace_callback (void);
+
   /** Timer for periodically updating the workspace model from the current
-    * symbol information. */
+   * symbol information. */
   QTimer _update_workspace_model_timer;
 
   /** Stores the current symbol information. */
   QList <symbol_information> _symbol_information;
   tree_item *_rootItem;
 };
 
 #endif // WORKSPACEMODEL_H
diff --git a/libgui/src/workspace-view.cc b/libgui/src/workspace-view.cc
--- a/libgui/src/workspace-view.cc
+++ b/libgui/src/workspace-view.cc
@@ -15,26 +15,32 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include "workspace-view.h"
 #include "resource-manager.h"
+#include <QHeaderView>
 #include <QHBoxLayout>
 #include <QVBoxLayout>
 #include <QPushButton>
 
-workspace_view::workspace_view (QWidget * parent) : QDockWidget
-  (parent)
+workspace_view::workspace_view (QWidget *p)
+  : QDockWidget (p)
 {
   setObjectName ("WorkspaceView");
+  setWindowIcon (QIcon(":/actions/icons/logo.png"));
   setWindowTitle (tr ("Workspace"));
 
   // Create a new workspace model.
   _workspace_model = new workspace_model ();
 
   _workspace_tree_view = new QTreeView (this);            // Create a new tree view.
   _workspace_tree_view->setHeaderHidden (false);          // Do not show header columns.
   _workspace_tree_view->setAlternatingRowColors (true);   // Activate alternating row colors.
@@ -42,61 +48,67 @@ workspace_view::workspace_view (QWidget 
   _workspace_tree_view->setTextElideMode (Qt::ElideRight);// Elide text to the right side of the cells.
   _workspace_tree_view->setWordWrap (false);              // No wordwrapping in cells.
   _workspace_tree_view->setModel (_workspace_model);      // Assign model.
 
   // Set an empty widget, so we can assign a layout to it.
   setWidget (new QWidget (this));
 
   // Create a new layout and add widgets to it.
-  QVBoxLayout *layout = new QVBoxLayout ();
-  layout->addWidget (_workspace_tree_view);
-  layout->setMargin (2);
+  QVBoxLayout *vbox_layout = new QVBoxLayout ();
+  vbox_layout->addWidget (_workspace_tree_view);
+  vbox_layout->setMargin (2);
 
   // Set the empty widget to have our layout.
-  widget ()->setLayout (layout);
+  widget ()->setLayout (vbox_layout);
 
   // Initialize collapse/expand state of the workspace subcategories.
 
   QSettings *settings = resource_manager::get_settings ();
 
   // FIXME -- what should happen if settings is 0?
 
   _explicit_collapse.local      = settings->value ("workspaceview/local_collapsed", false).toBool ();
   _explicit_collapse.global     = settings->value ("workspaceview/global_collapsed", false).toBool ();;
   _explicit_collapse.persistent = settings->value ("workspaceview/persistent_collapsed", false).toBool ();;
-  _explicit_collapse.hidden     = settings->value ("workspaceview/hidden_collapsed", false).toBool ();;
+
+  // Initialize column order and width of the workspace
+  
+  _workspace_tree_view->header ()->restoreState (settings->value("workspaceview/column_state").toByteArray ());
 
   // Connect signals and slots.
   connect (this, SIGNAL (visibilityChanged (bool)),
            this, SLOT(handle_visibility_changed (bool)));
 
   connect (_workspace_model, SIGNAL (model_changed ()),
            this, SLOT (model_changed ()));
 
   connect (_workspace_tree_view, SIGNAL (collapsed (QModelIndex)),
            this, SLOT (collapse_requested (QModelIndex)));
   connect (_workspace_tree_view, SIGNAL (expanded (QModelIndex)),
            this, SLOT (expand_requested (QModelIndex)));
 
   connect (_workspace_tree_view, SIGNAL (doubleClicked (QModelIndex)),
            this, SLOT (item_double_clicked (QModelIndex)));
 
+  // topLevelChanged is emitted when floating property changes (floating = true)
+  connect (this, SIGNAL (topLevelChanged(bool)), this, SLOT(top_level_changed(bool)));
+
 }
 
 workspace_view::~workspace_view ()
 {
   QSettings *settings = resource_manager::get_settings ();
 
   // FIXME -- what should happen if settings is 0?
 
   settings->setValue("workspaceview/local_collapsed", _explicit_collapse.local);
   settings->setValue("workspaceview/global_collapsed", _explicit_collapse.global);
   settings->setValue("workspaceview/persistent_collapsed", _explicit_collapse.persistent);
-  settings->setValue("workspaceview/hidden_collapsed", _explicit_collapse.hidden);
+  settings->setValue("workspaceview/column_state", _workspace_tree_view->header ()->saveState ());
 }
 
 void
 workspace_view::handle_visibility_changed (bool visible)
 {
   if (visible)
     emit active_changed (true);
 }
@@ -116,17 +128,16 @@ workspace_view::model_changed ()
   // displayed data as invalid.
   //
   // In order to make collapsing/expanding work again, we need to set
   // flags ourselves here.
 
   QModelIndex local_model_index = _workspace_model->index (0, 0);
   QModelIndex global_model_index = _workspace_model->index (1, 0);
   QModelIndex persistent_model_index = _workspace_model->index (2, 0);
-  QModelIndex hidden_model_index = _workspace_model->index (3, 0);
 
   if (_explicit_collapse.local) {
     _workspace_tree_view->collapse (local_model_index);
   } else {
     _workspace_tree_view->expand (local_model_index);
   }
 
   if (_explicit_collapse.global) {
@@ -135,22 +146,16 @@ workspace_view::model_changed ()
     _workspace_tree_view->expand (global_model_index);
   }
 
   if (_explicit_collapse.persistent) {
     _workspace_tree_view->collapse (persistent_model_index);
   } else {
     _workspace_tree_view->expand (persistent_model_index);
   }
-
-  if (_explicit_collapse.hidden) {
-    _workspace_tree_view->collapse (hidden_model_index);
-  } else {
-    _workspace_tree_view->expand (hidden_model_index);
-  }
 }
 
 void
 workspace_view::collapse_requested (QModelIndex index)
 {
   // This code is very quirky and requires some explanation.
   // Usually, we should not deal with collapsing or expanding ourselves,
   // because the view itself determines (based on the model) whether it
@@ -160,26 +165,24 @@ workspace_view::collapse_requested (QMod
   // would make it work correctly, but this is extremely slow and scales
   // very bad (O(n^2)). That's why we throw away our model and rebuild it
   // completely from scratch (O(n)), which is why the view renders all
   // displayed data as invalid.
   //
   // In order to make collapsing/expanding work again, we need to set
   // flags ourselves here.
   QMap<int, QVariant> item_data
-      = _workspace_model->itemData (index);
+    = _workspace_model->itemData (index);
 
   if (item_data[0] == "Local")
     _explicit_collapse.local = true;
   if (item_data[0] == "Global")
     _explicit_collapse.global = true;
   if (item_data[0] == "Persistent")
     _explicit_collapse.persistent = true;
-  if (item_data[0] == "Hidden")
-    _explicit_collapse.hidden = true;
 }
 
 void
 workspace_view::expand_requested (QModelIndex index)
 {
   // This code is very quirky and requires some explanation.
   // Usually, we should not deal with collapsing or expanding ourselves,
   // because the view itself determines (based on the model) whether it
@@ -189,33 +192,41 @@ workspace_view::expand_requested (QModel
   // would make it work correctly, but this is extremely slow and scales
   // very bad (O(n^2)). That's why we throw away our model and rebuild it
   // completely from scratch (O(n)), which is why the view renders all
   // displayed data as invalid.
   //
   // In order to make collapsing/expanding work again, we need to do set
   // flags ourselves here.
   QMap<int, QVariant> item_data
-      = _workspace_model->itemData (index);
+    = _workspace_model->itemData (index);
 
   if (item_data[0] == "Local")
     _explicit_collapse.local = false;
   if (item_data[0] == "Global")
     _explicit_collapse.global = false;
   if (item_data[0] == "Persistent")
     _explicit_collapse.persistent = false;
-  if (item_data[0] == "Hidden")
-    _explicit_collapse.hidden = false;
 }
 
 void
-workspace_view::item_double_clicked (QModelIndex index)
+workspace_view::item_double_clicked (QModelIndex)
 {
-  Q_UNUSED (index);
   // TODO: Implement opening a dialog that allows the user to change a variable in the workspace.
 }
 
 void
-workspace_view::closeEvent (QCloseEvent *event)
+workspace_view::closeEvent (QCloseEvent *e)
 {
   emit active_changed (false);
-  QDockWidget::closeEvent (event);
+  QDockWidget::closeEvent (e);
 }
+
+// slot for signal that is emitted when floating property changes
+void
+workspace_view::top_level_changed (bool floating)
+{
+  if(floating)
+    {
+      setWindowFlags(Qt::Window);  // make a window from the widget when floating
+      show();                      // make it visible again since setWindowFlags hides it
+    }
+}
diff --git a/libgui/src/workspace-view.h b/libgui/src/workspace-view.h
--- a/libgui/src/workspace-view.h
+++ b/libgui/src/workspace-view.h
@@ -21,29 +21,31 @@ along with Octave; see the file COPYING.
 */
 
 #ifndef WORKSPACEVIEW_H
 #define WORKSPACEVIEW_H
 
 #include <QDockWidget>
 #include <QTreeView>
 #include <QSemaphore>
-#include "octave-link.h"
+
 #include "workspace-model.h"
 
 class workspace_view : public QDockWidget
 {
   Q_OBJECT
-public:
+  public:
   workspace_view (QWidget * parent = 0);
   ~workspace_view ();
 
 public slots:
   void handle_visibility_changed (bool visible);
   void model_changed ();
+  /** Slot when floating property changes */
+  void top_level_changed (bool floating);
 
 signals:
   /** Custom signal that tells if a user has clicke away that dock widget. */
   void active_changed (bool active);
 
 protected:
   void closeEvent (QCloseEvent *event);
 
@@ -58,13 +60,12 @@ private:
   /** Stores the current workspace model. */
   workspace_model *_workspace_model;
 
   struct
   {
     bool local;
     bool global;
     bool persistent;
-    bool hidden;
   } _explicit_collapse;
 };
 
 #endif // WORKSPACEVIEW_H
diff --git a/libinterp/Makefile.am b/libinterp/Makefile.am
--- a/libinterp/Makefile.am
+++ b/libinterp/Makefile.am
@@ -1,9 +1,9 @@
-# Makefile for Octave's src directory
+# Makefile for Octave's libinterp directory
 #
 # Copyright (C) 1993-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
@@ -19,26 +19,34 @@
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
 AUTOMAKE_OPTIONS = subdir-objects
 
 ## Search local directories before those specified by the user.
 AM_CPPFLAGS = \
-  -I$(top_srcdir)/libcruft/misc \
-  -I../liboctave -I$(top_srcdir)/liboctave \
+  -I$(top_srcdir)/liboctave/cruft/misc \
+  -I$(top_srcdir)/liboctave/array \
+  -I$(top_builddir)/liboctave/numeric -I$(top_srcdir)/liboctave/numeric \
+  -I$(top_builddir)/liboctave/operators -I$(top_srcdir)/liboctave/operators \
+  -I$(top_srcdir)/liboctave/system \
+  -I$(top_srcdir)/liboctave/util \
   -I$(srcdir)/octave-value \
   -I$(srcdir)/operators \
   -Iparse-tree -I$(srcdir)/parse-tree \
   -Iinterp-core -I$(srcdir)/interp-core \
   -Iinterpfcn -I$(srcdir)/interpfcn \
   -Icorefcn \
   -I$(top_builddir)/libgnu -I$(top_srcdir)/libgnu
 
+AM_CFLAGS += $(WARN_CFLAGS)
+
+AM_CXXFLAGS += $(WARN_CXXFLAGS)
+
 octlib_LTLIBRARIES = liboctinterp.la
 
 ## Order matters here.  Leave builtins.cc last, because it depends on
 ## $(DEF_FILES), and building those requires all the sources
 ## (except builtins.cc) to be available.
 BUILT_SOURCES = \
   interp-core/mxarray.h \
   interp-core/oct-errno.cc \
@@ -46,30 +54,31 @@ BUILT_SOURCES = \
   interpfcn/graphics-props.cc \
   interpfcn/graphics.h \
   operators/ops.cc \
   parse-tree/lex.cc \
   parse-tree/oct-gperf.h \
   parse-tree/oct-parse.cc \
   oct-conf.h \
   version.h \
-  $(BUILT_SOURCES_EXTRA) \
+  builtin-defun-decls.h \
   builtins.cc
 
 BUILT_DISTFILES = \
   parse-tree/oct-gperf.h \
   parse-tree/oct-parse.h
 
 ## Files that are created during build process and installed,
 ## BUT not distributed in tarball.
 BUILT_NODISTFILES = \
   interp-core/mxarray.h \
   interp-core/oct-errno.cc \
   interpfcn/defaults.h \
   interpfcn/graphics.h \
+  builtin-defun-decls.h \
   operators/ops.cc \
   oct-conf.h \
   version.h \
   $(OPT_HANDLERS) \
   $(OPT_INC) \
   $(ALL_DEF_FILES) \
   builtins.cc
 
@@ -87,23 +96,23 @@ EXTRA_DIST = \
   oct-conf.in.h \
   version.in.h \
   $(BUILT_DISTFILES)
 
 octinclude_HEADERS = \
   interpfcn/graphics-props.cc \
   parse-tree/oct-gperf.h \
   builtins.h \
+  builtin-defun-decls.h \
   octave.h \
-  $(OV_INCLUDES) \
-  $(OV_SPARSE_INCLUDES) \
-  $(PT_INCLUDES) \
-	$(OPERATOR_INCLUDES) \
-  $(INTERP_CORE_INCLUDES) \
-  $(INTERPFCN_INCLUDES)
+  $(OCTAVE_VALUE_INC) \
+  $(PARSE_TREE_INC) \
+  $(OPERATORS_INC) \
+  $(INTERP_CORE_INC) \
+  $(INTERPFCN_INC)
 
 nodist_octinclude_HEADERS = \
   interp-core/mxarray.h \
   interpfcn/defaults.h \
   interpfcn/graphics.h \
   oct-conf.h \
   version.h
 
@@ -145,51 +154,48 @@ liboctinterp_la_SOURCES = \
   $(TEMPLATE_INST_SRC)
 
 nodist_liboctinterp_la_SOURCES = \
   interp-core/mxarray.h \
   interp-core/oct-errno.cc \
   interpfcn/defaults.h \
   interpfcn/graphics.h \
   operators/ops.cc \
+  builtin-defun-decls.h \
   builtins.cc \
   oct-conf.h \
   version.h \
   $(OPT_INC)
 
 liboctinterp_la_CPPFLAGS = @OCTINTERP_DLL_DEFS@ $(AM_CPPFLAGS)
 
 include link-deps.mk
 
 liboctinterp_la_LIBADD = \
   octave-value/liboctave-value.la \
   parse-tree/libparse-tree.la \
   interp-core/libinterp-core.la \
   interpfcn/libinterpfcn.la \
   corefcn/libcorefcn.la \
-  ../liboctave/liboctave.la \
-  ../libcruft/libcruft.la \
+  $(top_builddir)/liboctave/liboctave.la \
   $(LIBOCTINTERP_LINK_DEPS)
 
 # Increment these as needed and according to the rules in the libtool manual:
 liboctinterp_current = 1
 liboctinterp_revision = 1
 liboctinterp_age = 0
 
 liboctinterp_version_info = $(liboctinterp_current):$(liboctinterp_revision):$(liboctinterp_age)
 
 liboctinterp_la_LDFLAGS = \
   -version-info $(liboctinterp_version_info) \
   $(NO_UNDEFINED_LDFLAG) \
   -bindir $(bindir) \
   $(LIBOCTINTERP_LINK_OPTS)
 
-## FIXME: Does this rule need to be uncommented?
-#fft.df fft.lo fft2.df fft2.lo fftn.df fftn.lo: CPPFLAGS += $(FFTW_XCPPFLAGS)
-
 ## Section for defining and creating DEF_FILES
 SRC_DEF_FILES := $(shell $(srcdir)/find-defun-files.sh "$(srcdir)" $(DIST_SRC))
 
 DLDFCN_DEF_FILES = $(DLDFCN_SRC:.cc=.df)
 
 ## builtins.cc depends on $(DEF_FILES), so DEF_FILES should only include
 ## .df files that correspond to sources included in liboctave.
 if AMCOND_ENABLE_DYNAMIC_LINKING
@@ -199,16 +205,18 @@ else
 endif
 
 ALL_DEF_FILES = $(SRC_DEF_FILES) $(DLDFCN_DEF_FILES)
 
 $(SRC_DEF_FILES): mkdefs Makefile
 
 $(DEF_FILES): $(OPT_HANDLERS) $(OPT_INC)
 
+## FIXME: The following two variables are deprecated and should be removed
+##        in Octave version 3.12.
 DLL_CDEFS = @OCTINTERP_DLL_DEFS@
 DLL_CXXDEFS = @OCTINTERP_DLL_DEFS@
 
 ## Rule to build a DEF file from a .cc file
 %.df: %.cc
 	$(CXXCPP) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	  $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) \
 	  -DMAKE_BUILTINS $< | $(srcdir)/mkdefs $(srcdir) $< > $@-t
@@ -218,34 +226,39 @@ DLL_CXXDEFS = @OCTINTERP_DLL_DEFS@
 ## though we don't want it.  It would be super awesome if automake
 ## would allow users to choose the header file extension.
 .yy.cc:
 	$(am__skipyacc) $(SHELL) $(YLWRAP) $< y.tab.c $@ y.tab.h $*.h y.output $*.output -- $(YACCCOMPILE)
 
 ## Special rules:
 ## Mostly for sources which must be built before rest of compilation.
 
-## oct-conf.h must depend on Makefile.  Calling configure
-## may change default/config values.  However, calling configure will also
-## regenerate the Makefiles from Makefile.am and trigger the rules below.
+## oct-conf.h must depend on Makefile.
+## Calling configure may change default/config values.
+## However, calling configure will also regenerate the Makefiles from
+## Makefile.am and trigger the rules below.
 oct-conf.h: oct-conf.in.h Makefile
 	@$(do_subst_config_vals)
 
 version.h: version.in.h Makefile
 	$(SED) < $< \
 	  -e "s|%NO_EDIT_WARNING%|DO NOT EDIT!  Generated automatically from $(<F) by Make.|" \
 	  -e "s|%OCTAVE_API_VERSION_NUMBER%|${OCTAVE_API_VERSION_NUMBER}|" \
 	  -e "s|%OCTAVE_API_VERSION%|\"${OCTAVE_API_VERSION}\"|" \
 	  -e "s|%OCTAVE_COPYRIGHT%|\"${OCTAVE_COPYRIGHT}\"|" \
 	  -e "s|%OCTAVE_RELEASE_DATE%|\"${OCTAVE_RELEASE_DATE}\"|" \
 	  -e "s|%OCTAVE_VERSION%|\"${OCTAVE_VERSION}\"|" > $@-t
 	mv $@-t $@
 
 builtins.cc: $(DEF_FILES) mkbuiltins
-	$(srcdir)/mkbuiltins $(DEF_FILES) > $@-t
+	$(srcdir)/mkbuiltins --source $(DEF_FILES) > $@-t
+	mv $@-t $@
+
+builtin-defun-decls.h: $(SRC_DEF_FILES) mkbuiltins
+	$(srcdir)/mkbuiltins --header $(SRC_DEF_FILES) > $@-t
 	mv $@-t $@
 
 if AMCOND_ENABLE_DYNAMIC_LINKING
 DLDFCN_PKG_ADD_FILE = dldfcn/PKG_ADD
 
 dldfcn/PKG_ADD: $(DLDFCN_DEF_FILES) mk-pkg-add
 	$(srcdir)/mk-pkg-add $(DLDFCN_DEF_FILES) > $@-t
 	mv $@-t $@
@@ -262,17 +275,21 @@ if AMCOND_BUILD_DOCS
 	$(top_srcdir)/build-aux/move-if-change $@ DOCSTRINGS
 	touch $@
 
 all-local: $(OCT_STAMP_FILES) $(DLDFCN_PKG_ADD_FILE) .DOCSTRINGS
 else
 all-local: $(OCT_STAMP_FILES) $(DLDFCN_PKG_ADD_FILE)
 endif
 
+if AMCOND_BUILD_DOCS
+install-data-hook: install-oct install-built-in-docstrings
+else
 install-data-hook: install-oct
+endif
 
 uninstall-local: uninstall-oct
 
 if AMCOND_ENABLE_DYNAMIC_LINKING
 install-oct:
 	$(top_srcdir)/build-aux/mkinstalldirs $(DESTDIR)$(octfiledir)
 	if [ -n "`cat $(DLDFCN_PKG_ADD_FILE)`" ]; then \
 	  $(INSTALL_DATA) $(DLDFCN_PKG_ADD_FILE) $(DESTDIR)$(octfiledir)/PKG_ADD; \
@@ -296,16 +313,23 @@ install-oct:
 uninstall-oct:
 	for f in $(notdir $(OCT_FILES)); do \
 	  rm -f $(DESTDIR)$(octfiledir)/$$f; \
 	done
 	rm -f $(DESTDIR)$(octfiledir)/PKG_ADD
 endif
 .PHONY: install-oct uninstall-oct
 
+if AMCOND_BUILD_DOCS
+install-built-in-docstrings:
+	$(MKDIR_P) $(DESTDIR)$(octetcdir)
+	$(INSTALL_DATA) DOCSTRINGS $(DESTDIR)$(octetcdir)/built-in-docstrings
+endif
+.PHONY: install-built-in-docstrings
+
 CLEANFILES = \
   $(DLDFCN_PKG_ADD_FILE) \
   interpfcn/graphics-props.cc \
   parse-tree/oct-parse.output
 
 DISTCLEANFILES = \
   .DOCSTRINGS \
   DOCSTRINGS \
diff --git a/libinterp/builtins.h b/libinterp/builtins.h
--- a/libinterp/builtins.h
+++ b/libinterp/builtins.h
@@ -18,11 +18,15 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_builtins_h)
 #define octave_builtins_h 1
 
+#if !defined (MAKE_BUILTINS)
+#include "builtin-defun-decls.h"
+#endif
+
 extern OCTINTERP_API void install_builtins (void);
 
 #endif
diff --git a/libinterp/corefcn/__qp__.cc b/libinterp/corefcn/__qp__.cc
--- a/libinterp/corefcn/__qp__.cc
+++ b/libinterp/corefcn/__qp__.cc
@@ -46,17 +46,17 @@ null (const Matrix& A, octave_idx_type& 
   rank = 0;
 
   if (! A.is_empty ())
     {
       SVD A_svd (A);
 
       DiagMatrix S = A_svd.singular_values ();
 
-      ColumnVector s = S.diag ();
+      ColumnVector s = S.extract_diag ();
 
       Matrix V = A_svd.right_singular_matrix ();
 
       octave_idx_type A_nr = A.rows ();
       octave_idx_type A_nc = A.cols ();
 
       octave_idx_type tmp = A_nr > A_nc ? A_nr : A_nc;
 
diff --git a/libinterp/corefcn/conv2.cc b/libinterp/corefcn/conv2.cc
--- a/libinterp/corefcn/conv2.cc
+++ b/libinterp/corefcn/conv2.cc
@@ -83,148 +83,154 @@ When the third argument is a matrix, ret
         separable = true;
     }
   else if (nargin >= 4)
     {
       separable = true;
       shape = args(3).string_value ();
     }
 
+  if (args(0).ndims () > 2 || args(1).ndims () > 2)
+    {
+      error ("conv2: A and B must be 1-D vectors or 2-D matrices");
+      return retval;
+    }
+
   if (shape == "full")
     ct = convn_full;
   else if (shape == "same")
     ct = convn_same;
   else if (shape == "valid")
     ct = convn_valid;
   else
     {
       error ("conv2: SHAPE type not valid");
       print_usage ();
       return retval;
     }
 
-   if (separable)
-     {
-      // If user requests separable, check first two params are vectors
+  if (separable)
+    {
+     // If user requests separable, check first two params are vectors
 
-       if (! (1 == args(0).rows () || 1 == args(0).columns ())
-           || ! (1 == args(1).rows () || 1 == args(1).columns ()))
-         {
-           print_usage ();
-           return retval;
-         }
+      if (! (1 == args(0).rows () || 1 == args(0).columns ())
+          || ! (1 == args(1).rows () || 1 == args(1).columns ()))
+        {
+          print_usage ();
+          return retval;
+        }
 
-       if (args(0).is_single_type () || args(1).is_single_type ()
-           || args(2).is_single_type ())
-         {
-           if (args(0).is_complex_type () || args(1).is_complex_type ()
-               || args(2).is_complex_type ())
-             {
-               FloatComplexMatrix a (args(2).float_complex_matrix_value ());
-               if (args(1).is_real_type () && args(2).is_real_type ())
-                 {
-                   FloatColumnVector v1 (args(0).float_vector_value ());
-                   FloatRowVector v2 (args(1).float_vector_value ());
-                   retval = convn (a, v1, v2, ct);
-                 }
-               else
-                 {
-                   FloatComplexColumnVector v1 (args(0).float_complex_vector_value ());
-                   FloatComplexRowVector v2 (args(1).float_complex_vector_value ());
-                   retval = convn (a, v1, v2, ct);
-                 }
-             }
-           else
-             {
-               FloatColumnVector v1 (args(0).float_vector_value ());
-               FloatRowVector v2 (args(1).float_vector_value ());
-               FloatMatrix a (args(2).float_matrix_value ());
-               retval = convn (a, v1, v2, ct);
-             }
-         }
-       else
-         {
-           if (args(0).is_complex_type () || args(1).is_complex_type ()
-               || args(2).is_complex_type ())
-             {
-               ComplexMatrix a (args(2).complex_matrix_value ());
-               if (args(1).is_real_type () && args(2).is_real_type ())
-                 {
-                   ColumnVector v1 (args(0).vector_value ());
-                   RowVector v2 (args(1).vector_value ());
-                   retval = convn (a, v1, v2, ct);
-                 }
-               else
-                 {
-                   ComplexColumnVector v1 (args(0).complex_vector_value ());
-                   ComplexRowVector v2 (args(1).complex_vector_value ());
-                   retval = convn (a, v1, v2, ct);
-                 }
-             }
-           else
-             {
-               ColumnVector v1 (args(0).vector_value ());
-               RowVector v2 (args(1).vector_value ());
-               Matrix a (args(2).matrix_value ());
-               retval = convn (a, v1, v2, ct);
-             }
-         }
-     } // if (separable)
-   else
-     {
-       if (args(0).is_single_type () || args(1).is_single_type ())
-         {
-           if (args(0).is_complex_type () || args(1).is_complex_type ())
-             {
-               FloatComplexMatrix a (args(0).float_complex_matrix_value ());
-               if (args(1).is_real_type ())
-                 {
-                   FloatMatrix b (args(1).float_matrix_value ());
-                   retval = convn (a, b, ct);
-                 }
-               else
-                 {
-                   FloatComplexMatrix b (args(1).float_complex_matrix_value ());
-                   retval = convn (a, b, ct);
-                 }
-             }
-           else
-             {
-               FloatMatrix a (args(0).float_matrix_value ());
-               FloatMatrix b (args(1).float_matrix_value ());
-               retval = convn (a, b, ct);
-             }
-         }
-       else
-         {
-           if (args(0).is_complex_type () || args(1).is_complex_type ())
-             {
-               ComplexMatrix a (args(0).complex_matrix_value ());
-               if (args(1).is_real_type ())
-                 {
-                   Matrix b (args(1).matrix_value ());
-                   retval = convn (a, b, ct);
-                 }
-               else
-                 {
-                   ComplexMatrix b (args(1).complex_matrix_value ());
-                   retval = convn (a, b, ct);
-                 }
-             }
-           else
-             {
-               Matrix a (args(0).matrix_value ());
-               Matrix b (args(1).matrix_value ());
-               retval = convn (a, b, ct);
-             }
-         }
+      if (args(0).is_single_type () || args(1).is_single_type ()
+          || args(2).is_single_type ())
+        {
+          if (args(0).is_complex_type () || args(1).is_complex_type ()
+              || args(2).is_complex_type ())
+            {
+              FloatComplexMatrix a (args(2).float_complex_matrix_value ());
+              if (args(1).is_real_type () && args(2).is_real_type ())
+                {
+                  FloatColumnVector v1 (args(0).float_vector_value ());
+                  FloatRowVector v2 (args(1).float_vector_value ());
+                  retval = convn (a, v1, v2, ct);
+                }
+              else
+                {
+                  FloatComplexColumnVector v1 (args(0).float_complex_vector_value ());
+                  FloatComplexRowVector v2 (args(1).float_complex_vector_value ());
+                  retval = convn (a, v1, v2, ct);
+                }
+            }
+          else
+            {
+              FloatColumnVector v1 (args(0).float_vector_value ());
+              FloatRowVector v2 (args(1).float_vector_value ());
+              FloatMatrix a (args(2).float_matrix_value ());
+              retval = convn (a, v1, v2, ct);
+            }
+        }
+      else
+        {
+          if (args(0).is_complex_type () || args(1).is_complex_type ()
+              || args(2).is_complex_type ())
+            {
+              ComplexMatrix a (args(2).complex_matrix_value ());
+              if (args(1).is_real_type () && args(2).is_real_type ())
+                {
+                  ColumnVector v1 (args(0).vector_value ());
+                  RowVector v2 (args(1).vector_value ());
+                  retval = convn (a, v1, v2, ct);
+                }
+              else
+                {
+                  ComplexColumnVector v1 (args(0).complex_vector_value ());
+                  ComplexRowVector v2 (args(1).complex_vector_value ());
+                  retval = convn (a, v1, v2, ct);
+                }
+            }
+          else
+            {
+              ColumnVector v1 (args(0).vector_value ());
+              RowVector v2 (args(1).vector_value ());
+              Matrix a (args(2).matrix_value ());
+              retval = convn (a, v1, v2, ct);
+            }
+        }
+    } // if (separable)
+  else
+    {
+      if (args(0).is_single_type () || args(1).is_single_type ())
+        {
+          if (args(0).is_complex_type () || args(1).is_complex_type ())
+            {
+              FloatComplexMatrix a (args(0).float_complex_matrix_value ());
+              if (args(1).is_real_type ())
+                {
+                  FloatMatrix b (args(1).float_matrix_value ());
+                  retval = convn (a, b, ct);
+                }
+              else
+                {
+                  FloatComplexMatrix b (args(1).float_complex_matrix_value ());
+                  retval = convn (a, b, ct);
+                }
+            }
+          else
+            {
+              FloatMatrix a (args(0).float_matrix_value ());
+              FloatMatrix b (args(1).float_matrix_value ());
+              retval = convn (a, b, ct);
+            }
+        }
+      else
+        {
+          if (args(0).is_complex_type () || args(1).is_complex_type ())
+            {
+              ComplexMatrix a (args(0).complex_matrix_value ());
+              if (args(1).is_real_type ())
+                {
+                  Matrix b (args(1).matrix_value ());
+                  retval = convn (a, b, ct);
+                }
+              else
+                {
+                  ComplexMatrix b (args(1).complex_matrix_value ());
+                  retval = convn (a, b, ct);
+                }
+            }
+          else
+            {
+              Matrix a (args(0).matrix_value ());
+              Matrix b (args(1).matrix_value ());
+              retval = convn (a, b, ct);
+            }
+        }
 
-     } // if (separable)
+    } // if (separable)
 
-   return retval;
+  return retval;
 }
 
 /*
 %!test
 %! c = [0,1,2,3;1,8,12,12;4,20,24,21;7,22,25,18];
 %! assert (conv2 ([0,1;1,2], [1,2,3;4,5,6;7,8,9]), c);
 
 %!test
@@ -272,16 +278,17 @@ When the third argument is a matrix, ret
 %! A = conv2 (x, y)(5:end-4,5:end-4);
 %! B = conv2 (x, y, "valid");
 %! assert (B, A); ## Yes, this test is for *exact* equivalence.
 
 
 %% Test input validation
 %!error conv2 ()
 %!error conv2 (1)
+%!error <must be 1-D vectors or 2-D matrices> conv2 (ones (2), ones (2,2,2))
 %!error <SHAPE type not valid> conv2 (1,2, "NOT_A_SHAPE")
 %% Test alternate calling form which should be 2 vectors and a matrix
 %!error conv2 (ones (2), 1, 1)
 %!error conv2 (1, ones (2), 1)
 */
 
 DEFUN (convn, args, ,
   "-*- texinfo -*-\n\
@@ -380,14 +387,14 @@ The size of the result is @code{max (siz
       else
         {
           NDArray a (args(0).array_value ());
           NDArray b (args(1).array_value ());
           retval = convn (a, b, ct);
         }
     }
 
-   return retval;
+  return retval;
 }
 
 /*
  FIXME: Need tests for convn in addition to conv2.
 */
diff --git a/libinterp/corefcn/dlmread.cc b/libinterp/corefcn/dlmread.cc
--- a/libinterp/corefcn/dlmread.cc
+++ b/libinterp/corefcn/dlmread.cc
@@ -216,17 +216,17 @@ fields.  The default is zero.\n\
          return retval;
 
       std::string tname = file_ops::tilde_expand (fname);
 
       input_file.open (tname.c_str (), std::ios::in);
 
       if (! input_file)
         {
-          error ("dlmread: unable to open file `%s'", fname.c_str ());
+          error ("dlmread: unable to open file '%s'", fname.c_str ());
           return retval;
         }
       else
         input = &input_file;
     }
   else if (args(0).is_scalar_type ())
     {
       octave_stream is = octave_stream_list::lookup (args(0), "dlmread");
diff --git a/libinterp/corefcn/dot.cc b/libinterp/corefcn/dot.cc
--- a/libinterp/corefcn/dot.cc
+++ b/libinterp/corefcn/dot.cc
@@ -210,17 +210,17 @@ but avoids forming a temporary array and
                                                  z.fortran_vec ()));
                       retval = z;
                     }
                 }
               else
                 {
                   // Non-optimized evaluation.
                   octave_value_list tmp;
-                  tmp(1) = args(2);
+                  tmp(1) = dim + 1;
                   tmp(0) = do_binary_op (octave_value::op_el_mul, argx, argy);
                   if (! error_state)
                     {
                       tmp = feval ("sum", tmp, 1);
                       if (! tmp.empty ())
                         retval = tmp(0);
                     }
                 }
@@ -242,16 +242,29 @@ but avoids forming a temporary array and
 %!test
 %! x = [2, 1; 2, 1];
 %! y = [-0.5, 2; 0.5, -2];
 %! assert (dot (x, y), [0 0]);
 
 %!test
 %! x = [1+i, 3-i; 1-i, 3-i];
 %! assert (dot (x, x), [4, 20]);
+
+%!test
+%! x = int8 ([1 2]);
+%! y = int8 ([2 3]);
+%! assert (dot (x, y), 8);
+
+%!test
+%! x = int8 ([1 2; 3 4]);
+%! y = int8 ([5 6; 7 8]);
+%! assert (dot (x, y), [26 44]);
+%! assert (dot (x, y, 2), [17; 53]);
+%! assert (dot (x, y, 3), [5 12; 21 32]);
+
 */
 
 DEFUN (blkmm, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} blkmm (@var{A}, @var{B})\n\
 Compute products of matrix blocks.  The blocks are given as\n\
 2-dimensional subarrays of the arrays @var{A}, @var{B}.\n\
 The size of @var{A} must have the form @code{[m,k,@dots{}]} and\n\
diff --git a/libinterp/corefcn/mappers.cc b/libinterp/corefcn/mappers.cc
--- a/libinterp/corefcn/mappers.cc
+++ b/libinterp/corefcn/mappers.cc
@@ -1749,16 +1749,22 @@ Compute the @dfn{signum} function, which
 sign (x) =  0, x = 0;\n\
             1, x > 0.\n\
 @end group\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 \n\
 For complex arguments, @code{sign} returns @code{x ./ abs (@var{x})}.\n\
+\n\
+Note that @code{sign (-0.0)} is 0.\n\
+Although IEEE 754 floating point\n\
+allows zero to be signed, 0.0 and -0.0 compare equal.  If you must test\n\
+whether zero is signed, use the @code{signbit} function.\n\
+@seealso{signbit}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).signum ();
   else
     print_usage ();
 
@@ -1775,16 +1781,51 @@ For complex arguments, @code{sign} retur
 %!assert (sign (single (0)), single (0))
 %!assert (sign (single (3)), single (1))
 %!assert (sign (single ([1, -pi; e, 0])), single ([1, -1; 1, 0]))
 
 %!error sign ()
 %!error sign (1, 2)
 */
 
+DEFUNX ("signbit", Fsignbit, args, ,
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} signbit (@var{x})\n\
+Return a nonzero value if the value of @var{x} has its sign bit set.\n\
+\n\
+This is not the same as @code{x < 0.0}, because IEEE 754 floating point\n\
+allows zero to be signed.  The comparison @code{-0.0 < 0.0} is false,\n\
+but @code{signbit (-0.0)} will return a nonzero value.\n\
+@seealso{sign}\n\
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).xsignbit ();
+  else
+    print_usage ();
+
+  return retval;
+}
+
+/*
+%!assert (signbit (1) == 0)
+%!assert (signbit (-2) != 0)
+%!assert (signbit (0) == 0)
+%!assert (signbit (-0) != 0)
+
+%!assert (signbit (single (1)) == 0)
+%!assert (signbit (single (-2)) != 0)
+%!assert (signbit (single (0)) == 0)
+%!assert (signbit (single (-0)) != 0)
+
+%!error sign ()
+%!error sign (1, 2)
+*/
+
 DEFUN (sin, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sin (@var{x})\n\
 Compute the sine for each element of @var{x} in radians.\n\
 @seealso{asin, sind, sinh}\n\
 @end deftypefn")
 {
   octave_value retval;
diff --git a/libinterp/corefcn/mgorth.cc b/libinterp/corefcn/mgorth.cc
--- a/libinterp/corefcn/mgorth.cc
+++ b/libinterp/corefcn/mgorth.cc
@@ -46,25 +46,26 @@ do_mgorth (ColumnVector& x, const Matrix
   h(Vc) = xnorm (x);
   if (real (h(Vc)) > 0)
     x = x / h(Vc);
 }
 
 DEFUN (mgorth, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{y}, @var{h}] =} mgorth (@var{x}, @var{v})\n\
-Orthogonalize a given column vector @var{x} with respect to a given\n\
-orthonormal basis @var{v} using a modified Gram-Schmidt orthogonalization.  \n\
+Orthogonalize a given column vector @var{x} with respect to a set of\n\
+orthonormal vectors comprising the columns of @var{v}\n\
+using the modified Gram-Schmidt method.\n\
 On exit, @var{y} is a unit vector such that:\n\
 \n\
 @example\n\
 @group\n\
   norm (@var{y}) = 1\n\
   @var{v}' * @var{y} = 0\n\
-  @var{x} = @var{h}*[@var{v}, @var{y}]\n\
+  @var{x} = [@var{v}, @var{y}]*@var{h}'\n\
 @end group\n\
 @end example\n\
 \n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
@@ -76,17 +77,17 @@ On exit, @var{y} is a unit vector such t
   }
 
   octave_value arg_x = args(0);
   octave_value arg_v = args(1);
 
   if (arg_v.ndims () != 2 || arg_x.ndims () != 2 || arg_x.columns () != 1
       || arg_v.rows () != arg_x.rows ())
     {
-      error ("mgorth: V should me a matrix, and X a column vector with"
+      error ("mgorth: V should be a matrix, and X a column vector with"
              " the same number of rows as V.");
       return retval;
     }
 
   if (! arg_x.is_numeric_type () && ! arg_v.is_numeric_type ())
     {
       error ("mgorth: X and V must be numeric");
     }
diff --git a/libinterp/corefcn/module.mk b/libinterp/corefcn/module.mk
--- a/libinterp/corefcn/module.mk
+++ b/libinterp/corefcn/module.mk
@@ -6,28 +6,28 @@ EXTRA_DIST += \
 OPT_HANDLERS = \
   corefcn/DASPK-opts.cc \
   corefcn/DASRT-opts.cc \
   corefcn/DASSL-opts.cc \
   corefcn/LSODE-opts.cc \
   corefcn/Quad-opts.cc
 
 OPT_INC = \
-  $(top_builddir)/liboctave/DASPK-opts.h \
-  $(top_builddir)/liboctave/DASRT-opts.h \
-  $(top_builddir)/liboctave/DASSL-opts.h \
-  $(top_builddir)/liboctave/LSODE-opts.h \
-  $(top_builddir)/liboctave/Quad-opts.h
+  $(top_builddir)/liboctave/numeric/DASPK-opts.h \
+  $(top_builddir)/liboctave/numeric/DASRT-opts.h \
+  $(top_builddir)/liboctave/numeric/DASSL-opts.h \
+  $(top_builddir)/liboctave/numeric/LSODE-opts.h \
+  $(top_builddir)/liboctave/numeric/Quad-opts.h
 
-$(OPT_HANDLERS): corefcn/%.cc : $(top_builddir)/liboctave/%.in
+$(OPT_HANDLERS): corefcn/%.cc : $(top_builddir)/liboctave/numeric/%.in
 	$(PERL) $(top_srcdir)/build-aux/mk-opts.pl --opt-handler-fcns $< > $@-t
 	mv $@-t $@
 
 $(OPT_INC) : %.h : %.in
-	$(MAKE) -C $(top_builddir)/liboctave $(@F)
+	$(MAKE) -C $(top_builddir)/liboctave/numeric $(@F)
 
 COREFCN_SRC = \
   corefcn/__contourc__.cc \
   corefcn/__dispatch__.cc \
   corefcn/__lin_interpn__.cc \
   corefcn/__pchip_deriv__.cc \
   corefcn/__qp__.cc \
   corefcn/balance.cc \
@@ -90,9 +90,10 @@ COREFCN_SRC = \
   corefcn/syscalls.cc \
   corefcn/time.cc \
   corefcn/tril.cc \
   corefcn/typecast.cc
 
 noinst_LTLIBRARIES += corefcn/libcorefcn.la
 
 corefcn_libcorefcn_la_SOURCES = $(COREFCN_SRC)
+corefcn_libcorefcn_la_CPPFLAGS = $(liboctinterp_la_CPPFLAGS) $(FFTW_XCPPFLAGS)
 
diff --git a/libinterp/corefcn/quadcc.cc b/libinterp/corefcn/quadcc.cc
--- a/libinterp/corefcn/quadcc.cc
+++ b/libinterp/corefcn/quadcc.cc
@@ -1715,17 +1715,17 @@ Mathematical Software, Vol. 37, Issue 3,
               nans[nnans++] = i;
               iv->fx[i] = 0.0;
             }
         }
       Vinvfx (iv->fx, &(iv->c[idx[3]]), 3);
       Vinvfx (iv->fx, &(iv->c[idx[2]]), 2);
       Vinvfx (iv->fx, &(iv->c[0]), 0);
       for (i = 0; i < nnans; i++)
-        iv->fx[i] = octave_NaN;
+        iv->fx[nans[i]] = octave_NaN;
       iv->a = iivals[j];
       iv->b = iivals[j + 1];
       iv->depth = 3;
       iv->rdepth = 1;
       iv->ndiv = 0;
       iv->igral = 2 * h * iv->c[idx[3]] * w;
       nc = 0.0;
       for (i = n[2] + 1; i <= n[3]; i++)
@@ -1844,17 +1844,17 @@ Mathematical Software, Vol. 37, Issue 3,
 
           /* Compute the new coefficients. */
           Vinvfx (iv->fx, &(iv->c[idx[d]]), d);
           /* Downdate any NaNs. */
           if (nnans > 0)
             {
               downdate (&(iv->c[idx[d]]), n[d], d, nans, nnans);
               for (i = 0; i < nnans; i++)
-                iv->fx[i] = octave_NaN;
+                iv->fx[nans[i]] = octave_NaN;
             }
 
           /* Compute the error estimate. */
           nc = 0.0;
           for (i = n[d - 1] + 1; i <= n[d]; i++)
             {
               temp = iv->c[idx[d] + i];
               nc += temp * temp;
@@ -1989,17 +1989,17 @@ Mathematical Software, Vol. 37, Issue 3,
                   ivl->fx[i] = 0.0;
                 }
             }
           Vinvfx (ivl->fx, ivl->c, 0);
           if (nnans > 0)
             {
               downdate (ivl->c, n[0], 0, nans, nnans);
               for (i = 0; i < nnans; i++)
-                ivl->fx[i] = octave_NaN;
+                ivl->fx[nans[i]] = octave_NaN;
             }
           for (i = 0; i <= n[d]; i++)
             {
               ivl->c[idx[d] + i] = 0.0;
               for (j = i; j <= n[d]; j++)
                 ivl->c[idx[d] + i] += Tleft[i * 33 + j] * iv->c[idx[d] + j];
             }
           ncdiff = 0.0;
@@ -2085,17 +2085,17 @@ Mathematical Software, Vol. 37, Issue 3,
                   ivr->fx[i] = 0.0;
                 }
             }
           Vinvfx (ivr->fx, ivr->c, 0);
           if (nnans > 0)
             {
               downdate (ivr->c, n[0], 0, nans, nnans);
               for (i = 0; i < nnans; i++)
-                ivr->fx[i] = octave_NaN;
+                ivr->fx[nans[i]] = octave_NaN;
             }
           for (i = 0; i <= n[d]; i++)
             {
               ivr->c[idx[d] + i] = 0.0;
               for (j = i; j <= n[d]; j++)
                 ivr->c[idx[d] + i] += Tright[i * 33 + j] * iv->c[idx[d] + j];
             }
           ncdiff = 0.0;
@@ -2250,16 +2250,29 @@ Mathematical Software, Vol. 37, Issue 3,
 %!assert (quadcc (@sin, -pi, 0), -2, 1e-6)
 %!assert (quadcc (@sin, 0, pi), 2, 1e-6)
 %!assert (quadcc (@(x) 1./sqrt (x), 0, 1), 2, 1e-6)
 %!assert (quadcc (@(x) 1./(sqrt (x).*(x+1)), 0, Inf), pi, 1e-6)
 
 %!assert (quadcc (@(x) exp (-x .^ 2), -Inf, Inf), sqrt (pi), 1e-6)
 %!assert (quadcc (@(x) exp (-x .^ 2), -Inf, 0), sqrt (pi)/2, 1e-6)
 
+## Test function with NaNs in interval 
+%!function y = __nansin (x)
+%!  nan_locs = [-3*pi/4, -pi/4, 0, pi/3, pi/2, pi];
+%!  y = sin (x);
+%!  idx = min (abs (bsxfun (@minus, x(:), nan_locs)), [], 2); 
+%!  y(idx < 1e-10) = NaN;
+%!endfunction 
+
+%!test
+%! [q, err, npoints] = quadcc ("__nansin", -pi, pi); 
+%! assert (q, 0, eps);
+%! assert (err, 0, 15*eps);
+
 %% Test input validation
 %!error (quadcc ())
 %!error (quadcc (@sin))
 %!error (quadcc (@sin, 0))
 %!error (quadcc (@sin, ones (2), pi))
 %!error (quadcc (@sin, -i, pi))
 %!error (quadcc (@sin, 0, ones (2)))
 %!error (quadcc (@sin, 0, i))
diff --git a/libinterp/corefcn/rcond.cc b/libinterp/corefcn/rcond.cc
--- a/libinterp/corefcn/rcond.cc
+++ b/libinterp/corefcn/rcond.cc
@@ -86,9 +86,18 @@ instead.\n\
   return retval;
 }
 
 /*
 %!assert (rcond (eye (2)), 1)
 %!assert (rcond (ones (2)), 0)
 %!assert (rcond ([1 1; 2 1]), 1/9)
 %!assert (rcond (magic (4)), 0, eps)
+
+%!shared x, sx
+%! x = [-5.25, -2.25; -2.25, 1] * eps () + ones (2) / 2;
+%! sx = [-5.25, -2.25; -2.25, 1] * eps ("single") + ones (2) / 2;
+%!assert (rcond (x) < eps ());
+%!assert (rcond (sx) < eps ('single'));
+%!assert (rcond (x*i) < eps ());
+%!assert (rcond (sx*i) < eps ('single'));
+
 */
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -40,42 +40,87 @@ along with Octave; see the file COPYING.
 #include "Cell.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-map.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 // Replace backslash escapes in a string with the real values.  We need
-// this special function instead of the one in utils.cc because the set
-// of escape sequences used in regexps is different from those used in
-// the *printf functions.
+// two special functions instead of the one in utils.cc because the set
+// of escape sequences used for regexp patterns and replacement strings
+// is different from those used in the *printf functions.
 
 static std::string
-do_regexp_string_escapes (const std::string& s)
+do_regexp_ptn_string_escapes (const std::string& s)
 {
   std::string retval;
 
   size_t i = 0;
   size_t j = 0;
   size_t len = s.length ();
 
   retval.resize (len);
 
   while (j < len)
     {
       if (s[j] == '\\' && j+1 < len)
         {
           switch (s[++j])
             {
-            case '$':
-              retval[i] = '$';
+            case 'b': // backspace
+              retval[i] = '\b';
               break;
 
-            case 'a':
+#if 0
+// FIXME : To be complete, we need to handle \oN, \o{N}.
+//         The PCRE library already handles \N where N
+//         is an octal number.  New code needs to merely
+//         replace \oN or \o{N} with \N.
+            case 'o': // octal number
+#endif
+
+            default:  // pass escape sequence through
+              retval[i] = '\\';
+              retval[++i] = s[j];
+              break;
+            }
+        }
+      else
+        {
+          retval[i] = s[j];
+        }
+
+      i++;
+      j++;
+    }
+
+  retval.resize (i);
+
+  return retval;
+}
+
+static std::string
+do_regexp_rep_string_escapes (const std::string& s)
+{
+  std::string retval;
+
+  size_t i = 0;
+  size_t j = 0;
+  size_t len = s.length ();
+
+  retval.resize (len);
+
+  while (j < len)
+    {
+      if (s[j] == '\\' && j+1 < len)
+        {
+          switch (s[++j])
+            {
+            case 'a': // alarm
               retval[i] = '\a';
               break;
 
             case 'b': // backspace
               retval[i] = '\b';
               break;
 
             case 'f': // formfeed
@@ -93,30 +138,26 @@ do_regexp_string_escapes (const std::str
             case 't': // horizontal tab
               retval[i] = '\t';
               break;
 
             case 'v': // vertical tab
               retval[i] = '\v';
               break;
 
-            case '\\': // backslash
-              retval[i] = '\\';
-              break;
-
 #if 0
 // FIXME -- to be complete, we need to handle \oN, \o{N}, \xN, and
 // \x{N}.  Hex digits may be upper or lower case.  Brackets are
 // optional, so \x5Bz is the same as \x{5B}z.
 
             case 'o': // octal number
             case 'x': // hex number
 #endif
-
-            default:
+ 
+            default:  // pass escape sequence through
               retval[i] = '\\';
               retval[++i] = s[j];
               break;
             }
         }
       else
         {
           retval[i] = s[j];
@@ -200,17 +241,17 @@ octregexp (const octave_value_list &args
   if (error_state)
     return retval;
 
   std::string pattern = args(1).string_value ();
   if (error_state)
     return retval;
   // Matlab compatibility.
   if (args(1).is_sq_string ())
-    pattern = do_regexp_string_escapes (pattern);
+    pattern = do_regexp_ptn_string_escapes (pattern);
 
   regexp::opts options;
   options.case_insensitive (case_insensitive);
   bool extra_options = false;
   parse_options (options, args, who, 2, extra_options);
   if (error_state)
     return retval;
 
@@ -1191,24 +1232,24 @@ octregexprep (const octave_value_list &a
   if (error_state)
     return retval;
 
   std::string pattern = args(1).string_value ();
   if (error_state)
     return retval;
   // Matlab compatibility.
   if (args(1).is_sq_string ())
-    pattern = do_regexp_string_escapes (pattern);
+    pattern = do_regexp_ptn_string_escapes (pattern);
 
   std::string replacement = args(2).string_value ();
   if (error_state)
     return retval;
   // Matlab compatibility.
   if (args(2).is_sq_string ())
-    replacement = do_regexp_string_escapes (replacement);
+    replacement = do_regexp_rep_string_escapes (replacement);
 
   // Pack options excluding 'tokenize' and various output
   // reordering strings into regexp arg list
   octave_value_list regexpargs (nargin-3, octave_value ());
 
   int len = 0;
   for (int i = 3; i < nargin; i++)
     {
diff --git a/libinterp/corefcn/schur.cc b/libinterp/corefcn/schur.cc
--- a/libinterp/corefcn/schur.cc
+++ b/libinterp/corefcn/schur.cc
@@ -164,17 +164,17 @@ Riccati equations in control (see @code{
     }
   else
     {
       char ord_char = ord.empty () ? 'U' : ord[0];
 
       if (ord_char != 'U' && ord_char != 'A' && ord_char != 'D'
           && ord_char != 'u' && ord_char != 'a' && ord_char != 'd')
         {
-          warning ("schur: incorrect ordered schur argument `%c'",
+          warning ("schur: incorrect ordered schur argument '%c'",
                    ord.c_str ());
           return retval;
         }
     }
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
diff --git a/libinterp/corefcn/svd.cc b/libinterp/corefcn/svd.cc
--- a/libinterp/corefcn/svd.cc
+++ b/libinterp/corefcn/svd.cc
@@ -211,17 +211,17 @@ decomposition, eliminating the unnecessa
                     }
 
                   FloatSVD result (tmp, type, driver);
 
                   FloatDiagMatrix sigma = result.singular_values ();
 
                   if (nargout == 0 || nargout == 1)
                     {
-                      retval(0) = sigma.diag ();
+                      retval(0) = sigma.extract_diag ();
                     }
                   else
                     {
                       retval(2) = result.right_singular_matrix ();
                       retval(1) = sigma;
                       retval(0) = result.left_singular_matrix ();
                     }
                 }
@@ -239,17 +239,17 @@ decomposition, eliminating the unnecessa
                     }
 
                   FloatComplexSVD result (ctmp, type, driver);
 
                   FloatDiagMatrix sigma = result.singular_values ();
 
                   if (nargout == 0 || nargout == 1)
                     {
-                      retval(0) = sigma.diag ();
+                      retval(0) = sigma.extract_diag ();
                     }
                   else
                     {
                       retval(2) = result.right_singular_matrix ();
                       retval(1) = sigma;
                       retval(0) = result.left_singular_matrix ();
                     }
                 }
@@ -270,17 +270,17 @@ decomposition, eliminating the unnecessa
                     }
 
                   SVD result (tmp, type, driver);
 
                   DiagMatrix sigma = result.singular_values ();
 
                   if (nargout == 0 || nargout == 1)
                     {
-                      retval(0) = sigma.diag ();
+                      retval(0) = sigma.extract_diag ();
                     }
                   else
                     {
                       retval(2) = result.right_singular_matrix ();
                       retval(1) = sigma;
                       retval(0) = result.left_singular_matrix ();
                     }
                 }
@@ -298,17 +298,17 @@ decomposition, eliminating the unnecessa
                     }
 
                   ComplexSVD result (ctmp, type, driver);
 
                   DiagMatrix sigma = result.singular_values ();
 
                   if (nargout == 0 || nargout == 1)
                     {
-                      retval(0) = sigma.diag ();
+                      retval(0) = sigma.extract_diag ();
                     }
                   else
                     {
                       retval(2) = result.right_singular_matrix ();
                       retval(1) = sigma;
                       retval(0) = result.left_singular_matrix ();
                     }
                 }
diff --git a/libinterp/corefcn/typecast.cc b/libinterp/corefcn/typecast.cc
--- a/libinterp/corefcn/typecast.cc
+++ b/libinterp/corefcn/typecast.cc
@@ -20,16 +20,18 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include <climits>
+
 #include "mx-base.h"
 
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "unwind-prot.h"
 
@@ -125,17 +127,17 @@ bit length of @var{x} is not divisible b
 occurs.\n\
 \n\
 An example of the use of typecast on a little-endian machine is\n\
 \n\
 @example\n\
 @group\n\
 @var{x} = uint16 ([1, 65535]);\n\
 typecast (@var{x}, \"uint8\")\n\
-  @result{} [   0,   1, 255, 255]\n\
+@result{} [   1,   0, 255, 255]\n\
 @end group\n\
 @end example\n\
 @seealso{cast, bitunpack, bitpack, swapbytes}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 2)
diff --git a/libinterp/dldfcn/__fltk_uigetfile__.cc b/libinterp/dldfcn/__fltk_uigetfile__.cc
--- a/libinterp/dldfcn/__fltk_uigetfile__.cc
+++ b/libinterp/dldfcn/__fltk_uigetfile__.cc
@@ -19,40 +19,43 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#if defined (HAVE_FLTK)
+#ifdef HAVE_FLTK
 
 #ifdef WIN32
 #define WIN32_LEAN_AND_MEAN
 #endif
 
 #include <FL/Fl.H>
 #include <FL/Fl_File_Chooser.H>
 
 // FLTK headers may include X11/X.h which defines Complex, and that
 // conflicts with Octave's Complex typedef.  We don't need the X11
 // Complex definition in this file, so remove it before including Octave
 // headers which may require Octave's Complex typedef.
 #undef Complex
 
+#endif
+
 #include "defun-dld.h"
 #include "file-ops.h"
 
 DEFUN_DLD (__fltk_uigetfile__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __fltk_uigetfile__ (@dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
+#ifdef HAVE_FLTK
   // Expected argument list:
   //
   //   args(0) ... FileFilter in fltk format
   //   args(1) ... Title
   //   args(2) ... Default Filename
   //   args(3) ... PostionValue [x,y]
   //   args(4) ... SelectValue "on"/"off"/"dir"/"create"
 
@@ -127,16 +130,19 @@ Undocumented internal function.\n\
           retval(2) = fc.filter_value () + 1;
         }
     }
 
   fc.hide ();
   Fl::flush ();
 
   return retval;
+#else
+  error ("__fltk_uigetfile__: not available without OpenGL and FLTK libraries");
+  return octave_value ();
+#endif
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
 
-#endif
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -24,26 +24,26 @@ along with Octave; see the file COPYING.
 
 To initialize:
 
   graphics_toolkit ("fltk");
   plot (randn (1e3, 1));
 
 */
 
-// PKG_ADD: register_graphics_toolkit ("fltk");
+// PKG_ADD: if (__have_fltk__ ()) register_graphics_toolkit ("fltk"); endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "defun-dld.h"
 #include "error.h"
 
-#if defined (HAVE_FLTK)
+#ifdef HAVE_FLTK
 
 #include <map>
 #include <set>
 #include <sstream>
 #include <iostream>
 
 #ifdef WIN32
 #define WIN32_LEAN_AND_MEAN
@@ -1979,61 +1979,103 @@ public:
         feval ("remove_input_event_hook", args, 0);
 
         // FIXME ???
         Fl::wait (fltk_maxtime);
       }
   }
 };
 
+#endif
+
 // Initialize the fltk graphics toolkit.
 
-DEFUN_DLD (__init_fltk__, , , "")
+DEFUN_DLD (__init_fltk__, , ,
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {} __init_fltk__ ()\n\
+Undocumented internal function.\n\
+@end deftypefn")
 {
+#ifdef HAVE_FLTK
   if (! toolkit_loaded)
     {
       mlock ();
 
       graphics_toolkit tk (new fltk_graphics_toolkit ());
       gtk_manager::load_toolkit (tk);
       toolkit_loaded = true;
 
       octave_value_list args;
       args(0) = "__fltk_redraw__";
       feval ("add_input_event_hook", args, 0);
     }
-
-  octave_value retval;
-  return retval;
-}
-
-DEFUN_DLD (__fltk_redraw__, , , "")
-{
-  __fltk_redraw__ ();
+#else
+  error ("__init_fltk__: not available without OpenGL and FLTK libraries");
+#endif
 
   return octave_value ();
 }
 
-DEFUN_DLD (__fltk_maxtime__, args, ,"")
+DEFUN_DLD (__fltk_redraw__, , ,
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {} __fltk_redraw__ ()\n\
+Undocumented internal function.\n\
+@end deftypefn")
 {
+#ifdef HAVE_FLTK
+  __fltk_redraw__ ();
+#else
+  error ("__fltk_redraw__: not available without OpenGL and FLTK libraries");
+#endif
+
+  return octave_value ();
+}
+
+DEFUN_DLD (__fltk_maxtime__, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn  {Loadable Function} {@var{maxtime} =} __fltk_maxtime__ ()\n\
+@deftypefnx {Loadable Function} {} __fltk_maxtime__ (@var{maxtime})\n\
+Undocumented internal function.\n\
+@end deftypefn")
+{
+#ifdef HAVE_FLTK
   octave_value retval = fltk_maxtime;
 
   if (args.length () == 1)
     {
       if (args(0).is_real_scalar ())
         fltk_maxtime = args(0).double_value ();
       else
         error ("argument must be a real scalar");
     }
 
   return retval;
+#else
+  error ("__fltk_maxtime__: not available without OpenGL and FLTK libraries");
+  return octave_value ();
+#endif
 }
 
+DEFUN_DLD (__have_fltk__, , ,
+  "-*- texinfo -*-\n\
+@deftypefn  {Loadable Function} {@var{FLTK_available} =} __have_fltk__ ()\n\
+Undocumented internal function.\n\
+@end deftypefn")
+{
+  octave_value retval;
+
+#ifdef HAVE_FLTK
+  retval = true;
+#else
+  retval = false;
 #endif
 
+  return retval;
+}
+
 // FIXME -- This function should be abstracted and made potentially
 // available to all graphics toolkits.  This suggests putting it in
 // graphics.cc as is done for drawnow() and having the master
 // mouse_wheel_zoom function call fltk_mouse_wheel_zoom.  The same
 // should be done for gui_mode and fltk_gui_mode.  For now (2011.01.30),
 // just changing function names and docstrings.
 
 DEFUN_DLD (mouse_wheel_zoom, args, ,
@@ -2041,17 +2083,17 @@ DEFUN_DLD (mouse_wheel_zoom, args, ,
 @deftypefn  {Built-in Function} {@var{speed} =} mouse_wheel_zoom ()\n\
 @deftypefnx {Built-in Function} {} mouse_wheel_zoom (@var{speed})\n\
 Query or set the mouse wheel zoom factor.\n\
 \n\
 This function is currently implemented only for the FLTK graphics toolkit.\n\
 @seealso{gui_mode}\n\
 @end deftypefn")
 {
-#if defined (HAVE_FLTK)
+#ifdef HAVE_FLTK
   octave_value retval = wheel_zoom_speed;
 
   if (args.length () == 1)
     {
       if (args(0).is_real_scalar ())
         wheel_zoom_speed = args(0).double_value ();
       else
         error ("mouse_wheel_zoom: SPEED must be a real scalar");
@@ -2081,17 +2123,17 @@ Allows rotating and zooming of current a
 @item 'none'\n\
 Mouse inputs have no effect.\n\
 @end table\n\
 \n\
 This function is currently implemented only for the FLTK graphics toolkit.\n\
 @seealso{mouse_wheel_zoom}\n\
 @end deftypefn")
 {
-#if defined (HAVE_FLTK)
+#ifdef HAVE_FLTK
   caseless_str mode_str;
 
   if (gui_mode == pan_zoom)
     mode_str = "2d";
   else if (gui_mode == rotate_zoom)
     mode_str = "3d";
   else
     mode_str = "none";
@@ -2117,13 +2159,12 @@ This function is currently implemented o
         failed = true;
     }
 
   if (failed)
     error ("MODE must be one of the strings: \"2D\", \"3D\", or \"none\"");
 
   return octave_value (mode_str);
 #else
-  error ("mouse_wheel_zoom: not available without OpenGL and FLTK libraries");
+  error ("gui_mode: not available without OpenGL and FLTK libraries");
   return octave_value ();
 #endif
 }
-
diff --git a/libinterp/dldfcn/__init_gnuplot__.cc b/libinterp/dldfcn/__init_gnuplot__.cc
--- a/libinterp/dldfcn/__init_gnuplot__.cc
+++ b/libinterp/dldfcn/__init_gnuplot__.cc
@@ -28,16 +28,17 @@ To initialize:
   plot (randn (1e3, 1));
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include "builtins.h"
 #include "defun-dld.h"
 #include "error.h"
 #include "graphics.h"
 #include "parse.h"
 #include "variables.h"
 
 // PKG_ADD: register_graphics_toolkit ("gnuplot");
 
@@ -143,34 +144,27 @@ private:
     {
       if (! pstream.is_empty ())
         {
           octave_value_list args;
           Matrix fids = pstream.matrix_value ();
 
           if (! error_state)
             {
-              args(1) = "\nquit;\n";
-              args(0) = fids(0);
-              feval ("fputs", args);
+              Ffputs (ovl (fids(0), "\nquit;\n"));
 
-              args.resize (1);
-              feval ("fflush", args);
-              feval ("pclose", args);
+              Ffflush (ovl (fids(0)));
+              Fpclose (ovl (fids(0)));
 
               if (fids.numel () > 1)
                 {
-                  args(0) = fids(1);
-                  feval ("pclose", args);
+                  Fpclose (ovl (fids(1)));
 
                   if (fids.numel () > 2)
-                    {
-                      args(0) = fids(2);
-                      feval ("waitpid", args);
-                    }
+                    Fwaitpid (ovl (fids(2)));
                 }
             }
         }
     }
 };
 
 // Initialize the fltk graphics toolkit.
 
diff --git a/libinterp/dldfcn/__magick_read__.cc b/libinterp/dldfcn/__magick_read__.cc
--- a/libinterp/dldfcn/__magick_read__.cc
+++ b/libinterp/dldfcn/__magick_read__.cc
@@ -376,17 +376,17 @@ static void
 maybe_initialize_magick (void)
 {
 #ifdef HAVE_MAGICK
 
   static bool initialized = false;
 
   if (! initialized)
     {
-      // Save the locale as GraphicsMagick might change this (depending on version)
+      // Save locale as GraphicsMagick might change this (depending on version)
       const char *static_locale = setlocale (LC_ALL, NULL);
       const std::string locale (static_locale);
 
       std::string program_name = octave_env::get_program_invocation_name ();
 
       Magick::InitializeMagick (program_name.c_str ());
 
       // Restore locale from before GraphicsMagick initialisation
@@ -1075,17 +1075,17 @@ not be using this function.  Instead use
           octave_localtime mtime = fs.mtime ();
 
           filetime = mtime.strftime ("%e-%b-%Y %H:%M:%S");
         }
       else
         {
           std::string msg = fs.error ();
 
-          error ("imfinfo: error reading `%s': %s",
+          error ("imfinfo: error reading '%s': %s",
                  filename.c_str (), msg.c_str ());
 
           return retval;
         }
 
       // For each frame in the image (some images contain multiple
       // layers, each to be treated like a separate image).
       for (int frame = 0; frame < nframes; frame++)
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -175,35 +175,38 @@ sparse matrices.\n\
     }
 
   if (! error_state)
     {
       octave_value arg = args(0);
 
       octave_idx_type nr = arg.rows ();
       octave_idx_type nc = arg.columns ();
-      bool natural = (nargout != 3);
 
       int arg_is_empty = empty_arg ("chol", nr, nc);
 
       if (arg_is_empty < 0)
         return retval;
       if (arg_is_empty > 0)
         return octave_value (Matrix ());
 
       if (arg.is_sparse_type ())
         {
+          octave_idx_type info;
+          bool natural = (nargout != 3);
+          bool force = nargout > 1;
+
           if (arg.is_real_type ())
             {
               SparseMatrix m = arg.sparse_matrix_value ();
 
               if (! error_state)
                 {
-                  octave_idx_type info = nargout;
-                  SparseCHOL fact (m, info, natural);
+                  SparseCHOL fact (m, info, natural, force);
+
                   if (nargout == 3)
                     {
                       if (vecout)
                         retval(2) = fact.perm ();
                       else
                         retval(2) = fact.Q ();
                     }
 
@@ -220,18 +223,17 @@ sparse matrices.\n\
                 }
             }
           else if (arg.is_complex_type ())
             {
               SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
               if (! error_state)
                 {
-                  octave_idx_type info = nargout;
-                  SparseComplexCHOL fact (m, info, natural);
+                  SparseComplexCHOL fact (m, info, natural, force);
 
                   if (nargout == 3)
                     {
                       if (vecout)
                         retval(2) = fact.perm ();
                       else
                         retval(2) = fact.Q ();
                     }
@@ -400,38 +402,40 @@ symmetric positive definite matrix @var{
       octave_idx_type nc = arg.columns ();
 
       if (nr == 0 || nc == 0)
         retval = Matrix ();
       else
         {
           if (arg.is_sparse_type ())
             {
+              octave_idx_type info;
+
               if (arg.is_real_type ())
                 {
                   SparseMatrix m = arg.sparse_matrix_value ();
 
                   if (! error_state)
                     {
-                      octave_idx_type info;
                       SparseCHOL chol (m, info);
+
                       if (info == 0)
                         retval = chol.inverse ();
                       else
                         error ("cholinv: A must be positive definite");
                     }
                 }
               else if (arg.is_complex_type ())
                 {
                   SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
                   if (! error_state)
                     {
-                      octave_idx_type info;
                       SparseComplexCHOL chol (m, info);
+
                       if (info == 0)
                         retval = chol.inverse ();
                       else
                         error ("cholinv: A must be positive definite");
                     }
                 }
               else
                 gripe_wrong_type_arg ("cholinv", arg);
diff --git a/libinterp/dldfcn/config-module.awk b/libinterp/dldfcn/config-module.awk
--- a/libinterp/dldfcn/config-module.awk
+++ b/libinterp/dldfcn/config-module.awk
@@ -66,12 +66,12 @@ BEGIN {
       {
         printf ("dldfcn/%s.df: CPPFLAGS += %s\n",
                 basename, cppflags[i]);
         printf ("dldfcn_%s_la_CPPFLAGS = $(AM_CPPFLAGS) %s\n",
                 basename, cppflags[i]);
       }
     printf ("dldfcn_%s_la_LDFLAGS = -avoid-version -module $(NO_UNDEFINED_LDFLAG) %s $(OCT_LINK_OPTS)\n",
             basename, ldflags[i]);
-    printf ("dldfcn_%s_la_LIBADD = $(DLD_LIBOCTINTERP_LIBADD) ../liboctave/liboctave.la ../libcruft/libcruft.la %s $(OCT_LINK_DEPS)\n",
+    printf ("dldfcn_%s_la_LIBADD = $(DLD_LIBOCTINTERP_LIBADD) ../liboctave/liboctave.la %s $(OCT_LINK_DEPS)\n",
             basename, libraries[i]);
   }
 }
diff --git a/libinterp/dldfcn/urlwrite.cc b/libinterp/dldfcn/urlwrite.cc
--- a/libinterp/dldfcn/urlwrite.cc
+++ b/libinterp/dldfcn/urlwrite.cc
@@ -50,21 +50,16 @@ along with Octave; see the file COPYING.
 #include "unwind-prot.h"
 
 #ifdef HAVE_CURL
 
 #include <curl/curl.h>
 #include <curl/curlver.h>
 #include <curl/easy.h>
 
-// Backwards compatibility for curl < 7.17.0
-#if LIBCURL_VERSION_NUM < 0x071100
-#define CURLOPT_DIRLISTONLY CURLOPT_FTPLISTONLY
-#endif
-
 static int
 write_data (void *buffer, size_t size, size_t nmemb, void *streamp)
 {
   std::ostream& stream = *(static_cast<std::ostream*> (streamp));
   stream.write (static_cast<const char*> (buffer), size*nmemb);
   return (stream.fail () ? 0 : size * nmemb);
 }
 
@@ -144,16 +139,18 @@ private:
 
     bool is_binary (void) const
       {
         return !ascii;
       }
 
     octave_refcount<size_t> count;
     std::string host;
+    std::string url;
+    std::string userpwd;
     bool valid;
     bool ascii;
     mutable CURLcode errnum;
 
   private:
     CURL *curl;
 
     // No copying!
@@ -182,34 +179,39 @@ public:
 
   curl_handle (const std::string& _host, const std::string& user,
                const std::string& passwd) :
     rep (new curl_handle_rep ())
     {
       rep->host = _host;
       init (user, passwd, std::cin, octave_stdout);
 
-      std::string url = "ftp://" + _host;
-      setopt (CURLOPT_URL, url.c_str ());
+      rep->url = "ftp://" + _host;
+      setopt (CURLOPT_URL, rep->url.c_str ());
 
       // Setup the link, with no transfer
       if (!error_state)
         perform ();
     }
 
   curl_handle (const std::string& url, const std::string& method,
                const Cell& param, std::ostream& os, bool& retval) :
     rep (new curl_handle_rep ())
     {
       retval = false;
 
       init ("", "", std::cin, os);
 
       setopt (CURLOPT_NOBODY, 0);
 
+      // Restore the default HTTP request method to GET after setting
+      // NOBODY to true and back to false.  This is needed for backward
+      // compatibility with versions of libcurl < 7.18.2.
+      setopt (CURLOPT_HTTPGET, 1);
+
       // Don't need to store the parameters here as we can't change
       // the URL after the handle is created
       std::string query_string = form_query_string (param);
 
       if (method == "get")
         {
           query_string = url + "?" + query_string;
           setopt (CURLOPT_URL, query_string.c_str ());
@@ -353,71 +355,71 @@ public:
       if (! error_state)
         perform ();
       setopt (CURLOPT_POSTQUOTE, 0);
       curl_slist_free_all (slist);
     }
 
   void put (const std::string& file, std::istream& is) const
     {
-      std::string url = "ftp://" + rep->host + "/" + file;
-      setopt (CURLOPT_URL, url.c_str ());
+      rep->url = "ftp://" + rep->host + "/" + file;
+      setopt (CURLOPT_URL, rep->url.c_str ());
       setopt (CURLOPT_UPLOAD, 1);
       setopt (CURLOPT_NOBODY, 0);
       set_istream (is);
       if (! error_state)
         perform ();
       set_istream (std::cin);
       setopt (CURLOPT_NOBODY, 1);
       setopt (CURLOPT_UPLOAD, 0);
-      url = "ftp://" + rep->host;
-      setopt (CURLOPT_URL, url.c_str ());
+      rep->url = "ftp://" + rep->host;
+      setopt (CURLOPT_URL, rep->url.c_str ());
     }
 
   void get (const std::string& file, std::ostream& os) const
     {
-      std::string url = "ftp://" + rep->host + "/" + file;
-      setopt (CURLOPT_URL, url.c_str ());
+      rep->url = "ftp://" + rep->host + "/" + file;
+      setopt (CURLOPT_URL, rep->url.c_str ());
       setopt (CURLOPT_NOBODY, 0);
       set_ostream (os);
       if (! error_state)
         perform ();
       set_ostream (octave_stdout);
       setopt (CURLOPT_NOBODY, 1);
-      url = "ftp://" + rep->host;
-      setopt (CURLOPT_URL, url.c_str ());
+      rep->url = "ftp://" + rep->host;
+      setopt (CURLOPT_URL, rep->url.c_str ());
     }
 
   void dir (void) const
     {
-      std::string url = "ftp://" + rep->host + "/";
-      setopt (CURLOPT_URL, url.c_str ());
+      rep->url = "ftp://" + rep->host + "/";
+      setopt (CURLOPT_URL, rep->url.c_str ());
       setopt (CURLOPT_NOBODY, 0);
       if (! error_state)
         perform ();
       setopt (CURLOPT_NOBODY, 1);
-      url = "ftp://" + rep->host;
-      setopt (CURLOPT_URL, url.c_str ());
+      rep->url = "ftp://" + rep->host;
+      setopt (CURLOPT_URL, rep->url.c_str ());
     }
 
   string_vector list (void) const
     {
       std::ostringstream buf;
-      std::string url = "ftp://" + rep->host + "/";
+      rep->url = "ftp://" + rep->host + "/";
       setopt (CURLOPT_WRITEDATA, static_cast<void*> (&buf));
-      setopt (CURLOPT_URL, url.c_str ());
+      setopt (CURLOPT_URL, rep->url.c_str ());
       setopt (CURLOPT_DIRLISTONLY, 1);
       setopt (CURLOPT_NOBODY, 0);
       if (! error_state)
         perform ();
       setopt (CURLOPT_NOBODY, 1);
-      url = "ftp://" + rep->host;
+      rep->url = "ftp://" + rep->host;
       setopt (CURLOPT_WRITEDATA, static_cast<void*> (&octave_stdout));
       setopt (CURLOPT_DIRLISTONLY, 0);
-      setopt (CURLOPT_URL, url.c_str ());
+      setopt (CURLOPT_URL, rep->url.c_str ());
 
       // Count number of directory entries
       std::string str = buf.str ();
       octave_idx_type n = 0;
       size_t pos = 0;
       while (true)
         {
           pos = str.find_first_of ('\n', pos);
@@ -440,18 +442,18 @@ public:
       return retval;
     }
 
   void get_fileinfo (const std::string& filename, double& filesize,
                      time_t& filetime, bool& fileisdir) const
     {
       std::string path = pwd ();
 
-      std::string url = "ftp://" + rep->host + "/" + path + "/" + filename;
-      setopt (CURLOPT_URL, url.c_str ());
+      rep->url = "ftp://" + rep->host + "/" + path + "/" + filename;
+      setopt (CURLOPT_URL, rep->url.c_str ());
       setopt (CURLOPT_FILETIME, 1);
       setopt (CURLOPT_HEADERFUNCTION, throw_away);
       setopt (CURLOPT_WRITEFUNCTION, throw_away);
 
       // FIXME
       // The MDTM command fails for a directory on the servers I tested
       // so this is a means of testing for directories. It also means
       // I can't get the date of directories!
@@ -474,18 +476,18 @@ public:
                                  CURLINFO_CONTENT_LENGTH_DOWNLOAD, &fs);
               filesize = fs;
             }
         }
 
       setopt (CURLOPT_WRITEFUNCTION, write_data);
       setopt (CURLOPT_HEADERFUNCTION, 0);
       setopt (CURLOPT_FILETIME, 0);
-      url = "ftp://" + rep->host;
-      setopt (CURLOPT_URL, url.c_str ());
+      rep->url = "ftp://" + rep->host;
+      setopt (CURLOPT_URL, rep->url.c_str ());
 
       // The MDTM command seems to reset the path to the root with the
       // servers I tested with, so cd again into the correct path. Make
       // the path absolute so that this will work even with servers that
       // don't end up in the root after an MDTM command.
       cwd ("/" + path);
     }
 
@@ -557,21 +559,21 @@ private:
 
   void init (const std::string& user, const std::string& passwd,
              std::istream& is, std::ostream& os)
     {
       // No data transfer by default
       setopt (CURLOPT_NOBODY, 1);
 
       // Set the username and password
-      std::string userpwd = user;
+      rep->userpwd = user;
       if (! passwd.empty ())
-        userpwd += ":" + passwd;
-      if (! userpwd.empty ())
-        setopt (CURLOPT_USERPWD, userpwd.c_str ());
+        rep->userpwd += ":" + passwd;
+      if (! rep->userpwd.empty ())
+        setopt (CURLOPT_USERPWD, rep->userpwd.c_str ());
 
       // Define our callback to get called when there's data to be written.
       setopt (CURLOPT_WRITEFUNCTION, write_data);
 
       // Set a pointer to our struct to pass to the callback.
       setopt (CURLOPT_WRITEDATA, static_cast<void*> (&os));
 
       // Define our callback to get called when there's data to be read
diff --git a/libinterp/interp-core/action-container.h b/libinterp/interp-core/action-container.h
new file mode 100644
--- /dev/null
+++ b/libinterp/interp-core/action-container.h
@@ -0,0 +1,342 @@
+/*
+
+Copyright (C) 1993-2012 John W. Eaton
+Copyright (C) 2009-2010 VZLU Prague
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if !defined (octave_action_container_h)
+#define octave_action_container_h 1
+
+// This class allows registering actions in a list for later
+// execution, either explicitly or when the container goes out of
+// scope.
+
+// FIXME -- is there a better name for this class?
+
+class
+OCTINTERP_API
+action_container
+{
+public:
+
+  // A generic unwind_protect element. Knows how to run itself and
+  // discard itself.  Also, contains a pointer to the next element.
+  class elem
+  {
+  public:
+    elem (void) { }
+
+    virtual void run (void) { }
+
+    virtual ~elem (void) { }
+
+    friend class action_container;
+
+  private:
+
+    // No copying!
+
+    elem (const elem&);
+
+    elem& operator = (const elem&);
+  };
+
+  // An element that merely runs a void (*)(void) function.
+
+  class fcn_elem : public elem
+  {
+  public:
+    fcn_elem (void (*fptr) (void))
+      : e_fptr (fptr) { }
+
+    void run (void) { e_fptr (); }
+
+  private:
+    void (*e_fptr) (void);
+  };
+
+  // An element that stores a variable of type T along with a void (*) (T)
+  // function pointer, and calls the function with the parameter.
+
+  template <class T>
+  class fcn_arg_elem : public elem
+  {
+  public:
+    fcn_arg_elem (void (*fcn) (T), T arg)
+      : e_fcn (fcn), e_arg (arg) { }
+
+    void run (void) { e_fcn (e_arg); }
+
+  private:
+
+    // No copying!
+
+    fcn_arg_elem (const fcn_arg_elem&);
+
+    fcn_arg_elem& operator = (const fcn_arg_elem&);
+
+    void (*e_fcn) (T);
+    T e_arg;
+  };
+
+  // An element that stores a variable of type T along with a
+  // void (*) (const T&) function pointer, and calls the function with
+  // the parameter.
+
+  template <class T>
+  class fcn_crefarg_elem : public elem
+  {
+  public:
+    fcn_crefarg_elem (void (*fcn) (const T&), const T& arg)
+      : e_fcn (fcn), e_arg (arg) { }
+
+    void run (void) { e_fcn (e_arg); }
+
+  private:
+    void (*e_fcn) (const T&);
+    T e_arg;
+  };
+
+  // An element for calling a member function.
+
+  template <class T>
+  class method_elem : public elem
+  {
+  public:
+    method_elem (T *obj, void (T::*method) (void))
+      : e_obj (obj), e_method (method) { }
+
+    void run (void) { (e_obj->*e_method) (); }
+
+  private:
+
+    T *e_obj;
+    void (T::*e_method) (void);
+
+    // No copying!
+
+    method_elem (const method_elem&);
+
+    method_elem operator = (const method_elem&);
+  };
+
+  // An element for calling a member function with a single argument
+
+  template <class T, class A>
+  class method_arg_elem : public elem
+  {
+  public:
+    method_arg_elem (T *obj, void (T::*method) (A), A arg)
+      : e_obj (obj), e_method (method), e_arg (arg) { }
+
+    void run (void) { (e_obj->*e_method) (e_arg); }
+
+  private:
+
+    T *e_obj;
+    void (T::*e_method) (A);
+    A e_arg;
+
+    // No copying!
+
+    method_arg_elem (const method_arg_elem&);
+
+    method_arg_elem operator = (const method_arg_elem&);
+  };
+
+  // An element for calling a member function with a single argument
+
+  template <class T, class A>
+  class method_crefarg_elem : public elem
+  {
+  public:
+    method_crefarg_elem (T *obj, void (T::*method) (const A&), const A& arg)
+      : e_obj (obj), e_method (method), e_arg (arg) { }
+
+    void run (void) { (e_obj->*e_method) (e_arg); }
+
+  private:
+
+    T *e_obj;
+    void (T::*e_method) (const A&);
+    A e_arg;
+
+    // No copying!
+
+    method_crefarg_elem (const method_crefarg_elem&);
+
+    method_crefarg_elem operator = (const method_crefarg_elem&);
+  };
+
+  // An element that stores arbitrary variable, and restores it.
+
+  template <class T>
+  class restore_var_elem : public elem
+  {
+  public:
+    restore_var_elem (T& ref, const T& val)
+      : e_ptr (&ref), e_val (val) { }
+
+    void run (void) { *e_ptr = e_val; }
+
+  private:
+
+    // No copying!
+
+    restore_var_elem (const restore_var_elem&);
+
+    restore_var_elem& operator = (const restore_var_elem&);
+
+    T *e_ptr, e_val;
+  };
+
+  // Deletes a class allocated using new.
+
+  template <class T>
+  class delete_ptr_elem : public elem
+  {
+  public:
+    delete_ptr_elem (T *ptr)
+      : e_ptr (ptr) { }
+
+    void run (void) { delete e_ptr; }
+
+  private:
+
+    T *e_ptr;
+
+    // No copying!
+
+    delete_ptr_elem (const delete_ptr_elem&);
+
+    delete_ptr_elem operator = (const delete_ptr_elem&);
+  };
+
+  action_container (void) { }
+
+  virtual ~action_container (void) { }
+
+  virtual void add (elem *new_elem) = 0;
+
+  // Call to void func (void).
+  void add_fcn (void (*fcn) (void))
+  {
+    add (new fcn_elem (fcn));
+  }
+
+  // Call to void func (T).
+  template <class T>
+  void add_fcn (void (*action) (T), T val)
+  {
+    add (new fcn_arg_elem<T> (action, val));
+  }
+
+  // Call to void func (const T&).
+  template <class T>
+  void add_fcn (void (*action) (const T&), const T& val)
+  {
+    add (new fcn_crefarg_elem<T> (action, val));
+  }
+
+  // Call to T::method (void).
+  template <class T>
+  void add_method (T *obj, void (T::*method) (void))
+  {
+    add (new method_elem<T> (obj, method));
+  }
+
+  // Call to T::method (A).
+  template <class T, class A>
+  void add_method (T *obj, void (T::*method) (A), A arg)
+  {
+    add (new method_arg_elem<T, A> (obj, method, arg));
+  }
+
+  // Call to T::method (const A&).
+  template <class T, class A>
+  void add_method (T *obj, void (T::*method) (const A&), const A& arg)
+  {
+    add (new method_crefarg_elem<T, A> (obj, method, arg));
+  }
+
+  // Call to delete (T*).
+
+  template <class T>
+  void add_delete (T *obj)
+  {
+    add (new delete_ptr_elem<T> (obj));
+  }
+
+  // Protect any variable.
+  template <class T>
+  void protect_var (T& var)
+  {
+    add (new restore_var_elem<T> (var, var));
+  }
+
+  // Protect any variable, value given.
+  template <class T>
+  void protect_var (T& var, const T& val)
+  {
+    add (new restore_var_elem<T> (var, val));
+  }
+
+  operator bool (void) const { return ! empty (); }
+
+  virtual void run_first (void) = 0;
+
+  void run (size_t num)
+  {
+    if (num > size ())
+      num = size ();
+
+    for (size_t i = 0; i < num; i++)
+      run_first ();
+  }
+
+  void run (void) { run (size ()); }
+
+  virtual void discard_first (void) = 0;
+
+  void discard (size_t num)
+  {
+    if (num > size ())
+      num = size ();
+
+    for (size_t i = 0; i < num; i++)
+      discard_first ();
+  }
+
+  void discard (void) { discard (size ()); }
+
+  virtual size_t size (void) const = 0;
+
+  bool empty (void) const { return size () == 0; }
+
+private:
+
+  // No copying!
+
+  action_container (const action_container&);
+
+  action_container& operator = (const action_container&);
+};
+
+#endif
diff --git a/libinterp/interp-core/defun-dld.h b/libinterp/interp-core/defun-dld.h
--- a/libinterp/interp-core/defun-dld.h
+++ b/libinterp/interp-core/defun-dld.h
@@ -39,17 +39,17 @@ along with Octave; see the file COPYING.
 // The first DECLARE_FUN is for the benefit of the installer function
 // and the second is for the definition of the function.
 
 #if defined (MAKE_BUILTINS)
 
 #define DEFUN_DLD(name, args_name, nargout_name, doc) \
   DEFUN_DLD_INTERNAL (name, args_name, nargout_name, doc)
 
-// This one can be used when `name' cannot be used directly (if it is
+// This one can be used when 'name' cannot be used directly (if it is
 // already defined as a macro).  In that case, name is already a
 // quoted string, and the internal name of the function must be passed
 // too (the convention is to use a prefix of "F", so "foo" becomes
 // "Ffoo") as well as the name of the generated installer function
 // (the convention is to use a prefix of "G", so "foo" becomes "Gfoo").
 
 #define DEFUNX_DLD(name, fname, gname, args_name, nargout_name, doc) \
   DEFUNX_DLD_INTERNAL (name, fname, args_name, nargout_name, doc)
diff --git a/libinterp/interp-core/dynamic-ld.cc b/libinterp/interp-core/dynamic-ld.cc
--- a/libinterp/interp-core/dynamic-ld.cc
+++ b/libinterp/interp-core/dynamic-ld.cc
@@ -393,17 +393,17 @@ octave_dynamic_loader::do_load_oct (cons
           if (function)
             {
               octave_dld_fcn_getter f
                 = FCN_PTR_CAST (octave_dld_fcn_getter, function);
 
               retval = f (oct_file, relative);
 
               if (! retval)
-                ::error ("failed to install .oct file function `%s'",
+                ::error ("failed to install .oct file function '%s'",
                          fcn_name.c_str ());
             }
         }
       else
         ::error ("%s is not a valid shared library",
                  file_name.c_str ());
     }
 
@@ -463,17 +463,17 @@ octave_dynamic_loader::do_load_mex (cons
                     have_fmex = true;
                 }
             }
 
           if (function)
             retval = new octave_mex_function (function, have_fmex,
                                               mex_file, fcn_name);
           else
-            ::error ("failed to install .mex file function `%s'",
+            ::error ("failed to install .mex file function '%s'",
                      fcn_name.c_str ());
         }
       else
         ::error ("%s is not a valid shared library",
                  file_name.c_str ());
     }
 
   return retval;
diff --git a/libinterp/interp-core/event-queue.h b/libinterp/interp-core/event-queue.h
new file mode 100644
--- /dev/null
+++ b/libinterp/interp-core/event-queue.h
@@ -0,0 +1,126 @@
+/*
+
+Copyright (C) 2012 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if !defined (octave_event_queue_h)
+#define octave_event_queue_h 1
+
+#include <queue>
+#include <memory>
+
+#include "action-container.h"
+
+class
+OCTINTERP_API
+event_queue : public action_container
+{
+public:
+
+  event_queue (void) : fifo () { }
+
+  // Destructor should not raise an exception, so all actions
+  // registered should be exception-safe (but setting error_state is
+  // allowed). If you're not sure, see event_queue_safe.
+
+  ~event_queue (void) { run (); }
+
+  void add (elem *new_elem)
+  {
+    fifo.push (new_elem);
+  }
+
+  void run_first (void)
+  {
+    if (! empty ())
+      {
+        // No leak on exception!
+        std::auto_ptr<elem> ptr (fifo.front ());
+        fifo.pop ();
+        ptr->run ();
+      }
+  }
+
+  void discard_first (void)
+  {
+    if (! empty ())
+      {
+        elem *ptr = fifo.front ();
+        fifo.pop ();
+        delete ptr;
+      }
+  }
+
+  size_t size (void) const { return fifo.size (); }
+
+protected:
+
+  std::queue<elem *> fifo;
+
+private:
+
+  // No copying!
+
+  event_queue (const event_queue&);
+
+  event_queue& operator = (const event_queue&);
+};
+
+// Like event_queue, but this one will guard against the
+// possibility of seeing an exception (or interrupt) in the cleanup
+// actions. Not that we can do much about it, but at least we won't
+// crash.
+
+class
+event_queue_safe : public event_queue
+{
+private:
+
+  static void gripe_exception (void);
+
+public:
+
+  event_queue_safe (void) : event_queue () { }
+
+  ~event_queue_safe (void)
+    {
+      while (! empty ())
+        {
+          try
+            {
+              run_first ();
+            }
+          catch (...) // Yes, the black hole. Remember we're in a dtor.
+            {
+              gripe_exception ();
+            }
+        }
+    }
+
+private:
+
+  // No copying!
+
+  event_queue_safe (const event_queue_safe&);
+
+  event_queue_safe& operator = (const event_queue_safe&);
+};
+
+#endif
diff --git a/libinterp/interp-core/gl-render.cc b/libinterp/interp-core/gl-render.cc
--- a/libinterp/interp-core/gl-render.cc
+++ b/libinterp/interp-core/gl-render.cc
@@ -577,17 +577,17 @@ opengl_renderer::draw (const graphics_ob
     /* SKIP */;
   else if (go.isa ("uipanel"))
     {
       if (toplevel)
         draw_uipanel (dynamic_cast<const uipanel::properties&> (props), go);
     }
   else
     {
-      warning ("opengl_renderer: cannot render object of type `%s'",
+      warning ("opengl_renderer: cannot render object of type '%s'",
                props.graphics_object_name ().c_str ());
     }
 }
 
 void
 opengl_renderer::draw_figure (const figure::properties& props)
 {
   // Initialize OpenGL context
@@ -2977,17 +2977,17 @@ opengl_renderer::make_marker_list (const
             ang = (0.5 + double(i+1)/6.0) * M_PI;
             r = 1.0 - (dr * fmod (double(i+1), 2.0));
             glVertex2d (sz*r*cos (ang)/2, sz*r*sin (ang)/2);
           }
         glEnd ();
       }
       break;
     default:
-      warning ("opengl_renderer: unsupported marker `%s'",
+      warning ("opengl_renderer: unsupported marker '%s'",
                marker.c_str ());
       break;
     }
 
   glEndList ();
 
   return ID;
 }
diff --git a/libinterp/interp-core/gripes.cc b/libinterp/interp-core/gripes.cc
--- a/libinterp/interp-core/gripes.cc
+++ b/libinterp/interp-core/gripes.cc
@@ -98,17 +98,17 @@ void
 gripe_invalid_conversion (const std::string& from, const std::string& to)
 {
   error ("invalid conversion from %s to %s", from.c_str (), to.c_str ());
 }
 
 void
 gripe_invalid_value_specified (const char *name)
 {
-  warning ("invalid value specified for `%s'", name);
+  warning ("invalid value specified for '%s'", name);
 }
 
 void
 gripe_2_or_3_dim_plot (void)
 {
   error ("plot: can only plot in 2 or 3 dimensions");
 }
 
@@ -129,19 +129,19 @@ gripe_data_conversion (const char *from,
 {
   error ("unable to convert from %s to %s format", from, to);
 }
 
 void
 gripe_wrong_type_arg (const char *name, const char *s, bool is_error)
 {
   if (is_error)
-    error ("%s: wrong type argument `%s'", name, s);
+    error ("%s: wrong type argument '%s'", name, s);
   else
-    warning ("%s: wrong type argument `%s'", name, s);
+    warning ("%s: wrong type argument '%s'", name, s);
 }
 
 void
 gripe_wrong_type_arg (const char *name, const std::string& s, bool is_error)
 {
   gripe_wrong_type_arg (name, s.c_str (), is_error);
 }
 
@@ -160,24 +160,24 @@ gripe_wrong_type_arg (const std::string&
 {
   gripe_wrong_type_arg (name.c_str (), tc, is_error);
 }
 
 void
 gripe_wrong_type_arg_for_unary_op (const octave_value& op)
 {
   std::string type = op.type_name ();
-  error ("invalid operand `%s' for unary operator", type.c_str ());
+  error ("invalid operand '%s' for unary operator", type.c_str ());
 }
 
 void
 gripe_wrong_type_arg_for_binary_op (const octave_value& op)
 {
   std::string type = op.type_name ();
-  error ("invalid operand `%s' for binary operator", type.c_str ());
+  error ("invalid operand '%s' for binary operator", type.c_str ());
 }
 
 void
 gripe_implicit_conversion (const char *id, const char *from, const char *to)
 {
   warning_with_id (id, "implicit conversion from %s to %s", from, to);
 }
 
diff --git a/libinterp/interp-core/jit-ir.cc b/libinterp/interp-core/jit-ir.cc
--- a/libinterp/interp-core/jit-ir.cc
+++ b/libinterp/interp-core/jit-ir.cc
@@ -92,16 +92,18 @@ jit_block_list::print_dom (std::ostream&
 {
   os << "-------------------- dom info --------------------\n";
   for (const_iterator iter = begin (); iter != end (); ++iter)
     {
       assert (*iter);
       (*iter)->print_dom (os);
     }
   os << std::endl;
+
+  return os;
 }
 
 void
 jit_block_list::push_back (jit_block *b)
 {
   mlist.push_back (b);
   iterator iter = mlist.end ();
   b->stash_location (--iter);
diff --git a/libinterp/interp-core/jit-ir.h b/libinterp/interp-core/jit-ir.h
--- a/libinterp/interp-core/jit-ir.h
+++ b/libinterp/interp-core/jit-ir.h
@@ -37,16 +37,17 @@ along with Octave; see the file COPYING.
 
 #define JIT_VISIT_IR_NOTEMPLATE                 \
   JIT_METH(block);                              \
   JIT_METH(branch);                             \
   JIT_METH(cond_branch);                        \
   JIT_METH(call);                               \
   JIT_METH(extract_argument);                   \
   JIT_METH(store_argument);                     \
+  JIT_METH(return);                             \
   JIT_METH(phi);                                \
   JIT_METH(variable);                           \
   JIT_METH(error_check);                        \
   JIT_METH(assign)                              \
   JIT_METH(argument)                            \
   JIT_METH(magic_end)
 
 #define JIT_VISIT_IR_CONST                      \
@@ -275,16 +276,20 @@ private:
 
 std::ostream& operator<< (std::ostream& os, const jit_value& value);
 std::ostream& jit_print (std::ostream& os, jit_value *avalue);
 
 class
 jit_use : public jit_internal_node<jit_value, jit_use>
 {
 public:
+  // some compilers don't allow us to use jit_internal_node without template
+  // paremeters
+  typedef jit_internal_node<jit_value, jit_use> PARENT_T;
+
   jit_use (void) : muser (0), mindex (0) {}
 
   // we should really have a move operator, but not until c++11 :(
   jit_use (const jit_use& use) : muser (0), mindex (0)
   {
     *this = use;
   }
 
@@ -300,17 +305,17 @@ public:
 
   jit_block *user_parent (void) const;
 
   std::list<jit_block *> user_parent_location (void) const;
 
   void stash_value (jit_value *avalue, jit_instruction *auser = 0,
                     size_t aindex = -1)
   {
-    jit_internal_node::stash_value (avalue);
+    PARENT_T::stash_value (avalue);
     mindex = aindex;
     muser = auser;
   }
 private:
   jit_instruction *muser;
   size_t mindex;
 };
 
@@ -759,16 +764,20 @@ public:
       {
         mvisit_count = avisit_count + 1;
         return false;
       }
 
     return true;
   }
 
+  jit_instruction *front (void) { return instructions.front (); }
+
+  jit_instruction *back (void) { return instructions.back (); }
+
   JIT_VALUE_ACCEPT;
 private:
   void internal_append (jit_instruction *instr);
 
   void compute_df (size_t avisit_count);
 
   bool update_idom (size_t avisit_count);
 
@@ -791,17 +800,17 @@ private:
 class
 jit_phi_incomming : public jit_internal_node<jit_block, jit_phi_incomming>
 {
 public:
   jit_phi_incomming (void) : muser (0) {}
 
   jit_phi_incomming (jit_phi *auser) : muser (auser) {}
 
-  jit_phi_incomming (const jit_phi_incomming& use) : jit_internal_node ()
+  jit_phi_incomming (const jit_phi_incomming& use)
   {
     *this = use;
   }
 
   jit_phi_incomming& operator= (const jit_phi_incomming& use)
   {
     stash_value (use.value ());
     muser = use.muser;
@@ -1140,16 +1149,31 @@ public:
 
   JIT_VALUE_ACCEPT;
 };
 
 class
 jit_call : public jit_instruction
 {
 public:
+  jit_call (const jit_operation& (*aoperation) (void))
+    : moperation (aoperation ())
+  {
+    const jit_function& ol = overload ();
+    if (ol.valid ())
+      stash_type (ol.result ());
+  }
+
+  jit_call (const jit_operation& aoperation) : moperation (aoperation)
+  {
+    const jit_function& ol = overload ();
+    if (ol.valid ())
+      stash_type (ol.result ());
+  }
+
 #define JIT_CALL_CONST(N)                                               \
   jit_call (const jit_operation& aoperation,                            \
             OCT_MAKE_DECL_LIST (jit_value *, arg, N))                   \
     : jit_instruction (OCT_MAKE_ARG_LIST (arg, N)), moperation (aoperation) {} \
                                                                         \
   jit_call (const jit_operation& (*aoperation) (void),                  \
             OCT_MAKE_DECL_LIST (jit_value *, arg, N))                   \
     : jit_instruction (OCT_MAKE_ARG_LIST (arg, N)), moperation (aoperation ()) \
@@ -1357,16 +1381,48 @@ public:
   }
 
   JIT_VALUE_ACCEPT;
 private:
   jit_variable *dest;
 };
 
 class
+jit_return : public jit_instruction
+{
+public:
+  jit_return (void) {}
+
+  jit_return (jit_value *retval) : jit_instruction (retval) {}
+
+  jit_value *result (void) const
+  {
+    return argument_count () ? argument (0) : 0;
+  }
+
+  jit_type *result_type (void) const
+  {
+    jit_value *res = result ();
+    return res ? res->type () : 0;
+  }
+
+  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
+  {
+    print_indent (os, indent) << "return";
+
+    if (result ())
+      os << " " << *result ();
+
+    return os;
+  }
+
+  JIT_VALUE_ACCEPT;
+};
+
+class
 jit_ir_walker
 {
 public:
   virtual ~jit_ir_walker () {}
 
 #define JIT_METH(clname) \
   virtual void visit (jit_ ## clname&) = 0;
 
diff --git a/libinterp/interp-core/jit-typeinfo.cc b/libinterp/interp-core/jit-typeinfo.cc
--- a/libinterp/interp-core/jit-typeinfo.cc
+++ b/libinterp/interp-core/jit-typeinfo.cc
@@ -108,58 +108,58 @@ octave_jit_release_matrix (jit_matrix *m
 
 extern "C" octave_base_value *
 octave_jit_grab_any (octave_base_value *obv)
 {
   obv->grab ();
   return obv;
 }
 
-extern "C" void
-octave_jit_grab_matrix (jit_matrix *result, jit_matrix *m)
+extern "C" jit_matrix
+octave_jit_grab_matrix (jit_matrix *m)
 {
-  *result = *m->array;
+  return *m->array;
 }
 
 extern "C" octave_base_value *
 octave_jit_cast_any_matrix (jit_matrix *m)
 {
   octave_value ret (*m->array);
   octave_base_value *rep = ret.internal_rep ();
   rep->grab ();
   delete m->array;
 
   return rep;
 }
 
-extern "C" void
-octave_jit_cast_matrix_any (jit_matrix *ret, octave_base_value *obv)
+extern "C" jit_matrix
+octave_jit_cast_matrix_any (octave_base_value *obv)
 {
   NDArray m = obv->array_value ();
-  *ret = m;
   obv->release ();
+  return m;
 }
 
 extern "C" octave_base_value *
 octave_jit_cast_any_range (jit_range *rng)
 {
   Range temp (*rng);
   octave_value ret (temp);
   octave_base_value *rep = ret.internal_rep ();
   rep->grab ();
 
   return rep;
 }
-extern "C" void
-octave_jit_cast_range_any (jit_range *ret, octave_base_value *obv)
+extern "C" jit_range
+octave_jit_cast_range_any (octave_base_value *obv)
 {
 
   jit_range r (obv->range_value ());
-  *ret = r;
   obv->release ();
+  return r;
 }
 
 extern "C" double
 octave_jit_cast_scalar_any (octave_base_value *obv)
 {
   double ret = obv->double_value ();
   obv->release ();
   return ret;
@@ -223,29 +223,29 @@ octave_jit_gindex_range (int nd, int dim
       gripe_index_out_of_range (nd, dim, iext, ext);
     }
   catch (const octave_execution_exception&)
     {
       gripe_library_execution_error ();
     }
 }
 
-extern "C" void
-octave_jit_paren_subsasgn_impl (jit_matrix *ret, jit_matrix *mat,
-                                octave_idx_type index, double value)
+extern "C" jit_matrix
+octave_jit_paren_subsasgn_impl (jit_matrix *mat, octave_idx_type index,
+                                double value)
 {
   NDArray *array = mat->array;
   if (array->nelem () < index)
     array->resize1 (index);
 
   double *data = array->fortran_vec ();
   data[index - 1] = value;
 
   mat->update ();
-  *ret = *mat;
+  return *mat;
 }
 
 static void
 make_indices (double *indices, octave_idx_type idx_count,
               Array<idx_vector>& result)
 {
   result.resize (dim_vector (1, idx_count));
   for (octave_idx_type i = 0; i < idx_count; ++i)
@@ -267,41 +267,43 @@ octave_jit_paren_scalar (jit_matrix *mat
     }
   catch (const octave_execution_exception&)
     {
       gripe_library_execution_error ();
       return 0;
     }
 }
 
-extern "C" void
-octave_jit_paren_scalar_subsasgn (jit_matrix *ret, jit_matrix *mat,
-                                  double *indices, octave_idx_type idx_count,
-                                  double value)
+extern "C" jit_matrix
+octave_jit_paren_scalar_subsasgn (jit_matrix *mat, double *indices,
+                                  octave_idx_type idx_count, double value)
 {
   // FIXME: Replace this with a more optimal version
+  jit_matrix ret;
   try
     {
       Array<idx_vector> idx;
       make_indices (indices, idx_count, idx);
 
       Matrix temp (1, 1);
       temp.xelem(0) = value;
       mat->array->assign (idx, temp);
-      ret->update (mat->array);
+      ret.update (mat->array);
     }
   catch (const octave_execution_exception&)
     {
       gripe_library_execution_error ();
     }
+
+  return ret;
 }
 
-extern "C" void
-octave_jit_paren_subsasgn_matrix_range (jit_matrix *result, jit_matrix *mat,
-                                        jit_range *index, double value)
+extern "C" jit_matrix
+octave_jit_paren_subsasgn_matrix_range (jit_matrix *mat, jit_range *index,
+                                        double value)
 {
   NDArray *array = mat->array;
   bool done = false;
 
   // optimize for the simple case (no resizing and no errors)
   if (*array->jit_ref_count () == 1
       && index->all_elements_are_ints ())
     {
@@ -335,17 +337,19 @@ octave_jit_paren_subsasgn_matrix_range (
   if (! done)
     {
       idx_vector idx (*index);
       NDArray avalue (dim_vector (1, 1));
       avalue.xelem (0) = value;
       array->assign (idx, avalue);
     }
 
-  result->update (array);
+  jit_matrix ret;
+  ret.update (array);
+  return ret;
 }
 
 extern "C" double
 octave_jit_end_matrix (jit_matrix *mat, octave_idx_type idx,
                        octave_idx_type count)
 {
   octave_idx_type ndim = mat->dimensions[-1];
   if (ndim == count)
@@ -361,16 +365,26 @@ octave_jit_end_matrix (jit_matrix *mat, 
         }
 
       return mat->dimensions[idx];
     }
   else // ndim < count
     return idx < ndim ? mat->dimensions[idx] : 1;
 }
 
+extern "C" octave_base_value *
+octave_jit_create_undef (void)
+{
+  octave_value undef;
+  octave_base_value *ret = undef.internal_rep ();
+  ret->grab ();
+
+  return ret;
+}
+
 extern "C" Complex
 octave_jit_complex_div (Complex lhs, Complex rhs)
 {
   // see src/OPERATORS/op-cs-cs.cc
   if (rhs == 0.0)
     gripe_divide_by_zero ();
 
   return lhs / rhs;
@@ -547,32 +561,46 @@ jit_function::jit_function (llvm::Module
       llvm_args.push_back (argty);
     }
 
   // we mark all functinos as external linkage because this prevents llvm
   // from getting rid of always inline functions
   llvm::FunctionType *ft = llvm::FunctionType::get (rtype, llvm_args, false);
   llvm_function = llvm::Function::Create (ft, llvm::Function::ExternalLinkage,
                                           aname, module);
+
+  if (sret ())
+    llvm_function->addAttribute (1, llvm::Attribute::StructRet);
+
   if (call_conv == jit_convention::internal)
     llvm_function->addFnAttr (llvm::Attribute::AlwaysInline);
 }
 
 jit_function::jit_function (const jit_function& fn, jit_type *aresult,
                             const std::vector<jit_type *>& aargs)
   : module (fn.module), llvm_function (fn.llvm_function), mresult (aresult),
     args (aargs), call_conv (fn.call_conv), mcan_error (fn.mcan_error)
 {
 }
 
 jit_function::jit_function (const jit_function& fn)
   : module (fn.module), llvm_function (fn.llvm_function), mresult (fn.mresult),
     args (fn.args), call_conv (fn.call_conv), mcan_error (fn.mcan_error)
 {}
 
+void
+jit_function::erase (void)
+{
+  if (! llvm_function)
+    return;
+
+  llvm_function->eraseFromParent ();
+  llvm_function = 0;
+}
+
 std::string
 jit_function::name (void) const
 {
   return llvm_function->getName ();
 }
 
 llvm::BasicBlock *
 jit_function::new_block (const std::string& aname,
@@ -605,63 +633,65 @@ jit_function::call (llvm::IRBuilderD& bu
     throw jit_fail_exception ("Call not implemented");
 
   assert (in_args.size () == args.size ());
   llvm::Function *stacksave
     = llvm::Intrinsic::getDeclaration (module, llvm::Intrinsic::stacksave);
   llvm::SmallVector<llvm::Value *, 10> llvm_args;
   llvm_args.reserve (in_args.size () + sret ());
 
-  llvm::Value *sret_mem = 0;
-  llvm::Value *saved_stack = 0;
+  llvm::BasicBlock *insert_block = builder.GetInsertBlock ();
+  llvm::Function *parent = insert_block->getParent ();
+  assert (parent);
+
+  // we insert allocas inside the prelude block to prevent stack overflows
+  llvm::BasicBlock& prelude = parent->getEntryBlock ();
+  llvm::IRBuilder<> pre_builder (&prelude, prelude.begin ());
+
+  llvm::AllocaInst *sret_mem = 0;
   if (sret ())
     {
-      saved_stack = builder.CreateCall (stacksave);
-      sret_mem = builder.CreateAlloca (mresult->packed_type (call_conv));
+      sret_mem = pre_builder.CreateAlloca (mresult->packed_type (call_conv));
       llvm_args.push_back (sret_mem);
     }
 
   for (size_t i = 0; i < in_args.size (); ++i)
     {
       llvm::Value *arg = in_args[i];
       jit_type::convert_fn convert = args[i]->pack (call_conv);
       if (convert)
         arg = convert (builder, arg);
 
       if (args[i]->pointer_arg (call_conv))
         {
-          if (! saved_stack)
-            saved_stack = builder.CreateCall (stacksave);
-
-          arg = builder.CreateAlloca (args[i]->to_llvm ());
-          builder.CreateStore (in_args[i], arg);
+          llvm::Type *ty = args[i]->packed_type (call_conv);
+          llvm::Value *alloca = pre_builder.CreateAlloca (ty);
+          builder.CreateStore (arg, alloca);
+          arg = alloca;
         }
 
       llvm_args.push_back (arg);
     }
 
-  llvm::Value *ret = builder.CreateCall (llvm_function, llvm_args);
-  if (sret_mem)
-    ret = builder.CreateLoad (sret_mem);
+  llvm::CallInst *callinst = builder.CreateCall (llvm_function, llvm_args);
+  llvm::Value *ret = callinst;
+
+  if (sret ())
+    {
+      callinst->addAttribute (1, llvm::Attribute::StructRet);
+      ret = builder.CreateLoad (sret_mem);
+    }
 
   if (mresult)
     {
       jit_type::convert_fn unpack = mresult->unpack (call_conv);
       if (unpack)
         ret = unpack (builder, ret);
     }
 
-  if (saved_stack)
-    {
-      llvm::Function *stackrestore
-        = llvm::Intrinsic::getDeclaration (module,
-                                           llvm::Intrinsic::stackrestore);
-      builder.CreateCall (stackrestore, saved_stack);
-    }
-
   return ret;
 }
 
 llvm::Value *
 jit_function::argument (llvm::IRBuilderD& builder, size_t idx) const
 {
   assert (idx < args.size ());
 
@@ -676,35 +706,40 @@ jit_function::argument (llvm::IRBuilderD
 
   if (args[idx]->pointer_arg (call_conv))
     return builder.CreateLoad (iter);
 
   return iter;
 }
 
 void
-jit_function::do_return (llvm::IRBuilderD& builder, llvm::Value *rval)
+jit_function::do_return (llvm::IRBuilderD& builder, llvm::Value *rval,
+                         bool verify)
 {
   assert (! rval == ! mresult);
 
   if (rval)
     {
       jit_type::convert_fn convert = mresult->pack (call_conv);
       if (convert)
         rval = convert (builder, rval);
 
       if (sret ())
-        builder.CreateStore (rval, llvm_function->arg_begin ());
+        {
+          builder.CreateStore (rval, llvm_function->arg_begin ());
+          builder.CreateRetVoid ();
+        }
       else
         builder.CreateRet (rval);
     }
   else
     builder.CreateRetVoid ();
 
-  llvm::verifyFunction (*llvm_function);
+  if (verify)
+    llvm::verifyFunction (*llvm_function);
 }
 
 void
 jit_function::do_add_mapping (llvm::ExecutionEngine *engine, void *fn)
 {
   assert (valid ());
   engine->addGlobalMapping (llvm_function, fn);
 }
@@ -786,24 +821,25 @@ jit_operation::overload (const std::vect
 
   return ret;
 }
 
 Array<octave_idx_type>
 jit_operation::to_idx (const std::vector<jit_type*>& types) const
 {
   octave_idx_type numel = types.size ();
-  if (numel == 1)
-    numel = 2;
+  numel = std::max (2, numel);
 
   Array<octave_idx_type> idx (dim_vector (1, numel));
   for (octave_idx_type i = 0; i < static_cast<octave_idx_type> (types.size ());
        ++i)
     idx(i) = types[i]->type_id ();
 
+  if (types.size () == 0)
+    idx(0) = idx(1) = 0;
   if (types.size () == 1)
     {
       idx(1) = idx(0);
       idx(0) = 0;
     }
 
   return idx;
 }
@@ -1016,19 +1052,24 @@ jit_typeinfo::jit_typeinfo (llvm::Module
   matrix_contents[3] = index_t->getPointerTo ();
   matrix_contents[4] = string_t;
   matrix_t->setBody (llvm::makeArrayRef (matrix_contents, 5));
 
   llvm::Type *complex_t = llvm::VectorType::get (scalar_t, 2);
 
   // complex_ret is what is passed to C functions in order to get calling
   // convention right
+  llvm::Type *cmplx_inner_cont[] = {scalar_t, scalar_t};
+  llvm::StructType *cmplx_inner = llvm::StructType::create (cmplx_inner_cont);
+
   complex_ret = llvm::StructType::create (context, "complex_ret");
-  llvm::Type *complex_ret_contents[] = {scalar_t, scalar_t};
-  complex_ret->setBody (complex_ret_contents);
+  {
+    llvm::Type *contents[] = {cmplx_inner};
+    complex_ret->setBody (contents);
+  }
 
   // create types
   any = new_type ("any", 0, any_t);
   matrix = new_type ("matrix", any, matrix_t);
   complex = new_type ("complex", any, complex_t);
   scalar = new_type ("scalar", complex, scalar_t);
   scalar_ptr = new_type ("scalar_ptr", 0, scalar_t->getPointerTo ());
   any_ptr = new_type ("any_ptr", 0, any_t->getPointerTo ());
@@ -1043,28 +1084,28 @@ jit_typeinfo::jit_typeinfo (llvm::Module
   create_int (64);
 
   casts.resize (next_id + 1);
   identities.resize (next_id + 1);
 
   // specify calling conventions
   // FIXME: We should detect architecture and do something sane based on that
   // here we assume x86 or x86_64
-  matrix->mark_sret ();
-  matrix->mark_pointer_arg ();
+  matrix->mark_sret (jit_convention::external);
+  matrix->mark_pointer_arg (jit_convention::external);
 
-  range->mark_sret ();
-  range->mark_pointer_arg ();
+  range->mark_sret (jit_convention::external);
+  range->mark_pointer_arg (jit_convention::external);
 
   complex->set_pack (jit_convention::external, &jit_typeinfo::pack_complex);
   complex->set_unpack (jit_convention::external, &jit_typeinfo::unpack_complex);
   complex->set_packed_type (jit_convention::external, complex_ret);
 
   if (sizeof (void *) == 4)
-    complex->mark_sret ();
+    complex->mark_sret (jit_convention::external);
 
   paren_subsref_fn.initialize (module, engine);
   paren_subsasgn_fn.initialize (module, engine);
 
   // bind global variables
   lerror_state = new llvm::GlobalVariable (*module, bool_t, false,
                                            llvm::GlobalValue::ExternalLinkage,
                                            0, "error_state");
@@ -1118,45 +1159,49 @@ jit_typeinfo::jit_typeinfo (llvm::Module
       llvm::Value *op_as_llvm = llvm::ConstantInt::get (llvm_bo_type, op_int);
       llvm::Value *ret = any_binary.call (builder, op_as_llvm,
                                           fn.argument (builder, 0),
                                           fn.argument (builder, 1));
       fn.do_return (builder, ret);
       binary_ops[op].add_overload (fn);
     }
 
-  // grab any
-  fn = create_function (jit_convention::external, "octave_jit_grab_any", any,
-                        any);
-  fn.add_mapping (engine, &octave_jit_grab_any);
-  grab_fn.add_overload (fn);
-  grab_fn.stash_name ("grab");
-
   // grab matrix
   fn = create_function (jit_convention::external, "octave_jit_grab_matrix",
                         matrix, matrix);
   fn.add_mapping (engine, &octave_jit_grab_matrix);
   grab_fn.add_overload (fn);
 
+  grab_fn.add_overload (create_identity (scalar));
+  grab_fn.add_overload (create_identity (scalar_ptr));
+  grab_fn.add_overload (create_identity (any_ptr));
+  grab_fn.add_overload (create_identity (boolean));
+  grab_fn.add_overload (create_identity (complex));
+  grab_fn.add_overload (create_identity (index));
+
   // release any
   fn = create_function (jit_convention::external, "octave_jit_release_any", 0,
                         any);
   fn.add_mapping (engine, &octave_jit_release_any);
   release_fn.add_overload (fn);
   release_fn.stash_name ("release");
 
   // release matrix
   fn = create_function (jit_convention::external, "octave_jit_release_matrix",
                         0, matrix);
   fn.add_mapping (engine, &octave_jit_release_matrix);
   release_fn.add_overload (fn);
 
-  // copy
-  copy_fn.stash_name ("copy");
-  copy_fn.add_overload (create_identity (scalar));
+  // destroy
+  destroy_fn = release_fn;
+  destroy_fn.stash_name ("destroy");
+  destroy_fn.add_overload (create_identity(scalar));
+  destroy_fn.add_overload (create_identity(boolean));
+  destroy_fn.add_overload (create_identity(index));
+  destroy_fn.add_overload (create_identity(complex));
 
   // now for binary scalar operations
   add_binary_op (scalar, octave_value::op_add, llvm::Instruction::FAdd);
   add_binary_op (scalar, octave_value::op_sub, llvm::Instruction::FSub);
   add_binary_op (scalar, octave_value::op_mul, llvm::Instruction::FMul);
   add_binary_op (scalar, octave_value::op_el_mul, llvm::Instruction::FMul);
 
   add_binary_fcmp (scalar, octave_value::op_lt, llvm::CmpInst::FCMP_ULT);
@@ -1313,19 +1358,19 @@ jit_typeinfo::jit_typeinfo (llvm::Module
   jit_function complex_div = create_function (jit_convention::external,
                                               "octave_jit_complex_div",
                                               complex, complex, complex);
   complex_div.add_mapping (engine, &octave_jit_complex_div);
   complex_div.mark_can_error ();
   binary_ops[octave_value::op_div].add_overload (fn);
   binary_ops[octave_value::op_ldiv].add_overload (fn);
 
-  fn = mirror_binary (complex_div);
-  binary_ops[octave_value::op_ldiv].add_overload (fn);
-  binary_ops[octave_value::op_el_ldiv].add_overload (fn);
+  // fn = mirror_binary (complex_div);
+  // binary_ops[octave_value::op_ldiv].add_overload (fn);
+  // binary_ops[octave_value::op_el_ldiv].add_overload (fn);
 
   fn = create_function (jit_convention::external,
                         "octave_jit_pow_complex_complex", complex, complex,
                         complex);
   fn.add_mapping (engine, &octave_jit_pow_complex_complex);
   binary_ops[octave_value::op_pow].add_overload (fn);
   binary_ops[octave_value::op_el_pow].add_overload (fn);
 
@@ -1701,16 +1746,22 @@ jit_typeinfo::jit_typeinfo (llvm::Module
   }
   end1_fn.add_overload (fn);
 
   end_fn.stash_name ("end");
   fn = create_function (jit_convention::external, "octave_jit_end_matrix",
                         scalar, matrix, index, index);
   end_fn.add_overload (fn);
 
+  // -------------------- create_undef --------------------
+  create_undef_fn.stash_name ("create_undef");
+  fn = create_function (jit_convention::external, "octave_jit_create_undef",
+                        any);
+  create_undef_fn.add_overload (fn);
+
   casts[any->type_id ()].stash_name ("(any)");
   casts[scalar->type_id ()].stash_name ("(scalar)");
   casts[complex->type_id ()].stash_name ("(complex)");
   casts[matrix->type_id ()].stash_name ("(matrix)");
   casts[any->type_id ()].stash_name ("(range)");
 
   // cast any <- matrix
   fn = create_function (jit_convention::external, "octave_jit_cast_any_matrix",
@@ -1831,26 +1882,30 @@ jit_typeinfo::jit_typeinfo (llvm::Module
   register_generic ("eye", matrix, scalar);
   register_generic ("eye", matrix, std::vector<jit_type *> (2, scalar));
 
   add_builtin ("mod");
   register_generic ("mod", scalar, std::vector<jit_type *> (2, scalar));
 
   casts.resize (next_id + 1);
   jit_function any_id = create_identity (any);
+  jit_function grab_any = create_function (jit_convention::external,
+                                           "octave_jit_grab_any", any, any);
+  grab_any.add_mapping (engine, &octave_jit_grab_any);
   jit_function release_any = get_release (any);
   std::vector<jit_type *> args;
   args.resize (1);
 
   for (std::map<std::string, jit_type *>::iterator iter = builtins.begin ();
        iter != builtins.end (); ++iter)
     {
       jit_type *btype = iter->second;
       args[0] = btype;
 
+      grab_fn.add_overload (jit_function (grab_any, btype, args));
       release_fn.add_overload (jit_function (release_any, 0, args));
       casts[any->type_id ()].add_overload (jit_function (any_id, any, args));
 
       args[0] = any;
       casts[btype->type_id ()].add_overload (jit_function (any_id, btype,
                                                            args));
     }
 }
@@ -1960,18 +2015,21 @@ jit_function
 jit_typeinfo::create_identity (jit_type *type)
 {
   size_t id = type->type_id ();
   if (id >= identities.size ())
     identities.resize (id + 1);
 
   if (! identities[id].valid ())
     {
-      jit_function fn = create_function (jit_convention::internal, "id", type,
-                                         type);
+      std::stringstream name;
+      name << "id_" << type->name ();
+      jit_function fn = create_function (jit_convention::internal, name.str (),
+                                         type, type);
+
       llvm::BasicBlock *body = fn.new_block ();
       builder.SetInsertPoint (body);
       fn.do_return (builder, fn.argument (builder, 0));
       return identities[id] = fn;
     }
 
   return identities[id];
 }
@@ -2111,27 +2169,34 @@ jit_typeinfo::mirror_binary (const jit_f
 
 llvm::Value *
 jit_typeinfo::pack_complex (llvm::IRBuilderD& bld, llvm::Value *cplx)
 {
   llvm::Type *complex_ret = instance->complex_ret;
   llvm::Value *real = bld.CreateExtractElement (cplx, bld.getInt32 (0));
   llvm::Value *imag = bld.CreateExtractElement (cplx, bld.getInt32 (1));
   llvm::Value *ret = llvm::UndefValue::get (complex_ret);
-  ret = bld.CreateInsertValue (ret, real, 0);
-  return bld.CreateInsertValue (ret, imag, 1);
+
+  unsigned int re_idx[] = {0, 0};
+  unsigned int im_idx[] = {0, 1};
+  ret = bld.CreateInsertValue (ret, real, re_idx);
+  return bld.CreateInsertValue (ret, imag, im_idx);
 }
 
 llvm::Value *
 jit_typeinfo::unpack_complex (llvm::IRBuilderD& bld, llvm::Value *result)
 {
+  unsigned int re_idx[] = {0, 0};
+  unsigned int im_idx[] = {0, 1};
+
   llvm::Type *complex_t = get_complex ()->to_llvm ();
-  llvm::Value *real = bld.CreateExtractValue (result, 0);
-  llvm::Value *imag = bld.CreateExtractValue (result, 1);
+  llvm::Value *real = bld.CreateExtractValue (result, re_idx);
+  llvm::Value *imag = bld.CreateExtractValue (result, im_idx);
   llvm::Value *ret = llvm::UndefValue::get (complex_t);
+
   ret = bld.CreateInsertElement (ret, real, bld.getInt32 (0));
   return bld.CreateInsertElement (ret, imag, bld.getInt32 (1));
 }
 
 llvm::Value *
 jit_typeinfo::complex_real (llvm::Value *cx)
 {
   return builder.CreateExtractElement (cx, builder.getInt32 (0));
@@ -2193,17 +2258,17 @@ jit_typeinfo::do_type_of (const octave_v
         = dynamic_cast<octave_builtin *> (ov.internal_rep ());
       return builtin && builtin->to_jit () ? builtin->to_jit ()
         : unknown_function;
     }
 
   if (ov.is_range ())
     return get_range ();
 
-  if (ov.is_double_type ())
+  if (ov.is_double_type () && ! ov.is_complex_type ())
     {
       if (ov.is_real_scalar ())
         return get_scalar ();
 
       if (ov.is_matrix_type ())
         return get_matrix ();
     }
 
diff --git a/libinterp/interp-core/jit-typeinfo.h b/libinterp/interp-core/jit-typeinfo.h
--- a/libinterp/interp-core/jit-typeinfo.h
+++ b/libinterp/interp-core/jit-typeinfo.h
@@ -61,16 +61,18 @@ jit_range
 
 std::ostream& operator<< (std::ostream& os, const jit_range& rng);
 
 // jit_array is compatable with the llvm array/matrix structures
 template <typename T, typename U>
 struct
 jit_array
 {
+  jit_array () : array (0) {}
+
   jit_array (T& from) : array (new T (from))
   {
     update ();
   }
 
   void update (void)
   {
     ref_count = array->jit_ref_count ();
@@ -156,25 +158,25 @@ public:
   // -------------------- Calling Convention information --------------------
 
   // A function declared like: mytype foo (int arg0, int arg1);
   // Will be converted to: void foo (mytype *retval, int arg0, int arg1)
   // if mytype is sret. The caller is responsible for allocating space for
   // retval. (on the stack)
   bool sret (jit_convention::type cc) const { return msret[cc]; }
 
-  void mark_sret (jit_convention::type cc = jit_convention::external)
+  void mark_sret (jit_convention::type cc)
   { msret[cc] = true; }
 
   // A function like: void foo (mytype arg0)
   // Will be converted to: void foo (mytype *arg0)
   // Basically just pass by reference.
   bool pointer_arg (jit_convention::type cc) const { return mpointer_arg[cc]; }
 
-  void mark_pointer_arg (jit_convention::type cc = jit_convention::external)
+  void mark_pointer_arg (jit_convention::type cc)
   { mpointer_arg[cc] = true; }
 
   // Convert into an equivalent form before calling. For example, complex is
   // represented as two values llvm vector, but we need to pass it as a two
   // valued llvm structure to C functions.
   convert_fn pack (jit_convention::type cc) { return mpack[cc]; }
 
   void set_pack (jit_convention::type cc, convert_fn fn) { mpack[cc] = fn; }
@@ -229,16 +231,19 @@ public:
 
   // Use an existing function, but change the argument types. The new argument
   // types must behave the same for the current calling convention.
   jit_function (const jit_function& fn, jit_type *aresult,
                 const std::vector<jit_type *>& aargs);
 
   jit_function (const jit_function& fn);
 
+  // erase the interal LLVM function (if it exists). Will become invalid.
+  void erase (void);
+
   template <typename T>
   void add_mapping (llvm::ExecutionEngine *engine, T fn)
   {
     do_add_mapping (engine, reinterpret_cast<void *> (fn));
   }
 
   bool valid (void) const { return llvm_function; }
 
@@ -273,17 +278,18 @@ public:
   JIT_CALL (3);
 
 #undef JIT_CALL
 #undef JIT_PARAMS
 #undef JIT_PARAM_ARGS
 
   llvm::Value *argument (llvm::IRBuilderD& builder, size_t idx) const;
 
-  void do_return (llvm::IRBuilderD& builder, llvm::Value *rval = 0);
+  void do_return (llvm::IRBuilderD& builder, llvm::Value *rval = 0,
+                  bool verify = true);
 
   llvm::Function *to_llvm (void) const { return llvm_function; }
 
   // If true, then the return value is passed as a pointer in the first argument
   bool sret (void) const { return mresult && mresult->sret (call_conv); }
 
   bool can_error (void) const { return mcan_error; }
 
@@ -447,16 +453,18 @@ public:
 
   static jit_type *get_scalar (void) { return instance->scalar; }
 
   static llvm::Type *get_scalar_llvm (void)
   { return instance->scalar->to_llvm (); }
 
   static jit_type *get_scalar_ptr (void) { return instance->scalar_ptr; }
 
+  static jit_type *get_any_ptr (void) { return instance->any_ptr; }
+
   static jit_type *get_range (void) { return instance->range; }
 
   static jit_type *get_string (void) { return instance->string; }
 
   static jit_type *get_bool (void) { return instance->boolean; }
 
   static jit_type *get_index (void) { return instance->index; }
 
@@ -493,19 +501,19 @@ public:
     return instance->release_fn;
   }
 
   static const jit_function& get_release (jit_type *type)
   {
     return instance->release_fn.overload (type);
   }
 
-  static const jit_operation& copy (void)
+  static const jit_operation& destroy (void)
   {
-    return instance->copy_fn;
+    return instance->destroy_fn;
   }
 
   static const jit_operation& print_value (void)
   {
     return instance->print_fn;
   }
 
   static const jit_operation& for_init (void)
@@ -563,16 +571,21 @@ public:
     return instance->end_fn;
   }
 
   static const jit_function& end (jit_value *value, jit_value *index,
                                   jit_value *count)
   {
     return instance->do_end (value, index, count);
   }
+
+  static const jit_operation& create_undef (void)
+  {
+    return instance->create_undef_fn;
+  }
 private:
   jit_typeinfo (llvm::Module *m, llvm::ExecutionEngine *e);
 
   // FIXME: Do these methods really need to be in jit_typeinfo?
   jit_type *do_join (jit_type *lhs, jit_type *rhs)
   {
     // empty case
     if (! lhs)
@@ -751,27 +764,28 @@ private:
   std::map<std::string, jit_type *> builtins;
 
   llvm::StructType *complex_ret;
 
   std::vector<jit_operation> binary_ops;
   std::vector<jit_operation> unary_ops;
   jit_operation grab_fn;
   jit_operation release_fn;
-  jit_operation copy_fn;
+  jit_operation destroy_fn;
   jit_operation print_fn;
   jit_operation for_init_fn;
   jit_operation for_check_fn;
   jit_operation for_index_fn;
   jit_operation logically_true_fn;
   jit_operation make_range_fn;
   jit_paren_subsref paren_subsref_fn;
   jit_paren_subsasgn paren_subsasgn_fn;
   jit_operation end1_fn;
   jit_operation end_fn;
+  jit_operation create_undef_fn;
 
   jit_function any_call;
 
   // type id -> cast function TO that type
   std::vector<jit_operation> casts;
 
   // type id -> identity function
   std::vector<jit_function> identities;
diff --git a/libinterp/interp-core/ls-hdf5.cc b/libinterp/interp-core/ls-hdf5.cc
--- a/libinterp/interp-core/ls-hdf5.cc
+++ b/libinterp/interp-core/ls-hdf5.cc
@@ -433,26 +433,26 @@ hdf5_read_next_data (hid_t group_id, con
             case H5T_NATIVE_ULLONG:
               int_typ = "uint64 ";
               break;
             }
 #else
           hid_t int_sign = H5Tget_sign (type_id);
 
           if (int_sign == H5T_SGN_ERROR)
-            warning ("load: can't read `%s' (unknown datatype)", name);
+            warning ("load: can't read '%s' (unknown datatype)", name);
           else
             {
               if (int_sign == H5T_SGN_NONE)
                 int_typ.append ("u");
               int_typ.append ("int");
 
               int slen = H5Tget_size (type_id);
               if (slen < 0)
-                warning ("load: can't read `%s' (unknown datatype)", name);
+                warning ("load: can't read '%s' (unknown datatype)", name);
               else
                 {
                   switch (slen)
                     {
                     case 1:
                       int_typ.append ("8 ");
                       break;
 
@@ -464,26 +464,26 @@ hdf5_read_next_data (hid_t group_id, con
                       int_typ.append ("32 ");
                       break;
 
                     case 8:
                       int_typ.append ("64 ");
                       break;
 
                     default:
-                      warning ("load: can't read `%s' (unknown datatype)",
+                      warning ("load: can't read '%s' (unknown datatype)",
                                name);
                       int_typ = "";
                       break;
                     }
                 }
             }
 #endif
           if (int_typ == "")
-            warning ("load: can't read `%s' (unknown datatype)", name);
+            warning ("load: can't read '%s' (unknown datatype)", name);
           else
             {
               // Matrix or scalar?
               space_id = H5Dget_space (data_id);
 
               hsize_t rank = H5Sget_simple_extent_ndims (space_id);
 
               if (rank == 0)
@@ -518,34 +518,34 @@ hdf5_read_next_data (hid_t group_id, con
             // Assume that if its not complex its a range. If its not
             // it'll be rejected later in the range code
             d->tc = octave_value_typeinfo::lookup_type ("range");
 
           H5Tclose (complex_type);
         }
       else
         {
-          warning ("load: can't read `%s' (unknown datatype)", name);
+          warning ("load: can't read '%s' (unknown datatype)", name);
           retval = 0; // unknown datatype; skip
         }
 
       // check for OCTAVE_GLOBAL attribute:
       d->global = hdf5_check_attr (data_id, "OCTAVE_GLOBAL");
 
       H5Tclose (type_id);
       H5Dclose (data_id);
 
       retval = (d->tc.load_hdf5 (group_id, name) ? 1 : -1);
     }
 
   if (!ident_valid)
     {
       // should we attempt to handle invalid identifiers by converting
       // bad characters to '_', say?
-      warning ("load: skipping invalid identifier `%s' in hdf5 file",
+      warning ("load: skipping invalid identifier '%s' in hdf5 file",
                name);
     }
 
  done:
   if (retval < 0)
     error ("load: error while reading hdf5 item %s", name);
 
   if (retval > 0)
@@ -894,17 +894,17 @@ add_hdf5_data (hid_t loc_id, const octav
 
   if (space_id >= 0)
     H5Sclose (space_id);
 
   if (data_id >= 0)
     H5Gclose (data_id);
 
   if (! retval)
-    error ("save: error while writing `%s' to hdf5 file", name.c_str ());
+    error ("save: error while writing '%s' to hdf5 file", name.c_str ());
 
   return retval;
 }
 
 // Write data from TC in HDF5 (binary) format to the stream OS,
 // which must be an hdf5_ofstream, returning true on success.
 
 bool
diff --git a/libinterp/interp-core/ls-mat-ascii.cc b/libinterp/interp-core/ls-mat-ascii.cc
--- a/libinterp/interp-core/ls-mat-ascii.cc
+++ b/libinterp/interp-core/ls-mat-ascii.cc
@@ -173,17 +173,17 @@ get_lines_and_columns (std::istream& is,
             nr++;
           else
             error ("load: %s: inconsistent number of columns near line %d",
                    filename.c_str (), file_line_number);
         }
     }
 
   if (nr == 0 || nc == 0)
-    error ("load: file `%s' seems to be empty!", filename.c_str ());
+    error ("load: file '%s' seems to be empty!", filename.c_str ());
 
   is.clear ();
   is.seekg (pos);
 }
 
 // Extract a matrix from a file of numbers only.
 //
 // Comments are not allowed.  The file should only have numeric values.
@@ -279,17 +279,17 @@ read_mat_ascii_data (std::istream& is, c
                                 }
                             }
 
                           if (tmp_stream.eof ())
                             break;
                         }
                       else
                         {
-                          error ("load: failed to read matrix from file `%s'",
+                          error ("load: failed to read matrix from file '%s'",
                                  filename.c_str ());
 
                           return retval;
                         }
 
                     }
                 }
             }
@@ -308,25 +308,25 @@ read_mat_ascii_data (std::istream& is, c
                   tc = tmp;
                   retval = varname;
                 }
               else
                 error ("load: expected %d elements, found %d",
                        expected, total_count);
             }
           else
-            error ("load: failed to read matrix from file `%s'",
+            error ("load: failed to read matrix from file '%s'",
                    filename.c_str ());
         }
       else
-        error ("load: unable to extract matrix size from file `%s'",
+        error ("load: unable to extract matrix size from file '%s'",
                filename.c_str ());
     }
   else
-    error ("load: unable to convert filename `%s' to valid identifier",
+    error ("load: unable to convert filename '%s' to valid identifier",
            filename.c_str ());
 
   return retval;
 }
 
 bool
 save_mat_ascii_data (std::ostream& os, const octave_value& val,
                      int precision, bool tabs)
diff --git a/libinterp/interp-core/ls-mat4.cc b/libinterp/interp-core/ls-mat4.cc
--- a/libinterp/interp-core/ls-mat4.cc
+++ b/libinterp/interp-core/ls-mat4.cc
@@ -390,30 +390,30 @@ read_mat_binary_data (std::istream& is, 
     else
       {
         re.resize (nr, nc);
 
         read_mat_binary_data (is, re.fortran_vec (), prec, dlen, swap, flt_fmt);
 
         if (! is || error_state)
           {
-            error ("load: reading matrix data for `%s'", name);
+            error ("load: reading matrix data for '%s'", name);
             goto data_read_error;
           }
 
         if (imag)
           {
             Matrix im (nr, nc);
 
             read_mat_binary_data (is, im.fortran_vec (), prec, dlen, swap,
                                   flt_fmt);
 
             if (! is || error_state)
               {
-                error ("load: reading imaginary matrix data for `%s'", name);
+                error ("load: reading imaginary matrix data for '%s'", name);
                 goto data_read_error;
               }
 
             ComplexMatrix ctmp (nr, nc);
 
             for (octave_idx_type j = 0; j < nc; j++)
               for (octave_idx_type i = 0; i < nr; i++)
                 ctmp (i, j) = Complex (re (i, j), im (i, j));
@@ -426,17 +426,17 @@ read_mat_binary_data (std::istream& is, 
         if (type == 1)
           tc = tc.convert_to_str (false, true, '\'');
       }
 
       return retval;
     }
 
  data_read_error:
-  error ("load: trouble reading binary file `%s'", filename.c_str ());
+  error ("load: trouble reading binary file '%s'", filename.c_str ());
   return retval;
 }
 
 // Save the data from TC along with the corresponding NAME on stream OS
 // in the MatLab version 4 binary format.
 
 bool
 save_mat_binary_data (std::ostream& os, const octave_value& tc,
diff --git a/libinterp/interp-core/ls-mat5.cc b/libinterp/interp-core/ls-mat5.cc
--- a/libinterp/interp-core/ls-mat5.cc
+++ b/libinterp/interp-core/ls-mat5.cc
@@ -369,52 +369,52 @@ read_mat5_integer_data (std::istream& is
 #define OCTAVE_MAT5_INTEGER_READ(TYP) \
   { \
         TYP re (dims); \
   \
         std::streampos tmp_pos; \
   \
         if (read_mat5_tag (is, swap, type, len)) \
           { \
-            error ("load: reading matrix data for `%s'", retval.c_str ()); \
+            error ("load: reading matrix data for '%s'", retval.c_str ()); \
             goto data_read_error; \
           } \
   \
         octave_idx_type n = re.numel (); \
         tmp_pos = is.tellg (); \
         read_mat5_integer_data (is, re.fortran_vec (), n, swap, \
                                 static_cast<enum mat5_data_type> (type)); \
   \
         if (! is || error_state) \
           { \
-            error ("load: reading matrix data for `%s'", retval.c_str ()); \
+            error ("load: reading matrix data for '%s'", retval.c_str ()); \
             goto data_read_error; \
           } \
   \
         is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len))); \
   \
         if (imag) \
           { \
             /* We don't handle imag integer types, convert to an array */ \
             NDArray im (dims); \
   \
             if (read_mat5_tag (is, swap, type, len)) \
               { \
-                error ("load: reading matrix data for `%s'", \
+                error ("load: reading matrix data for '%s'", \
                        retval.c_str ()); \
                 goto data_read_error; \
               } \
   \
             n = im.numel (); \
             read_mat5_binary_data (is, im.fortran_vec (), n, swap, \
                                    static_cast<enum mat5_data_type> (type), flt_fmt); \
   \
             if (! is || error_state) \
               { \
-                error ("load: reading imaginary matrix data for `%s'", \
+                error ("load: reading imaginary matrix data for '%s'", \
                        retval.c_str ()); \
                 goto data_read_error; \
               } \
   \
             ComplexNDArray ctmp (dims); \
   \
             for (octave_idx_type i = 0; i < n; i++) \
               ctmp(i) = Complex (re(i).double_value (), im(i)); \
@@ -709,17 +709,17 @@ read_mat5_binary_element (std::istream& 
           {
             octave_value tc2;
 
             std::string nm
               = read_mat5_binary_element (is, filename, swap, global, tc2);
 
             if (! is || error_state)
               {
-                error ("load: reading cell data for `%s'", nm.c_str ());
+                error ("load: reading cell data for '%s'", nm.c_str ());
                 goto data_read_error;
               }
 
             cell_array(i) = tc2;
           }
 
         tc = cell_array;
       }
@@ -751,57 +751,57 @@ read_mat5_binary_element (std::istream& 
             data = sm.data ();
           }
 
         // row indices
         std::streampos tmp_pos;
 
         if (read_mat5_tag (is, swap, type, len))
           {
-            error ("load: reading sparse row data for `%s'", retval.c_str ());
+            error ("load: reading sparse row data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         tmp_pos = is.tellg ();
 
         read_mat5_integer_data (is, ridx, nzmax, swap,
                                 static_cast<enum mat5_data_type> (type));
 
         if (! is || error_state)
           {
-            error ("load: reading sparse row data for `%s'", retval.c_str ());
+            error ("load: reading sparse row data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
 
         // col indices
         if (read_mat5_tag (is, swap, type, len))
           {
-            error ("load: reading sparse column data for `%s'", retval.c_str ());
+            error ("load: reading sparse column data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         tmp_pos = is.tellg ();
 
         read_mat5_integer_data (is, cidx, nc + 1, swap,
                                 static_cast<enum mat5_data_type> (type));
 
         if (! is || error_state)
           {
-            error ("load: reading sparse column data for `%s'", retval.c_str ());
+            error ("load: reading sparse column data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
 
         // real data subelement
         if (read_mat5_tag (is, swap, type, len))
           {
-            error ("load: reading sparse matrix data for `%s'", retval.c_str ());
+            error ("load: reading sparse matrix data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         octave_idx_type nnz = cidx[nc];
         NDArray re;
         if (imag)
           {
             re = NDArray (dim_vector (nnz, 1));
@@ -809,39 +809,39 @@ read_mat5_binary_element (std::istream& 
           }
 
         tmp_pos = is.tellg ();
         read_mat5_binary_data (is, data, nnz, swap,
                                static_cast<enum mat5_data_type> (type), flt_fmt);
 
         if (! is || error_state)
           {
-            error ("load: reading sparse matrix data for `%s'", retval.c_str ());
+            error ("load: reading sparse matrix data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
 
         // imaginary data subelement
         if (imag)
           {
             NDArray im (dim_vector (static_cast<int> (nnz), 1));
 
             if (read_mat5_tag (is, swap, type, len))
               {
-                error ("load: reading sparse matrix data for `%s'", retval.c_str ());
+                error ("load: reading sparse matrix data for '%s'", retval.c_str ());
                 goto data_read_error;
               }
 
             read_mat5_binary_data (is, im.fortran_vec (), nnz, swap,
                                    static_cast<enum mat5_data_type> (type), flt_fmt);
 
             if (! is || error_state)
               {
-                error ("load: reading imaginary sparse matrix data for `%s'",
+                error ("load: reading imaginary sparse matrix data for '%s'",
                        retval.c_str ());
                 goto data_read_error;
               }
 
             for (octave_idx_type i = 0; i < nnz; i++)
               scm.xdata (i) = Complex (re (i), im (i));
 
             tc = scm;
@@ -1139,17 +1139,17 @@ read_mat5_binary_element (std::istream& 
 
           name[len] = '\0';
           classname = name;
         }
       }
       // Fall-through
     case MAT_FILE_STRUCT_CLASS:
       {
-        Octave_map m (dim_vector (1, 1));
+        Octave_map m (dims);
         int32_t fn_type;
         int32_t fn_len;
         int32_t field_name_length;
 
         // field name length subelement -- actually the maximum length
         // of a field name.  The Matlab docs promise this will always
         // be 32.  We read and use the actual value, on the theory
         // that eventually someone will recognize that's a waste of
@@ -1314,52 +1314,52 @@ read_mat5_binary_element (std::istream& 
         FloatNDArray re (dims);
 
         // real data subelement
 
         std::streampos tmp_pos;
 
         if (read_mat5_tag (is, swap, type, len))
           {
-            error ("load: reading matrix data for `%s'", retval.c_str ());
+            error ("load: reading matrix data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         octave_idx_type n = re.numel ();
         tmp_pos = is.tellg ();
         read_mat5_binary_data (is, re.fortran_vec (), n, swap,
                                static_cast<enum mat5_data_type> (type), flt_fmt);
 
         if (! is || error_state)
           {
-            error ("load: reading matrix data for `%s'", retval.c_str ());
+            error ("load: reading matrix data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
 
         if (imag)
           {
             // imaginary data subelement
 
             FloatNDArray im (dims);
 
             if (read_mat5_tag (is, swap, type, len))
               {
-                error ("load: reading matrix data for `%s'", retval.c_str ());
+                error ("load: reading matrix data for '%s'", retval.c_str ());
                 goto data_read_error;
               }
 
             n = im.numel ();
             read_mat5_binary_data (is, im.fortran_vec (), n, swap,
                                    static_cast<enum mat5_data_type> (type), flt_fmt);
 
             if (! is || error_state)
               {
-                error ("load: reading imaginary matrix data for `%s'",
+                error ("load: reading imaginary matrix data for '%s'",
                        retval.c_str ());
                 goto data_read_error;
               }
 
             FloatComplexNDArray ctmp (dims);
 
             for (octave_idx_type i = 0; i < n; i++)
               ctmp(i) = FloatComplex (re(i), im(i));
@@ -1380,28 +1380,28 @@ read_mat5_binary_element (std::istream& 
         NDArray re (dims);
 
         // real data subelement
 
         std::streampos tmp_pos;
 
         if (read_mat5_tag (is, swap, type, len))
           {
-            error ("load: reading matrix data for `%s'", retval.c_str ());
+            error ("load: reading matrix data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         octave_idx_type n = re.numel ();
         tmp_pos = is.tellg ();
         read_mat5_binary_data (is, re.fortran_vec (), n, swap,
                                static_cast<enum mat5_data_type> (type), flt_fmt);
 
         if (! is || error_state)
           {
-            error ("load: reading matrix data for `%s'", retval.c_str ());
+            error ("load: reading matrix data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
 
         if (logicalvar)
           {
             // Logical variables can either be MAT_FILE_UINT8_CLASS or
@@ -1418,27 +1418,27 @@ read_mat5_binary_element (std::istream& 
         else if (imag)
           {
             // imaginary data subelement
 
             NDArray im (dims);
 
             if (read_mat5_tag (is, swap, type, len))
               {
-                error ("load: reading matrix data for `%s'", retval.c_str ());
+                error ("load: reading matrix data for '%s'", retval.c_str ());
                 goto data_read_error;
               }
 
             n = im.numel ();
             read_mat5_binary_data (is, im.fortran_vec (), n, swap,
                                    static_cast<enum mat5_data_type> (type), flt_fmt);
 
             if (! is || error_state)
               {
-                error ("load: reading imaginary matrix data for `%s'",
+                error ("load: reading imaginary matrix data for '%s'",
                        retval.c_str ());
                 goto data_read_error;
               }
 
             ComplexNDArray ctmp (dims);
 
             for (octave_idx_type i = 0; i < n; i++)
               ctmp(i) = Complex (re(i), im(i));
@@ -1500,21 +1500,21 @@ read_mat5_binary_element (std::istream& 
 
   if (is.eof ())
     is.clear ();
 
   return retval;
 
  data_read_error:
  early_read_error:
-  error ("load: trouble reading binary file `%s'", filename.c_str ());
+  error ("load: trouble reading binary file '%s'", filename.c_str ());
   return std::string ();
 
  skip_ahead:
-  warning ("skipping over `%s'", retval.c_str ());
+  warning ("skipping over '%s'", retval.c_str ());
   is.seekg (pos + static_cast<std::streamoff> (element_length));
   return read_mat5_binary_element (is, filename, swap, global, tc);
 }
 
 int
 read_mat5_binary_file_header (std::istream& is, bool& swap, bool quiet,
                               const std::string& filename)
 {
@@ -2424,16 +2424,20 @@ save_mat5_binary_element (std::ostream& 
     flags |= MAT_FILE_OBJECT_CLASS;
   else
     {
       gripe_wrong_type_arg ("save", tc, false);
       goto error_cleanup;
     }
 
   os.write (reinterpret_cast<char *> (&flags), 4);
+  // Matlab seems to have trouble reading files that have nzmax == 0 at
+  // this point in the file.
+  if (nnz_32 == 0)
+    nnz_32 = 1;
   os.write (reinterpret_cast<char *> (&nnz_32), 4);
 
   write_mat5_tag (os, miINT32, dim_len);
 
   for (int i = 0; i < nd; i++)
     {
       int32_t n = dv(i);
       os.write (reinterpret_cast<char *> (&n), 4);
@@ -2708,12 +2712,12 @@ save_mat5_binary_element (std::ostream& 
     }
   else
     gripe_wrong_type_arg ("save", tc, false);
 
  skip_to_next:
   return true;
 
  error_cleanup:
-  error ("save: error while writing `%s' to MAT file", name.c_str ());
+  error ("save: error while writing '%s' to MAT file", name.c_str ());
 
   return false;
 }
diff --git a/libinterp/interp-core/ls-oct-binary.cc b/libinterp/interp-core/ls-oct-binary.cc
--- a/libinterp/interp-core/ls-oct-binary.cc
+++ b/libinterp/interp-core/ls-oct-binary.cc
@@ -251,17 +251,17 @@ read_binary_data (std::istream& is, bool
     default:
       goto data_read_error;
       break;
     }
 
   if (!tc.load_binary (is, swap, fmt))
     {
     data_read_error:
-      error ("load: trouble reading binary file `%s'", filename.c_str ());
+      error ("load: trouble reading binary file '%s'", filename.c_str ());
     }
 
   return retval;
 }
 
 // Save the data from TC along with the corresponding NAME, help
 // string DOC, and global flag MARK_AS_GLOBAL on stream OS in the
 // binary format described above for read_binary_data.
diff --git a/libinterp/interp-core/mex.cc b/libinterp/interp-core/mex.cc
--- a/libinterp/interp-core/mex.cc
+++ b/libinterp/interp-core/mex.cc
@@ -99,185 +99,22 @@ valid_key (const char *key)
 
  done:
 
   return retval;
 }
 
 // ------------------------------------------------------------------
 
-// A class to provide the default implemenation of some of the virtual
-// functions declared in the mxArray class.
-
-class mxArray_base : public mxArray
+void
+mxArray_base::error (const char *msg) const
 {
-protected:
-
-  mxArray_base (void) : mxArray (xmxArray ()) { }
-
-public:
-
-  mxArray *dup (void) const = 0;
-
-  ~mxArray_base (void) { }
-
-  bool is_octave_value (void) const { return false; }
-
-  int is_cell (void) const = 0;
-
-  int is_char (void) const = 0;
-
-  int is_class (const char *name_arg) const
-  {
-    int retval = 0;
-
-    const char *cname = get_class_name ();
-
-    if (cname && name_arg)
-      retval = ! strcmp (cname, name_arg);
-
-    return retval;
-  }
-
-  int is_complex (void) const = 0;
-
-  int is_double (void) const = 0;
-
-  int is_function_handle (void) const = 0;
-
-  int is_int16 (void) const = 0;
-
-  int is_int32 (void) const = 0;
-
-  int is_int64 (void) const = 0;
-
-  int is_int8 (void) const = 0;
-
-  int is_logical (void) const = 0;
-
-  int is_numeric (void) const = 0;
-
-  int is_single (void) const = 0;
-
-  int is_sparse (void) const = 0;
-
-  int is_struct (void) const = 0;
-
-  int is_uint16 (void) const = 0;
-
-  int is_uint32 (void) const = 0;
-
-  int is_uint64 (void) const = 0;
-
-  int is_uint8 (void) const = 0;
-
-  int is_logical_scalar (void) const
-  {
-    return is_logical () && get_number_of_elements () == 1;
-  }
-
-  int is_logical_scalar_true (void) const = 0;
-
-  mwSize get_m (void) const = 0;
-
-  mwSize get_n (void) const = 0;
-
-  mwSize *get_dimensions (void) const = 0;
-
-  mwSize get_number_of_dimensions (void) const = 0;
-
-  void set_m (mwSize m) = 0;
-
-  void set_n (mwSize n) = 0;
-
-  void set_dimensions (mwSize *dims_arg, mwSize ndims_arg) = 0;
-
-  mwSize get_number_of_elements (void) const = 0;
-
-  int is_empty (void) const = 0;
-
-  mxClassID get_class_id (void) const = 0;
-
-  const char *get_class_name (void) const = 0;
-
-  void set_class_name (const char *name_arg) = 0;
-
-  mxArray *get_cell (mwIndex /*idx*/) const
-  {
-    invalid_type_error ();
-    return 0;
-  }
-
-  void set_cell (mwIndex idx, mxArray *val) = 0;
-
-  double get_scalar (void) const = 0;
-
-  void *get_data (void) const = 0;
-
-  void *get_imag_data (void) const = 0;
-
-  void set_data (void *pr) = 0;
-
-  void set_imag_data (void *pi) = 0;
-
-  mwIndex *get_ir (void) const = 0;
-
-  mwIndex *get_jc (void) const = 0;
-
-  mwSize get_nzmax (void) const = 0;
-
-  void set_ir (mwIndex *ir) = 0;
-
-  void set_jc (mwIndex *jc) = 0;
-
-  void set_nzmax (mwSize nzmax) = 0;
-
-  int add_field (const char *key) = 0;
-
-  void remove_field (int key_num) = 0;
-
-  mxArray *get_field_by_number (mwIndex index, int key_num) const = 0;
-
-  void set_field_by_number (mwIndex index, int key_num, mxArray *val) = 0;
-
-  int get_number_of_fields (void) const = 0;
-
-  const char *get_field_name_by_number (int key_num) const = 0;
-
-  int get_field_number (const char *key) const = 0;
-
-  int get_string (char *buf, mwSize buflen) const = 0;
-
-  char *array_to_string (void) const = 0;
-
-  mwIndex calc_single_subscript (mwSize nsubs, mwIndex *subs) const = 0;
-
-  size_t get_element_size (void) const = 0;
-
-  bool mutation_needed (void) const { return false; }
-
-  mxArray *mutate (void) const { return 0; }
-
-protected:
-
-  octave_value as_octave_value (void) const = 0;
-
-  mxArray_base (const mxArray_base&) : mxArray (xmxArray ()) { }
-
-  void invalid_type_error (void) const
-  {
-    error ("invalid type for operation");
-  }
-
-  void error (const char *msg) const
-  {
-    // FIXME
-    ::error ("%s", msg);
-  }
-};
+  // FIXME
+  ::error ("%s", msg);
+}
 
 static mwIndex
 calc_single_subscript_internal (mwSize ndims, const mwSize *dims,
                                 mwSize nsubs, const mwIndex *subs)
 {
   mwIndex retval = 0;
 
   switch (nsubs)
@@ -322,24 +159,21 @@ static inline void *maybe_mark_foreign (
 class mxArray_octave_value : public mxArray_base
 {
 public:
 
   mxArray_octave_value (const octave_value& ov)
     : mxArray_base (), val (ov), mutate_flag (false),
       id (mxUNKNOWN_CLASS), class_name (0), ndims (-1), dims (0) { }
 
-  mxArray *dup (void) const
+  mxArray_base *dup (void) const { return new mxArray_octave_value (*this); }
+
+  mxArray *as_mxArray (void) const
   {
-    mxArray *retval = val.as_mxArray ();
-
-    if (! retval)
-      retval = new mxArray_octave_value (*this);
-
-    return retval;
+    return val.as_mxArray ();
   }
 
   ~mxArray_octave_value (void)
   {
     mxFree (class_name);
     mxFree (dims);
   }
 
@@ -406,17 +240,17 @@ public:
   }
 
   mwSize *get_dimensions (void) const
   {
     if (! dims)
       {
         ndims = val.ndims ();
 
-        dims = static_cast<mwSize *> (malloc (ndims * sizeof (mwSize)));
+        dims = static_cast<mwSize *> (mxArray::malloc (ndims * sizeof (mwSize)));
 
         dim_vector dv = val.dims ();
 
         for (mwIndex i = 0; i < ndims; i++)
           dims[i] = dv(i);
       }
 
     return dims;
@@ -483,17 +317,17 @@ public:
     return id;
   }
 
   const char *get_class_name (void) const
   {
     if (! class_name)
       {
         std::string s = val.class_name ();
-        class_name = strsave (s.c_str ());
+        class_name = mxArray::strsave (s.c_str ());
       }
 
     return class_name;
   }
 
   // Not allowed.
   void set_class_name (const char */*name_arg*/) { request_mutation (); }
 
@@ -624,17 +458,17 @@ public:
     // strings.
 
     char *buf = 0;
 
     if (val.is_string ())
       {
         mwSize nel = get_number_of_elements ();
 
-        buf = static_cast<char *> (malloc (nel + 1));
+        buf = static_cast<char *> (mxArray::malloc (nel + 1));
 
         if (buf)
           {
             charNDArray tmp = val.char_array_value ();
 
             const char *p = tmp.data ();
 
             for (mwIndex i = 0; i < nel; i++)
@@ -688,24 +522,25 @@ public:
     if (mutate_flag)
       panic_impossible ();
 
     mutate_flag = true;
   }
 
   mxArray *mutate (void) const { return val.as_mxArray (); }
 
+  octave_value as_octave_value (void) const { return val; }
+
 protected:
 
-  octave_value as_octave_value (void) const { return val; }
-
   mxArray_octave_value (const mxArray_octave_value& arg)
     : mxArray_base (arg), val (arg.val), mutate_flag (arg.mutate_flag),
-      id (arg.id), class_name (strsave (arg.class_name)), ndims (arg.ndims),
-      dims (ndims > 0 ? static_cast<mwSize *> (malloc (ndims * sizeof (mwSize))) : 0)
+      id (arg.id), class_name (mxArray::strsave (arg.class_name)),
+      ndims (arg.ndims),
+      dims (ndims > 0 ? static_cast<mwSize *> (mxArray::malloc (ndims * sizeof (mwSize))) : 0)
   {
     if (dims)
       {
         for (mwIndex i = 0; i < ndims; i++)
           dims[i] = arg.dims[i];
       }
   }
 
@@ -738,17 +573,17 @@ class mxArray_matlab : public mxArray_ba
 protected:
 
   mxArray_matlab (mxClassID id_arg = mxUNKNOWN_CLASS)
     : mxArray_base (), class_name (0), id (id_arg), ndims (0), dims (0) { }
 
   mxArray_matlab (mxClassID id_arg, mwSize ndims_arg, const mwSize *dims_arg)
     : mxArray_base (), class_name (0), id (id_arg),
       ndims (ndims_arg < 2 ? 2 : ndims_arg),
-      dims (static_cast<mwSize *> (malloc (ndims * sizeof (mwSize))))
+      dims (static_cast<mwSize *> (mxArray::malloc (ndims * sizeof (mwSize))))
   {
     if (ndims_arg < 2)
       {
         dims[0] = 1;
         dims[1] = 1;
       }
 
     for (mwIndex i = 0; i < ndims_arg; i++)
@@ -761,33 +596,33 @@ protected:
         else
           break;
       }
   }
 
   mxArray_matlab (mxClassID id_arg, const dim_vector& dv)
     : mxArray_base (), class_name (0), id (id_arg),
       ndims (dv.length ()),
-      dims (static_cast<mwSize *> (malloc (ndims * sizeof (mwSize))))
+      dims (static_cast<mwSize *> (mxArray::malloc (ndims * sizeof (mwSize))))
   {
     for (mwIndex i = 0; i < ndims; i++)
       dims[i] = dv(i);
 
     for (mwIndex i = ndims - 1; i > 1; i--)
       {
         if (dims[i] == 1)
           ndims--;
         else
           break;
       }
   }
 
   mxArray_matlab (mxClassID id_arg, mwSize m, mwSize n)
     : mxArray_base (), class_name (0), id (id_arg), ndims (2),
-      dims (static_cast<mwSize *> (malloc (ndims * sizeof (mwSize))))
+      dims (static_cast<mwSize *> (mxArray::malloc (ndims * sizeof (mwSize))))
   {
     dims[0] = m;
     dims[1] = n;
   }
 
 public:
 
   ~mxArray_matlab (void)
@@ -906,17 +741,17 @@ public:
       case mxFUNCTION_CLASS: return "function_handle";
       default: return "unknown";
       }
   }
 
   void set_class_name (const char *name_arg)
   {
     mxFree (class_name);
-    class_name = static_cast<char *> (malloc (strlen (name_arg) + 1));
+    class_name = static_cast<char *> (mxArray::malloc (strlen (name_arg) + 1));
     strcpy (class_name, name_arg);
   }
 
   mxArray *get_cell (mwIndex /*idx*/) const
   {
     invalid_type_error ();
     return 0;
   }
@@ -1064,19 +899,19 @@ public:
       case mxFUNCTION_CLASS: return 0;
       default: return 0;
       }
   }
 
 protected:
 
   mxArray_matlab (const mxArray_matlab& val)
-    : mxArray_base (val), class_name (strsave (val.class_name)),
+    : mxArray_base (val), class_name (mxArray::strsave (val.class_name)),
       id (val.id), ndims (val.ndims),
-      dims (static_cast<mwSize *> (malloc (ndims * sizeof (mwSize))))
+      dims (static_cast<mwSize *> (mxArray::malloc (ndims * sizeof (mwSize))))
   {
     for (mwIndex i = 0; i < ndims; i++)
       dims[i] = val.dims[i];
   }
 
   dim_vector
   dims_to_dim_vector (void) const
   {
@@ -1117,65 +952,65 @@ private:
 
 class mxArray_number : public mxArray_matlab
 {
 public:
 
   mxArray_number (mxClassID id_arg, mwSize ndims_arg, const mwSize *dims_arg,
                   mxComplexity flag = mxREAL)
     : mxArray_matlab (id_arg, ndims_arg, dims_arg),
-      pr (calloc (get_number_of_elements (), get_element_size ())),
-      pi (flag == mxCOMPLEX ? calloc (get_number_of_elements (), get_element_size ()) : 0) { }
+      pr (mxArray::calloc (get_number_of_elements (), get_element_size ())),
+      pi (flag == mxCOMPLEX ? mxArray::calloc (get_number_of_elements (), get_element_size ()) : 0) { }
 
   mxArray_number (mxClassID id_arg, const dim_vector& dv,
                   mxComplexity flag = mxREAL)
     : mxArray_matlab (id_arg, dv),
-      pr (calloc (get_number_of_elements (), get_element_size ())),
-      pi (flag == mxCOMPLEX ? calloc (get_number_of_elements (), get_element_size ()) : 0) { }
+      pr (mxArray::calloc (get_number_of_elements (), get_element_size ())),
+      pi (flag == mxCOMPLEX ? mxArray::calloc (get_number_of_elements (), get_element_size ()) : 0) { }
 
   mxArray_number (mxClassID id_arg, mwSize m, mwSize n, mxComplexity flag = mxREAL)
     : mxArray_matlab (id_arg, m, n),
-      pr (calloc (get_number_of_elements (), get_element_size ())),
-      pi (flag == mxCOMPLEX ? calloc (get_number_of_elements (), get_element_size ()) : 0) { }
+      pr (mxArray::calloc (get_number_of_elements (), get_element_size ())),
+      pi (flag == mxCOMPLEX ? mxArray::calloc (get_number_of_elements (), get_element_size ()) : 0) { }
 
   mxArray_number (mxClassID id_arg, double val)
     : mxArray_matlab (id_arg, 1, 1),
-      pr (calloc (get_number_of_elements (), get_element_size ())),
+      pr (mxArray::calloc (get_number_of_elements (), get_element_size ())),
       pi (0)
   {
     double *dpr = static_cast<double *> (pr);
     dpr[0] = val;
   }
 
   mxArray_number (mxClassID id_arg, mxLogical val)
     : mxArray_matlab (id_arg, 1, 1),
-      pr (calloc (get_number_of_elements (), get_element_size ())),
+      pr (mxArray::calloc (get_number_of_elements (), get_element_size ())),
       pi (0)
   {
     mxLogical *lpr = static_cast<mxLogical *> (pr);
     lpr[0] = val;
   }
 
   mxArray_number (const char *str)
     : mxArray_matlab (mxCHAR_CLASS,
                       str ? (strlen (str) ? 1 : 0) : 0,
                       str ? strlen (str) : 0),
-      pr (calloc (get_number_of_elements (), get_element_size ())),
+      pr (mxArray::calloc (get_number_of_elements (), get_element_size ())),
       pi (0)
   {
     mxChar *cpr = static_cast<mxChar *> (pr);
     mwSize nel = get_number_of_elements ();
     for (mwIndex i = 0; i < nel; i++)
       cpr[i] = str[i];
   }
 
   // FIXME??
   mxArray_number (mwSize m, const char **str)
     : mxArray_matlab (mxCHAR_CLASS, m, max_str_len (m, str)),
-      pr (calloc (get_number_of_elements (), get_element_size ())),
+      pr (mxArray::calloc (get_number_of_elements (), get_element_size ())),
       pi (0)
   {
     mxChar *cpr = static_cast<mxChar *> (pr);
 
     mwSize *dv = get_dimensions ();
 
     mwSize nc = dv[1];
 
@@ -1188,17 +1023,17 @@ public:
         for (size_t i = 0; i < tmp_len; i++)
           cpr[m*i+j] = static_cast<mxChar> (ptr[i]);
 
         for (size_t i = tmp_len; i < static_cast<size_t>(nc); i++)
           cpr[m*i+j] = static_cast<mxChar> (' ');
       }
   }
 
-  mxArray_number *dup (void) const { return new mxArray_number (*this); }
+  mxArray_base *dup (void) const { return new mxArray_number (*this); }
 
   ~mxArray_number (void)
   {
     mxFree (pr);
     mxFree (pi);
   }
 
   int is_complex (void) const { return pi != 0; }
@@ -1300,60 +1135,31 @@ public:
 
   char *array_to_string (void) const
   {
     // FIXME -- this is suposed to handle multi-byte character
     // strings.
 
     mwSize nel = get_number_of_elements ();
 
-    char *buf = static_cast<char *> (malloc (nel + 1));
+    char *buf = static_cast<char *> (mxArray::malloc (nel + 1));
 
     if (buf)
       {
         mxChar *ptr = static_cast<mxChar *> (pr);
 
         for (mwIndex i = 0; i < nel; i++)
           buf[i] = static_cast<char> (ptr[i]);
 
         buf[nel] = '\0';
       }
 
     return buf;
   }
 
-protected:
-
-  template <typename ELT_T, typename ARRAY_T, typename ARRAY_ELT_T>
-  octave_value
-  int_to_ov (const dim_vector& dv) const
-  {
-    octave_value retval;
-
-    mwSize nel = get_number_of_elements ();
-
-    ELT_T *ppr = static_cast<ELT_T *> (pr);
-
-    if (pi)
-      error ("complex integer types are not supported");
-    else
-      {
-        ARRAY_T val (dv);
-
-        ARRAY_ELT_T *ptr = val.fortran_vec ();
-
-        for (mwIndex i = 0; i < nel; i++)
-          ptr[i] = ppr[i];
-
-        retval = val;
-      }
-
-    return retval;
-  }
-
   octave_value as_octave_value (void) const
   {
     octave_value retval;
 
     dim_vector dv = dims_to_dim_vector ();
 
     switch (get_class_id ())
       {
@@ -1478,20 +1284,49 @@ protected:
 
       default:
         panic_impossible ();
       }
 
     return retval;
   }
 
+protected:
+
+  template <typename ELT_T, typename ARRAY_T, typename ARRAY_ELT_T>
+  octave_value
+  int_to_ov (const dim_vector& dv) const
+  {
+    octave_value retval;
+
+    mwSize nel = get_number_of_elements ();
+
+    ELT_T *ppr = static_cast<ELT_T *> (pr);
+
+    if (pi)
+      error ("complex integer types are not supported");
+    else
+      {
+        ARRAY_T val (dv);
+
+        ARRAY_ELT_T *ptr = val.fortran_vec ();
+
+        for (mwIndex i = 0; i < nel; i++)
+          ptr[i] = ppr[i];
+
+        retval = val;
+      }
+
+    return retval;
+  }
+
   mxArray_number (const mxArray_number& val)
     : mxArray_matlab (val),
-      pr (malloc (get_number_of_elements () * get_element_size ())),
-      pi (val.pi ? malloc (get_number_of_elements () * get_element_size ()) : 0)
+      pr (mxArray::malloc (get_number_of_elements () * get_element_size ())),
+      pi (val.pi ? mxArray::malloc (get_number_of_elements () * get_element_size ()) : 0)
   {
     size_t nbytes = get_number_of_elements () * get_element_size ();
 
     if (pr)
       memcpy (pr, val.pr, nbytes);
 
     if (pi)
       memcpy (pi, val.pi, nbytes);
@@ -1512,23 +1347,23 @@ private:
 
 class mxArray_sparse : public mxArray_matlab
 {
 public:
 
   mxArray_sparse (mxClassID id_arg, mwSize m, mwSize n, mwSize nzmax_arg,
                   mxComplexity flag = mxREAL)
     : mxArray_matlab (id_arg, m, n), nzmax (nzmax_arg),
-      pr (calloc (nzmax, get_element_size ())),
-      pi (flag == mxCOMPLEX ? calloc (nzmax, get_element_size ()) : 0),
-      ir (static_cast<mwIndex *> (calloc (nzmax, sizeof (mwIndex)))),
-      jc (static_cast<mwIndex *> (calloc (n + 1, sizeof (mwIndex))))
+      pr (mxArray::calloc (nzmax, get_element_size ())),
+      pi (flag == mxCOMPLEX ? mxArray::calloc (nzmax, get_element_size ()) : 0),
+      ir (static_cast<mwIndex *> (mxArray::calloc (nzmax, sizeof (mwIndex)))),
+      jc (static_cast<mwIndex *> (mxArray::calloc (n + 1, sizeof (mwIndex))))
     { }
 
-  mxArray_sparse *dup (void) const { return new mxArray_sparse (*this); }
+  mxArray_base *dup (void) const { return new mxArray_sparse (*this); }
 
   ~mxArray_sparse (void)
   {
     mxFree (pr);
     mxFree (pi);
     mxFree (ir);
     mxFree (jc);
   }
@@ -1552,18 +1387,16 @@ public:
   mwSize get_nzmax (void) const { return nzmax; }
 
   void set_ir (mwIndex *ir_arg) { ir = ir_arg; }
 
   void set_jc (mwIndex *jc_arg) { jc = jc_arg; }
 
   void set_nzmax (mwSize nzmax_arg) { nzmax = nzmax_arg; }
 
-protected:
-
   octave_value as_octave_value (void) const
   {
     octave_value retval;
 
     dim_vector dv = dims_to_dim_vector ();
 
     switch (get_class_id ())
       {
@@ -1646,20 +1479,20 @@ private:
 
   void *pr;
   void *pi;
   mwIndex *ir;
   mwIndex *jc;
 
   mxArray_sparse (const mxArray_sparse& val)
     : mxArray_matlab (val), nzmax (val.nzmax),
-      pr (malloc (nzmax * get_element_size ())),
-      pi (val.pi ? malloc (nzmax * get_element_size ()) : 0),
-      ir (static_cast<mwIndex *> (malloc (nzmax * sizeof (mwIndex)))),
-      jc (static_cast<mwIndex *> (malloc (nzmax * sizeof (mwIndex))))
+      pr (mxArray::malloc (nzmax * get_element_size ())),
+      pi (val.pi ? mxArray::malloc (nzmax * get_element_size ()) : 0),
+      ir (static_cast<mwIndex *> (mxArray::malloc (nzmax * sizeof (mwIndex)))),
+      jc (static_cast<mwIndex *> (mxArray::malloc (nzmax * sizeof (mwIndex))))
   {
     size_t nbytes = nzmax * get_element_size ();
 
     if (pr)
       memcpy (pr, val.pr, nbytes);
 
     if (pi)
       memcpy (pi, val.pi, nbytes);
@@ -1681,45 +1514,45 @@ private:
 
 class mxArray_struct : public mxArray_matlab
 {
 public:
 
   mxArray_struct (mwSize ndims_arg, const mwSize *dims_arg, int num_keys_arg,
                   const char **keys)
     : mxArray_matlab (mxSTRUCT_CLASS, ndims_arg, dims_arg), nfields (num_keys_arg),
-      fields (static_cast<char **> (calloc (nfields, sizeof (char *)))),
-      data (static_cast<mxArray **> (calloc (nfields * get_number_of_elements (), sizeof (mxArray *))))
+      fields (static_cast<char **> (mxArray::calloc (nfields, sizeof (char *)))),
+      data (static_cast<mxArray **> (mxArray::calloc (nfields * get_number_of_elements (), sizeof (mxArray *))))
   {
     init (keys);
   }
 
   mxArray_struct (const dim_vector& dv, int num_keys_arg, const char **keys)
     : mxArray_matlab (mxSTRUCT_CLASS, dv), nfields (num_keys_arg),
-      fields (static_cast<char **> (calloc (nfields, sizeof (char *)))),
-      data (static_cast<mxArray **> (calloc (nfields * get_number_of_elements (), sizeof (mxArray *))))
+      fields (static_cast<char **> (mxArray::calloc (nfields, sizeof (char *)))),
+      data (static_cast<mxArray **> (mxArray::calloc (nfields * get_number_of_elements (), sizeof (mxArray *))))
   {
     init (keys);
   }
 
   mxArray_struct (mwSize m, mwSize n, int num_keys_arg, const char **keys)
     : mxArray_matlab (mxSTRUCT_CLASS, m, n), nfields (num_keys_arg),
-      fields (static_cast<char **> (calloc (nfields, sizeof (char *)))),
-      data (static_cast<mxArray **> (calloc (nfields * get_number_of_elements (), sizeof (mxArray *))))
+      fields (static_cast<char **> (mxArray::calloc (nfields, sizeof (char *)))),
+      data (static_cast<mxArray **> (mxArray::calloc (nfields * get_number_of_elements (), sizeof (mxArray *))))
   {
     init (keys);
   }
 
   void init (const char **keys)
   {
     for (int i = 0; i < nfields; i++)
-      fields[i] = strsave (keys[i]);
+      fields[i] = mxArray::strsave (keys[i]);
   }
 
-  mxArray_struct *dup (void) const { return new mxArray_struct (*this); }
+  mxArray_base *dup (void) const { return new mxArray_struct (*this); }
 
   ~mxArray_struct (void)
   {
     for (int i = 0; i < nfields; i++)
       mxFree (fields[i]);
 
     mxFree (fields);
 
@@ -1738,23 +1571,23 @@ public:
     if (valid_key (key))
       {
         nfields++;
 
         fields = static_cast<char **> (mxRealloc (fields, nfields * sizeof (char *)));
 
         if (fields)
           {
-            fields[nfields-1] = strsave (key);
+            fields[nfields-1] = mxArray::strsave (key);
 
             mwSize nel = get_number_of_elements ();
 
             mwSize ntot = nfields * nel;
 
-            mxArray **new_data = static_cast<mxArray **> (malloc (ntot * sizeof (mxArray *)));
+            mxArray **new_data = static_cast<mxArray **> (mxArray::malloc (ntot * sizeof (mxArray *)));
 
             if (new_data)
               {
                 mwIndex j = 0;
                 mwIndex k = 0;
                 mwIndex n = 0;
 
                 for (mwIndex i = 0; i < ntot; i++)
@@ -1785,19 +1618,19 @@ public:
     if (key_num >= 0 && key_num < nfields)
       {
         mwSize nel = get_number_of_elements ();
 
         mwSize ntot = nfields * nel;
 
         int new_nfields = nfields - 1;
 
-        char **new_fields = static_cast<char **> (malloc (new_nfields * sizeof (char *)));
-
-        mxArray **new_data = static_cast<mxArray **> (malloc (new_nfields * nel * sizeof (mxArray *)));
+        char **new_fields = static_cast<char **> (mxArray::malloc (new_nfields * sizeof (char *)));
+
+        mxArray **new_data = static_cast<mxArray **> (mxArray::malloc (new_nfields * nel * sizeof (mxArray *)));
 
         for (int i = 0; i < key_num; i++)
           new_fields[i] = fields[i];
 
         for (int i = key_num + 1; i < nfields; i++)
           new_fields[i-1] = fields[i];
 
         if (new_nfields > 0)
@@ -1858,18 +1691,16 @@ public:
 
     return retval;
   }
 
   void *get_data (void) const { return data; }
 
   void set_data (void *data_arg) { data = static_cast<mxArray **> (data_arg); }
 
-protected:
-
   octave_value as_octave_value (void) const
   {
     dim_vector dv = dims_to_dim_vector ();
 
     string_vector keys (fields, nfields);
 
     octave_map m;
 
@@ -1896,21 +1727,21 @@ private:
   int nfields;
 
   char **fields;
 
   mxArray **data;
 
   mxArray_struct (const mxArray_struct& val)
     : mxArray_matlab (val), nfields (val.nfields),
-      fields (static_cast<char **> (malloc (nfields * sizeof (char *)))),
-      data (static_cast<mxArray **> (malloc (nfields * get_number_of_elements () * sizeof (mxArray *))))
+      fields (static_cast<char **> (mxArray::malloc (nfields * sizeof (char *)))),
+      data (static_cast<mxArray **> (mxArray::malloc (nfields * get_number_of_elements () * sizeof (mxArray *))))
   {
     for (int i = 0; i < nfields; i++)
-      fields[i] = strsave (val.fields[i]);
+      fields[i] = mxArray::strsave (val.fields[i]);
 
     mwSize nel = get_number_of_elements ();
 
     for (mwIndex i = 0; i < nel * nfields; i++)
       {
         mxArray *ptr = val.data[i];
         data[i] = ptr ? ptr->dup () : 0;
       }
@@ -1925,27 +1756,27 @@ private:
 // Matlab-style cell arrays.
 
 class mxArray_cell : public mxArray_matlab
 {
 public:
 
   mxArray_cell (mwSize ndims_arg, const mwSize *dims_arg)
     : mxArray_matlab (mxCELL_CLASS, ndims_arg, dims_arg),
-      data (static_cast<mxArray **> (calloc (get_number_of_elements (), sizeof (mxArray *)))) { }
+      data (static_cast<mxArray **> (mxArray::calloc (get_number_of_elements (), sizeof (mxArray *)))) { }
 
   mxArray_cell (const dim_vector& dv)
     : mxArray_matlab (mxCELL_CLASS, dv),
-      data (static_cast<mxArray **> (calloc (get_number_of_elements (), sizeof (mxArray *)))) { }
+      data (static_cast<mxArray **> (mxArray::calloc (get_number_of_elements (), sizeof (mxArray *)))) { }
 
   mxArray_cell (mwSize m, mwSize n)
     : mxArray_matlab (mxCELL_CLASS, m, n),
-      data (static_cast<mxArray **> (calloc (get_number_of_elements (), sizeof (mxArray *)))) { }
-
-  mxArray_cell *dup (void) const { return new mxArray_cell (*this); }
+      data (static_cast<mxArray **> (mxArray::calloc (get_number_of_elements (), sizeof (mxArray *)))) { }
+
+  mxArray_base *dup (void) const { return new mxArray_cell (*this); }
 
   ~mxArray_cell (void)
   {
     mwSize nel = get_number_of_elements ();
 
     for  (mwIndex i = 0; i < nel; i++)
       delete data[i];
 
@@ -1958,18 +1789,16 @@ public:
   }
 
   void set_cell (mwIndex idx, mxArray *val);
 
   void *get_data (void) const { return data; }
 
   void set_data (void *data_arg) { data = static_cast<mxArray **> (data_arg); }
 
-protected:
-
   octave_value as_octave_value (void) const
   {
     dim_vector dv = dims_to_dim_vector ();
 
     Cell c (dv);
 
     mwSize nel = get_number_of_elements ();
 
@@ -1982,17 +1811,17 @@ protected:
   }
 
 private:
 
   mxArray **data;
 
   mxArray_cell (const mxArray_cell& val)
     : mxArray_matlab (val),
-      data (static_cast<mxArray **> (malloc (get_number_of_elements () * sizeof (mxArray *))))
+      data (static_cast<mxArray **> (mxArray::malloc (get_number_of_elements () * sizeof (mxArray *))))
   {
     mwSize nel = get_number_of_elements ();
 
     for (mwIndex i = 0; i < nel; i++)
       {
         mxArray *ptr = val.data[i];
         data[i] = ptr ? ptr->dup () : 0;
       }
@@ -2057,21 +1886,21 @@ mxArray::~mxArray (void)
 
   delete rep;
 }
 
 void
 mxArray::set_name (const char *name_arg)
 {
   mxFree (name);
-  name = strsave (name_arg);
+  name = mxArray::strsave (name_arg);
 }
 
 octave_value
-mxArray::as_octave_value (mxArray *ptr)
+mxArray::as_octave_value (const mxArray *ptr)
 {
   return ptr ? ptr->as_octave_value () : octave_value (Matrix ());
 }
 
 octave_value
 mxArray::as_octave_value (void) const
 {
   return rep->as_octave_value ();
@@ -2527,17 +2356,17 @@ mxGetNaN (void)
 {
   return lo_ieee_nan_value ();
 }
 
 // Memory management.
 void *
 mxCalloc (size_t n, size_t size)
 {
-  return mex_context ? mex_context->calloc (n, size) : calloc (n, size);
+  return mex_context ? mex_context->calloc (n, size) : ::calloc (n, size);
 }
 
 void *
 mxMalloc (size_t n)
 {
   return mex_context ? mex_context->malloc (n) : gnulib::malloc (n);
 }
 
@@ -3175,18 +3004,18 @@ call_mex (bool have_fmex, void *f, const
 
 const char *
 mexFunctionName (void)
 {
   return mex_context ? mex_context->function_name () : "unknown";
 }
 
 int
-mexCallMATLAB (int nargout, mxArray *argout[], int nargin, mxArray *argin[],
-               const char *fname)
+mexCallMATLAB (int nargout, mxArray *argout[], int nargin,
+               mxArray *argin[], const char *fname)
 {
   octave_value_list args;
 
   // FIXME -- do we need unwind protect to clean up args?  Off hand, I
   // would say that this problem is endemic to Octave and we will
   // continue to have memory leaks after Ctrl-C until proper exception
   // handling is implemented.  longjmp() only clears the stack, so any
   // class which allocates data on the heap is going to leak.
@@ -3381,17 +3210,17 @@ mexGetVariable (const char *space, const
 
 const mxArray *
 mexGetVariablePtr (const char *space, const char *name)
 {
   return mexGetVariable (space, name);
 }
 
 int
-mexPutVariable (const char *space, const char *name, mxArray *ptr)
+mexPutVariable (const char *space, const char *name, const mxArray *ptr)
 {
   if (! ptr)
     return 1;
 
   if (! name)
     return 1;
 
   if (name[0] == '\0')
diff --git a/libinterp/interp-core/mexproto.h b/libinterp/interp-core/mexproto.h
--- a/libinterp/interp-core/mexproto.h
+++ b/libinterp/interp-core/mexproto.h
@@ -82,17 +82,18 @@ extern OCTINTERP_API void mexErrMsgTxt (
 extern OCTINTERP_API void mexErrMsgIdAndTxt (const char *id, const char *s, ...);
 extern OCTINTERP_API void mexWarnMsgTxt (const char *s);
 extern OCTINTERP_API void mexWarnMsgIdAndTxt (const char *id, const char *s, ...);
 extern OCTINTERP_API int mexPrintf (const char *fmt, ...);
 
 extern OCTINTERP_API mxArray *mexGetVariable (const char *space, const char *name);
 extern OCTINTERP_API const mxArray *mexGetVariablePtr (const char *space, const char *name);
 
-extern OCTINTERP_API int mexPutVariable (const char *space, const char *name, mxArray *ptr);
+extern OCTINTERP_API int mexPutVariable (const char *space, const char *name,
+                                         const mxArray *ptr);
 
 extern OCTINTERP_API void mexMakeArrayPersistent (mxArray *ptr);
 extern OCTINTERP_API void mexMakeMemoryPersistent (void *ptr);
 
 extern OCTINTERP_API int mexAtExit (void (*f) (void));
 extern OCTINTERP_API const mxArray *mexGet (double handle, const char *property);
 extern OCTINTERP_API int mexIsGlobal (const mxArray *ptr);
 extern OCTINTERP_API int mexIsLocked (void);
diff --git a/libinterp/interp-core/module.mk b/libinterp/interp-core/module.mk
--- a/libinterp/interp-core/module.mk
+++ b/libinterp/interp-core/module.mk
@@ -1,29 +1,31 @@
 EXTRA_DIST += \
   interp-core/module.mk \
   interp-core/gl2ps.c \
   interp-core/mxarray.in.h \
   interp-core/oct-errno.in.cc
 
-JIT_INCLUDES = \
+JIT_INC = \
   interp-core/jit-util.h \
   interp-core/jit-typeinfo.h \
   interp-core/jit-ir.h \
   interp-core/pt-jit.h
 
-INTERP_CORE_INCLUDES = \
+INTERP_CORE_INC = \
   interp-core/Cell.h \
+  interp-core/action-container.h \
   interp-core/c-file-ptr-stream.h \
   interp-core/comment-list.h \
   interp-core/cutils.h \
   interp-core/defun-dld.h \
   interp-core/defun-int.h \
   interp-core/display.h \
   interp-core/dynamic-ld.h \
+  interp-core/event-queue.h \
   interp-core/gl-render.h \
   interp-core/gl2ps-renderer.h \
   interp-core/gl2ps.h \
   interp-core/gripes.h \
   interp-core/ls-ascii-helper.h \
   interp-core/ls-hdf5.h \
   interp-core/ls-mat-ascii.h \
   interp-core/ls-mat4.h \
@@ -52,17 +54,17 @@ INTERP_CORE_INCLUDES = \
   interp-core/sparse-xpow.h \
   interp-core/txt-eng-ft.h \
   interp-core/txt-eng.h \
   interp-core/unwind-prot.h \
   interp-core/xdiv.h \
   interp-core/xnorm.h \
   interp-core/xpow.h \
   interp-core/zfstream.h \
-  $(JIT_INCLUDES)
+  $(JIT_INC)
 
 JIT_SRC = \
   interp-core/jit-util.cc \
   interp-core/jit-typeinfo.cc \
   interp-core/jit-ir.cc \
   interp-core/pt-jit.cc
 
 C_INTERP_CORE_SRC = \
@@ -104,18 +106,21 @@ INTERP_CORE_SRC = \
   interp-core/unwind-prot.cc \
   interp-core/xdiv.cc \
   interp-core/xnorm.cc \
   interp-core/xpow.cc \
   interp-core/zfstream.cc \
   $(JIT_SRC) \
   $(C_INTERP_CORE_SRC)
 
-## FIXME: I don't believe this rule actually fires
-display.df display.lo: CPPFLAGS += $(X11_FLAGS)
+## FIXME: Automake does not support per-object rules.
+##        These rules could be emulated by creating a new convenience
+##        library and using per-library rules.  Or we can just live
+##        without the rule since there haven't been any problems. (09/18/2012)
+#display.df display.lo: CPPFLAGS += $(X11_FLAGS)
 
 ## Special rules for sources which must be built before rest of compilation.
 interp-core/oct-errno.cc: interp-core/oct-errno.in.cc Makefile
 	if test -n "$(PERL)"; then \
 	  $(srcdir)/mk-errno-list --perl "$(PERL)" < $< > $@-t; \
 	elif test -n "$(PYTHON)"; then \
 	  $(srcdir)/mk-errno-list --python "$(PYTHON)" < $< > $@-t; \
 	else \
@@ -127,8 +132,9 @@ interp-core/mxarray.h: interp-core/mxarr
 	$(SED) < $< \
 	  -e "s|%NO_EDIT_WARNING%|DO NOT EDIT!  Generated automatically from $(<F) by Make.|" \
 	  -e "s|%OCTAVE_IDX_TYPE%|${OCTAVE_IDX_TYPE}|" > $@-t
 	mv $@-t $@
 
 noinst_LTLIBRARIES += interp-core/libinterp-core.la
 
 interp_core_libinterp_core_la_SOURCES = $(INTERP_CORE_SRC)
+interp_core_libinterp_core_la_CPPFLAGS = $(liboctinterp_la_CPPFLAGS)
diff --git a/libinterp/interp-core/mxarray.in.h b/libinterp/interp-core/mxarray.in.h
--- a/libinterp/interp-core/mxarray.in.h
+++ b/libinterp/interp-core/mxarray.in.h
@@ -83,16 +83,17 @@ typedef char mxChar;
 
 /*
  * FIXME? Mathworks says these should be size_t on 64-bit system and when
  * mex is used with the -largearraydims flag, but why do that? Its better
  * to conform to the same indexing as the rest of Octave
  */
 typedef %OCTAVE_IDX_TYPE% mwSize;
 typedef %OCTAVE_IDX_TYPE% mwIndex;
+typedef %OCTAVE_IDX_TYPE% mwSignedIndex;
 
 #if ! defined (MXARRAY_TYPEDEFS_ONLY)
 
 #include <cstring>
 
 class octave_value;
 
 #define DO_MUTABLE_METHOD(RET_T, METHOD_CALL) \
@@ -110,23 +111,184 @@ class octave_value;
   rep->METHOD_CALL; \
  \
   if (rep->mutation_needed ()) \
     { \
       maybe_mutate (); \
       rep->METHOD_CALL; \
     }
 
-// This just provides a way to avoid infinite recursion when building
-// mxArray objects.
+// A class to provide the default implemenation of some of the virtual
+// functions declared in the mxArray class.
+
+class mxArray;
+
+class mxArray_base
+{
+protected:
+
+  mxArray_base (void) { }
+
+public:
+
+  virtual mxArray_base *dup (void) const = 0;
+
+  virtual mxArray *as_mxArray (void) const { return 0; }
+
+  virtual ~mxArray_base (void) { }
+
+  virtual bool is_octave_value (void) const { return false; }
+
+  virtual int is_cell (void) const = 0;
+
+  virtual int is_char (void) const = 0;
+
+  virtual int is_class (const char *name_arg) const
+  {
+    int retval = 0;
+
+    const char *cname = get_class_name ();
+
+    if (cname && name_arg)
+      retval = ! strcmp (cname, name_arg);
+
+    return retval;
+  }
+
+  virtual int is_complex (void) const = 0;
+
+  virtual int is_double (void) const = 0;
+
+  virtual int is_function_handle (void) const = 0;
+
+  virtual int is_int16 (void) const = 0;
+
+  virtual int is_int32 (void) const = 0;
+
+  virtual int is_int64 (void) const = 0;
+
+  virtual int is_int8 (void) const = 0;
+
+  virtual int is_logical (void) const = 0;
+
+  virtual int is_numeric (void) const = 0;
+
+  virtual int is_single (void) const = 0;
+
+  virtual int is_sparse (void) const = 0;
+
+  virtual int is_struct (void) const = 0;
+
+  virtual int is_uint16 (void) const = 0;
+
+  virtual int is_uint32 (void) const = 0;
+
+  virtual int is_uint64 (void) const = 0;
+
+  virtual int is_uint8 (void) const = 0;
+
+  virtual int is_logical_scalar (void) const
+  {
+    return is_logical () && get_number_of_elements () == 1;
+  }
+
+  virtual int is_logical_scalar_true (void) const = 0;
+
+  virtual mwSize get_m (void) const = 0;
+
+  virtual mwSize get_n (void) const = 0;
+
+  virtual mwSize *get_dimensions (void) const = 0;
+
+  virtual mwSize get_number_of_dimensions (void) const = 0;
 
-struct
-xmxArray
-{
-  xmxArray (void) { }
+  virtual void set_m (mwSize m) = 0;
+
+  virtual void set_n (mwSize n) = 0;
+
+  virtual void set_dimensions (mwSize *dims_arg, mwSize ndims_arg) = 0;
+
+  virtual mwSize get_number_of_elements (void) const = 0;
+
+  virtual int is_empty (void) const = 0;
+
+  virtual mxClassID get_class_id (void) const = 0;
+
+  virtual const char *get_class_name (void) const = 0;
+
+  virtual void set_class_name (const char *name_arg) = 0;
+
+  virtual mxArray *get_cell (mwIndex /*idx*/) const
+  {
+    invalid_type_error ();
+    return 0;
+  }
+
+  virtual void set_cell (mwIndex idx, mxArray *val) = 0;
+
+  virtual double get_scalar (void) const = 0;
+
+  virtual void *get_data (void) const = 0;
+
+  virtual void *get_imag_data (void) const = 0;
+
+  virtual void set_data (void *pr) = 0;
+
+  virtual void set_imag_data (void *pi) = 0;
+
+  virtual mwIndex *get_ir (void) const = 0;
+
+  virtual mwIndex *get_jc (void) const = 0;
+
+  virtual mwSize get_nzmax (void) const = 0;
+
+  virtual void set_ir (mwIndex *ir) = 0;
+
+  virtual void set_jc (mwIndex *jc) = 0;
+
+  virtual void set_nzmax (mwSize nzmax) = 0;
+
+  virtual int add_field (const char *key) = 0;
+
+  virtual void remove_field (int key_num) = 0;
+
+  virtual mxArray *get_field_by_number (mwIndex index, int key_num) const = 0;
+
+  virtual void set_field_by_number (mwIndex index, int key_num, mxArray *val) = 0;
+
+  virtual int get_number_of_fields (void) const = 0;
+
+  virtual const char *get_field_name_by_number (int key_num) const = 0;
+
+  virtual int get_field_number (const char *key) const = 0;
+
+  virtual int get_string (char *buf, mwSize buflen) const = 0;
+
+  virtual char *array_to_string (void) const = 0;
+
+  virtual mwIndex calc_single_subscript (mwSize nsubs, mwIndex *subs) const = 0;
+
+  virtual size_t get_element_size (void) const = 0;
+
+  virtual bool mutation_needed (void) const { return false; }
+
+  virtual mxArray *mutate (void) const { return 0; }
+
+  virtual octave_value as_octave_value (void) const = 0;
+
+protected:
+
+  mxArray_base (const mxArray_base&) { }
+
+  void invalid_type_error (void) const
+  {
+    error ("invalid type for operation");
+  }
+
+  void error (const char *msg) const;
 };
 
 // The main interface class.  The representation can be based on an
 // octave_value object or a separate object that tries to reproduce
 // the semantics of mxArray objects in Matlab more directly.
 
 class mxArray
 {
@@ -159,148 +321,157 @@ public:
   mxArray (mwSize m, mwSize n, int num_keys, const char **keys);
 
   mxArray (mwSize ndims, const mwSize *dims);
 
   mxArray (const dim_vector& dv);
 
   mxArray (mwSize m, mwSize n);
 
-  virtual mxArray *dup (void) const
+  mxArray *dup (void) const
   {
-    mxArray *new_rep = rep->dup ();
+    mxArray *retval = rep->as_mxArray ();
 
-    return new mxArray (new_rep, name);
+    if (retval)
+      retval->set_name (name);
+    else
+      {
+        mxArray_base *new_rep = rep->dup ();
+
+        retval = new mxArray (new_rep, name);
+      }
+
+    return retval;
   }
 
-  virtual ~mxArray (void);
+  ~mxArray (void);
 
-  virtual bool is_octave_value (void) const { return rep->is_octave_value (); }
+  bool is_octave_value (void) const { return rep->is_octave_value (); }
 
-  virtual int is_cell (void) const { return rep->is_cell (); }
+  int is_cell (void) const { return rep->is_cell (); }
 
-  virtual int is_char (void) const { return rep->is_char (); }
+  int is_char (void) const { return rep->is_char (); }
 
-  virtual int is_class (const char *name_arg) const { return rep->is_class (name_arg); }
+  int is_class (const char *name_arg) const { return rep->is_class (name_arg); }
 
-  virtual int is_complex (void) const { return rep->is_complex (); }
+  int is_complex (void) const { return rep->is_complex (); }
 
-  virtual int is_double (void) const { return rep->is_double (); }
+  int is_double (void) const { return rep->is_double (); }
 
-  virtual int is_function_handle (void) const { return rep->is_function_handle (); }
+  int is_function_handle (void) const { return rep->is_function_handle (); }
 
-  virtual int is_int16 (void) const { return rep->is_int16 (); }
+  int is_int16 (void) const { return rep->is_int16 (); }
 
-  virtual int is_int32 (void) const { return rep->is_int32 (); }
+  int is_int32 (void) const { return rep->is_int32 (); }
 
-  virtual int is_int64 (void) const { return rep->is_int64 (); }
+  int is_int64 (void) const { return rep->is_int64 (); }
 
-  virtual int is_int8 (void) const { return rep->is_int8 (); }
+  int is_int8 (void) const { return rep->is_int8 (); }
 
-  virtual int is_logical (void) const { return rep->is_logical (); }
+  int is_logical (void) const { return rep->is_logical (); }
 
-  virtual int is_numeric (void) const { return rep->is_numeric (); }
+  int is_numeric (void) const { return rep->is_numeric (); }
 
-  virtual int is_single (void) const { return rep->is_single (); }
+  int is_single (void) const { return rep->is_single (); }
 
-  virtual int is_sparse (void) const { return rep->is_sparse (); }
+  int is_sparse (void) const { return rep->is_sparse (); }
 
-  virtual int is_struct (void) const { return rep->is_struct (); }
+  int is_struct (void) const { return rep->is_struct (); }
 
-  virtual int is_uint16 (void) const { return rep->is_uint16 (); }
+  int is_uint16 (void) const { return rep->is_uint16 (); }
 
-  virtual int is_uint32 (void) const { return rep->is_uint32 (); }
+  int is_uint32 (void) const { return rep->is_uint32 (); }
 
-  virtual int is_uint64 (void) const { return rep->is_uint64 (); }
+  int is_uint64 (void) const { return rep->is_uint64 (); }
 
-  virtual int is_uint8 (void) const { return rep->is_uint8 (); }
+  int is_uint8 (void) const { return rep->is_uint8 (); }
 
-  virtual int is_logical_scalar (void) const { return rep->is_logical_scalar (); }
+  int is_logical_scalar (void) const { return rep->is_logical_scalar (); }
 
-  virtual int is_logical_scalar_true (void) const { return rep->is_logical_scalar_true (); }
+  int is_logical_scalar_true (void) const { return rep->is_logical_scalar_true (); }
 
-  virtual mwSize get_m (void) const { return rep->get_m (); }
+  mwSize get_m (void) const { return rep->get_m (); }
 
-  virtual mwSize get_n (void) const { return rep->get_n (); }
+  mwSize get_n (void) const { return rep->get_n (); }
 
-  virtual mwSize *get_dimensions (void) const { return rep->get_dimensions (); }
+  mwSize *get_dimensions (void) const { return rep->get_dimensions (); }
 
-  virtual mwSize get_number_of_dimensions (void) const { return rep->get_number_of_dimensions (); }
+  mwSize get_number_of_dimensions (void) const { return rep->get_number_of_dimensions (); }
 
-  virtual void set_m (mwSize m) { DO_VOID_MUTABLE_METHOD (set_m (m)); }
+  void set_m (mwSize m) { DO_VOID_MUTABLE_METHOD (set_m (m)); }
 
-  virtual void set_n (mwSize n) { DO_VOID_MUTABLE_METHOD (set_n (n)); }
+  void set_n (mwSize n) { DO_VOID_MUTABLE_METHOD (set_n (n)); }
 
-  virtual void set_dimensions (mwSize *dims_arg, mwSize ndims_arg) { DO_VOID_MUTABLE_METHOD (set_dimensions (dims_arg, ndims_arg)); }
+  void set_dimensions (mwSize *dims_arg, mwSize ndims_arg) { DO_VOID_MUTABLE_METHOD (set_dimensions (dims_arg, ndims_arg)); }
 
-  virtual mwSize get_number_of_elements (void) const { return rep->get_number_of_elements (); }
+  mwSize get_number_of_elements (void) const { return rep->get_number_of_elements (); }
 
-  virtual int is_empty (void) const { return get_number_of_elements () == 0; }
+  int is_empty (void) const { return get_number_of_elements () == 0; }
 
   const char *get_name (void) const { return name; }
 
   void set_name (const char *name_arg);
 
-  virtual mxClassID get_class_id (void) const { return rep->get_class_id (); }
+  mxClassID get_class_id (void) const { return rep->get_class_id (); }
 
-  virtual const char *get_class_name (void) const { return rep->get_class_name (); }
+  const char *get_class_name (void) const { return rep->get_class_name (); }
 
-  virtual void set_class_name (const char *name_arg) { DO_VOID_MUTABLE_METHOD (set_class_name (name_arg)); }
+  void set_class_name (const char *name_arg) { DO_VOID_MUTABLE_METHOD (set_class_name (name_arg)); }
 
-  virtual mxArray *get_cell (mwIndex idx) const { DO_MUTABLE_METHOD (mxArray *, get_cell (idx)); }
+  mxArray *get_cell (mwIndex idx) const { DO_MUTABLE_METHOD (mxArray *, get_cell (idx)); }
 
-  virtual void set_cell (mwIndex idx, mxArray *val) { DO_VOID_MUTABLE_METHOD (set_cell (idx, val)); }
+  void set_cell (mwIndex idx, mxArray *val) { DO_VOID_MUTABLE_METHOD (set_cell (idx, val)); }
 
-  virtual double get_scalar (void) const { return rep->get_scalar (); }
+  double get_scalar (void) const { return rep->get_scalar (); }
 
-  virtual void *get_data (void) const { DO_MUTABLE_METHOD (void *, get_data ()); }
+  void *get_data (void) const { DO_MUTABLE_METHOD (void *, get_data ()); }
 
-  virtual void *get_imag_data (void) const { DO_MUTABLE_METHOD (void *, get_imag_data ()); }
+  void *get_imag_data (void) const { DO_MUTABLE_METHOD (void *, get_imag_data ()); }
 
-  virtual void set_data (void *pr) { DO_VOID_MUTABLE_METHOD (set_data (pr)); }
+  void set_data (void *pr) { DO_VOID_MUTABLE_METHOD (set_data (pr)); }
 
-  virtual void set_imag_data (void *pi) { DO_VOID_MUTABLE_METHOD (set_imag_data (pi)); }
+  void set_imag_data (void *pi) { DO_VOID_MUTABLE_METHOD (set_imag_data (pi)); }
 
-  virtual mwIndex *get_ir (void) const { DO_MUTABLE_METHOD (mwIndex *, get_ir ()); }
+  mwIndex *get_ir (void) const { DO_MUTABLE_METHOD (mwIndex *, get_ir ()); }
 
-  virtual mwIndex *get_jc (void) const { DO_MUTABLE_METHOD (mwIndex *, get_jc ()); }
+  mwIndex *get_jc (void) const { DO_MUTABLE_METHOD (mwIndex *, get_jc ()); }
 
-  virtual mwSize get_nzmax (void) const { return rep->get_nzmax (); }
+  mwSize get_nzmax (void) const { return rep->get_nzmax (); }
 
-  virtual void set_ir (mwIndex *ir) { DO_VOID_MUTABLE_METHOD (set_ir (ir)); }
+  void set_ir (mwIndex *ir) { DO_VOID_MUTABLE_METHOD (set_ir (ir)); }
 
-  virtual void set_jc (mwIndex *jc) { DO_VOID_MUTABLE_METHOD (set_jc (jc)); }
+  void set_jc (mwIndex *jc) { DO_VOID_MUTABLE_METHOD (set_jc (jc)); }
 
-  virtual void set_nzmax (mwSize nzmax) { DO_VOID_MUTABLE_METHOD (set_nzmax (nzmax)); }
+  void set_nzmax (mwSize nzmax) { DO_VOID_MUTABLE_METHOD (set_nzmax (nzmax)); }
 
-  virtual int add_field (const char *key) { DO_MUTABLE_METHOD (int, add_field (key)); }
+  int add_field (const char *key) { DO_MUTABLE_METHOD (int, add_field (key)); }
 
-  virtual void remove_field (int key_num) { DO_VOID_MUTABLE_METHOD (remove_field (key_num)); }
+  void remove_field (int key_num) { DO_VOID_MUTABLE_METHOD (remove_field (key_num)); }
 
-  virtual mxArray *get_field_by_number (mwIndex index, int key_num) const { DO_MUTABLE_METHOD (mxArray *, get_field_by_number (index, key_num)); }
+  mxArray *get_field_by_number (mwIndex index, int key_num) const { DO_MUTABLE_METHOD (mxArray *, get_field_by_number (index, key_num)); }
 
-  virtual void set_field_by_number (mwIndex index, int key_num, mxArray *val) { DO_VOID_MUTABLE_METHOD (set_field_by_number (index, key_num, val)); }
+  void set_field_by_number (mwIndex index, int key_num, mxArray *val) { DO_VOID_MUTABLE_METHOD (set_field_by_number (index, key_num, val)); }
 
-  virtual int get_number_of_fields (void) const { return rep->get_number_of_fields (); }
+  int get_number_of_fields (void) const { return rep->get_number_of_fields (); }
 
-  virtual const char *get_field_name_by_number (int key_num) const { DO_MUTABLE_METHOD (const char*, get_field_name_by_number (key_num)); }
+  const char *get_field_name_by_number (int key_num) const { DO_MUTABLE_METHOD (const char*, get_field_name_by_number (key_num)); }
 
-  virtual int get_field_number (const char *key) const { DO_MUTABLE_METHOD (int, get_field_number (key)); }
+  int get_field_number (const char *key) const { DO_MUTABLE_METHOD (int, get_field_number (key)); }
 
-  virtual int get_string (char *buf, mwSize buflen) const { return rep->get_string (buf, buflen); }
+  int get_string (char *buf, mwSize buflen) const { return rep->get_string (buf, buflen); }
 
-  virtual char *array_to_string (void) const { return rep->array_to_string (); }
+  char *array_to_string (void) const { return rep->array_to_string (); }
 
-  virtual mwIndex calc_single_subscript (mwSize nsubs, mwIndex *subs) const { return rep->calc_single_subscript (nsubs, subs); }
+  mwIndex calc_single_subscript (mwSize nsubs, mwIndex *subs) const { return rep->calc_single_subscript (nsubs, subs); }
 
-  virtual size_t get_element_size (void) const { return rep->get_element_size (); }
+  size_t get_element_size (void) const { return rep->get_element_size (); }
 
-  virtual bool mutation_needed (void) const { return rep->mutation_needed (); }
+  bool mutation_needed (void) const { return rep->mutation_needed (); }
 
-  virtual mxArray *mutate (void) const { return rep->mutate (); }
+  mxArray *mutate (void) const { return rep->mutate (); }
 
   static void *malloc (size_t n);
 
   static void *calloc (size_t n, size_t t);
 
   static char *strsave (const char *str)
   {
     char *retval = 0;
@@ -310,32 +481,30 @@ public:
         mwSize sz =  sizeof (mxChar) * (strlen (str) + 1);
         retval = static_cast<char *> (mxArray::malloc (sz));
         strcpy (retval, str);
       }
 
     return retval;
   }
 
-  static octave_value as_octave_value (mxArray *ptr);
+  static octave_value as_octave_value (const mxArray *ptr);
 
 protected:
 
-  virtual octave_value as_octave_value (void) const;
-
-  mxArray (const xmxArray&) : rep (0), name (0) { }
+  octave_value as_octave_value (void) const;
 
 private:
 
-  mutable mxArray *rep;
+  mutable mxArray_base *rep;
 
   char *name;
 
-  mxArray (mxArray *r, const char *n)
-    : rep (r), name (strsave (n)) { }
+  mxArray (mxArray_base *r, const char *n)
+    : rep (r), name (mxArray::strsave (n)) { }
 
   void maybe_mutate (void) const;
 
   // No copying!
 
   mxArray (const mxArray&);
 
   mxArray& operator = (const mxArray&);
diff --git a/libinterp/interp-core/oct-obj.h b/libinterp/interp-core/oct-obj.h
--- a/libinterp/interp-core/oct-obj.h
+++ b/libinterp/interp-core/oct-obj.h
@@ -161,9 +161,157 @@ private:
     }
 
   const octave_value& elem (octave_idx_type n) const
     { return data(n); }
 
   DECLARE_OCTAVE_ALLOCATOR
 };
 
+// Make it easy to build argument lists for built-in functions or for
+// returning values.
+
+inline octave_value_list
+ovl (const octave_value& a0)
+{
+  octave_value_list retval;
+  retval(0) = a0;
+  return retval;
+}
+
+inline octave_value_list
+ovl (const octave_value& a0, const octave_value& a1)
+{
+  octave_value_list retval;
+  retval(1) = a1;
+  retval(0) = a0;
+  return retval;
+}
+
+inline octave_value_list
+ovl (const octave_value& a0, const octave_value& a1,
+     const octave_value& a2)
+{
+  octave_value_list retval;
+  retval(2) = a2;
+  retval(1) = a1;
+  retval(0) = a0;
+  return retval;
+}
+
+inline octave_value_list
+ovl (const octave_value& a0, const octave_value& a1,
+     const octave_value& a2, const octave_value& a3)
+{
+  octave_value_list retval;
+  retval(3) = a3;
+  retval(2) = a2;
+  retval(1) = a1;
+  retval(0) = a0;
+  return retval;
+}
+
+inline octave_value_list
+ovl (const octave_value& a0, const octave_value& a1,
+     const octave_value& a2, const octave_value& a3,
+     const octave_value& a4)
+{
+  octave_value_list retval;
+  retval(4) = a4;
+  retval(3) = a3;
+  retval(2) = a2;
+  retval(1) = a1;
+  retval(0) = a0;
+  return retval;
+}
+
+inline octave_value_list
+ovl (const octave_value& a0, const octave_value& a1,
+     const octave_value& a2, const octave_value& a3,
+     const octave_value& a4, const octave_value& a5)
+{
+  octave_value_list retval;
+  retval(5) = a5;
+  retval(4) = a4;
+  retval(3) = a3;
+  retval(2) = a2;
+  retval(1) = a1;
+  retval(0) = a0;
+  return retval;
+}
+
+inline octave_value_list
+ovl (const octave_value& a0, const octave_value& a1,
+     const octave_value& a2, const octave_value& a3,
+     const octave_value& a4, const octave_value& a5,
+     const octave_value& a6)
+{
+  octave_value_list retval;
+  retval(6) = a6;
+  retval(5) = a5;
+  retval(4) = a4;
+  retval(3) = a3;
+  retval(2) = a2;
+  retval(1) = a1;
+  retval(0) = a0;
+  return retval;
+}
+
+inline octave_value_list
+ovl (const octave_value& a0, const octave_value& a1,
+     const octave_value& a2, const octave_value& a3,
+     const octave_value& a4, const octave_value& a5,
+     const octave_value& a6, const octave_value& a7)
+{
+  octave_value_list retval;
+  retval(7) = a7;
+  retval(6) = a6;
+  retval(5) = a5;
+  retval(4) = a4;
+  retval(3) = a3;
+  retval(2) = a2;
+  retval(1) = a1;
+  retval(0) = a0;
+  return retval;
+}
+
+inline octave_value_list
+ovl (const octave_value& a0, const octave_value& a1,
+     const octave_value& a2, const octave_value& a3,
+     const octave_value& a4, const octave_value& a5,
+     const octave_value& a6, const octave_value& a7,
+     const octave_value& a8)
+{
+  octave_value_list retval;
+  retval(8) = a8;
+  retval(7) = a7;
+  retval(6) = a6;
+  retval(5) = a5;
+  retval(4) = a4;
+  retval(3) = a3;
+  retval(2) = a2;
+  retval(1) = a1;
+  retval(0) = a0;
+  return retval;
+}
+
+inline octave_value_list
+ovl (const octave_value& a0, const octave_value& a1,
+     const octave_value& a2, const octave_value& a3,
+     const octave_value& a4, const octave_value& a5,
+     const octave_value& a6, const octave_value& a7,
+     const octave_value& a8, const octave_value& a9)
+{
+  octave_value_list retval;
+  retval(9) = a9;
+  retval(8) = a8;
+  retval(7) = a7;
+  retval(6) = a6;
+  retval(5) = a5;
+  retval(4) = a4;
+  retval(3) = a3;
+  retval(2) = a2;
+  retval(1) = a1;
+  retval(0) = a0;
+  return retval;
+}
+
 #endif
diff --git a/libinterp/interp-core/oct-stream.cc b/libinterp/interp-core/oct-stream.cc
--- a/libinterp/interp-core/oct-stream.cc
+++ b/libinterp/interp-core/oct-stream.cc
@@ -503,18 +503,18 @@ scanf_format_list::printme (void) const
         std::cerr << "literal text\n";
       else if (elt->type == scanf_format_elt::whitespace_conversion)
         std::cerr << "whitespace\n";
       else
         std::cerr << elt->type << "\n";
 
       std::cerr
         << "modifier:   " << elt->modifier << "\n"
-        << "char_class: `" << undo_string_escapes (elt->char_class) << "'\n"
-        << "text:       `" << undo_string_escapes (elt->text) << "'\n\n";
+        << "char_class: '" << undo_string_escapes (elt->char_class) << "'\n"
+        << "text:       '" << undo_string_escapes (elt->text) << "'\n\n";
     }
 }
 
 bool
 scanf_format_list::all_character_conversions (void)
 {
   octave_idx_type n = list.length ();
 
@@ -862,22 +862,22 @@ printf_format_list::printme (void) const
   int n = list.length ();
 
   for (int i = 0; i < n; i++)
     {
       printf_format_elt *elt = list(i);
 
       std::cerr
         << "args:     " << elt->args << "\n"
-        << "flags:    `" << elt->flags << "'\n"
+        << "flags:    '" << elt->flags << "'\n"
         << "width:    " << elt->fw << "\n"
         << "prec:     " << elt->prec << "\n"
-        << "type:     `" << elt->type << "'\n"
-        << "modifier: `" << elt->modifier << "'\n"
-        << "text:     `" << undo_string_escapes (elt->text) << "'\n\n";
+        << "type:     '" << elt->type << "'\n"
+        << "modifier: '" << elt->modifier << "'\n"
+        << "text:     '" << undo_string_escapes (elt->text) << "'\n\n";
     }
 }
 
 void
 octave_base_stream::error (const std::string& msg)
 {
   fail = true;
   errmsg = msg;
@@ -1382,17 +1382,17 @@ do_scanf_conv (std::istream&, const scan
   while (is && n < width && (c = is.get ()) != EOF) \
     tmp[n++] = static_cast<char> (c); \
  \
   if (n > 0 && c == EOF) \
     is.clear (); \
  \
   tmp.resize (n)
 
-// For a `%s' format, skip initial whitespace and then read until the
+// For a '%s' format, skip initial whitespace and then read until the
 // next whitespace character or until WIDTH characters have been read.
 #define BEGIN_S_CONVERSION() \
   int width = elt->width; \
  \
   std::string tmp; \
  \
   do \
     { \
@@ -2471,17 +2471,17 @@ octave_base_stream::do_printf (printf_fo
         return retval;
 
       for (;;)
         {
           octave_quit ();
 
           if (elt)
             {
-              // NSA is the number of `star' args to convert.
+              // NSA is the number of 'star' args to convert.
 
               int nsa = (elt->fw < 0) + (elt->prec < 0);
 
               int sa_1 = 0;
               int sa_2 = 0;
 
               if (nsa > 0)
                 {
diff --git a/libinterp/interp-core/oct-stream.h b/libinterp/interp-core/oct-stream.h
--- a/libinterp/interp-core/oct-stream.h
+++ b/libinterp/interp-core/oct-stream.h
@@ -82,24 +82,24 @@ public:
   const char *text;
 
   // The maximum field width.
   int width;
 
   // TRUE if we are not storing the result of this conversion.
   bool discard;
 
-  // Type of conversion -- `d', `i', `o', `u', `x', `e', `f', `g',
-  // `c', `s', `p', `%', or `['.
+  // Type of conversion -- 'd', 'i', 'o', 'u', 'x', 'e', 'f', 'g',
+  // 'c', 's', 'p', '%', or '['.
   char type;
 
-  // A length modifier -- `h', `l', or `L'.
+  // A length modifier -- 'h', 'l', or 'L'.
   char modifier;
 
-  // The class of characters in a `[' format.
+  // The class of characters in a '[' format.
   std::string char_class;
 };
 
 class
 OCTINTERP_API
 scanf_format_list
 {
 public:
@@ -224,24 +224,24 @@ public:
   int args;
 
   // Field width.
   int fw;
 
   // Precision.
   int prec;
 
-  // Flags -- `-', `+', ` ', `0', or `#'.
+  // Flags -- '-', '+', ' ', '0', or '#'.
   std::string flags;
 
-  // Type of conversion -- `d', `i', `o', `x', `X', `u', `c', `s',
-  // `f', `e', `E', `g', `G', `p', or `%'
+  // Type of conversion -- 'd', 'i', 'o', 'x', 'X', 'u', 'c', 's',
+  // 'f', 'e', 'E', 'g', 'G', 'p', or '%'
   char type;
 
-  // A length modifier -- `h', `l', or `L'.
+  // A length modifier -- 'h', 'l', or 'L'.
   char modifier;
 };
 
 class
 OCTINTERP_API
 printf_format_list
 {
 public:
diff --git a/libinterp/interp-core/oct.h b/libinterp/interp-core/oct.h
--- a/libinterp/interp-core/oct.h
+++ b/libinterp/interp-core/oct.h
@@ -23,17 +23,17 @@ along with Octave; see the file COPYING.
 #if !defined (octave_oct_h)
 #define octave_oct_h 1
 
 // Things that are often included to create .oct files.
 
 // config.h needs to be first because it includes #defines that can */
 // affect other header files.
 
-#include "config.h"
+#include <config.h>
 
 #include "Matrix.h"
 
 #include "oct-locbuf.h"
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
diff --git a/libinterp/interp-core/pt-jit.cc b/libinterp/interp-core/pt-jit.cc
--- a/libinterp/interp-core/pt-jit.cc
+++ b/libinterp/interp-core/pt-jit.cc
@@ -22,78 +22,160 @@ along with Octave; see the file COPYING.
 
 #define __STDC_LIMIT_MACROS
 #define __STDC_CONSTANT_MACROS
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#ifdef HAVE_LLVM
+#include "defun.h"
+#include "ov.h"
+#include "pt-all.h"
+#include "pt-jit.h"
+#include "symtab.h"
+#include "variables.h"
 
-#include "pt-jit.h"
+bool Venable_jit_debugging = false;
+
+bool Venable_jit_compiler = true;
+
+#ifdef HAVE_LLVM
 
 #include <llvm/Analysis/CallGraph.h>
 #include <llvm/Analysis/Passes.h>
 #include <llvm/Analysis/Verifier.h>
+#include <llvm/Bitcode/ReaderWriter.h>
 #include <llvm/LLVMContext.h>
 #include <llvm/ExecutionEngine/ExecutionEngine.h>
 #include <llvm/ExecutionEngine/JIT.h>
 #include <llvm/Module.h>
 #include <llvm/PassManager.h>
 #include <llvm/Support/IRBuilder.h>
 #include <llvm/Support/raw_os_ostream.h>
 #include <llvm/Support/TargetSelect.h>
 #include <llvm/Target/TargetData.h>
 #include <llvm/Transforms/IPO.h>
 #include <llvm/Transforms/Scalar.h>
 
-#ifdef OCTAVE_JIT_DEBUG
-#include <llvm/Bitcode/ReaderWriter.h>
-#endif
-
-#include "symtab.h"
-#include "pt-all.h"
-
 static llvm::IRBuilder<> builder (llvm::getGlobalContext ());
 
 static llvm::LLVMContext& context = llvm::getGlobalContext ();
 
 // -------------------- jit_convert --------------------
 jit_convert::jit_convert (tree &tee, jit_type *for_bounds)
-  : iterator_count (0), for_bounds_count (0), short_count (0), breaking (false)
+  : converting_function (false)
 {
-  jit_instruction::reset_ids ();
-
-  entry_block = factory.create<jit_block> ("body");
-  final_block = factory.create<jit_block> ("final");
-  blocks.push_back (entry_block);
-  entry_block->mark_alive ();
-  block = entry_block;
+  initialize (symbol_table::current_scope ());
 
   if (for_bounds)
     create_variable (next_for_bounds (false), for_bounds);
 
   visit (tee);
 
-  // FIXME: Remove if we no longer only compile loops
+  // breaks must have been handled by the top level loop
   assert (! breaking);
   assert (breaks.empty ());
   assert (continues.empty ());
 
   block->append (factory.create<jit_branch> (final_block));
   blocks.push_back (final_block);
 
   for (variable_map::iterator iter = vmap.begin (); iter != vmap.end (); ++iter)
     {
       jit_variable *var = iter->second;
       const std::string& name = var->name ();
       if (name.size () && name[0] != '#')
         final_block->append (factory.create<jit_store_argument> (var));
     }
+
+  final_block->append (factory.create<jit_return> ());
+}
+
+jit_convert::jit_convert (octave_user_function& fcn,
+                          const std::vector<jit_type *>& args)
+  : converting_function (true)
+{
+  initialize (fcn.scope ());
+
+  tree_parameter_list *plist = fcn.parameter_list ();
+  tree_parameter_list *rlist = fcn.return_list ();
+  if (plist && plist->takes_varargs ())
+    throw jit_fail_exception ("varags not supported");
+
+  if (rlist && (rlist->size () > 1 || rlist->takes_varargs ()))
+    throw jit_fail_exception ("multiple returns not supported");
+
+  if (plist)
+    {
+      tree_parameter_list::iterator piter = plist->begin ();
+      for (size_t i = 0; i < args.size (); ++i, ++piter)
+        {
+          if (piter == plist->end ())
+            throw jit_fail_exception ("Too many parameter to function");
+
+          tree_decl_elt *elt = *piter;
+          std::string name = elt->name ();
+          create_variable (name, args[i]);
+        }
+    }
+
+  jit_value *return_value = 0;
+  if (fcn.is_special_expr ())
+    {
+      tree_expression *expr = fcn.special_expr ();
+      if (expr)
+        {
+          jit_variable *retvar = get_variable ("#return");
+          jit_value *retval = visit (expr);
+          block->append (factory.create<jit_assign> (retvar, retval));
+          return_value = retvar;
+        }
+    }
+  else
+    visit_statement_list (*fcn.body ());
+
+  // the user may use break or continue to exit the function. Because the
+  // function does not start as a loop, we can have one continue, one break, or
+  // a regular fallthrough to exit the function
+  if (continues.size ())
+    {
+      assert (! continues.size ());
+      finish_breaks (final_block, continues);
+    }
+  else if (breaks.size ())
+    finish_breaks (final_block, breaks);
+  else
+    block->append (factory.create<jit_branch> (final_block));
+  blocks.push_back (final_block);
+  block = final_block;
+
+  if (! return_value && rlist && rlist->size () == 1)
+    {
+      tree_decl_elt *elt = rlist->front ();
+      return_value = get_variable (elt->name ());
+    }
+
+  // FIXME: We should use live range analysis to delete variables where needed.
+  // For now we just delete everything at the end of the function.
+  for (variable_map::iterator iter = vmap.begin (); iter != vmap.end (); ++iter)
+    {
+      if (iter->second != return_value)
+        {
+          jit_call *call;
+          call = factory.create<jit_call> (&jit_typeinfo::destroy,
+                                           iter->second);
+          final_block->append (call);
+        }
+    }
+
+  if (return_value)
+    final_block->append (factory.create<jit_return> (return_value));
+  else
+    final_block->append (factory.create<jit_return> ());
 }
 
 void
 jit_convert::visit_anon_fcn_handle (tree_anon_fcn_handle&)
 {
   throw jit_fail_exception ();
 }
 
@@ -238,34 +320,34 @@ jit_convert::visit_simple_for_command (t
 
   // we need a variable for our iterator, because it is used in multiple blocks
   std::string iter_name = next_iterator ();
   jit_variable *iterator = factory.create<jit_variable> (iter_name);
   factory.create<jit_variable> (iter_name);
   vmap[iter_name] = iterator;
 
   jit_block *body = factory.create<jit_block> ("for_body");
-  blocks.push_back (body);
-
   jit_block *tail = factory.create<jit_block> ("for_tail");
 
   // do control expression, iter init, and condition check in prev_block (block)
   // if we are the top level for loop, the bounds is an input argument.
   jit_value *control = find_variable (next_for_bounds ());
   if (! control)
     control = visit (cmd.control_expr ());
   jit_call *init_iter = factory.create<jit_call> (jit_typeinfo::for_init,
                                                   control);
   block->append (init_iter);
   block->append (factory.create<jit_assign> (iterator, init_iter));
 
   jit_call *check = factory.create<jit_call> (jit_typeinfo::for_check, control,
                                               iterator);
   block->append (check);
   block->append (factory.create<jit_cond_branch> (check, body, tail));
+
+  blocks.push_back (body);
   block = body;
 
   // compute the syntactical iterator
   jit_call *idx_rhs = factory.create<jit_call> (jit_typeinfo::for_index,
                                                 control, iterator);
   block->append (idx_rhs);
   do_assign (cmd.left_hand_side (), idx_rhs);
 
@@ -348,17 +430,22 @@ jit_convert::visit_identifier (tree_iden
 {
   if (ti.has_magic_end ())
     {
       if (!end_context.size ())
         throw jit_fail_exception ("Illegal end");
       result = block->append (factory.create<jit_magic_end> (end_context));
     }
   else
-    result = get_variable (ti.name ());
+    {
+      jit_variable *var = get_variable (ti.name ());
+      jit_instruction *instr;
+      instr = factory.create<jit_call> (&jit_typeinfo::grab, var);
+      result = block->append (instr);
+    }
 }
 
 void
 jit_convert::visit_if_clause (tree_if_clause&)
 {
   throw jit_fail_exception ();
 }
 
@@ -447,17 +534,17 @@ jit_convert::visit_if_command_list (tree
   else
     // every branch broke, so we don't have a tail
     breaking = true;
 }
 
 void
 jit_convert::visit_index_expression (tree_index_expression& exp)
 {
-  result = resolve (jit_typeinfo::paren_subsref (), exp);
+  result = resolve (exp);
 }
 
 void
 jit_convert::visit_matrix (tree_matrix&)
 {
   throw jit_fail_exception ();
 }
 
@@ -478,17 +565,17 @@ jit_convert::visit_no_op_command (tree_n
 {
   throw jit_fail_exception ();
 }
 
 void
 jit_convert::visit_constant (tree_constant& tc)
 {
   octave_value v = tc.rvalue1 ();
-  if (v.is_real_scalar () && v.is_double_type ())
+  if (v.is_real_scalar () && v.is_double_type () && ! v.is_complex_type ())
     {
       double dv = v.double_value ();
       result = factory.create<jit_const_scalar> (dv);
     }
   else if (v.is_range ())
     {
       Range rv = v.range_value ();
       result = factory.create<jit_const_range> (rv);
@@ -521,17 +608,17 @@ jit_convert::visit_postfix_expression (t
   tree_expression *operand = tpe.operand ();
   jit_value *operandv = visit (operand);
 
   const jit_operation& fn = jit_typeinfo::unary_op (etype);
   result = create_checked (fn, operandv);
 
   if (etype == octave_value::op_incr || etype == octave_value::op_decr)
     {
-      jit_value *ret = create_checked (&jit_typeinfo::copy, operandv);
+      jit_value *ret = create_checked (&jit_typeinfo::grab, operandv);
       do_assign (operand, result);
       result = ret;
     }
 }
 
 void
 jit_convert::visit_prefix_expression (tree_prefix_expression& tpe)
 {
@@ -703,16 +790,33 @@ jit_convert::visit_while_command (tree_w
 }
 
 void
 jit_convert::visit_do_until_command (tree_do_until_command&)
 {
   throw jit_fail_exception ();
 }
 
+void
+jit_convert::initialize (symbol_table::scope_id s)
+{
+  scope = s;
+  iterator_count = 0;
+  for_bounds_count = 0;
+  short_count = 0;
+  breaking = false;
+  jit_instruction::reset_ids ();
+
+  entry_block = factory.create<jit_block> ("body");
+  final_block = factory.create<jit_block> ("final");
+  blocks.push_back (entry_block);
+  entry_block->mark_alive ();
+  block = entry_block;
+}
+
 jit_call *
 jit_convert::create_checked_impl (jit_call *ret)
 {
   block->append (ret);
 
   jit_block *normal = factory.create<jit_block> (block->name ());
   jit_error_check *check = factory.create<jit_error_check> (ret, normal,
                                                             final_block);
@@ -733,62 +837,96 @@ jit_convert::find_variable (const std::s
 
 jit_variable *
 jit_convert::get_variable (const std::string& vname)
 {
   jit_variable *ret = find_variable (vname);
   if (ret)
     return ret;
 
-  octave_value val = symbol_table::find (vname);
-  jit_type *type = jit_typeinfo::type_of (val);
-  return create_variable (vname, type);
+  symbol_table::symbol_record record = symbol_table::find_symbol (vname, scope);
+  if (record.is_persistent () || record.is_global ())
+    throw jit_fail_exception ("Persistent and global not yet supported");
+
+  if (converting_function)
+    return create_variable (vname, jit_typeinfo::get_any (), false);
+  else
+    {
+      octave_value val = record.varval ();
+      jit_type *type = jit_typeinfo::type_of (val);
+      bounds.push_back (type_bound (type, vname));
+
+      return create_variable (vname, type);
+    }
 }
 
 jit_variable *
-jit_convert::create_variable (const std::string& vname, jit_type *type)
+jit_convert::create_variable (const std::string& vname, jit_type *type,
+                              bool isarg)
 {
   jit_variable *var = factory.create<jit_variable> (vname);
-  jit_extract_argument *extract;
-  extract = factory.create<jit_extract_argument> (type, var);
-  entry_block->prepend (extract);
+
+  if (isarg)
+    {
+      jit_extract_argument *extract;
+      extract = factory.create<jit_extract_argument> (type, var);
+      entry_block->prepend (extract);
+    }
+  else
+    {
+      jit_call *init = factory.create<jit_call> (&jit_typeinfo::create_undef);
+      jit_assign *assign = factory.create<jit_assign> (var, init);
+      entry_block->prepend (assign);
+      entry_block->prepend (init);
+    }
+
   return vmap[vname] = var;
 }
 
 std::string
 jit_convert::next_name (const char *prefix, size_t& count, bool inc)
 {
   std::stringstream ss;
   ss << prefix << count;
   if (inc)
     ++count;
   return ss.str ();
 }
 
 jit_instruction *
-jit_convert::resolve (const jit_operation& fres, tree_index_expression& exp,
-                      jit_value *extra_arg)
+jit_convert::resolve (tree_index_expression& exp, jit_value *extra_arg,
+                      bool lhs)
 {
   std::string type = exp.type_tags ();
   if (! (type.size () == 1 && type[0] == '('))
     throw jit_fail_exception ("Unsupported index operation");
 
   std::list<tree_argument_list *> args = exp.arg_lists ();
   if (args.size () != 1)
-    throw jit_fail_exception ("Bad number of arguments in tree_index_expression");
+    throw jit_fail_exception ("Bad number of arguments in "
+                              "tree_index_expression");
 
   tree_argument_list *arg_list = args.front ();
   if (! arg_list)
     throw jit_fail_exception ("null argument list");
 
   if (arg_list->size () < 1)
     throw jit_fail_exception ("Empty arg_list");
 
   tree_expression *tree_object = exp.expression ();
-  jit_value *object = visit (tree_object);
+  jit_value *object;
+  if (lhs)
+    {
+      tree_identifier *id = dynamic_cast<tree_identifier *> (tree_object);
+      if (! id)
+        throw jit_fail_exception ("expected identifier");
+      object = get_variable (id->name ());
+    }
+  else
+    object = visit (tree_object);
 
   size_t narg = arg_list->size ();
   tree_argument_list::iterator iter = arg_list->begin ();
   bool have_extra = extra_arg;
   std::vector<jit_value *> call_args (narg + 1 + have_extra);
   call_args[0] = object;
 
   for (size_t idx = 0; iter != arg_list->end (); ++idx, ++iter)
@@ -800,32 +938,34 @@ jit_convert::resolve (const jit_operatio
       jit_magic_end::context ctx (factory, object, idx, narg);
       end_context.push_back (ctx);
       call_args[idx + 1] = visit (*iter);
     }
 
   if (extra_arg)
     call_args[call_args.size () - 1] = extra_arg;
 
+  const jit_operation& fres = lhs ? jit_typeinfo::paren_subsasgn ()
+    : jit_typeinfo::paren_subsref ();
+
   return create_checked (fres, call_args);
 }
 
 jit_value *
 jit_convert::do_assign (tree_expression *exp, jit_value *rhs, bool artificial)
 {
   if (! exp)
     throw jit_fail_exception ("NULL lhs in assign");
 
   if (isa<tree_identifier> (exp))
     return do_assign (exp->name (), rhs, exp->print_result (), artificial);
   else if (tree_index_expression *idx
            = dynamic_cast<tree_index_expression *> (exp))
     {
-      jit_value *new_object = resolve (jit_typeinfo::paren_subsasgn (), *idx,
-                                       rhs);
+      jit_value *new_object = resolve (*idx, rhs, true);
       do_assign (idx->expression (), new_object, true);
 
       // FIXME: Will not work for values that must be release/grabed
       return rhs;
     }
   else
     throw jit_fail_exception ("Unsupported assignment");
 }
@@ -868,20 +1008,22 @@ jit_convert::finish_breaks (jit_block *d
     {
       jit_block *b = *iter;
       b->append (factory.create<jit_branch> (dest));
     }
 }
 
 // -------------------- jit_convert_llvm --------------------
 llvm::Function *
-jit_convert_llvm::convert (llvm::Module *module,
-                           const jit_block_list& blocks,
-                           const std::list<jit_value *>& constants)
+jit_convert_llvm::convert_loop (llvm::Module *module,
+                                const jit_block_list& blocks,
+                                const std::list<jit_value *>& constants)
 {
+  converting_function = false;
+
   // for now just init arguments from entry, later we will have to do something
   // more interesting
   jit_block *entry_block = blocks.front ();
   for (jit_block::iterator iter = entry_block->begin ();
        iter != entry_block->end (); ++iter)
     if (jit_extract_argument *extract
         = dynamic_cast<jit_extract_argument *> (*iter))
       argument_vec.push_back (std::make_pair (extract->name (), true));
@@ -904,63 +1046,112 @@ jit_convert_llvm::convert (llvm::Module 
 
       llvm::Value *arg = function->arg_begin ();
       for (size_t i = 0; i < argument_vec.size (); ++i)
         {
           llvm::Value *loaded_arg = builder.CreateConstInBoundsGEP1_32 (arg, i);
           arguments[argument_vec[i].first] = loaded_arg;
         }
 
-      std::list<jit_block *>::const_iterator biter;
-      for (biter = blocks.begin (); biter != blocks.end (); ++biter)
-        {
-          jit_block *jblock = *biter;
-          llvm::BasicBlock *block = llvm::BasicBlock::Create (context,
-                                                              jblock->name (),
-                                                              function);
-          jblock->stash_llvm (block);
-        }
-
-      jit_block *first = *blocks.begin ();
-      builder.CreateBr (first->to_llvm ());
-
-      // constants aren't in the IR, we visit those first
-      for (std::list<jit_value *>::const_iterator iter = constants.begin ();
-           iter != constants.end (); ++iter)
-        if (! isa<jit_instruction> (*iter))
-          visit (*iter);
-
-      // convert all instructions
-      for (biter = blocks.begin (); biter != blocks.end (); ++biter)
-        visit (*biter);
-
-      // now finish phi nodes
-      for (biter = blocks.begin (); biter != blocks.end (); ++biter)
-        {
-          jit_block& block = **biter;
-          for (jit_block::iterator piter = block.begin ();
-               piter != block.end () && isa<jit_phi> (*piter); ++piter)
-            {
-              jit_instruction *phi = *piter;
-              finish_phi (static_cast<jit_phi *> (phi));
-            }
-        }
-
-      jit_block *last = blocks.back ();
-      builder.SetInsertPoint (last->to_llvm ());
-      builder.CreateRetVoid ();
+      convert (blocks, constants);
     } catch (const jit_fail_exception& e)
     {
       function->eraseFromParent ();
       throw;
     }
 
   return function;
 }
 
+
+jit_function
+jit_convert_llvm::convert_function (llvm::Module *module,
+                                    const jit_block_list& blocks,
+                                    const std::list<jit_value *>& constants,
+                                    octave_user_function& fcn,
+                                    const std::vector<jit_type *>& args)
+{
+  converting_function = true;
+
+  jit_block *final_block = blocks.back ();
+  jit_return *ret = dynamic_cast<jit_return *> (final_block->back ());
+  assert (ret);
+
+  creating = jit_function (module, jit_convention::internal,
+                           "foobar", ret->result_type (), args);
+  function = creating.to_llvm ();
+
+  try
+    {
+      prelude = creating.new_block ("prelude");
+      builder.SetInsertPoint (prelude);
+
+      tree_parameter_list *plist = fcn.parameter_list ();
+      if (plist)
+        {
+          tree_parameter_list::iterator piter = plist->begin ();
+          tree_parameter_list::iterator pend = plist->end ();
+          for (size_t i = 0; i < args.size () && piter != pend; ++i, ++piter)
+            {
+              tree_decl_elt *elt = *piter;
+              std::string arg_name = elt->name ();
+              arguments[arg_name] = creating.argument (builder, i);
+            }
+        }
+
+      convert (blocks, constants);
+    } catch (const jit_fail_exception& e)
+    {
+      function->eraseFromParent ();
+      throw;
+    }
+
+  return creating;
+}
+
+void
+jit_convert_llvm::convert (const jit_block_list& blocks,
+                           const std::list<jit_value *>& constants)
+{
+  std::list<jit_block *>::const_iterator biter;
+  for (biter = blocks.begin (); biter != blocks.end (); ++biter)
+    {
+      jit_block *jblock = *biter;
+      llvm::BasicBlock *block = llvm::BasicBlock::Create (context,
+                                                          jblock->name (),
+                                                          function);
+      jblock->stash_llvm (block);
+    }
+
+  jit_block *first = *blocks.begin ();
+  builder.CreateBr (first->to_llvm ());
+
+  // constants aren't in the IR, we visit those first
+  for (std::list<jit_value *>::const_iterator iter = constants.begin ();
+       iter != constants.end (); ++iter)
+    if (! isa<jit_instruction> (*iter))
+      visit (*iter);
+
+  // convert all instructions
+  for (biter = blocks.begin (); biter != blocks.end (); ++biter)
+    visit (*biter);
+
+  // now finish phi nodes
+  for (biter = blocks.begin (); biter != blocks.end (); ++biter)
+    {
+      jit_block& block = **biter;
+      for (jit_block::iterator piter = block.begin ();
+           piter != block.end () && isa<jit_phi> (*piter); ++piter)
+        {
+          jit_instruction *phi = *piter;
+          finish_phi (static_cast<jit_phi *> (phi));
+        }
+    }
+}
+
 void
 jit_convert_llvm::finish_phi (jit_phi *phi)
 {
   llvm::PHINode *llvm_phi = phi->to_llvm ();
   for (size_t i = 0; i < phi->argument_count (); ++i)
     {
       llvm::BasicBlock *pred = phi->incomming_llvm (i);
       llvm_phi->addIncoming (phi->argument_llvm (i), pred);
@@ -1059,32 +1250,54 @@ jit_convert_llvm::visit (jit_call& call)
   call.stash_llvm (ret);
 }
 
 void
 jit_convert_llvm::visit (jit_extract_argument& extract)
 {
   llvm::Value *arg = arguments[extract.name ()];
   assert (arg);
-  arg = builder.CreateLoad (arg);
 
-  const jit_function& ol = extract.overload ();
-  extract.stash_llvm (ol.call (builder, arg));
+  if (converting_function)
+    extract.stash_llvm (arg);
+  else
+    {
+      arg = builder.CreateLoad (arg);
+
+      const jit_function& ol = extract.overload ();
+      extract.stash_llvm (ol.call (builder, arg));
+    }
 }
 
 void
 jit_convert_llvm::visit (jit_store_argument& store)
 {
   const jit_function& ol = store.overload ();
   llvm::Value *arg_value = ol.call (builder, store.result ());
   llvm::Value *arg = arguments[store.name ()];
   store.stash_llvm (builder.CreateStore (arg_value, arg));
 }
 
 void
+jit_convert_llvm::visit (jit_return& ret)
+{
+  jit_value *res = ret.result ();
+
+  if (converting_function)
+    creating.do_return (builder, res->to_llvm (), false);
+  else
+    {
+      if (res)
+        builder.CreateRet (res->to_llvm ());
+      else
+        builder.CreateRetVoid ();
+    }
+}
+
+void
 jit_convert_llvm::visit (jit_phi& phi)
 {
   // we might not have converted all incoming branches, so we don't
   // set incomming branches now
   llvm::PHINode *node = llvm::PHINode::Create (phi.type_llvm (),
                                                phi.argument_count ());
   builder.Insert (node);
   phi.stash_llvm (node);
@@ -1109,23 +1322,16 @@ void
 jit_convert_llvm::visit (jit_assign& assign)
 {
   jit_value *new_value = assign.src ();
   assign.stash_llvm (new_value->to_llvm ());
 
   if (assign.artificial ())
     return;
 
-  if (isa<jit_assign_base> (new_value))
-    {
-      const jit_function& ol =  jit_typeinfo::get_grab (new_value->type ());
-      if (ol.valid ())
-        assign.stash_llvm (ol.call (builder, new_value));
-    }
-
   jit_value *overwrite = assign.overwrite ();
   if (isa<jit_assign_base> (overwrite))
     {
       const jit_function& ol = jit_typeinfo::get_release (overwrite->type ());
       if (ol.valid ())
         ol.call (builder, overwrite);
     }
 }
@@ -1280,27 +1486,26 @@ jit_infer::do_construct_ssa (jit_block& 
     {
       jit_block *finish = ablock.successor (i);
 
       for (jit_block::iterator iter = finish->begin (); iter != finish->end ()
              && isa<jit_phi> (*iter);)
         {
           jit_phi *phi = static_cast<jit_phi *> (*iter);
           jit_variable *var = phi->dest ();
+          ++iter;
+
           if (var->has_top ())
-            {
-              phi->add_incomming (&ablock, var->top ());
-              ++iter;
-            }
+            phi->add_incomming (&ablock, var->top ());
           else
             {
               // temporaries may have extranious phi nodes which can be removed
               assert (! phi->use_count ());
               assert (var->name ().size () && var->name ()[0] == '#');
-              iter = finish->remove (iter);
+              phi->remove ();
             }
         }
     }
 
   for (size_t i = 0; i < ablock.dom_successor_count (); ++i)
     do_construct_ssa (*ablock.dom_successor (i), avisit_count);
 
   ablock.pop_all ();
@@ -1517,54 +1722,37 @@ tree_jit::tree_jit (void) : module (0), 
 }
 
 tree_jit::~tree_jit (void)
 {}
 
 bool
 tree_jit::execute (tree_simple_for_command& cmd, const octave_value& bounds)
 {
-  const size_t MIN_TRIP_COUNT = 1000;
-
-  size_t tc = trip_count (bounds);
-  if (! tc || ! initialize ())
-    return false;
-
-  jit_info::vmap extra_vars;
-  extra_vars["#for_bounds0"] = &bounds;
-
-  jit_info *info = cmd.get_info ();
-  if (! info || ! info->match (extra_vars))
-    {
-      if (tc < MIN_TRIP_COUNT)
-        return false;
-
-      delete info;
-      info = new jit_info (*this, cmd, bounds);
-      cmd.stash_info (info);
-    }
-
-  return info->execute (extra_vars);
+  return instance ().do_execute (cmd, bounds);
 }
 
 bool
 tree_jit::execute (tree_while_command& cmd)
 {
-  if (! initialize ())
-    return false;
+  return instance ().do_execute (cmd);
+}
 
-  jit_info *info = cmd.get_info ();
-  if (! info || ! info->match ())
-    {
-      delete info;
-      info = new jit_info (*this, cmd);
-      cmd.stash_info (info);
-    }
+bool
+tree_jit::execute (octave_user_function& fcn, const octave_value_list& args,
+                   octave_value_list& retval)
+{
+  return instance ().do_execute (fcn, args, retval);
+}
 
-  return info->execute ();
+tree_jit&
+tree_jit::instance (void)
+{
+  static tree_jit ret;
+  return ret;
 }
 
 bool
 tree_jit::initialize (void)
 {
   if (engine)
     return true;
 
@@ -1594,16 +1782,77 @@ tree_jit::initialize (void)
   pass_manager->add (llvm::createCFGSimplificationPass ());
   pass_manager->doInitialization ();
 
   jit_typeinfo::initialize (module, engine);
 
   return true;
 }
 
+bool
+tree_jit::do_execute (tree_simple_for_command& cmd, const octave_value& bounds)
+{
+  const size_t MIN_TRIP_COUNT = 1000;
+
+  size_t tc = trip_count (bounds);
+  if (! tc || ! initialize ())
+    return false;
+
+  jit_info::vmap extra_vars;
+  extra_vars["#for_bounds0"] = &bounds;
+
+  jit_info *info = cmd.get_info ();
+  if (! info || ! info->match (extra_vars))
+    {
+      if (tc < MIN_TRIP_COUNT)
+        return false;
+
+      delete info;
+      info = new jit_info (*this, cmd, bounds);
+      cmd.stash_info (info);
+    }
+
+  return info->execute (extra_vars);
+}
+
+bool
+tree_jit::do_execute (tree_while_command& cmd)
+{
+  if (! initialize ())
+    return false;
+
+  jit_info *info = cmd.get_info ();
+  if (! info || ! info->match ())
+    {
+      delete info;
+      info = new jit_info (*this, cmd);
+      cmd.stash_info (info);
+    }
+
+  return info->execute ();
+}
+
+bool
+tree_jit::do_execute (octave_user_function& fcn, const octave_value_list& args,
+                      octave_value_list& retval)
+{
+  if (! initialize ())
+    return false;
+
+  jit_function_info *info = fcn.get_info ();
+    if (! info || ! info->match (args))
+      {
+        delete info;
+        info = new jit_function_info (*this, fcn, args);
+        fcn.stash_info (info);
+      }
+
+    return info->execute (args, retval);
+}
+
 size_t
 tree_jit::trip_count (const octave_value& bounds) const
 {
   if (bounds.is_range ())
     {
       Range rng = bounds.range_value ();
       return rng.nelem ();
     }
@@ -1611,25 +1860,187 @@ tree_jit::trip_count (const octave_value
   // unsupported type
   return 0;
 }
 
 
 void
 tree_jit::optimize (llvm::Function *fn)
 {
+  if (Venable_jit_debugging)
+    llvm::verifyModule (*module);
+
   module_pass_manager->run (*module);
   pass_manager->run (*fn);
 
-#ifdef OCTAVE_JIT_DEBUG
-  std::string error;
-  llvm::raw_fd_ostream fout ("test.bc", error,
-                             llvm::raw_fd_ostream::F_Binary);
-  llvm::WriteBitcodeToFile (module, fout);
-#endif
+  if (Venable_jit_debugging)
+    {
+      std::string error;
+      llvm::raw_fd_ostream fout ("test.bc", error,
+                                 llvm::raw_fd_ostream::F_Binary);
+      llvm::WriteBitcodeToFile (module, fout);
+    }
+}
+
+// -------------------- jit_function_info --------------------
+jit_function_info::jit_function_info (tree_jit& tjit,
+                                      octave_user_function& fcn,
+                                      const octave_value_list& ov_args)
+  : argument_types (ov_args.length ()), function (0)
+{
+  size_t nargs = ov_args.length ();
+  for (size_t i = 0; i < nargs; ++i)
+    argument_types[i] = jit_typeinfo::type_of (ov_args(i));
+
+  jit_function raw_fn;
+  jit_function wrapper;
+
+  try
+    {
+      jit_convert conv (fcn, argument_types);
+      jit_infer infer (conv.get_factory (), conv.get_blocks (),
+                       conv.get_variable_map ());
+      infer.infer ();
+
+      if (Venable_jit_debugging)
+        {
+          jit_block_list& blocks = infer.get_blocks ();
+          jit_block *entry_block = blocks.front ();
+          entry_block->label ();
+          std::cout << "-------------------- Compiling function ";
+          std::cout << "--------------------\n";
+
+          tree_print_code tpc (std::cout);
+          tpc.visit_octave_user_function_header (fcn);
+          tpc.visit_statement_list (*fcn.body ());
+          tpc.visit_octave_user_function_trailer (fcn);
+          blocks.print (std::cout, "octave jit ir");
+        }
+
+      jit_factory& factory = conv.get_factory ();
+      llvm::Module *module = tjit.get_module ();
+      jit_convert_llvm to_llvm;
+      raw_fn = to_llvm.convert_function (module, infer.get_blocks (),
+                                         factory.constants (), fcn,
+                                         argument_types);
+
+      if (Venable_jit_debugging)
+        {
+          std::cout << "-------------------- raw function ";
+          std::cout << "--------------------\n";
+          std::cout << *raw_fn.to_llvm () << std::endl;
+          llvm::verifyFunction (*raw_fn.to_llvm ());
+        }
+
+      std::string wrapper_name = fcn.name () + "_wrapper";
+      jit_type *any_t = jit_typeinfo::get_any ();
+      std::vector<jit_type *> wrapper_args (1, jit_typeinfo::get_any_ptr ());
+      wrapper = jit_function (module, jit_convention::internal, wrapper_name,
+                              any_t, wrapper_args);
+
+      llvm::BasicBlock *wrapper_body = wrapper.new_block ();
+      builder.SetInsertPoint (wrapper_body);
+
+      llvm::Value *wrapper_arg = wrapper.argument (builder, 0);
+      std::vector<llvm::Value *> raw_args (nargs);
+      for (size_t i = 0; i < nargs; ++i)
+        {
+          llvm::Value *arg;
+          arg = builder.CreateConstInBoundsGEP1_32 (wrapper_arg, i);
+          arg = builder.CreateLoad (arg);
+
+          jit_type *arg_type = argument_types[i];
+          const jit_function& cast = jit_typeinfo::cast (arg_type, any_t);
+          raw_args[i] = cast.call (builder, arg);
+        }
+
+      llvm::Value *result = raw_fn.call (builder, raw_args);
+      if (raw_fn.result ())
+        {
+          jit_type *raw_result_t = raw_fn.result ();
+          const jit_function& cast = jit_typeinfo::cast (any_t, raw_result_t);
+          result = cast.call (builder, result);
+        }
+      else
+        {
+          llvm::Value *zero = builder.getInt32 (0);
+          result = builder.CreateBitCast (zero, any_t->to_llvm ());
+        }
+
+      wrapper.do_return (builder, result);
+
+      llvm::Function *llvm_function = wrapper.to_llvm ();
+      tjit.optimize (llvm_function);
+
+      if (Venable_jit_debugging)
+        {
+          std::cout << "-------------------- optimized and wrapped ";
+          std::cout << "--------------------\n";
+          std::cout << *llvm_function << std::endl;
+          llvm::verifyFunction (*llvm_function);
+        }
+
+      llvm::ExecutionEngine* engine = tjit.get_engine ();
+      void *void_fn = engine->getPointerToFunction (llvm_function);
+      function = reinterpret_cast<jited_function> (void_fn);
+    }
+  catch (const jit_fail_exception& e)
+    {
+      argument_types.clear ();
+
+      if (Venable_jit_debugging)
+        {
+          if (e.known ())
+            std::cout << "jit fail: " << e.what () << std::endl;
+        }
+
+      wrapper.erase ();
+      raw_fn.erase ();
+    }
+}
+
+bool
+jit_function_info::execute (const octave_value_list& ov_args,
+                            octave_value_list& retval) const
+{
+  if (! function)
+    return false;
+
+  // TODO figure out a way to delete ov_args so we avoid duplicating refcount
+  size_t nargs = ov_args.length ();
+  std::vector<octave_base_value *> args (nargs);
+  for (size_t i = 0; i < nargs; ++i)
+    {
+      octave_base_value *obv = ov_args(i).internal_rep ();
+      obv->grab ();
+      args[i] = obv;
+    }
+
+  octave_base_value *ret = function (&args[0]);
+  if (ret)
+    retval(0) = octave_value (ret);
+
+  return true;
+}
+
+bool
+jit_function_info::match (const octave_value_list& ov_args) const
+{
+  if (! function)
+    return true;
+
+  size_t nargs = ov_args.length ();
+  if (nargs != argument_types.size ())
+    return false;
+
+  for (size_t i = 0; i < nargs; ++i)
+    if (jit_typeinfo::type_of (ov_args(i)) != argument_types[i])
+      return false;
+
+  return true;
 }
 
 // -------------------- jit_info --------------------
 jit_info::jit_info (tree_jit& tjit, tree& tee)
   : engine (tjit.get_engine ()), function (0), llvm_function (0)
 {
   compile (tjit, tee);
 }
@@ -1703,75 +2114,119 @@ jit_info::compile (tree_jit& tjit, tree&
 {
   try
     {
       jit_convert conv (tee, for_bounds);
       jit_infer infer (conv.get_factory (), conv.get_blocks (),
                        conv.get_variable_map ());
 
       infer.infer ();
-#ifdef OCTAVE_JIT_DEBUG
-      jit_block *entry_block = infer.get_blocks ().front ();
-      entry_block->label ();
-      std::cout << "-------------------- Compiling tree --------------------\n";
-      std::cout << tee.str_print_code () << std::endl;
-      entry_block->print (std::cout, "octave jit ir");
-#endif
+
+      if (Venable_jit_debugging)
+        {
+          jit_block_list& blocks = infer.get_blocks ();
+          jit_block *entry_block = blocks.front ();
+          entry_block->label ();
+          std::cout << "-------------------- Compiling tree --------------------\n";
+          std::cout << tee.str_print_code () << std::endl;
+          blocks.print (std::cout, "octave jit ir");
+        }
 
       jit_factory& factory = conv.get_factory ();
       jit_convert_llvm to_llvm;
-      llvm_function = to_llvm.convert (tjit.get_module (), infer.get_blocks (),
-                                       factory.constants ());
+      llvm_function = to_llvm.convert_loop (tjit.get_module (),
+                                            infer.get_blocks (),
+                                            factory.constants ());
       arguments = to_llvm.get_arguments ();
       bounds = conv.get_bounds ();
     }
   catch (const jit_fail_exception& e)
     {
-#ifdef OCTAVE_JIT_DEBUG
-      if (e.known ())
-        std::cout << "jit fail: " << e.what () << std::endl;
-#endif
+      if (Venable_jit_debugging)
+        {
+          if (e.known ())
+            std::cout << "jit fail: " << e.what () << std::endl;
+        }
     }
 
   if (llvm_function)
     {
-#ifdef OCTAVE_JIT_DEBUG
-      std::cout << "-------------------- llvm ir --------------------";
-      llvm::raw_os_ostream llvm_cout (std::cout);
-      function->print (llvm_cout);
-      std::cout << std::endl;
-      llvm::verifyFunction (*function);
-#endif
+      if (Venable_jit_debugging)
+        {
+          std::cout << "-------------------- llvm ir --------------------";
+          std::cout << *llvm_function << std::endl;
+          llvm::verifyFunction (*llvm_function);
+        }
 
       tjit.optimize (llvm_function);
 
-#ifdef OCTAVE_JIT_DEBUG
-      std::cout << "-------------------- optimized llvm ir "
-                << "--------------------\n";
-      llvm::raw_os_ostream llvm_cout (std::cout);
-      llvm_function->print (llvm_cout);
-      llvm_cout.flush ();
-      std::cout << std::endl;
-#endif
+      if (Venable_jit_debugging)
+        {
+          std::cout << "-------------------- optimized llvm ir "
+                    << "--------------------\n";
+          std::cout << *llvm_function << std::endl;
+        }
 
       void *void_fn = engine->getPointerToFunction (llvm_function);
       function = reinterpret_cast<jited_function> (void_fn);
     }
 }
 
 octave_value
 jit_info::find (const vmap& extra_vars, const std::string& vname) const
 {
   vmap::const_iterator iter = extra_vars.find (vname);
   return iter == extra_vars.end () ? symbol_table::varval (vname)
     : *iter->second;
 }
 
 #endif
 
+DEFUN (enable_jit_debugging, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn  {Built-in Function} {@var{val} =} enable_jit_debugging ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} enable_jit_debugging (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} enable_jit_debugging (@var{new_val}, \"local\")\n\
+Query or set the internal variable that determines whether\n\
+debugging/tracing is enabled for Octave's JIT compiler.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
+@seealso{enable_jit_compiler}\n\
+@end deftypefn")
+{
+#if defined (HAVE_LLVM)
+  return SET_INTERNAL_VARIABLE (enable_jit_debugging);
+#else
+  warning ("enable_jit_debugging: JIT compiling not available in this version of Octave");
+  return octave_value ();
+#endif
+}
+
+DEFUN (enable_jit_compiler, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn  {Built-in Function} {@var{val} =} enable_jit_compiler ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} enable_jit_compiler (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} enable_jit_compiler (@var{new_val}, \"local\")\n\
+Query or set the internal variable that enables Octave's JIT compiler.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
+@seealso{enable_jit_debugging}\n\
+@end deftypefn")
+{
+#if defined (HAVE_LLVM)
+  return SET_INTERNAL_VARIABLE (enable_jit_compiler);
+#else
+  warning ("enable_jit_compiler: JIT compiling not available in this version of Octave");
+  return octave_value ();
+#endif
+}
 
 /*
 Test some simple cases that compile.
 
 %!test
 %! inc = 1e-5;
 %! result = 0;
 %! for ii = 0:inc:1
@@ -2007,9 +2462,74 @@ Test some simple cases that compile.
 %!     li++;
 %!   else
 %!     si++;
 %!   endif;
 %! endwhile
 
 %!error test_compute_idom ()
 
+%!function x = test_overload (a)
+%!  while 1
+%!    x = a;
+%!    break;
+%!  endwhile
+%!endfunction
+
+%!assert (test_overload (1), 1);
+%!assert (test_overload ([1 2]), [1 2]);
+
+%!function a = bubble (a = [3 2 1])
+%!  swapped = 1;
+%!  n = length (a);
+%!  while (swapped)
+%!    swapped = 0;
+%!    for i = 1:n-1
+%!      if a(i) > a(i + 1)
+%!        swapped = 1;
+%!        temp = a(i);
+%!        a(i) = a(i + 1);
+%!        a(i + 1) = temp;
+%!      endif
+%!    endfor
+%!  endwhile
+%!endfunction
+
+%!assert (bubble (), [1 2 3]);
+
+%!test
+%! a = 0;
+%! b = 1;
+%! for i=1:1e3
+%!   for j=1:2
+%!     a = a + b;
+%!   endfor
+%! endfor
+%! assert (a, 2000);
+%! assert (b, 1);
+
+%!test
+%! a = [1+1i 1+2i];
+%! b = 0;
+%! while 1
+%!   b = a(1);
+%!   break;
+%! endwhile
+%! assert (b, a(1));
+
+%!function test_undef ()
+%!  for i=1:1e7
+%!    XXX;
+%!  endfor
+%!endfunction
+
+%!error <undefined near> (test_undef);
+
+%!shared id
+%! id = @(x) x;
+
+%!assert (id (1), 1);
+%!assert (id (1+1i), 1+1i)
+%!assert (id (1, 2), 1)
+%!error <undefined> (id ())
+
+
 */
diff --git a/libinterp/interp-core/pt-jit.h b/libinterp/interp-core/pt-jit.h
--- a/libinterp/interp-core/pt-jit.h
+++ b/libinterp/interp-core/pt-jit.h
@@ -21,30 +21,34 @@ along with Octave; see the file COPYING.
 */
 
 #if !defined (octave_tree_jit_h)
 #define octave_tree_jit_h 1
 
 #ifdef HAVE_LLVM
 
 #include "jit-ir.h"
+#include "pt-walk.h"
+#include "symtab.h"
 
-#include "pt-walk.h"
+class octave_value_list;
 
 // Convert from the parse tree (AST) to the low level Octave IR.
 class
 jit_convert : public tree_walker
 {
 public:
   typedef std::pair<jit_type *, std::string> type_bound;
   typedef std::vector<type_bound> type_bound_vector;
   typedef std::map<std::string, jit_variable *> variable_map;
 
   jit_convert (tree &tee, jit_type *for_bounds = 0);
 
+  jit_convert (octave_user_function& fcn, const std::vector<jit_type *>& args);
+
 #define DECL_ARG(n) const ARG ## n& arg ## n
 #define JIT_CREATE_CHECKED(N)                                           \
   template <OCT_MAKE_DECL_LIST (typename, ARG, N)>                      \
   jit_call *create_checked (OCT_MAKE_LIST (DECL_ARG, N))                \
   {                                                                     \
     jit_call *ret = factory.create<jit_call> (OCT_MAKE_ARG_LIST (arg, N)); \
     return create_checked_impl (ret);                                   \
   }
@@ -151,16 +155,21 @@ public:
 
   void visit_while_command (tree_while_command&);
 
   void visit_do_until_command (tree_do_until_command&);
 private:
   std::vector<std::pair<std::string, bool> > arguments;
   type_bound_vector bounds;
 
+  bool converting_function;
+
+  // the scope of the function we are converting, or the current scope
+  symbol_table::scope_id scope;
+
   jit_factory factory;
 
   // used instead of return values from visit_* functions
   jit_value *result;
 
   jit_block *entry_block;
 
   jit_block *final_block;
@@ -174,46 +183,48 @@ private:
   std::vector<jit_magic_end::context> end_context;
 
   size_t iterator_count;
   size_t for_bounds_count;
   size_t short_count;
 
   variable_map vmap;
 
+  void initialize (symbol_table::scope_id s);
+
   jit_call *create_checked_impl (jit_call *ret);
 
   // get an existing vairable. If the variable does not exist, it will not be
   // created
   jit_variable *find_variable (const std::string& vname) const;
 
   // get a variable, create it if it does not exist. The type will default to
   // the variable's current type in the symbol table.
   jit_variable *get_variable (const std::string& vname);
 
   // create a variable of the given name and given type. Will also insert an
   // extract statement
-  jit_variable *create_variable (const std::string& vname, jit_type *type);
+  jit_variable *create_variable (const std::string& vname, jit_type *type,
+                                 bool isarg = true);
 
   // The name of the next for loop iterator. If inc is false, then the iterator
   // counter will not be incremented.
   std::string next_iterator (bool inc = true)
   { return next_name ("#iter", iterator_count, inc); }
 
   std::string next_for_bounds (bool inc = true)
   { return next_name ("#for_bounds", for_bounds_count, inc); }
 
   std::string next_shortcircut_result (bool inc = true)
   { return next_name ("#shortcircut_result", short_count, inc); }
 
   std::string next_name (const char *prefix, size_t& count, bool inc);
 
-  jit_instruction *resolve (const jit_operation& fres,
-                            tree_index_expression& exp,
-                            jit_value *extra_arg = 0);
+  jit_instruction *resolve (tree_index_expression& exp,
+                            jit_value *extra_arg = 0, bool lhs = false);
 
   jit_value *do_assign (tree_expression *exp, jit_value *rhs,
                         bool artificial = false);
 
   jit_value *do_assign (const std::string& lhs, jit_value *rhs, bool print,
                         bool artificial = false);
 
   jit_value *visit (tree *tee) { return visit (*tee); }
@@ -229,37 +240,56 @@ private:
   void finish_breaks (jit_block *dest, const block_list& lst);
 };
 
 // Convert from the low level Octave IR to LLVM
 class
 jit_convert_llvm : public jit_ir_walker
 {
 public:
-  llvm::Function *convert (llvm::Module *module,
-                           const jit_block_list& blocks,
-                           const std::list<jit_value *>& constants);
+  llvm::Function *convert_loop (llvm::Module *module,
+                                const jit_block_list& blocks,
+                                const std::list<jit_value *>& constants);
 
+  jit_function convert_function (llvm::Module *module,
+                                 const jit_block_list& blocks,
+                                 const std::list<jit_value *>& constants,
+                                 octave_user_function& fcn,
+                                 const std::vector<jit_type *>& args);
+
+  // arguments to the llvm::Function for loops
   const std::vector<std::pair<std::string, bool> >& get_arguments(void) const
   { return argument_vec; }
 
 #define JIT_METH(clname)                        \
   virtual void visit (jit_ ## clname&);
 
   JIT_VISIT_IR_CLASSES;
 
 #undef JIT_METH
 private:
+  // name -> argument index (used for compiling functions)
+  std::map<std::string, int> argument_index;
+
   std::vector<std::pair<std::string, bool> > argument_vec;
 
-  // name -> llvm argument
+  // name -> llvm argument (used for compiling loops)
   std::map<std::string, llvm::Value *> arguments;
+
+  bool converting_function;
+
+  // only used if we are converting a function
+  jit_function creating;
+
   llvm::Function *function;
   llvm::BasicBlock *prelude;
 
+  void convert (const jit_block_list& blocks,
+                const std::list<jit_value *>& constants);
+
   void finish_phi (jit_phi *phi);
 
   void visit (jit_value *jvalue)
   {
     return visit (*jvalue);
   }
 
   void visit (jit_value &jvalue)
@@ -315,41 +345,72 @@ private:
 
   void simplify_phi (jit_phi& phi);
 };
 
 class
 tree_jit
 {
 public:
-  tree_jit (void);
-
   ~tree_jit (void);
 
-  bool execute (tree_simple_for_command& cmd, const octave_value& bounds);
+  static bool execute (tree_simple_for_command& cmd,
+                       const octave_value& bounds);
 
-  bool execute (tree_while_command& cmd);
+  static bool execute (tree_while_command& cmd);
+
+  static bool execute (octave_user_function& fcn, const octave_value_list& args,
+                       octave_value_list& retval);
 
   llvm::ExecutionEngine *get_engine (void) const { return engine; }
 
   llvm::Module *get_module (void) const { return module; }
 
   void optimize (llvm::Function *fn);
  private:
+  tree_jit (void);
+
+  static tree_jit& instance (void);
+
   bool initialize (void);
 
+  bool do_execute (tree_simple_for_command& cmd, const octave_value& bounds);
+
+  bool do_execute (tree_while_command& cmd);
+
+  bool do_execute (octave_user_function& fcn, const octave_value_list& args,
+                   octave_value_list& retval);
+
   size_t trip_count (const octave_value& bounds) const;
 
   llvm::Module *module;
   llvm::PassManager *module_pass_manager;
   llvm::FunctionPassManager *pass_manager;
   llvm::ExecutionEngine *engine;
 };
 
 class
+jit_function_info
+{
+public:
+  jit_function_info (tree_jit& tjit, octave_user_function& fcn,
+                     const octave_value_list& ov_args);
+
+  bool execute (const octave_value_list& ov_args,
+                octave_value_list& retval) const;
+
+  bool match (const octave_value_list& ov_args) const;
+private:
+  typedef octave_base_value *(*jited_function)(octave_base_value**);
+
+  std::vector<jit_type *> argument_types;
+  jited_function function;
+};
+
+class
 jit_info
 {
 public:
   // we use a pointer here so we don't have to include ov.h
   typedef std::map<std::string, const octave_value *> vmap;
 
   jit_info (tree_jit& tjit, tree& tee);
 
@@ -373,9 +434,16 @@ private:
   jited_function function;
   llvm::Function *llvm_function;
 
   std::vector<std::pair<std::string, bool> > arguments;
   type_bound_vector bounds;
 };
 
 #endif
+
+// If TRUE, enable JIT compiler debugging/tracing.
+extern bool Venable_jit_debugging;
+
+// If TRUE, enable JIT compiler.
+extern bool Venable_jit_compiler;
+
 #endif
diff --git a/libinterp/interp-core/sparse-xpow.cc b/libinterp/interp-core/sparse-xpow.cc
--- a/libinterp/interp-core/sparse-xpow.cc
+++ b/libinterp/interp-core/sparse-xpow.cc
@@ -225,16 +225,39 @@ xpow (const SparseComplexMatrix& a, doub
 //
 //   a = -1; b = [ 0, 0.5, 1 ]; for i = 1:3, r(i) = a .^ b(i), end
 //
 // produce identical results.  Also, it would be nice if -1^0.5
 // produced a pure imaginary result instead of a complex number with a
 // small real part.  But perhaps that's really a problem with the math
 // library...
 
+// Handle special case of scalar-sparse-matrix .^ sparse-matrix.
+// Forwarding to the scalar elem_xpow function and then converting the
+// result back to a sparse matrix is a bit wasteful but it does not
+// seem worth the effort to optimize -- how often does this case come up
+// in practice?
+
+template <class S, class SM>
+inline octave_value
+scalar_xpow (const S& a, const SM& b)
+{
+  octave_value val = elem_xpow (a, b);
+
+  if (val.is_complex_type ())
+    return SparseComplexMatrix (val.complex_matrix_value ());
+  else
+    return SparseMatrix (val.matrix_value ());
+}
+
+/*
+%!assert (sparse (2) .^ [3, 4], sparse ([8, 16]));
+%!assert (sparse (2i) .^ [3, 4], sparse ([-0-8i, 16]));
+*/
+
 // -*- 1 -*-
 octave_value
 elem_xpow (double a, const SparseMatrix& b)
 {
   octave_value retval;
 
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
@@ -395,16 +418,19 @@ elem_xpow (const SparseMatrix& a, const 
   octave_value retval;
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
+  if (a.numel () == 1 && b.numel () > 1)
+    return scalar_xpow (a(0), b);
+
   if (nr != b_nr || nc != b_nc)
     {
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
   int convert_to_complex = 0;
   for (octave_idx_type j = 0; j < nc; j++)
@@ -497,16 +523,19 @@ octave_value
 elem_xpow (const SparseMatrix& a, const SparseComplexMatrix& b)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
+  if (a.numel () == 1 && b.numel () > 1)
+    return scalar_xpow (a(0), b);
+
   if (nr != b_nr || nc != b_nc)
     {
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
   SparseComplexMatrix result (nr, nc, Complex (1.0, 0.0));
   for (octave_idx_type j = 0; j < nc; j++)
@@ -637,16 +666,19 @@ octave_value
 elem_xpow (const SparseComplexMatrix& a, const SparseMatrix& b)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
+  if (a.numel () == 1 && b.numel () > 1)
+    return scalar_xpow (a(0), b);
+
   if (nr != b_nr || nc != b_nc)
     {
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
   SparseComplexMatrix result (nr, nc, Complex (1.0, 0.0));
   for (octave_idx_type j = 0; j < nc; j++)
@@ -705,16 +737,19 @@ octave_value
 elem_xpow (const SparseComplexMatrix& a, const SparseComplexMatrix& b)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
+  if (a.numel () == 1 && b.numel () > 1)
+    return scalar_xpow (a(0), b);
+
   if (nr != b_nr || nc != b_nc)
     {
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
   SparseComplexMatrix result (nr, nc, Complex (1.0, 0.0));
   for (octave_idx_type j = 0; j < nc; j++)
diff --git a/libinterp/interp-core/txt-eng-ft.cc b/libinterp/interp-core/txt-eng-ft.cc
--- a/libinterp/interp-core/txt-eng-ft.cc
+++ b/libinterp/interp-core/txt-eng-ft.cc
@@ -40,25 +40,25 @@ along with Octave; see the file COPYING.
 
 // FIXME -- maybe issue at most one warning per glyph/font/size/weight
 // combination.
 
 static void
 gripe_missing_glyph (char c)
 {
   warning_with_id ("Octave:missing-glyph",
-                   "ft_render: skipping missing glyph for character `%c'",
+                   "ft_render: skipping missing glyph for character '%c'",
                    c);
 }
 
 static void
 gripe_glyph_render (char c)
 {
   warning_with_id ("Octave:glyph-render",
-                   "ft_render: unable to render glyph for character `%c'",
+                   "ft_render: unable to render glyph for character '%c'",
                    c);
 }
 
 #ifdef _MSC_VER
 // This is just a trick to avoid multiply symbols definition.
 // PermMatrix.h contains a dllexport'ed Array<octave_idx_type>
 // that will make MSVC not to generate new instantiation and
 // use the imported one.
@@ -131,17 +131,17 @@ private:
     {
       if (freetype_initialized)
         FT_Done_FreeType (library);
 
 #if defined (HAVE_FONTCONFIG)
       // FIXME -- Skip the call to FcFini because it can trigger the
       // assertion
       //
-      //   octave: fccache.c:507: FcCacheFini: Assertion `fcCacheChains[i] == ((void *)0)' failed.
+      //   octave: fccache.c:507: FcCacheFini: Assertion 'fcCacheChains[i] == ((void *)0)' failed.
       //
       // if (fontconfig_initialized)
       //   FcFini ();
 #endif
     }
 
 
   FT_Face do_get_font (const std::string& name, const std::string& weight,
@@ -293,17 +293,17 @@ ft_render::set_mode (int m)
         {
           pixels = uint8NDArray (dim_vector (4, bbox(2), bbox(3)),
                                  static_cast<uint8_t> (0));
           xoffset = 0;
           yoffset = -bbox(1)-1;
         }
       break;
     default:
-      ::error ("ft_render: invalid mode `%d'", mode);
+      ::error ("ft_render: invalid mode '%d'", mode);
       break;
     }
 }
 
 void
 ft_render::visit (text_element_string& e)
 {
   if (face)
diff --git a/libinterp/interp-core/unwind-prot.cc b/libinterp/interp-core/unwind-prot.cc
--- a/libinterp/interp-core/unwind-prot.cc
+++ b/libinterp/interp-core/unwind-prot.cc
@@ -20,20 +20,16 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <cstddef>
-#include <cstring>
-
 #include "error.h"
 #include "unwind-prot.h"
-#include "utils.h"
 
 void unwind_protect_safe::gripe_exception (void)
 {
   // FIXME: can this throw an exception?
   error ("internal: unhandled exception in unwind_protect handler");
 }
diff --git a/libinterp/interp-core/unwind-prot.h b/libinterp/interp-core/unwind-prot.h
--- a/libinterp/interp-core/unwind-prot.h
+++ b/libinterp/interp-core/unwind-prot.h
@@ -19,326 +19,125 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_unwind_prot_h)
 #define octave_unwind_prot_h 1
 
-#include <cstddef>
-
-#include <string>
+#include <stack>
 #include <memory>
 
-// This class allows registering cleanup actions.
+#include "action-container.h"
+
 class
 OCTINTERP_API
-unwind_protect
+unwind_protect : public action_container
 {
 public:
 
-  // A generic unwind_protect element. Knows how to run itself and discard itself.
-  // Also, contains a pointer to the next element.
-  class elem
-  {
-    elem *next;
-
-  public:
-    elem (void) : next (0) { }
-
-    virtual void run (void) { }
-
-    virtual ~elem (void) { }
-
-    friend class unwind_protect;
-
-  private:
-
-    // No copying!
-
-    elem (const elem&);
-
-    elem& operator = (const elem&);
-  };
-
-  // An element that merely runs a void (*)(void) function.
-
-  class fcn_elem : public elem
-  {
-  public:
-    fcn_elem (void (*fptr) (void))
-      : e_fptr (fptr) { }
+  unwind_protect (void) : lifo () { }
 
-    void run (void) { e_fptr (); }
-
-  private:
-    void (*e_fptr) (void);
-  };
-
-  // An element that stores a variable of type T along with a void (*) (T)
-  // function pointer, and calls the function with the parameter.
-
-  template <class T>
-  class fcn_arg_elem : public elem
-  {
-  public:
-    fcn_arg_elem (void (*fcn) (T), T arg)
-      : e_fcn (fcn), e_arg (arg) { }
+  // Destructor should not raise an exception, so all actions
+  // registered should be exception-safe (but setting error_state is
+  // allowed). If you're not sure, see unwind_protect_safe.
 
-    void run (void) { e_fcn (e_arg); }
-
-  private:
-
-    // No copying!
-
-    fcn_arg_elem (const fcn_arg_elem&);
-
-    fcn_arg_elem& operator = (const fcn_arg_elem&);
-
-    void (*e_fcn) (T);
-    T e_arg;
-  };
-
-  // An element that stores a variable of type T along with a void (*) (const T&)
-  // function pointer, and calls the function with the parameter.
+  ~unwind_protect (void) { run (); }
 
-  template <class T>
-  class fcn_crefarg_elem : public elem
+  virtual void add (elem *new_elem)
   {
-  public:
-    fcn_crefarg_elem (void (*fcn) (const T&), T arg)
-      : e_fcn (fcn), e_arg (arg) { }
-
-    void run (void) { e_fcn (e_arg); }
-
-  private:
-    void (*e_fcn) (const T&);
-    T e_arg;
-  };
-
-  // An element for calling a member function.
-
-  template <class T>
-  class method_elem : public elem
-  {
-  public:
-    method_elem (T *obj, void (T::*method) (void))
-      : e_obj (obj), e_method (method) { }
-
-    void run (void) { (e_obj->*e_method) (); }
-
-  private:
-
-    T *e_obj;
-    void (T::*e_method) (void);
-
-    // No copying!
-
-    method_elem (const method_elem&);
+    lifo.push (new_elem);
+  }
 
-    method_elem operator = (const method_elem&);
-  };
-
-  // An element that stores arbitrary variable, and restores it.
-
-  template <class T>
-  class restore_var_elem : public elem
+  void add (void (*fcn) (void *), void *ptr = 0) GCC_ATTR_DEPRECATED
   {
-  public:
-    restore_var_elem (T& ref, const T& val)
-      : e_ptr (&ref), e_val (val) { }
-
-    void run (void) { *e_ptr = e_val; }
-
-  private:
+    add (new fcn_arg_elem<void *> (fcn, ptr));
+  }
 
-    // No copying!
-
-    restore_var_elem (const restore_var_elem&);
-
-    restore_var_elem& operator = (const restore_var_elem&);
-
-    T *e_ptr, e_val;
-  };
+  operator bool (void) const { return ! empty (); }
 
-  // Deletes a class allocated using new.
-
-  template <class T>
-  class delete_ptr_elem : public elem
-  {
-  public:
-    delete_ptr_elem (T *ptr)
-      : e_ptr (ptr) { }
+  void run_top (void) GCC_ATTR_DEPRECATED { run_first (); }
 
-    void run (void) { delete e_ptr; }
-
-  private:
-
-    T *e_ptr;
-
-    // No copying!
-
-    delete_ptr_elem (const delete_ptr_elem&);
-
-    delete_ptr_elem operator = (const delete_ptr_elem&);
-  };
-
-  unwind_protect (void) : head () { }
-
-  void add (elem *new_elem)
-    {
-      new_elem->next = head;
-      head = new_elem;
-    }
-
-  // For backward compatibility.
-  void add (void (*fcn) (void *), void *ptr = 0)
-    {
-      add (new fcn_arg_elem<void *> (fcn, ptr));
-    }
+  void run_first (void)
+  {
+    if (! empty ())
+      {
+        // No leak on exception!
+        std::auto_ptr<elem> ptr (lifo.top ());
+        lifo.pop ();
+        ptr->run ();
+      }
+  }
 
-  // Call to void func (void).
-  void add_fcn (void (*fcn) (void))
-    {
-      add (new fcn_elem (fcn));
-    }
-
-  // Call to void func (T).
-  template <class T>
-  void add_fcn (void (*action) (T), T val)
-    {
-      add (new fcn_arg_elem<T> (action, val));
-    }
+  void run_top (int num) GCC_ATTR_DEPRECATED { run (num); }
 
-  // Call to void func (const T&).
-  template <class T>
-  void add_fcn (void (*action) (const T&), T val)
-    {
-      add (new fcn_crefarg_elem<T> (action, val));
-    }
-
-  // Call to T::method (void).
-  template <class T>
-  void add_method (T *obj, void (T::*method) (void))
-    {
-      add (new method_elem<T> (obj, method));
-    }
-
-  // Call to delete (T*).
-
-  template <class T>
-  void add_delete (T *obj)
-    {
-      add (new delete_ptr_elem<T> (obj));
-    }
+  void discard_top (void) GCC_ATTR_DEPRECATED { discard_first (); }
 
-  // Protect any variable.
-  template <class T>
-  void protect_var (T& var)
-    {
-      add (new restore_var_elem<T> (var, var));
-    }
-
-  // Protect any variable, value given.
-  template <class T>
-  void protect_var (T& var, const T& val)
-    {
-      add (new restore_var_elem<T> (var, val));
-    }
-
-  operator bool (void) const
-    {
-      return head != 0;
-    }
-
-  void run_top (void)
-    {
-      if (head)
-        {
-          // No leak on exception!
-          std::auto_ptr<elem> ptr (head);
-          head = ptr->next;
-          ptr->run ();
-        }
-    }
-
-  void run_top (int num)
-    {
-      while (num-- > 0)
-        run_top ();
-    }
+  void discard_first (void)
+  {
+    if (! empty ())
+      {
+        elem *ptr = lifo.top ();
+        lifo.pop ();
+        delete ptr;
+      }
+  }
 
-  void discard_top (void)
-    {
-      if (head)
-        {
-          elem *ptr = head;
-          head = ptr->next;
-          delete ptr;
-        }
-    }
+  void discard_top (int num) GCC_ATTR_DEPRECATED { discard (num); }
 
-  void discard_top (int num)
-    {
-      while (num-- > 0)
-        discard_top ();
-    }
+  size_t size (void) const { return lifo.size (); }
 
-  void run (void)
-    {
-      while (head)
-        run_top ();
-    }
+protected:
 
-  void discard (void)
-    {
-      while (head)
-        discard_top ();
-    }
-
-  // Destructor should not raise an exception, so all actions registered should
-  // be exception-safe (but setting error_state is allowed). If you're not sure,
-  // see unwind_protect_safe.
-  ~unwind_protect (void)
-    {
-      run ();
-    }
+  std::stack<elem *> lifo;
 
 private:
 
-  elem *head;
-
   // No copying!
 
   unwind_protect (const unwind_protect&);
 
   unwind_protect& operator = (const unwind_protect&);
 };
 
-// Like unwind_protect, but this one will guard against the possibility of seeing
-// an exception (or interrupt) in the cleanup actions. Not that we can do much about
-// it, but at least we won't crash.
+// Like unwind_protect, but this one will guard against the
+// possibility of seeing an exception (or interrupt) in the cleanup
+// actions. Not that we can do much about it, but at least we won't
+// crash.
 
 class
 OCTINTERP_API
 unwind_protect_safe : public unwind_protect
 {
+private:
+
   static void gripe_exception (void);
 
 public:
+
+  unwind_protect_safe (void) : unwind_protect () { }
+
   ~unwind_protect_safe (void)
     {
-      while (*this)
+      while (! empty ())
         {
           try
             {
-              run_top ();
+              run_first ();
             }
           catch (...) // Yes, the black hole. Remember we're in a dtor.
             {
               gripe_exception ();
             }
         }
     }
+
+private:
+
+  // No copying!
+
+  unwind_protect_safe (const unwind_protect_safe&);
+
+  unwind_protect_safe& operator = (const unwind_protect_safe&);
 };
 
 #endif
diff --git a/libinterp/interp-core/zfstream.cc b/libinterp/interp-core/zfstream.cc
--- a/libinterp/interp-core/zfstream.cc
+++ b/libinterp/interp-core/zfstream.cc
@@ -468,16 +468,21 @@ gzfilebuf::seekoff (off_type off, std::i
 
   if (this->is_open ())
     {
       off_type computed_off = off;
 
       if ((io_mode & std::ios_base::in) && way == std::ios_base::cur)
         computed_off += this->gptr () - this->egptr ();
 
+      // Handle tellg/tellp as a special case up front, no need to seek
+      // or invalidate get/put buffers
+      if (off == 0 && way == std::ios_base::cur)
+        return pos_type (gztell (file) + computed_off);
+
       if (way == std::ios_base::beg)
         ret = pos_type (gzseek (file, computed_off, SEEK_SET));
       else if (way == std::ios_base::cur)
         ret = pos_type (gzseek (file, computed_off, SEEK_CUR));
       else
         // Can't seek from end of a gzipped file, so this will give -1
         ret = pos_type (gzseek (file, computed_off, SEEK_END));
 
diff --git a/libinterp/interpfcn/data.cc b/libinterp/interpfcn/data.cc
--- a/libinterp/interpfcn/data.cc
+++ b/libinterp/interpfcn/data.cc
@@ -33,20 +33,20 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_SYS_RESOURCE_H
 #include <sys/resource.h>
 #endif
 
 #include <cfloat>
 #include <ctime>
 
 #include <string>
-#include <base64.h>
 
 #include "lo-ieee.h"
 #include "lo-math.h"
+#include "oct-base64.h"
 #include "oct-time.h"
 #include "str-vec.h"
 #include "quit.h"
 #include "mx-base.h"
 #include "oct-binmap.h"
 
 #include "Cell.h"
 #include "defun.h"
@@ -1333,16 +1333,21 @@ Given a matrix argument, instead of a ve
 %!assert (diag (int8 ([1; 2; 3]), 2), int8 ([0, 0, 1, 0, 0; 0, 0, 0, 2, 0; 0, 0, 0, 0, 3; 0, 0, 0, 0, 0; 0, 0, 0, 0, 0]))
 %!assert (diag (int8 ([1; 2; 3]),-1), int8 ([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]))
 %!assert (diag (int8 ([1; 2; 3]),-2), int8 ([0, 0, 0, 0, 0; 0, 0, 0, 0, 0; 1, 0, 0, 0, 0; 0, 2, 0, 0, 0; 0, 0, 3, 0, 0]))
 
 %!assert (diag (int8 ([1, 0, 0; 0, 2, 0; 0, 0, 3])), int8 ([1; 2; 3]))
 %!assert (diag (int8 ([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]), 1), int8 ([1; 2; 3]))
 %!assert (diag (int8 ([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]), -1), int8 ([1; 2; 3]))
 
+## bug #37411
+%!assert (diag (diag ([5, 2, 3])(:,1)), diag([5 0 0 ]))
+%!assert (diag (diag ([5, 2, 3])(:,1), 2),  [0 0 5 0 0; zeros(4, 5)])
+%!assert (diag (diag ([5, 2, 3])(:,1), -2), [[0 0 5 0 0]', zeros(5, 4)])
+
 ## Test non-square size
 %!assert (diag ([1,2,3], 6, 3), [1 0 0; 0 2 0; 0 0 3; 0 0 0; 0 0 0; 0 0 0])
 %!assert (diag (1, 2, 3), [1,0,0; 0,0,0]);
 %!assert (diag ({1}, 2, 3), {1,[],[]; [],[],[]});
 %!assert (diag ({1,2}, 3, 4), {1,[],[],[]; [],2,[],[]; [],[],[],[]});
 
 %% Test input validation
 %!error <Invalid call to diag> diag ()
@@ -4106,63 +4111,63 @@ either \"double\" or \"single\".\n\
 {
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin == 1 && ! args(0).is_string ())
     {
       if (args(0).is_single_type ())
         {
-          float val = args(0).float_value ();
+          Array<float> x = args(0).float_array_value ();
 
           if (! error_state)
-            {
-              val = ::fabsf (val);
-              if (xisnan (val) || xisinf (val))
-                retval = fill_matrix (octave_value ("single"),
-                                      lo_ieee_nan_value (),
-                                      lo_ieee_float_nan_value (), "eps");
-              else if (val < std::numeric_limits<float>::min ())
-                retval = fill_matrix (octave_value ("single"), 0e0,
-                                      powf (2.0, -149e0), "eps");
-              else
+            {              
+              Array<float> epsval (x.dims ());
+              
+              for (octave_idx_type i = 0; i < x.numel (); i++)
                 {
-                  int expon;
-                  frexpf (val, &expon);
-                  val = std::pow (static_cast <float> (2.0),
-                                  static_cast <float> (expon - 24));
-                  retval = fill_matrix (octave_value ("single"),
-                                        std::numeric_limits<double>::epsilon (),
-                                        val, "eps");
+                  float val = ::fabsf (x(i));
+                  if (xisnan (val) || xisinf (val))
+                    epsval(i) = lo_ieee_nan_value ();
+                  else if (val < std::numeric_limits<float>::min ())
+                    epsval(i) = powf (2.0, -149e0);                  
+                  else
+                    {
+                      int expon;
+                      frexpf (val, &expon);
+                      epsval(i) = std::pow (static_cast <float> (2.0),
+                                            static_cast <float> (expon - 24));
+                    }
                 }
+              retval = epsval;
             }
         }
       else
         {
-          double val = args(0).double_value ();
+          Array<double> x = args(0).array_value ();
 
           if (! error_state)
             {
-              val = ::fabs (val);
-              if (xisnan (val) || xisinf (val))
-                retval = fill_matrix (octave_value_list (),
-                                      lo_ieee_nan_value (),
-                                      lo_ieee_float_nan_value (), "eps");
-              else if (val < std::numeric_limits<double>::min ())
-                retval = fill_matrix (octave_value_list (),
-                                      pow (2.0, -1074e0), 0e0, "eps");
-              else
+              Array<double> epsval (x.dims ());
+
+              for (octave_idx_type i = 0; i < x.numel (); i++)
                 {
-                  int expon;
-                  frexp (val, &expon);
-                  val = std::pow (static_cast <double> (2.0),
-                                  static_cast <double> (expon - 53));
-                  retval = fill_matrix (octave_value_list (), val,
-                                        std::numeric_limits<float>::epsilon (),
-                                        "eps");
+                  double val = ::fabs (x(i));
+                  if (xisnan (val) || xisinf (val))
+                    epsval(i) = lo_ieee_nan_value ();
+                  else if (val < std::numeric_limits<double>::min ())
+                    epsval(i) = pow (2.0, -1074e0);
+                  else
+                    {
+                      int expon;
+                      frexp (val, &expon);
+                      epsval(i) = std::pow (static_cast <double> (2.0),
+                                            static_cast <double> (expon - 53));
+                    }
+                  retval = epsval;
                 }
             }
         }
     }
   else
     retval = fill_matrix (args, std::numeric_limits<double>::epsilon (),
                           std::numeric_limits<float>::epsilon (), "eps");
 
@@ -4174,25 +4179,30 @@ either \"double\" or \"single\".\n\
 %!assert (eps (1), 2^(-52))
 %!assert (eps (2), 2^(-51))
 %!assert (eps (realmax), 2^971)
 %!assert (eps (0), 2^(-1074))
 %!assert (eps (realmin/2), 2^(-1074))
 %!assert (eps (realmin/16), 2^(-1074))
 %!assert (eps (Inf), NaN)
 %!assert (eps (NaN), NaN)
+%!assert (eps ([1/2 1 2 realmax 0 realmin/2 realmin/16 Inf NaN]), 
+%!             [2^(-53) 2^(-52) 2^(-51) 2^971 2^(-1074) 2^(-1074) 2^(-1074) NaN NaN])
 %!assert (eps (single (1/2)), single (2^(-24)))
 %!assert (eps (single (1)), single (2^(-23)))
 %!assert (eps (single (2)), single (2^(-22)))
 %!assert (eps (realmax ("single")), single (2^104))
 %!assert (eps (single (0)), single (2^(-149)))
 %!assert (eps (realmin ("single")/2), single (2^(-149)))
 %!assert (eps (realmin ("single")/16), single (2^(-149)))
 %!assert (eps (single (Inf)), single (NaN))
 %!assert (eps (single (NaN)), single (NaN))
+%!assert (eps (single ([1/2 1 2 realmax("single") 0 realmin("single")/2 realmin("single")/16 Inf NaN])), 
+%!             single ([2^(-24) 2^(-23) 2^(-22) 2^104 2^(-149) 2^(-149) 2^(-149) NaN NaN]))
+
 */
 
 DEFUN (pi, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} pi\n\
 @deftypefnx {Built-in Function} {} pi (@var{n})\n\
 @deftypefnx {Built-in Function} {} pi (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} pi (@var{n}, @var{m}, @var{k}, @dots{})\n\
@@ -6199,17 +6209,17 @@ ordered lists.\n\
 %! [v, i] = sort (a);
 %! assert (i, [1, 4, 2, 5, 3]);
 
 %!error sort ()
 %!error sort (1, 2, 3, 4)
 */
 
 // Sort the rows of the matrix @var{a} according to the order
-// specified by @var{mode}, which can either be `ascend' or `descend'
+// specified by @var{mode}, which can either be 'ascend' or 'descend'
 // and return the index vector corresponding to the sort order.
 //
 // This function does not yet support sparse matrices.
 
 DEFUN (__sort_rows_idx__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __sort_rows_idx__ (@var{a}, @var{mode})\n\
 Undocumented internal function.\n\
@@ -7230,32 +7240,18 @@ endfor\n\
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
-bool do_base64_encode (const char * inc, const size_t inlen, char *& out)
-{  
-  bool ret = false;
-  size_t outlen = base64_encode_alloc (inc, inlen, &out);
-  
-  if (! out && outlen == 0 && inlen != 0)
-    error ("base64_encode: input array too large");
-  else if (! out)
-    error ("base64_encode: memory allocation error");
-  else
-    ret = true;
-
-  return ret;
-}
-
-DEFUN (base64_encode, args, , "-*- texinfo -*-\n\
+DEFUN (base64_encode, args, ,
+  "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{s} =} base64_encode (@var{x})\n\
 Encode a double matrix or array @var{x} into the base64 format string\n\
 @var{s}.\n\
 \n\
 @seealso{base64_decode}\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -7277,17 +7273,17 @@ Encode a double matrix or array @var{x} 
             {                                                           \
               const X##NDArray in = args(0).  X## _array_value ();      \
               size_t inlen =                                            \
                 in.numel () * sizeof (X## _t) / sizeof (char);          \
               const char* inc =                                         \
                 reinterpret_cast<const char*> (in.data ());             \
               char* out;                                                \
               if (! error_state                                         \
-                  && do_base64_encode (inc, inlen, out))                \
+                  && octave_base64_encode (inc, inlen, &out))          \
                 retval(0) = octave_value (out);                         \
             }
                                           
           MAKE_INT_BRANCH(int8)
           else MAKE_INT_BRANCH(int16)
           else MAKE_INT_BRANCH(int32)
           else MAKE_INT_BRANCH(int64)
           else MAKE_INT_BRANCH(uint8)
@@ -7303,29 +7299,29 @@ Encode a double matrix or array @var{x} 
         {
           const Array<float> in = args(0).float_array_value ();
           size_t inlen;
           inlen = in.numel () * sizeof (float) / sizeof (char); 
           const char*  inc;
           inc = reinterpret_cast<const char*> (in.data ());  
           char* out;
           if (! error_state 
-              && do_base64_encode (inc, inlen, out))
+              && octave_base64_encode (inc, inlen, &out))
             retval(0) = octave_value (out);
         }                 
       else
         {
           const Array<double> in = args(0).array_value ();
           size_t inlen;
           inlen = in.numel () * sizeof (double) / sizeof (char); 
           const char*  inc;
           inc = reinterpret_cast<const char*> (in.data ());   
           char* out;
           if (! error_state 
-              && do_base64_encode (inc, inlen, out))
+              && octave_base64_encode (inc, inlen, &out))
             retval(0) = octave_value (out);
         }
     }  
   return retval;
 }
 
 /*
 %!assert (base64_encode (single (pi)), "2w9JQA==")
@@ -7337,81 +7333,60 @@ Encode a double matrix or array @var{x} 
 
 %!error base64_encode ()
 %!error base64_encode (1,2)
 %!error base64_encode ("A string")
 %!error base64_encode ({"A cell array"})
 %!error base64_encode (struct ())
 */
 
-DEFUN (base64_decode, args, , "-*- texinfo -*-\n\
+DEFUN (base64_decode, args, ,
+  "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{x} =} base64_decode (@var{s})\n\
 @deftypefnx {Built-in Function} {@var{x} =} base64_decode (@var{s}, @var{dims})\n\
-Decode the double matrix or array @var{x} from the base64 format string\n\
+Decode the double matrix or array @var{x} from the base64 encoded string\n\
 @var{s}.  The optional input parameter @var{dims} should be a vector\n\
 containing the dimensions of the decoded array.\n\
 @seealso{base64_encode}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   else
     {
-      dim_vector new_dims;
-      Array<double> res;
+      dim_vector dims;
 
       if (nargin > 1)
         {
-          const Array<octave_idx_type> new_size =
+          const Array<octave_idx_type> size =
             args(1).octave_idx_type_vector_value ();
+
           if (! error_state)
             {
-              new_dims = dim_vector::alloc (new_size.length ());
-              for (octave_idx_type i = 0; i < new_size.length (); i++)
-                new_dims(i) = new_size(i);
+              dims = dim_vector::alloc (size.length ());
+              for (octave_idx_type i = 0; i < size.length (); i++)
+                dims(i) = size(i);
             }
         }
 
-      const std::string in = args(0).string_value ();
+      const std::string str = args(0).string_value ();
 
       if (! error_state)
         {
-          const char *inc = &(in[0]);
-          char *out;
-          size_t inlen = in.length (), outlen;
-
-          bool ok = base64_decode_alloc (inc, inlen, &out, &outlen);
-
-          if (! ok)
-            error ("base64_decode: input was not valid base64");
-          else if (! out)
-            error ("base64_decode: memory allocation error");
-          else
-            {
-              if ((outlen % (sizeof (double) / sizeof (char))) != 0)
-                error ("base64_decode: incorrect input size");
-              else
-                {
-                  octave_idx_type l;
-                  l = (outlen * sizeof (char)) / sizeof (double);
-                  res.resize1 (l);
-                  double *dout = reinterpret_cast<double*> (out);
-                  std::copy (dout, dout + l, res.fortran_vec ());
-
-                  if (nargin > 1)
-                    retval(0) = octave_value (res).reshape (new_dims);
-                  else
-                    retval(0) = octave_value (res);
-                }
-            }
-        }
+          Array<double> res = octave_base64_decode (str);
+
+          if (nargin > 1)
+            res = res.reshape (dims);
+
+          retval = res;
+        }        
     }
 
   return retval; 
 }
 
 /*
 %!assert (base64_decode (base64_encode (pi)), pi)
 %!
diff --git a/libinterp/interpfcn/debug.cc b/libinterp/interpfcn/debug.cc
--- a/libinterp/interpfcn/debug.cc
+++ b/libinterp/interpfcn/debug.cc
@@ -779,17 +779,17 @@ do_dbtype (std::ostream& os, const std::
                 {
                   line++;
                   if (line >= start && line <= end)
                     os << line << "\t";
                 }
             }
         }
       else
-        os << "dbtype: unable to open `" << ff << "' for reading!\n";
+        os << "dbtype: unable to open '" << ff << "' for reading!\n";
     }
   else
     os << "dbtype: unknown function " << name << "\n";
 
   os.flush ();
 }
 
 DEFUN (dbtype, args, ,
diff --git a/libinterp/interpfcn/debug.h b/libinterp/interpfcn/debug.h
--- a/libinterp/interpfcn/debug.h
+++ b/libinterp/interpfcn/debug.h
@@ -124,11 +124,11 @@ private:
 
   void do_remove_all_breakpoints (void);
 
   fname_line_map do_get_breakpoint_list (const octave_value_list& fname_list);
 
   bool do_have_breakpoints (void) { return (! bp_set.empty ()); }
 };
 
-std::string get_file_line (const std::string& fname, size_t line);
+extern std::string get_file_line (const std::string& fname, size_t line);
 
 #endif
diff --git a/libinterp/interpfcn/defaults.cc b/libinterp/interpfcn/defaults.cc
--- a/libinterp/interpfcn/defaults.cc
+++ b/libinterp/interpfcn/defaults.cc
@@ -88,16 +88,18 @@ static std::string VEXEC_PATH;
 // Name of the editor to be invoked by the edit_history command.
 std::string VEDITOR;
 
 static std::string VIMAGE_PATH;
 
 std::string Vlocal_site_defaults_file;
 std::string Vsite_defaults_file;
 
+std::string Vbuilt_in_docstrings_file;
+
 std::string
 subst_octave_home (const std::string& s)
 {
   std::string retval;
 
   std::string prefix = OCTAVE_PREFIX;
 
   retval = s;
@@ -289,52 +291,64 @@ set_image_path (const std::string& path)
 
   if (! tpath.empty ())
     VIMAGE_PATH += dir_path::path_sep_str () + tpath;
 }
 
 static void
 set_default_doc_cache_file (void)
 {
-  std::string def_file = subst_octave_home (OCTAVE_DOC_CACHE_FILE);
+  if (Vdoc_cache_file.empty ())
+    {
+      std::string def_file = subst_octave_home (OCTAVE_DOC_CACHE_FILE);
 
-  std::string env_file = octave_env::getenv ("OCTAVE_DOC_CACHE_FILE");
+      std::string env_file = octave_env::getenv ("OCTAVE_DOC_CACHE_FILE");
 
-  Vdoc_cache_file = env_file.empty () ? def_file : env_file;
+      Vdoc_cache_file = env_file.empty () ? def_file : env_file;
+    }
 }
 
 static void
 set_default_texi_macros_file (void)
 {
-  std::string def_file = subst_octave_home (OCTAVE_TEXI_MACROS_FILE);
+  if (Vtexi_macros_file.empty ())
+    {
+      std::string def_file = subst_octave_home (OCTAVE_TEXI_MACROS_FILE);
 
-  std::string env_file = octave_env::getenv ("OCTAVE_TEXI_MACROS_FILE");
+      std::string env_file = octave_env::getenv ("OCTAVE_TEXI_MACROS_FILE");
 
-  Vtexi_macros_file = env_file.empty () ? def_file : env_file;
+      Vtexi_macros_file = env_file.empty () ? def_file : env_file;
+    }
 }
 
 static void
 set_default_info_file (void)
 {
-  std::string std_info_file = subst_octave_home (OCTAVE_INFOFILE);
+  if (Vinfo_file.empty ())
+    {
+      std::string std_info_file = subst_octave_home (OCTAVE_INFOFILE);
 
-  std::string oct_info_file = octave_env::getenv ("OCTAVE_INFO_FILE");
+      std::string oct_info_file = octave_env::getenv ("OCTAVE_INFO_FILE");
 
-  Vinfo_file = oct_info_file.empty () ? std_info_file : oct_info_file;
+      Vinfo_file = oct_info_file.empty () ? std_info_file : oct_info_file;
+    }
 }
 
 static void
 set_default_info_prog (void)
 {
-  std::string oct_info_prog = octave_env::getenv ("OCTAVE_INFO_PROGRAM");
+  if (Vinfo_program.empty ())
+    {
+      std::string oct_info_prog = octave_env::getenv ("OCTAVE_INFO_PROGRAM");
 
-  if (oct_info_prog.empty ())
-    Vinfo_program = "info";
-  else
-    Vinfo_program = std::string (oct_info_prog);
+      if (oct_info_prog.empty ())
+        Vinfo_program = "info";
+      else
+        Vinfo_program = std::string (oct_info_prog);
+    }
 }
 
 static void
 set_default_editor (void)
 {
   VEDITOR = "emacs";
 
   std::string env_editor = octave_env::getenv ("EDITOR");
@@ -366,16 +380,31 @@ set_site_defaults_file (void)
     {
       Vsite_defaults_file = subst_octave_home (OCTAVE_STARTUPFILEDIR);
       Vsite_defaults_file.append ("/octaverc");
     }
   else
     Vsite_defaults_file = sf;
 }
 
+static void
+set_built_in_docstrings_file (void)
+{
+  if (Vbuilt_in_docstrings_file.empty ())
+    {
+      std::string df = octave_env::getenv ("OCTAVE_BUILT_IN_DOCSTRINGS_FILE");
+
+      if (df.empty ())
+        Vbuilt_in_docstrings_file
+          = Voct_etc_dir + file_ops::dir_sep_str () + "built-in-docstrings";
+      else
+        Vbuilt_in_docstrings_file = df;
+    }
+}
+
 void
 install_defaults (void)
 {
   // OCTAVE_HOME must be set first!
 
   set_octave_home ();
 
   set_default_info_dir ();
@@ -419,16 +448,18 @@ install_defaults (void)
 
   set_default_info_prog ();
 
   set_default_editor ();
 
   set_local_site_defaults_file ();
 
   set_site_defaults_file ();
+
+  set_built_in_docstrings_file ();
 }
 
 DEFUN (EDITOR, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} EDITOR ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} EDITOR (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} EDITOR (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the editor to\n\
diff --git a/libinterp/interpfcn/defaults.in.h b/libinterp/interpfcn/defaults.in.h
--- a/libinterp/interpfcn/defaults.in.h
+++ b/libinterp/interpfcn/defaults.in.h
@@ -171,50 +171,52 @@ along with Octave; see the file COPYING.
 #ifndef OCTAVE_STARTUPFILEDIR
 #define OCTAVE_STARTUPFILEDIR %OCTAVE_STARTUPFILEDIR%
 #endif
 
 #ifndef OCTAVE_RELEASE
 #define OCTAVE_RELEASE %OCTAVE_RELEASE%
 #endif
 
-extern std::string Voctave_home;
+extern OCTINTERP_API std::string Voctave_home;
 
-extern std::string Vbin_dir;
-extern std::string Vinfo_dir;
-extern std::string Vdata_dir;
-extern std::string Vlibexec_dir;
-extern std::string Varch_lib_dir;
-extern std::string Vlocal_arch_lib_dir;
-extern std::string Vlocal_ver_arch_lib_dir;
+extern OCTINTERP_API std::string Vbin_dir;
+extern OCTINTERP_API std::string Vinfo_dir;
+extern OCTINTERP_API std::string Vdata_dir;
+extern OCTINTERP_API std::string Vlibexec_dir;
+extern OCTINTERP_API std::string Varch_lib_dir;
+extern OCTINTERP_API std::string Vlocal_arch_lib_dir;
+extern OCTINTERP_API std::string Vlocal_ver_arch_lib_dir;
 
-extern std::string Vlocal_ver_oct_file_dir;
-extern std::string Vlocal_api_oct_file_dir;
-extern std::string Vlocal_oct_file_dir;
+extern OCTINTERP_API std::string Vlocal_ver_oct_file_dir;
+extern OCTINTERP_API std::string Vlocal_api_oct_file_dir;
+extern OCTINTERP_API std::string Vlocal_oct_file_dir;
 
-extern std::string Vlocal_ver_fcn_file_dir;
-extern std::string Vlocal_api_fcn_file_dir;
-extern std::string Vlocal_fcn_file_dir;
+extern OCTINTERP_API std::string Vlocal_ver_fcn_file_dir;
+extern OCTINTERP_API std::string Vlocal_api_fcn_file_dir;
+extern OCTINTERP_API std::string Vlocal_fcn_file_dir;
 
-extern std::string Voct_etc_dir;
+extern OCTINTERP_API std::string Voct_etc_dir;
 
-extern std::string Voct_file_dir;
-extern std::string Vfcn_file_dir;
+extern OCTINTERP_API std::string Voct_file_dir;
+extern OCTINTERP_API std::string Vfcn_file_dir;
 
-extern std::string Vimage_dir;
+extern OCTINTERP_API std::string Vimage_dir;
 
 // Name of the editor to be invoked by the edit_history command.
-extern std::string VEDITOR;
+extern OCTINTERP_API std::string VEDITOR;
 
-extern std::string Vlocal_site_defaults_file;
-extern std::string Vsite_defaults_file;
+extern OCTINTERP_API std::string Vlocal_site_defaults_file;
+extern OCTINTERP_API std::string Vsite_defaults_file;
+
+extern OCTINTERP_API std::string Vbuilt_in_docstrings_file;
 
 // Name of the FFTW wisdom program.
 extern OCTINTERP_API std::string Vfftw_wisdom_program;
 
-extern std::string subst_octave_home (const std::string&);
+extern OCTINTERP_API std::string subst_octave_home (const std::string&);
 
-extern void install_defaults (void);
+extern OCTINTERP_API void install_defaults (void);
 
-extern void set_exec_path (const std::string& path = std::string ());
-extern void set_image_path (const std::string& path = std::string ());
+extern OCTINTERP_API void set_exec_path (const std::string& path = std::string ());
+extern OCTINTERP_API void set_image_path (const std::string& path = std::string ());
 
 #endif
diff --git a/libinterp/interpfcn/defun.cc b/libinterp/interpfcn/defun.cc
--- a/libinterp/interpfcn/defun.cc
+++ b/libinterp/interpfcn/defun.cc
@@ -63,17 +63,17 @@ print_usage (const std::string& name)
   feval ("print_usage", octave_value (name), 0);
 }
 
 void
 check_version (const std::string& version, const std::string& fcn)
 {
   if (version != OCTAVE_API_VERSION)
     {
-      error ("API version %s found in .oct file function `%s'\n"
+      error ("API version %s found in .oct file function '%s'\n"
              "       does not match the running Octave (API version %s)\n"
              "       this can lead to incorrect results or other failures\n"
              "       you can fix this problem by recompiling this .oct file",
              version.c_str (), fcn.c_str (), OCTAVE_API_VERSION);
     }
 }
 
 // Install variables and functions in the symbol tables.
diff --git a/libinterp/interpfcn/defun.h b/libinterp/interpfcn/defun.h
--- a/libinterp/interpfcn/defun.h
+++ b/libinterp/interpfcn/defun.h
@@ -39,17 +39,17 @@ along with Octave; see the file COPYING.
 //   nargout_name is the name of the int variable used to pass the
 //     number of output arguments this function is expected to produce.
 //
 //   doc is the simple help text for the function.
 
 #define DEFUN(name, args_name, nargout_name, doc) \
   DEFUN_INTERNAL (name, args_name, nargout_name, doc)
 
-// This one can be used when `name' cannot be used directly (if it is
+// This one can be used when 'name' cannot be used directly (if it is
 // already defined as a macro).  In that case, name is already a
 // quoted string, and the internal name of the function must be passed
 // too (the convention is to use a prefix of "F", so "foo" becomes "Ffoo").
 
 #define DEFUNX(name, fname, args_name, nargout_name, doc) \
   DEFUNX_INTERNAL (name, fname, args_name, nargout_name, doc)
 
 // This is a function with a name that can't be hidden by a variable.
diff --git a/libinterp/interpfcn/error.cc b/libinterp/interpfcn/error.cc
--- a/libinterp/interpfcn/error.cc
+++ b/libinterp/interpfcn/error.cc
@@ -105,17 +105,17 @@ int error_state = 0;
 //
 //    0: no warning
 //    1: a warning has occurred
 //
 int warning_state = 0;
 
 // Tell the error handler whether to print messages, or just store
 // them for later.  Used for handling errors in eval() and
-// the `unwind_protect' statement.
+// the 'unwind_protect' statement.
 int buffer_error_messages = 0;
 
 // TRUE means error messages are turned off.
 bool discard_error_messages = false;
 
 // TRUE means warning messages are turned off.
 bool discard_warning_messages = false;
 
@@ -916,20 +916,20 @@ location of the error.  Typically @var{e
                                 pr_where_1 ("error: near line %d", l);
                             }
                         }
                       else
                         {
                           if (l > 0)
                             {
                               if (c > 0)
-                                pr_where_1 ("error: called from `%s' near line %d, column %d",
+                                pr_where_1 ("error: called from '%s' near line %d, column %d",
                                             nm.c_str (), l, c);
                               else
-                                pr_where_1 ("error: called from `%d' near line %d", nm.c_str (), l);
+                                pr_where_1 ("error: called from '%d' near line %d", nm.c_str (), l);
                             }
                         }
                     }
                   else
                     {
                       if (nm.empty ())
                         {
                           if (l > 0)
@@ -941,20 +941,20 @@ location of the error.  Typically @var{e
                                 pr_where_1 ("error: in file %s near line %d", file.c_str (), l);
                             }
                         }
                       else
                         {
                           if (l > 0)
                             {
                               if (c > 0)
-                                pr_where_1 ("error: called from `%s' in file %s near line %d, column %d",
+                                pr_where_1 ("error: called from '%s' in file %s near line %d, column %d",
                                             nm.c_str (), file.c_str (), l, c);
                               else
-                                pr_where_1 ("error: called from `%d' in file %s near line %d", nm.c_str (), file.c_str (), l);
+                                pr_where_1 ("error: called from '%d' in file %s near line %d", nm.c_str (), file.c_str (), l);
                             }
                         }
                     }
                 }
             }
           else
             error ("rethrow: ERR structure must contain the fields 'message and 'identifier'");
         }
@@ -1136,51 +1136,116 @@ Use a second backslash to stop interpola
 
       handle_message (error_with_id, id.c_str (), "unspecified error",
                       nargs, have_fmt);
     }
 
   return retval;
 }
 
+static octave_scalar_map
+warning_query (const std::string& id_arg)
+{
+  octave_scalar_map retval;
+
+  std::string id = id_arg;
+
+  if (id == "last")
+    id = Vlast_warning_id;
+
+  Cell ident = warning_options.contents ("identifier");
+  Cell state = warning_options.contents ("state");
+
+  octave_idx_type nel = ident.numel ();
+
+  bool found = false;
+
+  std::string val;
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    {
+      if (ident(i).string_value () == id)
+        {
+          val = state(i).string_value ();
+          found = true;
+          break;
+        }
+    }
+
+  if (! found)
+    {
+      for (octave_idx_type i = 0; i < nel; i++)
+        {
+          if (ident(i).string_value () == "all")
+            {
+              val = state(i).string_value ();
+              found = true;
+              break;
+            }
+        }
+    }
+
+  if (found)
+    {
+      retval.assign ("identifier", id);
+      retval.assign ("state", val);
+    }
+  else
+    error ("warning: unable to find default warning state!");
+
+  return retval;
+}
+
 DEFUN (warning, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} warning (@var{template}, @dots{})\n\
 @deftypefnx {Built-in Function} {} warning (@var{id}, @var{template}, @dots{})\n\
 @deftypefnx {Built-in Function} {} warning (\"on\", @var{id})\n\
 @deftypefnx {Built-in Function} {} warning (\"off\", @var{id})\n\
 @deftypefnx {Built-in Function} {} warning (\"query\", @var{id})\n\
 @deftypefnx {Built-in Function} {} warning (\"error\", @var{id})\n\
+@deftypefnx {Built-in Function} {} warning (@var{state}, @var{id}, \"local\")\n\
 Format the optional arguments under the control of the template string\n\
 @var{template} using the same rules as the @code{printf} family of\n\
 functions (@pxref{Formatted Output}) and print the resulting message\n\
 on the @code{stderr} stream.  The message is prefixed by the character\n\
 string @samp{warning: }.\n\
 You should use this function when you want to notify the user\n\
 of an unusual condition, but only when it makes sense for your program\n\
 to go on.\n\
 \n\
 The optional message identifier allows users to enable or disable\n\
-warnings tagged by @var{id}.  The special identifier @samp{\"all\"} may\n\
-be used to set the state of all warnings.\n\
+warnings tagged by @var{id}.  A message identifier is of the form\n\
+\"NAMESPACE:WARNING-NAME\".  Octave's own warnings use the \"Octave\"\n\
+namespace (@pxref{doc-warning_ids}).  The special identifier @samp{\"all\"}\n\
+may be used to set the state of all warnings.\n\
 \n\
 If the first argument is @samp{\"on\"} or @samp{\"off\"}, set the state\n\
 of a particular warning using the identifier @var{id}.  If the first\n\
 argument is @samp{\"query\"}, query the state of this warning instead.\n\
 If the identifier is omitted, a value of @samp{\"all\"} is assumed.  If\n\
 you set the state of a warning to @samp{\"error\"}, the warning named by\n\
 @var{id} is handled as if it were an error instead.  So, for example, the\n\
 following handles all warnings as errors:\n\
 \n\
 @example\n\
 @group\n\
 warning (\"error\");\n\
 @end group\n\
 @end example\n\
 \n\
+If the state is @samp{\"on\"}, @samp{\"off\"}, or @samp{\"error\"}\n\
+and the third argument is @samp{\"local\"}, then the warning state\n\
+will be set temporarily, until the end of the current function.\n\
+Changes to warning states that are set locally affect the current\n\
+function and all functions called from the current scope.  The\n\
+previous warning state is restored on return from the current\n\
+function.  The \"local\" option is ignored if used in the top-level\n\
+workspace.\n\
+\n\
 Implementation Note: For compatibility with @sc{matlab}, escape\n\
 sequences (e.g., \"\\n\" => newline) are processed in @var{template}\n\
 regardless of whether @var{template} has been defined within single quotes\n\
 as long as there are two or more input arguments.\n\
 Use a second backslash to stop interpolation of the escape sequence (e.g.,\n\
 \"\\\\n\") or use the @code{regexptranslate} function.\n\
 @seealso{warning_ids, lastwarn, error}\n\
 @end deftypefn")
@@ -1196,23 +1261,103 @@ Use a second backslash to stop interpola
     {
       string_vector argv = args.make_argv ("warning");
 
       if (! error_state)
         {
           std::string arg1 = argv(1);
           std::string arg2 = "all";
 
-          if (argc == 3)
+          if (argc >= 3)
             arg2 = argv(2);
 
           if (arg1 == "on" || arg1 == "off" || arg1 == "error")
             {
               octave_map old_warning_options = warning_options;
 
+              if (argc == 4 && argv(3) == "local"
+                  && ! symbol_table::at_top_level ())
+                {
+                  symbol_table::scope_id scope
+                    = octave_call_stack::current_scope ();
+
+                  symbol_table::context_id context
+                    = octave_call_stack::current_context ();
+
+                  octave_scalar_map val = warning_query (arg2);
+
+                  octave_value curr_state = val.contents ("state");
+
+                  // FIXME -- this might be better with a dictionary
+                  // object.
+
+                  octave_value curr_warning_states
+                    = symbol_table::varval (".saved_warning_states.",
+                                            scope, context);
+
+                  octave_map m;
+
+                  if (curr_warning_states.is_defined ())
+                    m = curr_warning_states.map_value ();
+                  else
+                    {
+                      string_vector fields (2);
+
+                      fields(0) = "identifier";
+                      fields(1) = "state";
+
+                      m = octave_map (dim_vector (0, 1), fields);
+                    }
+
+                  if (error_state)
+                    panic_impossible ();
+
+                  Cell ids = m.contents ("identifier");
+                  Cell states = m.contents ("state");
+
+                  octave_idx_type nel = states.numel ();
+                  bool found = false;
+                  octave_idx_type i;
+                  for (i = 0; i < nel; i++)
+                    {
+                      std::string id = ids(i).string_value ();
+
+                      if (error_state)
+                        panic_impossible ();
+
+                      if (id == arg2)
+                        {
+                          states(i) = curr_state;
+                          found = true;
+                          break;
+                        }
+                    }
+
+                  if (! found)
+                    {
+                      m.resize (dim_vector (nel+1, 1));
+
+                      ids.resize (dim_vector (nel+1, 1));
+                      states.resize (dim_vector (nel+1, 1));
+
+                      ids(nel) = arg2;
+                      states(nel) = curr_state;
+                    }
+
+                  m.contents ("identifier") = ids;
+                  m.contents ("state") = states;
+
+                  symbol_table::varref
+                    (".saved_warning_states.", scope, context) = m;
+
+                  // Now ignore the "local" argument and continue to
+                  // handle the current setting.
+                  argc--;
+                }
+                  
               if (arg2 == "all")
                 {
                   octave_map tmp;
 
                   Cell id (1, 1);
                   Cell st (1, 1);
 
                   id(0) = arg2;
@@ -1364,64 +1509,17 @@ Use a second backslash to stop interpola
                   else if (arg2 == "verbose")
                     tmp.assign ("state", Vverbose_warning ? "on" : "off");
                   else
                     tmp.assign ("state", Vquiet_warning ? "on" : "off");
 
                   retval = tmp;
                 }
               else
-                {
-                  if (arg2 == "last")
-                    arg2 = Vlast_warning_id;
-
-                  Cell ident = warning_options.contents ("identifier");
-                  Cell state = warning_options.contents ("state");
-
-                  octave_idx_type nel = ident.numel ();
-
-                  bool found = false;
-
-                  std::string val;
-
-                  for (octave_idx_type i = 0; i < nel; i++)
-                    {
-                      if (ident(i).string_value () == arg2)
-                        {
-                          val = state(i).string_value ();
-                          found = true;
-                          break;
-                        }
-                    }
-
-                  if (! found)
-                    {
-                      for (octave_idx_type i = 0; i < nel; i++)
-                        {
-                          if (ident(i).string_value () == "all")
-                            {
-                              val = state(i).string_value ();
-                              found = true;
-                              break;
-                            }
-                        }
-                    }
-
-                  if (found)
-                    {
-                      octave_scalar_map tmp;
-
-                      tmp.assign ("identifier", arg2);
-                      tmp.assign ("state", val);
-
-                      retval = tmp;
-                    }
-                  else
-                    error ("warning: unable to find default warning state!");
-                }
+                retval = warning_query (arg2);
 
               done = true;
             }
         }
     }
   else if (argc == 1)
     {
       retval = warning_options;
@@ -1436,17 +1534,17 @@ Use a second backslash to stop interpola
 
       if (arg.is_map ())
         {
           octave_map m = arg.map_value ();
 
           if (m.contains ("identifier") && m.contains ("state"))
             warning_options = m;
           else
-            error ("warning: expecting structure with fields `identifier' and `state'");
+            error ("warning: expecting structure with fields 'identifier' and 'state'");
 
           done = true;
 
           if (nargout > 0)
             retval = old_warning_options;
         }
     }
 
diff --git a/libinterp/interpfcn/error.h b/libinterp/interpfcn/error.h
--- a/libinterp/interpfcn/error.h
+++ b/libinterp/interpfcn/error.h
@@ -25,17 +25,17 @@ along with Octave; see the file COPYING.
 
 #include <cstdarg>
 #include <string>
 
 class octave_value_list;
 class unwind_protect;
 
 #define panic_impossible() \
-  panic ("impossible state reached in file `%s' at line %d", \
+  panic ("impossible state reached in file '%s' at line %d", \
          __FILE__, __LINE__)
 
 extern OCTINTERP_API void reset_error_handler (void);
 
 extern OCTINTERP_API int warning_enabled (const std::string& id);
 
 extern OCTINTERP_API void vmessage (const char *name, const char *fmt, va_list args);
 extern OCTINTERP_API void message (const char *name, const char *fmt, ...);
@@ -117,17 +117,17 @@ extern OCTINTERP_API bool Vdebug_on_warn
 // Current error state.
 extern OCTINTERP_API int error_state;
 
 // Current warning state.
 extern OCTINTERP_API int warning_state;
 
 // Tell the error handler whether to print messages, or just store
 // them for later.  Used for handling errors in eval() and
-// the `unwind_protect' statement.
+// the 'unwind_protect' statement.
 extern OCTINTERP_API int buffer_error_messages;
 
 // TRUE means error messages are turned off.
 extern OCTINTERP_API bool discard_error_messages;
 
 // TRUE means warning messages are turned off.
 extern OCTINTERP_API bool discard_warning_messages;
 
diff --git a/libinterp/interpfcn/file-io.cc b/libinterp/interpfcn/file-io.cc
--- a/libinterp/interpfcn/file-io.cc
+++ b/libinterp/interpfcn/file-io.cc
@@ -1159,17 +1159,17 @@ complete description of the syntax of th
                   // old val for restoring afterwards.
                   oldloc = 
                     os.imbue (std::locale (args(2).string_value ().c_str ()));
 
                 }
               catch (std::runtime_error)
                 {
                   // Display a warning if the specified locale is unknown
-                  warning ("fscanf: invalid locale. Try `locale -a' for a list of supported values.");
+                  warning ("fscanf: invalid locale. Try 'locale -a' for a list of supported values.");
                   oldloc = std::locale::classic ();
                 }
               retval = os.oscanf (args(1), who);
               os.imbue (oldloc);
             }
           else
             ::error ("%s: format TEMPLATE must be a string", who.c_str ());
         }
@@ -1269,17 +1269,17 @@ is returned in @var{pos}.\n\
                   // locale afterwards.
                   try
                     {  
                       os.imbue (std::locale (args(2).string_value ().c_str ()));
                     }
                   catch (std::runtime_error)
                     {
                       // Display a warning if the specified locale is unknown
-                      warning ("sscanf: invalid locale. Try `locale -a' for a list of supported values.");
+                      warning ("sscanf: invalid locale. Try 'locale -a' for a list of supported values.");
                     }
                   retval = os.oscanf (args(1), who);
                 }              
               else
                 ::error ("%s: format TEMPLATE must be a string", who.c_str ());
             }
           else
             ::error ("%s: unable to create temporary input buffer",
@@ -2044,18 +2044,17 @@ Return the file ID corresponding to a ne
 name created from @var{template}.  The last six characters of @var{template}\n\
 must be @code{XXXXXX} and these are replaced with a string that makes the\n\
 filename unique.  The file is then created with mode read/write and\n\
 permissions that are system dependent (on GNU/Linux systems, the permissions\n\
 will be 0600 for versions of glibc 2.0.7 and later).  The file is opened\n\
 in binary mode and with the @w{@code{O_EXCL}} flag.\n\
 \n\
 If the optional argument @var{delete} is supplied and is true,\n\
-the file will be deleted automatically when Octave exits, or when\n\
-the function @code{purge_tmp_files} is called.\n\
+the file will be deleted automatically when Octave exits.\n\
 \n\
 If successful, @var{fid} is a valid file ID, @var{name} is the name of\n\
 the file, and @var{msg} is an empty string.  Otherwise, @var{fid}\n\
 is -1, @var{name} is empty, and @var{msg} contains a system-dependent\n\
 error message.\n\
 @seealso{tmpfile, tmpnam, P_tmpdir}\n\
 @end deftypefn")
 {
diff --git a/libinterp/interpfcn/graphics.cc b/libinterp/interpfcn/graphics.cc
--- a/libinterp/interpfcn/graphics.cc
+++ b/libinterp/interpfcn/graphics.cc
@@ -37,16 +37,17 @@ along with Octave; see the file COPYING.
 #include <sstream>
 
 #include "cmd-edit.h"
 #include "file-ops.h"
 #include "file-stat.h"
 #include "oct-locbuf.h"
 #include "singleton-cleanup.h"
 
+#include "builtins.h"
 #include "cutils.h"
 #include "defun.h"
 #include "display.h"
 #include "error.h"
 #include "graphics.h"
 #include "input.h"
 #include "ov.h"
 #include "oct-obj.h"
@@ -1797,17 +1798,17 @@ property_list::set (const caseless_str& 
 
                   if (p != pval_map.end ())
                     pval_map.erase (p);
                 }
               else
                 pval_map[pname] = val;
             }
           else
-            error ("invalid %s property `%s'", pfx.c_str (), pname.c_str ());
+            error ("invalid %s property '%s'", pfx.c_str (), pname.c_str ());
         }
     }
 
   if (! error_state && offset == 0)
     error ("invalid default property specification");
 }
 
 octave_value
@@ -7775,17 +7776,17 @@ gh_manager::do_make_graphics_handle (con
       if (do_createfcn)
         go->get_properties ().execute_createfcn ();
 
       // Notify graphics toolkit.
       if (do_notify_toolkit)
         obj.initialize ();
     }
   else
-    error ("gh_manager::do_make_graphics_handle: invalid object type `%s'",
+    error ("gh_manager::do_make_graphics_handle: invalid object type '%s'",
            go_name.c_str ());
 
   return h;
 }
 
 graphics_handle
 gh_manager::do_make_figure_handle (double val, bool do_notify_toolkit)
 {
@@ -8197,17 +8198,17 @@ gh_manager::do_process_events (bool forc
 
   gh_manager::unlock ();
 
   if (events_executed)
     flush_octave_stdout ();
 
   if (Vdrawnow_requested && ! old_Vdrawnow_requested)
     {
-      feval ("drawnow");
+      Fdrawnow ();
 
       Vdrawnow_requested = false;
     }
 
   return 0;
 }
 
 void
@@ -9345,17 +9346,17 @@ gtk_manager::do_get_toolkit (void) const
             pl = loaded_toolkits.find (dtk);
 
           if (error_state || pl == loaded_toolkits.end ())
             error ("failed to load %s graphics toolkit", dtk.c_str ());
           else
             retval = pl->second;
         }
       else
-        error ("default graphics toolkit `%s' is not available!",
+        error ("default graphics toolkit '%s' is not available!",
                dtk.c_str ());
     }
   else
     retval = pl->second;
 
   return retval;
 }
 
@@ -9469,17 +9470,17 @@ undocumented.\n\
           if (args.length () == 1)
             {
               caseless_str val (args(0).string_value ());
 
               if (! error_state && val.compare ("expose"))
                 do_events = false;
               else
                 {
-                  error ("drawnow: invalid argument, expected `expose' as argument");
+                  error ("drawnow: invalid argument, expected 'expose' as argument");
                   return retval;
                 }
             }
 
           if (do_events)
             {
               gh_manager::unlock ();
 
@@ -9511,17 +9512,17 @@ undocumented.\n\
                       if (pos != std::string::npos)
                         {
                           std::string dirname = file.substr (0, pos+1);
 
                           file_stat fs (dirname);
 
                           if (! (fs && fs.is_dir ()))
                             {
-                              error ("drawnow: nonexistent directory `%s'",
+                              error ("drawnow: nonexistent directory '%s'",
                                      dirname.c_str ());
 
                               return retval;
                             }
                         }
                     }
 
                   mono = (args.length () >= 3 ? args(2).bool_value () : false);
@@ -9823,17 +9824,17 @@ addproperty (\"my_style\", gcf, \"lineli
                         {
                           property p = property::create (name, gh, type,
                                                          args.splice (0, 3));
 
                           if (! error_state)
                             go.get_properties ().insert_property (name, p);
                         }
                       else
-                        error ("addproperty: a `%s' property already exists in the graphics object",
+                        error ("addproperty: a '%s' property already exists in the graphics object",
                                name.c_str ());
                     }
                   else
                     error ("addproperty: invalid property TYPE, expected a string value");
                 }
               else
                 error ("addproperty: invalid graphics object (= %g)", h);
             }
@@ -10185,20 +10186,20 @@ In all cases, typing CTRL-C stops progra
             {
               caseless_str s = args(max_arg_index + 1).string_value ();
 
               if (! error_state)
                 {
                   if (s.compare ("timeout"))
                     timeout_index = max_arg_index + 1;
                   else
-                    error ("waitfor: invalid parameter `%s'", s.c_str ());
+                    error ("waitfor: invalid parameter '%s'", s.c_str ());
                 }
               else
-                error ("waitfor: invalid parameter, expected `timeout'");
+                error ("waitfor: invalid parameter, expected 'timeout'");
             }
 
           if (! error_state && timeout_index >= 0)
             {
               if (args.length () > (timeout_index + 1))
                 {
                   timeout = static_cast<int>
                     (args(timeout_index + 1).scalar_value ());
diff --git a/libinterp/interpfcn/graphics.in.h b/libinterp/interpfcn/graphics.in.h
--- a/libinterp/interpfcn/graphics.in.h
+++ b/libinterp/interpfcn/graphics.in.h
@@ -3245,28 +3245,28 @@ public:
     octave_value retval = default_properties.lookup (name);
 
     if (retval.is_undefined ())
       {
         // no default property found, use factory default
         retval = factory_properties.lookup (name);
 
         if (retval.is_undefined ())
-          error ("get: invalid default property `%s'", name.c_str ());
+          error ("get: invalid default property '%s'", name.c_str ());
       }
 
     return retval;
   }
 
   octave_value get_factory_default (const caseless_str& name) const
   {
     octave_value retval = factory_properties.lookup (name);
 
     if (retval.is_undefined ())
-      error ("get: invalid factory default property `%s'", name.c_str ());
+      error ("get: invalid factory default property '%s'", name.c_str ());
 
     return retval;
   }
 
   octave_value get_defaults (void) const
   {
     return default_properties.as_struct ("default");
   }
@@ -4805,16 +4805,18 @@ public:
         base_properties::adopt (h);
         update_limits (h);
       }
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
 
     BEGIN_PROPERTIES (hggroup)
+      string_property displayname , ""
+      radio_property erasemode , "{normal}|none|xor|background"
       // hidden properties for limit computation
       row_vector_property xlim hr , Matrix ()
       row_vector_property ylim hr , Matrix ()
       row_vector_property zlim hr , Matrix ()
       row_vector_property clim hr , Matrix ()
       row_vector_property alim hr , Matrix ()
       bool_property xliminclude h , "on"
       bool_property yliminclude h , "on"
diff --git a/libinterp/interpfcn/help.cc b/libinterp/interpfcn/help.cc
--- a/libinterp/interpfcn/help.cc
+++ b/libinterp/interpfcn/help.cc
@@ -917,16 +917,105 @@ raw_help (const std::string& nm, bool& s
   (raw_help_from_symbol_table (nm, h, w, symbol_found)
    || raw_help_from_file (nm, h, f, symbol_found)
    || raw_help_from_map (nm, h, operators_map, symbol_found)
    || raw_help_from_map (nm, h, keywords_map, symbol_found));
 
   return h;
 }
 
+
+DEFUN (built_in_docstrings_file, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn  {Built-in Function} {@var{val} =} built_in_docstrings_file ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} built_in_docstrings_file (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} built_in_docstrings_file (@var{new_val}, \"local\")\n\
+Query or set the internal variable that specifies the name of the\n\
+file containing docstrings for built-in Octave functions.\n\
+\n\
+Note that this variable is only used when Octave is initializing itself,\n\
+so setting it will have no effect.\n\
+@end deftypefn")
+{
+  return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (built_in_docstrings_file);
+}
+
+void
+install_built_in_docstrings (void)
+{
+  std::string fname = Vbuilt_in_docstrings_file;
+
+  std::ifstream file (fname.c_str (), std::ios::in | std::ios::binary);
+
+  if (file)
+    {
+      // Ignore header;
+      file.ignore (1000, 0x1f);
+
+      if (file.gcount () == 1000)
+        {
+          // We use std::cerr here instead of calling Octave's warning
+          // function because install_built_in_docstrings is called
+          // before the interpreter is initialized, so warning messages
+          // won't work properly.
+
+          std::cerr << "warning: is builtin-docstrings file corrupted?"
+                    << std::endl;
+          return;
+        }
+
+      // FIXME -- eliminate fixed buffer size.
+      size_t bufsize = 100000;
+
+      OCTAVE_LOCAL_BUFFER (char, buf, bufsize);
+
+      while (! file.eof ())
+        {
+          file.getline (buf, bufsize, 0x1f);
+
+          std::string tmp (buf);
+
+          size_t pos = tmp.find ('\n');
+
+          std::string fcn = tmp.substr (0, pos);
+
+          octave_value ov = symbol_table::find_built_in_function (fcn);
+
+          if (ov.is_defined ())
+            {
+              octave_function *fp = ov.function_value ();
+
+              if (fp)
+                {
+                  tmp = tmp.substr (pos+1);
+
+                  // Strip @c FILENAME which is part of current DOCSTRINGS
+                  // syntax.  This may disappear if a specific format for
+                  // docstring files is developed.
+                  while (tmp.length () > 2 && tmp[0] == '@' && tmp[1] == 'c')
+                    {
+                      pos = tmp.find ('\n');
+                      tmp = tmp.substr (pos+1);
+                    }
+
+                  fp->document (tmp);
+                }
+            }
+        }
+    }
+  else
+    {
+      // See note above about using std::cerr instead of warning.
+
+      std::cerr << "warning: docstring file '" << fname << "' not found"
+                << std::endl;
+    }
+
+}
+
 static void
 do_get_help_text (const std::string& name, std::string& text,
                   std::string& format)
 {
   bool symbol_found = false;
   text = raw_help (name, symbol_found);
 
   format = "Not found";
diff --git a/libinterp/interpfcn/help.h b/libinterp/interpfcn/help.h
--- a/libinterp/interpfcn/help.h
+++ b/libinterp/interpfcn/help.h
@@ -27,16 +27,18 @@ along with Octave; see the file COPYING.
 #include <string>
 
 class string_vector;
 
 extern string_vector make_name_list (void);
 
 extern OCTINTERP_API std::string raw_help (const std::string&, bool&);
 
+extern OCTINTERP_API void install_built_in_docstrings (void);
+
 // Name of the doc cache file specified on the command line.
 // (--doc-cache-file file)
 extern std::string Vdoc_cache_file;
 
 // Name of the file containing local Texinfo macros that are prepended
 // to doc strings before processing.
 // (--texi-macros-file)
 extern std::string Vtexi_macros_file;
diff --git a/libinterp/interpfcn/input.cc b/libinterp/interpfcn/input.cc
--- a/libinterp/interpfcn/input.cc
+++ b/libinterp/interpfcn/input.cc
@@ -417,17 +417,17 @@ octave_read (char *buf, unsigned max_siz
       status = 0;
     }
   else
     status = -1;
 
   return status;
 }
 
-// Fix things up so that input can come from file `name', printing a
+// Fix things up so that input can come from file 'name', printing a
 // warning if the file doesn't exist.
 
 FILE *
 get_input_from_file (const std::string& name, int warn)
 {
   FILE *instream = 0;
 
   if (name.length () > 0)
@@ -760,17 +760,17 @@ get_debug_input (const std::string& prom
           global_command->accept (*current_evaluator);
 
           if (octave_completion_matches_called)
             octave_completion_matches_called = false;
         }
 
       // Unmark forced variables.
       // Restore previous value of global_command.
-      frame.run_top (2);
+      frame.run (2);
 
       octave_quit ();
     }
 }
 
 // If the user simply hits return, this will produce an empty matrix.
 
 static octave_value_list
diff --git a/libinterp/interpfcn/load-path.cc b/libinterp/interpfcn/load-path.cc
--- a/libinterp/interpfcn/load-path.cc
+++ b/libinterp/interpfcn/load-path.cc
@@ -598,17 +598,17 @@ load_path::do_set (const std::string& p,
 
   do_clear ();
 
   for (std::list<std::string>::const_iterator i = elts.begin ();
        i != elts.end (); i++)
     do_append (*i, warn);
 
   // Restore add hook and execute for all newly added directories.
-  frame.run_top ();
+  frame.run_first ();
 
   for (dir_info_list_iterator i = dir_info_list.begin ();
        i != dir_info_list.end ();
        i++)
     {
       if (add_hook)
         add_hook (i->dir_name);
     }
@@ -651,17 +651,17 @@ strip_trailing_separators (const std::st
 
 void
 load_path::do_add (const std::string& dir_arg, bool at_end, bool warn)
 {
   size_t len = dir_arg.length ();
 
   if (len > 1 && dir_arg.substr (len-2) == "//")
     warning_with_id ("Octave:recursive-path-search",
-                     "trailing `//' is no longer special in search path elements");
+                     "trailing '//' is no longer special in search path elements");
 
   std::string dir = file_ops::tilde_expand (dir_arg);
 
   dir = strip_trailing_separators (dir);
 
   dir_info_list_iterator i = find_dir_info (dir);
 
   if (i != dir_info_list.end ())
diff --git a/libinterp/interpfcn/load-save.cc b/libinterp/interpfcn/load-save.cc
--- a/libinterp/interpfcn/load-save.cc
+++ b/libinterp/interpfcn/load-save.cc
@@ -116,29 +116,29 @@ default_save_header_format (void)
                  ", %a %b %d %H:%M:%S %Y %Z <")
     + octave_env::get_user_name ()
     + std::string ("@")
     + octave_env::get_host_name ()
     + std::string (">");
 }
 
 // The format string for the comment line at the top of text-format
-// save files.  Passed to strftime.  Should begin with `#' and contain
+// save files.  Passed to strftime.  Should begin with '#' and contain
 // no newline characters.
 static std::string Vsave_header_format_string = default_save_header_format ();
 
 static void
 gripe_file_open (const std::string& fcn, const std::string& file)
 {
   if (fcn == "load")
-    error ("%s: unable to open input file `%s'", fcn.c_str (), file.c_str ());
+    error ("%s: unable to open input file '%s'", fcn.c_str (), file.c_str ());
   else if (fcn == "save")
-    error ("%s: unable to open output file `%s'", fcn.c_str (), file.c_str ());
+    error ("%s: unable to open output file '%s'", fcn.c_str (), file.c_str ());
   else
-    error ("%s: unable to open file `%s'", fcn.c_str (), file.c_str ());
+    error ("%s: unable to open file '%s'", fcn.c_str (), file.c_str ());
 }
 
 // Install a variable with name NAME and the value VAL in the
 // symbol table.  If GLOBAL is TRUE, make the variable global.
 
 static void
 install_loaded_variable (const std::string& name,
                          const octave_value& val,
@@ -389,17 +389,17 @@ do_load (std::istream& stream, const std
 
       if (error_state || stream.eof () || name.empty ())
         break;
       else if (! error_state && ! name.empty ())
         {
           if (tc.is_defined ())
             {
               if (format == LS_MAT_ASCII && argv_idx < argc)
-                warning ("load: loaded ASCII file `%s' -- ignoring extra args",
+                warning ("load: loaded ASCII file '%s' -- ignoring extra args",
                          orig_fname.c_str ());
 
               if (format == LS_MAT_ASCII
                   || argv_idx == argc
                   || matches_patterns (argv, argv_idx, argc, name))
                 {
                   count++;
                   if (list_only)
@@ -437,22 +437,22 @@ do_load (std::istream& stream, const std
                 }
 
               // Only attempt to read one item from a headless text file.
 
               if (format == LS_MAT_ASCII)
                 break;
             }
           else
-            error ("load: unable to load variable `%s'", name.c_str ());
+            error ("load: unable to load variable '%s'", name.c_str ());
         }
       else
         {
           if (count == 0)
-            error ("load: are you sure `%s' is an Octave data file?",
+            error ("load: are you sure '%s' is an Octave data file?",
                    orig_fname.c_str ());
 
           break;
         }
     }
 
   if (list_only && count)
     {
@@ -868,17 +868,17 @@ Force Octave to assume the file is in Oc
 
                   retval = do_load (file, orig_fname, format,
                                     flt_fmt, list_only, swap, verbose,
                                     argv, i, argc, nargout);
 
                   file.close ();
                 }
               else
-                error ("load: unable to open input file `%s'",
+                error ("load: unable to open input file '%s'",
                        orig_fname.c_str ());
             }
         }
     }
 
   return retval;
 }
 
@@ -1116,16 +1116,24 @@ parse_save_options (const string_vector 
 #endif /* ! HAVE_HDF5 */
         }
 #ifdef HAVE_ZLIB
       else if (argv[i] == "-zip" || argv[i] == "-z")
         {
           use_zlib  = true;
         }
 #endif
+      else if (argv[i] == "-struct")
+        {
+          retval.append (argv[i]);
+        }
+      else if (argv[i][0] == '-')
+        {
+          error ("save: Unrecognized option '%s'", argv[i].c_str ());
+        }
       else
         retval.append (argv[i]);
     }
 
   if (do_double)
     {
       if (format == LS_MAT_ASCII)
         format.opts |= LS_MAT_ASCII_LONG;
@@ -1264,53 +1272,53 @@ save_vars (const string_vector& argv, in
           error ("save: missing struct name");
           return;
         }
 
       std::string struct_name = argv[argv_idx];
 
       if (! symbol_table::is_variable (struct_name))
         {
-          error ("save: no such variable: `%s'", struct_name.c_str ());
+          error ("save: no such variable: '%s'", struct_name.c_str ());
           return;
         }
 
       octave_value struct_var = symbol_table::varref (struct_name);
 
       if (! struct_var.is_map () || struct_var.numel () != 1)
         {
-          error ("save: `%s' is not a scalar structure",
+          error ("save: '%s' is not a scalar structure",
                  struct_name.c_str ());
           return;
         }
       octave_scalar_map struct_var_map = struct_var.scalar_map_value ();
 
       ++argv_idx;
 
       if (argv_idx < argc)
         {
           for (int i = argv_idx; i < argc; i++)
             {
               if (! save_fields (os, struct_var_map, argv[i], fmt,
                                  save_as_floats))
                 {
-                  warning ("save: no such field `%s.%s'",
+                  warning ("save: no such field '%s.%s'",
                            struct_name.c_str (), argv[i].c_str ());
                 }
             }
         }
       else
         save_fields (os, struct_var_map, "*", fmt, save_as_floats);
     }
   else
     {
       for (int i = argv_idx; i < argc; i++)
         {
           if (! save_vars (os, argv[i], fmt, save_as_floats))
-            warning ("save: no such variable `%s'", argv[i].c_str ());
+            warning ("save: no such variable '%s'", argv[i].c_str ());
         }
     }
 }
 
 static void
 dump_octave_core (std::ostream& os, const char *fname, load_save_format fmt,
                   bool save_as_floats)
 {
@@ -1345,29 +1353,29 @@ dump_octave_core (std::ostream& os, cons
               do_save (os, val, name, help, global, fmt, save_as_floats);
 
               if (error_state)
                 break;
             }
         }
     }
 
-  message (0, "save to `%s' complete", fname);
+  message (0, "save to '%s' complete", fname);
 }
 
 void
 dump_octave_core (void)
 {
   if (Vcrash_dumps_octave_core)
     {
       // FIXME -- should choose better file name?
 
       const char *fname = Voctave_core_file_name.c_str ();
 
-      message (0, "attempting to save variables to `%s'...", fname);
+      message (0, "attempting to save variables to '%s'...", fname);
 
       load_save_format format = LS_BINARY;
 
       bool save_as_floats = false;
 
       bool append = false;
 
       bool use_zlib = false;
@@ -1399,17 +1407,17 @@ dump_octave_core (void)
 
           if (file.file_id >= 0)
             {
               dump_octave_core (file, fname, format, save_as_floats);
 
               file.close ();
             }
           else
-            warning ("unable to open `%s' for writing...", fname);
+            warning ("unable to open '%s' for writing...", fname);
         }
       else
 #endif /* HAVE_HDF5 */
         // don't insert any commands here!  The open brace below must
         // go with the else above!
         {
 #ifdef HAVE_ZLIB
           if (use_zlib)
@@ -1418,37 +1426,36 @@ dump_octave_core (void)
 
               if (file)
                 {
                   dump_octave_core (file, fname, format, save_as_floats);
 
                   file.close ();
                 }
               else
-                warning ("unable to open `%s' for writing...", fname);
+                warning ("unable to open '%s' for writing...", fname);
             }
           else
 #endif
             {
               std::ofstream file (fname, mode);
 
               if (file)
                 {
                   dump_octave_core (file, fname, format, save_as_floats);
 
                   file.close ();
                 }
               else
-                warning ("unable to open `%s' for writing...", fname);
+                warning ("unable to open '%s' for writing...", fname);
             }
         }
     }
 }
 
-
 DEFUN (save, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Command} {} save file\n\
 @deftypefnx {Command} {} save options file\n\
 @deftypefnx {Command} {} save options file @var{v1} @var{v2} @dots{}\n\
 @deftypefnx {Command} {} save options file -struct @var{STRUCT} @var{f1} @var{f2} @dots{}\n\
 Save the named variables @var{v1}, @var{v2}, @dots{}, in the file\n\
 @var{file}.  The special filename @samp{-} may be used to write\n\
@@ -1632,17 +1639,17 @@ the file @file{data} in Octave's binary 
           // FIXME -- should things intended for the screen end up
           // in a octave_value (string)?
 
           save_vars (argv, i, argc, octave_stdout, format,
                      save_as_floats, true);
         }
     }
 
-  // Guard against things like `save a*', which are probably mistakes...
+  // Guard against things like 'save a*', which are probably mistakes...
 
   else if (i == argc - 1 && glob_pattern_p (argv[i]))
     {
       print_usage ();
       return retval;
     }
   else
     {
diff --git a/libinterp/interpfcn/ls-oct-ascii.cc b/libinterp/interpfcn/ls-oct-ascii.cc
--- a/libinterp/interpfcn/ls-oct-ascii.cc
+++ b/libinterp/interpfcn/ls-oct-ascii.cc
@@ -150,17 +150,17 @@ extract_keyword (std::istream& is, const
 // function is extensible.
 //
 // FILENAME is used for error messages.
 //
 // The data is expected to be in the following format:
 //
 // The input file must have a header followed by some data.
 //
-// All lines in the header must begin with a `#' character.
+// All lines in the header must begin with a '#' character.
 //
 // The header must contain a list of keyword and value pairs with the
 // keyword and value separated by a colon.
 //
 // Keywords must appear in the following order:
 //
 // # name: <name>
 // # type: <type>
@@ -239,26 +239,26 @@ read_ascii_data (std::istream& is, const
 {
   // Read name for this entry or break on EOF.
 
   std::string name = extract_keyword (is, "name");
 
   if (name.empty ())
     {
       if (count == 0)
-        error ("load: empty name keyword or no data found in file `%s'",
+        error ("load: empty name keyword or no data found in file '%s'",
                filename.c_str ());
 
       return std::string ();
     }
 
   if (! (name == ".nargin." || name == ".nargout."
          || name == CELL_ELT_TAG || valid_identifier (name)))
     {
-      error ("load: bogus identifier `%s' found in file `%s'",
+      error ("load: bogus identifier '%s' found in file '%s'",
              name.c_str (), filename.c_str ());
       return std::string ();
     }
 
   // Look for type keyword.
 
   std::string tag = extract_keyword (is, "type");
 
@@ -278,17 +278,17 @@ read_ascii_data (std::istream& is, const
 
       // Special case for backward compatiablity. A small bit of cruft
       if (SUBSTRING_COMPARE_EQ (typ, 0, 12, "string array"))
         tc = charMatrix ();
       else
         tc = octave_value_typeinfo::lookup_type (typ);
 
       if (! tc.load_ascii (is))
-        error ("load: trouble reading ascii file `%s'", filename.c_str ());
+        error ("load: trouble reading ascii file '%s'", filename.c_str ());
     }
   else
     error ("load: failed to extract keyword specifying value type");
 
   if (error_state)
     {
       error ("load: reading file %s", filename.c_str ());
       return std::string ();
diff --git a/libinterp/interpfcn/module.mk b/libinterp/interpfcn/module.mk
--- a/libinterp/interpfcn/module.mk
+++ b/libinterp/interpfcn/module.mk
@@ -1,14 +1,14 @@
 EXTRA_DIST += \
   interpfcn/module.mk \
   interpfcn/defaults.in.h \
   interpfcn/graphics.in.h
 
-INTERPFCN_INCLUDES = \
+INTERPFCN_INC = \
   interpfcn/data.h \
   interpfcn/debug.h \
   interpfcn/defun.h \
   interpfcn/dirfns.h \
   interpfcn/error.h \
   interpfcn/file-io.h \
   interpfcn/help.h \
   interpfcn/input.h \
@@ -60,18 +60,12 @@ interpfcn/defaults.h: interpfcn/defaults
 interpfcn/graphics.h: interpfcn/graphics.in.h genprops.awk Makefile
 	$(AWK) -f $(srcdir)/genprops.awk $< > $@-t
 	mv $@-t $@
 
 interpfcn/graphics-props.cc: interpfcn/graphics.in.h genprops.awk Makefile
 	$(AWK) -v emit_graphics_props=1 -f $(srcdir)/genprops.awk $< > $@-t
 	mv $@-t $@
 
-## FIXME: Do these rules work correctly after transplant to interpfcn/ dir?
-__fltk_uigetfile__.lo __fltk_uigetfile__.o: \
-  AM_CXXFLAGS := $(filter-out $(DLL_CXXDEFS), $(AM_CXXFLAGS) $(GRAPHICS_CFLAGS))
-
-__init_fltk__.lo __init_fltk__.o: \
-  AM_CXXFLAGS := $(filter-out $(DLL_CXXDEFS), $(AM_CXXFLAGS) $(GRAPHICS_CFLAGS))
-
 noinst_LTLIBRARIES += interpfcn/libinterpfcn.la
 
 interpfcn_libinterpfcn_la_SOURCES = $(INTERPFCN_SRC)
+interpfcn_libinterpfcn_la_CPPFLAGS = $(liboctinterp_la_CPPFLAGS)
diff --git a/libinterp/interpfcn/oct-hist.cc b/libinterp/interpfcn/oct-hist.cc
--- a/libinterp/interpfcn/oct-hist.cc
+++ b/libinterp/interpfcn/oct-hist.cc
@@ -144,29 +144,29 @@ do_history (int argc, const string_vecto
 
       if (option == "-r" || option == "-w" || option == "-a"
           || option == "-n")
         {
           if (i < argc - 1)
             command_history::set_file (argv[i+1]);
 
           if (option == "-a")
-            // Append `new' lines to file.
+            // Append 'new' lines to file.
             command_history::append ();
 
           else if (option == "-w")
             // Write entire history.
             command_history::write ();
 
           else if (option == "-r")
             // Read entire file.
             command_history::read ();
 
           else if (option == "-n")
-            // Read `new' history from file.
+            // Read 'new' history from file.
             command_history::read_range ();
 
           else
             panic_impossible ();
 
           return;
         }
       else if (argv[i] == "-q")
@@ -182,19 +182,19 @@ do_history (int argc, const string_vecto
 
   int limit = -1;
 
   if (i < argc)
     {
       if (sscanf (argv[i].c_str (), "%d", &limit) != 1)
         {
           if (argv[i][0] == '-')
-            error ("history: unrecognized option `%s'", argv[i].c_str ());
+            error ("history: unrecognized option '%s'", argv[i].c_str ());
           else
-            error ("history: bad non-numeric arg `%s'", argv[i].c_str ());
+            error ("history: bad non-numeric arg '%s'", argv[i].c_str ());
 
           return;
         }
 
       if (limit < 0)
         limit = -limit;
     }
 
@@ -255,20 +255,20 @@ edit_history_readline (std::fstream& str
 
   // Finish with newline if none in file.
 
   line[lindex++] = '\n';
   line[lindex++] = '\0';
   return line;
 }
 
-// Use `command' to replace the last entry in the history list, which,
-// by this time, is `run_history blah...'.  The intent is that the
-// new command becomes the history entry, and that `fc' should never
-// appear in the history list.  This way you can do `run_history' to
+// Use 'command' to replace the last entry in the history list, which,
+// by this time, is 'run_history blah...'.  The intent is that the
+// new command becomes the history entry, and that 'fc' should never
+// appear in the history list.  This way you can do 'run_history' to
 // your heart's content.
 
 static void
 edit_history_repl_hist (const std::string& command)
 {
   if (! command.empty ())
     {
       string_vector hlist = command_history::list ();
@@ -388,17 +388,17 @@ mk_tmp_hist_file (int argc, const string
     }
 
   std::string name = octave_tempnam ("", "oct-");
 
   std::fstream file (name.c_str (), std::ios::out);
 
   if (! file)
     {
-      error ("%s: couldn't open temporary file `%s'", warn_for,
+      error ("%s: couldn't open temporary file '%s'", warn_for,
              name.c_str ());
       return retval;
     }
 
   if (reverse)
     {
       for (int i = hist_end; i >= hist_beg; i--)
         file << hlist[i] << "\n";
diff --git a/libinterp/interpfcn/pager.cc b/libinterp/interpfcn/pager.cc
--- a/libinterp/interpfcn/pager.cc
+++ b/libinterp/interpfcn/pager.cc
@@ -504,17 +504,17 @@ open_diary_file (void)
   // If there is pending output in the pager buf, it should not go
   // into the diary file.
 
   octave_pager_stream::set_diary_skip ();
 
   external_diary_file.open (diary_file.c_str (), std::ios::app);
 
   if (! external_diary_file)
-    error ("diary: can't open diary file `%s'", diary_file.c_str ());
+    error ("diary: can't open diary file '%s'", diary_file.c_str ());
 }
 
 DEFUN (diary, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Command} {} diary options\n\
 Record a list of all commands @emph{and} the output they produce, mixed\n\
 together just as you see them on your terminal.  Valid options are:\n\
 \n\
@@ -607,17 +607,17 @@ The current state can be determined via 
     {
       std::string arg = argv[1];
 
       if (arg == "on")
         Vpage_screen_output = true;
       else if (arg == "off")
         Vpage_screen_output = false;
       else
-        error ("more: unrecognized argument `%s'", arg.c_str ());
+        error ("more: unrecognized argument '%s'", arg.c_str ());
     }
   else if (argc == 1)
     Vpage_screen_output = ! Vpage_screen_output;
   else
     print_usage ();
 
   return retval;
 }
diff --git a/libinterp/interpfcn/pr-output.cc b/libinterp/interpfcn/pr-output.cc
--- a/libinterp/interpfcn/pr-output.cc
+++ b/libinterp/interpfcn/pr-output.cc
@@ -53,18 +53,18 @@ along with Octave; see the file COPYING.
 #include "oct-stream.h"
 #include "pager.h"
 #include "pr-output.h"
 #include "sysdep.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
-// TRUE means use a scaled fixed point format for `format long' and
-// `format short'.
+// TRUE means use a scaled fixed point format for 'format long' and
+// 'format short'.
 static bool Vfixed_point_format = false;
 
 // The maximum field width for a number printed by the default output
 // routines.
 static int Voutput_max_field_width = 10;
 
 // The precision of the numbers printed by the default output
 // routines.
@@ -3628,17 +3628,17 @@ set_format_style (int argc, const string
                 }
               else if (arg == "eng")
                 {
                   init_format_state ();
                   print_eng = true;
                 }
               else
                 {
-                  error ("format: unrecognized option `short %s'",
+                  error ("format: unrecognized option 'short %s'",
                          arg.c_str ());
                   return;
                 }
             }
           else
             init_format_state ();
 
           set_output_prec_and_fw (5, 10);
@@ -3673,17 +3673,17 @@ set_format_style (int argc, const string
                 }
               else if (arg == "eng")
                 {
                   init_format_state ();
                   print_eng = true;
                 }
               else
                 {
-                  error ("format: unrecognized option `long %s'",
+                  error ("format: unrecognized option 'long %s'",
                          arg.c_str ());
                   return;
                 }
             }
           else
             init_format_state ();
 
           set_output_prec_and_fw (15, 20);
@@ -3752,17 +3752,17 @@ set_format_style (int argc, const string
         {
           Vcompact_format = true;
         }
       else if (arg == "loose")
         {
           Vcompact_format = false;
         }
       else
-        error ("format: unrecognized format state `%s'", arg.c_str ());
+        error ("format: unrecognized format state '%s'", arg.c_str ());
     }
   else
     {
       init_format_state ();
       set_output_prec_and_fw (5, 10);
     }
 }
 
diff --git a/libinterp/interpfcn/symtab.cc b/libinterp/interpfcn/symtab.cc
--- a/libinterp/interpfcn/symtab.cc
+++ b/libinterp/interpfcn/symtab.cc
@@ -1487,18 +1487,21 @@ symbol_table::do_update_nest (void)
                   ti->second = parents;
                 }
             }
           else
             ours.set_curr_fcn (curr_fcn);
         }
     }
   else if (nest_children.size ())
-    for (table_iterator ti = table.begin (); ti != table.end (); ++ti)
-      ti->second.set_curr_fcn (curr_fcn);
+    {
+      static_workspace = true;
+      for (table_iterator ti = table.begin (); ti != table.end (); ++ti)
+        ti->second.set_curr_fcn (curr_fcn);
+    }
 
   for (std::vector<symbol_table*>::iterator iter = nest_children.begin ();
        iter != nest_children.end (); ++iter)
     (*iter)->do_update_nest ();
 }
 
 DEFUN (ignore_function_time_stamp, args, nargout,
     "-*- texinfo -*-\n\
@@ -1696,17 +1699,17 @@ DEFUN (variable_value, args, , "VALUE = 
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
         {
           retval = symbol_table::varval (name);
 
           if (retval.is_undefined ())
-            error ("variable_value: `%s' is not a variable in the current scope",
+            error ("variable_value: '%s' is not a variable in the current scope",
                    name.c_str ());
         }
       else
         error ("variable_value: expecting variable name as first argument");
     }
   else
     print_usage ();
 
diff --git a/libinterp/interpfcn/symtab.h b/libinterp/interpfcn/symtab.h
--- a/libinterp/interpfcn/symtab.h
+++ b/libinterp/interpfcn/symtab.h
@@ -194,16 +194,20 @@ public:
     static const unsigned int global = 32;
 
     // not cleared at function exit
     static const unsigned int persistent = 64;
 
     // temporary variables forced into symbol table for parsing
     static const unsigned int forced = 128;
 
+    // this symbol may NOT become a variable.
+    // (symbol added to a static workspace)
+    static const unsigned int added_static = 256;
+
   private:
 
     class
     symbol_record_rep
     {
     public:
 
       symbol_record_rep (scope_id s, const std::string& nm,
@@ -343,16 +347,17 @@ public:
       bool is_local (void) const { return storage_class & local; }
       bool is_automatic (void) const { return storage_class & automatic; }
       bool is_formal (void) const { return storage_class & formal; }
       bool is_hidden (void) const { return storage_class & hidden; }
       bool is_inherited (void) const { return storage_class & inherited; }
       bool is_global (void) const { return storage_class & global; }
       bool is_persistent (void) const { return storage_class & persistent; }
       bool is_forced (void) const { return storage_class & forced; }
+      bool is_added_static (void) const {return storage_class & added_static; }
 
       void mark_local (void) { storage_class |= local; }
       void mark_automatic (void) { storage_class |= automatic; }
       void mark_formal (void) { storage_class |= formal; }
       void mark_hidden (void) { storage_class |= hidden; }
       void mark_inherited (void) { storage_class |= inherited; }
       void mark_global (void)
       {
@@ -364,25 +369,27 @@ public:
       void mark_persistent (void)
       {
         if (is_global ())
           error ("can't make global variable %s persistent", name.c_str ());
         else
           storage_class |= persistent;
       }
       void mark_forced (void) { storage_class |= forced; }
+      void mark_added_static (void) { storage_class |= added_static; }
 
       void unmark_local (void) { storage_class &= ~local; }
       void unmark_automatic (void) { storage_class &= ~automatic; }
       void unmark_formal (void) { storage_class &= ~formal; }
       void unmark_hidden (void) { storage_class &= ~hidden; }
       void unmark_inherited (void) { storage_class &= ~inherited; }
       void unmark_global (void) { storage_class &= ~global; }
       void unmark_persistent (void) { storage_class &= ~persistent; }
       void unmark_forced (void) { storage_class &= ~forced; }
+      void unmark_added_static (void) { storage_class &= ~added_static; }
 
       void init_persistent (void)
       {
         if (! is_defined ())
           {
             mark_persistent ();
 
             varref () = symbol_table::persistent_varval (name);
@@ -398,17 +405,17 @@ public:
       }
 
       void erase_persistent (void)
       {
         unmark_persistent ();
         symbol_table::erase_persistent (name);
       }
 
-      context_id active_context (void) const;
+      OCTINTERP_API context_id active_context (void) const;
 
       scope_id scope (void) const { return decl_scope; }
 
       void set_curr_fcn (octave_user_function *fcn)
       {
         curr_fcn = fcn;
       }
 
@@ -530,34 +537,37 @@ public:
     bool is_local (void) const { return rep->is_local (); }
     bool is_automatic (void) const { return rep->is_automatic (); }
     bool is_formal (void) const { return rep->is_formal (); }
     bool is_global (void) const { return rep->is_global (); }
     bool is_hidden (void) const { return rep->is_hidden (); }
     bool is_inherited (void) const { return rep->is_inherited (); }
     bool is_persistent (void) const { return rep->is_persistent (); }
     bool is_forced (void) const { return rep->is_forced (); }
+    bool is_added_static (void) const { return rep->is_added_static (); }
 
     void mark_local (void) { rep->mark_local (); }
     void mark_automatic (void) { rep->mark_automatic (); }
     void mark_formal (void) { rep->mark_formal (); }
     void mark_hidden (void) { rep->mark_hidden (); }
     void mark_inherited (void) { rep->mark_inherited (); }
     void mark_global (void) { rep->mark_global (); }
     void mark_persistent (void) { rep->mark_persistent (); }
     void mark_forced (void) { rep->mark_forced (); }
+    void mark_added_static (void) { rep->mark_added_static (); }
 
     void unmark_local (void) { rep->unmark_local (); }
     void unmark_automatic (void) { rep->unmark_automatic (); }
     void unmark_formal (void) { rep->unmark_formal (); }
     void unmark_hidden (void) { rep->unmark_hidden (); }
     void unmark_inherited (void) { rep->unmark_inherited (); }
     void unmark_global (void) { rep->unmark_global (); }
     void unmark_persistent (void) { rep->unmark_persistent (); }
     void unmark_forced (void) { rep->unmark_forced (); }
+    void unmark_added_static (void) { rep->unmark_added_static (); }
 
     void init_persistent (void) { rep->init_persistent (); }
 
     void erase_persistent (void) { rep->erase_persistent (); }
 
     void invalidate (void) { rep->invalidate (); }
 
     context_id active_context (void) const { return rep->active_context (); }
@@ -1202,23 +1212,33 @@ public:
     symbol_table *inst = get_instance (scope);
 
     if (inst)
       inst->do_force_variable (name, context);
   }
 
   static octave_value& varref (const std::string& name,
                                scope_id scope = xcurrent_scope,
-                               context_id context = xdefault_context)
+                               context_id context = xdefault_context,
+                               bool force_add = false)
   {
     static octave_value foobar;
 
     symbol_table *inst = get_instance (scope);
 
-    return inst ? inst->do_varref (name, context) : foobar;
+    return inst ? inst->do_varref (name, context, force_add) : foobar;
+  }
+
+  // Convenience function to greatly simplify
+  // octave_user_function::bind_automatic_vars
+  static octave_value& force_varref (const std::string& name,
+                                     scope_id scope = xcurrent_scope,
+                                     context_id context = xdefault_context)
+  {
+    return varref (name, scope, context, true);
   }
 
   static octave_value varval (const std::string& name,
                               scope_id scope = xcurrent_scope,
                               context_id context = xdefault_context)
   {
     symbol_table *inst = get_instance (scope);
 
@@ -1568,17 +1588,17 @@ public:
     if (p != fcn_table.end ())
       {
         fcn_info& finfo = p->second;
 
         finfo.clear_user_function ();
       }
     // FIXME -- is this necessary, or even useful?
     // else
-    //   error ("clear: no such function `%s'", name.c_str ());
+    //   error ("clear: no such function '%s'", name.c_str ());
   }
 
   // This clears oct and mex files, incl. autoloads.
   static void clear_dld_function (const std::string& name)
   {
     fcn_table_iterator p = fcn_table.find (name);
 
     if (p != fcn_table.end ())
@@ -1614,17 +1634,17 @@ public:
       {
         fcn_info finfo (alias);
 
         finfo.install_built_in_function (fcn);
 
         fcn_table[alias] = finfo;
       }
     else
-      panic ("alias: `%s' is undefined", name.c_str ());
+      panic ("alias: '%s' is undefined", name.c_str ());
   }
 
   static void add_dispatch (const std::string& name, const std::string& type,
                             const std::string& fname)
   {
     fcn_table_iterator p = fcn_table.find (name);
 
     if (p != fcn_table.end ())
@@ -1747,25 +1767,28 @@ public:
   static void mark_global (const std::string& name)
   {
     symbol_table *inst = get_instance (xcurrent_scope);
 
     if (inst)
       inst->do_mark_global (name);
   }
 
+  // exclude: Storage classes to exclude, you can OR them together
   static std::list<symbol_record>
   all_variables (scope_id scope = xcurrent_scope,
                  context_id context = xdefault_context,
-                 bool defined_only = true)
+                 bool defined_only = true,
+                 unsigned int exclude = symbol_record::hidden)
   {
     symbol_table *inst = get_instance (scope);
 
     return inst
-      ? inst->do_all_variables (context, defined_only) : std::list<symbol_record> ();
+      ? inst->do_all_variables (context, defined_only, exclude)
+      : std::list<symbol_record> ();
   }
 
   static std::list<symbol_record> glob (const std::string& pattern)
   {
     symbol_table *inst = get_instance (xcurrent_scope);
 
     return inst ? inst->do_glob (pattern) : std::list<symbol_record> ();
   }
@@ -2105,16 +2128,19 @@ private:
   std::vector<symbol_table*> nest_children;
 
   // Parent nested function (may be null).
   symbol_table *nest_parent;
 
   // The associated user code (may be null).
   octave_user_function *curr_fcn;
 
+  // If true then no variables can be added.
+  bool static_workspace;
+
   // Map from names of global variables to values.
   static std::map<std::string, octave_value> global_table;
 
   // Map from names of persistent variables to values.
   std::map<std::string, octave_value> persistent_table;
 
   // Pointer to symbol table for current scope (variables only).
   static symbol_table *instance;
@@ -2145,17 +2171,17 @@ private:
   static scope_id xcurrent_scope;
 
   static context_id xcurrent_context;
 
   static const context_id xdefault_context = static_cast<context_id> (-1);
 
   symbol_table (scope_id scope)
     : my_scope (scope), table_name (), table (), nest_children (), nest_parent (0),
-    curr_fcn (0), persistent_table () { }
+    curr_fcn (0), static_workspace (false), persistent_table () { }
 
   ~symbol_table (void) { }
 
   static symbol_table *get_instance (scope_id scope, bool create = true)
   {
     symbol_table *retval = 0;
 
     bool ok = true;
@@ -2273,28 +2299,33 @@ private:
     }
 
   octave_value
   do_find (const std::string& name, const octave_value_list& args,
            bool skip_variables, bool local_funcs);
 
   octave_value do_builtin_find (const std::string& name);
 
-  symbol_record& do_insert (const std::string& name)
+  symbol_record& do_insert (const std::string& name, bool force_add = false)
   {
     table_iterator p = table.find (name);
 
     if (p == table.end ())
       {
-        symbol_record parent_symbol;
-
-        if (nest_parent && nest_parent->look_nonlocal (name, parent_symbol))
-          return table[name] = parent_symbol;
+        symbol_record ret (my_scope, name);
+
+        if (nest_parent && nest_parent->look_nonlocal (name, ret))
+          return table[name] = ret;
         else
-          return table[name] = symbol_record (my_scope, name, octave_value ());
+          {
+            if (static_workspace && ! force_add)
+              ret.mark_added_static ();
+
+            return table[name] = ret;
+          }
       }
     else
       return p->second;
   }
 
   void do_force_variable (const std::string& name, context_id context)
   {
     table_iterator p = table.find (name);
@@ -2304,23 +2335,23 @@ private:
         symbol_record& sr = do_insert (name);
 
         sr.force_variable (context);
       }
     else
       p->second.force_variable (context);
   }
 
-  octave_value& do_varref (const std::string& name, context_id context)
+  octave_value& do_varref (const std::string& name, context_id context, bool force_add)
   {
     table_iterator p = table.find (name);
 
     if (p == table.end ())
       {
-        symbol_record& sr = do_insert (name);
+        symbol_record& sr = do_insert (name, force_add);
 
         return sr.varref (context);
       }
     else
       return p->second.varref (context);
   }
 
   octave_value do_varval (const std::string& name, context_id context) const
@@ -2505,25 +2536,27 @@ private:
   }
 
   void do_mark_global (const std::string& name)
   {
     do_insert (name).mark_global ();
   }
 
   std::list<symbol_record>
-  do_all_variables (context_id context, bool defined_only) const
+  do_all_variables (context_id context, bool defined_only,
+                    unsigned int exclude) const
   {
     std::list<symbol_record> retval;
 
     for (table_const_iterator p = table.begin (); p != table.end (); p++)
       {
         const symbol_record& sr = p->second;
 
-        if (defined_only && ! sr.is_defined (context))
+        if ((defined_only && ! sr.is_defined (context))
+            || (sr.xstorage_class () & exclude))
           continue;
 
         retval.push_back (sr);
       }
 
     return retval;
   }
 
diff --git a/libinterp/interpfcn/sysdep.cc b/libinterp/interpfcn/sysdep.cc
--- a/libinterp/interpfcn/sysdep.cc
+++ b/libinterp/interpfcn/sysdep.cc
@@ -64,16 +64,17 @@ along with Octave; see the file COPYING.
 #include "file-ops.h"
 #include "lo-mappers.h"
 #include "lo-math.h"
 #include "mach-info.h"
 #include "oct-env.h"
 #include "quit.h"
 
 #include "Cell.h"
+#include "builtins.h"
 #include "defun.h"
 #include "error.h"
 #include "input.h"
 #include "oct-obj.h"
 #include "ov.h"
 #include "pager.h"
 #include "parse.h"
 #include "sighandlers.h"
@@ -640,17 +641,17 @@ returning the empty string if no key is 
 @end deftypefn")
 {
   octave_value retval;
 
   // FIXME -- add timeout and default value args?
 
   if (interactive || forced_interactive)
     {
-      feval ("drawnow");
+      Fdrawnow ();
 
       int c = octave_kbhit (args.length () == 0);
 
       if (c == -1)
         c = 0;
 
       char *s = new char [2];
       s[0] = c;
@@ -692,33 +693,33 @@ clc;\n\
   if (nargin == 1)
     {
       double dval = args(0).double_value ();
 
       if (! error_state)
         {
           if (! xisnan (dval))
             {
-              feval ("drawnow");
+              Fdrawnow ();
 
               if (xisinf (dval))
                 {
                   flush_octave_stdout ();
                   octave_kbhit ();
                 }
               else
                 octave_sleep (dval);
             }
           else
             warning ("pause: NaN is an invalid delay");
         }
     }
   else
     {
-      feval ("drawnow");
+      Fdrawnow ();
       flush_octave_stdout ();
       octave_kbhit ();
     }
 
   return retval;
 }
 
 /*
@@ -741,17 +742,17 @@ Suspend the execution of the program for
       double dval = args(0).double_value ();
 
       if (! error_state)
         {
           if (xisnan (dval))
             warning ("sleep: NaN is an invalid delay");
           else
             {
-              feval ("drawnow");
+              Fdrawnow ();
               octave_sleep (dval);
             }
         }
     }
   else
     print_usage ();
 
   return retval;
@@ -781,17 +782,17 @@ of time less than one second, @code{usle
       double dval = args(0).double_value ();
 
       if (! error_state)
         {
           if (xisnan (dval))
             warning ("usleep: NaN is an invalid delay");
           else
             {
-              feval ("drawnow");
+              Fdrawnow ();
 
               int delay = NINT (dval);
 
               if (delay > 0)
                 octave_usleep (delay);
             }
         }
     }
diff --git a/libinterp/interpfcn/toplev.cc b/libinterp/interpfcn/toplev.cc
--- a/libinterp/interpfcn/toplev.cc
+++ b/libinterp/interpfcn/toplev.cc
@@ -648,17 +648,17 @@ main_loop (void)
           std::cerr
             << "error: unhandled execution exception -- trying to return to prompt"
             << std::endl;
         }
       catch (std::bad_alloc)
         {
           recover_from_exception ();
           std::cerr
-            << "error: memory exhausted or requested size too large for range of Octave's index type -- trying to return to prompt"
+            << "error: out of memory -- trying to return to prompt"
             << std::endl;
         }
     }
   while (retval == 0);
 
   return retval;
 }
 
@@ -812,17 +812,17 @@ run_command_and_return_output (const std
         cmd_status = octave_wait::exitstatus (cmd_status);
       else
         cmd_status = 127;
 
       retval(1) = output_buf.str ();
       retval(0) = cmd_status;
     }
   else
-    error ("unable to start subprocess for `%s'", cmd_str.c_str ());
+    error ("unable to start subprocess for '%s'", cmd_str.c_str ());
 
   return retval;
 }
 
 enum system_exec_type { et_sync, et_async };
 
 DEFUN (system, args, nargout,
   "-*- texinfo -*-\n\
@@ -1244,20 +1244,20 @@ specified option.\n\
       { false, "AMD_LDFLAGS", OCTAVE_CONF_AMD_LDFLAGS },
       { false, "AMD_LIBS", OCTAVE_CONF_AMD_LIBS },
       { false, "AR", OCTAVE_CONF_AR },
       { false, "ARFLAGS", OCTAVE_CONF_ARFLAGS },
       { false, "ARPACK_CPPFLAGS", OCTAVE_CONF_ARPACK_CPPFLAGS },
       { false, "ARPACK_LDFLAGS", OCTAVE_CONF_ARPACK_LDFLAGS },
       { false, "ARPACK_LIBS", OCTAVE_CONF_ARPACK_LIBS },
       { false, "BLAS_LIBS", OCTAVE_CONF_BLAS_LIBS },
-      { false, "CARBON_LIBS", OCTAVE_CONF_CARBON_LIBS },
       { false, "CAMD_CPPFLAGS", OCTAVE_CONF_CAMD_CPPFLAGS },
       { false, "CAMD_LDFLAGS", OCTAVE_CONF_CAMD_LDFLAGS },
       { false, "CAMD_LIBS", OCTAVE_CONF_CAMD_LIBS },
+      { false, "CARBON_LIBS", OCTAVE_CONF_CARBON_LIBS },
       { false, "CC", OCTAVE_CONF_CC },
       // FIXME: CC_VERSION is deprecated.  Remove in version 3.12
       { false, "CC_VERSION", OCTAVE_CONF_CC_VERSION },
       { false, "CCOLAMD_CPPFLAGS", OCTAVE_CONF_CCOLAMD_CPPFLAGS },
       { false, "CCOLAMD_LDFLAGS", OCTAVE_CONF_CCOLAMD_LDFLAGS },
       { false, "CCOLAMD_LIBS", OCTAVE_CONF_CCOLAMD_LIBS },
       { false, "CFLAGS", OCTAVE_CONF_CFLAGS },
       { false, "CHOLMOD_CPPFLAGS", OCTAVE_CONF_CHOLMOD_CPPFLAGS },
@@ -1297,45 +1297,46 @@ specified option.\n\
       { false, "FFTW3_CPPFLAGS", OCTAVE_CONF_FFTW3_CPPFLAGS },
       { false, "FFTW3_LDFLAGS", OCTAVE_CONF_FFTW3_LDFLAGS },
       { false, "FFTW3_LIBS", OCTAVE_CONF_FFTW3_LIBS },
       { false, "FFTW3F_CPPFLAGS", OCTAVE_CONF_FFTW3F_CPPFLAGS },
       { false, "FFTW3F_LDFLAGS", OCTAVE_CONF_FFTW3F_LDFLAGS },
       { false, "FFTW3F_LIBS", OCTAVE_CONF_FFTW3F_LIBS },
       { false, "FLIBS", OCTAVE_CONF_FLIBS },
       { false, "FPICFLAG", OCTAVE_CONF_FPICFLAG },
+      { false, "FT2_CFLAGS", OCTAVE_CONF_FT2_CFLAGS },
       { false, "FT2_LIBS", OCTAVE_CONF_FT2_LIBS },
       { false, "GLPK_CPPFLAGS", OCTAVE_CONF_GLPK_CPPFLAGS },
       { false, "GLPK_LDFLAGS", OCTAVE_CONF_GLPK_LDFLAGS },
       { false, "GLPK_LIBS", OCTAVE_CONF_GLPK_LIBS },
       { false, "GNUPLOT", OCTAVE_CONF_GNUPLOT },
+      { false, "GRAPHICS_CFLAGS", OCTAVE_CONF_GRAPHICS_CFLAGS },
       { false, "GRAPHICS_LIBS", OCTAVE_CONF_GRAPHICS_LIBS },
       { false, "HDF5_CPPFLAGS", OCTAVE_CONF_HDF5_CPPFLAGS },
       { false, "HDF5_LDFLAGS", OCTAVE_CONF_HDF5_LDFLAGS },
       { false, "HDF5_LIBS", OCTAVE_CONF_HDF5_LIBS },
       { false, "LAPACK_LIBS", OCTAVE_CONF_LAPACK_LIBS },
       { false, "LDFLAGS", OCTAVE_CONF_LDFLAGS },
       { false, "LD_CXX", OCTAVE_CONF_LD_CXX },
       { false, "LD_STATIC_FLAG", OCTAVE_CONF_LD_STATIC_FLAG },
       { false, "LEX", OCTAVE_CONF_LEX },
       { false, "LEXLIB", OCTAVE_CONF_LEXLIB },
       { false, "LFLAGS", OCTAVE_CONF_LFLAGS },
-      { false, "LIBCRUFT", OCTAVE_CONF_LIBCRUFT },
       { false, "LIBEXT", OCTAVE_CONF_LIBEXT },
       { false, "LIBFLAGS", OCTAVE_CONF_LIBFLAGS },
       { false, "LIBOCTAVE", OCTAVE_CONF_LIBOCTAVE },
       { false, "LIBOCTINTERP", OCTAVE_CONF_LIBOCTINTERP },
       { false, "LIBS", OCTAVE_CONF_LIBS },
+      { false, "LLVM_CPPFLAGS", OCTAVE_CONF_LLVM_CPPFLAGS },
+      { false, "LLVM_LDFLAGS", OCTAVE_CONF_LLVM_LDFLAGS },
+      { false, "LLVM_LIBS", OCTAVE_CONF_LLVM_LIBS },
       { false, "LN_S", OCTAVE_CONF_LN_S },
       { false, "MAGICK_CPPFLAGS", OCTAVE_CONF_MAGICK_CPPFLAGS },
       { false, "MAGICK_LDFLAGS", OCTAVE_CONF_MAGICK_LDFLAGS },
       { false, "MAGICK_LIBS", OCTAVE_CONF_MAGICK_LIBS },
-      { false, "LLVM_CPPFLAGS", OCTAVE_CONF_LLVM_CPPFLAGS },
-      { false, "LLVM_LDFLAGS", OCTAVE_CONF_LLVM_LDFLAGS },
-      { false, "LLVM_LIBS", OCTAVE_CONF_LLVM_LIBS },
       { false, "MKOCTFILE_DL_LDFLAGS", OCTAVE_CONF_MKOCTFILE_DL_LDFLAGS },
       { false, "OCTAVE_LINK_DEPS", OCTAVE_CONF_OCTAVE_LINK_DEPS },
       { false, "OCTAVE_LINK_OPTS", OCTAVE_CONF_OCTAVE_LINK_OPTS },
       { false, "OCT_LINK_DEPS", OCTAVE_CONF_OCT_LINK_DEPS },
       { false, "OCT_LINK_OPTS", OCTAVE_CONF_OCT_LINK_OPTS },
       { false, "OPENGL_LIBS", OCTAVE_CONF_OPENGL_LIBS },
       { false, "PTHREAD_CFLAGS", OCTAVE_CONF_PTHREAD_CFLAGS },
       { false, "PTHREAD_LIBS", OCTAVE_CONF_PTHREAD_LIBS },
@@ -1360,16 +1361,18 @@ specified option.\n\
       { false, "SONAME_FLAGS", OCTAVE_CONF_SONAME_FLAGS },
       { false, "STATIC_LIBS", OCTAVE_CONF_STATIC_LIBS },
       { false, "TERM_LIBS", OCTAVE_CONF_TERM_LIBS },
       { false, "UGLY_DEFS", OCTAVE_CONF_UGLY_DEFS },
       { false, "UMFPACK_CPPFLAGS", OCTAVE_CONF_UMFPACK_CPPFLAGS },
       { false, "UMFPACK_LDFLAGS", OCTAVE_CONF_UMFPACK_LDFLAGS },
       { false, "UMFPACK_LIBS", OCTAVE_CONF_UMFPACK_LIBS },
       { false, "USE_64_BIT_IDX_T", OCTAVE_CONF_USE_64_BIT_IDX_T },
+      { false, "WARN_CFLAGS", OCTAVE_CONF_WARN_CFLAGS },
+      { false, "WARN_CXXFLAGS", OCTAVE_CONF_WARN_CXXFLAGS },
       { false, "X11_INCFLAGS", OCTAVE_CONF_X11_INCFLAGS },
       { false, "X11_LIBS", OCTAVE_CONF_X11_LIBS },
       { false, "XTRA_CFLAGS", OCTAVE_CONF_XTRA_CFLAGS },
       { false, "XTRA_CXXFLAGS", OCTAVE_CONF_XTRA_CXXFLAGS },
       { false, "YACC", OCTAVE_CONF_YACC },
       { false, "YFLAGS", OCTAVE_CONF_YFLAGS },
       { false, "Z_CPPFLAGS", OCTAVE_CONF_Z_CPPFLAGS },
       { false, "Z_LDFLAGS", OCTAVE_CONF_Z_LDFLAGS },
@@ -1470,22 +1473,27 @@ specified option.\n\
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string arg = args(0).string_value ();
 
       if (! error_state)
         {
-          Cell c = m.contents (arg.c_str ());
+          if (m.isfield (arg))
+            {
+              Cell c = m.contents (arg);
 
-          if (c.is_empty ())
-            error ("octave_config_info: no info for `%s'", arg.c_str ());
+              if (c.is_empty ())
+                error ("octave_config_info: no info for '%s'", arg.c_str ());
+              else
+                retval = c(0);
+            }
           else
-            retval = c(0);
+            error ("octave_config_info: invalid parameter '%s'", arg.c_str ());
         }
     }
   else if (nargin == 0)
     retval = m;
   else
     print_usage ();
 
   return retval;
@@ -1511,21 +1519,21 @@ extern vfp __new_handler;
 void *
 __builtin_new (size_t sz)
 {
   void *p;
 
   /* malloc (0) is unpredictable; avoid it.  */
   if (sz == 0)
     sz = 1;
-  p = malloc (sz);
+  p = gnulib::malloc (sz);
   while (p == 0)
     {
       (*__new_handler) ();
-      p = malloc (sz);
+      p = gnulib::malloc (sz);
     }
 
   if (debug_new_delete)
     std::cerr << "__builtin_new: " << p << std::endl;
 
   return p;
 }
 
diff --git a/libinterp/interpfcn/utils.cc b/libinterp/interpfcn/utils.cc
--- a/libinterp/interpfcn/utils.cc
+++ b/libinterp/interpfcn/utils.cc
@@ -94,39 +94,38 @@ valid_identifier (const std::string& s)
 
 DEFUN (isvarname, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isvarname (@var{name})\n\
 Return true if @var{name} is a valid variable name.\n\
 @seealso{iskeyword, exist, who}\n\
 @end deftypefn")
 {
-  octave_value retval;
+  octave_value retval = false;
 
-  int argc = args.length () + 1;
-
-  string_vector argv = args.make_argv ("isvarname");
+  int nargin = args.length ();
 
-  if (error_state)
-    return retval;
-
-  if (argc == 2)
-    retval = valid_identifier (argv[1]) && ! is_keyword (argv[1]);
-  else
+  if (nargin != 1)
     print_usage ();
+  else if (args(0).is_string ())
+    {
+      std::string varname = args(0).string_value ();
+      retval = valid_identifier (varname) && ! is_keyword (varname);
+    }
 
   return retval;
 }
 
 /*
 %!assert (isvarname ("foo"), true)
 %!assert (isvarname ("_foo"), true)
 %!assert (isvarname ("_1"), true)
 %!assert (isvarname ("1foo"), false)
 %!assert (isvarname (""), false)
+%!assert (isvarname (12), false)
 
 %!error isvarname ()
 %!error isvarname ("foo", "bar");
 */
 
 // Return TRUE if F and G are both names for the same file.
 
 bool
@@ -625,18 +624,18 @@ do_string_escapes (const std::string& s)
               retval[i] = '\'';
               break;
 
             case '"': // double quote
               retval[i] = '"';
               break;
 
             default:
-              warning ("unrecognized escape sequence `\\%c' --\
- converting to `%c'", s[j], s[j]);
+              warning ("unrecognized escape sequence '\\%c' --\
+ converting to '%c'", s[j], s[j]);
               retval[i] = s[j];
               break;
             }
         }
       else
         {
           retval[i] = s[j];
         }
diff --git a/libinterp/interpfcn/variables.cc b/libinterp/interpfcn/variables.cc
--- a/libinterp/interpfcn/variables.cc
+++ b/libinterp/interpfcn/variables.cc
@@ -104,17 +104,17 @@ is_valid_function (const std::string& fc
     {
       octave_value val = symbol_table::find_function (fcn_name);
 
       if (val.is_defined ())
         ans = val.function_value (true);
     }
 
   if (! ans && warn)
-    error ("%s: the symbol `%s' is not valid as a function",
+    error ("%s: the symbol '%s' is not valid as a function",
            warn_for.c_str (), fcn_name.c_str ());
 
   return ans;
 }
 
 octave_function *
 is_valid_function (const octave_value& arg,
                    const std::string& warn_for, bool warn)
@@ -162,26 +162,26 @@ extract_function (const octave_value& ar
           eval_string (cmd, true, parse_status, 0);
 
           if (parse_status == 0)
             {
               retval = is_valid_function (fname, warn_for, 0);
 
               if (! retval)
                 {
-                  error ("%s: `%s' is not valid as a function",
+                  error ("%s: '%s' is not valid as a function",
                          warn_for.c_str (), fname.c_str ());
                   return retval;
                 }
 
               warning ("%s: passing function body as a string is obsolete; please use anonymous functions",
                        warn_for.c_str ());
             }
           else
-            error ("%s: `%s' is not valid as a function",
+            error ("%s: '%s' is not valid as a function",
                    warn_for.c_str (), fname.c_str ());
         }
       else
         error ("%s: expecting first argument to be a string",
                warn_for.c_str ());
     }
 
   return retval;
@@ -538,23 +538,23 @@ symbols of the specified type.  Valid ty
 @table @asis\n\
 @item \"var\"\n\
 Check only for variables.\n\
 \n\
 @item \"builtin\"\n\
 Check only for built-in functions.\n\
 \n\
 @item \"file\"\n\
-Check only for files.\n\
+Check only for files and directories.\n\
 \n\
 @item \"dir\"\n\
 Check only for directories.\n\
 @end table\n\
 \n\
-@seealso{file_in_loadpath}\n\
+@seealso{file_in_loadpath, file_in_path, stat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
@@ -603,34 +603,34 @@ lookup_function_handle (const std::strin
 }
 
 octave_value
 get_global_value (const std::string& nm, bool silent)
 {
   octave_value val = symbol_table::global_varval (nm);
 
   if (val.is_undefined () && ! silent)
-    error ("get_global_value: undefined symbol `%s'", nm.c_str ());
+    error ("get_global_value: undefined symbol '%s'", nm.c_str ());
 
   return val;
 }
 
 void
 set_global_value (const std::string& nm, const octave_value& val)
 {
   symbol_table::global_varref (nm) = val;
 }
 
 octave_value
 get_top_level_value (const std::string& nm, bool silent)
 {
   octave_value val = symbol_table::top_level_varval (nm);
 
   if (val.is_undefined () && ! silent)
-    error ("get_top_level_value: undefined symbol `%s'", nm.c_str ());
+    error ("get_top_level_value: undefined symbol '%s'", nm.c_str ());
 
   return val;
 }
 
 void
 set_top_level_value (const std::string& nm, const octave_value& val)
 {
   symbol_table::top_level_varref (nm) = val;
@@ -1105,17 +1105,17 @@ private:
                   else
                     {
                       os << std::setiosflags (std::ios::left)
                          << std::setw (param.parameter_length);
                     }
                   break;
 
                 default:
-                  error ("whos_line_format: modifier `%c' unknown",
+                  error ("whos_line_format: modifier '%c' unknown",
                          param.modifier);
 
                   os << std::setiosflags (std::ios::right)
                      << std::setw (param.parameter_length);
                 }
 
               switch (param.command)
                 {
@@ -1155,17 +1155,17 @@ private:
                     os << dims_str;
                   break;
 
                 case 't':
                   os << varval.type_name ();
                   break;
 
                 default:
-                  error ("whos_line_format: command `%c' unknown",
+                  error ("whos_line_format: command '%c' unknown",
                          param.command);
                 }
 
               os << std::resetiosflags (std::ios::left)
                  << std::resetiosflags (std::ios::right);
               i++;
             }
           else
@@ -1588,17 +1588,17 @@ do_who (int argc, const string_vector& a
 
           return retval;
         }
       else if (argv[i] == "-regexp")
         have_regexp = true;
       else if (argv[i] == "global")
         global_only = true;
       else if (argv[i][0] == '-')
-        warning ("%s: unrecognized option `%s'", my_name.c_str (),
+        warning ("%s: unrecognized option '%s'", my_name.c_str (),
                  argv[i].c_str ());
       else
         break;
     }
 
   int npats = argc - i;
   string_vector pats;
   if (npats > 0)
@@ -1876,17 +1876,17 @@ bind_ans (const octave_value& val, bool 
         {
           octave_value_list lst = val.list_value ();
 
           for (octave_idx_type i = 0; i < lst.length (); i++)
             bind_ans (lst(i), print);
         }
       else
         {
-          symbol_table::varref (ans) = val;
+          symbol_table::force_varref (ans) = val;
 
           if (print)
             val.print_with_name (octave_stdout, ans);
         }
     }
 }
 
 void
@@ -2335,18 +2335,18 @@ without the dash as well.\n\
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("clear");
 
   if (! error_state)
     {
       if (argc == 1)
         {
-          do_clear_globals (argv, argc, 1);
-          do_clear_variables (argv, argc, 1);
+          do_clear_globals (argv, argc, true);
+          do_clear_variables (argv, argc, true);
         }
       else
         {
           int idx = 0;
 
           bool clear_all = false;
           bool clear_functions = false;
           bool clear_globals = false;
@@ -2531,17 +2531,17 @@ When called from inside a function with 
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @seealso{whos}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (whos_line_format);
 }
 
-static std::string Vmissing_function_hook = "unimplemented";
+static std::string Vmissing_function_hook = "__unimplemented__";
 
 DEFUN (missing_function_hook, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} missing_function_hook ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} missing_function_hook (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} missing_function_hook (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the function to call when\n\
 an unknown identifier is requested.\n\
@@ -2554,26 +2554,31 @@ variable value is restored when exiting 
   return SET_INTERNAL_VARIABLE (missing_function_hook);
 }
 
 void maybe_missing_function_hook (const std::string& name)
 {
   // Don't do this if we're handling errors.
   if (buffer_error_messages == 0 && ! Vmissing_function_hook.empty ())
     {
-      // Ensure auto-restoration.
-      unwind_protect frame;
-      frame.protect_var (Vmissing_function_hook);
-
-      // Clear the variable prior to calling the function.
-      const std::string func_name = Vmissing_function_hook;
-      Vmissing_function_hook.clear ();
-
-      // Call.
-      feval (func_name, octave_value (name));
+      octave_value val = symbol_table::find_function (Vmissing_function_hook);
+
+      if (val.is_defined ())
+        {
+          // Ensure auto-restoration.
+          unwind_protect frame;
+          frame.protect_var (Vmissing_function_hook);
+
+          // Clear the variable prior to calling the function.
+          const std::string func_name = Vmissing_function_hook;
+          Vmissing_function_hook.clear ();
+
+          // Call.
+          feval (func_name, octave_value (name));
+        }
     }
 }
 
 DEFUN (__varval__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __varval__ (@var{name})\n\
 Undocumented internal function.\n\
 @end deftypefn")
diff --git a/libinterp/interpfcn/variables.h b/libinterp/interpfcn/variables.h
--- a/libinterp/interpfcn/variables.h
+++ b/libinterp/interpfcn/variables.h
@@ -131,17 +131,18 @@ set_internal_variable (int& var, const o
 
 extern OCTINTERP_API std::string builtin_string_variable (const std::string&);
 extern OCTINTERP_API int builtin_real_scalar_variable (const std::string&, double&);
 extern OCTINTERP_API octave_value builtin_any_variable (const std::string&);
 
 extern OCTINTERP_API void bind_ans (const octave_value& val, bool print);
 
 extern OCTINTERP_API void
-bind_internal_variable (const std::string& fname, const octave_value& val);
+bind_internal_variable (const std::string& fname,
+                        const octave_value& val) GCC_ATTR_DEPRECATED;
 
 extern OCTINTERP_API void mlock (void);
 extern OCTINTERP_API void munlock (const std::string&);
 extern OCTINTERP_API bool mislocked (const std::string&);
 
 extern OCTINTERP_API void clear_function (const std::string& nm);
 extern OCTINTERP_API void clear_variable (const std::string& nm);
 extern OCTINTERP_API void clear_symbol (const std::string& nm);
diff --git a/libinterp/mkbuiltins b/libinterp/mkbuiltins
--- a/libinterp/mkbuiltins
+++ b/libinterp/mkbuiltins
@@ -13,31 +13,77 @@
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
 # 
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
-if test $# -eq 0; then
-  echo "usage: mkbuiltins f1 f2 ..." 1>&2
+if test $# -lt 2; then
+  echo "usage: mkbuiltins --header|--source f1 f2 ..." 1>&2
   exit 1
 fi
 
 SED=${SED:-'sed'}
 
-cat << \EOF
+make_header=false
+make_source=false
+case "$1" in
+  --header)
+    make_header=true
+    shift
+  ;;
+  --source)
+    make_source=true
+    shift
+  ;;
+  *)
+    echo "mkbuiltins: unrecognized option: $1" 1>&2
+    exit 1
+  ;;
+esac
+
+if $make_header; then
+
+  cat << \EOF
+// DO NOT EDIT!  Generated automatically by mkbuiltins.
+
+#if !defined (octave_builtin_defun_decls_h)
+#define octave_builtin_defun_decls_h 1
+
+#include "oct-obj.h"
+
+#define DEFUN_DECL(name) \
+  extern OCTINTERP_API octave_value_list \
+  name (const octave_value_list& = octave_value_list (), int = 0);
+
+EOF
+
+ $SED -n -e 's/ *\(XDEFUN\|XDEFCONSTFUN\)_INTERNAL *( *\([_A-Za-z][_A-Za-z0-9]*\) *,.*$/DEFUN_DECL (F\2);/p; s/^ *XDEFUNX_INTERNAL *( *"\([_A-Za-z][_A-Za-z0-9]*\)" *,.*$/DEFUN_DECL (F\1);/p' "$@"
+
+  cat << \EOF
+
+#undef DEFUN_DECL
+
+#endif
+
+EOF
+
+else
+
+  cat << \EOF
 // DO NOT EDIT!  Generated automatically by mkbuiltins.
 
 #ifdef HAVE_CONFIG_H
-#include "config.h"
+#include <config.h>
 #endif
 
 #include "defun.h"
+#include "help.h"
 #include "oct-obj.h"
 #include "variables.h"
 #include "builtins.h"
 
 #if defined (quad)
 #undef quad
 #endif
 
@@ -74,38 +120,42 @@ cat << \EOF
 
 #define XDEFALIAS_INTERNAL(alias, name) \
   alias_builtin (#alias, #name);
 
 #define XDEFCONST_INTERNAL(name, defn, doc)
 
 EOF
 
-for arg
-do
-  fcn=`echo "$arg" | $SED 's,.*/,,; s/\.df//; s/-/_/g;'`
-  echo "static void"
-  echo "install_${fcn}_fcns (void)"
-  echo "{"
-  cat "$arg"
-  echo "}"
-  echo ""
-done
+  for arg
+  do
+    fcn=`echo "$arg" | $SED 's,.*/,,; s/\.df//; s/-/_/g;'`
+    echo "static void"
+    echo "install_${fcn}_fcns (void)"
+    echo "{"
+    cat "$arg"
+    echo "}"
+    echo ""
+  done
 
-cat << \EOF
+  cat << \EOF
 
 void
 install_builtins (void)
 {
 EOF
 
-for arg
-do
-  fcn=`echo "$arg" | $SED 's,.*/,,; s/\.df//; s/-/_/g;'`
-  echo "  install_${fcn}_fcns ();"
-done
+  for arg
+  do
+    fcn=`echo "$arg" | $SED 's,.*/,,; s/\.df//; s/-/_/g;'`
+    echo "  install_${fcn}_fcns ();"
+  done
 
-cat << \EOF
+  cat << \EOF
+
+  install_built_in_docstrings ();
 }
 
 EOF
 
+fi
+
 exit 0
diff --git a/libinterp/mkdefs b/libinterp/mkdefs
--- a/libinterp/mkdefs
+++ b/libinterp/mkdefs
@@ -26,20 +26,20 @@ if [ $# -ne 2 ]; then
 fi
 
 srcdir="$1"
 file="$2";
 
 echo "// DO NOT EDIT!  Generated automatically by mkdefs."
 case "$file" in
   $srcdir/*)
-    xsrcdir=`echo "$file" | sed "s,^$srcdir,src,"`
+    xsrcdir=`echo "$file" | sed "s,^$srcdir,libinterp,"`
   ;;
   *)
-    xsrcdir="src/$file"
+    xsrcdir="libinterp/$file"
   ;;
 esac
 echo " XDEFUN_FILE_NAME (\"$xsrcdir\")"
 egrep '^(///*|/\*) *PKG_ADD:' $file
 
 $SED -n -e '/^ *BEGIN_INSTALL_BUILTIN/{
   : loop
   s/BEGIN_INSTALL_BUILTIN//
diff --git a/libinterp/mkops b/libinterp/mkops
--- a/libinterp/mkops
+++ b/libinterp/mkops
@@ -19,17 +19,17 @@
 # <http://www.gnu.org/licenses/>.
 
 SED=${SED:-'sed'}
 
 cat << \EOF
 // DO NOT EDIT!  Generated automatically by mkops.
 
 #ifdef HAVE_CONFIG_H
-#include "config.h"
+#include <config.h>
 #endif
 
 extern void install_base_type_conversions (void);
 
 EOF
 
 for file in "$@"; do
   f=`echo $file | $SED 's,^\./,,; s%^operators/op-%%; s%\.cc%%; s%-%_%g'`
diff --git a/libinterp/oct-conf.in.h b/libinterp/oct-conf.in.h
--- a/libinterp/oct-conf.in.h
+++ b/libinterp/oct-conf.in.h
@@ -209,28 +209,32 @@ along with Octave; see the file COPYING.
 #ifndef OCTAVE_CONF_DL_LDFLAGS
 #define OCTAVE_CONF_DL_LDFLAGS %OCTAVE_CONF_DL_LDFLAGS%
 #endif
 
 #ifndef OCTAVE_CONF_DL_LIBS
 #define OCTAVE_CONF_DL_LIBS %OCTAVE_CONF_DL_LIBS%
 #endif
 
+#ifndef OCTAVE_CONF_ENABLE_DYNAMIC_LINKING
+#define OCTAVE_CONF_ENABLE_DYNAMIC_LINKING %OCTAVE_CONF_ENABLE_DYNAMIC_LINKING%
+#endif
+
+#ifndef OCTAVE_CONF_EXEEXT
+#define OCTAVE_CONF_EXEEXT %OCTAVE_CONF_EXEEXT%
+#endif
+
 #ifndef OCTAVE_CONF_GCC_VERSION
 #define OCTAVE_CONF_GCC_VERSION %OCTAVE_CONF_GCC_VERSION%
 #endif
 
 #ifndef OCTAVE_CONF_GXX_VERSION
 #define OCTAVE_CONF_GXX_VERSION %OCTAVE_CONF_GXX_VERSION%
 #endif
 
-#ifndef OCTAVE_CONF_EXEEXT
-#define OCTAVE_CONF_EXEEXT %OCTAVE_CONF_EXEEXT%
-#endif
-
 #ifndef OCTAVE_CONF_F77
 #define OCTAVE_CONF_F77 %OCTAVE_CONF_F77%
 #endif
 
 #ifndef OCTAVE_CONF_F77_FLOAT_STORE_FLAG
 #define OCTAVE_CONF_F77_FLOAT_STORE_FLAG %OCTAVE_CONF_F77_FLOAT_STORE_FLAG%
 #endif
 
@@ -273,16 +277,20 @@ along with Octave; see the file COPYING.
 #ifndef OCTAVE_CONF_FLIBS
 #define OCTAVE_CONF_FLIBS %OCTAVE_CONF_FLIBS%
 #endif
 
 #ifndef OCTAVE_CONF_FPICFLAG
 #define OCTAVE_CONF_FPICFLAG %OCTAVE_CONF_FPICFLAG%
 #endif
 
+#ifndef OCTAVE_CONF_FT2_CFLAGS
+#define OCTAVE_CONF_FT2_CFLAGS %OCTAVE_CONF_FT2_CFLAGS%
+#endif
+
 #ifndef OCTAVE_CONF_FT2_LIBS
 #define OCTAVE_CONF_FT2_LIBS %OCTAVE_CONF_FT2_LIBS%
 #endif
 
 #ifndef OCTAVE_CONF_GLPK_CPPFLAGS
 #define OCTAVE_CONF_GLPK_CPPFLAGS %OCTAVE_CONF_GLPK_CPPFLAGS%
 #endif
 
@@ -293,16 +301,20 @@ along with Octave; see the file COPYING.
 #ifndef OCTAVE_CONF_GLPK_LIBS
 #define OCTAVE_CONF_GLPK_LIBS %OCTAVE_CONF_GLPK_LIBS%
 #endif
 
 #ifndef OCTAVE_CONF_GNUPLOT
 #define OCTAVE_CONF_GNUPLOT %OCTAVE_CONF_GNUPLOT%
 #endif
 
+#ifndef OCTAVE_CONF_GRAPHICS_CFLAGS
+#define OCTAVE_CONF_GRAPHICS_CFLAGS %OCTAVE_CONF_GRAPHICS_CFLAGS%
+#endif
+
 #ifndef OCTAVE_CONF_GRAPHICS_LIBS
 #define OCTAVE_CONF_GRAPHICS_LIBS %OCTAVE_CONF_GRAPHICS_LIBS%
 #endif
 
 #ifndef OCTAVE_CONF_HDF5_CPPFLAGS
 #define OCTAVE_CONF_HDF5_CPPFLAGS %OCTAVE_CONF_HDF5_CPPFLAGS%
 #endif
 
@@ -345,20 +357,16 @@ along with Octave; see the file COPYING.
 #ifndef OCTAVE_CONF_LEX
 #define OCTAVE_CONF_LEX %OCTAVE_CONF_LEX%
 #endif
 
 #ifndef OCTAVE_CONF_LFLAGS
 #define OCTAVE_CONF_LFLAGS %OCTAVE_CONF_LFLAGS%
 #endif
 
-#ifndef OCTAVE_CONF_LIBCRUFT
-#define OCTAVE_CONF_LIBCRUFT %OCTAVE_CONF_LIBCRUFT%
-#endif
-
 #ifndef OCTAVE_CONF_LIBEXT
 #define OCTAVE_CONF_LIBEXT %OCTAVE_CONF_LIBEXT%
 #endif
 
 #ifndef OCTAVE_CONF_LIBFLAGS
 #define OCTAVE_CONF_LIBFLAGS %OCTAVE_CONF_LIBFLAGS%
 #endif
 
@@ -549,18 +557,22 @@ along with Octave; see the file COPYING.
 #ifndef OCTAVE_CONF_UMFPACK_LIBS
 #define OCTAVE_CONF_UMFPACK_LIBS %OCTAVE_CONF_UMFPACK_LIBS%
 #endif
 
 #ifndef OCTAVE_CONF_USE_64_BIT_IDX_T
 #define OCTAVE_CONF_USE_64_BIT_IDX_T %OCTAVE_CONF_USE_64_BIT_IDX_T%
 #endif
 
-#ifndef OCTAVE_CONF_ENABLE_DYNAMIC_LINKING
-#define OCTAVE_CONF_ENABLE_DYNAMIC_LINKING %OCTAVE_CONF_ENABLE_DYNAMIC_LINKING%
+#ifndef OCTAVE_CONF_WARN_CFLAGS
+#define OCTAVE_CONF_WARN_CFLAGS %OCTAVE_CONF_WARN_CFLAGS%
+#endif
+
+#ifndef OCTAVE_CONF_WARN_CXXFLAGS
+#define OCTAVE_CONF_WARN_CXXFLAGS %OCTAVE_CONF_WARN_CXXFLAGS%
 #endif
 
 #ifndef OCTAVE_CONF_X11_INCFLAGS
 #define OCTAVE_CONF_X11_INCFLAGS %OCTAVE_CONF_X11_INCFLAGS%
 #endif
 
 #ifndef OCTAVE_CONF_X11_LIBS
 #define OCTAVE_CONF_X11_LIBS %OCTAVE_CONF_X11_LIBS%
diff --git a/libinterp/octave-value/module.mk b/libinterp/octave-value/module.mk
--- a/libinterp/octave-value/module.mk
+++ b/libinterp/octave-value/module.mk
@@ -1,32 +1,32 @@
 EXTRA_DIST += \
   octave-value/module.mk
 
-OV_INTTYPE_INCLUDES = \
+OV_INTTYPE_INC = \
   octave-value/ov-base-int.h \
   octave-value/ov-base-int.cc \
   octave-value/ov-int-traits.h \
   octave-value/ov-int16.h \
   octave-value/ov-int32.h \
   octave-value/ov-int64.h \
   octave-value/ov-int8.h \
   octave-value/ov-intx.h \
   octave-value/ov-uint16.h \
   octave-value/ov-uint32.h \
   octave-value/ov-uint64.h \
   octave-value/ov-uint8.h
 
-OV_SPARSE_INCLUDES = \
+OV_SPARSE_INC = \
   octave-value/ov-base-sparse.h \
   octave-value/ov-bool-sparse.h \
   octave-value/ov-cx-sparse.h \
   octave-value/ov-re-sparse.h
 
-OV_INCLUDES = \
+OCTAVE_VALUE_INC = \
   octave-value/ov-base-diag.h \
   octave-value/ov-base-diag.cc \
   octave-value/ov-base-mat.h \
   octave-value/ov-base-mat.cc \
   octave-value/ov-base-scalar.h \
   octave-value/ov-base-scalar.cc \
   octave-value/ov-base.h \
   octave-value/ov-bool-mat.h \
@@ -62,17 +62,18 @@ OV_INCLUDES = \
   octave-value/ov-re-mat.h \
   octave-value/ov-scalar.h \
   octave-value/ov-str-mat.h \
   octave-value/ov-struct.h \
   octave-value/ov-type-conv.h \
   octave-value/ov-typeinfo.h \
   octave-value/ov-usr-fcn.h \
   octave-value/ov.h \
-  $(OV_INTTYPE_INCLUDES)
+  $(OV_INTTYPE_INC) \
+  $(OV_SPARSE_INC)
 
 OV_INTTYPE_SRC = \
   octave-value/ov-int16.cc \
   octave-value/ov-int32.cc \
   octave-value/ov-int64.cc \
   octave-value/ov-int8.cc \
   octave-value/ov-uint16.cc \
   octave-value/ov-uint32.cc \
@@ -124,8 +125,9 @@ OCTAVE_VALUE_SRC = \
   octave-value/ov-usr-fcn.cc \
   octave-value/ov.cc \
   $(OV_INTTYPE_SRC) \
   $(OV_SPARSE_SRC)
 
 noinst_LTLIBRARIES += octave-value/liboctave-value.la
 
 octave_value_liboctave_value_la_SOURCES = $(OCTAVE_VALUE_SRC)
+octave_value_liboctave_value_la_CPPFLAGS = $(liboctinterp_la_CPPFLAGS)
diff --git a/libinterp/octave-value/ov-base-diag.cc b/libinterp/octave-value/ov-base-diag.cc
--- a/libinterp/octave-value/ov-base-diag.cc
+++ b/libinterp/octave-value/ov-base-diag.cc
@@ -63,16 +63,42 @@ octave_base_diag<DMT, MT>::subsref (cons
 
     default:
       panic_impossible ();
     }
 
   return retval.next_subsref (type, idx);
 }
 
+
+template <class DMT, class MT>
+octave_value
+octave_base_diag<DMT,MT>::diag (octave_idx_type k) const
+{
+  octave_value retval;
+  if (matrix.rows () == 1 || matrix.cols () == 1)
+    {
+      // Rather odd special case. This is a row or column vector
+      // represented as a diagonal matrix with a single nonzero entry, but
+      // Fdiag semantics are to product a diagonal matrix for vector
+      // inputs.
+      if (k == 0)
+        // Returns Diag2Array<T> with nnz <= 1.
+        retval = matrix.build_diag_matrix ();
+      else
+        // Returns Array<T> matrix
+        retval = matrix.array_value ().diag (k);
+    }
+  else
+    // Returns Array<T> vector
+    retval = matrix.extract_diag (k);
+  return retval;
+}
+
+
 template <class DMT, class MT>
 octave_value
 octave_base_diag<DMT, MT>::do_index_op (const octave_value_list& idx,
                                         bool resize_ok)
 {
   octave_value retval;
   typedef typename DMT::element_type el_type;
 
@@ -117,17 +143,17 @@ octave_base_diag<DMT, MT>::subsasgn (con
   switch (type[0])
     {
     case '(':
       {
         if (type.length () == 1)
           {
             octave_value_list jdx = idx.front ();
             // Check for a simple element assignment. That means, if D is a diagonal matrix,
-            // `D(i,i) = x' will not destroy its diagonality (provided i is a valid index).
+            // 'D(i,i) = x' will not destroy its diagonality (provided i is a valid index).
             if (jdx.length () == 2 && jdx(0).is_scalar_type () && jdx(1).is_scalar_type ())
               {
                 typename DMT::element_type val;
                 idx_vector i0 = jdx(0).index_vector (), i1 = jdx(1).index_vector ();
                 if (! error_state  && i0(0) == i1(0)
                     && i0(0) < matrix.rows () && i1(0) < matrix.cols ()
                     && chk_valid_scalar (rhs, val))
                   {
@@ -395,17 +421,17 @@ octave_base_diag<DMT, MT>::convert_to_st
 
 template <class DMT, class MT>
 bool
 octave_base_diag<DMT, MT>::save_ascii (std::ostream& os)
 {
   os << "# rows: " << matrix.rows () << "\n"
     << "# columns: " << matrix.columns () << "\n";
 
-  os << matrix.diag ();
+  os << matrix.extract_diag ();
 
   return true;
 }
 
 template <class DMT, class MT>
 bool
 octave_base_diag<DMT, MT>::load_ascii (std::istream& is)
 {
diff --git a/libinterp/octave-value/ov-base-diag.h b/libinterp/octave-value/ov-base-diag.h
--- a/libinterp/octave-value/ov-base-diag.h
+++ b/libinterp/octave-value/ov-base-diag.h
@@ -92,18 +92,17 @@ public:
 
   octave_value all (int dim = 0) const { return MT (matrix).all (dim); }
   octave_value any (int dim = 0) const { return MT (matrix).any (dim); }
 
   MatrixType matrix_type (void) const { return MatrixType::Diagonal; }
   MatrixType matrix_type (const MatrixType&) const
     { return matrix_type (); }
 
-  octave_value diag (octave_idx_type k = 0) const
-    { return octave_value (matrix.diag (k)); }
+  octave_value diag (octave_idx_type k = 0) const;
 
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
     { return to_dense ().sort (dim, mode); }
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
                      sortmode mode = ASCENDING) const
     { return to_dense ().sort (sidx, dim, mode); }
 
   sortmode is_sorted (sortmode mode = UNSORTED) const
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -1188,16 +1188,17 @@ octave_base_value::get_umap_name (unary_
       "ceil",
       "conj",
       "cos",
       "cosh",
       "erf",
       "erfinv",
       "erfcinv",
       "erfc",
+      "erfcx",
       "exp",
       "expm1",
       "finite",
       "fix",
       "floor",
       "gamma",
       "imag",
       "isinf",
@@ -1224,16 +1225,17 @@ octave_base_value::get_umap_name (unary_
       "isdigit",
       "isgraph",
       "islower",
       "isprint",
       "ispunct",
       "isspace",
       "isupper",
       "isxdigit",
+      "signbit",
       "toascii",
       "tolower",
       "toupper"
     };
 
   if (umap < 0 || umap >= num_unary_mappers)
     return "unknown";
   else
@@ -1267,33 +1269,33 @@ octave_base_value::dump (std::ostream& o
   os << "class: " << this->class_name ()
      << " type: " << this->type_name ()
      << " dims: " << dv.str ();
 }
 
 static void
 gripe_indexed_assignment (const std::string& tn1, const std::string& tn2)
 {
-  error ("assignment of `%s' to indexed `%s' not implemented",
+  error ("assignment of '%s' to indexed '%s' not implemented",
          tn2.c_str (), tn1.c_str ());
 }
 
 static void
 gripe_assign_conversion_failed (const std::string& tn1,
                                 const std::string& tn2)
 {
-  error ("type conversion for assignment of `%s' to indexed `%s' failed",
+  error ("type conversion for assignment of '%s' to indexed '%s' failed",
          tn2.c_str (), tn1.c_str ());
 }
 
 static void
 gripe_no_conversion (const std::string& on, const std::string& tn1,
                      const std::string& tn2)
 {
-  error ("operator %s: no conversion for assignment of `%s' to indexed `%s'",
+  error ("operator %s: no conversion for assignment of '%s' to indexed '%s'",
          on.c_str (), tn2.c_str (), tn1.c_str ());
 }
 
 octave_value
 octave_base_value::numeric_assign (const std::string& type,
                                    const std::list<octave_value_list>& idx,
                                    const octave_value& rhs)
 {
diff --git a/libinterp/octave-value/ov-base.h b/libinterp/octave-value/ov-base.h
--- a/libinterp/octave-value/ov-base.h
+++ b/libinterp/octave-value/ov-base.h
@@ -720,16 +720,17 @@ public:
       umap_xisdigit,
       umap_xisgraph,
       umap_xislower,
       umap_xisprint,
       umap_xispunct,
       umap_xisspace,
       umap_xisupper,
       umap_xisxdigit,
+      umap_xsignbit,
       umap_xtoascii,
       umap_xtolower,
       umap_xtoupper,
       umap_unknown,
       num_unary_mappers = umap_unknown
     };
 
   virtual octave_value map (unary_mapper_t) const;
@@ -796,19 +797,19 @@ protected:
   void reset (void) const;
 
   // A reference count.
   // NOTE: the declaration is octave_idx_type because with 64-bit indexing,
   // it is well possible to have more than MAX_INT copies of a single value
   // (think of an empty cell array with >2G elements).
   octave_refcount<octave_idx_type> count;
 
-private:
+  static const char *get_umap_name (unary_mapper_t);
 
-  static const char *get_umap_name (unary_mapper_t);
+private:
 
   static int curr_print_indent_level;
   static bool beginning_of_line;
 
   DECLARE_OV_BASE_TYPEID_FUNCTIONS_AND_DATA
 };
 
 // TRUE means to perform automatic sparse to real mutation if there
diff --git a/libinterp/octave-value/ov-ch-mat.cc b/libinterp/octave-value/ov-ch-mat.cc
--- a/libinterp/octave-value/ov-ch-mat.cc
+++ b/libinterp/octave-value/ov-ch-mat.cc
@@ -147,31 +147,38 @@ octave_char_matrix::as_mxArray (void) co
   const char *p = matrix.data ();
 
   for (mwIndex i = 0; i < nel; i++)
     pr[i] = p[i];
 
   return retval;
 }
 
-// The C++ standard guarantees cctype defines functions, not macros (and hence macros *CAN'T*
-// be defined if only cctype is included)
-// so there's no need to f*ck around. The exceptions are isascii and toascii,
-// which are not C++.
-// Oddly enough, all those character functions are int (*) (int), even
-// in C++. Wicked!
+// The C++ standard guarantees cctype defines functions, not macros (and
+// hence macros *CAN'T* be defined if only cctype is included) so
+// there's no need to fuck around. The exceptions are isascii and
+// toascii, which are not C++. Oddly enough, all those character
+// functions are int (*) (int), even in C++. Wicked!
 static inline int xisascii (int c)
 { return isascii (c); }
 
 static inline int xtoascii (int c)
-{ return toascii (c); }
+{
+#ifdef HAVE_TOASCII
+  return toascii (c);
+#else
+  return (c & 0x7F);
+#endif
+}
 
 octave_value
 octave_char_matrix::map (unary_mapper_t umap) const
 {
+  octave_value retval;
+
   switch (umap)
     {
 #define STRING_MAPPER(UMAP,FCN,TYPE) \
     case umap_ ## UMAP: \
       return octave_value (matrix.map<TYPE, int (&) (int)> (FCN))
 
     STRING_MAPPER (xisalnum, std::isalnum, bool);
     STRING_MAPPER (xisalpha, std::isalpha, bool);
@@ -184,15 +191,31 @@ octave_char_matrix::map (unary_mapper_t 
     STRING_MAPPER (xispunct, std::ispunct, bool);
     STRING_MAPPER (xisspace, std::isspace, bool);
     STRING_MAPPER (xisupper, std::isupper, bool);
     STRING_MAPPER (xisxdigit, std::isxdigit, bool);
     STRING_MAPPER (xtoascii, xtoascii, double);
     STRING_MAPPER (xtolower, std::tolower, char);
     STRING_MAPPER (xtoupper, std::toupper, char);
 
-    default:
+    // For Matlab compatibility, these should work on ASCII values
+    // without error or warning.
+    case umap_abs:
+    case umap_ceil:
+    case umap_fix:
+    case umap_floor:
+    case umap_imag:
+    case umap_isinf:
+    case umap_isnan:
+    case umap_real:
+    case umap_round:
       {
         octave_matrix m (array_value (true));
         return m.map (umap);
       }
+
+    default:
+      error ("%s: expecting numeric argument", get_umap_name (umap));
+      break;
     }
+
+  return retval;
 }
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -319,23 +319,23 @@ make_idx_args (const std::string& type,
                 if (vlist.length () == 1)
                   {
                     octave_value val = vlist(0);
 
                     if (val.is_string ())
                       subs_field(i) = val;
                     else
                       {
-                        error ("expecting character string argument for `.' index");
+                        error ("expecting character string argument for '.' index");
                         return retval;
                       }
                   }
                 else
                   {
-                    error ("expecting single argument for `.' index");
+                    error ("expecting single argument for '.' index");
                     return retval;
                   }
               }
               break;
 
             default:
               panic_impossible ();
               break;
@@ -381,17 +381,17 @@ octave_class::dotref (const octave_value
 
   if (! error_state)
     {
       octave_map::const_iterator p = my_map.seek (nm);
 
       if (p != my_map.end ())
         retval = my_map.contents (p);
       else
-        error ("class has no member `%s'", nm.c_str ());
+        error ("class has no member '%s'", nm.c_str ());
     }
   else
     gripe_invalid_index1 ();
 
   return retval;
 }
 
 static bool
@@ -1970,25 +1970,25 @@ derived.\n\
                         {
                           octave_class::exemplar_const_iterator it
                             = octave_class::exemplar_map.find (id);
 
                           if (it == octave_class::exemplar_map.end ())
                             octave_class::exemplar_map[id]
                               = octave_class::exemplar_info (retval);
                           else if (! it->second.compare (retval))
-                            error ("class: object of class `%s' does not match previously constructed objects",
+                            error ("class: object of class '%s' does not match previously constructed objects",
                                    id.c_str ());
                         }
                     }
                   else
                     error ("class: expecting structure S as first argument");
                 }
               else
-                error ("class: `%s' is invalid as a class name in this context",
+                error ("class: '%s' is invalid as a class name in this context",
                        id.c_str ());
             }
           else
             error ("class: invalid call from outside class constructor or method");
         }
       else
         error ("class: ID (class name) must be a character string");
     }
diff --git a/libinterp/octave-value/ov-colon.h b/libinterp/octave-value/ov-colon.h
--- a/libinterp/octave-value/ov-colon.h
+++ b/libinterp/octave-value/ov-colon.h
@@ -34,17 +34,17 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "ov-base.h"
 #include "ov-typeinfo.h"
 
 class octave_value_list;
 
 class tree_walker;
 
-// A type to represent `:' as used for indexing.
+// A type to represent ':' as used for indexing.
 
 class
 octave_magic_colon : public octave_base_value
 {
 public:
 
   octave_magic_colon (void)
     : octave_base_value () { }
diff --git a/libinterp/octave-value/ov-cx-diag.cc b/libinterp/octave-value/ov-cx-diag.cc
--- a/libinterp/octave-value/ov-cx-diag.cc
+++ b/libinterp/octave-value/ov-cx-diag.cc
@@ -144,17 +144,17 @@ octave_complex_diag_matrix::map (unary_m
     case umap_real:
       return ::real (matrix);
     case umap_conj:
       return ::conj (matrix);
     case umap_imag:
       return ::imag (matrix);
     case umap_sqrt:
       {
-        ComplexColumnVector tmp = matrix.diag ().map<Complex> (std::sqrt);
+        ComplexColumnVector tmp = matrix.extract_diag ().map<Complex> (std::sqrt);
         ComplexDiagMatrix retval (tmp);
         retval.resize (matrix.rows (), matrix.columns ());
         return retval;
       }
     default:
       return to_dense ().map (umap);
     }
 }
@@ -162,17 +162,17 @@ octave_complex_diag_matrix::map (unary_m
 bool
 octave_complex_diag_matrix::save_binary (std::ostream& os, bool& save_as_floats)
 {
 
   int32_t r = matrix.rows (), c = matrix.cols ();
   os.write (reinterpret_cast<char *> (&r), 4);
   os.write (reinterpret_cast<char *> (&c), 4);
 
-  ComplexMatrix m = ComplexMatrix (matrix.diag ());
+  ComplexMatrix m = ComplexMatrix (matrix.extract_diag ());
   save_type st = LS_DOUBLE;
   if (save_as_floats)
     {
       if (m.too_large_for_float ())
         {
           warning ("save: some values too large to save as floats --");
           warning ("save: saving as doubles instead");
         }
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -370,17 +370,17 @@ octave_fcn_handle::save_ascii (std::ostr
 
       if (varlen > 0)
         {
           os << "# length: " << varlen << "\n";
 
           for (std::list<symbol_table::symbol_record>::const_iterator p = vars.begin ();
                p != vars.end (); p++)
             {
-              if (! save_ascii_data (os, p->varval (), p->name (), false, 0))
+              if (! save_ascii_data (os, p->varval (0), p->name (), false, 0))
                 return os;
             }
         }
     }
   else
     {
       octave_function *f = function_value ();
       std::string fnm = f ? f->fcn_file_name () : std::string ();
@@ -545,17 +545,17 @@ octave_fcn_handle::save_binary (std::ost
       os.write (reinterpret_cast<char *> (&tmp), 4);
       os.write (stmp.c_str (), stmp.length ());
 
       if (varlen > 0)
         {
           for (std::list<symbol_table::symbol_record>::const_iterator p = vars.begin ();
                p != vars.end (); p++)
             {
-              if (! save_binary_data (os, p->varval (), p->name (),
+              if (! save_binary_data (os, p->varval (0), p->name (),
                                       "", 0, save_as_floats))
                 return os;
             }
         }
     }
   else
     {
       std::ostringstream nmbuf;
@@ -834,17 +834,17 @@ octave_fcn_handle::save_hdf5 (hid_t loc_
               H5Tclose (type_hid);
               H5Gclose (group_hid);
               return false;
             }
 
           for (std::list<symbol_table::symbol_record>::const_iterator p = vars.begin ();
                p != vars.end (); p++)
             {
-              if (! add_hdf5_data (data_hid, p->varval (), p->name (),
+              if (! add_hdf5_data (data_hid, p->varval (0), p->name (),
                                    "", false, save_as_floats))
                 break;
             }
           H5Gclose (data_hid);
         }
     }
   else
     {
@@ -1306,30 +1306,83 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
 %! modes = {"-text", "-binary"};
 %! if (!isempty (findstr (octave_config_info ("DEFS"), "HAVE_HDF5")))
 %!   modes(end+1) = "-hdf5";
 %! endif
 %! for i = 1:numel (modes)
 %!   mode = modes{i};
 %!   nm = tmpnam ();
 %!   unwind_protect
+%!     f2 (1); # bug #33857
 %!     save (mode, nm, "f2", "g2", "hm2", "hdld2", "hbi2");
 %!     clear f2 g2 hm2 hdld2 hbi2
 %!     load (nm);
 %!     assert (f (2), f2 (2));
 %!     assert (g (2), g2 (2));
 %!     assert (g (3), g2 (3));
 %!     unlink (nm);
 %!     save (mode, nm, "f2", "g2", "hm2", "hdld2", "hbi2");
 %!   unwind_protect_cleanup
 %!     unlink (nm);
 %!   end_unwind_protect
 %! endfor
 */
 
+/*
+%!function fcn_handle_save_recurse (n, mode, nm, f2, g2, hm2, hdld2, hbi2)
+%!  if n == 0
+%!    save (mode, nm, "f2", "g2", "hm2", "hdld2", "hbi2");
+%!  else
+%!    fcn_handle_save_recurse (n - 1, mode, nm, f2, g2, hm2, hdld2, hbi2);
+%!  endif
+%!endfunction
+%!function [f2, g2, hm2, hdld2, hbi2] = fcn_handle_load_recurse (n, nm)
+%!  if n == 0
+%!    load (nm)
+%!  else
+%!    [f2, g2, hm2, hdld2, hbi2] = fcn_handle_load_recurse (n - 1, nm);
+%!  endif
+%!endfunction
+
+Test for bug #35876
+%!test
+%! a = 2;
+%! f = @(x) a + x;
+%! g = @(x) 2 * x;
+%! hm = @version;
+%! hdld = @svd;
+%! hbi = @log2;
+%! f2 = f;
+%! g2 = g;
+%! hm2 = hm;
+%! hdld2 = hdld;
+%! hbi2 = hbi;
+%! modes = {"-text", "-binary"};
+%! if (!isempty (findstr (octave_config_info ("DEFS"), "HAVE_HDF5")))
+%!   modes(end+1) = "-hdf5";
+%! endif
+%! for i = 1:numel (modes)
+%!   mode = modes{i};
+%!   nm = tmpnam ();
+%!   unwind_protect
+%!     fcn_handle_save_recurse (2, mode, nm, f2, g2, hm2, hdld2, hbi2);
+%!     clear f2 g2 hm2 hdld2 hbi2
+%!     [f2, f2, hm2, hdld2, hbi2] = fcn_handle_load_recurse (2, nm);
+%!     load (nm);
+%!     assert (f (2), f2 (2));
+%!     assert (g (2), g2 (2));
+%!     assert (g (3), g2 (3));
+%!     unlink (nm);
+%!     fcn_handle_save_recurse (2, mode, nm, f2, g2, hm2, hdld2, hbi2);
+%!   unwind_protect_cleanup
+%!     unlink (nm);
+%!   end_unwind_protect
+%! endfor
+*/
+
 void
 octave_fcn_handle::print (std::ostream& os, bool pr_as_read_syntax) const
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
 
 void
diff --git a/libinterp/octave-value/ov-float.cc b/libinterp/octave-value/ov-float.cc
--- a/libinterp/octave-value/ov-float.cc
+++ b/libinterp/octave-value/ov-float.cc
@@ -316,16 +316,17 @@ octave_float_scalar::map (unary_mapper_t
       SCALAR_MAPPER (sinh, ::sinhf);
       SCALAR_MAPPER (sqrt, rc_sqrt);
       SCALAR_MAPPER (tan, ::tanf);
       SCALAR_MAPPER (tanh, ::tanhf);
       SCALAR_MAPPER (finite, xfinite);
       SCALAR_MAPPER (isinf, xisinf);
       SCALAR_MAPPER (isna, octave_is_NA);
       SCALAR_MAPPER (isnan, xisnan);
+      SCALAR_MAPPER (xsignbit, xsignbit);
 
     default:
       return octave_base_value::map (umap);
     }
 }
 
 bool
 octave_float_scalar::fast_elem_insert_self (void *where, builtin_type_t btyp) const
diff --git a/libinterp/octave-value/ov-flt-cx-diag.cc b/libinterp/octave-value/ov-flt-cx-diag.cc
--- a/libinterp/octave-value/ov-flt-cx-diag.cc
+++ b/libinterp/octave-value/ov-flt-cx-diag.cc
@@ -128,17 +128,17 @@ octave_float_complex_diag_matrix::map (u
     case umap_real:
       return ::real (matrix);
     case umap_conj:
       return ::conj (matrix);
     case umap_imag:
       return ::imag (matrix);
     case umap_sqrt:
       {
-        FloatComplexColumnVector tmp = matrix.diag ().map<FloatComplex> (std::sqrt);
+        FloatComplexColumnVector tmp = matrix.extract_diag ().map<FloatComplex> (std::sqrt);
         FloatComplexDiagMatrix retval (tmp);
         retval.resize (matrix.rows (), matrix.columns ());
         return retval;
       }
     default:
       return to_dense ().map (umap);
     }
 }
@@ -148,17 +148,17 @@ bool
 octave_float_complex_diag_matrix::save_binary (std::ostream& os,
                                                bool& /* save_as_floats */)
 {
 
   int32_t r = matrix.rows (), c = matrix.cols ();
   os.write (reinterpret_cast<char *> (&r), 4);
   os.write (reinterpret_cast<char *> (&c), 4);
 
-  FloatComplexMatrix m = FloatComplexMatrix (matrix.diag ());
+  FloatComplexMatrix m = FloatComplexMatrix (matrix.extract_diag ());
   save_type st = LS_FLOAT;
   if (matrix.length () > 4096) // FIXME -- make this configurable.
     {
       float max_val, min_val;
       if (m.all_integers (max_val, min_val))
         st = get_save_type (max_val, min_val);
     }
 
diff --git a/libinterp/octave-value/ov-flt-re-diag.cc b/libinterp/octave-value/ov-flt-re-diag.cc
--- a/libinterp/octave-value/ov-flt-re-diag.cc
+++ b/libinterp/octave-value/ov-flt-re-diag.cc
@@ -98,17 +98,17 @@ octave_float_diag_matrix::map (unary_map
       return matrix.abs ();
     case umap_real:
     case umap_conj:
       return matrix;
     case umap_imag:
       return DiagMatrix (matrix.rows (), matrix.cols (), 0.0);
     case umap_sqrt:
       {
-        FloatComplexColumnVector tmp = matrix.diag ().map<FloatComplex> (rc_sqrt);
+        FloatComplexColumnVector tmp = matrix.extract_diag ().map<FloatComplex> (rc_sqrt);
         FloatComplexDiagMatrix retval (tmp);
         retval.resize (matrix.rows (), matrix.columns ());
         return retval;
       }
     default:
       return to_dense ().map (umap);
     }
 }
@@ -117,17 +117,17 @@ bool
 octave_float_diag_matrix::save_binary (std::ostream& os,
                                        bool& /* save_as_floats*/)
 {
 
   int32_t r = matrix.rows (), c = matrix.cols ();
   os.write (reinterpret_cast<char *> (&r), 4);
   os.write (reinterpret_cast<char *> (&c), 4);
 
-  FloatMatrix m = FloatMatrix (matrix.diag ());
+  FloatMatrix m = FloatMatrix (matrix.extract_diag ());
   save_type st = LS_FLOAT;
   if (matrix.length () > 8192) // FIXME -- make this configurable.
     {
       float max_val, min_val;
       if (m.all_integers (max_val, min_val))
         st = get_save_type (max_val, min_val);
     }
 
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -801,16 +801,17 @@ octave_float_matrix::map (unary_mapper_t
       ARRAY_MAPPER (roundb, float, xroundb);
       ARRAY_MAPPER (signum, float, ::signum);
       ARRAY_MAPPER (sin, float, ::sinf);
       ARRAY_MAPPER (sinh, float, ::sinhf);
       RC_ARRAY_MAPPER (sqrt, FloatComplex, rc_sqrt);
       ARRAY_MAPPER (tan, float, ::tanf);
       ARRAY_MAPPER (tanh, float, ::tanhf);
       ARRAY_MAPPER (isna, bool, octave_is_NA);
+      ARRAY_MAPPER (xsignbit, float, xsignbit);
 
     default:
       return octave_base_value::map (umap);
     }
 }
 
 DEFUN (single, args, ,
   "-*- texinfo -*-\n\
diff --git a/libinterp/octave-value/ov-oncleanup.cc b/libinterp/octave-value/ov-oncleanup.cc
--- a/libinterp/octave-value/ov-oncleanup.cc
+++ b/libinterp/octave-value/ov-oncleanup.cc
@@ -87,33 +87,28 @@ octave_oncleanup::~octave_oncleanup (voi
       // Run the actual code.
       fcn.do_multi_index_op (0, octave_value_list ());
     }
   catch (octave_interrupt_exception)
     {
       // Swallow the interrupt.
       warning ("onCleanup: interrupt occured in cleanup action");
     }
-  catch (std::bad_alloc)
-    {
-      // Swallow the exception.
-      warning ("onCleanup: out of memory occured in cleanup action");
-    }
   catch (...) // Yes, the black hole. We're in a d-tor.
     {
       // This shouldn't happen, in theory.
       error ("onCleanup: internal error: unhandled exception in cleanup action");
     }
 
   // We don't want to ignore errors that occur in the cleanup code, so
   // if an error is encountered there, leave error_state alone.
   // Otherwise, set it back to what it was before.
   if (error_state)
     {
-      frame.discard_top ();
+      frame.discard_first ();
       octave_call_stack::backtrace_error_message ();
     }
 }
 
 octave_scalar_map
 octave_oncleanup::scalar_map_value (void) const
 {
   octave_scalar_map retval;
diff --git a/libinterp/octave-value/ov-re-diag.cc b/libinterp/octave-value/ov-re-diag.cc
--- a/libinterp/octave-value/ov-re-diag.cc
+++ b/libinterp/octave-value/ov-re-diag.cc
@@ -158,17 +158,17 @@ octave_diag_matrix::map (unary_mapper_t 
       return matrix.abs ();
     case umap_real:
     case umap_conj:
       return matrix;
     case umap_imag:
       return DiagMatrix (matrix.rows (), matrix.cols (), 0.0);
     case umap_sqrt:
       {
-        ComplexColumnVector tmp = matrix.diag ().map<Complex> (rc_sqrt);
+        ComplexColumnVector tmp = matrix.extract_diag ().map<Complex> (rc_sqrt);
         ComplexDiagMatrix retval (tmp);
         retval.resize (matrix.rows (), matrix.columns ());
         return retval;
       }
     default:
       return to_dense ().map (umap);
     }
 }
@@ -176,17 +176,17 @@ octave_diag_matrix::map (unary_mapper_t 
 bool
 octave_diag_matrix::save_binary (std::ostream& os, bool& save_as_floats)
 {
 
   int32_t r = matrix.rows (), c = matrix.cols ();
   os.write (reinterpret_cast<char *> (&r), 4);
   os.write (reinterpret_cast<char *> (&c), 4);
 
-  Matrix m = Matrix (matrix.diag ());
+  Matrix m = Matrix (matrix.extract_diag ());
   save_type st = LS_DOUBLE;
   if (save_as_floats)
     {
       if (m.too_large_for_float ())
         {
           warning ("save: some values too large to save as floats --");
           warning ("save: saving as doubles instead");
         }
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -924,16 +924,17 @@ octave_matrix::map (unary_mapper_t umap)
       ARRAY_MAPPER (roundb, double, xroundb);
       ARRAY_MAPPER (signum, double, ::signum);
       ARRAY_MAPPER (sin, double, ::sin);
       ARRAY_MAPPER (sinh, double, ::sinh);
       RC_ARRAY_MAPPER (sqrt, Complex, rc_sqrt);
       ARRAY_MAPPER (tan, double, ::tan);
       ARRAY_MAPPER (tanh, double, ::tanh);
       ARRAY_MAPPER (isna, bool, octave_is_NA);
+      ARRAY_MAPPER (xsignbit, double, xsignbit);
 
     default:
       if (umap >= umap_xisalnum && umap <= umap_xtoupper)
         {
           octave_value str_conv = convert_to_str (true, true);
           return error_state ? octave_value () : str_conv.map (umap);
         }
       else
diff --git a/libinterp/octave-value/ov-scalar.cc b/libinterp/octave-value/ov-scalar.cc
--- a/libinterp/octave-value/ov-scalar.cc
+++ b/libinterp/octave-value/ov-scalar.cc
@@ -332,16 +332,17 @@ octave_scalar::map (unary_mapper_t umap)
       SCALAR_MAPPER (sinh, ::sinh);
       SCALAR_MAPPER (sqrt, rc_sqrt);
       SCALAR_MAPPER (tan, ::tan);
       SCALAR_MAPPER (tanh, ::tanh);
       SCALAR_MAPPER (finite, xfinite);
       SCALAR_MAPPER (isinf, xisinf);
       SCALAR_MAPPER (isna, octave_is_NA);
       SCALAR_MAPPER (isnan, xisnan);
+      SCALAR_MAPPER (xsignbit, xsignbit);
 
     default:
       if (umap >= umap_xisalnum && umap <= umap_xtoupper)
         {
           octave_value str_conv = convert_to_str (true, true);
           return error_state ? octave_value () : str_conv.map (umap);
         }
       else
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -80,17 +80,17 @@ octave_struct::dotref (const octave_valu
 
   octave_map::const_iterator p = map.seek (nm);
 
   if (p != map.end ())
     retval = map.contents (p);
   else if (auto_add)
     retval = (numel () == 0) ? Cell (dim_vector (1, 1)) : Cell (dims ());
   else
-    error ("structure has no member `%s'", nm.c_str ());
+    error ("structure has no member '%s'", nm.c_str ());
 
   return retval;
 }
 
 #if 0
 static void
 gripe_invalid_index1 (void)
 {
@@ -1095,17 +1095,17 @@ octave_scalar_struct::dotref (const octa
 {
   assert (idx.length () == 1);
 
   std::string nm = idx(0).string_value ();
 
   octave_value retval = map.getfield (nm);
 
   if (! auto_add && retval.is_undefined ())
-    error ("structure has no member `%s'", nm.c_str ());
+    error ("structure has no member '%s'", nm.c_str ());
 
   return retval;
 }
 
 octave_value
 octave_scalar_struct::subsref (const std::string& type,
                                const std::list<octave_value_list>& idx)
 {
@@ -1802,17 +1802,17 @@ If the argument is an object, return the
 
       std::string key (args(i).string_value ());
 
       if (error_state)
         return retval;
 
       if (! valid_identifier (key))
         {
-          error ("struct: invalid structure field name `%s'", key.c_str ());
+          error ("struct: invalid structure field name '%s'", key.c_str ());
           return retval;
         }
 
       // Value may be v, { v }, or { v1, v2, ... }
       // In the first two cases, we need to create a cell array of
       // the appropriate dimensions filled with v.  In the last case,
       // the cell array has already been determined to be of the
       // correct dimensions.
@@ -2139,20 +2139,21 @@ A(1)\n\
 */
 
 
 // So we can call Fcellstr directly.
 extern octave_value_list Fcellstr (const octave_value_list& args, int);
 
 DEFUN (rmfield, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} rmfield (@var{s}, @var{f})\n\
+@deftypefn  {Built-in Function} {@var{s} =} rmfield (@var{s}, \"@var{f}\")\n\
+@deftypefnx {Built-in Function} {@var{s} =} rmfield (@var{s}, @var{f})\n\
 Return a copy of the structure (array) @var{s} with the field @var{f}\n\
 removed.  If @var{f} is a cell array of strings or a character array, remove\n\
-the named fields.\n\
+each of the named fields.\n\
 @seealso{cellstr, iscellstr, setfield}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2)
@@ -2187,18 +2188,24 @@ the named fields.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 ## test rmfield
+%!shared x
+%! x(3).d=1;  x(2).a=2;  x(1).b=3;  x(2).c=3;  x(6).f="abc123";
+%!
 %!test
-%! x(3).d=1;  x(2).a=2;  x(1).b=3;  x(2).c=3;  x(6).f="abc123";
+%! y = rmfield (x, "c");
+%! assert (fieldnames (y), {"d"; "a"; "b"; "f"});
+%! assert (size (y), [1, 6]);
+%!test
 %! y = rmfield (x, {"a", "f"});
 %! assert (fieldnames (y), {"d"; "b"; "c"});
 %! assert (size (y), [1, 6]);
 */
 
 DEFUN (struct_levels_to_print, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} struct_levels_to_print ()\n\
diff --git a/libinterp/octave-value/ov-typeinfo.cc b/libinterp/octave-value/ov-typeinfo.cc
--- a/libinterp/octave-value/ov-typeinfo.cc
+++ b/libinterp/octave-value/ov-typeinfo.cc
@@ -238,17 +238,17 @@ octave_value_typeinfo::do_register_type 
 bool
 octave_value_typeinfo::do_register_unary_class_op (octave_value::unary_op op,
                                                    octave_value_typeinfo::unary_class_op_fcn f)
 {
   if (lookup_unary_class_op (op))
     {
       std::string op_name = octave_value::unary_op_as_string (op);
 
-      warning ("duplicate unary operator `%s' for class dispatch",
+      warning ("duplicate unary operator '%s' for class dispatch",
                op_name.c_str ());
     }
 
   unary_class_ops.checkelem (static_cast<int> (op)) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
@@ -256,17 +256,17 @@ bool
 octave_value_typeinfo::do_register_unary_op (octave_value::unary_op op,
                                              int t, octave_value_typeinfo::unary_op_fcn f)
 {
   if (lookup_unary_op (op, t))
     {
       std::string op_name = octave_value::unary_op_as_string (op);
       std::string type_name = types(t);
 
-      warning ("duplicate unary operator `%s' for type `%s'",
+      warning ("duplicate unary operator '%s' for type '%s'",
                op_name.c_str (), type_name.c_str ());
     }
 
   unary_ops.checkelem (static_cast<int> (op), t) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
@@ -274,34 +274,34 @@ bool
 octave_value_typeinfo::do_register_non_const_unary_op
   (octave_value::unary_op op, int t, octave_value_typeinfo::non_const_unary_op_fcn f)
 {
   if (lookup_non_const_unary_op (op, t))
     {
       std::string op_name = octave_value::unary_op_as_string (op);
       std::string type_name = types(t);
 
-      warning ("duplicate unary operator `%s' for type `%s'",
+      warning ("duplicate unary operator '%s' for type '%s'",
                op_name.c_str (), type_name.c_str ());
     }
 
   non_const_unary_ops.checkelem (static_cast<int> (op), t) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_binary_class_op (octave_value::binary_op op,
                                                     octave_value_typeinfo::binary_class_op_fcn f)
 {
   if (lookup_binary_class_op (op))
     {
       std::string op_name = octave_value::binary_op_as_string (op);
 
-      warning ("duplicate binary operator `%s' for class dispatch",
+      warning ("duplicate binary operator '%s' for class dispatch",
                op_name.c_str ());
     }
 
   binary_class_ops.checkelem (static_cast<int> (op)) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
@@ -311,34 +311,34 @@ octave_value_typeinfo::do_register_binar
                                               octave_value_typeinfo::binary_op_fcn f)
 {
   if (lookup_binary_op (op, t1, t2))
     {
       std::string op_name = octave_value::binary_op_as_string (op);
       std::string t1_name = types(t1);
       std::string t2_name = types(t2);
 
-      warning ("duplicate binary operator `%s' for types `%s' and `%s'",
+      warning ("duplicate binary operator '%s' for types '%s' and '%s'",
                op_name.c_str (), t1_name.c_str (), t1_name.c_str ());
     }
 
   binary_ops.checkelem (static_cast<int> (op), t1, t2) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_binary_class_op (octave_value::compound_binary_op op,
                                                     octave_value_typeinfo::binary_class_op_fcn f)
 {
   if (lookup_binary_class_op (op))
     {
       std::string op_name = octave_value::binary_op_fcn_name (op);
 
-      warning ("duplicate compound binary operator `%s' for class dispatch",
+      warning ("duplicate compound binary operator '%s' for class dispatch",
                op_name.c_str ());
     }
 
   compound_binary_class_ops.checkelem (static_cast<int> (op)) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
@@ -348,34 +348,34 @@ octave_value_typeinfo::do_register_binar
                                               octave_value_typeinfo::binary_op_fcn f)
 {
   if (lookup_binary_op (op, t1, t2))
     {
       std::string op_name = octave_value::binary_op_fcn_name (op);
       std::string t1_name = types(t1);
       std::string t2_name = types(t2);
 
-      warning ("duplicate compound binary operator `%s' for types `%s' and `%s'",
+      warning ("duplicate compound binary operator '%s' for types '%s' and '%s'",
                op_name.c_str (), t1_name.c_str (), t1_name.c_str ());
     }
 
   compound_binary_ops.checkelem (static_cast<int> (op), t1, t2) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_cat_op (int t1, int t2, octave_value_typeinfo::cat_op_fcn f)
 {
   if (lookup_cat_op (t1, t2))
     {
       std::string t1_name = types(t1);
       std::string t2_name = types(t2);
 
-      warning ("duplicate concatenation operator for types `%s' and `%s'",
+      warning ("duplicate concatenation operator for types '%s' and '%s'",
                t1_name.c_str (), t1_name.c_str ());
     }
 
   cat_ops.checkelem (t1, t2) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
@@ -385,17 +385,17 @@ octave_value_typeinfo::do_register_assig
                                               octave_value_typeinfo::assign_op_fcn f)
 {
   if (lookup_assign_op (op, t_lhs, t_rhs))
     {
       std::string op_name = octave_value::assign_op_as_string (op);
       std::string t_lhs_name = types(t_lhs);
       std::string t_rhs_name = types(t_rhs);
 
-      warning ("duplicate assignment operator `%s' for types `%s' and `%s'",
+      warning ("duplicate assignment operator '%s' for types '%s' and '%s'",
                op_name.c_str (), t_lhs_name.c_str (), t_rhs_name.c_str ());
     }
 
   assign_ops.checkelem (static_cast<int> (op), t_lhs, t_rhs) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
@@ -403,17 +403,17 @@ bool
 octave_value_typeinfo::do_register_assignany_op (octave_value::assign_op op,
                                                  int t_lhs, octave_value_typeinfo::assignany_op_fcn f)
 {
   if (lookup_assignany_op (op, t_lhs))
     {
       std::string op_name = octave_value::assign_op_as_string (op);
       std::string t_lhs_name = types(t_lhs);
 
-      warning ("duplicate assignment operator `%s' for types `%s'",
+      warning ("duplicate assignment operator '%s' for types '%s'",
                op_name.c_str (), t_lhs_name.c_str ());
     }
 
   assignany_ops.checkelem (static_cast<int> (op), t_lhs) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
@@ -421,17 +421,17 @@ bool
 octave_value_typeinfo::do_register_pref_assign_conv (int t_lhs, int t_rhs,
                                                      int t_result)
 {
   if (lookup_pref_assign_conv (t_lhs, t_rhs) >= 0)
     {
       std::string t_lhs_name = types(t_lhs);
       std::string t_rhs_name = types(t_rhs);
 
-      warning ("overriding assignment conversion for types `%s' and `%s'",
+      warning ("overriding assignment conversion for types '%s' and '%s'",
                t_lhs_name.c_str (), t_rhs_name.c_str ());
     }
 
   pref_assign_conv.checkelem (t_lhs, t_rhs) = t_result;
 
   return false;
 }
 
@@ -439,17 +439,17 @@ bool
 octave_value_typeinfo::do_register_type_conv_op
   (int t, int t_result, octave_base_value::type_conv_fcn f)
 {
   if (lookup_type_conv_op (t, t_result))
     {
       std::string t_name = types(t);
       std::string t_result_name = types(t_result);
 
-      warning ("overriding type conversion op for `%s' to `%s'",
+      warning ("overriding type conversion op for '%s' to '%s'",
                t_name.c_str (), t_result_name.c_str ());
     }
 
   type_conv_ops.checkelem (t, t_result) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
@@ -457,17 +457,17 @@ bool
 octave_value_typeinfo::do_register_widening_op
   (int t, int t_result, octave_base_value::type_conv_fcn f)
 {
   if (lookup_widening_op (t, t_result))
     {
       std::string t_name = types(t);
       std::string t_result_name = types(t_result);
 
-      warning ("overriding widening op for `%s' to `%s'",
+      warning ("overriding widening op for '%s' to '%s'",
                t_name.c_str (), t_result_name.c_str ());
     }
 
   widening_ops.checkelem (t, t_result) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -25,25 +25,27 @@ along with Octave; see the file COPYING.
 #endif
 
 #include <sstream>
 
 #include "str-vec.h"
 
 #include <defaults.h>
 #include "Cell.h"
+#include "builtins.h"
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "input.h"
 #include "oct-obj.h"
 #include "ov-usr-fcn.h"
 #include "ov.h"
 #include "pager.h"
 #include "pt-eval.h"
+#include "pt-jit.h"
 #include "pt-jump.h"
 #include "pt-misc.h"
 #include "pt-pr-code.h"
 #include "pt-stmt.h"
 #include "pt-walk.h"
 #include "symtab.h"
 #include "toplev.h"
 #include "unwind-prot.h"
@@ -187,32 +189,39 @@ octave_user_function::octave_user_functi
     t_checked (static_cast<time_t> (0)),
     system_fcn_file (false), call_depth (-1),
     num_named_args (param_list ? param_list->length () : 0),
     subfunction (false), inline_function (false),
     anonymous_function (false), nested_function (false),
     class_constructor (false), class_method (false),
     parent_scope (-1), local_scope (sid),
     curr_unwind_protect_frame (0)
+#ifdef HAVE_LLVM
+    , jit_info (0)
+#endif
 {
   if (cmd_list)
     cmd_list->mark_as_function_body ();
 
   if (local_scope >= 0)
     symbol_table::set_curr_fcn (this, local_scope);
 }
 
 octave_user_function::~octave_user_function (void)
 {
   delete param_list;
   delete ret_list;
   delete cmd_list;
   delete lead_comm;
   delete trail_comm;
 
+#ifdef HAVE_LLVM
+  delete jit_info;
+#endif
+
   symbol_table::erase_scope (local_scope);
 }
 
 octave_user_function *
 octave_user_function::define_ret_list (tree_parameter_list *t)
 {
   ret_list = t;
 
@@ -367,16 +376,22 @@ octave_user_function::do_multi_index_op 
   octave_value_list retval;
 
   if (error_state)
     return retval;
 
   if (! cmd_list)
     return retval;
 
+#ifdef HAVE_LLVM
+  if (Venable_jit_compiler && is_special_expr ()
+      && tree_jit::execute (*this, args, retval))
+    return retval;
+#endif
+
   int nargin = args.length ();
 
   unwind_protect frame;
 
   frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth >= Vmax_recursion_depth)
@@ -436,49 +451,42 @@ octave_user_function::do_multi_index_op 
       // undefined by the clear_param_list cleanup function.
 
       frame.add_fcn (symbol_table::clear_variables);
     }
 
   bind_automatic_vars (arg_names, nargin, nargout, all_va_args (args),
                        lvalue_list);
 
+  frame.add_method (this, &octave_user_function::restore_warning_states);
+
   bool echo_commands = (Vecho_executing_commands & ECHO_FUNCTIONS);
 
   if (echo_commands)
     print_code_function_header ();
 
   // Set pointer to the current unwind_protect frame to allow
   // certain builtins register simple cleanup in a very optimized manner.
   // This is *not* intended as a general-purpose on-cleanup mechanism,
   frame.protect_var (curr_unwind_protect_frame);
   curr_unwind_protect_frame = &frame;
 
   // Evaluate the commands that make up the function.
 
   frame.protect_var (tree_evaluator::statement_context);
   tree_evaluator::statement_context = tree_evaluator::function;
 
-  bool special_expr = (is_inline_function () || is_anonymous_function ());
-
   BEGIN_PROFILER_BLOCK (profiler_name ())
 
-  if (special_expr)
+  if (is_special_expr ())
     {
-      assert (cmd_list->length () == 1);
-
-      tree_statement *stmt = 0;
+      tree_expression *expr = special_expr ();
 
-      if ((stmt = cmd_list->front ())
-          && stmt->is_expression ())
-        {
-          tree_expression *expr = stmt->expression ();
-
-          retval = expr->rvalue (nargout);
-        }
+      if (expr)
+        retval = expr->rvalue (nargout);
     }
   else
     cmd_list->accept (*current_evaluator);
 
   END_PROFILER_BLOCK
 
   if (echo_commands)
     print_code_function_trailer ();
@@ -492,17 +500,17 @@ octave_user_function::do_multi_index_op 
   if (error_state)
     {
       octave_call_stack::backtrace_error_message ();
       return retval;
     }
 
   // Copy return values out.
 
-  if (ret_list && ! special_expr)
+  if (ret_list && ! is_special_expr ())
     {
       ret_list->initialize_undefined_elements (my_name, nargout, Matrix ());
 
       Cell varargout;
 
       if (ret_list->takes_varargs ())
         {
           octave_value varargout_varval = symbol_table::varval ("varargout");
@@ -524,16 +532,26 @@ octave_user_function::do_multi_index_op 
 }
 
 void
 octave_user_function::accept (tree_walker& tw)
 {
   tw.visit_octave_user_function (*this);
 }
 
+tree_expression *
+octave_user_function::special_expr (void)
+{
+  assert (is_special_expr ());
+  assert (cmd_list->length () == 1);
+
+  tree_statement *stmt = cmd_list->front ();
+  return stmt->expression ();
+}
+
 bool
 octave_user_function::subsasgn_optimization_ok (void)
 {
   bool retval = false;
   if (Voptimize_subsasgn_calls
       && param_list->length () > 0 && ! param_list->varargs_only ()
       && ret_list->length () == 1 && ! ret_list->takes_varargs ())
     {
@@ -576,34 +594,39 @@ octave_user_function::bind_automatic_var
 {
   if (! arg_names.empty ())
     {
       // It is better to save this in the hidden variable .argn. and
       // then use that in the inputname function instead of using argn,
       // which might be redefined in a function.  Keep the old argn name
       // for backward compatibility of functions that use it directly.
 
-      symbol_table::varref ("argn") = arg_names;
-      symbol_table::varref (".argn.") = Cell (arg_names);
+      symbol_table::force_varref ("argn") = arg_names;
+      symbol_table::force_varref (".argn.") = Cell (arg_names);
 
       symbol_table::mark_hidden (".argn.");
 
       symbol_table::mark_automatic ("argn");
       symbol_table::mark_automatic (".argn.");
     }
 
-  symbol_table::varref (".nargin.") = nargin;
-  symbol_table::varref (".nargout.") = nargout;
+  symbol_table::force_varref (".nargin.") = nargin;
+  symbol_table::force_varref (".nargout.") = nargout;
 
   symbol_table::mark_hidden (".nargin.");
   symbol_table::mark_hidden (".nargout.");
 
   symbol_table::mark_automatic (".nargin.");
   symbol_table::mark_automatic (".nargout.");
 
+  symbol_table::varref (".saved_warning_states.") = octave_value ();
+
+  symbol_table::mark_automatic (".saved_warning_states.");
+  symbol_table::mark_automatic (".saved_warning_states.");
+
   if (takes_varargs ())
     symbol_table::varref ("varargin") = va_args.cell_value ();
 
   // Force .ignored. variable to be undefined by default.
   symbol_table::varref (".ignored.") = octave_value ();
 
   if (lvalue_list)
     {
@@ -628,16 +651,36 @@ octave_user_function::bind_automatic_var
           symbol_table::varref (".ignored.") = bh;
         }
     }
 
   symbol_table::mark_hidden (".ignored.");
   symbol_table::mark_automatic (".ignored.");
 }
 
+void
+octave_user_function::restore_warning_states (void)
+{
+  octave_value val = symbol_table::varval (".saved_warning_states.");
+
+  if (val.is_defined ())
+    {
+      octave_map m = val.map_value ();
+
+      if (error_state)
+        panic_impossible ();
+
+      Cell ids = m.contents ("identifier");
+      Cell states = m.contents ("state");
+
+      for (octave_idx_type i = 0; i < m.numel (); i++)
+        Fwarning (ovl (states(i), ids(i)));
+    }
+}
+
 DEFUN (nargin, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} nargin ()\n\
 @deftypefnx {Built-in Function} {} nargin (@var{fcn})\n\
 Within a function, return the number of arguments passed to the function.\n\
 At the top level, return the number of command line arguments passed to\n\
 Octave.\n\
 \n\
diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -36,18 +36,23 @@ along with Octave; see the file COPYING.
 #include "unwind-prot.h"
 
 class string_vector;
 
 class octave_value;
 class tree_parameter_list;
 class tree_statement_list;
 class tree_va_return_list;
+class tree_expression;
 class tree_walker;
 
+#ifdef HAVE_LLVM
+class jit_function_info;
+#endif
+
 class
 octave_user_code : public octave_function
 {
 public:
   octave_user_code (void)
     : octave_function () { }
 
   ~octave_user_code (void) { }
@@ -278,16 +283,24 @@ public:
   {
     return anonymous_function
       ? (cname.empty ()
          ? (! dispatch_class ().empty ())
          : cname == dispatch_class ())
       : false;
   }
 
+  // If we are a special expression, then the function body consists of exactly
+  // one expression. The expression's result is the return value of the
+  // function.
+  bool is_special_expr (void) const
+  {
+    return is_inline_function () || is_anonymous_function ();
+  }
+
   bool is_nested_function (void) const { return nested_function; }
 
   void mark_as_nested_function (void) { nested_function = true; }
 
   void mark_as_class_constructor (void) { class_constructor = true; }
 
   bool is_class_constructor (const std::string& cname = std::string ()) const
     {
@@ -330,32 +343,42 @@ public:
   tree_parameter_list *return_list (void) { return ret_list; }
 
   tree_statement_list *body (void) { return cmd_list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
+  // If is_special_expr is true, retrieve the sigular expression that forms the
+  // body. May be null (even if is_special_expr is true).
+  tree_expression *special_expr (void);
+
   bool subsasgn_optimization_ok (void);
 
   void accept (tree_walker& tw);
 
   template <class T>
   bool local_protect (T& variable)
     {
       if (curr_unwind_protect_frame)
         {
           curr_unwind_protect_frame->protect_var (variable);
           return true;
         }
       else
         return false;
     }
 
+#ifdef HAVE_LLVM
+  jit_function_info *get_info (void) { return jit_info; }
+
+  void stash_info (jit_function_info *info) { jit_info = info; }
+#endif
+
 #if 0
   void print_symtab_info (std::ostream& os) const;
 #endif
 
 private:
 
   // List of arguments for this function.  These are local variables.
   tree_parameter_list *param_list;
@@ -422,16 +445,20 @@ private:
   // The scope of the parent function, if any.
   symbol_table::scope_id parent_scope;
 
   symbol_table::scope_id local_scope;
 
   // pointer to the current unwind_protect frame of this function.
   unwind_protect *curr_unwind_protect_frame;
 
+#ifdef HAVE_LLVM
+  jit_function_info *jit_info;
+#endif
+
 #if 0
   // The symbol record for argn in the local symbol table.
   octave_value& argn_varref;
 
   // The symbol record for nargin in the local symbol table.
   octave_value& nargin_varref;
 
   // The symbol record for nargout in the local symbol table.
@@ -444,16 +471,18 @@ private:
   void print_code_function_header (void);
 
   void print_code_function_trailer (void);
 
   void bind_automatic_vars (const string_vector& arg_names, int nargin,
                             int nargout, const octave_value_list& va_args,
                             const std::list<octave_lvalue> *lvalue_list);
 
+  void restore_warning_states (void);
+
   // No copying!
 
   octave_user_function (const octave_user_function& fn);
 
   octave_user_function& operator = (const octave_user_function& fn);
 
   DECLARE_OCTAVE_ALLOCATOR
 
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -665,16 +665,40 @@ octave_value::octave_value (const Array<
 }
 
 octave_value::octave_value (const Array<float>& a)
   : rep (new octave_float_matrix (a))
 {
   maybe_mutate ();
 }
 
+octave_value::octave_value (const DiagArray2<double>& d)
+  : rep (new octave_diag_matrix (d))
+{
+  maybe_mutate ();
+}
+
+octave_value::octave_value (const DiagArray2<float>& d)
+  : rep (new octave_float_diag_matrix (d))
+{
+  maybe_mutate ();
+}
+
+octave_value::octave_value (const DiagArray2<Complex>& d)
+  : rep (new octave_complex_diag_matrix (d))
+{
+  maybe_mutate ();
+}
+
+octave_value::octave_value (const DiagArray2<FloatComplex>& d)
+  : rep (new octave_float_complex_diag_matrix (d))
+{
+  maybe_mutate ();
+}
+
 octave_value::octave_value (const DiagMatrix& d)
   : rep (new octave_diag_matrix (d))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const FloatDiagMatrix& d)
   : rep (new octave_float_diag_matrix (d))
@@ -1315,27 +1339,27 @@ octave_value::do_multi_index_op (int nar
   return rep->do_multi_index_op (nargout, idx, lvalue_list);
 }
 
 #if 0
 static void
 gripe_assign_failed (const std::string& on, const std::string& tn1,
                      const std::string& tn2)
 {
-  error ("assignment failed for `%s %s %s'",
+  error ("assignment failed for '%s %s %s'",
          tn1.c_str (), on.c_str (), tn2.c_str ());
 }
 #endif
 
 static void
 gripe_assign_failed_or_no_method (const std::string& on,
                                   const std::string& tn1,
                                   const std::string& tn2)
 {
-  error ("assignment failed, or no method for `%s %s %s'",
+  error ("assignment failed, or no method for '%s %s %s'",
          tn1.c_str (), on.c_str (), tn2.c_str ());
 }
 
 octave_value
 octave_value::subsasgn (const std::string& type,
                         const std::list<octave_value_list>& idx,
                         const octave_value& rhs)
 {
@@ -1883,24 +1907,24 @@ octave_value::write (octave_stream& os, 
 {
   return rep->write (os, block_size, output_type, skip, flt_fmt);
 }
 
 static void
 gripe_binary_op (const std::string& on, const std::string& tn1,
                  const std::string& tn2)
 {
-  error ("binary operator `%s' not implemented for `%s' by `%s' operations",
+  error ("binary operator '%s' not implemented for '%s' by '%s' operations",
          on.c_str (), tn1.c_str (), tn2.c_str ());
 }
 
 static void
 gripe_binary_op_conv (const std::string& on)
 {
-  error ("type conversion failed for binary operator `%s'", on.c_str ());
+  error ("type conversion failed for binary operator '%s'", on.c_str ());
 }
 
 octave_value
 do_binary_op (octave_value::binary_op op,
               const octave_value& v1, const octave_value& v2)
 {
   octave_value retval;
 
@@ -2195,17 +2219,17 @@ do_binary_op (octave_value::compound_bin
     }
 
   return retval;
 }
 
 static void
 gripe_cat_op (const std::string& tn1, const std::string& tn2)
 {
-  error ("concatenation operator not implemented for `%s' by `%s' operations",
+  error ("concatenation operator not implemented for '%s' by '%s' operations",
          tn1.c_str (), tn2.c_str ());
 }
 
 static void
 gripe_cat_op_conv (void)
 {
   error ("type conversion failed for concatenation operator");
 }
@@ -2307,24 +2331,24 @@ octave_value::print_info (std::ostream& 
      << prefix << "rep info:  ";
 
   rep->print_info (os, prefix + " ");
 }
 
 static void
 gripe_unary_op (const std::string& on, const std::string& tn)
 {
-  error ("unary operator `%s' not implemented for `%s' operands",
+  error ("unary operator '%s' not implemented for '%s' operands",
          on.c_str (), tn.c_str ());
 }
 
 static void
 gripe_unary_op_conv (const std::string& on)
 {
-  error ("type conversion failed for unary operator `%s'", on.c_str ());
+  error ("type conversion failed for unary operator '%s'", on.c_str ());
 }
 
 octave_value
 do_unary_op (octave_value::unary_op op, const octave_value& v)
 {
   octave_value retval;
 
   int t = v.type_id ();
@@ -2394,17 +2418,17 @@ do_unary_op (octave_value::unary_op op, 
 
   return retval;
 }
 
 static void
 gripe_unary_op_conversion_failed (const std::string& op,
                                   const std::string& tn)
 {
-  error ("operator %s: type conversion for `%s' failed",
+  error ("operator %s: type conversion for '%s' failed",
          op.c_str (), tn.c_str ());
 }
 
 octave_value&
 octave_value::do_non_const_unary_op (unary_op op)
 {
   if (op == op_incr || op == op_decr)
     {
@@ -2786,17 +2810,17 @@ decode_subscripts (const char* name, con
               if (item == "{}")
                 type_string[k] = '{';
               else if (item == "()")
                 type_string[k] = '(';
               else if (item == ".")
                 type_string[k] = '.';
               else
                 {
-                  error ("%s: invalid indexing type `%s'", name, item.c_str ());
+                  error ("%s: invalid indexing type '%s'", name, item.c_str ());
                   return;
                 }
             }
           else
             {
               error ("%s: expecting type(%d) to be a character string",
                      name, k+1);
               return;
@@ -2825,17 +2849,17 @@ decode_subscripts (const char* name, con
                      name, k+1);
               return;
             }
 
           idx.push_back (idx_item);
         }
     }
   else
-    error ("%s: second argument must be a structure with fields `type' and `subs'", name);
+    error ("%s: second argument must be a structure with fields 'type' and 'subs'", name);
 }
 
 DEFUN (subsref, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} subsref (@var{val}, @var{idx})\n\
 Perform the subscripted element selection operation according to\n\
 the subscript specified by @var{idx}.\n\
 \n\
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -198,16 +198,20 @@ public:
   octave_value (const Cell& c, bool is_cs_list = false);
   octave_value (const Matrix& m, const MatrixType& t = MatrixType ());
   octave_value (const FloatMatrix& m, const MatrixType& t = MatrixType ());
   octave_value (const NDArray& nda);
   octave_value (const FloatNDArray& nda);
   octave_value (const Array<double>& m);
   octave_value (const Array<float>& m);
   octave_value (const DiagMatrix& d);
+  octave_value (const DiagArray2<double>& d);
+  octave_value (const DiagArray2<float>& d);
+  octave_value (const DiagArray2<Complex>& d);
+  octave_value (const DiagArray2<FloatComplex>& d);
   octave_value (const FloatDiagMatrix& d);
   octave_value (const RowVector& v);
   octave_value (const FloatRowVector& v);
   octave_value (const ColumnVector& v);
   octave_value (const FloatColumnVector& v);
   octave_value (const Complex& C);
   octave_value (const FloatComplex& C);
   octave_value (const ComplexMatrix& m, const MatrixType& t = MatrixType ());
@@ -1157,16 +1161,17 @@ public:
   MAPPER_FORWARD (xisdigit)
   MAPPER_FORWARD (xisgraph)
   MAPPER_FORWARD (xislower)
   MAPPER_FORWARD (xisprint)
   MAPPER_FORWARD (xispunct)
   MAPPER_FORWARD (xisspace)
   MAPPER_FORWARD (xisupper)
   MAPPER_FORWARD (xisxdigit)
+  MAPPER_FORWARD (xsignbit)
   MAPPER_FORWARD (xtoascii)
   MAPPER_FORWARD (xtolower)
   MAPPER_FORWARD (xtoupper)
 
 #undef MAPPER_FORWARD
 
   octave_value map (octave_base_value::unary_mapper_t umap) const
     { return rep->map (umap); }
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -38,25 +38,26 @@ along with Octave; see the file COPYING.
 #include <unistd.h>
 
 #include "cmd-edit.h"
 #include "f77-fcn.h"
 #include "file-ops.h"
 #include "file-stat.h"
 #include "lo-error.h"
 #include "oct-env.h"
-#include "pathsearch.h"
 #include "str-vec.h"
 
-#include <defaults.h>
+#include "builtins.h"
+#include "defaults.h"
 #include "Cell.h"
 #include "defun.h"
 #include "display.h"
 #include "error.h"
 #include "file-io.h"
+#include "help.h"
 #include "input.h"
 #include "lex.h"
 #include "load-path.h"
 #include "octave.h"
 #include "oct-conf.h"
 #include "oct-hist.h"
 #include "oct-map.h"
 #include "oct-mutex.h"
@@ -108,20 +109,16 @@ static bool read_site_files = true;
 // TRUE means we set the initial path to configured defaults.
 // (--no-init-path)
 static bool set_initial_path = true;
 
 // TRUE means we don't print the usual startup message.
 // (--quiet; --silent; -q)
 static bool inhibit_startup_message = false;
 
-// TRUE means we turn on compatibility options.
-// (--traditional)
-static bool traditional = false;
-
 // If TRUE, print verbose info in some cases.
 // (--verbose; -V)
 static bool verbose_flag = false;
 
 // If TRUE, force the GUI to start.
 // (--force-gui)
 static bool force_gui_option = false;
 
@@ -136,122 +133,107 @@ static bool forced_line_editing = false;
 // If TRUE, initialize history list from saved history file.
 // (--no-history; -H)
 static bool read_history_file = true;
 
 // The value of "path" specified on the command line.
 // (--path; -p)
 static std::list<std::string> command_line_path;
 
-// Flags used to determine what commands should be echoed when they are
-// parsed and executed.
-// (--echo-commands; -x)
-static int echo_executing_commands = 0;
-
-// The file used for the doc string cache.
-// (--doc-cache-file)
-static std::string doc_cache_file;
-
 // The value for "EXEC_PATH" specified on the command line.
 // (--exec-path)
 static std::string exec_path;
 
 // The value for "IMAGE_PATH" specified on the command line.
 // (--image-path)
 static std::string image_path;
 
-// The value for "info_file" specified on the command line.
-// (--info-file)
-static std::string info_file;
-
-// The value for "info_program" specified on the command line.
-// (--info-program)
-static std::string info_program;
-
 // If TRUE, ignore the window system even if it is available.
 // (--no-window-system)
 static bool no_window_system = false;
 
-// The value for "texi_macros_file" specified on the command line.
-// (--texi-macros-file)
-static std::string texi_macros_file;
-
 // Usage message
 static const char *usage_string =
   "octave [-HVdfhiqvx] [--debug] [--echo-commands] [--eval CODE]\n\
        [--exec-path path] [--force-gui] [--help] [--image-path path]\n\
        [--info-file file] [--info-program prog] [--interactive]\n\
-       [--line-editing] [--no-gui] [--no-history] [--no-init-file]\n\
-       [--no-init-path] [--no-line-editing] [--no-site-file]\n\
-       [--no-window-system] [-p path] [--path path] [--silent]\n\
-       [--traditional] [--verbose] [--version] [file]";
+       [--jit-debugging] [--line-editing] [--no-gui] [--no-history]\n\
+       [--no-init-file] [--no-init-path] [--no-jit-compiler]\n\
+       [--no-line-editing] [--no-site-file] [--no-window-system]\n\
+       [-p path] [--path path] [--silent] [--traditional]\n\
+       [--verbose] [--version] [file]";
 
 // This is here so that it's more likely that the usage message and
-// the real set of options will agree.  Note: the `+' must come first
+// the real set of options will agree.  Note: the '+' must come first
 // to prevent getopt from permuting arguments!
 static const char *short_opts = "+HVdfhip:qvx";
 
 // The code to evaluate at startup (--eval CODE)
 static std::string code_to_eval;
 
 // If TRUE, don't exit after evaluating code given by --eval option.
 static bool persist = false;
 
 // Long options.  See the comments in getopt.h for the meanings of the
 // fields in this structure.
-#define DOC_CACHE_FILE_OPTION 1
-#define EVAL_OPTION 2
-#define EXEC_PATH_OPTION 3
-#define FORCE_GUI_OPTION 4
-#define IMAGE_PATH_OPTION 5
-#define INFO_FILE_OPTION 6
-#define INFO_PROG_OPTION 7
-#define LINE_EDITING_OPTION 8
-#define NO_GUI_OPTION 9
-#define NO_INIT_FILE_OPTION 10
-#define NO_INIT_PATH_OPTION 11
-#define NO_LINE_EDITING_OPTION 12
-#define NO_SITE_FILE_OPTION 13
-#define NO_WINDOW_SYSTEM_OPTION 14
-#define PERSIST_OPTION 15
-#define TEXI_MACROS_FILE_OPTION 16
-#define TRADITIONAL_OPTION 17
-struct option long_opts[] =
-  {
-    { "braindead",        no_argument,       0, TRADITIONAL_OPTION },
-    { "debug",            no_argument,       0, 'd' },
-    { "doc-cache-file",   required_argument, 0, DOC_CACHE_FILE_OPTION },
-    { "echo-commands",    no_argument,       0, 'x' },
-    { "eval",             required_argument, 0, EVAL_OPTION },
-    { "exec-path",        required_argument, 0, EXEC_PATH_OPTION },
-    { "force-gui",        no_argument,       0, FORCE_GUI_OPTION },
-    { "help",             no_argument,       0, 'h' },
-    { "image-path",       required_argument, 0, IMAGE_PATH_OPTION },
-    { "info-file",        required_argument, 0, INFO_FILE_OPTION },
-    { "info-program",     required_argument, 0, INFO_PROG_OPTION },
-    { "interactive",      no_argument,       0, 'i' },
-    { "line-editing",     no_argument,       0, LINE_EDITING_OPTION },
-    { "no-gui",           no_argument,       0, NO_GUI_OPTION },
-    { "no-history",       no_argument,       0, 'H' },
-    { "no-init-file",     no_argument,       0, NO_INIT_FILE_OPTION },
-    { "no-init-path",     no_argument,       0, NO_INIT_PATH_OPTION },
-    { "no-line-editing",  no_argument,       0, NO_LINE_EDITING_OPTION },
-    { "no-site-file",     no_argument,       0, NO_SITE_FILE_OPTION },
-    { "no-window-system", no_argument,       0, NO_WINDOW_SYSTEM_OPTION },
-    { "norc",             no_argument,       0, 'f' },
-    { "path",             required_argument, 0, 'p' },
-    { "persist",          no_argument,       0, PERSIST_OPTION },
-    { "quiet",            no_argument,       0, 'q' },
-    { "silent",           no_argument,       0, 'q' },
-    { "texi-macros-file", required_argument, 0, TEXI_MACROS_FILE_OPTION },
-    { "traditional",      no_argument,       0, TRADITIONAL_OPTION },
-    { "verbose",          no_argument,       0, 'V' },
-    { "version",          no_argument,       0, 'v' },
-    { 0,                  0,                 0, 0 }
-  };
+#define BUILT_IN_DOCSTRINGS_FILE_OPTION 1
+#define DOC_CACHE_FILE_OPTION 2
+#define EVAL_OPTION 3
+#define EXEC_PATH_OPTION 4
+#define FORCE_GUI_OPTION 5
+#define IMAGE_PATH_OPTION 6
+#define INFO_FILE_OPTION 7
+#define INFO_PROG_OPTION 8
+#define JIT_DEBUGGING_OPTION 9
+#define LINE_EDITING_OPTION 10
+#define NO_GUI_OPTION 11
+#define NO_INIT_FILE_OPTION 12
+#define NO_INIT_PATH_OPTION 13
+#define NO_JIT_COMPILER_OPTION 14
+#define NO_LINE_EDITING_OPTION 15
+#define NO_SITE_FILE_OPTION 16
+#define NO_WINDOW_SYSTEM_OPTION 17
+#define PERSIST_OPTION 18
+#define TEXI_MACROS_FILE_OPTION 19
+#define TRADITIONAL_OPTION 20
+struct option long_opts[] = {
+  { "braindead",                no_argument,       0, TRADITIONAL_OPTION },
+  { "built-in-docstrings-file", required_argument, 0, BUILT_IN_DOCSTRINGS_FILE_OPTION },
+  { "debug",                    no_argument,       0, 'd' },
+  { "doc-cache-file",           required_argument, 0, DOC_CACHE_FILE_OPTION },
+  { "echo-commands",            no_argument,       0, 'x' },
+  { "eval",                     required_argument, 0, EVAL_OPTION },
+  { "exec-path",                required_argument, 0, EXEC_PATH_OPTION },
+  { "force-gui",                no_argument,       0, FORCE_GUI_OPTION },
+  { "help",                     no_argument,       0, 'h' },
+  { "image-path",               required_argument, 0, IMAGE_PATH_OPTION },
+  { "info-file",                required_argument, 0, INFO_FILE_OPTION },
+  { "info-program",             required_argument, 0, INFO_PROG_OPTION },
+  { "interactive",              no_argument,       0, 'i' },
+  { "jit-debugging",            no_argument,       0, JIT_DEBUGGING_OPTION },
+  { "line-editing",             no_argument,       0, LINE_EDITING_OPTION },
+  { "no-gui",                   no_argument,       0, NO_GUI_OPTION },
+  { "no-history",               no_argument,       0, 'H' },
+  { "no-init-file",             no_argument,       0, NO_INIT_FILE_OPTION },
+  { "no-init-path",             no_argument,       0, NO_INIT_PATH_OPTION },
+  { "no-jit-compiler",          no_argument,       0, NO_JIT_COMPILER_OPTION },
+  { "no-line-editing",          no_argument,       0, NO_LINE_EDITING_OPTION },
+  { "no-site-file",             no_argument,       0, NO_SITE_FILE_OPTION },
+  { "no-window-system",         no_argument,       0, NO_WINDOW_SYSTEM_OPTION },
+  { "norc",                     no_argument,       0, 'f' },
+  { "path",                     required_argument, 0, 'p' },
+  { "persist",                  no_argument,       0, PERSIST_OPTION },
+  { "quiet",                    no_argument,       0, 'q' },
+  { "silent",                   no_argument,       0, 'q' },
+  { "texi-macros-file",         required_argument, 0, TEXI_MACROS_FILE_OPTION },
+  { "traditional",              no_argument,       0, TRADITIONAL_OPTION },
+  { "verbose",                  no_argument,       0, 'V' },
+  { "version",                  no_argument,       0, 'v' },
+  { 0,                          0,                 0, 0 }
+};
 
 // Store the command-line options for later use.
 
 static void
 intern_argv (int argc, char **argv)
 {
   assert (symbol_table::at_top_level ());
 
@@ -265,34 +247,16 @@ intern_argv (int argc, char **argv)
 
       // Skip program name in argv.
       int i = argc;
       while (--i > 0)
         octave_argv[i-1] = *(argv+i);
     }
 }
 
-static void
-initialize_pathsearch (void)
-{
-  // This may seem odd, but doing it this way means that we don't have
-  // to modify the kpathsea library...
-
-  std::string odb = octave_env::getenv ("OCTAVE_DB_PATH");
-
-  // For backward compatibility.
-
-  if (odb.empty ())
-    odb = octave_env::getenv ("OCTAVE_DB_DIR");
-
-  if (odb.empty ())
-    odb = Vdata_dir + file_ops::dir_sep_str () + "octave:"
-      + Vlibexec_dir + file_ops::dir_sep_str () + "octave";
-}
-
 DEFUN (__version_info__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {retval =} __version_info__ (@var{name}, @var{version}, @var{release}, @var{date})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
@@ -375,24 +339,16 @@ safe_source_file (const std::string& fil
       if (quitting_gracefully)
         clean_up_and_exit (exit_status);
     }
   catch (octave_execution_exception)
     {
       recover_from_exception ();
       gripe_safe_source_exception (file_name, "unhandled execution exception");
     }
-  catch (std::bad_alloc)
-    {
-      recover_from_exception ();
-      error_state = -2;
-      gripe_safe_source_exception
-        (file_name,
-         "memory exhausted or requested size too large for range of Octave's index type");
-    }
 }
 
 // Initialize by reading startup files.
 
 static void
 execute_startup_files (void)
 {
   unwind_protect frame;
@@ -503,22 +459,16 @@ execute_eval_option_code (const std::str
         clean_up_and_exit (exit_status);
     }
   catch (octave_execution_exception)
     {
       recover_from_exception ();
       std::cerr << "error: unhandled execution exception -- eval failed"
                 << std::endl;
     }
-  catch (std::bad_alloc)
-    {
-      error_state = -2;
-      std::cerr << "error: memory exhausted or requested size too large for range of Octave's index type -- eval failed"
-                << std::endl;
-    }
 
   return parse_status;
 }
 
 static void
 execute_command_line_file (const std::string& fname)
 {
   unwind_protect frame;
@@ -585,21 +535,23 @@ Options:\n\
   --eval CODE             Evaluate CODE.  Exit when done unless --persist.\n\
   --exec-path PATH        Set path for executing subprograms.\n\
   --force-gui             Force graphical user interface to start.\n\
   --help, -h,             Print short help message and exit.\n\
   --image-path PATH       Add PATH to head of image search path.\n\
   --info-file FILE        Use top-level info file FILE.\n\
   --info-program PROGRAM  Use PROGRAM for reading info files.\n\
   --interactive, -i       Force interactive behavior.\n\
+  --jit-debug             Enable JIT compiler debugging/tracing.\n\
   --line-editing          Force readline use for command-line editing.\n\
   --no-gui                Disable the graphical user interface.\n\
   --no-history, -H        Don't save commands to the history list\n\
   --no-init-file          Don't read the ~/.octaverc or .octaverc files.\n\
   --no-init-path          Don't initialize function search path.\n\
+  --no-jit-compiler       Disable the JIT compiler.\n\
   --no-line-editing       Don't use readline for command-line editing.\n\
   --no-site-file          Don't read the site-wide octaverc file.\n\
   --no-window-system      Disable window system, including graphics.\n\
   --norc, -f              Don't read any initialization files.\n\
   --path PATH, -p PATH    Add PATH to head of function search path.\n\
   --persist               Go interactive after --eval or reading from FILE.\n\
   --silent, -q            Don't print message at startup.\n\
   --texi-macros-file FILE Use Texinfo macros in FILE for makeinfo command.\n\
@@ -668,45 +620,47 @@ initialize_error_handlers ()
 
 // What happens on --traditional.
 
 static void
 maximum_braindamage (void)
 {
   persist = true;
 
-  bind_internal_variable ("PS1", ">> ");
-  bind_internal_variable ("PS2", "");
-  bind_internal_variable ("allow_noninteger_range_as_index", true);
-  bind_internal_variable ("beep_on_error", true);
-  bind_internal_variable ("confirm_recursive_rmdir", false);
-  bind_internal_variable ("crash_dumps_octave_core", false);
-  bind_internal_variable ("default_save_options", "-mat-binary");
-  bind_internal_variable ("do_braindead_shortcircuit_evaluation", true);
-  bind_internal_variable ("fixed_point_format", true);
-  bind_internal_variable ("history_timestamp_format_string",
-                         "%%-- %D %I:%M %p --%%");
-  bind_internal_variable ("page_screen_output", false);
-  bind_internal_variable ("print_empty_dimensions", false);
+  FPS1 (octave_value (">> "));
+  FPS2 (octave_value (""));
+  FPS4 (octave_value (""));
+  Fallow_noninteger_range_as_index (octave_value (true));
+  Fbeep_on_error (octave_value (true));
+  Fconfirm_recursive_rmdir (octave_value (false));
+  Fcrash_dumps_octave_core (octave_value (false));
+  Fdefault_save_options (octave_value ("-mat-binary"));
+  Fdo_braindead_shortcircuit_evaluation (octave_value (true));
+  Ffixed_point_format (octave_value (true));
+  Fhistory_timestamp_format_string (octave_value ("%%-- %D %I:%M %p --%%"));
+  Fpage_screen_output (octave_value (false));
+  Fprint_empty_dimensions (octave_value (false));
 
   disable_warning ("Octave:abbreviated-property-match");
   disable_warning ("Octave:fopen-file-in-path");
   disable_warning ("Octave:function-name-clash");
   disable_warning ("Octave:load-file-in-path");
   disable_warning ("Octave:possible-matlab-short-circuit-operator");
 }
 
 // EMBEDDED is declared int instead of bool because this function is
 // declared extern "C".
 
 int
 octave_main (int argc, char **argv, int embedded)
 {
   octave_process_command_line (argc, argv);
 
+  install_defaults ();
+
   octave_initialize_interpreter (argc, argv, embedded);
 
   return octave_execute_interpreter ();
 }
 
 void
 octave_process_command_line (int argc, char **argv)
 {
@@ -727,16 +681,17 @@ octave_process_command_line (int argc, c
         case '?':
           // Unrecognized option.  getopt_long already printed a
           // message about that, so we will just print the usage string
           // and exit.
           usage ();
           break;
 
         case 'H':
+          Fsaving_history (octave_value (false));
           read_history_file = false;
           break;
 
         case 'V':
           verbose_flag = true;
           break;
 
         case 'd':
@@ -762,27 +717,34 @@ octave_process_command_line (int argc, c
             command_line_path.push_back (optarg);
           break;
 
         case 'q':
           inhibit_startup_message = true;
           break;
 
         case 'x':
-          echo_executing_commands
-            = (ECHO_SCRIPTS | ECHO_FUNCTIONS | ECHO_CMD_LINE);
+          {
+            int val = ECHO_SCRIPTS | ECHO_FUNCTIONS | ECHO_CMD_LINE;
+            Fecho_executing_commands (octave_value (val));
+          }
           break;
 
         case 'v':
           print_version_and_exit ();
           break;
 
+        case BUILT_IN_DOCSTRINGS_FILE_OPTION:
+          if (optarg)
+            Fbuilt_in_docstrings_file (octave_value (optarg));
+          break;
+
         case DOC_CACHE_FILE_OPTION:
           if (optarg)
-            doc_cache_file = optarg;
+            Fdoc_cache_file (octave_value (optarg));
           break;
 
         case EVAL_OPTION:
           if (optarg)
             {
               if (code_to_eval.empty ())
                 code_to_eval = optarg;
               else
@@ -801,38 +763,46 @@ octave_process_command_line (int argc, c
 
         case IMAGE_PATH_OPTION:
           if (optarg)
             image_path = optarg;
           break;
 
         case INFO_FILE_OPTION:
           if (optarg)
-            info_file = optarg;
+            Finfo_file (octave_value (optarg));
           break;
 
         case INFO_PROG_OPTION:
           if (optarg)
-            info_program = optarg;
+            Finfo_program (octave_value (optarg));
+          break;
+
+        case JIT_DEBUGGING_OPTION:
+          Fenable_jit_debugging (octave_value (true));
           break;
 
         case LINE_EDITING_OPTION:
           forced_line_editing = true;
           break;
 
+        case NO_GUI_OPTION:
+          no_gui_option = true;
+          break;
+
         case NO_INIT_FILE_OPTION:
           read_init_files = false;
           break;
 
-        case NO_GUI_OPTION:
-          no_gui_option = true;
+        case NO_INIT_PATH_OPTION:
+          set_initial_path = false;
           break;
 
-        case NO_INIT_PATH_OPTION:
-          set_initial_path = false;
+        case NO_JIT_COMPILER_OPTION:
+          Fenable_jit_compiler (octave_value (false));
           break;
 
         case NO_LINE_EDITING_OPTION:
           line_editing = false;
           break;
 
         case NO_SITE_FILE_OPTION:
           read_site_files = 0;
@@ -843,21 +813,21 @@ octave_process_command_line (int argc, c
           break;
 
         case PERSIST_OPTION:
           persist = true;
           break;
 
         case TEXI_MACROS_FILE_OPTION:
           if (optarg)
-            texi_macros_file = optarg;
+            Ftexi_macros_file (octave_value (optarg));
           break;
 
         case TRADITIONAL_OPTION:
-          traditional = true;
+          maximum_braindamage ();
           break;
 
         default:
           // getopt_long should print a message about unrecognized
           // options and return '?', which is handled above.  So if we
           // end up here, it is because there was an option but we
           // forgot to handle it.  That should be fatal.
           panic_impossible ();
@@ -882,23 +852,16 @@ octave_initialize_interpreter (int argc,
 
   octave_env::set_program_name (argv[0]);
 
   octave_program_invocation_name = octave_env::get_program_invocation_name ();
   octave_program_name = octave_env::get_program_name ();
 
   octave_thread::init ();
 
-  // The order of these calls is important.  The call to
-  // install_defaults must come before install_builtins because
-  // default variable values must be available for the variables to be
-  // installed, and the call to install_builtins must come before the
-  // options are processed because some command line options override
-  // defaults by calling bind_internal_variable.
-
   init_signals ();
 
   sysdep_init ();
 
   octave_ieee_init ();
 
   // The idea here is to force xerbla to be referenced so that we will
   // link to our own version instead of the one provided by the BLAS
@@ -907,65 +870,42 @@ octave_initialize_interpreter (int argc,
 
   if (octave_NaN == -1)
     F77_FUNC (xerbla, XERBLA) ("octave", 13 F77_CHAR_ARG_LEN (6));
 
   initialize_error_handlers ();
 
   initialize_default_warning_state ();
 
-  install_defaults ();
-
-  initialize_pathsearch ();
-
   if (! embedded)
     install_signal_handlers ();
   else
     quit_allowed = false;
 
   initialize_file_io ();
 
   install_types ();
 
   install_ops ();
 
   install_builtins ();
 
-  if (! read_history_file)
-    bind_internal_variable ("saving_history", false);
-
   for (std::list<std::string>::const_iterator it = command_line_path.begin ();
        it != command_line_path.end (); it++)
     load_path::set_command_line_path (*it);
 
-  if (echo_executing_commands)
-    bind_internal_variable ("echo_executing_commands",
-                            echo_executing_commands);
-
-  if (! doc_cache_file.empty ())
-    bind_internal_variable ("doc_cache_file", doc_cache_file);
-
   if (! exec_path.empty ())
     set_exec_path (exec_path);
 
   if (! image_path.empty ())
-    set_exec_path (image_path);
-
-  if (! info_file.empty ())
-    bind_internal_variable ("info_file", info_file);
-
-  if (! info_program.empty ())
-    bind_internal_variable ("info_program", info_program);
+    set_image_path (image_path);
 
   if (no_window_system)
     display_info::no_window_system ();
 
-  if (! texi_macros_file.empty ())
-    bind_internal_variable ("texi_macros_file", texi_macros_file);
-
   // Make sure we clean up when we exit.  Also allow users to register
   // functions.  If we don't have atexit or on_exit, we're going to
   // leave some junk files around if we exit abnormally.
 
   atexit (do_octave_atexit);
 
   // Is input coming from a terminal?  If so, we are probably
   // interactive.
@@ -985,19 +925,16 @@ octave_initialize_interpreter (int argc,
     command_editor::force_default_editor ();
 
   // These can come after command line args since none of them set any
   // defaults that might be changed by command line options.
 
   if (line_editing)
     initialize_command_input ();
 
-  if (traditional)
-    maximum_braindamage ();
-
   octave_interpreter_ready = true;
 
   initialize_version_info ();
 
   // Make all command-line arguments available to startup files,
   // including PKG_ADD files.
 
   intern_argv (argc, argv);
@@ -1065,17 +1002,17 @@ octave_execute_interpreter (void)
   // has forced interactive behavior.
 
   if (! interactive && forced_interactive)
     {
       command_editor::blink_matching_paren (false);
 
       // FIXME -- is this the right thing to do?
 
-      bind_internal_variable ("echo_executing_commands", ECHO_CMD_LINE);
+      Fecho_executing_commands (octave_value (ECHO_CMD_LINE));
     }
 
   if (octave_embedded)
     {
       // FIXME -- do we need to do any cleanup here before
       // returning?  If we don't, what will happen to Octave functions
       // that have been registered to execute with atexit, for example?
 
@@ -1095,17 +1032,17 @@ octave_execute_interpreter (void)
 }
 
 // Return int instead of bool because this function is declared
 // extern "C".
 
 int
 octave_starting_gui (void)
 {
-  if (! display_info::display_available ())
+  if (no_window_system || ! display_info::display_available ())
     return false;
 
   if (force_gui_option)
     return true;
 
   if (no_gui_option)
     return false;
 
diff --git a/libinterp/operators/module.mk b/libinterp/operators/module.mk
--- a/libinterp/operators/module.mk
+++ b/libinterp/operators/module.mk
@@ -125,17 +125,17 @@ OPERATORS_SRC = \
   operators/op-str-str.cc \
   operators/op-struct.cc \
   operators/op-ui16-ui16.cc \
   operators/op-ui32-ui32.cc \
   operators/op-ui64-ui64.cc \
   operators/op-ui8-ui8.cc
 
 ## These look like included header files to Autotools build process
-OPERATOR_INCLUDES = \
+OPERATORS_INC = \
   operators/op-dm-template.cc \
   operators/op-dms-template.cc \
   operators/op-int.h \
   operators/op-pm-template.cc \
   operators/ops.h
 
 ## Special rules for sources which must be built before rest of compilation.
 operators/ops.cc: $(OPERATORS_SRC) mkops
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -104,17 +104,17 @@ along with Octave; see the file COPYING.
 #undef YY_INPUT
 #endif
 #define YY_INPUT(buf, result, max_size) \
   if ((result = octave_read (buf, max_size)) < 0) \
     YY_FATAL_ERROR ("octave_read () in flex scanner failed");
 
 // Try to avoid crashing out completely on fatal scanner errors.
 // The call to yy_fatal_error should never happen, but it avoids a
-// `static function defined but not used' warning from gcc.
+// 'static function defined but not used' warning from gcc.
 
 #ifdef YY_FATAL_ERROR
 #undef YY_FATAL_ERROR
 #endif
 #define YY_FATAL_ERROR(msg) \
   do \
     { \
       error (msg); \
@@ -434,17 +434,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
     lexer_flags.looking_for_object_index = false;
     lexer_flags.at_beginning_of_statement = false;
 
     TOK_PUSH_AND_RETURN (tok, SQ_STRING);
   }
 
 %{
 // For this and the next two rules, we're looking at ']', and we
-// need to know if the next token is `=' or `=='.
+// need to know if the next token is '=' or '=='.
 //
 // It would have been so much easier if the delimiters were simply
 // different for the expression on the left hand side of the equals
 // operator.
 //
 // It's also a pain in the ass to decide whether to insert a comma
 // after seeing a ']' character...
 
@@ -676,17 +676,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 {NUMBER}{Im} {
     LEXER_DEBUG ("{NUMBER}{Im}");
 
     handle_number ();
     COUNT_TOK_AND_RETURN (IMAG_NUM);
   }
 
 %{
-// Real numbers.  Don't grab the `.' part of a dot operator as part of
+// Real numbers.  Don't grab the '.' part of a dot operator as part of
 // the constant.
 %}
 
 {D}+/\.[\*/\\^\'] |
 {NUMBER} {
     LEXER_DEBUG ("{D}+/\\.[\\*/\\^\\']|{NUMBER}");
     handle_number ();
     COUNT_TOK_AND_RETURN (NUM);
@@ -725,17 +725,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
     LEXER_DEBUG ("<<EOF>>");
 
     if (block_comment_nesting_level != 0)
       {
         warning ("block comment open at end of input");
 
         if ((reading_fcn_file || reading_script_file || reading_classdef_file)
             && ! curr_fcn_file_name.empty ())
-          warning ("near line %d of file `%s.m'",
+          warning ("near line %d of file '%s.m'",
                    input_line_number, curr_fcn_file_name.c_str ());
       }
 
     TOK_RETURN (END_OF_INPUT);
   }
 
 %{
 // Identifiers.  Truncate the token at the first space or tab but
@@ -1073,17 +1073,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
     xunput (yytext[0], yytext);
 
     int c = text_yyinput ();
 
     if (c != EOF)
       {
         current_input_column++;
 
-        error ("invalid character `%s' (ASCII %d) near line %d, column %d",
+        error ("invalid character '%s' (ASCII %d) near line %d, column %d",
                undo_string_escape (static_cast<char> (c)), c,
                input_line_number, current_input_column);
 
         return LEXICAL_ERROR;
       }
     else
       TOK_RETURN (END_OF_INPUT);
   }
@@ -1510,22 +1510,22 @@ is_keyword_token (const std::string& s)
           lexer_flags.at_beginning_of_statement = true;
           break;
 
         case static_kw:
           if ((reading_fcn_file || reading_script_file
                || reading_classdef_file)
               && ! curr_fcn_file_full_name.empty ())
             warning_with_id ("Octave:deprecated-keyword",
-                             "the `static' keyword is obsolete and will be removed from a future version of Octave; please use `persistent' instead; near line %d of file `%s'",
+                             "the 'static' keyword is obsolete and will be removed from a future version of Octave; please use 'persistent' instead; near line %d of file '%s'",
                              input_line_number,
                              curr_fcn_file_full_name.c_str ());
           else
             warning_with_id ("Octave:deprecated-keyword",
-                             "the `static' keyword is obsolete and will be removed from a future version of Octave; please use `persistent' instead; near line %d",
+                             "the 'static' keyword is obsolete and will be removed from a future version of Octave; please use 'persistent' instead; near line %d",
                              input_line_number);
           // fall through ...
 
         case persistent_kw:
           break;
 
         case case_kw:
         case elseif_kw:
@@ -2552,17 +2552,17 @@ cleanup:
 
   int len = s.length ();
   while (len--)
     xunput (s[len], yytext);
 
   return false;
 }
 
-// We have seen a `.' and need to see if it is the start of a
+// We have seen a '.' and need to see if it is the start of a
 // continuation.  If so, this eats it, up to and including the new
 // line character.
 
 static bool
 have_ellipsis_continuation (bool trailing_comments_ok)
 {
   char c1 = text_yyinput ();
   if (c1 == '.')
@@ -3348,17 +3348,17 @@ handle_identifier (void)
 
   xunput (c1, yytext);
 
   // Kluge alert.
   //
   // If we are looking at a text style function, set up to gobble its
   // arguments.
   //
-  // If the following token is `=', or if we are parsing a function
+  // If the following token is '=', or if we are parsing a function
   // return list or function parameter list, or if we are looking at
   // something like [ab,cd] = foo (), force the symbol to be inserted
   // as a variable in the current symbol table.
 
   if (! is_variable (tok))
     {
       if (at_bos && spc_gobbled && can_be_command (tok)
           && looks_like_command_arg ())
@@ -3574,21 +3574,21 @@ prep_lexer_for_classdef_file (void)
 
 static void
 maybe_warn_separator_insert (char sep)
 {
   std::string nm = curr_fcn_file_full_name;
 
   if (nm.empty ())
     warning_with_id ("Octave:separator-insert",
-                     "potential auto-insertion of `%c' near line %d",
+                     "potential auto-insertion of '%c' near line %d",
                      sep, input_line_number);
   else
     warning_with_id ("Octave:separator-insert",
-                     "potential auto-insertion of `%c' near line %d of file %s",
+                     "potential auto-insertion of '%c' near line %d of file %s",
                      sep, input_line_number, nm.c_str ());
 }
 
 static void
 gripe_single_quote_string (void)
 {
   std::string nm = curr_fcn_file_full_name;
 
diff --git a/libinterp/parse-tree/module.mk b/libinterp/parse-tree/module.mk
--- a/libinterp/parse-tree/module.mk
+++ b/libinterp/parse-tree/module.mk
@@ -1,25 +1,29 @@
 EXTRA_DIST += \
   parse-tree/module.mk \
   parse-tree/octave.gperf
 
-PARSER_INCLUDES = \
+PARSER_INC = \
   parse-tree/lex.h \
   parse-tree/parse.h \
   parse-tree/parse-private.h
 
 PARSER_SRC = \
   parse-tree/lex.ll \
   parse-tree/oct-parse.yy
 
-lex.lo lex.o oct-parse.lo oct-parse.o: \
-  AM_CXXFLAGS := $(filter-out -Wold-style-cast, $(AM_CXXFLAGS))
+## FIXME: Automake does not support per-object rules.
+##        These rules could be emulated by creating a new convenience
+##        library and using per-library rules.  Or we can just live
+##        with the extra warnings about old-sytle-casts. (09/18/2012)
+#lex.lo lex.o oct-parse.lo oct-parse.o: \
+#  AM_CXXFLAGS := $(filter-out -Wold-style-cast, $(AM_CXXFLAGS))
 
-PT_INCLUDES = \
+PARSE_TREE_INC = \
   parse-tree/pt-all.h \
   parse-tree/pt-arg-list.h \
   parse-tree/pt-assign.h \
   parse-tree/pt-binop.h \
   parse-tree/pt-bp.h \
   parse-tree/pt-cbinop.h \
   parse-tree/pt-cell.h \
   parse-tree/pt-check.h \
@@ -41,17 +45,17 @@ PT_INCLUDES = \
   parse-tree/pt-misc.h \
   parse-tree/pt-pr-code.h \
   parse-tree/pt-select.h \
   parse-tree/pt-stmt.h \
   parse-tree/pt-unop.h \
   parse-tree/pt-walk.h \
   parse-tree/pt.h \
   parse-tree/token.h \
-  $(PARSER_INCLUDES)
+  $(PARSER_INC)
 
 PARSE_TREE_SRC = \
   parse-tree/pt-arg-list.cc \
   parse-tree/pt-assign.cc \
   parse-tree/pt-binop.cc \
   parse-tree/pt-bp.cc \
   parse-tree/pt-cbinop.cc \
   parse-tree/pt-cell.cc \
@@ -90,8 +94,9 @@ parse-tree/oct-gperf.h: parse-tree/octav
 	$(GPERF) -t -C -D -G -L C++ -Z octave_kw_hash $< > $@-t1
 	$(SED) 's,lookup\[,gperf_lookup[,' < $@-t1 > $@-t
 	mv $@-t $@
 	rm -f $@-t1
 
 noinst_LTLIBRARIES += parse-tree/libparse-tree.la
 
 parse_tree_libparse_tree_la_SOURCES = $(PARSE_TREE_SRC)
+parse_tree_libparse_tree_la_CPPFLAGS = $(liboctinterp_la_CPPFLAGS)
diff --git a/libinterp/parse-tree/oct-parse.yy b/libinterp/parse-tree/oct-parse.yy
--- a/libinterp/parse-tree/oct-parse.yy
+++ b/libinterp/parse-tree/oct-parse.yy
@@ -983,17 +983,17 @@ simple_expr     : colon_expr
                 | simple_expr EXPR_OR simple_expr
                   { $$ = make_binary_op (EXPR_OR, $1, $2, $3); }
                 | simple_expr EXPR_AND_AND simple_expr
                   { $$ = make_boolean_op (EXPR_AND_AND, $1, $2, $3); }
                 | simple_expr EXPR_OR_OR simple_expr
                   { $$ = make_boolean_op (EXPR_OR_OR, $1, $2, $3); }
                 ;
 
-// Arrange for the lexer to return CLOSE_BRACE for `]' by looking ahead
+// Arrange for the lexer to return CLOSE_BRACE for ']' by looking ahead
 // one token for an assignment op.
 
 assign_lhs      : simple_expr
                   {
                     $$ = new tree_argument_list ($1);
                     $$->mark_as_simple_assign_lhs ();
                   }
                 | '[' arg_list opt_comma CLOSE_BRACE
@@ -1295,17 +1295,17 @@ except_command  : UNWIND stash_comment o
                 | TRY stash_comment opt_sep opt_list END
                   {
                     if (! ($$ = make_try_command ($1, $4, 0, $5, $2, 0)))
                       ABORT_PARSE;
                   }
                 ;
 
 // ===========================================
-// Some `subroutines' for function definitions
+// Some 'subroutines' for function definitions
 // ===========================================
 
 push_fcn_symtab : // empty
                   {
                     current_function_depth++;
 
                     if (max_function_depth < current_function_depth)
                       max_function_depth = current_function_depth;
@@ -1870,17 +1870,17 @@ yyerror (const char *s)
 }
 
 // Error mesages for mismatched end tokens.
 
 static void
 end_error (const char *type, token::end_tok_type ettype, int l, int c)
 {
   static const char *fmt
-    = "`%s' command matched by `%s' near line %d column %d";
+    = "'%s' command matched by '%s' near line %d column %d";
 
   switch (ettype)
     {
     case token::simple_end:
       error (fmt, type, "end", l, c);
       break;
 
     case token::for_end:
@@ -2001,17 +2001,17 @@ maybe_warn_assign_as_truth_value (tree_e
     {
       if (curr_fcn_file_full_name.empty ())
         warning_with_id
           ("Octave:assign-as-truth-value",
            "suggest parenthesis around assignment used as truth value");
       else
         warning_with_id
           ("Octave:assign-as-truth-value",
-           "suggest parenthesis around assignment used as truth value near line %d, column %d in file `%s'",
+           "suggest parenthesis around assignment used as truth value near line %d, column %d in file '%s'",
            expr->line (), expr->column (), curr_fcn_file_full_name.c_str ());
     }
 }
 
 // Maybe print a warning about switch labels that aren't constants.
 
 static void
 maybe_warn_variable_switch_label (tree_expression *expr)
@@ -2019,17 +2019,17 @@ maybe_warn_variable_switch_label (tree_e
   if (! expr->is_constant ())
     {
       if (curr_fcn_file_full_name.empty ())
         warning_with_id ("Octave:variable-switch-label",
                          "variable switch label");
       else
         warning_with_id
           ("Octave:variable-switch-label",
-           "variable switch label near line %d, column %d in file `%s'",
+           "variable switch label near line %d, column %d in file '%s'",
            expr->line (), expr->column (), curr_fcn_file_full_name.c_str ());
     }
 }
 
 static tree_expression *
 fold (tree_binary_expression *e)
 {
   tree_expression *retval = e;
@@ -2983,17 +2983,17 @@ frob_function (const std::string& fname,
 
     if (pos != std::string::npos)
       nm = curr_fcn_file_name.substr (pos+1);
 
     if (nm != id_name)
       {
         warning_with_id
           ("Octave:function-name-clash",
-           "function name `%s' does not agree with function file name `%s'",
+           "function name '%s' does not agree with function file name '%s'",
            id_name.c_str (), curr_fcn_file_full_name.c_str ());
 
         id_name = nm;
       }
   }
 
   if (reading_fcn_file || reading_classdef_file || autoloading)
     {
@@ -3027,23 +3027,23 @@ frob_function (const std::string& fname,
         }
 
       std::string nm = fcn->fcn_file_name ();
 
       file_stat fs (nm);
 
       if (fs && fs.is_newer (now))
         warning_with_id ("Octave:future-time-stamp",
-                         "time stamp for `%s' is in the future", nm.c_str ());
+                         "time stamp for '%s' is in the future", nm.c_str ());
     }
   else if (! (input_from_tmp_history_file || input_from_startup_file)
            && reading_script_file
            && curr_fcn_file_name == id_name)
     {
-      warning ("function `%s' defined within script file `%s'",
+      warning ("function '%s' defined within script file '%s'",
                id_name.c_str (), curr_fcn_file_full_name.c_str ());
     }
 
   fcn->stash_function_name (id_name);
   fcn->stash_fcn_location (input_line_number, current_input_column);
 
   if (! help_buf.empty () && current_function_depth == 1
       && ! parsing_subfunctions)
@@ -3253,17 +3253,17 @@ make_decl_command (int tok, token *tok_v
       break;
 
     case PERSISTENT:
       if (current_function_depth > 0)
         retval = new tree_persistent_command (lst, l, c);
       else
         {
           if (reading_script_file)
-            warning ("ignoring persistent declaration near line %d of file `%s'",
+            warning ("ignoring persistent declaration near line %d of file '%s'",
                      l, curr_fcn_file_full_name.c_str ());
           else
             warning ("ignoring persistent declaration near line %d", l);
         }
       break;
 
     default:
       panic_impossible ();
@@ -3338,17 +3338,17 @@ maybe_warn_missing_semi (tree_statement_
 {
   if (current_function_depth > 0)
     {
       tree_statement *tmp = t->back ();
 
       if (tmp->is_expression ())
         warning_with_id
           ("Octave:missing-semicolon",
-           "missing semicolon near line %d, column %d in file `%s'",
+           "missing semicolon near line %d, column %d in file '%s'",
             tmp->line (), tmp->column (), curr_fcn_file_full_name.c_str ());
     }
 }
 
 static tree_statement_list *
 set_stmt_print_flag (tree_statement_list *list, char sep,
                      bool warn_missing_semi)
 {
@@ -3909,19 +3909,19 @@ parse_fcn_file (const std::string& ff, c
             = make_end ("endscript", input_line_number, current_input_column);
 
           make_script (0, end_of_script);
 
           fcn_ptr = primary_fcn_ptr;
         }
     }
   else if (require_file)
-    error ("no such file, `%s'", ff.c_str ());
+    error ("no such file, '%s'", ff.c_str ());
   else if (! warn_for.empty ())
-    error ("%s: unable to open file `%s'", warn_for.c_str (), ff.c_str ());
+    error ("%s: unable to open file '%s'", warn_for.c_str (), ff.c_str ());
 
   return fcn_ptr;
 }
 
 std::string
 get_help_from_file (const std::string& nm, bool& symbol_found,
                     std::string& file)
 {
@@ -4197,17 +4197,17 @@ With no arguments, return a structure co
                         {
                           nm = fname + nm;
                           found = true;
                         }
                     }
                 }
               if (! found)
                 warning_with_id ("Octave:autoload-relative-file-name",
-                                 "autoload: `%s' is not an absolute file name",
+                                 "autoload: '%s' is not an absolute file name",
                                  nm.c_str ());
             }
           autoload_map[argv[1]] = nm;
         }
     }
   else
     print_usage ();
 
@@ -4313,17 +4313,17 @@ source_file (const std::string& file_nam
 
               if (verbose)
                 std::cout << "done." << std::endl;
 
               delete fcn;
             }
         }
       else
-        error ("source: error sourcing file `%s'",
+        error ("source: error sourcing file '%s'",
                file_full_name.c_str ());
     }
 }
 
 DEFUN (mfilename, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} mfilename ()\n\
 @deftypefnx {Built-in Function} {} mfilename (\"fullpath\")\n\
@@ -4442,17 +4442,17 @@ feval (const std::string& name, const oc
   octave_value fcn = symbol_table::find_function (name, args);
 
   if (fcn.is_defined ())
     retval = fcn.do_multi_index_op (nargout, args);
   else
     {
       maybe_missing_function_hook (name);
       if (! error_state)
-        error ("feval: function `%s' not found", name.c_str ());
+        error ("feval: function '%s' not found", name.c_str ());
     }
 
   return retval;
 }
 
 octave_value_list
 feval (octave_function *fcn, const octave_value_list& args, int nargout)
 {
@@ -4582,17 +4582,17 @@ another function for the given type sign
       if (! error_state)
         {
           octave_value fcn = symbol_table::builtin_find (name);
 
           if (fcn.is_defined ())
             retval = feval (fcn.function_value (), args.splice (0, 1),
                             nargout);
           else
-            error ("builtin: lookup for symbol `%s' failed", name.c_str ());
+            error ("builtin: lookup for symbol '%s' failed", name.c_str ());
         }
       else
         error ("builtin: function name (F) must be a string");
     }
   else
     print_usage ();
 
   return retval;
@@ -4661,17 +4661,17 @@ eval_string (const std::string& s, bool 
       frame.add_fcn (symbol_table::unmark_forced_variables, scope);
 
       parse_status = yyparse ();
 
       tree_statement_list *command_list = global_command;
 
       // Unmark forced variables.
       // Restore previous value of global_command.
-      frame.run_top (2);
+      frame.run (2);
 
       if (parse_status == 0)
         {
           if (command_list)
             {
               unwind_protect inner_frame;
 
               // Use an unwind-protect cleanup function so that the
diff --git a/libinterp/parse-tree/pt-binop.cc b/libinterp/parse-tree/pt-binop.cc
--- a/libinterp/parse-tree/pt-binop.cc
+++ b/libinterp/parse-tree/pt-binop.cc
@@ -41,17 +41,17 @@ static bool Vdo_braindead_shortcircuit_e
 // Binary expressions.
 
 octave_value_list
 tree_binary_expression::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (nargout > 1)
-    error ("binary operator `%s': invalid number of output arguments",
+    error ("binary operator '%s': invalid number of output arguments",
            oper () . c_str ());
   else
     retval = rvalue1 (nargout);
 
   return retval;
 }
 
 octave_value
@@ -171,17 +171,17 @@ tree_binary_expression::accept (tree_wal
 // Boolean expressions.
 
 octave_value_list
 tree_boolean_expression::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (nargout > 1)
-    error ("binary operator `%s': invalid number of output arguments",
+    error ("binary operator '%s': invalid number of output arguments",
            oper () . c_str ());
   else
     retval = rvalue1 (nargout);
 
   return retval;
 }
 
 octave_value
diff --git a/libinterp/parse-tree/pt-decl.h b/libinterp/parse-tree/pt-decl.h
--- a/libinterp/parse-tree/pt-decl.h
+++ b/libinterp/parse-tree/pt-decl.h
@@ -79,16 +79,18 @@ public:
 
     return retval;
   }
 
   octave_lvalue lvalue (void) { return id ? id->lvalue () : octave_lvalue (); }
 
   tree_identifier *ident (void) { return id; }
 
+  std::string name (void) { return id ? id->name () : ""; }
+
   tree_expression *expression (void) { return expr; }
 
   tree_decl_elt *dup (symbol_table::scope_id scope,
                       symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -39,21 +39,18 @@ along with Octave; see the file COPYING.
 #include "ov-fcn-handle.h"
 #include "ov-usr-fcn.h"
 #include "variables.h"
 #include "pt-all.h"
 #include "pt-eval.h"
 #include "symtab.h"
 #include "unwind-prot.h"
 
-#if HAVE_LLVM
 //FIXME: This should be part of tree_evaluator
 #include "pt-jit.h"
-static tree_jit jiter;
-#endif
 
 static tree_evaluator std_evaluator;
 
 tree_evaluator *current_evaluator = &std_evaluator;
 
 int tree_evaluator::dbstep_flag = 0;
 
 size_t tree_evaluator::current_frame = 0;
@@ -266,17 +263,17 @@ tree_evaluator::visit_decl_init_list (tr
 }
 
 // Decide if it's time to quit a for or while loop.
 static inline bool
 quit_loop_now (void)
 {
   octave_quit ();
 
-  // Maybe handle `continue N' someday...
+  // Maybe handle 'continue N' someday...
 
   if (tree_continue_command::continuing)
     tree_continue_command::continuing--;
 
   bool quit = (error_state
                || tree_return_command::returning
                || tree_break_command::breaking
                || tree_continue_command::continuing);
@@ -305,17 +302,17 @@ tree_evaluator::visit_simple_for_command
 
   in_loop_command = true;
 
   tree_expression *expr = cmd.control_expr ();
 
   octave_value rhs = expr->rvalue1 ();
 
 #if HAVE_LLVM
-  if (jiter.execute (cmd, rhs))
+  if (Venable_jit_compiler && tree_jit::execute (cmd, rhs))
     return;
 #endif
 
   if (error_state || rhs.is_undefined ())
     return;
 
   {
     tree_expression *lhs = cmd.left_hand_side ();
@@ -486,17 +483,17 @@ tree_evaluator::visit_complex_for_comman
           if (! error_state && loop_body)
             loop_body->accept (*this);
 
           if (quit_loop_now ())
             break;
         }
     }
   else
-    error ("in statement `for [X, Y] = VAL', VAL must be a structure");
+    error ("in statement 'for [X, Y] = VAL', VAL must be a structure");
 }
 
 void
 tree_evaluator::visit_octave_user_script (octave_user_script&)
 {
   panic_impossible ();
 }
 
@@ -758,16 +755,29 @@ tree_evaluator::visit_statement (tree_st
               //              if (tmp_result.is_defined ())
               //                result_values(0) = tmp_result;
             }
         }
       catch (octave_execution_exception)
         {
           gripe_library_execution_error ();
         }
+      catch (std::bad_alloc)
+        {
+          // FIXME -- We want to use error_with_id here so that we set
+          // the error state, give users control over this error
+          // message, and so that we set the error_state appropriately
+          // so we'll get stack trace info when appropriate.  But
+          // error_with_id will require some memory allocations.  Is
+          // there anything we can do to make those more likely to
+          // succeed?
+
+          error_with_id ("Octave:bad-alloc",
+                         "out of memory or dimension too large for Octave's index type");
+        }
     }
 }
 
 void
 tree_evaluator::visit_statement_list (tree_statement_list& lst)
 {
   static octave_value_list empty_list;
 
@@ -898,17 +908,16 @@ tree_evaluator::visit_try_catch_command 
   // The catch code is *not* added to unwind_protect stack; it doesn't need
   // to be run on interrupts.
 
   tree_statement_list *try_code = cmd.body ();
 
   if (try_code)
     {
       try_code->accept (*this);
-      // FIXME: should std::bad_alloc be handled here?
     }
 
   if (error_state)
     {
       error_state = 0;
 
       if (catch_code)
         {
@@ -982,31 +991,31 @@ tree_evaluator::do_unwind_protect_cleanu
   // If we reset the value of the breaking flag, both the returning
   // flag and the breaking flag will be set, and we shouldn't have
   // both.  So, use the most recent one.  If there is no return or
   // break in the cleanup block, the values should be reset to
   // whatever they were when the cleanup block was entered.
 
   if (tree_break_command::breaking || tree_return_command::returning)
     {
-      frame.discard_top (2);
+      frame.discard (2);
     }
   else
     {
-      frame.run_top (2);
+      frame.run (2);
     }
 
   // We don't want to ignore errors that occur in the cleanup code, so
   // if an error is encountered there, leave error_state alone.
   // Otherwise, set it back to what it was before.
 
   if (error_state)
-    frame.discard_top (2);
+    frame.discard (2);
   else
-    frame.run_top (2);
+    frame.run (2);
 
   frame.run ();
 }
 
 void
 tree_evaluator::visit_unwind_protect_command (tree_unwind_protect_command& cmd)
 {
   tree_statement_list *cleanup_code = cmd.cleanup ();
@@ -1036,17 +1045,17 @@ tree_evaluator::visit_unwind_protect_com
 
 void
 tree_evaluator::visit_while_command (tree_while_command& cmd)
 {
   if (error_state)
     return;
 
 #if HAVE_LLVM
-  if (jiter.execute (cmd))
+  if (Venable_jit_compiler && tree_jit::execute (cmd))
     return;
 #endif
 
   unwind_protect frame;
 
   frame.protect_var (in_loop_command);
 
   in_loop_command = true;
diff --git a/libinterp/parse-tree/pt-id.cc b/libinterp/parse-tree/pt-id.cc
--- a/libinterp/parse-tree/pt-id.cc
+++ b/libinterp/parse-tree/pt-id.cc
@@ -45,20 +45,20 @@ tree_identifier::eval_undefined_error (v
   int c = column ();
 
   maybe_missing_function_hook (name ());
   if (error_state)
     return;
 
   if (l == -1 && c == -1)
     ::error_with_id ("Octave:undefined-function",
-                     "`%s' undefined", name ().c_str ());
+                     "'%s' undefined", name ().c_str ());
   else
     ::error_with_id ("Octave:undefined-function",
-                     "`%s' undefined near line %d column %d",
+                     "'%s' undefined near line %d column %d",
                      name ().c_str (), l, c);
 }
 
 octave_value_list
 tree_identifier::rvalue (int nargout)
 {
   octave_value_list retval;
 
@@ -69,17 +69,17 @@ tree_identifier::rvalue (int nargout)
 
   if (val.is_defined ())
     {
       // GAGME -- this would be cleaner if we required
       // parens to indicate function calls.
       //
       // If this identifier refers to a function, we need to know
       // whether it is indexed so that we can do the same thing
-      // for `f' and `f()'.  If the index is present, return the
+      // for 'f' and 'f()'.  If the index is present, return the
       // function object and let tree_index_expression::rvalue
       // handle indexing.  Otherwise, arrange to call the function
       // here, so that we don't return the function definition as
       // a value.
 
       if (val.is_function () && ! is_postfix_indexed ())
         {
           octave_value_list tmp_args;
@@ -89,16 +89,18 @@ tree_identifier::rvalue (int nargout)
       else
         {
           if (print_result () && nargout == 0)
             val.print_with_name (octave_stdout, name ());
 
           retval = val;
         }
     }
+  else if (sym->is_added_static ())
+    static_workspace_error ();
   else
     eval_undefined_error ();
 
   return retval;
 }
 
 octave_value
 tree_identifier::rvalue1 (int nargout)
@@ -111,16 +113,19 @@ tree_identifier::rvalue1 (int nargout)
     retval = tmp(0);
 
   return retval;
 }
 
 octave_lvalue
 tree_identifier::lvalue (void)
 {
+  if (sym->is_added_static ())
+    static_workspace_error ();
+
   return octave_lvalue (&(sym->varref ()));
 }
 
 tree_identifier *
 tree_identifier::dup (symbol_table::scope_id sc,
                       symbol_table::context_id) const
 {
   // The new tree_identifier object contains a symbol_record
diff --git a/libinterp/parse-tree/pt-id.h b/libinterp/parse-tree/pt-id.h
--- a/libinterp/parse-tree/pt-id.h
+++ b/libinterp/parse-tree/pt-id.h
@@ -105,16 +105,22 @@ public:
   octave_value rvalue1 (int nargout = 1);
 
   octave_value_list rvalue (int nargout);
 
   octave_lvalue lvalue (void);
 
   void eval_undefined_error (void);
 
+  void static_workspace_error (void)
+  {
+    ::error ("can not add variable \"%s\" to a static workspace",
+             name ().c_str ());
+  }
+
   tree_identifier *dup (symbol_table::scope_id scope,
                         symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
   symbol_table::symbol_reference symbol (void) const
   {
     return sym;
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -215,17 +215,17 @@ tree_index_expression::get_struct_index
         {
           octave_value t = df->rvalue1 ();
 
           if (! error_state)
             {
               fn = t.string_value ();
 
               if (! valid_identifier (fn))
-                ::error ("invalid structure field name `%s'", fn.c_str ());
+                ::error ("invalid structure field name '%s'", fn.c_str ());
             }
         }
       else
         panic_impossible ();
     }
 
   return fn;
 }
diff --git a/libinterp/parse-tree/pt-misc.cc b/libinterp/parse-tree/pt-misc.cc
--- a/libinterp/parse-tree/pt-misc.cc
+++ b/libinterp/parse-tree/pt-misc.cc
@@ -78,17 +78,17 @@ tree_parameter_list::validate (in_or_out
           if (id->is_black_hole ())
             {
               if (type != in)
                 error ("invalid use of ~ in output list");
             }
           else if (dict.find (name) != dict.end ())
             {
               retval = false;
-              error ("`%s' appears more than once in parameter list",
+              error ("'%s' appears more than once in parameter list",
                      name.c_str ());
               break;
             }
           else
             dict.insert (name);
         }
     }
 
diff --git a/libinterp/parse-tree/pt-unop.cc b/libinterp/parse-tree/pt-unop.cc
--- a/libinterp/parse-tree/pt-unop.cc
+++ b/libinterp/parse-tree/pt-unop.cc
@@ -44,17 +44,17 @@ tree_unary_expression::oper (void) const
 // Prefix expressions.
 
 octave_value_list
 tree_prefix_expression::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (nargout > 1)
-    error ("prefix operator `%s': invalid number of output arguments",
+    error ("prefix operator '%s': invalid number of output arguments",
            oper () . c_str ());
   else
     retval = rvalue1 (nargout);
 
   return retval;
 }
 
 octave_value
@@ -131,17 +131,17 @@ tree_prefix_expression::accept (tree_wal
 // Postfix expressions.
 
 octave_value_list
 tree_postfix_expression::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (nargout > 1)
-    error ("postfix operator `%s': invalid number of output arguments",
+    error ("postfix operator '%s': invalid number of output arguments",
            oper () . c_str ());
   else
     retval = rvalue1 (nargout);
 
   return retval;
 }
 
 octave_value
diff --git a/libinterp/version.in.h b/libinterp/version.in.h
--- a/libinterp/version.in.h
+++ b/libinterp/version.in.h
@@ -53,17 +53,17 @@ FITNESS FOR A PARTICULAR PURPOSE." ARG
 #define OCTAVE_WARRANTY_STATEMENT \
   X_OCTAVE_WARRANTY_STATEMENT ("")
 
 #define OCTAVE_WWW_STATEMENT \
   "Additional information about Octave is available at http://www.octave.org."
 
 #define OCTAVE_CONTRIB_STATEMENT \
   "Please contribute if you find this software useful.\n\
-For more information, visit http://www.octave.org/help-wanted.html"
+For more information, visit http://www.octave.org/get-involved.html"
 
 #define OCTAVE_BUGS_STATEMENT \
   "Read http://www.octave.org/bugs.html to learn how to submit bug reports."
 
 #define OCTAVE_NAME_VERSION_AND_COPYRIGHT \
   OCTAVE_NAME_AND_VERSION "\n" \
   OCTAVE_COPYRIGHT
 
@@ -82,11 +82,11 @@ For more information, visit http://www.o
   OCTAVE_CONTRIB_STATEMENT "\n\n" \
   OCTAVE_BUGS_STATEMENT
 
 #define OCTAVE_NAME_VERSION_COPYRIGHT_COPYING_WARRANTY_AND_BUGS \
   X_OCTAVE_NAME_VERSION_COPYRIGHT_COPYING_WARRANTY_AND_BUGS ("")
 
 #define OCTAVE_STARTUP_MESSAGE \
   X_OCTAVE_NAME_VERSION_COPYRIGHT_COPYING_WARRANTY_AND_BUGS \
-    ("  For details, type `warranty'.") "\n\n" \
-  "For information about changes from previous versions, type `news'."
+    ("  For details, type 'warranty'.") "\n\n" \
+  "For information about changes from previous versions, type 'news'."
 #endif
diff --git a/liboctave/Makefile.am b/liboctave/Makefile.am
--- a/liboctave/Makefile.am
+++ b/liboctave/Makefile.am
@@ -1,9 +1,9 @@
-# Makefile for octave's liboctave directory
+# Makefile for Octave's liboctave directory
 #
 # Copyright (C) 1993-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
@@ -15,550 +15,106 @@
 # for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
+AUTOMAKE_OPTIONS = subdir-objects
+
+## Run cruft dir with stand-alone Makefile.
+## Eventually this will use module.mk syntax.
+SUBDIRS = cruft
+
 ## Search local directories before those specified by the user.
 AM_CPPFLAGS = \
-  -I$(top_builddir)/libgnu -I$(top_srcdir)/libgnu \
-  -I$(top_srcdir)/libcruft/misc
-
-EXTRA_DIST = \
-  config-ops.sh \
-  mk-ops.awk \
-  mx-op-inc.mk \
-  mx-op-src.mk \
-  mx-ops \
-  smx-op-inc.mk \
-  smx-op-src.mk \
-  sparse-mk-ops.awk \
-  sparse-mx-ops \
-  vx-op-inc.mk \
-  vx-op-src.mk \
-  vx-ops \
-  $(OPT_IN)
+  -I$(srcdir)/array \
+  -I$(srcdir)/cruft/misc \
+  -Inumeric -I$(srcdir)/numeric \
+  -Ioperators -I$(srcdir)/operators \
+  -I$(srcdir)/system \
+  -I$(srcdir)/util \
+  -I$(top_builddir)/libgnu -I$(top_srcdir)/libgnu
 
-MATRIX_INC = \
-  Array-util.h \
-  Array.h \
-  Array2.h \
-  Array3.h \
-  ArrayN.h \
-  CColVector.h \
-  CDiagMatrix.h \
-  CMatrix.h \
-  CNDArray.h \
-  CRowVector.h \
-  CSparse.h \
-  CmplxAEPBAL.h \
-  CmplxCHOL.h \
-  CmplxGEPBAL.h \
-  CmplxHESS.h \
-  CmplxLU.h \
-  CmplxQR.h \
-  CmplxQRP.h \
-  CmplxSCHUR.h \
-  CmplxSVD.h \
-  DET.h \
-  DiagArray2.h \
-  EIG.h \
-  MArray-decl.h \
-  MArray-defs.h \
-  MArray.h \
-  MArray2.h \
-  MArrayN.h \
-  MDiagArray2.h \
-  MSparse-defs.h \
-  MSparse.h \
-  Matrix.h \
-  MatrixType.h \
-  PermMatrix.h \
-  Sparse-diag-op-defs.h \
-  Sparse-op-defs.h \
-  Sparse-perm-op-defs.h \
-  Sparse.h \
-  SparseCmplxCHOL.h \
-  SparseCmplxLU.h \
-  SparseCmplxQR.h \
-  SparseQR.h \
-  SparsedbleCHOL.h \
-  SparsedbleLU.h \
-  base-aepbal.h \
-  base-lu.h \
-  base-qr.h \
-  boolMatrix.h \
-  boolNDArray.h \
-  boolSparse.h \
-  bsxfun-decl.h \
-  chMatrix.h \
-  chNDArray.h \
-  dColVector.h \
-  dDiagMatrix.h \
-  dMatrix.h \
-  dNDArray.h \
-  dRowVector.h \
-  dSparse.h \
-  dbleAEPBAL.h \
-  dbleCHOL.h \
-  dbleGEPBAL.h \
-  dbleHESS.h \
-  dbleLU.h \
-  dbleQR.h \
-  dbleQRP.h \
-  dbleSCHUR.h \
-  dbleSVD.h \
-  dim-vector.h \
-  fCColVector.h \
-  fCDiagMatrix.h \
-  fCMatrix.h \
-  fCNDArray.h \
-  fCRowVector.h \
-  fCmplxAEPBAL.h \
-  fCmplxCHOL.h \
-  fCmplxGEPBAL.h \
-  fCmplxHESS.h \
-  fCmplxLU.h \
-  fCmplxQR.h \
-  fCmplxQRP.h \
-  fCmplxSCHUR.h \
-  fCmplxSVD.h \
-  fColVector.h \
-  fDiagMatrix.h \
-  fEIG.h \
-  fMatrix.h \
-  fNDArray.h \
-  fRowVector.h \
-  floatAEPBAL.h \
-  floatCHOL.h \
-  floatGEPBAL.h \
-  floatHESS.h \
-  floatLU.h \
-  floatQR.h \
-  floatQRP.h \
-  floatSCHUR.h \
-  floatSVD.h \
-  int16NDArray.h \
-  int32NDArray.h \
-  int64NDArray.h \
-  int8NDArray.h \
-  intNDArray.h \
-  mx-base.h \
-  mx-defs.h \
-  mx-ext.h \
-  mx-op-decl.h \
-  mx-op-defs.h \
-  sparse-base-chol.h \
-  sparse-base-lu.h \
-  uint16NDArray.h \
-  uint32NDArray.h \
-  uint64NDArray.h \
-  uint8NDArray.h
+AM_CFLAGS += $(WARN_CFLAGS)
+
+AM_CXXFLAGS += $(WARN_CXXFLAGS)
 
-OPT_IN = \
-  DASPK-opts.in \
-  DASRT-opts.in \
-  DASSL-opts.in \
-  LSODE-opts.in \
-  Quad-opts.in
-
-OPT_INC = \
-  DASPK-opts.h \
-  DASRT-opts.h \
-  DASSL-opts.h \
-  LSODE-opts.h \
-  Quad-opts.h
+octlib_LTLIBRARIES = liboctave.la
 
-INCS = \
-  CollocWt.h \
-  DAE.h \
-  DAEFunc.h \
-  DAERT.h \
-  DAERTFunc.h \
-  DASPK.h \
-  DASRT.h \
-  DASSL.h \
-  LSODE.h \
-  ODE.h \
-  ODEFunc.h \
-  ODES.h \
-  ODESFunc.h \
-  Quad.h \
-  Range.h \
-  base-dae.h \
-  base-de.h \
-  base-list.h \
-  base-min.h \
-  bsxfun.h \
-  byte-swap.h \
-  caseless-str.h \
-  cmd-edit.h \
-  cmd-hist.h \
-  data-conv.h \
-  dir-ops.h \
-  file-ops.h \
-  file-stat.h \
-  functor.h \
-  glob-match.h \
-  idx-vector.h \
-  lo-array-gripes.h \
-  lo-cutils.h \
-  lo-ieee.h \
-  lo-macros.h \
-  lo-mappers.h \
-  lo-math.h \
-  lo-specfun.h \
-  lo-sysdep.h \
-  lo-traits.h \
-  lo-utils.h \
-  mach-info.h \
-  oct-alloc.h \
-  oct-binmap.h \
-  oct-cmplx.h \
-  oct-convn.h \
-  oct-env.h \
-  oct-fftw.h \
-  oct-glob.h \
-  oct-group.h \
-  oct-inttypes.h \
-  oct-locbuf.h \
-  oct-md5.h \
-  oct-mem.h \
-  oct-mutex.h \
-  oct-norm.h \
-  oct-openmp.h \
-  oct-passwd.h \
-  oct-rand.h \
-  oct-refcount.h \
-  oct-rl-edit.h \
-  oct-rl-hist.h \
-  oct-shlib.h \
-  oct-sort.h \
-  oct-sparse.h \
-  oct-spparms.h \
-  oct-syscalls.h \
-  oct-time.h \
-  oct-uname.h \
-  pathlen.h \
-  pathsearch.h \
-  randgamma.h \
-  randmtzig.h \
-  randpoisson.h \
-  regexp.h \
-  singleton-cleanup.h \
-  sparse-sort.h \
-  sparse-util.h \
-  statdefs.h \
-  str-vec.h \
-  sun-utils.h \
-  sysdir.h \
-  syswait.h \
-  $(MATRIX_INC)
+EXTRA_DIST =
 
-PRIVATE_INCS = \
-  oct-glob.h
-
-OTHER_INC = \
-  intNDArray.cc \
-  kpse.cc \
-  mx-inlines.cc
-
-include vx-op-inc.mk
-include mx-op-inc.mk
-include smx-op-inc.mk
-
-$(srcdir)/vx-op-inc.mk: $(srcdir)/config-ops.sh $(srcdir)/mk-ops.awk $(srcdir)/vx-ops
-	$(srcdir)/config-ops.sh $(top_srcdir) vx inc
-
-$(srcdir)/mx-op-inc.mk: $(srcdir)/config-ops.sh $(srcdir)/mk-ops.awk $(srcdir)/mx-ops
-	$(srcdir)/config-ops.sh $(top_srcdir) mx inc
-
-$(srcdir)/smx-op-inc.mk: $(srcdir)/config-ops.sh $(srcdir)/sparse-mk-ops.awk $(srcdir)/sparse-mx-ops
-	$(srcdir)/config-ops.sh $(top_srcdir) smx inc
+DISTCLEANFILES =
 
 BUILT_INCS = \
-  mx-ops.h \
+  operators/mx-ops.h \
   $(OPT_INC) \
   $(MX_OP_INC) \
   $(VX_OP_INC) \
   $(SMX_OP_INC)
 
 BUILT_SOURCES = $(BUILT_INCS)
 
-TEMPLATE_SRC = \
-  Array.cc \
-  DiagArray2.cc \
-  MArray.cc \
-  MDiagArray2.cc \
-  base-lu.cc \
-  base-qr.cc \
-  bsxfun-defs.cc \
-  eigs-base.cc \
-  oct-sort.cc \
-  sparse-base-chol.cc \
-  sparse-base-lu.cc \
-  sparse-dmsolve.cc
+octinclude_HEADERS = \
+  $(ARRAY_INC) \
+  $(NUMERIC_INC) \
+  $(OPERATORS_INC) \
+  $(SYSTEM_INC) \
+  $(UTIL_INC) \
+  $(OTHER_INC) \
+  $(TEMPLATE_SRC)
 
-TI_SRC = \
-  Array-C.cc \
-  Array-b.cc \
-  Array-ch.cc \
-  Array-d.cc \
-  Array-f.cc \
-  Array-fC.cc \
-  Array-i.cc \
-  Array-idx-vec.cc \
-  Array-s.cc \
-  Array-str.cc \
-  Array-voidp.cc \
-  MArray-C.cc \
-  MArray-d.cc \
-  MArray-f.cc \
-  MArray-fC.cc \
-  MArray-i.cc \
-  MArray-s.cc \
-  MSparse-C.cc \
-  MSparse-d.cc \
-  Sparse-C.cc \
-  Sparse-b.cc \
-  Sparse-d.cc \
-  oct-inttypes.cc
+nodist_octinclude_HEADERS = \
+  $(BUILT_INCS)
+
+noinst_LTLIBRARIES =
 
-MATRIX_SRC = \
-  Array-util.cc \
-  CColVector.cc \
-  CDiagMatrix.cc \
-  CMatrix.cc \
-  CNDArray.cc \
-  CRowVector.cc \
-  CSparse.cc \
-  CmplxAEPBAL.cc \
-  CmplxCHOL.cc \
-  CmplxGEPBAL.cc \
-  CmplxHESS.cc \
-  CmplxLU.cc \
-  CmplxQR.cc \
-  CmplxQRP.cc \
-  CmplxSCHUR.cc \
-  CmplxSVD.cc \
-  EIG.cc \
-  MSparse.cc \
-  MatrixType.cc \
-  PermMatrix.cc \
-  Sparse.cc \
-  SparseCmplxCHOL.cc \
-  SparseCmplxLU.cc \
-  SparseCmplxQR.cc \
-  SparseQR.cc \
-  SparsedbleCHOL.cc \
-  SparsedbleLU.cc \
-  boolMatrix.cc \
-  boolNDArray.cc \
-  boolSparse.cc \
-  chMatrix.cc \
-  chNDArray.cc \
-  dim-vector.cc \
-  dColVector.cc \
-  dDiagMatrix.cc \
-  dMatrix.cc \
-  dNDArray.cc \
-  dRowVector.cc \
-  dSparse.cc \
-  dbleAEPBAL.cc \
-  dbleCHOL.cc \
-  dbleGEPBAL.cc \
-  dbleHESS.cc \
-  dbleLU.cc \
-  dbleQR.cc \
-  dbleQRP.cc \
-  dbleSCHUR.cc \
-  dbleSVD.cc \
-  fCColVector.cc \
-  fCDiagMatrix.cc \
-  fCMatrix.cc \
-  fCNDArray.cc \
-  fCRowVector.cc \
-  fCmplxAEPBAL.cc \
-  fCmplxCHOL.cc \
-  fCmplxGEPBAL.cc \
-  fCmplxHESS.cc \
-  fCmplxLU.cc \
-  fCmplxQR.cc \
-  fCmplxQRP.cc \
-  fCmplxSCHUR.cc \
-  fCmplxSVD.cc \
-  fColVector.cc \
-  fDiagMatrix.cc \
-  fEIG.cc \
-  fMatrix.cc \
-  fNDArray.cc \
-  fRowVector.cc \
-  floatAEPBAL.cc \
-  floatCHOL.cc \
-  floatGEPBAL.cc \
-  floatHESS.cc \
-  floatLU.cc \
-  floatQR.cc \
-  floatQRP.cc \
-  floatSCHUR.cc \
-  floatSVD.cc \
-  int16NDArray.cc \
-  int32NDArray.cc \
-  int64NDArray.cc \
-  int8NDArray.cc \
-  uint16NDArray.cc \
-  uint32NDArray.cc \
-  uint64NDArray.cc \
-  uint8NDArray.cc
+## C++ files that are #included, not compiled
+OTHER_INC =
 
-octlib_LTLIBRARIES = liboctave.la
+## C++ files with templates that are #included, not compiled
+TEMPLATE_SRC =
 
-LIBOCTAVE_CXX_SOURCES = \
-  CollocWt.cc \
-  DASPK.cc \
-  DASRT.cc \
-  DASSL.cc \
-  LSODE.cc \
-  ODES.cc \
-  Quad.cc \
-  Range.cc \
-  data-conv.cc \
-  dir-ops.cc \
-  file-ops.cc \
-  file-stat.cc \
-  glob-match.cc \
-  idx-vector.cc \
-  lo-array-gripes.cc \
-  lo-ieee.cc \
-  lo-mappers.cc \
-  lo-specfun.cc \
-  lo-sysdep.cc \
-  lo-utils.cc \
-  mach-info.cc \
-  oct-alloc.cc \
-  oct-convn.cc \
-  oct-env.cc \
-  oct-fftw.cc \
-  oct-glob.cc \
-  oct-group.cc \
-  oct-locbuf.cc \
-  oct-md5.cc \
-  oct-mutex.cc \
-  oct-norm.cc \
-  oct-passwd.cc \
-  oct-rand.cc \
-  oct-shlib.cc \
-  oct-spparms.cc \
-  oct-syscalls.cc \
-  oct-time.cc \
-  oct-uname.cc \
-  pathsearch.cc \
-  regexp.cc \
-  singleton-cleanup.cc \
-  sparse-sort.cc \
-  sparse-util.cc \
-  str-vec.cc \
-  $(TI_SRC) \
-  $(MATRIX_SRC)
+include array/module.mk
+include numeric/module.mk
+include operators/module.mk
+include system/module.mk
+include util/module.mk
 
-include vx-op-src.mk
-include mx-op-src.mk
-include smx-op-src.mk
-
-$(srcdir)/vx-op-src.mk: $(srcdir)/config-ops.sh $(srcdir)/mk-ops.awk $(srcdir)/vx-ops
-	$(srcdir)/config-ops.sh $(top_srcdir) vx src
-
-$(srcdir)/mx-op-src.mk: $(srcdir)/config-ops.sh $(srcdir)/mk-ops.awk $(srcdir)/mx-ops
-	$(srcdir)/config-ops.sh $(top_srcdir) mx src
-
-$(srcdir)/smx-op-src.mk: $(srcdir)/config-ops.sh $(srcdir)/sparse-mk-ops.awk $(srcdir)/sparse-mx-ops
-	$(srcdir)/config-ops.sh $(top_srcdir) smx src
-
-BUILT_LIBOCTAVE_CXX_SOURCES = \
-  $(MX_OP_SRC) \
-  $(VX_OP_SRC) \
-  $(SMX_OP_SRC)
+## liboctave merely collects a bunch of compiled convenience libraries.
+## It has no source code itself.
+liboctave_la_SOURCES = 
 
-LIBOCTAVE_C_SOURCES = \
-  f2c-main.c \
-  lo-cieee.c \
-  lo-cutils.c \
-  randgamma.c \
-  randmtzig.c \
-  randpoisson.c \
-  tempnam.c \
-  tempname.c
-
-LIBOCT_READLINE_CXX_SOURCES = cmd-edit.cc cmd-hist.cc
-
-LIBOCT_READLINE_C_SOURCES = oct-rl-edit.c oct-rl-hist.c
-
-LIBOCT_READLINE_SOURCES = $(LIBOCT_READLINE_CXX_SOURCES) $(LIBOCT_READLINE_C_SOURCES)
-
-liboctave_la_SOURCES = \
-  $(LIBOCTAVE_CXX_SOURCES) \
-  $(LIBOCTAVE_C_SOURCES) \
-  $(LIBOCTAVE_SOURCES) \
-  $(LIBOCT_READLINE_SOURCES) \
-  $(LIBOCT_PATHSEARCH_SOURCES)
-
-nodist_liboctave_la_SOURCES = \
-  $(BUILT_LIBOCTAVE_CXX_SOURCES)
+liboctave_la_CPPFLAGS = @OCTAVE_DLL_DEFS@ $(AM_CPPFLAGS)
 
 include link-deps.mk
 
+# Dummy C++ source to force C++ linking.
+nodist_EXTRA_liboctave_la_SOURCES = dummy.cc
+
 liboctave_la_LIBADD = \
-  ../libcruft/libcruft.la \
+  array/libarray.la \
+  cruft/libcruft.la \
+  cruft/ranlib/libranlib.la \
+  numeric/libnumeric.la \
+  operators/liboperators.la \
+  system/libsystem.la \
+  util/libutil.la \
+  $(top_builddir)/libgnu/libgnu.la \
   $(LIBOCTAVE_LINK_DEPS)
 
-liboctave_la_CPPFLAGS = \
-  @OCTAVE_DLL_DEFS@ \
-  $(SPARSE_XCPPFLAGS) \
-  $(FFTW_XCPPFLAGS) \
-  $(ARPACK_CPPFLAGS) \
-  $(AM_CPPFLAGS)
-
-# Increment these as needed and according to the rules in the libtool
-# manual:
+# Increment these as needed and according to the rules in the libtool manual:
 liboctave_current = 1
 liboctave_revision = 1
 liboctave_age = 0
 
 liboctave_version_info = $(liboctave_current):$(liboctave_revision):$(liboctave_age)
 
 liboctave_la_LDFLAGS = \
   -version-info $(liboctave_version_info) \
   $(NO_UNDEFINED_LDFLAG) \
   -bindir $(bindir) \
   $(LIBOCTAVE_LINK_OPTS)
 
-octinclude_HEADERS = \
-  $(INCS) \
-  $(OTHER_INC) \
-  $(TEMPLATE_SRC) \
-  $(EXTRA_HEADERS)
-
-nodist_octinclude_HEADERS = \
-  $(BUILT_INCS)
-
-$(OPT_INC) : %.h : %.in $(top_srcdir)/build-aux/mk-opts.pl
-	@echo making $@ from $<
-	@$(PERL) $(top_srcdir)/build-aux/mk-opts.pl --opt-class-header $< > $@-t
-	mv $@-t $@
+DISTCLEANFILES += $(BUILT_INCS)
 
-$(VX_OP_INC) $(VX_OP_SRC) : $(srcdir)/mk-ops.awk vx-ops
-	$(AWK) -f $(srcdir)/mk-ops.awk prefix=vx $(srcdir)/vx-ops
-
-$(MX_OP_INC) $(MX_OP_SRC) : $(srcdir)/mk-ops.awk mx-ops
-	$(AWK) -f $(srcdir)/mk-ops.awk prefix=mx $(srcdir)/mx-ops
-
-$(SMX_OP_INC) $(SMX_OP_SRC) : $(srcdir)/sparse-mk-ops.awk sparse-mx-ops
-	$(AWK) -f $(srcdir)/sparse-mk-ops.awk prefix=smx $(srcdir)/sparse-mx-ops
-
-mx-ops.h : $(srcdir)/mk-ops.awk mx-ops
-	$(AWK) -f $(srcdir)/mk-ops.awk prefix=mx make_inclusive_header=mx-ops.h $(srcdir)/mx-ops > $@-t
-	mv $@-t $@
-
-DISTCLEANFILES = $(BUILT_INCS) $(BUILT_LIBOCTAVE_CXX_SOURCES)
-
diff --git a/liboctave/Array-C.cc b/liboctave/array/Array-C.cc
rename from liboctave/Array-C.cc
rename to liboctave/array/Array-C.cc
diff --git a/liboctave/Array-b.cc b/liboctave/array/Array-b.cc
rename from liboctave/Array-b.cc
rename to liboctave/array/Array-b.cc
diff --git a/liboctave/Array-ch.cc b/liboctave/array/Array-ch.cc
rename from liboctave/Array-ch.cc
rename to liboctave/array/Array-ch.cc
diff --git a/liboctave/Array-d.cc b/liboctave/array/Array-d.cc
rename from liboctave/Array-d.cc
rename to liboctave/array/Array-d.cc
diff --git a/liboctave/Array-f.cc b/liboctave/array/Array-f.cc
rename from liboctave/Array-f.cc
rename to liboctave/array/Array-f.cc
diff --git a/liboctave/Array-fC.cc b/liboctave/array/Array-fC.cc
rename from liboctave/Array-fC.cc
rename to liboctave/array/Array-fC.cc
diff --git a/liboctave/Array-i.cc b/liboctave/array/Array-i.cc
rename from liboctave/Array-i.cc
rename to liboctave/array/Array-i.cc
diff --git a/liboctave/Array-idx-vec.cc b/liboctave/array/Array-idx-vec.cc
rename from liboctave/Array-idx-vec.cc
rename to liboctave/array/Array-idx-vec.cc
diff --git a/liboctave/Array-s.cc b/liboctave/array/Array-s.cc
rename from liboctave/Array-s.cc
rename to liboctave/array/Array-s.cc
diff --git a/liboctave/Array-str.cc b/liboctave/array/Array-str.cc
rename from liboctave/Array-str.cc
rename to liboctave/array/Array-str.cc
diff --git a/liboctave/Array-util.cc b/liboctave/array/Array-util.cc
rename from liboctave/Array-util.cc
rename to liboctave/array/Array-util.cc
diff --git a/liboctave/Array-util.h b/liboctave/array/Array-util.h
rename from liboctave/Array-util.h
rename to liboctave/array/Array-util.h
diff --git a/liboctave/Array-voidp.cc b/liboctave/array/Array-voidp.cc
rename from liboctave/Array-voidp.cc
rename to liboctave/array/Array-voidp.cc
diff --git a/liboctave/Array.cc b/liboctave/array/Array.cc
rename from liboctave/Array.cc
rename to liboctave/array/Array.cc
diff --git a/liboctave/Array.h b/liboctave/array/Array.h
rename from liboctave/Array.h
rename to liboctave/array/Array.h
diff --git a/liboctave/Array2.h b/liboctave/array/Array2.h
rename from liboctave/Array2.h
rename to liboctave/array/Array2.h
diff --git a/liboctave/Array3.h b/liboctave/array/Array3.h
rename from liboctave/Array3.h
rename to liboctave/array/Array3.h
diff --git a/liboctave/ArrayN.h b/liboctave/array/ArrayN.h
rename from liboctave/ArrayN.h
rename to liboctave/array/ArrayN.h
diff --git a/liboctave/CColVector.cc b/liboctave/array/CColVector.cc
rename from liboctave/CColVector.cc
rename to liboctave/array/CColVector.cc
diff --git a/liboctave/CColVector.h b/liboctave/array/CColVector.h
rename from liboctave/CColVector.h
rename to liboctave/array/CColVector.h
diff --git a/liboctave/CDiagMatrix.cc b/liboctave/array/CDiagMatrix.cc
rename from liboctave/CDiagMatrix.cc
rename to liboctave/array/CDiagMatrix.cc
--- a/liboctave/CDiagMatrix.cc
+++ b/liboctave/array/CDiagMatrix.cc
@@ -231,23 +231,23 @@ ComplexDiagMatrix::fill (const ComplexRo
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 DiagMatrix
 ComplexDiagMatrix::abs (void) const
 {
-  return DiagMatrix (diag ().abs (), rows (), columns ());
+  return DiagMatrix (extract_diag ().abs (), rows (), columns ());
 }
 
 ComplexDiagMatrix
 conj (const ComplexDiagMatrix& a)
 {
-  return ComplexDiagMatrix (conj (a.diag ()), a.rows (), a.columns ());
+  return ComplexDiagMatrix (conj (a.extract_diag ()), a.rows (), a.columns ());
 }
 
 // resize is the destructive analog for this one
 
 ComplexMatrix
 ComplexDiagMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
 {
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
@@ -541,17 +541,17 @@ ComplexDiagMatrix::determinant (void) co
     }
 
   return det;
 }
 
 double
 ComplexDiagMatrix::rcond (void) const
 {
-  ColumnVector av = diag (0).map<double> (std::abs);
+  ColumnVector av = extract_diag (0).map<double> (std::abs);
   double amx = av.max (), amn = av.min ();
   return amx == 0 ? 0.0 : amn / amx;
 }
 
 // i/o
 
 std::ostream&
 operator << (std::ostream& os, const ComplexDiagMatrix& a)
diff --git a/liboctave/CDiagMatrix.h b/liboctave/array/CDiagMatrix.h
rename from liboctave/CDiagMatrix.h
rename to liboctave/array/CDiagMatrix.h
--- a/liboctave/CDiagMatrix.h
+++ b/liboctave/array/CDiagMatrix.h
@@ -115,18 +115,18 @@ public:
 
   // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
   ComplexDiagMatrix& operator += (const DiagMatrix& a);
   ComplexDiagMatrix& operator -= (const DiagMatrix& a);
 
   // other operations
 
-  ComplexColumnVector diag (octave_idx_type k = 0) const
-    { return MDiagArray2<Complex>::diag (k); }
+  ComplexColumnVector extract_diag (octave_idx_type k = 0) const
+    { return MDiagArray2<Complex>::extract_diag (k); }
 
   ComplexDET determinant (void) const;
   double rcond (void) const;
 
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const ComplexDiagMatrix& a);
 
diff --git a/liboctave/CMatrix.cc b/liboctave/array/CMatrix.cc
rename from liboctave/CMatrix.cc
rename to liboctave/array/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -1178,17 +1178,17 @@ ComplexMatrix::pseudo_inverse (double to
   ComplexMatrix retval;
 
   ComplexSVD result (*this, SVD::economy);
 
   DiagMatrix S = result.singular_values ();
   ComplexMatrix U = result.left_singular_matrix ();
   ComplexMatrix V = result.right_singular_matrix ();
 
-  ColumnVector sigma = S.diag ();
+  ColumnVector sigma = S.extract_diag ();
 
   octave_idx_type r = sigma.length () - 1;
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (tol <= 0.0)
     {
       if (nr > nc)
@@ -1781,25 +1781,27 @@ ComplexMatrix::rcond (MatrixType &mattyp
             rcon = 0.0;
         }
       else if (typ == MatrixType::Permuted_Lower)
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
         {
           double anorm = -1.0;
-          ComplexMatrix atmp = *this;
-          Complex *tmp_data = atmp.fortran_vec ();
 
           if (typ == MatrixType::Hermitian)
             {
               octave_idx_type info = 0;
               char job = 'L';
-              anorm = atmp.abs ().sum ().
-                row(static_cast<octave_idx_type>(0)).max ();
+
+              ComplexMatrix atmp = *this;
+              Complex *tmp_data = atmp.fortran_vec ();
+
+              anorm = atmp.abs().sum().
+                row(static_cast<octave_idx_type>(0)).max();
 
               F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                          tmp_data, nr, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0)
                 {
                   rcon = 0.0;
@@ -1824,16 +1826,19 @@ ComplexMatrix::rcond (MatrixType &mattyp
                 }
             }
 
 
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
+              ComplexMatrix atmp = *this;
+              Complex *tmp_data = atmp.fortran_vec ();
+
               Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
               if (anorm < 0.)
                 anorm = atmp.abs ().sum ().
                   row(static_cast<octave_idx_type>(0)).max ();
 
               Array<Complex> z (dim_vector (2 * nc, 1));
@@ -2093,19 +2098,21 @@ ComplexMatrix::fsolve (MatrixType &matty
 
      // Calculate the norm of the matrix, for later use.
       double anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
+
           ComplexMatrix atmp = *this;
           Complex *tmp_data = atmp.fortran_vec ();
-          anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
+
+          anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
           F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
diff --git a/liboctave/CMatrix.h b/liboctave/array/CMatrix.h
rename from liboctave/CMatrix.h
rename to liboctave/array/CMatrix.h
diff --git a/liboctave/CNDArray.cc b/liboctave/array/CNDArray.cc
rename from liboctave/CNDArray.cc
rename to liboctave/array/CNDArray.cc
diff --git a/liboctave/CNDArray.h b/liboctave/array/CNDArray.h
rename from liboctave/CNDArray.h
rename to liboctave/array/CNDArray.h
diff --git a/liboctave/CRowVector.cc b/liboctave/array/CRowVector.cc
rename from liboctave/CRowVector.cc
rename to liboctave/array/CRowVector.cc
diff --git a/liboctave/CRowVector.h b/liboctave/array/CRowVector.h
rename from liboctave/CRowVector.h
rename to liboctave/array/CRowVector.h
diff --git a/liboctave/CSparse.cc b/liboctave/array/CSparse.cc
rename from liboctave/CSparse.cc
rename to liboctave/array/CSparse.cc
diff --git a/liboctave/CSparse.h b/liboctave/array/CSparse.h
rename from liboctave/CSparse.h
rename to liboctave/array/CSparse.h
diff --git a/liboctave/DiagArray2.cc b/liboctave/array/DiagArray2.cc
rename from liboctave/DiagArray2.cc
rename to liboctave/array/DiagArray2.cc
--- a/liboctave/DiagArray2.cc
+++ b/liboctave/array/DiagArray2.cc
@@ -45,16 +45,23 @@ DiagArray2<T>::DiagArray2 (const Array<T
   if (rcmin != a.length ())
     Array<T>::resize (dim_vector (rcmin, 1));
 }
 
 template <class T>
 Array<T>
 DiagArray2<T>::diag (octave_idx_type k) const
 {
+  return extract_diag (k);
+}
+
+template <class T>
+Array<T>
+DiagArray2<T>::extract_diag (octave_idx_type k) const
+{
   Array<T> d;
 
   if (k == 0)
     // The main diagonal is shallow-copied.
     d = *this;
   else if (k > 0 && k < cols ())
     d = Array<T> (dim_vector (std::min (cols () - k, rows ()), 1), T ());
   else if (k < 0 && -k < rows ())
diff --git a/liboctave/DiagArray2.h b/liboctave/array/DiagArray2.h
rename from liboctave/DiagArray2.h
rename to liboctave/array/DiagArray2.h
--- a/liboctave/DiagArray2.h
+++ b/liboctave/array/DiagArray2.h
@@ -59,17 +59,17 @@ public:
 
   DiagArray2 (const Array<T>& a, octave_idx_type r, octave_idx_type c);
 
   DiagArray2 (const DiagArray2<T>& a)
     : Array<T> (a), d1 (a.d1), d2 (a.d2) { }
 
   template <class U>
   DiagArray2 (const DiagArray2<U>& a)
-    : Array<T> (a.diag ()), d1 (a.dim1 ()), d2 (a.dim2 ()) { }
+    : Array<T> (a.extract_diag ()), d1 (a.dim1 ()), d2 (a.dim2 ()) { }
 
   ~DiagArray2 (void) { }
 
   DiagArray2<T>& operator = (const DiagArray2<T>& a)
     {
       if (this != &a)
         {
           Array<T>::operator = (a);
@@ -92,17 +92,22 @@ public:
   octave_idx_type length (void) const { return Array<T>::length (); }
   octave_idx_type nelem (void) const { return dim1 () * dim2 (); }
   octave_idx_type numel (void) const { return nelem (); }
 
   size_t byte_size (void) const { return Array<T>::byte_size (); }
 
   dim_vector dims (void) const { return dim_vector (d1, d2); }
 
-  Array<T> diag (octave_idx_type k = 0) const;
+  Array<T> diag (octave_idx_type k = 0) const GCC_ATTR_DEPRECATED;
+  Array<T> extract_diag (octave_idx_type k = 0) const;
+  DiagArray2<T> build_diag_matrix () const
+  {
+    return DiagArray2<T> (array_value ());
+  }
 
   // Warning: the non-const two-index versions will silently ignore assignments
   // to off-diagonal elements.
 
   T elem (octave_idx_type r, octave_idx_type c) const
     {
       return (r == c) ? Array<T>::elem (r) : T (0);
     }
diff --git a/liboctave/MArray-C.cc b/liboctave/array/MArray-C.cc
rename from liboctave/MArray-C.cc
rename to liboctave/array/MArray-C.cc
diff --git a/liboctave/MArray-d.cc b/liboctave/array/MArray-d.cc
rename from liboctave/MArray-d.cc
rename to liboctave/array/MArray-d.cc
diff --git a/liboctave/MArray-decl.h b/liboctave/array/MArray-decl.h
rename from liboctave/MArray-decl.h
rename to liboctave/array/MArray-decl.h
diff --git a/liboctave/MArray-defs.h b/liboctave/array/MArray-defs.h
rename from liboctave/MArray-defs.h
rename to liboctave/array/MArray-defs.h
diff --git a/liboctave/MArray-f.cc b/liboctave/array/MArray-f.cc
rename from liboctave/MArray-f.cc
rename to liboctave/array/MArray-f.cc
diff --git a/liboctave/MArray-fC.cc b/liboctave/array/MArray-fC.cc
rename from liboctave/MArray-fC.cc
rename to liboctave/array/MArray-fC.cc
diff --git a/liboctave/MArray-i.cc b/liboctave/array/MArray-i.cc
rename from liboctave/MArray-i.cc
rename to liboctave/array/MArray-i.cc
diff --git a/liboctave/MArray-s.cc b/liboctave/array/MArray-s.cc
rename from liboctave/MArray-s.cc
rename to liboctave/array/MArray-s.cc
diff --git a/liboctave/MArray.cc b/liboctave/array/MArray.cc
rename from liboctave/MArray.cc
rename to liboctave/array/MArray.cc
diff --git a/liboctave/MArray.h b/liboctave/array/MArray.h
rename from liboctave/MArray.h
rename to liboctave/array/MArray.h
diff --git a/liboctave/MArray2.h b/liboctave/array/MArray2.h
rename from liboctave/MArray2.h
rename to liboctave/array/MArray2.h
diff --git a/liboctave/MArrayN.h b/liboctave/array/MArrayN.h
rename from liboctave/MArrayN.h
rename to liboctave/array/MArrayN.h
diff --git a/liboctave/MDiagArray2.cc b/liboctave/array/MDiagArray2.cc
rename from liboctave/MDiagArray2.cc
rename to liboctave/array/MDiagArray2.cc
diff --git a/liboctave/MDiagArray2.h b/liboctave/array/MDiagArray2.h
rename from liboctave/MDiagArray2.h
rename to liboctave/array/MDiagArray2.h
--- a/liboctave/MDiagArray2.h
+++ b/liboctave/array/MDiagArray2.h
@@ -86,17 +86,17 @@ public:
           if (d[i] != T ())
             retval++;
         }
 
       return retval;
     }
 
   MArray<T> diag (octave_idx_type k = 0) const
-    { return DiagArray2<T>::diag (k); }
+    { return DiagArray2<T>::extract_diag (k); }
 
   MDiagArray2<T> transpose (void) const { return DiagArray2<T>::transpose (); }
   MDiagArray2<T> hermitian (T (*fcn) (const T&) = 0) const { return DiagArray2<T>::hermitian (fcn); }
 
   bool is_multiple_of_identity (T val) const;
 
   // Currently, the OPS functions don't need to be friends, but that
   // may change.
diff --git a/liboctave/MSparse-C.cc b/liboctave/array/MSparse-C.cc
rename from liboctave/MSparse-C.cc
rename to liboctave/array/MSparse-C.cc
diff --git a/liboctave/MSparse-d.cc b/liboctave/array/MSparse-d.cc
rename from liboctave/MSparse-d.cc
rename to liboctave/array/MSparse-d.cc
diff --git a/liboctave/MSparse-defs.h b/liboctave/array/MSparse-defs.h
rename from liboctave/MSparse-defs.h
rename to liboctave/array/MSparse-defs.h
diff --git a/liboctave/MSparse.cc b/liboctave/array/MSparse.cc
rename from liboctave/MSparse.cc
rename to liboctave/array/MSparse.cc
diff --git a/liboctave/MSparse.h b/liboctave/array/MSparse.h
rename from liboctave/MSparse.h
rename to liboctave/array/MSparse.h
diff --git a/liboctave/Matrix.h b/liboctave/array/Matrix.h
rename from liboctave/Matrix.h
rename to liboctave/array/Matrix.h
diff --git a/liboctave/MatrixType.cc b/liboctave/array/MatrixType.cc
rename from liboctave/MatrixType.cc
rename to liboctave/array/MatrixType.cc
diff --git a/liboctave/MatrixType.h b/liboctave/array/MatrixType.h
rename from liboctave/MatrixType.h
rename to liboctave/array/MatrixType.h
diff --git a/liboctave/PermMatrix.cc b/liboctave/array/PermMatrix.cc
rename from liboctave/PermMatrix.cc
rename to liboctave/array/PermMatrix.cc
diff --git a/liboctave/PermMatrix.h b/liboctave/array/PermMatrix.h
rename from liboctave/PermMatrix.h
rename to liboctave/array/PermMatrix.h
diff --git a/liboctave/Range.cc b/liboctave/array/Range.cc
rename from liboctave/Range.cc
rename to liboctave/array/Range.cc
diff --git a/liboctave/Range.h b/liboctave/array/Range.h
rename from liboctave/Range.h
rename to liboctave/array/Range.h
diff --git a/liboctave/Sparse-C.cc b/liboctave/array/Sparse-C.cc
rename from liboctave/Sparse-C.cc
rename to liboctave/array/Sparse-C.cc
diff --git a/liboctave/Sparse-b.cc b/liboctave/array/Sparse-b.cc
rename from liboctave/Sparse-b.cc
rename to liboctave/array/Sparse-b.cc
diff --git a/liboctave/Sparse-d.cc b/liboctave/array/Sparse-d.cc
rename from liboctave/Sparse-d.cc
rename to liboctave/array/Sparse-d.cc
diff --git a/liboctave/Sparse.cc b/liboctave/array/Sparse.cc
rename from liboctave/Sparse.cc
rename to liboctave/array/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -318,19 +318,20 @@ Sparse<T>::Sparse (const Array<T>& a, co
   if ((rl != 1 && rl != n) || (cl != 1 && cl != n))
     (*current_liboctave_error_handler) ("sparse: dimension mismatch");
 
   if (rl <= 1 && cl <= 1)
     {
       if (n == 1 && a(0) != T ())
         {
           change_capacity (nzm > 1 ? nzm : 1);
-          xcidx (0) = 0;
-          xridx (0) = r(0);
-          xdata (0) = a(0);
+          xcidx(0) = 0;
+          xridx(0) = r(0);
+          xdata(0) = a(0);
+
           for (octave_idx_type j = 0; j < nc; j++)
             xcidx (j+1) = j >= c(0);
         }
     }
   else if (a_scalar)
     {
       // This is completely specialized, because the sorts can be simplified.
       T a0 = a(0);
@@ -490,18 +491,18 @@ Sparse<T>::Sparse (const Array<T>& a, co
 
       const octave_idx_type *rd = rs.raw (), *rdi = rsi.data ();
       // Count unique indices.
       octave_idx_type new_nz = 1;
       for (octave_idx_type i = 1; i < n; i++)
         new_nz += rd[i-1] != rd[i];
       // Allocate result.
       change_capacity (nzm > new_nz ? nzm : new_nz);
-      xcidx (0) = 0;
-      xcidx (1) = new_nz;
+      xcidx(0) = 0;
+      xcidx(1) = new_nz;
       octave_idx_type *rri = ridx ();
       T *rrd = data ();
 
       octave_quit ();
 
       octave_idx_type k = 0;
       rri[k] = rd[0];
       rrd[k] = a(rdi[0]);
@@ -1248,17 +1249,17 @@ Sparse<T>::delete_elements (const idx_ve
           else if (nz == 0)
             {
               // No elements to preserve; adjust dimensions.
               *this = Sparse<T> (nr, nc - (ub - lb));
             }
           else
             {
               const Sparse<T> tmp = *this;
-              octave_idx_type lbi = tmp.cidx (lb), ubi = tmp.cidx (ub),
+              octave_idx_type lbi = tmp.cidx(lb), ubi = tmp.cidx(ub),
                 new_nz = nz - (ubi - lbi);
 
               *this = Sparse<T> (nr, nc - (ub - lb), new_nz);
               copy_or_memcpy (lbi, tmp.data (), data ());
               copy_or_memcpy (lbi, tmp.ridx (), ridx ());
               copy_or_memcpy (nz - ubi, tmp.data () + ubi, xdata () + lbi);
               copy_or_memcpy (nz - ubi, tmp.ridx () + ubi, xridx () + lbi);
               copy_or_memcpy (lb, tmp.cidx () + 1, cidx () + 1);
@@ -1291,30 +1292,30 @@ Sparse<T>::delete_elements (const idx_ve
             {
               // This is more memory-efficient than the approach below.
               const Sparse<T> tmpl = index (idx_vector (0, lb), idx_j);
               const Sparse<T> tmpu = index (idx_vector (ub, nr), idx_j);
               *this = Sparse<T> (nr - (ub - lb), nc,
                                  tmpl.nnz () + tmpu.nnz ());
               for (octave_idx_type j = 0, k = 0; j < nc; j++)
                 {
-                  for (octave_idx_type i = tmpl.cidx (j); i < tmpl.cidx (j+1);
+                  for (octave_idx_type i = tmpl.cidx(j); i < tmpl.cidx(j+1);
                        i++)
                     {
-                      xdata (k) = tmpl.data (i);
-                      xridx (k++) = tmpl.ridx (i);
+                      xdata(k) = tmpl.data(i);
+                      xridx(k++) = tmpl.ridx(i);
                     }
-                  for (octave_idx_type i = tmpu.cidx (j); i < tmpu.cidx (j+1);
+                  for (octave_idx_type i = tmpu.cidx(j); i < tmpu.cidx(j+1);
                        i++)
                     {
-                      xdata (k) = tmpu.data (i);
-                      xridx (k++) = tmpu.ridx (i) + lb;
+                      xdata(k) = tmpu.data(i);
+                      xridx(k++) = tmpu.ridx(i) + lb;
                     }
 
-                  xcidx (j+1) = k;
+                  xcidx(j+1) = k;
                 }
             }
         }
       else
         {
           // This is done by transposing, deleting columns, then transposing
           // again.
           Sparse<T> tmp = transpose ();
diff --git a/liboctave/Sparse.h b/liboctave/array/Sparse.h
rename from liboctave/Sparse.h
rename to liboctave/array/Sparse.h
diff --git a/liboctave/boolMatrix.cc b/liboctave/array/boolMatrix.cc
rename from liboctave/boolMatrix.cc
rename to liboctave/array/boolMatrix.cc
diff --git a/liboctave/boolMatrix.h b/liboctave/array/boolMatrix.h
rename from liboctave/boolMatrix.h
rename to liboctave/array/boolMatrix.h
diff --git a/liboctave/boolNDArray.cc b/liboctave/array/boolNDArray.cc
rename from liboctave/boolNDArray.cc
rename to liboctave/array/boolNDArray.cc
diff --git a/liboctave/boolNDArray.h b/liboctave/array/boolNDArray.h
rename from liboctave/boolNDArray.h
rename to liboctave/array/boolNDArray.h
diff --git a/liboctave/boolSparse.cc b/liboctave/array/boolSparse.cc
rename from liboctave/boolSparse.cc
rename to liboctave/array/boolSparse.cc
--- a/liboctave/boolSparse.cc
+++ b/liboctave/array/boolSparse.cc
@@ -24,17 +24,16 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
 #include <vector>
 
-#include "config.h"
 #include "quit.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 
 #include "boolSparse.h"
 #include "dSparse.h"
 #include "oct-mem.h"
 #include "oct-locbuf.h"
diff --git a/liboctave/boolSparse.h b/liboctave/array/boolSparse.h
rename from liboctave/boolSparse.h
rename to liboctave/array/boolSparse.h
diff --git a/liboctave/chMatrix.cc b/liboctave/array/chMatrix.cc
rename from liboctave/chMatrix.cc
rename to liboctave/array/chMatrix.cc
diff --git a/liboctave/chMatrix.h b/liboctave/array/chMatrix.h
rename from liboctave/chMatrix.h
rename to liboctave/array/chMatrix.h
diff --git a/liboctave/chNDArray.cc b/liboctave/array/chNDArray.cc
rename from liboctave/chNDArray.cc
rename to liboctave/array/chNDArray.cc
diff --git a/liboctave/chNDArray.h b/liboctave/array/chNDArray.h
rename from liboctave/chNDArray.h
rename to liboctave/array/chNDArray.h
diff --git a/liboctave/dColVector.cc b/liboctave/array/dColVector.cc
rename from liboctave/dColVector.cc
rename to liboctave/array/dColVector.cc
diff --git a/liboctave/dColVector.h b/liboctave/array/dColVector.h
rename from liboctave/dColVector.h
rename to liboctave/array/dColVector.h
diff --git a/liboctave/dDiagMatrix.cc b/liboctave/array/dDiagMatrix.cc
rename from liboctave/dDiagMatrix.cc
rename to liboctave/array/dDiagMatrix.cc
--- a/liboctave/dDiagMatrix.cc
+++ b/liboctave/array/dDiagMatrix.cc
@@ -136,29 +136,29 @@ DiagMatrix::fill (const RowVector& a, oc
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 DiagMatrix
 DiagMatrix::abs (void) const
 {
-  return DiagMatrix (diag ().abs (), rows (), columns ());
+  return DiagMatrix (extract_diag ().abs (), rows (), columns ());
 }
 
 DiagMatrix
 real (const ComplexDiagMatrix& a)
 {
-  return DiagMatrix (real (a.diag ()), a.rows (), a.cols ());
+  return DiagMatrix (real (a.extract_diag ()), a.rows (), a.cols ());
 }
 
 DiagMatrix
 imag (const ComplexDiagMatrix& a)
 {
-  return DiagMatrix (imag (a.diag ()), a.rows (), a.cols ());
+  return DiagMatrix (imag (a.extract_diag ()), a.rows (), a.cols ());
 }
 
 Matrix
 DiagMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
 {
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
@@ -357,17 +357,17 @@ DiagMatrix::determinant (void) const
     }
 
   return det;
 }
 
 double
 DiagMatrix::rcond (void) const
 {
-  ColumnVector av = diag (0).map<double> (fabs);
+  ColumnVector av = extract_diag (0).map<double> (fabs);
   double amx = av.max (), amn = av.min ();
   return amx == 0 ? 0.0 : amn / amx;
 }
 
 std::ostream&
 operator << (std::ostream& os, const DiagMatrix& a)
 {
 //  int field_width = os.precision () + 7;
diff --git a/liboctave/dDiagMatrix.h b/liboctave/array/dDiagMatrix.h
rename from liboctave/dDiagMatrix.h
rename to liboctave/array/dDiagMatrix.h
--- a/liboctave/dDiagMatrix.h
+++ b/liboctave/array/dDiagMatrix.h
@@ -93,18 +93,18 @@ public:
   ColumnVector column (char *s) const;
 
   DiagMatrix inverse (void) const;
   DiagMatrix inverse (octave_idx_type& info) const;
   DiagMatrix pseudo_inverse (void) const;
 
   // other operations
 
-  ColumnVector diag (octave_idx_type k = 0) const
-    { return MDiagArray2<double>::diag (k); }
+  ColumnVector extract_diag (octave_idx_type k = 0) const
+    { return MDiagArray2<double>::extract_diag (k); }
 
   DET determinant (void) const;
   double rcond (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const DiagMatrix& a);
 
diff --git a/liboctave/dMatrix.cc b/liboctave/array/dMatrix.cc
rename from liboctave/dMatrix.cc
rename to liboctave/array/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -851,17 +851,17 @@ Matrix
 Matrix::pseudo_inverse (double tol) const
 {
   SVD result (*this, SVD::economy);
 
   DiagMatrix S = result.singular_values ();
   Matrix U = result.left_singular_matrix ();
   Matrix V = result.right_singular_matrix ();
 
-  ColumnVector sigma = S.diag ();
+  ColumnVector sigma = S.extract_diag ();
 
   octave_idx_type r = sigma.length () - 1;
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (tol <= 0.0)
     {
       if (nr > nc)
@@ -1449,25 +1449,27 @@ Matrix::rcond (MatrixType &mattype) cons
             rcon = 0.0;
         }
       else if (typ == MatrixType::Permuted_Lower)
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
         {
           double anorm = -1.0;
-          Matrix atmp = *this;
-          double *tmp_data = atmp.fortran_vec ();
 
           if (typ == MatrixType::Hermitian)
             {
               octave_idx_type info = 0;
               char job = 'L';
-              anorm = atmp.abs ().sum ().
-                row(static_cast<octave_idx_type>(0)).max ();
+
+              Matrix atmp = *this;
+              double *tmp_data = atmp.fortran_vec ();
+
+              anorm = atmp.abs().sum().
+                row(static_cast<octave_idx_type>(0)).max();
 
               F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                          tmp_data, nr, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0)
                 {
                   rcon = 0.0;
@@ -1490,16 +1492,19 @@ Matrix::rcond (MatrixType &mattype) cons
                     rcon = 0.0;
                 }
             }
 
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
+              Matrix atmp = *this;
+              double *tmp_data = atmp.fortran_vec ();
+
               Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
               if (anorm < 0.)
                 anorm = atmp.abs ().sum ().
                   row(static_cast<octave_idx_type>(0)).max ();
 
               Array<double> z (dim_vector (4 * nc, 1));
@@ -1755,19 +1760,21 @@ Matrix::fsolve (MatrixType &mattype, con
 
      // Calculate the norm of the matrix, for later use.
       double anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
+
           Matrix atmp = *this;
           double *tmp_data = atmp.fortran_vec ();
-          anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
+
+          anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
           F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
@@ -1833,18 +1840,19 @@ Matrix::fsolve (MatrixType &mattype, con
         {
           info = 0;
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           Matrix atmp = *this;
           double *tmp_data = atmp.fortran_vec ();
-          if (anorm < 0.)
-            anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
+
+          if(anorm < 0.)
+            anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
           Array<double> z (dim_vector (4 * nc, 1));
           double *pz = z.fortran_vec ();
           Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
 
           F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
diff --git a/liboctave/dMatrix.h b/liboctave/array/dMatrix.h
rename from liboctave/dMatrix.h
rename to liboctave/array/dMatrix.h
diff --git a/liboctave/dNDArray.cc b/liboctave/array/dNDArray.cc
rename from liboctave/dNDArray.cc
rename to liboctave/array/dNDArray.cc
diff --git a/liboctave/dNDArray.h b/liboctave/array/dNDArray.h
rename from liboctave/dNDArray.h
rename to liboctave/array/dNDArray.h
diff --git a/liboctave/dRowVector.cc b/liboctave/array/dRowVector.cc
rename from liboctave/dRowVector.cc
rename to liboctave/array/dRowVector.cc
diff --git a/liboctave/dRowVector.h b/liboctave/array/dRowVector.h
rename from liboctave/dRowVector.h
rename to liboctave/array/dRowVector.h
diff --git a/liboctave/dSparse.cc b/liboctave/array/dSparse.cc
rename from liboctave/dSparse.cc
rename to liboctave/array/dSparse.cc
diff --git a/liboctave/dSparse.h b/liboctave/array/dSparse.h
rename from liboctave/dSparse.h
rename to liboctave/array/dSparse.h
diff --git a/liboctave/dim-vector.cc b/liboctave/array/dim-vector.cc
rename from liboctave/dim-vector.cc
rename to liboctave/array/dim-vector.cc
diff --git a/liboctave/dim-vector.h b/liboctave/array/dim-vector.h
rename from liboctave/dim-vector.h
rename to liboctave/array/dim-vector.h
diff --git a/liboctave/fCColVector.cc b/liboctave/array/fCColVector.cc
rename from liboctave/fCColVector.cc
rename to liboctave/array/fCColVector.cc
diff --git a/liboctave/fCColVector.h b/liboctave/array/fCColVector.h
rename from liboctave/fCColVector.h
rename to liboctave/array/fCColVector.h
diff --git a/liboctave/fCDiagMatrix.cc b/liboctave/array/fCDiagMatrix.cc
rename from liboctave/fCDiagMatrix.cc
rename to liboctave/array/fCDiagMatrix.cc
--- a/liboctave/fCDiagMatrix.cc
+++ b/liboctave/array/fCDiagMatrix.cc
@@ -231,23 +231,23 @@ FloatComplexDiagMatrix::fill (const Floa
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 FloatDiagMatrix
 FloatComplexDiagMatrix::abs (void) const
 {
-  return FloatDiagMatrix (diag ().abs (), rows (), columns ());
+  return FloatDiagMatrix (extract_diag ().abs (), rows (), columns ());
 }
 
 FloatComplexDiagMatrix
 conj (const FloatComplexDiagMatrix& a)
 {
-  return FloatComplexDiagMatrix (conj (a.diag ()), a.rows (), a.columns ());
+  return FloatComplexDiagMatrix (conj (a.extract_diag ()), a.rows (), a.columns ());
 }
 
 // resize is the destructive analog for this one
 
 FloatComplexMatrix
 FloatComplexDiagMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
 {
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
@@ -541,17 +541,17 @@ FloatComplexDiagMatrix::determinant (voi
     }
 
   return det;
 }
 
 float
 FloatComplexDiagMatrix::rcond (void) const
 {
-  FloatColumnVector av = diag (0).map<float> (std::abs);
+  FloatColumnVector av = extract_diag (0).map<float> (std::abs);
   float amx = av.max (), amn = av.min ();
   return amx == 0 ? 0.0f : amn / amx;
 }
 
 // i/o
 
 std::ostream&
 operator << (std::ostream& os, const FloatComplexDiagMatrix& a)
diff --git a/liboctave/fCDiagMatrix.h b/liboctave/array/fCDiagMatrix.h
rename from liboctave/fCDiagMatrix.h
rename to liboctave/array/fCDiagMatrix.h
--- a/liboctave/fCDiagMatrix.h
+++ b/liboctave/array/fCDiagMatrix.h
@@ -115,18 +115,18 @@ public:
 
   // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
   FloatComplexDiagMatrix& operator += (const FloatDiagMatrix& a);
   FloatComplexDiagMatrix& operator -= (const FloatDiagMatrix& a);
 
   // other operations
 
-  FloatComplexColumnVector diag (octave_idx_type k = 0) const
-    { return MDiagArray2<FloatComplex>::diag (k); }
+  FloatComplexColumnVector extract_diag (octave_idx_type k = 0) const
+    { return MDiagArray2<FloatComplex>::extract_diag (k); }
 
   FloatComplexDET determinant (void) const;
   float rcond (void) const;
 
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const FloatComplexDiagMatrix& a);
 
diff --git a/liboctave/fCMatrix.cc b/liboctave/array/fCMatrix.cc
rename from liboctave/fCMatrix.cc
rename to liboctave/array/fCMatrix.cc
--- a/liboctave/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -1180,17 +1180,17 @@ FloatComplexMatrix::pseudo_inverse (floa
   FloatComplexMatrix retval;
 
   FloatComplexSVD result (*this, SVD::economy);
 
   FloatDiagMatrix S = result.singular_values ();
   FloatComplexMatrix U = result.left_singular_matrix ();
   FloatComplexMatrix V = result.right_singular_matrix ();
 
-  FloatColumnVector sigma = S.diag ();
+  FloatColumnVector sigma = S.extract_diag ();
 
   octave_idx_type r = sigma.length () - 1;
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (tol <= 0.0)
     {
       if (nr > nc)
@@ -1777,25 +1777,27 @@ FloatComplexMatrix::rcond (MatrixType &m
             rcon = 0.0;
         }
       else if (typ == MatrixType::Permuted_Lower)
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
         {
           float anorm = -1.0;
-          FloatComplexMatrix atmp = *this;
-          FloatComplex *tmp_data = atmp.fortran_vec ();
 
           if (typ == MatrixType::Hermitian)
             {
               octave_idx_type info = 0;
               char job = 'L';
-              anorm = atmp.abs ().sum ().
-                row(static_cast<octave_idx_type>(0)).max ();
+
+              FloatComplexMatrix atmp = *this;
+              FloatComplex *tmp_data = atmp.fortran_vec ();
+
+              anorm = atmp.abs().sum().
+                row(static_cast<octave_idx_type>(0)).max();
 
               F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                          tmp_data, nr, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0)
                 {
                   rcon = 0.0;
@@ -1820,16 +1822,19 @@ FloatComplexMatrix::rcond (MatrixType &m
                 }
             }
 
 
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
+              FloatComplexMatrix atmp = *this;
+              FloatComplex *tmp_data = atmp.fortran_vec ();
+
               Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
               if (anorm < 0.)
                 anorm = atmp.abs ().sum ().
                   row(static_cast<octave_idx_type>(0)).max ();
 
               Array<FloatComplex> z (dim_vector (2 * nc, 1));
@@ -2089,19 +2094,21 @@ FloatComplexMatrix::fsolve (MatrixType &
 
      // Calculate the norm of the matrix, for later use.
       float anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
+
           FloatComplexMatrix atmp = *this;
           FloatComplex *tmp_data = atmp.fortran_vec ();
-          anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
+
+          anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
           F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
diff --git a/liboctave/fCMatrix.h b/liboctave/array/fCMatrix.h
rename from liboctave/fCMatrix.h
rename to liboctave/array/fCMatrix.h
diff --git a/liboctave/fCNDArray.cc b/liboctave/array/fCNDArray.cc
rename from liboctave/fCNDArray.cc
rename to liboctave/array/fCNDArray.cc
diff --git a/liboctave/fCNDArray.h b/liboctave/array/fCNDArray.h
rename from liboctave/fCNDArray.h
rename to liboctave/array/fCNDArray.h
diff --git a/liboctave/fCRowVector.cc b/liboctave/array/fCRowVector.cc
rename from liboctave/fCRowVector.cc
rename to liboctave/array/fCRowVector.cc
diff --git a/liboctave/fCRowVector.h b/liboctave/array/fCRowVector.h
rename from liboctave/fCRowVector.h
rename to liboctave/array/fCRowVector.h
diff --git a/liboctave/fColVector.cc b/liboctave/array/fColVector.cc
rename from liboctave/fColVector.cc
rename to liboctave/array/fColVector.cc
diff --git a/liboctave/fColVector.h b/liboctave/array/fColVector.h
rename from liboctave/fColVector.h
rename to liboctave/array/fColVector.h
diff --git a/liboctave/fDiagMatrix.cc b/liboctave/array/fDiagMatrix.cc
rename from liboctave/fDiagMatrix.cc
rename to liboctave/array/fDiagMatrix.cc
--- a/liboctave/fDiagMatrix.cc
+++ b/liboctave/array/fDiagMatrix.cc
@@ -136,29 +136,29 @@ FloatDiagMatrix::fill (const FloatRowVec
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 FloatDiagMatrix
 FloatDiagMatrix::abs (void) const
 {
-  return FloatDiagMatrix (diag ().abs (), rows (), columns ());
+  return FloatDiagMatrix (extract_diag ().abs (), rows (), columns ());
 }
 
 FloatDiagMatrix
 real (const FloatComplexDiagMatrix& a)
 {
-  return FloatDiagMatrix (real (a.diag ()), a.rows (), a.columns ());
+  return FloatDiagMatrix (real (a.extract_diag ()), a.rows (), a.columns ());
 }
 
 FloatDiagMatrix
 imag (const FloatComplexDiagMatrix& a)
 {
-  return FloatDiagMatrix (imag (a.diag ()), a.rows (), a.columns ());
+  return FloatDiagMatrix (imag (a.extract_diag ()), a.rows (), a.columns ());
 }
 
 FloatMatrix
 FloatDiagMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
 {
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
@@ -357,17 +357,17 @@ FloatDiagMatrix::determinant (void) cons
     }
 
   return det;
 }
 
 float
 FloatDiagMatrix::rcond (void) const
 {
-  FloatColumnVector av = diag (0).map<float> (fabsf);
+  FloatColumnVector av = extract_diag (0).map<float> (fabsf);
   float amx = av.max (), amn = av.min ();
   return amx == 0 ? 0.0f : amn / amx;
 }
 
 std::ostream&
 operator << (std::ostream& os, const FloatDiagMatrix& a)
 {
 //  int field_width = os.precision () + 7;
diff --git a/liboctave/fDiagMatrix.h b/liboctave/array/fDiagMatrix.h
rename from liboctave/fDiagMatrix.h
rename to liboctave/array/fDiagMatrix.h
--- a/liboctave/fDiagMatrix.h
+++ b/liboctave/array/fDiagMatrix.h
@@ -93,18 +93,18 @@ public:
   FloatColumnVector column (char *s) const;
 
   FloatDiagMatrix inverse (void) const;
   FloatDiagMatrix inverse (octave_idx_type& info) const;
   FloatDiagMatrix pseudo_inverse (void) const;
 
   // other operations
 
-  FloatColumnVector diag (octave_idx_type k = 0) const
-    { return MDiagArray2<float>::diag (k); }
+  FloatColumnVector extract_diag (octave_idx_type k = 0) const
+    { return MDiagArray2<float>::extract_diag (k); }
 
   FloatDET determinant (void) const;
   float rcond (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatDiagMatrix& a);
 
diff --git a/liboctave/fMatrix.cc b/liboctave/array/fMatrix.cc
rename from liboctave/fMatrix.cc
rename to liboctave/array/fMatrix.cc
--- a/liboctave/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -851,17 +851,17 @@ FloatMatrix
 FloatMatrix::pseudo_inverse (float tol) const
 {
   FloatSVD result (*this, SVD::economy);
 
   FloatDiagMatrix S = result.singular_values ();
   FloatMatrix U = result.left_singular_matrix ();
   FloatMatrix V = result.right_singular_matrix ();
 
-  FloatColumnVector sigma = S.diag ();
+  FloatColumnVector sigma = S.extract_diag ();
 
   octave_idx_type r = sigma.length () - 1;
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (tol <= 0.0)
     {
       if (nr > nc)
@@ -1449,25 +1449,27 @@ FloatMatrix::rcond (MatrixType &mattype)
             rcon = 0.0;
         }
       else if (typ == MatrixType::Permuted_Lower)
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
         {
           float anorm = -1.0;
-          FloatMatrix atmp = *this;
-          float *tmp_data = atmp.fortran_vec ();
 
           if (typ == MatrixType::Hermitian)
             {
               octave_idx_type info = 0;
               char job = 'L';
-              anorm = atmp.abs ().sum ().
-                row (static_cast<octave_idx_type>(0)).max ();
+
+              FloatMatrix atmp = *this;
+              float *tmp_data = atmp.fortran_vec ();
+
+              anorm = atmp.abs().sum().
+                row(static_cast<octave_idx_type>(0)).max();
 
               F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                          tmp_data, nr, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0)
                 {
                   rcon = 0.0;
@@ -1490,16 +1492,19 @@ FloatMatrix::rcond (MatrixType &mattype)
                     rcon = 0.0;
                 }
             }
 
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
+              FloatMatrix atmp = *this;
+              float *tmp_data = atmp.fortran_vec ();
+
               Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
               if (anorm < 0.)
                 anorm = atmp.abs ().sum ().
                   row(static_cast<octave_idx_type>(0)).max ();
 
               Array<float> z (dim_vector (4 * nc, 1));
@@ -1755,19 +1760,21 @@ FloatMatrix::fsolve (MatrixType &mattype
 
      // Calculate the norm of the matrix, for later use.
       float anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
+
           FloatMatrix atmp = *this;
           float *tmp_data = atmp.fortran_vec ();
-          anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
+
+          anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
           F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
@@ -1833,18 +1840,19 @@ FloatMatrix::fsolve (MatrixType &mattype
         {
           info = 0;
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           FloatMatrix atmp = *this;
           float *tmp_data = atmp.fortran_vec ();
-          if (anorm < 0.)
-            anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
+
+          if(anorm < 0.)
+            anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
           Array<float> z (dim_vector (4 * nc, 1));
           float *pz = z.fortran_vec ();
           Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
 
           F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
diff --git a/liboctave/fMatrix.h b/liboctave/array/fMatrix.h
rename from liboctave/fMatrix.h
rename to liboctave/array/fMatrix.h
diff --git a/liboctave/fNDArray.cc b/liboctave/array/fNDArray.cc
rename from liboctave/fNDArray.cc
rename to liboctave/array/fNDArray.cc
diff --git a/liboctave/fNDArray.h b/liboctave/array/fNDArray.h
rename from liboctave/fNDArray.h
rename to liboctave/array/fNDArray.h
diff --git a/liboctave/fRowVector.cc b/liboctave/array/fRowVector.cc
rename from liboctave/fRowVector.cc
rename to liboctave/array/fRowVector.cc
diff --git a/liboctave/fRowVector.h b/liboctave/array/fRowVector.h
rename from liboctave/fRowVector.h
rename to liboctave/array/fRowVector.h
diff --git a/liboctave/idx-vector.cc b/liboctave/array/idx-vector.cc
rename from liboctave/idx-vector.cc
rename to liboctave/array/idx-vector.cc
diff --git a/liboctave/idx-vector.h b/liboctave/array/idx-vector.h
rename from liboctave/idx-vector.h
rename to liboctave/array/idx-vector.h
diff --git a/liboctave/int16NDArray.cc b/liboctave/array/int16NDArray.cc
rename from liboctave/int16NDArray.cc
rename to liboctave/array/int16NDArray.cc
diff --git a/liboctave/int16NDArray.h b/liboctave/array/int16NDArray.h
rename from liboctave/int16NDArray.h
rename to liboctave/array/int16NDArray.h
diff --git a/liboctave/int32NDArray.cc b/liboctave/array/int32NDArray.cc
rename from liboctave/int32NDArray.cc
rename to liboctave/array/int32NDArray.cc
diff --git a/liboctave/int32NDArray.h b/liboctave/array/int32NDArray.h
rename from liboctave/int32NDArray.h
rename to liboctave/array/int32NDArray.h
diff --git a/liboctave/int64NDArray.cc b/liboctave/array/int64NDArray.cc
rename from liboctave/int64NDArray.cc
rename to liboctave/array/int64NDArray.cc
diff --git a/liboctave/int64NDArray.h b/liboctave/array/int64NDArray.h
rename from liboctave/int64NDArray.h
rename to liboctave/array/int64NDArray.h
diff --git a/liboctave/int8NDArray.cc b/liboctave/array/int8NDArray.cc
rename from liboctave/int8NDArray.cc
rename to liboctave/array/int8NDArray.cc
diff --git a/liboctave/int8NDArray.h b/liboctave/array/int8NDArray.h
rename from liboctave/int8NDArray.h
rename to liboctave/array/int8NDArray.h
diff --git a/liboctave/intNDArray.cc b/liboctave/array/intNDArray.cc
rename from liboctave/intNDArray.cc
rename to liboctave/array/intNDArray.cc
diff --git a/liboctave/intNDArray.h b/liboctave/array/intNDArray.h
rename from liboctave/intNDArray.h
rename to liboctave/array/intNDArray.h
diff --git a/liboctave/array/module.mk b/liboctave/array/module.mk
new file mode 100644
--- /dev/null
+++ b/liboctave/array/module.mk
@@ -0,0 +1,143 @@
+EXTRA_DIST += \
+  array/module.mk
+
+ARRAY_INC = \
+  array/Array2.h \
+  array/Array3.h \
+  array/Array.h \
+  array/ArrayN.h \
+  array/Array-util.h \
+  array/boolMatrix.h \
+  array/boolNDArray.h \
+  array/boolSparse.h \
+  array/CColVector.h \
+  array/CDiagMatrix.h \
+  array/chMatrix.h \
+  array/chNDArray.h \
+  array/CMatrix.h \
+  array/CNDArray.h \
+  array/CRowVector.h \
+  array/CSparse.h \
+  array/dColVector.h \
+  array/dDiagMatrix.h \
+  array/DiagArray2.h \
+  array/dim-vector.h \
+  array/dMatrix.h \
+  array/dNDArray.h \
+  array/dRowVector.h \
+  array/dSparse.h \
+  array/fCColVector.h \
+  array/fCDiagMatrix.h \
+  array/fCMatrix.h \
+  array/fCNDArray.h \
+  array/fColVector.h \
+  array/fCRowVector.h \
+  array/fDiagMatrix.h \
+  array/fMatrix.h \
+  array/fNDArray.h \
+  array/fRowVector.h \
+  array/idx-vector.h \
+  array/int16NDArray.h \
+  array/int32NDArray.h \
+  array/int64NDArray.h \
+  array/int8NDArray.h \
+  array/intNDArray.h \
+  array/MArray2.h \
+  array/MArray-decl.h \
+  array/MArray-defs.h \
+  array/MArray.h \
+  array/MArrayN.h \
+  array/Matrix.h \
+  array/MatrixType.h \
+  array/MDiagArray2.h \
+  array/MSparse-defs.h \
+  array/MSparse.h \
+  array/PermMatrix.h \
+  array/Range.h \
+  array/Sparse.h \
+  array/uint16NDArray.h \
+  array/uint32NDArray.h \
+  array/uint64NDArray.h \
+  array/uint8NDArray.h
+
+ARRAY_SRC = \
+  array/Array-b.cc \
+  array/Array-C.cc \
+  array/Array-ch.cc \
+  array/Array-d.cc \
+  array/Array-f.cc \
+  array/Array-fC.cc \
+  array/Array-i.cc \
+  array/Array-idx-vec.cc \
+  array/Array-s.cc \
+  array/Array-str.cc \
+  array/Array-util.cc \
+  array/Array-voidp.cc \
+  array/boolMatrix.cc \
+  array/boolNDArray.cc \
+  array/boolSparse.cc \
+  array/CColVector.cc \
+  array/CDiagMatrix.cc \
+  array/chMatrix.cc \
+  array/chNDArray.cc \
+  array/CMatrix.cc \
+  array/CNDArray.cc \
+  array/CRowVector.cc \
+  array/CSparse.cc \
+  array/dColVector.cc \
+  array/dDiagMatrix.cc \
+  array/dim-vector.cc \
+  array/dMatrix.cc \
+  array/dNDArray.cc \
+  array/dRowVector.cc \
+  array/dSparse.cc \
+  array/fCColVector.cc \
+  array/fCDiagMatrix.cc \
+  array/fCMatrix.cc \
+  array/fCNDArray.cc \
+  array/fColVector.cc \
+  array/fCRowVector.cc \
+  array/fDiagMatrix.cc \
+  array/fMatrix.cc \
+  array/fNDArray.cc \
+  array/fRowVector.cc \
+  array/idx-vector.cc \
+  array/int16NDArray.cc \
+  array/int32NDArray.cc \
+  array/int64NDArray.cc \
+  array/int8NDArray.cc \
+  array/MArray-C.cc \
+  array/MArray-d.cc \
+  array/MArray-f.cc \
+  array/MArray-fC.cc \
+  array/MArray-i.cc \
+  array/MArray-s.cc \
+  array/MatrixType.cc \
+  array/MSparse-C.cc \
+  array/MSparse-d.cc \
+  array/PermMatrix.cc \
+  array/Range.cc \
+  array/Sparse-b.cc \
+  array/Sparse-C.cc \
+  array/Sparse-d.cc \
+  array/uint16NDArray.cc \
+  array/uint32NDArray.cc \
+  array/uint64NDArray.cc \
+  array/uint8NDArray.cc 
+
+TEMPLATE_SRC += \
+  array/Array.cc \
+  array/DiagArray2.cc \
+  array/intNDArray.cc \
+  array/MArray.cc \
+  array/MDiagArray2.cc \
+  array/MSparse.cc \
+  array/Sparse.cc
+
+noinst_LTLIBRARIES += array/libarray.la
+
+array_libarray_la_SOURCES = $(ARRAY_SRC)
+array_libarray_la_CPPFLAGS = \
+  $(liboctave_la_CPPFLAGS) \
+  $(SPARSE_XCPPFLAGS)
+
diff --git a/liboctave/uint16NDArray.cc b/liboctave/array/uint16NDArray.cc
rename from liboctave/uint16NDArray.cc
rename to liboctave/array/uint16NDArray.cc
diff --git a/liboctave/uint16NDArray.h b/liboctave/array/uint16NDArray.h
rename from liboctave/uint16NDArray.h
rename to liboctave/array/uint16NDArray.h
diff --git a/liboctave/uint32NDArray.cc b/liboctave/array/uint32NDArray.cc
rename from liboctave/uint32NDArray.cc
rename to liboctave/array/uint32NDArray.cc
diff --git a/liboctave/uint32NDArray.h b/liboctave/array/uint32NDArray.h
rename from liboctave/uint32NDArray.h
rename to liboctave/array/uint32NDArray.h
diff --git a/liboctave/uint64NDArray.cc b/liboctave/array/uint64NDArray.cc
rename from liboctave/uint64NDArray.cc
rename to liboctave/array/uint64NDArray.cc
diff --git a/liboctave/uint64NDArray.h b/liboctave/array/uint64NDArray.h
rename from liboctave/uint64NDArray.h
rename to liboctave/array/uint64NDArray.h
diff --git a/liboctave/uint8NDArray.cc b/liboctave/array/uint8NDArray.cc
rename from liboctave/uint8NDArray.cc
rename to liboctave/array/uint8NDArray.cc
diff --git a/liboctave/uint8NDArray.h b/liboctave/array/uint8NDArray.h
rename from liboctave/uint8NDArray.h
rename to liboctave/array/uint8NDArray.h
diff --git a/libcruft/Makefile.am b/liboctave/cruft/Makefile.am
rename from libcruft/Makefile.am
rename to liboctave/cruft/Makefile.am
--- a/libcruft/Makefile.am
+++ b/liboctave/cruft/Makefile.am
@@ -1,9 +1,9 @@
-# Makefile for octave's libcruft directory
+# Makefile for Octave's liboctave/cruft directory
 #
 # Copyright (C) 1993-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
@@ -21,83 +21,50 @@
 include $(top_srcdir)/build-aux/common.mk
 
 AUTOMAKE_OPTIONS = subdir-objects
 
 ## Search local directories before those specified by the user.
 AM_CPPFLAGS = \
   -I$(top_builddir)/libgnu -I$(top_srcdir)/libgnu
 
-octlib_LTLIBRARIES = libcruft.la
+EXTRA_DIST = mkf77def.in
+
+noinst_LTLIBRARIES = libcruft.la
 
 libcruft_la_SOURCES =
 
 nodist_libcruft_la_SOURCES =
 
 libcruft_la_FFLAGS = $(F77_INTEGER_8_FLAG)
 
-libcruft_la_CPPFLAGS = \
-  @CRUFT_DLL_DEFS@ \
-  $(AM_CPPFLAGS)
-
-include link-deps.mk
-
-libcruft_la_LIBADD = \
-  libranlib.la \
-  $(top_builddir)/libgnu/libgnu.la \
-  $(LIBCRUFT_LINK_DEPS)
-
-# Increment these as needed and according to the rules in the libtool
-# manual:
-libcruft_current = 1
-libcruft_revision = 0
-libcruft_age = 0
-
-libcruft_version_info = $(libcruft_current):$(libcruft_revision):$(libcruft_age)
-
-libcruft_la_LDFLAGS = \
-  -version-info $(libcruft_version_info) \
-  $(NO_UNDEFINED_LDFLAG) \
-  @XTRA_CRUFT_SH_LDFLAGS@ \
-  -bindir $(bindir) \
-  $(LIBCRUFT_LINK_OPTS)
+libcruft_la_CPPFLAGS = @CRUFT_DLL_DEFS@ $(AM_CPPFLAGS)
 
 libcruft_la_DEPENDENCIES = cruft.def
 
-noinst_LTLIBRARIES = libranlib.la
-
-libranlib_la_SOURCES =
-
-libranlib_la_DEPENDENCIES = ranlib.def
-
 octinclude_HEADERS =
 
-EXTRA_DIST =
-
 include amos/module.mk
 include blas-xtra/module.mk
 include daspk/module.mk
 include dasrt/module.mk
 include dassl/module.mk
 include fftpack/module.mk
 include lapack-xtra/module.mk
 include misc/module.mk
 include odepack/module.mk
 include ordered-qz/module.mk
 include quadpack/module.mk
 include ranlib/module.mk
 include slatec-err/module.mk
 include slatec-fn/module.mk
 
+## Special rules for files which must be built before compilation
 cruft.def: $(libcruft_la_SOURCES) mkf77def
 	chmod a+rx mkf77def
 	./mkf77def $(srcdir) $(libcruft_la_SOURCES) > $@-t
 	mv $@-t $@
 
-ranlib.def: $(libranlib_la_SOURCES) mkf77def
-	chmod a+rx mkf77def
-	./mkf77def $(srcdir) $(libranlib_la_SOURCES) > $@-t
-	mv $@-t $@
+DISTCLEANFILES = \
+  cruft.def \
+  ranlib/ranlib.def \
+  $(nodist_libcruft_la_SOURCES)
 
-EXTRA_DIST += mkf77def.in
-
-DISTCLEANFILES = cruft.def ranlib.def $(nodist_libcruft_la_SOURCES)
-
diff --git a/libcruft/amos/README b/liboctave/cruft/amos/README
rename from libcruft/amos/README
rename to liboctave/cruft/amos/README
diff --git a/libcruft/amos/cacai.f b/liboctave/cruft/amos/cacai.f
rename from libcruft/amos/cacai.f
rename to liboctave/cruft/amos/cacai.f
diff --git a/libcruft/amos/cacon.f b/liboctave/cruft/amos/cacon.f
rename from libcruft/amos/cacon.f
rename to liboctave/cruft/amos/cacon.f
diff --git a/libcruft/amos/cairy.f b/liboctave/cruft/amos/cairy.f
rename from libcruft/amos/cairy.f
rename to liboctave/cruft/amos/cairy.f
diff --git a/libcruft/amos/casyi.f b/liboctave/cruft/amos/casyi.f
rename from libcruft/amos/casyi.f
rename to liboctave/cruft/amos/casyi.f
diff --git a/libcruft/amos/cbesh.f b/liboctave/cruft/amos/cbesh.f
rename from libcruft/amos/cbesh.f
rename to liboctave/cruft/amos/cbesh.f
diff --git a/libcruft/amos/cbesi.f b/liboctave/cruft/amos/cbesi.f
rename from libcruft/amos/cbesi.f
rename to liboctave/cruft/amos/cbesi.f
diff --git a/libcruft/amos/cbesj.f b/liboctave/cruft/amos/cbesj.f
rename from libcruft/amos/cbesj.f
rename to liboctave/cruft/amos/cbesj.f
diff --git a/libcruft/amos/cbesk.f b/liboctave/cruft/amos/cbesk.f
rename from libcruft/amos/cbesk.f
rename to liboctave/cruft/amos/cbesk.f
diff --git a/libcruft/amos/cbesy.f b/liboctave/cruft/amos/cbesy.f
rename from libcruft/amos/cbesy.f
rename to liboctave/cruft/amos/cbesy.f
diff --git a/libcruft/amos/cbinu.f b/liboctave/cruft/amos/cbinu.f
rename from libcruft/amos/cbinu.f
rename to liboctave/cruft/amos/cbinu.f
diff --git a/libcruft/amos/cbiry.f b/liboctave/cruft/amos/cbiry.f
rename from libcruft/amos/cbiry.f
rename to liboctave/cruft/amos/cbiry.f
diff --git a/libcruft/amos/cbknu.f b/liboctave/cruft/amos/cbknu.f
rename from libcruft/amos/cbknu.f
rename to liboctave/cruft/amos/cbknu.f
diff --git a/libcruft/amos/cbuni.f b/liboctave/cruft/amos/cbuni.f
rename from libcruft/amos/cbuni.f
rename to liboctave/cruft/amos/cbuni.f
diff --git a/libcruft/amos/cbunk.f b/liboctave/cruft/amos/cbunk.f
rename from libcruft/amos/cbunk.f
rename to liboctave/cruft/amos/cbunk.f
diff --git a/libcruft/amos/ckscl.f b/liboctave/cruft/amos/ckscl.f
rename from libcruft/amos/ckscl.f
rename to liboctave/cruft/amos/ckscl.f
diff --git a/libcruft/amos/cmlri.f b/liboctave/cruft/amos/cmlri.f
rename from libcruft/amos/cmlri.f
rename to liboctave/cruft/amos/cmlri.f
diff --git a/libcruft/amos/crati.f b/liboctave/cruft/amos/crati.f
rename from libcruft/amos/crati.f
rename to liboctave/cruft/amos/crati.f
diff --git a/libcruft/amos/cs1s2.f b/liboctave/cruft/amos/cs1s2.f
rename from libcruft/amos/cs1s2.f
rename to liboctave/cruft/amos/cs1s2.f
diff --git a/libcruft/amos/cseri.f b/liboctave/cruft/amos/cseri.f
rename from libcruft/amos/cseri.f
rename to liboctave/cruft/amos/cseri.f
diff --git a/libcruft/amos/cshch.f b/liboctave/cruft/amos/cshch.f
rename from libcruft/amos/cshch.f
rename to liboctave/cruft/amos/cshch.f
diff --git a/libcruft/amos/cuchk.f b/liboctave/cruft/amos/cuchk.f
rename from libcruft/amos/cuchk.f
rename to liboctave/cruft/amos/cuchk.f
diff --git a/libcruft/amos/cunhj.f b/liboctave/cruft/amos/cunhj.f
rename from libcruft/amos/cunhj.f
rename to liboctave/cruft/amos/cunhj.f
diff --git a/libcruft/amos/cuni1.f b/liboctave/cruft/amos/cuni1.f
rename from libcruft/amos/cuni1.f
rename to liboctave/cruft/amos/cuni1.f
diff --git a/libcruft/amos/cuni2.f b/liboctave/cruft/amos/cuni2.f
rename from libcruft/amos/cuni2.f
rename to liboctave/cruft/amos/cuni2.f
diff --git a/libcruft/amos/cunik.f b/liboctave/cruft/amos/cunik.f
rename from libcruft/amos/cunik.f
rename to liboctave/cruft/amos/cunik.f
diff --git a/libcruft/amos/cunk1.f b/liboctave/cruft/amos/cunk1.f
rename from libcruft/amos/cunk1.f
rename to liboctave/cruft/amos/cunk1.f
diff --git a/libcruft/amos/cunk2.f b/liboctave/cruft/amos/cunk2.f
rename from libcruft/amos/cunk2.f
rename to liboctave/cruft/amos/cunk2.f
diff --git a/libcruft/amos/cuoik.f b/liboctave/cruft/amos/cuoik.f
rename from libcruft/amos/cuoik.f
rename to liboctave/cruft/amos/cuoik.f
diff --git a/libcruft/amos/cwrsk.f b/liboctave/cruft/amos/cwrsk.f
rename from libcruft/amos/cwrsk.f
rename to liboctave/cruft/amos/cwrsk.f
diff --git a/libcruft/amos/dgamln.f b/liboctave/cruft/amos/dgamln.f
rename from libcruft/amos/dgamln.f
rename to liboctave/cruft/amos/dgamln.f
diff --git a/libcruft/amos/gamln.f b/liboctave/cruft/amos/gamln.f
rename from libcruft/amos/gamln.f
rename to liboctave/cruft/amos/gamln.f
diff --git a/libcruft/amos/module.mk b/liboctave/cruft/amos/module.mk
rename from libcruft/amos/module.mk
rename to liboctave/cruft/amos/module.mk
diff --git a/libcruft/amos/xzabs.f b/liboctave/cruft/amos/xzabs.f
rename from libcruft/amos/xzabs.f
rename to liboctave/cruft/amos/xzabs.f
diff --git a/libcruft/amos/xzexp.f b/liboctave/cruft/amos/xzexp.f
rename from libcruft/amos/xzexp.f
rename to liboctave/cruft/amos/xzexp.f
diff --git a/libcruft/amos/xzlog.f b/liboctave/cruft/amos/xzlog.f
rename from libcruft/amos/xzlog.f
rename to liboctave/cruft/amos/xzlog.f
diff --git a/libcruft/amos/xzsqrt.f b/liboctave/cruft/amos/xzsqrt.f
rename from libcruft/amos/xzsqrt.f
rename to liboctave/cruft/amos/xzsqrt.f
diff --git a/libcruft/amos/zacai.f b/liboctave/cruft/amos/zacai.f
rename from libcruft/amos/zacai.f
rename to liboctave/cruft/amos/zacai.f
diff --git a/libcruft/amos/zacon.f b/liboctave/cruft/amos/zacon.f
rename from libcruft/amos/zacon.f
rename to liboctave/cruft/amos/zacon.f
diff --git a/libcruft/amos/zairy.f b/liboctave/cruft/amos/zairy.f
rename from libcruft/amos/zairy.f
rename to liboctave/cruft/amos/zairy.f
diff --git a/libcruft/amos/zasyi.f b/liboctave/cruft/amos/zasyi.f
rename from libcruft/amos/zasyi.f
rename to liboctave/cruft/amos/zasyi.f
diff --git a/libcruft/amos/zbesh.f b/liboctave/cruft/amos/zbesh.f
rename from libcruft/amos/zbesh.f
rename to liboctave/cruft/amos/zbesh.f
diff --git a/libcruft/amos/zbesi.f b/liboctave/cruft/amos/zbesi.f
rename from libcruft/amos/zbesi.f
rename to liboctave/cruft/amos/zbesi.f
diff --git a/libcruft/amos/zbesj.f b/liboctave/cruft/amos/zbesj.f
rename from libcruft/amos/zbesj.f
rename to liboctave/cruft/amos/zbesj.f
diff --git a/libcruft/amos/zbesk.f b/liboctave/cruft/amos/zbesk.f
rename from libcruft/amos/zbesk.f
rename to liboctave/cruft/amos/zbesk.f
diff --git a/libcruft/amos/zbesy.f b/liboctave/cruft/amos/zbesy.f
rename from libcruft/amos/zbesy.f
rename to liboctave/cruft/amos/zbesy.f
diff --git a/libcruft/amos/zbinu.f b/liboctave/cruft/amos/zbinu.f
rename from libcruft/amos/zbinu.f
rename to liboctave/cruft/amos/zbinu.f
diff --git a/libcruft/amos/zbiry.f b/liboctave/cruft/amos/zbiry.f
rename from libcruft/amos/zbiry.f
rename to liboctave/cruft/amos/zbiry.f
diff --git a/libcruft/amos/zbknu.f b/liboctave/cruft/amos/zbknu.f
rename from libcruft/amos/zbknu.f
rename to liboctave/cruft/amos/zbknu.f
diff --git a/libcruft/amos/zbuni.f b/liboctave/cruft/amos/zbuni.f
rename from libcruft/amos/zbuni.f
rename to liboctave/cruft/amos/zbuni.f
diff --git a/libcruft/amos/zbunk.f b/liboctave/cruft/amos/zbunk.f
rename from libcruft/amos/zbunk.f
rename to liboctave/cruft/amos/zbunk.f
diff --git a/libcruft/amos/zdiv.f b/liboctave/cruft/amos/zdiv.f
rename from libcruft/amos/zdiv.f
rename to liboctave/cruft/amos/zdiv.f
diff --git a/libcruft/amos/zkscl.f b/liboctave/cruft/amos/zkscl.f
rename from libcruft/amos/zkscl.f
rename to liboctave/cruft/amos/zkscl.f
diff --git a/libcruft/amos/zmlri.f b/liboctave/cruft/amos/zmlri.f
rename from libcruft/amos/zmlri.f
rename to liboctave/cruft/amos/zmlri.f
diff --git a/libcruft/amos/zmlt.f b/liboctave/cruft/amos/zmlt.f
rename from libcruft/amos/zmlt.f
rename to liboctave/cruft/amos/zmlt.f
diff --git a/libcruft/amos/zrati.f b/liboctave/cruft/amos/zrati.f
rename from libcruft/amos/zrati.f
rename to liboctave/cruft/amos/zrati.f
diff --git a/libcruft/amos/zs1s2.f b/liboctave/cruft/amos/zs1s2.f
rename from libcruft/amos/zs1s2.f
rename to liboctave/cruft/amos/zs1s2.f
diff --git a/libcruft/amos/zseri.f b/liboctave/cruft/amos/zseri.f
rename from libcruft/amos/zseri.f
rename to liboctave/cruft/amos/zseri.f
diff --git a/libcruft/amos/zshch.f b/liboctave/cruft/amos/zshch.f
rename from libcruft/amos/zshch.f
rename to liboctave/cruft/amos/zshch.f
diff --git a/libcruft/amos/zuchk.f b/liboctave/cruft/amos/zuchk.f
rename from libcruft/amos/zuchk.f
rename to liboctave/cruft/amos/zuchk.f
diff --git a/libcruft/amos/zunhj.f b/liboctave/cruft/amos/zunhj.f
rename from libcruft/amos/zunhj.f
rename to liboctave/cruft/amos/zunhj.f
diff --git a/libcruft/amos/zuni1.f b/liboctave/cruft/amos/zuni1.f
rename from libcruft/amos/zuni1.f
rename to liboctave/cruft/amos/zuni1.f
diff --git a/libcruft/amos/zuni2.f b/liboctave/cruft/amos/zuni2.f
rename from libcruft/amos/zuni2.f
rename to liboctave/cruft/amos/zuni2.f
diff --git a/libcruft/amos/zunik.f b/liboctave/cruft/amos/zunik.f
rename from libcruft/amos/zunik.f
rename to liboctave/cruft/amos/zunik.f
diff --git a/libcruft/amos/zunk1.f b/liboctave/cruft/amos/zunk1.f
rename from libcruft/amos/zunk1.f
rename to liboctave/cruft/amos/zunk1.f
diff --git a/libcruft/amos/zunk2.f b/liboctave/cruft/amos/zunk2.f
rename from libcruft/amos/zunk2.f
rename to liboctave/cruft/amos/zunk2.f
diff --git a/libcruft/amos/zuoik.f b/liboctave/cruft/amos/zuoik.f
rename from libcruft/amos/zuoik.f
rename to liboctave/cruft/amos/zuoik.f
diff --git a/libcruft/amos/zwrsk.f b/liboctave/cruft/amos/zwrsk.f
rename from libcruft/amos/zwrsk.f
rename to liboctave/cruft/amos/zwrsk.f
diff --git a/libcruft/blas-xtra/cconv2.f b/liboctave/cruft/blas-xtra/cconv2.f
rename from libcruft/blas-xtra/cconv2.f
rename to liboctave/cruft/blas-xtra/cconv2.f
diff --git a/libcruft/blas-xtra/cdotc3.f b/liboctave/cruft/blas-xtra/cdotc3.f
rename from libcruft/blas-xtra/cdotc3.f
rename to liboctave/cruft/blas-xtra/cdotc3.f
diff --git a/libcruft/blas-xtra/cmatm3.f b/liboctave/cruft/blas-xtra/cmatm3.f
rename from libcruft/blas-xtra/cmatm3.f
rename to liboctave/cruft/blas-xtra/cmatm3.f
diff --git a/libcruft/blas-xtra/csconv2.f b/liboctave/cruft/blas-xtra/csconv2.f
rename from libcruft/blas-xtra/csconv2.f
rename to liboctave/cruft/blas-xtra/csconv2.f
diff --git a/libcruft/blas-xtra/dconv2.f b/liboctave/cruft/blas-xtra/dconv2.f
rename from libcruft/blas-xtra/dconv2.f
rename to liboctave/cruft/blas-xtra/dconv2.f
diff --git a/libcruft/blas-xtra/ddot3.f b/liboctave/cruft/blas-xtra/ddot3.f
rename from libcruft/blas-xtra/ddot3.f
rename to liboctave/cruft/blas-xtra/ddot3.f
diff --git a/libcruft/blas-xtra/dmatm3.f b/liboctave/cruft/blas-xtra/dmatm3.f
rename from libcruft/blas-xtra/dmatm3.f
rename to liboctave/cruft/blas-xtra/dmatm3.f
diff --git a/libcruft/blas-xtra/module.mk b/liboctave/cruft/blas-xtra/module.mk
rename from libcruft/blas-xtra/module.mk
rename to liboctave/cruft/blas-xtra/module.mk
diff --git a/libcruft/blas-xtra/sconv2.f b/liboctave/cruft/blas-xtra/sconv2.f
rename from libcruft/blas-xtra/sconv2.f
rename to liboctave/cruft/blas-xtra/sconv2.f
diff --git a/libcruft/blas-xtra/sdot3.f b/liboctave/cruft/blas-xtra/sdot3.f
rename from libcruft/blas-xtra/sdot3.f
rename to liboctave/cruft/blas-xtra/sdot3.f
diff --git a/libcruft/blas-xtra/smatm3.f b/liboctave/cruft/blas-xtra/smatm3.f
rename from libcruft/blas-xtra/smatm3.f
rename to liboctave/cruft/blas-xtra/smatm3.f
diff --git a/libcruft/blas-xtra/xcdotc.f b/liboctave/cruft/blas-xtra/xcdotc.f
rename from libcruft/blas-xtra/xcdotc.f
rename to liboctave/cruft/blas-xtra/xcdotc.f
diff --git a/libcruft/blas-xtra/xcdotu.f b/liboctave/cruft/blas-xtra/xcdotu.f
rename from libcruft/blas-xtra/xcdotu.f
rename to liboctave/cruft/blas-xtra/xcdotu.f
diff --git a/libcruft/blas-xtra/xddot.f b/liboctave/cruft/blas-xtra/xddot.f
rename from libcruft/blas-xtra/xddot.f
rename to liboctave/cruft/blas-xtra/xddot.f
diff --git a/libcruft/blas-xtra/xdnrm2.f b/liboctave/cruft/blas-xtra/xdnrm2.f
rename from libcruft/blas-xtra/xdnrm2.f
rename to liboctave/cruft/blas-xtra/xdnrm2.f
diff --git a/libcruft/blas-xtra/xdznrm2.f b/liboctave/cruft/blas-xtra/xdznrm2.f
rename from libcruft/blas-xtra/xdznrm2.f
rename to liboctave/cruft/blas-xtra/xdznrm2.f
diff --git a/libcruft/blas-xtra/xerbla.f b/liboctave/cruft/blas-xtra/xerbla.f
rename from libcruft/blas-xtra/xerbla.f
rename to liboctave/cruft/blas-xtra/xerbla.f
diff --git a/libcruft/blas-xtra/xscnrm2.f b/liboctave/cruft/blas-xtra/xscnrm2.f
rename from libcruft/blas-xtra/xscnrm2.f
rename to liboctave/cruft/blas-xtra/xscnrm2.f
diff --git a/libcruft/blas-xtra/xsdot.f b/liboctave/cruft/blas-xtra/xsdot.f
rename from libcruft/blas-xtra/xsdot.f
rename to liboctave/cruft/blas-xtra/xsdot.f
diff --git a/libcruft/blas-xtra/xsnrm2.f b/liboctave/cruft/blas-xtra/xsnrm2.f
rename from libcruft/blas-xtra/xsnrm2.f
rename to liboctave/cruft/blas-xtra/xsnrm2.f
diff --git a/libcruft/blas-xtra/xzdotc.f b/liboctave/cruft/blas-xtra/xzdotc.f
rename from libcruft/blas-xtra/xzdotc.f
rename to liboctave/cruft/blas-xtra/xzdotc.f
diff --git a/libcruft/blas-xtra/xzdotu.f b/liboctave/cruft/blas-xtra/xzdotu.f
rename from libcruft/blas-xtra/xzdotu.f
rename to liboctave/cruft/blas-xtra/xzdotu.f
diff --git a/libcruft/blas-xtra/zconv2.f b/liboctave/cruft/blas-xtra/zconv2.f
rename from libcruft/blas-xtra/zconv2.f
rename to liboctave/cruft/blas-xtra/zconv2.f
diff --git a/libcruft/blas-xtra/zdconv2.f b/liboctave/cruft/blas-xtra/zdconv2.f
rename from libcruft/blas-xtra/zdconv2.f
rename to liboctave/cruft/blas-xtra/zdconv2.f
diff --git a/libcruft/blas-xtra/zdotc3.f b/liboctave/cruft/blas-xtra/zdotc3.f
rename from libcruft/blas-xtra/zdotc3.f
rename to liboctave/cruft/blas-xtra/zdotc3.f
diff --git a/libcruft/blas-xtra/zmatm3.f b/liboctave/cruft/blas-xtra/zmatm3.f
rename from libcruft/blas-xtra/zmatm3.f
rename to liboctave/cruft/blas-xtra/zmatm3.f
diff --git a/libcruft/daspk/datv.f b/liboctave/cruft/daspk/datv.f
rename from libcruft/daspk/datv.f
rename to liboctave/cruft/daspk/datv.f
diff --git a/libcruft/daspk/dcnst0.f b/liboctave/cruft/daspk/dcnst0.f
rename from libcruft/daspk/dcnst0.f
rename to liboctave/cruft/daspk/dcnst0.f
diff --git a/libcruft/daspk/dcnstr.f b/liboctave/cruft/daspk/dcnstr.f
rename from libcruft/daspk/dcnstr.f
rename to liboctave/cruft/daspk/dcnstr.f
diff --git a/libcruft/daspk/ddasic.f b/liboctave/cruft/daspk/ddasic.f
rename from libcruft/daspk/ddasic.f
rename to liboctave/cruft/daspk/ddasic.f
diff --git a/libcruft/daspk/ddasid.f b/liboctave/cruft/daspk/ddasid.f
rename from libcruft/daspk/ddasid.f
rename to liboctave/cruft/daspk/ddasid.f
diff --git a/libcruft/daspk/ddasik.f b/liboctave/cruft/daspk/ddasik.f
rename from libcruft/daspk/ddasik.f
rename to liboctave/cruft/daspk/ddasik.f
diff --git a/libcruft/daspk/ddaspk.f b/liboctave/cruft/daspk/ddaspk.f
rename from libcruft/daspk/ddaspk.f
rename to liboctave/cruft/daspk/ddaspk.f
diff --git a/libcruft/daspk/ddstp.f b/liboctave/cruft/daspk/ddstp.f
rename from libcruft/daspk/ddstp.f
rename to liboctave/cruft/daspk/ddstp.f
diff --git a/libcruft/daspk/ddwnrm.f b/liboctave/cruft/daspk/ddwnrm.f
rename from libcruft/daspk/ddwnrm.f
rename to liboctave/cruft/daspk/ddwnrm.f
diff --git a/libcruft/daspk/dfnrmd.f b/liboctave/cruft/daspk/dfnrmd.f
rename from libcruft/daspk/dfnrmd.f
rename to liboctave/cruft/daspk/dfnrmd.f
diff --git a/libcruft/daspk/dfnrmk.f b/liboctave/cruft/daspk/dfnrmk.f
rename from libcruft/daspk/dfnrmk.f
rename to liboctave/cruft/daspk/dfnrmk.f
diff --git a/libcruft/daspk/dhels.f b/liboctave/cruft/daspk/dhels.f
rename from libcruft/daspk/dhels.f
rename to liboctave/cruft/daspk/dhels.f
diff --git a/libcruft/daspk/dheqr.f b/liboctave/cruft/daspk/dheqr.f
rename from libcruft/daspk/dheqr.f
rename to liboctave/cruft/daspk/dheqr.f
diff --git a/libcruft/daspk/dinvwt.f b/liboctave/cruft/daspk/dinvwt.f
rename from libcruft/daspk/dinvwt.f
rename to liboctave/cruft/daspk/dinvwt.f
diff --git a/libcruft/daspk/dlinsd.f b/liboctave/cruft/daspk/dlinsd.f
rename from libcruft/daspk/dlinsd.f
rename to liboctave/cruft/daspk/dlinsd.f
diff --git a/libcruft/daspk/dlinsk.f b/liboctave/cruft/daspk/dlinsk.f
rename from libcruft/daspk/dlinsk.f
rename to liboctave/cruft/daspk/dlinsk.f
diff --git a/libcruft/daspk/dmatd.f b/liboctave/cruft/daspk/dmatd.f
rename from libcruft/daspk/dmatd.f
rename to liboctave/cruft/daspk/dmatd.f
diff --git a/libcruft/daspk/dnedd.f b/liboctave/cruft/daspk/dnedd.f
rename from libcruft/daspk/dnedd.f
rename to liboctave/cruft/daspk/dnedd.f
diff --git a/libcruft/daspk/dnedk.f b/liboctave/cruft/daspk/dnedk.f
rename from libcruft/daspk/dnedk.f
rename to liboctave/cruft/daspk/dnedk.f
diff --git a/libcruft/daspk/dnsd.f b/liboctave/cruft/daspk/dnsd.f
rename from libcruft/daspk/dnsd.f
rename to liboctave/cruft/daspk/dnsd.f
diff --git a/libcruft/daspk/dnsid.f b/liboctave/cruft/daspk/dnsid.f
rename from libcruft/daspk/dnsid.f
rename to liboctave/cruft/daspk/dnsid.f
diff --git a/libcruft/daspk/dnsik.f b/liboctave/cruft/daspk/dnsik.f
rename from libcruft/daspk/dnsik.f
rename to liboctave/cruft/daspk/dnsik.f
diff --git a/libcruft/daspk/dnsk.f b/liboctave/cruft/daspk/dnsk.f
rename from libcruft/daspk/dnsk.f
rename to liboctave/cruft/daspk/dnsk.f
diff --git a/libcruft/daspk/dorth.f b/liboctave/cruft/daspk/dorth.f
rename from libcruft/daspk/dorth.f
rename to liboctave/cruft/daspk/dorth.f
diff --git a/libcruft/daspk/dslvd.f b/liboctave/cruft/daspk/dslvd.f
rename from libcruft/daspk/dslvd.f
rename to liboctave/cruft/daspk/dslvd.f
diff --git a/libcruft/daspk/dslvk.f b/liboctave/cruft/daspk/dslvk.f
rename from libcruft/daspk/dslvk.f
rename to liboctave/cruft/daspk/dslvk.f
diff --git a/libcruft/daspk/dspigm.f b/liboctave/cruft/daspk/dspigm.f
rename from libcruft/daspk/dspigm.f
rename to liboctave/cruft/daspk/dspigm.f
diff --git a/libcruft/daspk/dyypnw.f b/liboctave/cruft/daspk/dyypnw.f
rename from libcruft/daspk/dyypnw.f
rename to liboctave/cruft/daspk/dyypnw.f
diff --git a/libcruft/daspk/module.mk b/liboctave/cruft/daspk/module.mk
rename from libcruft/daspk/module.mk
rename to liboctave/cruft/daspk/module.mk
diff --git a/libcruft/dasrt/ddasrt.f b/liboctave/cruft/dasrt/ddasrt.f
rename from libcruft/dasrt/ddasrt.f
rename to liboctave/cruft/dasrt/ddasrt.f
diff --git a/libcruft/dasrt/drchek.f b/liboctave/cruft/dasrt/drchek.f
rename from libcruft/dasrt/drchek.f
rename to liboctave/cruft/dasrt/drchek.f
diff --git a/libcruft/dasrt/droots.f b/liboctave/cruft/dasrt/droots.f
rename from libcruft/dasrt/droots.f
rename to liboctave/cruft/dasrt/droots.f
diff --git a/libcruft/dasrt/module.mk b/liboctave/cruft/dasrt/module.mk
rename from libcruft/dasrt/module.mk
rename to liboctave/cruft/dasrt/module.mk
diff --git a/libcruft/dassl/ddaini.f b/liboctave/cruft/dassl/ddaini.f
rename from libcruft/dassl/ddaini.f
rename to liboctave/cruft/dassl/ddaini.f
diff --git a/libcruft/dassl/ddajac.f b/liboctave/cruft/dassl/ddajac.f
rename from libcruft/dassl/ddajac.f
rename to liboctave/cruft/dassl/ddajac.f
diff --git a/libcruft/dassl/ddanrm.f b/liboctave/cruft/dassl/ddanrm.f
rename from libcruft/dassl/ddanrm.f
rename to liboctave/cruft/dassl/ddanrm.f
diff --git a/libcruft/dassl/ddaslv.f b/liboctave/cruft/dassl/ddaslv.f
rename from libcruft/dassl/ddaslv.f
rename to liboctave/cruft/dassl/ddaslv.f
diff --git a/libcruft/dassl/ddassl.f b/liboctave/cruft/dassl/ddassl.f
rename from libcruft/dassl/ddassl.f
rename to liboctave/cruft/dassl/ddassl.f
diff --git a/libcruft/dassl/ddastp.f b/liboctave/cruft/dassl/ddastp.f
rename from libcruft/dassl/ddastp.f
rename to liboctave/cruft/dassl/ddastp.f
diff --git a/libcruft/dassl/ddatrp.f b/liboctave/cruft/dassl/ddatrp.f
rename from libcruft/dassl/ddatrp.f
rename to liboctave/cruft/dassl/ddatrp.f
diff --git a/libcruft/dassl/ddawts.f b/liboctave/cruft/dassl/ddawts.f
rename from libcruft/dassl/ddawts.f
rename to liboctave/cruft/dassl/ddawts.f
diff --git a/libcruft/dassl/module.mk b/liboctave/cruft/dassl/module.mk
rename from libcruft/dassl/module.mk
rename to liboctave/cruft/dassl/module.mk
diff --git a/libcruft/fftpack/cfftb.f b/liboctave/cruft/fftpack/cfftb.f
rename from libcruft/fftpack/cfftb.f
rename to liboctave/cruft/fftpack/cfftb.f
diff --git a/libcruft/fftpack/cfftb1.f b/liboctave/cruft/fftpack/cfftb1.f
rename from libcruft/fftpack/cfftb1.f
rename to liboctave/cruft/fftpack/cfftb1.f
diff --git a/libcruft/fftpack/cfftf.f b/liboctave/cruft/fftpack/cfftf.f
rename from libcruft/fftpack/cfftf.f
rename to liboctave/cruft/fftpack/cfftf.f
diff --git a/libcruft/fftpack/cfftf1.f b/liboctave/cruft/fftpack/cfftf1.f
rename from libcruft/fftpack/cfftf1.f
rename to liboctave/cruft/fftpack/cfftf1.f
diff --git a/libcruft/fftpack/cffti.f b/liboctave/cruft/fftpack/cffti.f
rename from libcruft/fftpack/cffti.f
rename to liboctave/cruft/fftpack/cffti.f
diff --git a/libcruft/fftpack/cffti1.f b/liboctave/cruft/fftpack/cffti1.f
rename from libcruft/fftpack/cffti1.f
rename to liboctave/cruft/fftpack/cffti1.f
diff --git a/libcruft/fftpack/fftpack.doc b/liboctave/cruft/fftpack/fftpack.doc
rename from libcruft/fftpack/fftpack.doc
rename to liboctave/cruft/fftpack/fftpack.doc
diff --git a/libcruft/fftpack/module.mk b/liboctave/cruft/fftpack/module.mk
rename from libcruft/fftpack/module.mk
rename to liboctave/cruft/fftpack/module.mk
diff --git a/libcruft/fftpack/passb.f b/liboctave/cruft/fftpack/passb.f
rename from libcruft/fftpack/passb.f
rename to liboctave/cruft/fftpack/passb.f
diff --git a/libcruft/fftpack/passb2.f b/liboctave/cruft/fftpack/passb2.f
rename from libcruft/fftpack/passb2.f
rename to liboctave/cruft/fftpack/passb2.f
diff --git a/libcruft/fftpack/passb3.f b/liboctave/cruft/fftpack/passb3.f
rename from libcruft/fftpack/passb3.f
rename to liboctave/cruft/fftpack/passb3.f
diff --git a/libcruft/fftpack/passb4.f b/liboctave/cruft/fftpack/passb4.f
rename from libcruft/fftpack/passb4.f
rename to liboctave/cruft/fftpack/passb4.f
diff --git a/libcruft/fftpack/passb5.f b/liboctave/cruft/fftpack/passb5.f
rename from libcruft/fftpack/passb5.f
rename to liboctave/cruft/fftpack/passb5.f
diff --git a/libcruft/fftpack/passf.f b/liboctave/cruft/fftpack/passf.f
rename from libcruft/fftpack/passf.f
rename to liboctave/cruft/fftpack/passf.f
diff --git a/libcruft/fftpack/passf2.f b/liboctave/cruft/fftpack/passf2.f
rename from libcruft/fftpack/passf2.f
rename to liboctave/cruft/fftpack/passf2.f
diff --git a/libcruft/fftpack/passf3.f b/liboctave/cruft/fftpack/passf3.f
rename from libcruft/fftpack/passf3.f
rename to liboctave/cruft/fftpack/passf3.f
diff --git a/libcruft/fftpack/passf4.f b/liboctave/cruft/fftpack/passf4.f
rename from libcruft/fftpack/passf4.f
rename to liboctave/cruft/fftpack/passf4.f
diff --git a/libcruft/fftpack/passf5.f b/liboctave/cruft/fftpack/passf5.f
rename from libcruft/fftpack/passf5.f
rename to liboctave/cruft/fftpack/passf5.f
diff --git a/libcruft/fftpack/zfftb.f b/liboctave/cruft/fftpack/zfftb.f
rename from libcruft/fftpack/zfftb.f
rename to liboctave/cruft/fftpack/zfftb.f
diff --git a/libcruft/fftpack/zfftb1.f b/liboctave/cruft/fftpack/zfftb1.f
rename from libcruft/fftpack/zfftb1.f
rename to liboctave/cruft/fftpack/zfftb1.f
diff --git a/libcruft/fftpack/zfftf.f b/liboctave/cruft/fftpack/zfftf.f
rename from libcruft/fftpack/zfftf.f
rename to liboctave/cruft/fftpack/zfftf.f
diff --git a/libcruft/fftpack/zfftf1.f b/liboctave/cruft/fftpack/zfftf1.f
rename from libcruft/fftpack/zfftf1.f
rename to liboctave/cruft/fftpack/zfftf1.f
diff --git a/libcruft/fftpack/zffti.f b/liboctave/cruft/fftpack/zffti.f
rename from libcruft/fftpack/zffti.f
rename to liboctave/cruft/fftpack/zffti.f
diff --git a/libcruft/fftpack/zffti1.f b/liboctave/cruft/fftpack/zffti1.f
rename from libcruft/fftpack/zffti1.f
rename to liboctave/cruft/fftpack/zffti1.f
diff --git a/libcruft/fftpack/zpassb.f b/liboctave/cruft/fftpack/zpassb.f
rename from libcruft/fftpack/zpassb.f
rename to liboctave/cruft/fftpack/zpassb.f
diff --git a/libcruft/fftpack/zpassb2.f b/liboctave/cruft/fftpack/zpassb2.f
rename from libcruft/fftpack/zpassb2.f
rename to liboctave/cruft/fftpack/zpassb2.f
diff --git a/libcruft/fftpack/zpassb3.f b/liboctave/cruft/fftpack/zpassb3.f
rename from libcruft/fftpack/zpassb3.f
rename to liboctave/cruft/fftpack/zpassb3.f
diff --git a/libcruft/fftpack/zpassb4.f b/liboctave/cruft/fftpack/zpassb4.f
rename from libcruft/fftpack/zpassb4.f
rename to liboctave/cruft/fftpack/zpassb4.f
diff --git a/libcruft/fftpack/zpassb5.f b/liboctave/cruft/fftpack/zpassb5.f
rename from libcruft/fftpack/zpassb5.f
rename to liboctave/cruft/fftpack/zpassb5.f
diff --git a/libcruft/fftpack/zpassf.f b/liboctave/cruft/fftpack/zpassf.f
rename from libcruft/fftpack/zpassf.f
rename to liboctave/cruft/fftpack/zpassf.f
diff --git a/libcruft/fftpack/zpassf2.f b/liboctave/cruft/fftpack/zpassf2.f
rename from libcruft/fftpack/zpassf2.f
rename to liboctave/cruft/fftpack/zpassf2.f
diff --git a/libcruft/fftpack/zpassf3.f b/liboctave/cruft/fftpack/zpassf3.f
rename from libcruft/fftpack/zpassf3.f
rename to liboctave/cruft/fftpack/zpassf3.f
diff --git a/libcruft/fftpack/zpassf4.f b/liboctave/cruft/fftpack/zpassf4.f
rename from libcruft/fftpack/zpassf4.f
rename to liboctave/cruft/fftpack/zpassf4.f
diff --git a/libcruft/fftpack/zpassf5.f b/liboctave/cruft/fftpack/zpassf5.f
rename from libcruft/fftpack/zpassf5.f
rename to liboctave/cruft/fftpack/zpassf5.f
diff --git a/libcruft/lapack-xtra/crsf2csf.f b/liboctave/cruft/lapack-xtra/crsf2csf.f
rename from libcruft/lapack-xtra/crsf2csf.f
rename to liboctave/cruft/lapack-xtra/crsf2csf.f
diff --git a/libcruft/lapack-xtra/module.mk b/liboctave/cruft/lapack-xtra/module.mk
rename from libcruft/lapack-xtra/module.mk
rename to liboctave/cruft/lapack-xtra/module.mk
diff --git a/libcruft/lapack-xtra/xclange.f b/liboctave/cruft/lapack-xtra/xclange.f
rename from libcruft/lapack-xtra/xclange.f
rename to liboctave/cruft/lapack-xtra/xclange.f
diff --git a/libcruft/lapack-xtra/xdlamch.f b/liboctave/cruft/lapack-xtra/xdlamch.f
rename from libcruft/lapack-xtra/xdlamch.f
rename to liboctave/cruft/lapack-xtra/xdlamch.f
diff --git a/libcruft/lapack-xtra/xdlange.f b/liboctave/cruft/lapack-xtra/xdlange.f
rename from libcruft/lapack-xtra/xdlange.f
rename to liboctave/cruft/lapack-xtra/xdlange.f
diff --git a/libcruft/lapack-xtra/xilaenv.f b/liboctave/cruft/lapack-xtra/xilaenv.f
rename from libcruft/lapack-xtra/xilaenv.f
rename to liboctave/cruft/lapack-xtra/xilaenv.f
diff --git a/libcruft/lapack-xtra/xslamch.f b/liboctave/cruft/lapack-xtra/xslamch.f
rename from libcruft/lapack-xtra/xslamch.f
rename to liboctave/cruft/lapack-xtra/xslamch.f
diff --git a/libcruft/lapack-xtra/xslange.f b/liboctave/cruft/lapack-xtra/xslange.f
rename from libcruft/lapack-xtra/xslange.f
rename to liboctave/cruft/lapack-xtra/xslange.f
diff --git a/libcruft/lapack-xtra/xzlange.f b/liboctave/cruft/lapack-xtra/xzlange.f
rename from libcruft/lapack-xtra/xzlange.f
rename to liboctave/cruft/lapack-xtra/xzlange.f
diff --git a/libcruft/lapack-xtra/zrsf2csf.f b/liboctave/cruft/lapack-xtra/zrsf2csf.f
rename from libcruft/lapack-xtra/zrsf2csf.f
rename to liboctave/cruft/lapack-xtra/zrsf2csf.f
diff --git a/libcruft/misc/blaswrap.c b/liboctave/cruft/misc/blaswrap.c
rename from libcruft/misc/blaswrap.c
rename to liboctave/cruft/misc/blaswrap.c
diff --git a/libcruft/misc/cquit.c b/liboctave/cruft/misc/cquit.c
rename from libcruft/misc/cquit.c
rename to liboctave/cruft/misc/cquit.c
diff --git a/libcruft/misc/d1mach-tst.for b/liboctave/cruft/misc/d1mach-tst.for
rename from libcruft/misc/d1mach-tst.for
rename to liboctave/cruft/misc/d1mach-tst.for
diff --git a/libcruft/misc/d1mach.f b/liboctave/cruft/misc/d1mach.f
rename from libcruft/misc/d1mach.f
rename to liboctave/cruft/misc/d1mach.f
diff --git a/libcruft/misc/f77-extern.cc b/liboctave/cruft/misc/f77-extern.cc
rename from libcruft/misc/f77-extern.cc
rename to liboctave/cruft/misc/f77-extern.cc
diff --git a/libcruft/misc/f77-fcn.c b/liboctave/cruft/misc/f77-fcn.c
rename from libcruft/misc/f77-fcn.c
rename to liboctave/cruft/misc/f77-fcn.c
diff --git a/libcruft/misc/f77-fcn.h b/liboctave/cruft/misc/f77-fcn.h
rename from libcruft/misc/f77-fcn.h
rename to liboctave/cruft/misc/f77-fcn.h
diff --git a/libcruft/misc/i1mach.f b/liboctave/cruft/misc/i1mach.f
rename from libcruft/misc/i1mach.f
rename to liboctave/cruft/misc/i1mach.f
diff --git a/libcruft/misc/lo-error.c b/liboctave/cruft/misc/lo-error.c
rename from libcruft/misc/lo-error.c
rename to liboctave/cruft/misc/lo-error.c
diff --git a/libcruft/misc/lo-error.h b/liboctave/cruft/misc/lo-error.h
rename from libcruft/misc/lo-error.h
rename to liboctave/cruft/misc/lo-error.h
diff --git a/libcruft/misc/module.mk b/liboctave/cruft/misc/module.mk
rename from libcruft/misc/module.mk
rename to liboctave/cruft/misc/module.mk
diff --git a/libcruft/misc/quit.cc b/liboctave/cruft/misc/quit.cc
rename from libcruft/misc/quit.cc
rename to liboctave/cruft/misc/quit.cc
diff --git a/libcruft/misc/quit.h b/liboctave/cruft/misc/quit.h
rename from libcruft/misc/quit.h
rename to liboctave/cruft/misc/quit.h
diff --git a/libcruft/misc/r1mach.f b/liboctave/cruft/misc/r1mach.f
rename from libcruft/misc/r1mach.f
rename to liboctave/cruft/misc/r1mach.f
diff --git a/libcruft/mkf77def.in b/liboctave/cruft/mkf77def.in
rename from libcruft/mkf77def.in
rename to liboctave/cruft/mkf77def.in
diff --git a/libcruft/odepack/cfode.f b/liboctave/cruft/odepack/cfode.f
rename from libcruft/odepack/cfode.f
rename to liboctave/cruft/odepack/cfode.f
diff --git a/libcruft/odepack/dlsode.f b/liboctave/cruft/odepack/dlsode.f
rename from libcruft/odepack/dlsode.f
rename to liboctave/cruft/odepack/dlsode.f
diff --git a/libcruft/odepack/ewset.f b/liboctave/cruft/odepack/ewset.f
rename from libcruft/odepack/ewset.f
rename to liboctave/cruft/odepack/ewset.f
diff --git a/libcruft/odepack/intdy.f b/liboctave/cruft/odepack/intdy.f
rename from libcruft/odepack/intdy.f
rename to liboctave/cruft/odepack/intdy.f
diff --git a/libcruft/odepack/module.mk b/liboctave/cruft/odepack/module.mk
rename from libcruft/odepack/module.mk
rename to liboctave/cruft/odepack/module.mk
diff --git a/libcruft/odepack/prepj.f b/liboctave/cruft/odepack/prepj.f
rename from libcruft/odepack/prepj.f
rename to liboctave/cruft/odepack/prepj.f
diff --git a/libcruft/odepack/scfode.f b/liboctave/cruft/odepack/scfode.f
rename from libcruft/odepack/scfode.f
rename to liboctave/cruft/odepack/scfode.f
diff --git a/libcruft/odepack/sewset.f b/liboctave/cruft/odepack/sewset.f
rename from libcruft/odepack/sewset.f
rename to liboctave/cruft/odepack/sewset.f
diff --git a/libcruft/odepack/sintdy.f b/liboctave/cruft/odepack/sintdy.f
rename from libcruft/odepack/sintdy.f
rename to liboctave/cruft/odepack/sintdy.f
diff --git a/libcruft/odepack/slsode.f b/liboctave/cruft/odepack/slsode.f
rename from libcruft/odepack/slsode.f
rename to liboctave/cruft/odepack/slsode.f
diff --git a/libcruft/odepack/solsy.f b/liboctave/cruft/odepack/solsy.f
rename from libcruft/odepack/solsy.f
rename to liboctave/cruft/odepack/solsy.f
diff --git a/libcruft/odepack/sprepj.f b/liboctave/cruft/odepack/sprepj.f
rename from libcruft/odepack/sprepj.f
rename to liboctave/cruft/odepack/sprepj.f
diff --git a/libcruft/odepack/ssolsy.f b/liboctave/cruft/odepack/ssolsy.f
rename from libcruft/odepack/ssolsy.f
rename to liboctave/cruft/odepack/ssolsy.f
diff --git a/libcruft/odepack/sstode.f b/liboctave/cruft/odepack/sstode.f
rename from libcruft/odepack/sstode.f
rename to liboctave/cruft/odepack/sstode.f
diff --git a/libcruft/odepack/stode.f b/liboctave/cruft/odepack/stode.f
rename from libcruft/odepack/stode.f
rename to liboctave/cruft/odepack/stode.f
diff --git a/libcruft/odepack/svnorm.f b/liboctave/cruft/odepack/svnorm.f
rename from libcruft/odepack/svnorm.f
rename to liboctave/cruft/odepack/svnorm.f
diff --git a/libcruft/odepack/vnorm.f b/liboctave/cruft/odepack/vnorm.f
rename from libcruft/odepack/vnorm.f
rename to liboctave/cruft/odepack/vnorm.f
diff --git a/libcruft/ordered-qz/README b/liboctave/cruft/ordered-qz/README
rename from libcruft/ordered-qz/README
rename to liboctave/cruft/ordered-qz/README
diff --git a/libcruft/ordered-qz/dsubsp.f b/liboctave/cruft/ordered-qz/dsubsp.f
rename from libcruft/ordered-qz/dsubsp.f
rename to liboctave/cruft/ordered-qz/dsubsp.f
diff --git a/libcruft/ordered-qz/exchqz.f b/liboctave/cruft/ordered-qz/exchqz.f
rename from libcruft/ordered-qz/exchqz.f
rename to liboctave/cruft/ordered-qz/exchqz.f
diff --git a/libcruft/ordered-qz/module.mk b/liboctave/cruft/ordered-qz/module.mk
rename from libcruft/ordered-qz/module.mk
rename to liboctave/cruft/ordered-qz/module.mk
diff --git a/libcruft/ordered-qz/sexchqz.f b/liboctave/cruft/ordered-qz/sexchqz.f
rename from libcruft/ordered-qz/sexchqz.f
rename to liboctave/cruft/ordered-qz/sexchqz.f
diff --git a/libcruft/ordered-qz/ssubsp.f b/liboctave/cruft/ordered-qz/ssubsp.f
rename from libcruft/ordered-qz/ssubsp.f
rename to liboctave/cruft/ordered-qz/ssubsp.f
diff --git a/libcruft/quadpack/dqagi.f b/liboctave/cruft/quadpack/dqagi.f
rename from libcruft/quadpack/dqagi.f
rename to liboctave/cruft/quadpack/dqagi.f
diff --git a/libcruft/quadpack/dqagie.f b/liboctave/cruft/quadpack/dqagie.f
rename from libcruft/quadpack/dqagie.f
rename to liboctave/cruft/quadpack/dqagie.f
diff --git a/libcruft/quadpack/dqagp.f b/liboctave/cruft/quadpack/dqagp.f
rename from libcruft/quadpack/dqagp.f
rename to liboctave/cruft/quadpack/dqagp.f
diff --git a/libcruft/quadpack/dqagpe.f b/liboctave/cruft/quadpack/dqagpe.f
rename from libcruft/quadpack/dqagpe.f
rename to liboctave/cruft/quadpack/dqagpe.f
diff --git a/libcruft/quadpack/dqelg.f b/liboctave/cruft/quadpack/dqelg.f
rename from libcruft/quadpack/dqelg.f
rename to liboctave/cruft/quadpack/dqelg.f
diff --git a/libcruft/quadpack/dqk15i.f b/liboctave/cruft/quadpack/dqk15i.f
rename from libcruft/quadpack/dqk15i.f
rename to liboctave/cruft/quadpack/dqk15i.f
diff --git a/libcruft/quadpack/dqk21.f b/liboctave/cruft/quadpack/dqk21.f
rename from libcruft/quadpack/dqk21.f
rename to liboctave/cruft/quadpack/dqk21.f
diff --git a/libcruft/quadpack/dqpsrt.f b/liboctave/cruft/quadpack/dqpsrt.f
rename from libcruft/quadpack/dqpsrt.f
rename to liboctave/cruft/quadpack/dqpsrt.f
diff --git a/libcruft/quadpack/module.mk b/liboctave/cruft/quadpack/module.mk
rename from libcruft/quadpack/module.mk
rename to liboctave/cruft/quadpack/module.mk
diff --git a/libcruft/quadpack/qagi.f b/liboctave/cruft/quadpack/qagi.f
rename from libcruft/quadpack/qagi.f
rename to liboctave/cruft/quadpack/qagi.f
diff --git a/libcruft/quadpack/qagie.f b/liboctave/cruft/quadpack/qagie.f
rename from libcruft/quadpack/qagie.f
rename to liboctave/cruft/quadpack/qagie.f
diff --git a/libcruft/quadpack/qagp.f b/liboctave/cruft/quadpack/qagp.f
rename from libcruft/quadpack/qagp.f
rename to liboctave/cruft/quadpack/qagp.f
diff --git a/libcruft/quadpack/qagpe.f b/liboctave/cruft/quadpack/qagpe.f
rename from libcruft/quadpack/qagpe.f
rename to liboctave/cruft/quadpack/qagpe.f
diff --git a/libcruft/quadpack/qelg.f b/liboctave/cruft/quadpack/qelg.f
rename from libcruft/quadpack/qelg.f
rename to liboctave/cruft/quadpack/qelg.f
diff --git a/libcruft/quadpack/qk15i.f b/liboctave/cruft/quadpack/qk15i.f
rename from libcruft/quadpack/qk15i.f
rename to liboctave/cruft/quadpack/qk15i.f
diff --git a/libcruft/quadpack/qk21.f b/liboctave/cruft/quadpack/qk21.f
rename from libcruft/quadpack/qk21.f
rename to liboctave/cruft/quadpack/qk21.f
diff --git a/libcruft/quadpack/qpsrt.f b/liboctave/cruft/quadpack/qpsrt.f
rename from libcruft/quadpack/qpsrt.f
rename to liboctave/cruft/quadpack/qpsrt.f
diff --git a/libcruft/quadpack/xerror.f b/liboctave/cruft/quadpack/xerror.f
rename from libcruft/quadpack/xerror.f
rename to liboctave/cruft/quadpack/xerror.f
diff --git a/libcruft/ranlib/Basegen.doc b/liboctave/cruft/ranlib/Basegen.doc
rename from libcruft/ranlib/Basegen.doc
rename to liboctave/cruft/ranlib/Basegen.doc
diff --git a/libcruft/ranlib/HOWTOGET b/liboctave/cruft/ranlib/HOWTOGET
rename from libcruft/ranlib/HOWTOGET
rename to liboctave/cruft/ranlib/HOWTOGET
diff --git a/libcruft/ranlib/README b/liboctave/cruft/ranlib/README
rename from libcruft/ranlib/README
rename to liboctave/cruft/ranlib/README
diff --git a/libcruft/ranlib/advnst.f b/liboctave/cruft/ranlib/advnst.f
rename from libcruft/ranlib/advnst.f
rename to liboctave/cruft/ranlib/advnst.f
diff --git a/libcruft/ranlib/genbet.f b/liboctave/cruft/ranlib/genbet.f
rename from libcruft/ranlib/genbet.f
rename to liboctave/cruft/ranlib/genbet.f
diff --git a/libcruft/ranlib/genchi.f b/liboctave/cruft/ranlib/genchi.f
rename from libcruft/ranlib/genchi.f
rename to liboctave/cruft/ranlib/genchi.f
diff --git a/libcruft/ranlib/genexp.f b/liboctave/cruft/ranlib/genexp.f
rename from libcruft/ranlib/genexp.f
rename to liboctave/cruft/ranlib/genexp.f
diff --git a/libcruft/ranlib/genf.f b/liboctave/cruft/ranlib/genf.f
rename from libcruft/ranlib/genf.f
rename to liboctave/cruft/ranlib/genf.f
diff --git a/libcruft/ranlib/gengam.f b/liboctave/cruft/ranlib/gengam.f
rename from libcruft/ranlib/gengam.f
rename to liboctave/cruft/ranlib/gengam.f
diff --git a/libcruft/ranlib/genmn.f b/liboctave/cruft/ranlib/genmn.f
rename from libcruft/ranlib/genmn.f
rename to liboctave/cruft/ranlib/genmn.f
diff --git a/libcruft/ranlib/genmul.f b/liboctave/cruft/ranlib/genmul.f
rename from libcruft/ranlib/genmul.f
rename to liboctave/cruft/ranlib/genmul.f
diff --git a/libcruft/ranlib/gennch.f b/liboctave/cruft/ranlib/gennch.f
rename from libcruft/ranlib/gennch.f
rename to liboctave/cruft/ranlib/gennch.f
diff --git a/libcruft/ranlib/gennf.f b/liboctave/cruft/ranlib/gennf.f
rename from libcruft/ranlib/gennf.f
rename to liboctave/cruft/ranlib/gennf.f
diff --git a/libcruft/ranlib/gennor.f b/liboctave/cruft/ranlib/gennor.f
rename from libcruft/ranlib/gennor.f
rename to liboctave/cruft/ranlib/gennor.f
diff --git a/libcruft/ranlib/genprm.f b/liboctave/cruft/ranlib/genprm.f
rename from libcruft/ranlib/genprm.f
rename to liboctave/cruft/ranlib/genprm.f
diff --git a/libcruft/ranlib/genunf.f b/liboctave/cruft/ranlib/genunf.f
rename from libcruft/ranlib/genunf.f
rename to liboctave/cruft/ranlib/genunf.f
diff --git a/libcruft/ranlib/getcgn.f b/liboctave/cruft/ranlib/getcgn.f
rename from libcruft/ranlib/getcgn.f
rename to liboctave/cruft/ranlib/getcgn.f
diff --git a/libcruft/ranlib/getsd.f b/liboctave/cruft/ranlib/getsd.f
rename from libcruft/ranlib/getsd.f
rename to liboctave/cruft/ranlib/getsd.f
diff --git a/libcruft/ranlib/ignbin.f b/liboctave/cruft/ranlib/ignbin.f
rename from libcruft/ranlib/ignbin.f
rename to liboctave/cruft/ranlib/ignbin.f
diff --git a/libcruft/ranlib/ignlgi.f b/liboctave/cruft/ranlib/ignlgi.f
rename from libcruft/ranlib/ignlgi.f
rename to liboctave/cruft/ranlib/ignlgi.f
diff --git a/libcruft/ranlib/ignnbn.f b/liboctave/cruft/ranlib/ignnbn.f
rename from libcruft/ranlib/ignnbn.f
rename to liboctave/cruft/ranlib/ignnbn.f
diff --git a/libcruft/ranlib/ignpoi.f b/liboctave/cruft/ranlib/ignpoi.f
rename from libcruft/ranlib/ignpoi.f
rename to liboctave/cruft/ranlib/ignpoi.f
diff --git a/libcruft/ranlib/ignuin.f b/liboctave/cruft/ranlib/ignuin.f
rename from libcruft/ranlib/ignuin.f
rename to liboctave/cruft/ranlib/ignuin.f
diff --git a/libcruft/ranlib/initgn.f b/liboctave/cruft/ranlib/initgn.f
rename from libcruft/ranlib/initgn.f
rename to liboctave/cruft/ranlib/initgn.f
diff --git a/libcruft/ranlib/inrgcm.f b/liboctave/cruft/ranlib/inrgcm.f
rename from libcruft/ranlib/inrgcm.f
rename to liboctave/cruft/ranlib/inrgcm.f
diff --git a/libcruft/ranlib/lennob.f b/liboctave/cruft/ranlib/lennob.f
rename from libcruft/ranlib/lennob.f
rename to liboctave/cruft/ranlib/lennob.f
diff --git a/libcruft/ranlib/mltmod.f b/liboctave/cruft/ranlib/mltmod.f
rename from libcruft/ranlib/mltmod.f
rename to liboctave/cruft/ranlib/mltmod.f
diff --git a/libcruft/ranlib/module.mk b/liboctave/cruft/ranlib/module.mk
rename from libcruft/ranlib/module.mk
rename to liboctave/cruft/ranlib/module.mk
--- a/libcruft/ranlib/module.mk
+++ b/liboctave/cruft/ranlib/module.mk
@@ -4,17 +4,17 @@ EXTRA_DIST += \
   ranlib/HOWTOGET \
   ranlib/README \
   ranlib/randlib.chs \
   ranlib/randlib.fdoc \
   ranlib/tstbot.for \
   ranlib/tstgmn.for \
   ranlib/tstmid.for
 
-libranlib_la_SOURCES += \
+RANLIB_SRC = \
   ranlib/advnst.f \
   ranlib/genbet.f \
   ranlib/genchi.f \
   ranlib/genexp.f \
   ranlib/genf.f \
   ranlib/gengam.f \
   ranlib/genmn.f \
   ranlib/genmul.f \
@@ -40,8 +40,21 @@ libranlib_la_SOURCES += \
   ranlib/setall.f \
   ranlib/setant.f \
   ranlib/setgmn.f \
   ranlib/setsd.f \
   ranlib/sexpo.f \
   ranlib/sgamma.f \
   ranlib/snorm.f \
   ranlib/wrap.f
+
+noinst_LTLIBRARIES += ranlib/libranlib.la
+
+ranlib_libranlib_la_SOURCES = $(RANLIB_SRC)
+
+ranlib_libranlib_la_DEPENDENCIES = ranlib/ranlib.def
+
+## Special rules for files which must be built before compilation
+ranlib/ranlib.def: $(RANLIB_SRC) mkf77def
+	chmod a+rx mkf77def
+	./mkf77def $(srcdir) $(RANLIB_SRC) > $@-t
+	mv $@-t $@
+
diff --git a/libcruft/ranlib/phrtsd.f b/liboctave/cruft/ranlib/phrtsd.f
rename from libcruft/ranlib/phrtsd.f
rename to liboctave/cruft/ranlib/phrtsd.f
diff --git a/libcruft/ranlib/qrgnin.f b/liboctave/cruft/ranlib/qrgnin.f
rename from libcruft/ranlib/qrgnin.f
rename to liboctave/cruft/ranlib/qrgnin.f
diff --git a/libcruft/ranlib/randlib.chs b/liboctave/cruft/ranlib/randlib.chs
rename from libcruft/ranlib/randlib.chs
rename to liboctave/cruft/ranlib/randlib.chs
diff --git a/libcruft/ranlib/randlib.fdoc b/liboctave/cruft/ranlib/randlib.fdoc
rename from libcruft/ranlib/randlib.fdoc
rename to liboctave/cruft/ranlib/randlib.fdoc
diff --git a/libcruft/ranlib/ranf.f b/liboctave/cruft/ranlib/ranf.f
rename from libcruft/ranlib/ranf.f
rename to liboctave/cruft/ranlib/ranf.f
diff --git a/libcruft/ranlib/setall.f b/liboctave/cruft/ranlib/setall.f
rename from libcruft/ranlib/setall.f
rename to liboctave/cruft/ranlib/setall.f
diff --git a/libcruft/ranlib/setant.f b/liboctave/cruft/ranlib/setant.f
rename from libcruft/ranlib/setant.f
rename to liboctave/cruft/ranlib/setant.f
diff --git a/libcruft/ranlib/setgmn.f b/liboctave/cruft/ranlib/setgmn.f
rename from libcruft/ranlib/setgmn.f
rename to liboctave/cruft/ranlib/setgmn.f
diff --git a/libcruft/ranlib/setsd.f b/liboctave/cruft/ranlib/setsd.f
rename from libcruft/ranlib/setsd.f
rename to liboctave/cruft/ranlib/setsd.f
diff --git a/libcruft/ranlib/sexpo.f b/liboctave/cruft/ranlib/sexpo.f
rename from libcruft/ranlib/sexpo.f
rename to liboctave/cruft/ranlib/sexpo.f
diff --git a/libcruft/ranlib/sgamma.f b/liboctave/cruft/ranlib/sgamma.f
rename from libcruft/ranlib/sgamma.f
rename to liboctave/cruft/ranlib/sgamma.f
diff --git a/libcruft/ranlib/snorm.f b/liboctave/cruft/ranlib/snorm.f
rename from libcruft/ranlib/snorm.f
rename to liboctave/cruft/ranlib/snorm.f
diff --git a/libcruft/ranlib/tstbot.for b/liboctave/cruft/ranlib/tstbot.for
rename from libcruft/ranlib/tstbot.for
rename to liboctave/cruft/ranlib/tstbot.for
diff --git a/libcruft/ranlib/tstgmn.for b/liboctave/cruft/ranlib/tstgmn.for
rename from libcruft/ranlib/tstgmn.for
rename to liboctave/cruft/ranlib/tstgmn.for
diff --git a/libcruft/ranlib/tstmid.for b/liboctave/cruft/ranlib/tstmid.for
rename from libcruft/ranlib/tstmid.for
rename to liboctave/cruft/ranlib/tstmid.for
diff --git a/libcruft/ranlib/wrap.f b/liboctave/cruft/ranlib/wrap.f
rename from libcruft/ranlib/wrap.f
rename to liboctave/cruft/ranlib/wrap.f
diff --git a/libcruft/slatec-err/fdump.f b/liboctave/cruft/slatec-err/fdump.f
rename from libcruft/slatec-err/fdump.f
rename to liboctave/cruft/slatec-err/fdump.f
diff --git a/libcruft/slatec-err/ixsav.f b/liboctave/cruft/slatec-err/ixsav.f
rename from libcruft/slatec-err/ixsav.f
rename to liboctave/cruft/slatec-err/ixsav.f
diff --git a/libcruft/slatec-err/j4save.f b/liboctave/cruft/slatec-err/j4save.f
rename from libcruft/slatec-err/j4save.f
rename to liboctave/cruft/slatec-err/j4save.f
diff --git a/libcruft/slatec-err/module.mk b/liboctave/cruft/slatec-err/module.mk
rename from libcruft/slatec-err/module.mk
rename to liboctave/cruft/slatec-err/module.mk
diff --git a/libcruft/slatec-err/xerclr.f b/liboctave/cruft/slatec-err/xerclr.f
rename from libcruft/slatec-err/xerclr.f
rename to liboctave/cruft/slatec-err/xerclr.f
diff --git a/libcruft/slatec-err/xercnt.f b/liboctave/cruft/slatec-err/xercnt.f
rename from libcruft/slatec-err/xercnt.f
rename to liboctave/cruft/slatec-err/xercnt.f
diff --git a/libcruft/slatec-err/xerhlt.f b/liboctave/cruft/slatec-err/xerhlt.f
rename from libcruft/slatec-err/xerhlt.f
rename to liboctave/cruft/slatec-err/xerhlt.f
diff --git a/libcruft/slatec-err/xermsg.f b/liboctave/cruft/slatec-err/xermsg.f
rename from libcruft/slatec-err/xermsg.f
rename to liboctave/cruft/slatec-err/xermsg.f
diff --git a/libcruft/slatec-err/xerprn.f b/liboctave/cruft/slatec-err/xerprn.f
rename from libcruft/slatec-err/xerprn.f
rename to liboctave/cruft/slatec-err/xerprn.f
diff --git a/libcruft/slatec-err/xerrwd.f b/liboctave/cruft/slatec-err/xerrwd.f
rename from libcruft/slatec-err/xerrwd.f
rename to liboctave/cruft/slatec-err/xerrwd.f
diff --git a/libcruft/slatec-err/xersve.f b/liboctave/cruft/slatec-err/xersve.f
rename from libcruft/slatec-err/xersve.f
rename to liboctave/cruft/slatec-err/xersve.f
diff --git a/libcruft/slatec-err/xgetf.f b/liboctave/cruft/slatec-err/xgetf.f
rename from libcruft/slatec-err/xgetf.f
rename to liboctave/cruft/slatec-err/xgetf.f
diff --git a/libcruft/slatec-err/xgetua.f b/liboctave/cruft/slatec-err/xgetua.f
rename from libcruft/slatec-err/xgetua.f
rename to liboctave/cruft/slatec-err/xgetua.f
diff --git a/libcruft/slatec-err/xsetf.f b/liboctave/cruft/slatec-err/xsetf.f
rename from libcruft/slatec-err/xsetf.f
rename to liboctave/cruft/slatec-err/xsetf.f
diff --git a/libcruft/slatec-err/xsetua.f b/liboctave/cruft/slatec-err/xsetua.f
rename from libcruft/slatec-err/xsetua.f
rename to liboctave/cruft/slatec-err/xsetua.f
diff --git a/libcruft/slatec-fn/acosh.f b/liboctave/cruft/slatec-fn/acosh.f
rename from libcruft/slatec-fn/acosh.f
rename to liboctave/cruft/slatec-fn/acosh.f
diff --git a/libcruft/slatec-fn/albeta.f b/liboctave/cruft/slatec-fn/albeta.f
rename from libcruft/slatec-fn/albeta.f
rename to liboctave/cruft/slatec-fn/albeta.f
diff --git a/libcruft/slatec-fn/algams.f b/liboctave/cruft/slatec-fn/algams.f
rename from libcruft/slatec-fn/algams.f
rename to liboctave/cruft/slatec-fn/algams.f
diff --git a/libcruft/slatec-fn/alngam.f b/liboctave/cruft/slatec-fn/alngam.f
rename from libcruft/slatec-fn/alngam.f
rename to liboctave/cruft/slatec-fn/alngam.f
diff --git a/libcruft/slatec-fn/alnrel.f b/liboctave/cruft/slatec-fn/alnrel.f
rename from libcruft/slatec-fn/alnrel.f
rename to liboctave/cruft/slatec-fn/alnrel.f
diff --git a/libcruft/slatec-fn/asinh.f b/liboctave/cruft/slatec-fn/asinh.f
rename from libcruft/slatec-fn/asinh.f
rename to liboctave/cruft/slatec-fn/asinh.f
diff --git a/libcruft/slatec-fn/atanh.f b/liboctave/cruft/slatec-fn/atanh.f
rename from libcruft/slatec-fn/atanh.f
rename to liboctave/cruft/slatec-fn/atanh.f
diff --git a/libcruft/slatec-fn/betai.f b/liboctave/cruft/slatec-fn/betai.f
rename from libcruft/slatec-fn/betai.f
rename to liboctave/cruft/slatec-fn/betai.f
diff --git a/libcruft/slatec-fn/csevl.f b/liboctave/cruft/slatec-fn/csevl.f
rename from libcruft/slatec-fn/csevl.f
rename to liboctave/cruft/slatec-fn/csevl.f
diff --git a/libcruft/slatec-fn/d9gmit.f b/liboctave/cruft/slatec-fn/d9gmit.f
rename from libcruft/slatec-fn/d9gmit.f
rename to liboctave/cruft/slatec-fn/d9gmit.f
diff --git a/libcruft/slatec-fn/d9lgic.f b/liboctave/cruft/slatec-fn/d9lgic.f
rename from libcruft/slatec-fn/d9lgic.f
rename to liboctave/cruft/slatec-fn/d9lgic.f
diff --git a/libcruft/slatec-fn/d9lgit.f b/liboctave/cruft/slatec-fn/d9lgit.f
rename from libcruft/slatec-fn/d9lgit.f
rename to liboctave/cruft/slatec-fn/d9lgit.f
diff --git a/libcruft/slatec-fn/d9lgmc.f b/liboctave/cruft/slatec-fn/d9lgmc.f
rename from libcruft/slatec-fn/d9lgmc.f
rename to liboctave/cruft/slatec-fn/d9lgmc.f
diff --git a/libcruft/slatec-fn/dacosh.f b/liboctave/cruft/slatec-fn/dacosh.f
rename from libcruft/slatec-fn/dacosh.f
rename to liboctave/cruft/slatec-fn/dacosh.f
diff --git a/libcruft/slatec-fn/dasinh.f b/liboctave/cruft/slatec-fn/dasinh.f
rename from libcruft/slatec-fn/dasinh.f
rename to liboctave/cruft/slatec-fn/dasinh.f
diff --git a/libcruft/slatec-fn/datanh.f b/liboctave/cruft/slatec-fn/datanh.f
rename from libcruft/slatec-fn/datanh.f
rename to liboctave/cruft/slatec-fn/datanh.f
diff --git a/libcruft/slatec-fn/dbetai.f b/liboctave/cruft/slatec-fn/dbetai.f
rename from libcruft/slatec-fn/dbetai.f
rename to liboctave/cruft/slatec-fn/dbetai.f
diff --git a/libcruft/slatec-fn/dcsevl.f b/liboctave/cruft/slatec-fn/dcsevl.f
rename from libcruft/slatec-fn/dcsevl.f
rename to liboctave/cruft/slatec-fn/dcsevl.f
diff --git a/libcruft/slatec-fn/derf.f b/liboctave/cruft/slatec-fn/derf.f
rename from libcruft/slatec-fn/derf.f
rename to liboctave/cruft/slatec-fn/derf.f
diff --git a/libcruft/slatec-fn/derfc.in.f b/liboctave/cruft/slatec-fn/derfc.in.f
rename from libcruft/slatec-fn/derfc.in.f
rename to liboctave/cruft/slatec-fn/derfc.in.f
diff --git a/libcruft/slatec-fn/dgami.f b/liboctave/cruft/slatec-fn/dgami.f
rename from libcruft/slatec-fn/dgami.f
rename to liboctave/cruft/slatec-fn/dgami.f
diff --git a/libcruft/slatec-fn/dgamit.f b/liboctave/cruft/slatec-fn/dgamit.f
rename from libcruft/slatec-fn/dgamit.f
rename to liboctave/cruft/slatec-fn/dgamit.f
diff --git a/libcruft/slatec-fn/dgamlm.f b/liboctave/cruft/slatec-fn/dgamlm.f
rename from libcruft/slatec-fn/dgamlm.f
rename to liboctave/cruft/slatec-fn/dgamlm.f
diff --git a/libcruft/slatec-fn/dgamma.f b/liboctave/cruft/slatec-fn/dgamma.f
rename from libcruft/slatec-fn/dgamma.f
rename to liboctave/cruft/slatec-fn/dgamma.f
diff --git a/libcruft/slatec-fn/dgamr.f b/liboctave/cruft/slatec-fn/dgamr.f
rename from libcruft/slatec-fn/dgamr.f
rename to liboctave/cruft/slatec-fn/dgamr.f
diff --git a/libcruft/slatec-fn/dlbeta.f b/liboctave/cruft/slatec-fn/dlbeta.f
rename from libcruft/slatec-fn/dlbeta.f
rename to liboctave/cruft/slatec-fn/dlbeta.f
diff --git a/libcruft/slatec-fn/dlgams.f b/liboctave/cruft/slatec-fn/dlgams.f
rename from libcruft/slatec-fn/dlgams.f
rename to liboctave/cruft/slatec-fn/dlgams.f
diff --git a/libcruft/slatec-fn/dlngam.f b/liboctave/cruft/slatec-fn/dlngam.f
rename from libcruft/slatec-fn/dlngam.f
rename to liboctave/cruft/slatec-fn/dlngam.f
diff --git a/libcruft/slatec-fn/dlnrel.f b/liboctave/cruft/slatec-fn/dlnrel.f
rename from libcruft/slatec-fn/dlnrel.f
rename to liboctave/cruft/slatec-fn/dlnrel.f
diff --git a/libcruft/slatec-fn/dpchim.f b/liboctave/cruft/slatec-fn/dpchim.f
rename from libcruft/slatec-fn/dpchim.f
rename to liboctave/cruft/slatec-fn/dpchim.f
diff --git a/libcruft/slatec-fn/dpchst.f b/liboctave/cruft/slatec-fn/dpchst.f
rename from libcruft/slatec-fn/dpchst.f
rename to liboctave/cruft/slatec-fn/dpchst.f
diff --git a/libcruft/slatec-fn/erf.f b/liboctave/cruft/slatec-fn/erf.f
rename from libcruft/slatec-fn/erf.f
rename to liboctave/cruft/slatec-fn/erf.f
diff --git a/libcruft/slatec-fn/erfc.in.f b/liboctave/cruft/slatec-fn/erfc.in.f
rename from libcruft/slatec-fn/erfc.in.f
rename to liboctave/cruft/slatec-fn/erfc.in.f
diff --git a/libcruft/slatec-fn/gami.f b/liboctave/cruft/slatec-fn/gami.f
rename from libcruft/slatec-fn/gami.f
rename to liboctave/cruft/slatec-fn/gami.f
diff --git a/libcruft/slatec-fn/gamit.f b/liboctave/cruft/slatec-fn/gamit.f
rename from libcruft/slatec-fn/gamit.f
rename to liboctave/cruft/slatec-fn/gamit.f
diff --git a/libcruft/slatec-fn/gamlim.f b/liboctave/cruft/slatec-fn/gamlim.f
rename from libcruft/slatec-fn/gamlim.f
rename to liboctave/cruft/slatec-fn/gamlim.f
diff --git a/libcruft/slatec-fn/gamma.f b/liboctave/cruft/slatec-fn/gamma.f
rename from libcruft/slatec-fn/gamma.f
rename to liboctave/cruft/slatec-fn/gamma.f
diff --git a/libcruft/slatec-fn/gamr.f b/liboctave/cruft/slatec-fn/gamr.f
rename from libcruft/slatec-fn/gamr.f
rename to liboctave/cruft/slatec-fn/gamr.f
diff --git a/libcruft/slatec-fn/initds.f b/liboctave/cruft/slatec-fn/initds.f
rename from libcruft/slatec-fn/initds.f
rename to liboctave/cruft/slatec-fn/initds.f
diff --git a/libcruft/slatec-fn/inits.f b/liboctave/cruft/slatec-fn/inits.f
rename from libcruft/slatec-fn/inits.f
rename to liboctave/cruft/slatec-fn/inits.f
diff --git a/libcruft/slatec-fn/module.mk b/liboctave/cruft/slatec-fn/module.mk
rename from libcruft/slatec-fn/module.mk
rename to liboctave/cruft/slatec-fn/module.mk
--- a/libcruft/slatec-fn/module.mk
+++ b/liboctave/cruft/slatec-fn/module.mk
@@ -73,8 +73,9 @@ nodist_libcruft_la_SOURCES += \
 
 slatec-fn/erfc.f: slatec-fn/erfc.in.f Makefile
 	$(SED) -e "${F77_ISNAN_MACRO}" < $< > $@-t
 	mv $@-t $@
 
 slatec-fn/derfc.f: slatec-fn/derfc.in.f Makefile
 	$(SED) -e "${F77_ISNAN_MACRO}" < $< > $@-t
 	mv $@-t $@
+
diff --git a/libcruft/slatec-fn/pchim.f b/liboctave/cruft/slatec-fn/pchim.f
rename from libcruft/slatec-fn/pchim.f
rename to liboctave/cruft/slatec-fn/pchim.f
diff --git a/libcruft/slatec-fn/pchst.f b/liboctave/cruft/slatec-fn/pchst.f
rename from libcruft/slatec-fn/pchst.f
rename to liboctave/cruft/slatec-fn/pchst.f
diff --git a/libcruft/slatec-fn/r9gmit.f b/liboctave/cruft/slatec-fn/r9gmit.f
rename from libcruft/slatec-fn/r9gmit.f
rename to liboctave/cruft/slatec-fn/r9gmit.f
diff --git a/libcruft/slatec-fn/r9lgic.f b/liboctave/cruft/slatec-fn/r9lgic.f
rename from libcruft/slatec-fn/r9lgic.f
rename to liboctave/cruft/slatec-fn/r9lgic.f
diff --git a/libcruft/slatec-fn/r9lgit.f b/liboctave/cruft/slatec-fn/r9lgit.f
rename from libcruft/slatec-fn/r9lgit.f
rename to liboctave/cruft/slatec-fn/r9lgit.f
diff --git a/libcruft/slatec-fn/r9lgmc.f b/liboctave/cruft/slatec-fn/r9lgmc.f
rename from libcruft/slatec-fn/r9lgmc.f
rename to liboctave/cruft/slatec-fn/r9lgmc.f
diff --git a/libcruft/slatec-fn/xacosh.f b/liboctave/cruft/slatec-fn/xacosh.f
rename from libcruft/slatec-fn/xacosh.f
rename to liboctave/cruft/slatec-fn/xacosh.f
diff --git a/libcruft/slatec-fn/xasinh.f b/liboctave/cruft/slatec-fn/xasinh.f
rename from libcruft/slatec-fn/xasinh.f
rename to liboctave/cruft/slatec-fn/xasinh.f
diff --git a/libcruft/slatec-fn/xatanh.f b/liboctave/cruft/slatec-fn/xatanh.f
rename from libcruft/slatec-fn/xatanh.f
rename to liboctave/cruft/slatec-fn/xatanh.f
diff --git a/libcruft/slatec-fn/xbetai.f b/liboctave/cruft/slatec-fn/xbetai.f
rename from libcruft/slatec-fn/xbetai.f
rename to liboctave/cruft/slatec-fn/xbetai.f
diff --git a/libcruft/slatec-fn/xdacosh.f b/liboctave/cruft/slatec-fn/xdacosh.f
rename from libcruft/slatec-fn/xdacosh.f
rename to liboctave/cruft/slatec-fn/xdacosh.f
diff --git a/libcruft/slatec-fn/xdasinh.f b/liboctave/cruft/slatec-fn/xdasinh.f
rename from libcruft/slatec-fn/xdasinh.f
rename to liboctave/cruft/slatec-fn/xdasinh.f
diff --git a/libcruft/slatec-fn/xdatanh.f b/liboctave/cruft/slatec-fn/xdatanh.f
rename from libcruft/slatec-fn/xdatanh.f
rename to liboctave/cruft/slatec-fn/xdatanh.f
diff --git a/libcruft/slatec-fn/xdbetai.f b/liboctave/cruft/slatec-fn/xdbetai.f
rename from libcruft/slatec-fn/xdbetai.f
rename to liboctave/cruft/slatec-fn/xdbetai.f
diff --git a/libcruft/slatec-fn/xderf.f b/liboctave/cruft/slatec-fn/xderf.f
rename from libcruft/slatec-fn/xderf.f
rename to liboctave/cruft/slatec-fn/xderf.f
diff --git a/libcruft/slatec-fn/xderfc.f b/liboctave/cruft/slatec-fn/xderfc.f
rename from libcruft/slatec-fn/xderfc.f
rename to liboctave/cruft/slatec-fn/xderfc.f
diff --git a/libcruft/slatec-fn/xdgami.f b/liboctave/cruft/slatec-fn/xdgami.f
rename from libcruft/slatec-fn/xdgami.f
rename to liboctave/cruft/slatec-fn/xdgami.f
diff --git a/libcruft/slatec-fn/xdgamit.f b/liboctave/cruft/slatec-fn/xdgamit.f
rename from libcruft/slatec-fn/xdgamit.f
rename to liboctave/cruft/slatec-fn/xdgamit.f
diff --git a/libcruft/slatec-fn/xdgamma.f b/liboctave/cruft/slatec-fn/xdgamma.f
rename from libcruft/slatec-fn/xdgamma.f
rename to liboctave/cruft/slatec-fn/xdgamma.f
diff --git a/libcruft/slatec-fn/xerf.f b/liboctave/cruft/slatec-fn/xerf.f
rename from libcruft/slatec-fn/xerf.f
rename to liboctave/cruft/slatec-fn/xerf.f
diff --git a/libcruft/slatec-fn/xerfc.f b/liboctave/cruft/slatec-fn/xerfc.f
rename from libcruft/slatec-fn/xerfc.f
rename to liboctave/cruft/slatec-fn/xerfc.f
diff --git a/libcruft/slatec-fn/xgamma.f b/liboctave/cruft/slatec-fn/xgamma.f
rename from libcruft/slatec-fn/xgamma.f
rename to liboctave/cruft/slatec-fn/xgamma.f
diff --git a/libcruft/slatec-fn/xgmainc.f b/liboctave/cruft/slatec-fn/xgmainc.f
rename from libcruft/slatec-fn/xgmainc.f
rename to liboctave/cruft/slatec-fn/xgmainc.f
diff --git a/libcruft/slatec-fn/xsgmainc.f b/liboctave/cruft/slatec-fn/xsgmainc.f
rename from libcruft/slatec-fn/xsgmainc.f
rename to liboctave/cruft/slatec-fn/xsgmainc.f
diff --git a/liboctave/link-deps.mk b/liboctave/link-deps.mk
--- a/liboctave/link-deps.mk
+++ b/liboctave/link-deps.mk
@@ -1,27 +1,37 @@
-include $(top_srcdir)/libcruft/link-deps.mk
+GNULIB_LINK_DEPS = \
+  $(COPYSIGNF_LIBM)\
+  $(COPYSIGN_LIBM)\
+  $(FLOORF_LIBM)\
+  $(FLOOR_LIBM)\
+  $(GETHOSTNAME_LIB)\
+  $(LIBSOCKET)\
+  $(LIB_NANOSLEEP)\
+  $(LIB_SELECT)\
+  $(LTLIBINTL)\
+  $(ROUNDF_LIBM)\
+  $(ROUND_LIBM)\
+  $(TRUNCF_LIBM)\
+  $(TRUNC_LIBM)
 
 LIBOCTAVE_LINK_DEPS = \
+  $(GNULIB_LINK_DEPS) \
   $(SPARSE_XLIBS) \
   $(ARPACK_LIBS) \
   $(QRUPDATE_LIBS) \
   $(FFTW_XLIBS) \
   $(LAPACK_LIBS) \
   $(BLAS_LIBS) \
   $(READLINE_LIBS) \
   $(TERM_LIBS) \
   $(LIBGLOB) \
   $(REGEX_LIBS) \
   $(DL_LIBS) \
   $(PTHREAD_LIBS) \
+  $(FLIBS) \
   $(LIBS)
 
 LIBOCTAVE_LINK_OPTS = \
   $(SPARSE_XLDFLAGS) \
   $(ARPACK_LDFLAGS) \
   $(QRUPDATE_LDFLAGS) \
   $(FFTW_XLDFLAGS)
-
-if AMCOND_LINK_ALL_DEPS
-  LIBOCTAVE_LINK_DEPS += $(LIBCRUFT_LINK_DEPS)
-  LIBOCTAVE_LINK_OPTS += $(LIBCRUFT_LINK_OPTS)
-endif
diff --git a/liboctave/CmplxAEPBAL.cc b/liboctave/numeric/CmplxAEPBAL.cc
rename from liboctave/CmplxAEPBAL.cc
rename to liboctave/numeric/CmplxAEPBAL.cc
diff --git a/liboctave/CmplxAEPBAL.h b/liboctave/numeric/CmplxAEPBAL.h
rename from liboctave/CmplxAEPBAL.h
rename to liboctave/numeric/CmplxAEPBAL.h
diff --git a/liboctave/CmplxCHOL.cc b/liboctave/numeric/CmplxCHOL.cc
rename from liboctave/CmplxCHOL.cc
rename to liboctave/numeric/CmplxCHOL.cc
diff --git a/liboctave/CmplxCHOL.h b/liboctave/numeric/CmplxCHOL.h
rename from liboctave/CmplxCHOL.h
rename to liboctave/numeric/CmplxCHOL.h
diff --git a/liboctave/CmplxGEPBAL.cc b/liboctave/numeric/CmplxGEPBAL.cc
rename from liboctave/CmplxGEPBAL.cc
rename to liboctave/numeric/CmplxGEPBAL.cc
diff --git a/liboctave/CmplxGEPBAL.h b/liboctave/numeric/CmplxGEPBAL.h
rename from liboctave/CmplxGEPBAL.h
rename to liboctave/numeric/CmplxGEPBAL.h
diff --git a/liboctave/CmplxHESS.cc b/liboctave/numeric/CmplxHESS.cc
rename from liboctave/CmplxHESS.cc
rename to liboctave/numeric/CmplxHESS.cc
diff --git a/liboctave/CmplxHESS.h b/liboctave/numeric/CmplxHESS.h
rename from liboctave/CmplxHESS.h
rename to liboctave/numeric/CmplxHESS.h
diff --git a/liboctave/CmplxLU.cc b/liboctave/numeric/CmplxLU.cc
rename from liboctave/CmplxLU.cc
rename to liboctave/numeric/CmplxLU.cc
--- a/liboctave/CmplxLU.cc
+++ b/liboctave/numeric/CmplxLU.cc
@@ -28,18 +28,18 @@ along with Octave; see the file COPYING.
 #include "CmplxLU.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "oct-locbuf.h"
 #include "CColVector.h"
 
 // Instantiate the base LU class for the types we need.
 
-#include <base-lu.h>
-#include <base-lu.cc>
+#include "base-lu.h"
+#include "base-lu.cc"
 
 template class base_lu <ComplexMatrix>;
 
 // Define the constructor for this particular derivation.
 
 extern "C"
 {
   F77_RET_T
diff --git a/liboctave/CmplxLU.h b/liboctave/numeric/CmplxLU.h
rename from liboctave/CmplxLU.h
rename to liboctave/numeric/CmplxLU.h
diff --git a/liboctave/CmplxQR.cc b/liboctave/numeric/CmplxQR.cc
rename from liboctave/CmplxQR.cc
rename to liboctave/numeric/CmplxQR.cc
diff --git a/liboctave/CmplxQR.h b/liboctave/numeric/CmplxQR.h
rename from liboctave/CmplxQR.h
rename to liboctave/numeric/CmplxQR.h
diff --git a/liboctave/CmplxQRP.cc b/liboctave/numeric/CmplxQRP.cc
rename from liboctave/CmplxQRP.cc
rename to liboctave/numeric/CmplxQRP.cc
diff --git a/liboctave/CmplxQRP.h b/liboctave/numeric/CmplxQRP.h
rename from liboctave/CmplxQRP.h
rename to liboctave/numeric/CmplxQRP.h
diff --git a/liboctave/CmplxSCHUR.cc b/liboctave/numeric/CmplxSCHUR.cc
rename from liboctave/CmplxSCHUR.cc
rename to liboctave/numeric/CmplxSCHUR.cc
diff --git a/liboctave/CmplxSCHUR.h b/liboctave/numeric/CmplxSCHUR.h
rename from liboctave/CmplxSCHUR.h
rename to liboctave/numeric/CmplxSCHUR.h
diff --git a/liboctave/CmplxSVD.cc b/liboctave/numeric/CmplxSVD.cc
rename from liboctave/CmplxSVD.cc
rename to liboctave/numeric/CmplxSVD.cc
diff --git a/liboctave/CmplxSVD.h b/liboctave/numeric/CmplxSVD.h
rename from liboctave/CmplxSVD.h
rename to liboctave/numeric/CmplxSVD.h
diff --git a/liboctave/CollocWt.cc b/liboctave/numeric/CollocWt.cc
rename from liboctave/CollocWt.cc
rename to liboctave/numeric/CollocWt.cc
diff --git a/liboctave/CollocWt.h b/liboctave/numeric/CollocWt.h
rename from liboctave/CollocWt.h
rename to liboctave/numeric/CollocWt.h
diff --git a/liboctave/DAE.h b/liboctave/numeric/DAE.h
rename from liboctave/DAE.h
rename to liboctave/numeric/DAE.h
diff --git a/liboctave/DAEFunc.h b/liboctave/numeric/DAEFunc.h
rename from liboctave/DAEFunc.h
rename to liboctave/numeric/DAEFunc.h
diff --git a/liboctave/DAERT.h b/liboctave/numeric/DAERT.h
rename from liboctave/DAERT.h
rename to liboctave/numeric/DAERT.h
diff --git a/liboctave/DAERTFunc.h b/liboctave/numeric/DAERTFunc.h
rename from liboctave/DAERTFunc.h
rename to liboctave/numeric/DAERTFunc.h
diff --git a/liboctave/DASPK-opts.in b/liboctave/numeric/DASPK-opts.in
rename from liboctave/DASPK-opts.in
rename to liboctave/numeric/DASPK-opts.in
diff --git a/liboctave/DASPK.cc b/liboctave/numeric/DASPK.cc
rename from liboctave/DASPK.cc
rename to liboctave/numeric/DASPK.cc
diff --git a/liboctave/DASPK.h b/liboctave/numeric/DASPK.h
rename from liboctave/DASPK.h
rename to liboctave/numeric/DASPK.h
diff --git a/liboctave/DASRT-opts.in b/liboctave/numeric/DASRT-opts.in
rename from liboctave/DASRT-opts.in
rename to liboctave/numeric/DASRT-opts.in
diff --git a/liboctave/DASRT.cc b/liboctave/numeric/DASRT.cc
rename from liboctave/DASRT.cc
rename to liboctave/numeric/DASRT.cc
diff --git a/liboctave/DASRT.h b/liboctave/numeric/DASRT.h
rename from liboctave/DASRT.h
rename to liboctave/numeric/DASRT.h
diff --git a/liboctave/DASSL-opts.in b/liboctave/numeric/DASSL-opts.in
rename from liboctave/DASSL-opts.in
rename to liboctave/numeric/DASSL-opts.in
diff --git a/liboctave/DASSL.cc b/liboctave/numeric/DASSL.cc
rename from liboctave/DASSL.cc
rename to liboctave/numeric/DASSL.cc
diff --git a/liboctave/DASSL.h b/liboctave/numeric/DASSL.h
rename from liboctave/DASSL.h
rename to liboctave/numeric/DASSL.h
diff --git a/liboctave/DET.h b/liboctave/numeric/DET.h
rename from liboctave/DET.h
rename to liboctave/numeric/DET.h
diff --git a/liboctave/EIG.cc b/liboctave/numeric/EIG.cc
rename from liboctave/EIG.cc
rename to liboctave/numeric/EIG.cc
diff --git a/liboctave/EIG.h b/liboctave/numeric/EIG.h
rename from liboctave/EIG.h
rename to liboctave/numeric/EIG.h
diff --git a/liboctave/LSODE-opts.in b/liboctave/numeric/LSODE-opts.in
rename from liboctave/LSODE-opts.in
rename to liboctave/numeric/LSODE-opts.in
diff --git a/liboctave/LSODE.cc b/liboctave/numeric/LSODE.cc
rename from liboctave/LSODE.cc
rename to liboctave/numeric/LSODE.cc
diff --git a/liboctave/LSODE.h b/liboctave/numeric/LSODE.h
rename from liboctave/LSODE.h
rename to liboctave/numeric/LSODE.h
diff --git a/liboctave/ODE.h b/liboctave/numeric/ODE.h
rename from liboctave/ODE.h
rename to liboctave/numeric/ODE.h
diff --git a/liboctave/ODEFunc.h b/liboctave/numeric/ODEFunc.h
rename from liboctave/ODEFunc.h
rename to liboctave/numeric/ODEFunc.h
diff --git a/liboctave/ODES.cc b/liboctave/numeric/ODES.cc
rename from liboctave/ODES.cc
rename to liboctave/numeric/ODES.cc
diff --git a/liboctave/ODES.h b/liboctave/numeric/ODES.h
rename from liboctave/ODES.h
rename to liboctave/numeric/ODES.h
diff --git a/liboctave/ODESFunc.h b/liboctave/numeric/ODESFunc.h
rename from liboctave/ODESFunc.h
rename to liboctave/numeric/ODESFunc.h
diff --git a/liboctave/Quad-opts.in b/liboctave/numeric/Quad-opts.in
rename from liboctave/Quad-opts.in
rename to liboctave/numeric/Quad-opts.in
diff --git a/liboctave/Quad.cc b/liboctave/numeric/Quad.cc
rename from liboctave/Quad.cc
rename to liboctave/numeric/Quad.cc
diff --git a/liboctave/Quad.h b/liboctave/numeric/Quad.h
rename from liboctave/Quad.h
rename to liboctave/numeric/Quad.h
diff --git a/liboctave/SparseCmplxCHOL.cc b/liboctave/numeric/SparseCmplxCHOL.cc
rename from liboctave/SparseCmplxCHOL.cc
rename to liboctave/numeric/SparseCmplxCHOL.cc
diff --git a/liboctave/SparseCmplxCHOL.h b/liboctave/numeric/SparseCmplxCHOL.h
rename from liboctave/SparseCmplxCHOL.h
rename to liboctave/numeric/SparseCmplxCHOL.h
--- a/liboctave/SparseCmplxCHOL.h
+++ b/liboctave/numeric/SparseCmplxCHOL.h
@@ -33,24 +33,23 @@ OCTAVE_API
 SparseComplexCHOL :
   public sparse_base_chol <SparseComplexMatrix, Complex, SparseMatrix>
 {
 public:
 
   SparseComplexCHOL (void) :
     sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix> () { }
 
-  SparseComplexCHOL (const SparseComplexMatrix& a, bool natural = true) :
-    sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix>
-  (a, natural) { }
+  SparseComplexCHOL (const SparseComplexMatrix& a, bool natural = true,
+                     bool force = false) :
+    sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix> (a, natural, force) { }
 
   SparseComplexCHOL (const SparseComplexMatrix& a, octave_idx_type& info,
-                     bool natural = true) :
-    sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix>
-  (a, info, natural) { }
+                     bool natural = true, bool force = false) :
+    sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix> (a, info, natural, force) { }
 
   SparseComplexCHOL (const SparseComplexCHOL& a) :
     sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix> (a) { }
 
   ~SparseComplexCHOL (void) { }
 
   SparseComplexCHOL& operator = (const SparseComplexCHOL& a)
     {
diff --git a/liboctave/SparseCmplxLU.cc b/liboctave/numeric/SparseCmplxLU.cc
rename from liboctave/SparseCmplxLU.cc
rename to liboctave/numeric/SparseCmplxLU.cc
diff --git a/liboctave/SparseCmplxLU.h b/liboctave/numeric/SparseCmplxLU.h
rename from liboctave/SparseCmplxLU.h
rename to liboctave/numeric/SparseCmplxLU.h
diff --git a/liboctave/SparseCmplxQR.cc b/liboctave/numeric/SparseCmplxQR.cc
rename from liboctave/SparseCmplxQR.cc
rename to liboctave/numeric/SparseCmplxQR.cc
diff --git a/liboctave/SparseCmplxQR.h b/liboctave/numeric/SparseCmplxQR.h
rename from liboctave/SparseCmplxQR.h
rename to liboctave/numeric/SparseCmplxQR.h
diff --git a/liboctave/SparseQR.cc b/liboctave/numeric/SparseQR.cc
rename from liboctave/SparseQR.cc
rename to liboctave/numeric/SparseQR.cc
diff --git a/liboctave/SparseQR.h b/liboctave/numeric/SparseQR.h
rename from liboctave/SparseQR.h
rename to liboctave/numeric/SparseQR.h
diff --git a/liboctave/SparsedbleCHOL.cc b/liboctave/numeric/SparsedbleCHOL.cc
rename from liboctave/SparsedbleCHOL.cc
rename to liboctave/numeric/SparsedbleCHOL.cc
diff --git a/liboctave/SparsedbleCHOL.h b/liboctave/numeric/SparsedbleCHOL.h
rename from liboctave/SparsedbleCHOL.h
rename to liboctave/numeric/SparsedbleCHOL.h
--- a/liboctave/SparsedbleCHOL.h
+++ b/liboctave/numeric/SparsedbleCHOL.h
@@ -30,22 +30,22 @@ along with Octave; see the file COPYING.
 class
 OCTAVE_API
 SparseCHOL : public sparse_base_chol <SparseMatrix, double, SparseMatrix>
 {
 public:
 
   SparseCHOL (void) : sparse_base_chol<SparseMatrix, double, SparseMatrix> () { }
 
-  SparseCHOL (const SparseMatrix& a, bool natural = true) :
-    sparse_base_chol<SparseMatrix, double, SparseMatrix> (a, natural) { }
+  SparseCHOL (const SparseMatrix& a, bool natural = true, bool force = false) :
+    sparse_base_chol<SparseMatrix, double, SparseMatrix> (a, natural, force) { }
 
   SparseCHOL (const SparseMatrix& a, octave_idx_type& info,
-              bool natural = true) :
-    sparse_base_chol<SparseMatrix, double, SparseMatrix> (a, info, natural) { }
+              bool natural = false, bool force = false) :
+    sparse_base_chol<SparseMatrix, double, SparseMatrix> (a, info, natural, force) { }
 
   SparseCHOL (const SparseCHOL& a) :
     sparse_base_chol<SparseMatrix, double, SparseMatrix> (a) { }
 
   ~SparseCHOL (void) { }
 
   SparseCHOL& operator = (const SparseCHOL& a)
     {
diff --git a/liboctave/SparsedbleLU.cc b/liboctave/numeric/SparsedbleLU.cc
rename from liboctave/SparsedbleLU.cc
rename to liboctave/numeric/SparsedbleLU.cc
diff --git a/liboctave/SparsedbleLU.h b/liboctave/numeric/SparsedbleLU.h
rename from liboctave/SparsedbleLU.h
rename to liboctave/numeric/SparsedbleLU.h
diff --git a/liboctave/base-aepbal.h b/liboctave/numeric/base-aepbal.h
rename from liboctave/base-aepbal.h
rename to liboctave/numeric/base-aepbal.h
diff --git a/liboctave/base-dae.h b/liboctave/numeric/base-dae.h
rename from liboctave/base-dae.h
rename to liboctave/numeric/base-dae.h
diff --git a/liboctave/base-de.h b/liboctave/numeric/base-de.h
rename from liboctave/base-de.h
rename to liboctave/numeric/base-de.h
diff --git a/liboctave/base-lu.cc b/liboctave/numeric/base-lu.cc
rename from liboctave/base-lu.cc
rename to liboctave/numeric/base-lu.cc
diff --git a/liboctave/base-lu.h b/liboctave/numeric/base-lu.h
rename from liboctave/base-lu.h
rename to liboctave/numeric/base-lu.h
diff --git a/liboctave/base-min.h b/liboctave/numeric/base-min.h
rename from liboctave/base-min.h
rename to liboctave/numeric/base-min.h
diff --git a/liboctave/base-qr.cc b/liboctave/numeric/base-qr.cc
rename from liboctave/base-qr.cc
rename to liboctave/numeric/base-qr.cc
diff --git a/liboctave/base-qr.h b/liboctave/numeric/base-qr.h
rename from liboctave/base-qr.h
rename to liboctave/numeric/base-qr.h
diff --git a/liboctave/bsxfun-decl.h b/liboctave/numeric/bsxfun-decl.h
rename from liboctave/bsxfun-decl.h
rename to liboctave/numeric/bsxfun-decl.h
diff --git a/liboctave/bsxfun-defs.cc b/liboctave/numeric/bsxfun-defs.cc
rename from liboctave/bsxfun-defs.cc
rename to liboctave/numeric/bsxfun-defs.cc
diff --git a/liboctave/bsxfun.h b/liboctave/numeric/bsxfun.h
rename from liboctave/bsxfun.h
rename to liboctave/numeric/bsxfun.h
diff --git a/liboctave/dbleAEPBAL.cc b/liboctave/numeric/dbleAEPBAL.cc
rename from liboctave/dbleAEPBAL.cc
rename to liboctave/numeric/dbleAEPBAL.cc
diff --git a/liboctave/dbleAEPBAL.h b/liboctave/numeric/dbleAEPBAL.h
rename from liboctave/dbleAEPBAL.h
rename to liboctave/numeric/dbleAEPBAL.h
diff --git a/liboctave/dbleCHOL.cc b/liboctave/numeric/dbleCHOL.cc
rename from liboctave/dbleCHOL.cc
rename to liboctave/numeric/dbleCHOL.cc
diff --git a/liboctave/dbleCHOL.h b/liboctave/numeric/dbleCHOL.h
rename from liboctave/dbleCHOL.h
rename to liboctave/numeric/dbleCHOL.h
diff --git a/liboctave/dbleGEPBAL.cc b/liboctave/numeric/dbleGEPBAL.cc
rename from liboctave/dbleGEPBAL.cc
rename to liboctave/numeric/dbleGEPBAL.cc
diff --git a/liboctave/dbleGEPBAL.h b/liboctave/numeric/dbleGEPBAL.h
rename from liboctave/dbleGEPBAL.h
rename to liboctave/numeric/dbleGEPBAL.h
diff --git a/liboctave/dbleHESS.cc b/liboctave/numeric/dbleHESS.cc
rename from liboctave/dbleHESS.cc
rename to liboctave/numeric/dbleHESS.cc
diff --git a/liboctave/dbleHESS.h b/liboctave/numeric/dbleHESS.h
rename from liboctave/dbleHESS.h
rename to liboctave/numeric/dbleHESS.h
diff --git a/liboctave/dbleLU.cc b/liboctave/numeric/dbleLU.cc
rename from liboctave/dbleLU.cc
rename to liboctave/numeric/dbleLU.cc
--- a/liboctave/dbleLU.cc
+++ b/liboctave/numeric/dbleLU.cc
@@ -28,18 +28,18 @@ along with Octave; see the file COPYING.
 #include "dbleLU.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "oct-locbuf.h"
 #include "dColVector.h"
 
 // Instantiate the base LU class for the types we need.
 
-#include <base-lu.h>
-#include <base-lu.cc>
+#include "base-lu.h"
+#include "base-lu.cc"
 
 template class base_lu <Matrix>;
 
 // Define the constructor for this particular derivation.
 
 extern "C"
 {
   F77_RET_T
diff --git a/liboctave/dbleLU.h b/liboctave/numeric/dbleLU.h
rename from liboctave/dbleLU.h
rename to liboctave/numeric/dbleLU.h
diff --git a/liboctave/dbleQR.cc b/liboctave/numeric/dbleQR.cc
rename from liboctave/dbleQR.cc
rename to liboctave/numeric/dbleQR.cc
diff --git a/liboctave/dbleQR.h b/liboctave/numeric/dbleQR.h
rename from liboctave/dbleQR.h
rename to liboctave/numeric/dbleQR.h
diff --git a/liboctave/dbleQRP.cc b/liboctave/numeric/dbleQRP.cc
rename from liboctave/dbleQRP.cc
rename to liboctave/numeric/dbleQRP.cc
diff --git a/liboctave/dbleQRP.h b/liboctave/numeric/dbleQRP.h
rename from liboctave/dbleQRP.h
rename to liboctave/numeric/dbleQRP.h
diff --git a/liboctave/dbleSCHUR.cc b/liboctave/numeric/dbleSCHUR.cc
rename from liboctave/dbleSCHUR.cc
rename to liboctave/numeric/dbleSCHUR.cc
diff --git a/liboctave/dbleSCHUR.h b/liboctave/numeric/dbleSCHUR.h
rename from liboctave/dbleSCHUR.h
rename to liboctave/numeric/dbleSCHUR.h
diff --git a/liboctave/dbleSVD.cc b/liboctave/numeric/dbleSVD.cc
rename from liboctave/dbleSVD.cc
rename to liboctave/numeric/dbleSVD.cc
diff --git a/liboctave/dbleSVD.h b/liboctave/numeric/dbleSVD.h
rename from liboctave/dbleSVD.h
rename to liboctave/numeric/dbleSVD.h
diff --git a/liboctave/eigs-base.cc b/liboctave/numeric/eigs-base.cc
rename from liboctave/eigs-base.cc
rename to liboctave/numeric/eigs-base.cc
diff --git a/liboctave/fCmplxAEPBAL.cc b/liboctave/numeric/fCmplxAEPBAL.cc
rename from liboctave/fCmplxAEPBAL.cc
rename to liboctave/numeric/fCmplxAEPBAL.cc
diff --git a/liboctave/fCmplxAEPBAL.h b/liboctave/numeric/fCmplxAEPBAL.h
rename from liboctave/fCmplxAEPBAL.h
rename to liboctave/numeric/fCmplxAEPBAL.h
diff --git a/liboctave/fCmplxCHOL.cc b/liboctave/numeric/fCmplxCHOL.cc
rename from liboctave/fCmplxCHOL.cc
rename to liboctave/numeric/fCmplxCHOL.cc
diff --git a/liboctave/fCmplxCHOL.h b/liboctave/numeric/fCmplxCHOL.h
rename from liboctave/fCmplxCHOL.h
rename to liboctave/numeric/fCmplxCHOL.h
diff --git a/liboctave/fCmplxGEPBAL.cc b/liboctave/numeric/fCmplxGEPBAL.cc
rename from liboctave/fCmplxGEPBAL.cc
rename to liboctave/numeric/fCmplxGEPBAL.cc
diff --git a/liboctave/fCmplxGEPBAL.h b/liboctave/numeric/fCmplxGEPBAL.h
rename from liboctave/fCmplxGEPBAL.h
rename to liboctave/numeric/fCmplxGEPBAL.h
diff --git a/liboctave/fCmplxHESS.cc b/liboctave/numeric/fCmplxHESS.cc
rename from liboctave/fCmplxHESS.cc
rename to liboctave/numeric/fCmplxHESS.cc
diff --git a/liboctave/fCmplxHESS.h b/liboctave/numeric/fCmplxHESS.h
rename from liboctave/fCmplxHESS.h
rename to liboctave/numeric/fCmplxHESS.h
diff --git a/liboctave/fCmplxLU.cc b/liboctave/numeric/fCmplxLU.cc
rename from liboctave/fCmplxLU.cc
rename to liboctave/numeric/fCmplxLU.cc
--- a/liboctave/fCmplxLU.cc
+++ b/liboctave/numeric/fCmplxLU.cc
@@ -28,18 +28,18 @@ along with Octave; see the file COPYING.
 #include "fCmplxLU.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "oct-locbuf.h"
 #include "fCColVector.h"
 
 // Instantiate the base LU class for the types we need.
 
-#include <base-lu.h>
-#include <base-lu.cc>
+#include "base-lu.h"
+#include "base-lu.cc"
 
 template class base_lu <FloatComplexMatrix>;
 
 // Define the constructor for this particular derivation.
 
 extern "C"
 {
   F77_RET_T
diff --git a/liboctave/fCmplxLU.h b/liboctave/numeric/fCmplxLU.h
rename from liboctave/fCmplxLU.h
rename to liboctave/numeric/fCmplxLU.h
diff --git a/liboctave/fCmplxQR.cc b/liboctave/numeric/fCmplxQR.cc
rename from liboctave/fCmplxQR.cc
rename to liboctave/numeric/fCmplxQR.cc
diff --git a/liboctave/fCmplxQR.h b/liboctave/numeric/fCmplxQR.h
rename from liboctave/fCmplxQR.h
rename to liboctave/numeric/fCmplxQR.h
diff --git a/liboctave/fCmplxQRP.cc b/liboctave/numeric/fCmplxQRP.cc
rename from liboctave/fCmplxQRP.cc
rename to liboctave/numeric/fCmplxQRP.cc
diff --git a/liboctave/fCmplxQRP.h b/liboctave/numeric/fCmplxQRP.h
rename from liboctave/fCmplxQRP.h
rename to liboctave/numeric/fCmplxQRP.h
diff --git a/liboctave/fCmplxSCHUR.cc b/liboctave/numeric/fCmplxSCHUR.cc
rename from liboctave/fCmplxSCHUR.cc
rename to liboctave/numeric/fCmplxSCHUR.cc
diff --git a/liboctave/fCmplxSCHUR.h b/liboctave/numeric/fCmplxSCHUR.h
rename from liboctave/fCmplxSCHUR.h
rename to liboctave/numeric/fCmplxSCHUR.h
diff --git a/liboctave/fCmplxSVD.cc b/liboctave/numeric/fCmplxSVD.cc
rename from liboctave/fCmplxSVD.cc
rename to liboctave/numeric/fCmplxSVD.cc
diff --git a/liboctave/fCmplxSVD.h b/liboctave/numeric/fCmplxSVD.h
rename from liboctave/fCmplxSVD.h
rename to liboctave/numeric/fCmplxSVD.h
diff --git a/liboctave/fEIG.cc b/liboctave/numeric/fEIG.cc
rename from liboctave/fEIG.cc
rename to liboctave/numeric/fEIG.cc
diff --git a/liboctave/fEIG.h b/liboctave/numeric/fEIG.h
rename from liboctave/fEIG.h
rename to liboctave/numeric/fEIG.h
diff --git a/liboctave/floatAEPBAL.cc b/liboctave/numeric/floatAEPBAL.cc
rename from liboctave/floatAEPBAL.cc
rename to liboctave/numeric/floatAEPBAL.cc
diff --git a/liboctave/floatAEPBAL.h b/liboctave/numeric/floatAEPBAL.h
rename from liboctave/floatAEPBAL.h
rename to liboctave/numeric/floatAEPBAL.h
diff --git a/liboctave/floatCHOL.cc b/liboctave/numeric/floatCHOL.cc
rename from liboctave/floatCHOL.cc
rename to liboctave/numeric/floatCHOL.cc
diff --git a/liboctave/floatCHOL.h b/liboctave/numeric/floatCHOL.h
rename from liboctave/floatCHOL.h
rename to liboctave/numeric/floatCHOL.h
diff --git a/liboctave/floatGEPBAL.cc b/liboctave/numeric/floatGEPBAL.cc
rename from liboctave/floatGEPBAL.cc
rename to liboctave/numeric/floatGEPBAL.cc
diff --git a/liboctave/floatGEPBAL.h b/liboctave/numeric/floatGEPBAL.h
rename from liboctave/floatGEPBAL.h
rename to liboctave/numeric/floatGEPBAL.h
diff --git a/liboctave/floatHESS.cc b/liboctave/numeric/floatHESS.cc
rename from liboctave/floatHESS.cc
rename to liboctave/numeric/floatHESS.cc
diff --git a/liboctave/floatHESS.h b/liboctave/numeric/floatHESS.h
rename from liboctave/floatHESS.h
rename to liboctave/numeric/floatHESS.h
diff --git a/liboctave/floatLU.cc b/liboctave/numeric/floatLU.cc
rename from liboctave/floatLU.cc
rename to liboctave/numeric/floatLU.cc
--- a/liboctave/floatLU.cc
+++ b/liboctave/numeric/floatLU.cc
@@ -28,18 +28,18 @@ along with Octave; see the file COPYING.
 #include "floatLU.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "oct-locbuf.h"
 #include "fColVector.h"
 
 // Instantiate the base LU class for the types we need.
 
-#include <base-lu.h>
-#include <base-lu.cc>
+#include "base-lu.h"
+#include "base-lu.cc"
 
 template class base_lu <FloatMatrix>;
 
 // Define the constructor for this particular derivation.
 
 extern "C"
 {
   F77_RET_T
diff --git a/liboctave/floatLU.h b/liboctave/numeric/floatLU.h
rename from liboctave/floatLU.h
rename to liboctave/numeric/floatLU.h
diff --git a/liboctave/floatQR.cc b/liboctave/numeric/floatQR.cc
rename from liboctave/floatQR.cc
rename to liboctave/numeric/floatQR.cc
diff --git a/liboctave/floatQR.h b/liboctave/numeric/floatQR.h
rename from liboctave/floatQR.h
rename to liboctave/numeric/floatQR.h
diff --git a/liboctave/floatQRP.cc b/liboctave/numeric/floatQRP.cc
rename from liboctave/floatQRP.cc
rename to liboctave/numeric/floatQRP.cc
diff --git a/liboctave/floatQRP.h b/liboctave/numeric/floatQRP.h
rename from liboctave/floatQRP.h
rename to liboctave/numeric/floatQRP.h
diff --git a/liboctave/floatSCHUR.cc b/liboctave/numeric/floatSCHUR.cc
rename from liboctave/floatSCHUR.cc
rename to liboctave/numeric/floatSCHUR.cc
diff --git a/liboctave/floatSCHUR.h b/liboctave/numeric/floatSCHUR.h
rename from liboctave/floatSCHUR.h
rename to liboctave/numeric/floatSCHUR.h
diff --git a/liboctave/floatSVD.cc b/liboctave/numeric/floatSVD.cc
rename from liboctave/floatSVD.cc
rename to liboctave/numeric/floatSVD.cc
diff --git a/liboctave/floatSVD.h b/liboctave/numeric/floatSVD.h
rename from liboctave/floatSVD.h
rename to liboctave/numeric/floatSVD.h
diff --git a/liboctave/lo-mappers.cc b/liboctave/numeric/lo-mappers.cc
rename from liboctave/lo-mappers.cc
rename to liboctave/numeric/lo-mappers.cc
--- a/liboctave/lo-mappers.cc
+++ b/liboctave/numeric/lo-mappers.cc
@@ -274,20 +274,25 @@ xtrunc (float x)
 }
 
 float
 xcopysign (float x, float y)
 {
   return gnulib::copysignf (x, y);
 }
 
+float xfloor (float x)
+{
+  return gnulib::floorf (x);
+}
+
 float
 xround (float x)
 {
-  return gnulib::round (x);
+  return gnulib::roundf (x);
 }
 
 float
 xroundb (float x)
 {
   float t = xround (x);
 
   if (fabsf (x - t) == 0.5)
@@ -307,17 +312,19 @@ signum (float x)
     tmp = 1.0;
 
   return xisnan (x) ? octave_Float_NaN : tmp;
 }
 
 float
 xlog2 (float x)
 {
-#if defined (HAVE_LOG2)
+#if defined (HAVE_LOG2F)
+  return log2f (x);
+#elif defined (HAVE_LOG2)
   return log2 (x);
 #else
 #if defined (M_LN2)
   static float ln2 = M_LN2;
 #else
   static float ln2 = log2 (2);
 #endif
 
@@ -335,17 +342,19 @@ xlog2 (const FloatComplex& x)
 #endif
 
   return std::log (x) / ln2;
 }
 
 float
 xexp2 (float x)
 {
-#if defined (HAVE_EXP2)
+#if defined (HAVE_EXP2F)
+  return exp2f (x);
+#elif defined (HAVE_EXP2)
   return exp2 (x);
 #else
 #if defined (M_LN2)
   static float ln2 = M_LN2;
 #else
   static float ln2 = log2 (2);
 #endif
 
diff --git a/liboctave/lo-mappers.h b/liboctave/numeric/lo-mappers.h
rename from liboctave/lo-mappers.h
rename to liboctave/numeric/lo-mappers.h
--- a/liboctave/lo-mappers.h
+++ b/liboctave/numeric/lo-mappers.h
@@ -114,17 +114,17 @@ extern OCTAVE_API bool octave_is_NaN_or_
 
 extern OCTAVE_API Complex xmin (const Complex& x, const Complex& y);
 extern OCTAVE_API Complex xmax (const Complex& x, const Complex& y);
 
 // Single Precision
 extern OCTAVE_API float xtrunc (float x);
 extern OCTAVE_API float xcopysign (float x, float y);
 inline float xceil (float x) { return ceilf (x); }
-inline float xfloor (float x) { return floorf (x); }
+extern OCTAVE_API float xfloor (float x);
 inline float arg (float x) { return atan2f (0.0f, x); }
 inline float conj (float x) { return x; }
 inline float fix (float x) { return xtrunc (x); }
 inline float imag (float) { return 0.0f; }
 inline float real (float x) { return x; }
 extern OCTAVE_API float xround (float x);
 extern OCTAVE_API float xroundb (float x);
 extern OCTAVE_API float signum (float x);
@@ -396,9 +396,16 @@ xrem (T x, T y)
     }
 
   if (x != y && y != 0 && retval != 0)
     retval = xcopysign (retval, x);
 
   return retval;
 }
 
+template <typename T>
+T
+xsignbit (T x)
+{
+  return signbit (x);
+}
+
 #endif
diff --git a/liboctave/lo-specfun.cc b/liboctave/numeric/lo-specfun.cc
rename from liboctave/lo-specfun.cc
rename to liboctave/numeric/lo-specfun.cc
diff --git a/liboctave/lo-specfun.h b/liboctave/numeric/lo-specfun.h
rename from liboctave/lo-specfun.h
rename to liboctave/numeric/lo-specfun.h
diff --git a/liboctave/numeric/module.mk b/liboctave/numeric/module.mk
new file mode 100644
--- /dev/null
+++ b/liboctave/numeric/module.mk
@@ -0,0 +1,184 @@
+EXTRA_DIST += \
+  numeric/module.mk \
+  $(OPT_IN)
+
+OPT_INC = \
+  numeric/DASPK-opts.h \
+  numeric/DASRT-opts.h \
+  numeric/DASSL-opts.h \
+  numeric/LSODE-opts.h \
+  numeric/Quad-opts.h
+
+OPT_IN = $(OPT_INC:.h=.in)
+
+NUMERIC_INC = \
+  numeric/base-aepbal.h \
+  numeric/base-dae.h \
+  numeric/base-de.h \
+  numeric/base-lu.h \
+  numeric/base-min.h \
+  numeric/base-qr.h \
+  numeric/bsxfun-decl.h \
+  numeric/bsxfun.h \
+  numeric/CmplxAEPBAL.h \
+  numeric/CmplxCHOL.h \
+  numeric/CmplxGEPBAL.h \
+  numeric/CmplxHESS.h \
+  numeric/CmplxLU.h \
+  numeric/CmplxQR.h \
+  numeric/CmplxQRP.h \
+  numeric/CmplxSCHUR.h \
+  numeric/CmplxSVD.h \
+  numeric/CollocWt.h \
+  numeric/DAEFunc.h \
+  numeric/DAE.h \
+  numeric/DAERTFunc.h \
+  numeric/DAERT.h \
+  numeric/DASPK.h \
+  numeric/DASRT.h \
+  numeric/DASSL.h \
+  numeric/dbleAEPBAL.h \
+  numeric/dbleCHOL.h \
+  numeric/dbleGEPBAL.h \
+  numeric/dbleHESS.h \
+  numeric/dbleLU.h \
+  numeric/dbleQR.h \
+  numeric/dbleQRP.h \
+  numeric/dbleSCHUR.h \
+  numeric/dbleSVD.h \
+  numeric/DET.h \
+  numeric/EIG.h \
+  numeric/fCmplxAEPBAL.h \
+  numeric/fCmplxCHOL.h \
+  numeric/fCmplxGEPBAL.h \
+  numeric/fCmplxHESS.h \
+  numeric/fCmplxLU.h \
+  numeric/fCmplxQR.h \
+  numeric/fCmplxQRP.h \
+  numeric/fCmplxSCHUR.h \
+  numeric/fCmplxSVD.h \
+  numeric/fEIG.h \
+  numeric/floatAEPBAL.h \
+  numeric/floatCHOL.h \
+  numeric/floatGEPBAL.h \
+  numeric/floatHESS.h \
+  numeric/floatLU.h \
+  numeric/floatQR.h \
+  numeric/floatQRP.h \
+  numeric/floatSCHUR.h \
+  numeric/floatSVD.h \
+  numeric/lo-mappers.h \
+  numeric/lo-specfun.h \
+  numeric/LSODE.h \
+  numeric/oct-convn.h \
+  numeric/oct-fftw.h \
+  numeric/oct-norm.h \
+  numeric/oct-rand.h \
+  numeric/oct-spparms.h \
+  numeric/ODEFunc.h \
+  numeric/ODE.h \
+  numeric/ODESFunc.h \
+  numeric/ODES.h \
+  numeric/Quad.h \
+  numeric/randgamma.h \
+  numeric/randmtzig.h \
+  numeric/randpoisson.h \
+  numeric/sparse-base-chol.h \
+  numeric/sparse-base-lu.h \
+  numeric/SparseCmplxCHOL.h \
+  numeric/SparseCmplxLU.h \
+  numeric/SparseCmplxQR.h \
+  numeric/SparsedbleCHOL.h \
+  numeric/SparsedbleLU.h \
+  numeric/SparseQR.h 
+
+NUMERIC_C_SRC = \
+  numeric/randgamma.c \
+  numeric/randmtzig.c \
+  numeric/randpoisson.c
+
+NUMERIC_SRC = \
+  numeric/CmplxAEPBAL.cc \
+  numeric/CmplxCHOL.cc \
+  numeric/CmplxGEPBAL.cc \
+  numeric/CmplxHESS.cc \
+  numeric/CmplxLU.cc \
+  numeric/CmplxQR.cc \
+  numeric/CmplxQRP.cc \
+  numeric/CmplxSCHUR.cc \
+  numeric/CmplxSVD.cc \
+  numeric/CollocWt.cc \
+  numeric/DASPK.cc \
+  numeric/DASRT.cc \
+  numeric/DASSL.cc \
+  numeric/dbleAEPBAL.cc \
+  numeric/dbleCHOL.cc \
+  numeric/dbleGEPBAL.cc \
+  numeric/dbleHESS.cc \
+  numeric/dbleLU.cc \
+  numeric/dbleQR.cc \
+  numeric/dbleQRP.cc \
+  numeric/dbleSCHUR.cc \
+  numeric/dbleSVD.cc \
+  numeric/EIG.cc \
+  numeric/fCmplxAEPBAL.cc \
+  numeric/fCmplxCHOL.cc \
+  numeric/fCmplxGEPBAL.cc \
+  numeric/fCmplxHESS.cc \
+  numeric/fCmplxLU.cc \
+  numeric/fCmplxQR.cc \
+  numeric/fCmplxQRP.cc \
+  numeric/fCmplxSCHUR.cc \
+  numeric/fCmplxSVD.cc \
+  numeric/fEIG.cc \
+  numeric/floatAEPBAL.cc \
+  numeric/floatCHOL.cc \
+  numeric/floatGEPBAL.cc \
+  numeric/floatHESS.cc \
+  numeric/floatLU.cc \
+  numeric/floatQR.cc \
+  numeric/floatQRP.cc \
+  numeric/floatSCHUR.cc \
+  numeric/floatSVD.cc \
+  numeric/lo-mappers.cc \
+  numeric/lo-specfun.cc \
+  numeric/LSODE.cc \
+  numeric/oct-convn.cc \
+  numeric/oct-fftw.cc \
+  numeric/oct-norm.cc \
+  numeric/oct-rand.cc \
+  numeric/oct-spparms.cc \
+  numeric/ODES.cc \
+  numeric/Quad.cc \
+  numeric/SparseCmplxCHOL.cc \
+  numeric/SparseCmplxLU.cc \
+  numeric/SparseCmplxQR.cc \
+  numeric/SparsedbleCHOL.cc \
+  numeric/SparsedbleLU.cc \
+  numeric/SparseQR.cc \
+  $(NUMERIC_C_SRC)
+
+TEMPLATE_SRC += \
+  numeric/base-lu.cc \
+  numeric/base-qr.cc \
+  numeric/bsxfun-defs.cc \
+  numeric/eigs-base.cc \
+  numeric/sparse-base-chol.cc \
+  numeric/sparse-base-lu.cc \
+  numeric/sparse-dmsolve.cc
+
+## Special rules for sources which must be built before rest of compilation.
+$(OPT_INC) : %.h : %.in $(top_srcdir)/build-aux/mk-opts.pl
+	@echo making $@ from $<
+	@$(PERL) $(top_srcdir)/build-aux/mk-opts.pl --opt-class-header $< > $@-t
+	mv $@-t $@
+
+noinst_LTLIBRARIES += numeric/libnumeric.la
+
+numeric_libnumeric_la_SOURCES = $(NUMERIC_SRC)
+numeric_libnumeric_la_CPPFLAGS = \
+  $(liboctave_la_CPPFLAGS) \
+  $(ARPACK_CPPFLAGS) \
+  $(FFTW_XCPPFLAGS) \
+  $(SPARSE_XCPPFLAGS)
+
diff --git a/liboctave/oct-convn.cc b/liboctave/numeric/oct-convn.cc
rename from liboctave/oct-convn.cc
rename to liboctave/numeric/oct-convn.cc
diff --git a/liboctave/oct-convn.h b/liboctave/numeric/oct-convn.h
rename from liboctave/oct-convn.h
rename to liboctave/numeric/oct-convn.h
diff --git a/liboctave/oct-fftw.cc b/liboctave/numeric/oct-fftw.cc
rename from liboctave/oct-fftw.cc
rename to liboctave/numeric/oct-fftw.cc
diff --git a/liboctave/oct-fftw.h b/liboctave/numeric/oct-fftw.h
rename from liboctave/oct-fftw.h
rename to liboctave/numeric/oct-fftw.h
diff --git a/liboctave/oct-norm.cc b/liboctave/numeric/oct-norm.cc
rename from liboctave/oct-norm.cc
rename to liboctave/numeric/oct-norm.cc
diff --git a/liboctave/oct-norm.h b/liboctave/numeric/oct-norm.h
rename from liboctave/oct-norm.h
rename to liboctave/numeric/oct-norm.h
diff --git a/liboctave/oct-rand.cc b/liboctave/numeric/oct-rand.cc
rename from liboctave/oct-rand.cc
rename to liboctave/numeric/oct-rand.cc
--- a/liboctave/oct-rand.cc
+++ b/liboctave/numeric/oct-rand.cc
@@ -653,17 +653,17 @@ octave_rand::get_dist_id (const std::str
   else if (d == "exponential" || d == "rande")
     retval = expon_dist;
   else if (d == "poisson" || d == "randp")
     retval = poisson_dist;
   else if (d == "gamma" || d == "randg")
     retval = gamma_dist;
   else
     (*current_liboctave_error_handler)
-      ("rand: invalid distribution `%s'", d.c_str ());
+      ("rand: invalid distribution '%s'", d.c_str ());
 
   return retval;
 }
 
 void
 octave_rand::set_internal_state (const ColumnVector& s)
 {
   octave_idx_type len = s.length ();
diff --git a/liboctave/oct-rand.h b/liboctave/numeric/oct-rand.h
rename from liboctave/oct-rand.h
rename to liboctave/numeric/oct-rand.h
diff --git a/liboctave/oct-spparms.cc b/liboctave/numeric/oct-spparms.cc
rename from liboctave/oct-spparms.cc
rename to liboctave/numeric/oct-spparms.cc
diff --git a/liboctave/oct-spparms.h b/liboctave/numeric/oct-spparms.h
rename from liboctave/oct-spparms.h
rename to liboctave/numeric/oct-spparms.h
diff --git a/liboctave/randgamma.c b/liboctave/numeric/randgamma.c
rename from liboctave/randgamma.c
rename to liboctave/numeric/randgamma.c
diff --git a/liboctave/randgamma.h b/liboctave/numeric/randgamma.h
rename from liboctave/randgamma.h
rename to liboctave/numeric/randgamma.h
diff --git a/liboctave/randmtzig.c b/liboctave/numeric/randmtzig.c
rename from liboctave/randmtzig.c
rename to liboctave/numeric/randmtzig.c
--- a/liboctave/randmtzig.c
+++ b/liboctave/numeric/randmtzig.c
@@ -255,17 +255,17 @@ oct_init_by_array (uint32_t *init_key, i
 
 void
 oct_init_by_entropy (void)
 {
     uint32_t entropy[MT_N];
     int n = 0;
 
     /* Look for entropy in /dev/urandom */
-    FILE* urandom =fopen ("/dev/urandom", "rb");
+    FILE* urandom = fopen ("/dev/urandom", "rb");
     if (urandom)
       {
         while (n < MT_N)
           {
             unsigned char word[4];
             if (fread (word, 4, 1, urandom) != 1)
               break;
             entropy[n++] = word[0]+(word[1]<<8)+(word[2]<<16)+(word[3]<<24);
@@ -395,18 +395,18 @@ randu32 (void)
   return ((float)randi32 () + 0.5) * (1.0/4294967296.0);
   /* divided by 2^32 */
 }
 
 /* generates a random number on (0,1) with 53-bit resolution */
 static double
 randu53 (void)
 {
-  const uint32_t a=randi32 ()>>5;
-  const uint32_t b=randi32 ()>>6;
+  const uint32_t a = randi32 ()>>5;
+  const uint32_t b = randi32 ()>>6;
   return (a*67108864.0+b+0.4) * (1.0/9007199254740992.0);
 }
 
 /* Determine mantissa for uniform doubles */
 double
 oct_randu (void)
 {
   return randu53 ();
@@ -588,17 +588,17 @@ oct_randn (void)
       hi = randi32 ();
       si = hi&UMASK;
       p[0] = lo;
       p[1] = hi&0x1FFFFF;
       x = ( si ? -rabs : rabs ) * wi[idx];
 # else /* !HAVE_X86_32 */
       /* arbitrary mantissa (selected by NRANDI, with 1 bit for sign) */
       const uint64_t r = NRANDI;
-      const int64_t rabs=r>>1;
+      const int64_t rabs = r>>1;
       const int idx = (int)(rabs&0xFF);
       const double x = ( r&1 ? -rabs : rabs) * wi[idx];
 # endif /* !HAVE_X86_32 */
       if (rabs < (int64_t)ki[idx])
         return x;        /* 99.3% of the time we return here 1st try */
       else if (idx == 0)
         {
           /* As stated in Marsaglia and Tsang
diff --git a/liboctave/randmtzig.h b/liboctave/numeric/randmtzig.h
rename from liboctave/randmtzig.h
rename to liboctave/numeric/randmtzig.h
diff --git a/liboctave/randpoisson.c b/liboctave/numeric/randpoisson.c
rename from liboctave/randpoisson.c
rename to liboctave/numeric/randpoisson.c
diff --git a/liboctave/randpoisson.h b/liboctave/numeric/randpoisson.h
rename from liboctave/randpoisson.h
rename to liboctave/numeric/randpoisson.h
diff --git a/liboctave/sparse-base-chol.cc b/liboctave/numeric/sparse-base-chol.cc
rename from liboctave/sparse-base-chol.cc
rename to liboctave/numeric/sparse-base-chol.cc
--- a/liboctave/sparse-base-chol.cc
+++ b/liboctave/numeric/sparse-base-chol.cc
@@ -75,19 +75,20 @@ sparse_base_chol<chol_type, chol_elt, p_
     }
   Sp[ncol] = pdest;
 }
 #endif
 
 template <class chol_type, class chol_elt, class p_type>
 octave_idx_type
 sparse_base_chol<chol_type, chol_elt, p_type>::sparse_base_chol_rep::init
-  (const chol_type& a, bool natural, octave_idx_type nargout)
+  (const chol_type& a, bool natural, bool force)
 {
   volatile octave_idx_type info = 0;
+
 #ifdef HAVE_CHOLMOD
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler)
         ("SparseCHOL requires square matrix");
@@ -165,17 +166,17 @@ sparse_base_chol<chol_type, chol_elt, p_
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   Lfactor = CHOLMOD_NAME(analyze) (ac, cm);
   CHOLMOD_NAME(factorize) (ac, Lfactor, cm);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
   is_pd = cm->status == CHOLMOD_OK;
   info = (is_pd ? 0 : cm->status);
 
-  if (is_pd || nargout > 1)
+  if (is_pd || force)
     {
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       cond = CHOLMOD_NAME(rcond) (Lfactor, cm);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
       minor_p = Lfactor->minor;
 
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
diff --git a/liboctave/sparse-base-chol.h b/liboctave/numeric/sparse-base-chol.h
rename from liboctave/sparse-base-chol.h
rename to liboctave/numeric/sparse-base-chol.h
--- a/liboctave/sparse-base-chol.h
+++ b/liboctave/numeric/sparse-base-chol.h
@@ -36,29 +36,29 @@ protected:
   class sparse_base_chol_rep
   {
   public:
     sparse_base_chol_rep (void)
       : count (1), Lsparse (0), Common (), is_pd (false), minor_p (0),
         perms (), cond (0)
       { }
 
-    sparse_base_chol_rep (const chol_type& a, const bool natural)
+    sparse_base_chol_rep (const chol_type& a, bool natural, bool force)
       : count (1), Lsparse (0), Common (), is_pd (false), minor_p (0),
         perms (), cond (0)
       {
-        init (a, natural);
+        init (a, natural, force);
       }
 
     sparse_base_chol_rep (const chol_type& a, octave_idx_type& info,
-                          const bool natural)
+                          bool natural, bool force)
       : count (1), Lsparse (0), Common (), is_pd (false), minor_p (0),
         perms (), cond (0)
       {
-        info = init (a, natural, info);
+        info = init (a, natural, force);
       }
 
     ~sparse_base_chol_rep (void)
       {
         if (is_pd)
           CHOLMOD_NAME (free_sparse) (&Lsparse, &Common);
       }
 
@@ -88,46 +88,44 @@ protected:
     bool is_pd;
 
     octave_idx_type minor_p;
 
     ColumnVector perms;
 
     double cond;
 
-    octave_idx_type init (const chol_type& a, bool natural = true,
-                          octave_idx_type nargout = 1);
+    octave_idx_type init (const chol_type& a, bool natural, bool force);
 
     void drop_zeros (const cholmod_sparse* S);
 
     // No copying!
 
     sparse_base_chol_rep (const sparse_base_chol_rep&);
 
     sparse_base_chol_rep& operator = (const sparse_base_chol_rep&);
   };
 #else
   class sparse_base_chol_rep
   {
   public:
     sparse_base_chol_rep (void)
       : count (1), is_pd (false), minor_p (0), perms (), cond (0) { }
 
-    sparse_base_chol_rep (const chol_type& a,
-                          const bool natural)
+    sparse_base_chol_rep (const chol_type& a, bool natural, bool force)
       : count (1), is_pd (false), minor_p (0), perms (), cond (0)
       {
-        init (a, natural);
+        init (a, natural, force);
       }
 
     sparse_base_chol_rep (const chol_type& a, octave_idx_type& info,
-                          const bool natural)
+                          bool natural, bool force)
       : count (1), is_pd (false), minor_p (0), perms (), cond (0)
       {
-        info = init (a, natural, info);
+        info = init (a, natural, force);
       }
 
     ~sparse_base_chol_rep (void) { }
 
     octave_idx_type P (void) const { return 0; }
 
     ColumnVector perm (void) const { return perms + 1; }
 
@@ -143,18 +141,17 @@ protected:
     bool is_pd;
 
     octave_idx_type minor_p;
 
     ColumnVector perms;
 
     double cond;
 
-    octave_idx_type init (const chol_type& a, bool natural = true,
-                          octave_idx_type nargout = 0);
+    octave_idx_type init (const chol_type& a, bool natural, bool force);
 
     // No copying!
 
     sparse_base_chol_rep (const sparse_base_chol_rep&);
 
     sparse_base_chol_rep& operator = (const sparse_base_chol_rep&);
   };
 #endif
@@ -164,23 +161,24 @@ protected:
 
 public:
 
   sparse_base_chol (void)
     : rep (new typename
            sparse_base_chol<chol_type, chol_elt, p_type>::sparse_base_chol_rep ())
     { }
 
-  sparse_base_chol (const chol_type& a, const bool n)
+  sparse_base_chol (const chol_type& a, bool natural, bool force)
     : rep (new typename
-           sparse_base_chol<chol_type, chol_elt, p_type>::sparse_base_chol_rep (a, n))
+           sparse_base_chol<chol_type, chol_elt, p_type>::sparse_base_chol_rep (a, natural, force))
     { }
 
-  sparse_base_chol (const chol_type& a, octave_idx_type& info, const bool n)
-    : rep (new typename sparse_base_chol<chol_type, chol_elt, p_type>::sparse_base_chol_rep (a, info, n))
+  sparse_base_chol (const chol_type& a, octave_idx_type& info,
+                    bool natural, bool force)
+    : rep (new typename sparse_base_chol<chol_type, chol_elt, p_type>::sparse_base_chol_rep (a, info, natural, force))
     { }
 
   sparse_base_chol (const sparse_base_chol<chol_type, chol_elt, p_type>& a)
     : rep (a.rep)
     { rep->count++; }
 
   virtual ~sparse_base_chol (void)
     {
diff --git a/liboctave/sparse-base-lu.cc b/liboctave/numeric/sparse-base-lu.cc
rename from liboctave/sparse-base-lu.cc
rename to liboctave/numeric/sparse-base-lu.cc
diff --git a/liboctave/sparse-base-lu.h b/liboctave/numeric/sparse-base-lu.h
rename from liboctave/sparse-base-lu.h
rename to liboctave/numeric/sparse-base-lu.h
diff --git a/liboctave/sparse-dmsolve.cc b/liboctave/numeric/sparse-dmsolve.cc
rename from liboctave/sparse-dmsolve.cc
rename to liboctave/numeric/sparse-dmsolve.cc
--- a/liboctave/sparse-dmsolve.cc
+++ b/liboctave/numeric/sparse-dmsolve.cc
@@ -477,16 +477,18 @@ dmsolve (const ST &a, const T &b, octave
                                          b_nc), info);
           dmsolve_insert (retval, mtmp, q, 0, 0);
         }
 
       CXSPARSE_DNAME (_dfree) (dm);
     }
   return retval;
 #else
+  (*current_liboctave_error_handler)
+    ("CXSPARSE unavailable; cannot solve minimum norm problem");
   return RT ();
 #endif
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 extern Matrix
 dmsolve (const SparseMatrix &a, const Matrix &b,
          octave_idx_type &info);
diff --git a/liboctave/Sparse-diag-op-defs.h b/liboctave/operators/Sparse-diag-op-defs.h
rename from liboctave/Sparse-diag-op-defs.h
rename to liboctave/operators/Sparse-diag-op-defs.h
diff --git a/liboctave/Sparse-op-defs.h b/liboctave/operators/Sparse-op-defs.h
rename from liboctave/Sparse-op-defs.h
rename to liboctave/operators/Sparse-op-defs.h
diff --git a/liboctave/Sparse-perm-op-defs.h b/liboctave/operators/Sparse-perm-op-defs.h
rename from liboctave/Sparse-perm-op-defs.h
rename to liboctave/operators/Sparse-perm-op-defs.h
diff --git a/liboctave/config-ops.sh b/liboctave/operators/config-ops.sh
rename from liboctave/config-ops.sh
rename to liboctave/operators/config-ops.sh
--- a/liboctave/config-ops.sh
+++ b/liboctave/operators/config-ops.sh
@@ -12,24 +12,24 @@ fi
 
 if [ $# -lt 2 ]; then
   obj_type="all"
 else
   obj_type="$2"
 fi
 
 if [ $# -lt 1 ]; then
-  top_srcdir=".."
+  top_srcdir="../.."
 else
   top_srcdir="$1"
 fi
 
 move_if_change="$top_srcdir/build-aux/move-if-change"
 
-liboctave_dir="$top_srcdir/liboctave"
+liboctave_dir="$top_srcdir/liboctave/operators"
 
 mk_ops="$liboctave_dir/mk-ops.awk"
 sparse_mk_ops="$liboctave_dir/sparse-mk-ops.awk"
 
 case "$obj_type" in
   vx | all)
     case "$src_type" in
       inc | all)
diff --git a/liboctave/mk-ops.awk b/liboctave/operators/mk-ops.awk
rename from liboctave/mk-ops.awk
rename to liboctave/operators/mk-ops.awk
--- a/liboctave/mk-ops.awk
+++ b/liboctave/operators/mk-ops.awk
@@ -88,23 +88,23 @@ BEGIN {
           while (NF > n)
             bool_headers[k++] = $(++n);
 
           cc_file = sprintf ("%s-%s-%s.cc", prefix, lhs_tag, rhs_tag);
           h_file = sprintf ("%s-%s-%s.h", prefix, lhs_tag, rhs_tag);
 
           if (list_cc_files)
             {
-              printf (" %s", cc_file);
+              printf (" operators/%s", cc_file);
               next;
             }
 
           if (list_h_files)
             {
-              printf (" %s", h_file);
+              printf (" operators/%s", h_file);
               next;
             }
 
           if (make_inclusive_header)
             {
               printf ("#include \"%s\"\n", h_file);
               next;
             }
diff --git a/liboctave/operators/module.mk b/liboctave/operators/module.mk
new file mode 100644
--- /dev/null
+++ b/liboctave/operators/module.mk
@@ -0,0 +1,69 @@
+EXTRA_DIST += \
+  operators/module.mk \
+  operators/config-ops.sh \
+  operators/mk-ops.awk \
+  operators/mx-op-inc.mk \
+  operators/mx-op-src.mk \
+  operators/mx-ops \
+  operators/smx-op-inc.mk \
+  operators/smx-op-src.mk \
+  operators/sparse-mk-ops.awk \
+  operators/sparse-mx-ops \
+  operators/vx-op-inc.mk \
+  operators/vx-op-src.mk \
+  operators/vx-ops
+
+include operators/vx-op-inc.mk
+include operators/mx-op-inc.mk
+include operators/smx-op-inc.mk
+
+include operators/vx-op-src.mk
+include operators/mx-op-src.mk
+include operators/smx-op-src.mk
+
+BUILT_LIBOPERATORS_SOURCES = \
+  $(MX_OP_SRC) \
+  $(VX_OP_SRC) \
+  $(SMX_OP_SRC)
+
+OPERATORS_INC = \
+  operators/mx-base.h \
+  operators/mx-defs.h \
+  operators/mx-ext.h \
+  operators/mx-op-decl.h \
+  operators/mx-op-defs.h \
+  operators/Sparse-diag-op-defs.h \
+  operators/Sparse-op-defs.h \
+  operators/Sparse-perm-op-defs.h
+
+## There are no distributed source files in this directory
+OPERATORS_SRC =
+
+TEMPLATE_SRC += \
+  operators/mx-inlines.cc
+
+OP_SRCDIR = $(abs_top_srcdir)/liboctave/operators
+
+## Special rules for sources which must be built before rest of compilation.
+$(VX_OP_INC) $(VX_OP_SRC) : operators/mk-ops.awk operators/vx-ops
+	(cd operators; $(AWK) -f $(OP_SRCDIR)/mk-ops.awk prefix=vx $(OP_SRCDIR)/vx-ops)
+
+$(MX_OP_INC) $(MX_OP_SRC) : operators/mk-ops.awk operators/mx-ops
+	(cd operators; $(AWK) -f $(OP_SRCDIR)/mk-ops.awk prefix=mx $(OP_SRCDIR)/mx-ops)
+
+$(SMX_OP_INC) $(SMX_OP_SRC) : operators/sparse-mk-ops.awk operators/sparse-mx-ops
+	(cd operators; $(AWK) -f $(OP_SRCDIR)/sparse-mk-ops.awk prefix=smx $(OP_SRCDIR)/sparse-mx-ops)
+
+operators/mx-ops.h : operators/mk-ops.awk operators/mx-ops
+	$(AWK) -f $(OP_SRCDIR)/mk-ops.awk prefix=mx make_inclusive_header=mx-ops.h $(OP_SRCDIR)/mx-ops > $@-t
+	mv $@-t $@
+
+noinst_LTLIBRARIES += operators/liboperators.la
+
+operators_liboperators_la_SOURCES = $(OPERATORS_SRC)
+nodist_operators_liboperators_la_SOURCES = $(BUILT_LIBOPERATORS_SOURCES)
+
+operators_liboperators_la_CPPFLAGS = $(liboctave_la_CPPFLAGS)
+
+DISTCLEANFILES += $(BUILT_LIBOPERATORS_SOURCES)
+
diff --git a/liboctave/mx-base.h b/liboctave/operators/mx-base.h
rename from liboctave/mx-base.h
rename to liboctave/operators/mx-base.h
diff --git a/liboctave/mx-defs.h b/liboctave/operators/mx-defs.h
rename from liboctave/mx-defs.h
rename to liboctave/operators/mx-defs.h
diff --git a/liboctave/mx-ext.h b/liboctave/operators/mx-ext.h
rename from liboctave/mx-ext.h
rename to liboctave/operators/mx-ext.h
diff --git a/liboctave/mx-inlines.cc b/liboctave/operators/mx-inlines.cc
rename from liboctave/mx-inlines.cc
rename to liboctave/operators/mx-inlines.cc
--- a/liboctave/mx-inlines.cc
+++ b/liboctave/operators/mx-inlines.cc
@@ -1081,17 +1081,17 @@ void mx_inline_diff (const T *v, T *r,
     case 1:
       for (octave_idx_type i = 0; i < m*(n-1); i++)
         r[i] = v[i+m] - v[i];
       break;
     case 2:
       for (octave_idx_type i = 0; i < n-2; i++)
         {
           for (octave_idx_type j = i*m; j < i*m+m; j++)
-            r[j] = (v[j+m+m] - v[j+m]) + (v[j+m] - v[j]);
+            r[j] = (v[j+m+m] - v[j+m]) - (v[j+m] - v[j]);
         }
       break;
     default:
         {
           OCTAVE_LOCAL_BUFFER (T, buf, n-1);
 
           for (octave_idx_type j = 0; j < m; j++)
             {
diff --git a/liboctave/mx-op-decl.h b/liboctave/operators/mx-op-decl.h
rename from liboctave/mx-op-decl.h
rename to liboctave/operators/mx-op-decl.h
diff --git a/liboctave/mx-op-defs.h b/liboctave/operators/mx-op-defs.h
rename from liboctave/mx-op-defs.h
rename to liboctave/operators/mx-op-defs.h
diff --git a/liboctave/mx-ops b/liboctave/operators/mx-ops
rename from liboctave/mx-ops
rename to liboctave/operators/mx-ops
--- a/liboctave/mx-ops
+++ b/liboctave/operators/mx-ops
@@ -11,17 +11,17 @@
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
 # 
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
-# NOTE: if this file changes, you must run autogen.sh and configure to
+# NOTE: if this file changes, you must run bootstrap and configure to
 # rebuild the source file lists for Make.
 
 # types
 #
 # key typename object-type header fwd-decl-ok scalar-zero core-type
 #
 # object-type is one of
 #
diff --git a/liboctave/sparse-mk-ops.awk b/liboctave/operators/sparse-mk-ops.awk
rename from liboctave/sparse-mk-ops.awk
rename to liboctave/operators/sparse-mk-ops.awk
--- a/liboctave/sparse-mk-ops.awk
+++ b/liboctave/operators/sparse-mk-ops.awk
@@ -87,23 +87,23 @@ BEGIN {
           while (NF > n)
             bool_headers[k++] = $(++n);
 
           cc_file = sprintf ("%s-%s-%s.cc", prefix, lhs_tag, rhs_tag);
           h_file = sprintf ("%s-%s-%s.h", prefix, lhs_tag, rhs_tag);
 
           if (list_cc_files)
             {
-              printf (" %s", cc_file);
+              printf (" operators/%s", cc_file);
               next;
             }
 
           if (list_h_files)
             {
-              printf (" %s", h_file);
+              printf (" operators/%s", h_file);
               next;
             }
 
           if (make_inclusive_header)
             {
               printf ("#include \"%s\"\n", h_file);
               next;
             }
diff --git a/liboctave/sparse-mx-ops b/liboctave/operators/sparse-mx-ops
rename from liboctave/sparse-mx-ops
rename to liboctave/operators/sparse-mx-ops
--- a/liboctave/sparse-mx-ops
+++ b/liboctave/operators/sparse-mx-ops
@@ -11,17 +11,17 @@
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
 # 
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
-# NOTE: if this file changes, you must run autogen.sh and configure to
+# NOTE: if this file changes, you must run bootstrap and configure to
 # rebuild the source file lists for Make.
 
 # types
 #
 # key typename object-type header fwd-decl-ok scalar-zero
 #
 #   S:  scalar
 #   M:  matrix
diff --git a/liboctave/vx-ops b/liboctave/operators/vx-ops
rename from liboctave/vx-ops
rename to liboctave/operators/vx-ops
--- a/liboctave/vx-ops
+++ b/liboctave/operators/vx-ops
@@ -11,17 +11,17 @@
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
 # 
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
-# NOTE: if this file changes, you must run autogen.sh and configure to
+# NOTE: if this file changes, you must run bootstrap and configure to
 # rebuild the source file lists for Make.
 
 # types
 ccv ComplexColumnVector V CColVector.h YES 0.0
 crv ComplexRowVector V CRowVector.h YES 0.0
 cs Complex S oct-cmplx.h NO 0.0
 cv ColumnVector V dColVector.h YES 0.0
 rv RowVector V dRowVector.h YES 0.0
diff --git a/liboctave/dir-ops.cc b/liboctave/system/dir-ops.cc
rename from liboctave/dir-ops.cc
rename to liboctave/system/dir-ops.cc
diff --git a/liboctave/dir-ops.h b/liboctave/system/dir-ops.h
rename from liboctave/dir-ops.h
rename to liboctave/system/dir-ops.h
diff --git a/liboctave/file-ops.cc b/liboctave/system/file-ops.cc
rename from liboctave/file-ops.cc
rename to liboctave/system/file-ops.cc
--- a/liboctave/file-ops.cc
+++ b/liboctave/system/file-ops.cc
@@ -32,16 +32,17 @@ along with Octave; see the file COPYING.
 #include <iostream>
 #include <vector>
 
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <unistd.h>
 
 #include "pathmax.h"
+#include "canonicalize.h"
 
 #include "dir-ops.h"
 #include "file-ops.h"
 #include "file-stat.h"
 #include "oct-env.h"
 #include "oct-locbuf.h"
 #include "oct-passwd.h"
 #include "pathlen.h"
@@ -112,23 +113,23 @@ file_ops::tilde_expansion_hook file_ops:
 // If non-null, this contains the address of a function to call if the
 // standard meaning for expanding a tilde fails.  The function is
 // called with the text (sans tilde, as in "foo"), and returns a
 // malloc()'ed string which is the expansion, or a NULL pointer if
 // there is no expansion.
 file_ops::tilde_expansion_hook file_ops::tilde_expansion_failure_hook = 0;
 
 // When non-null, this is a NULL terminated array of strings which are
-// duplicates for a tilde prefix.  Bash uses this to expand `=~' and
-// `:~'.
+// duplicates for a tilde prefix.  Bash uses this to expand '=~' and
+// ':~'.
 string_vector file_ops::tilde_additional_prefixes = default_prefixes;
 
 // When non-null, this is a NULL terminated array of strings which
 // match the end of a username, instead of just "/".  Bash sets this
-// to `:' and `=~'.
+// to ':' and '=~'.
 string_vector file_ops::tilde_additional_suffixes = default_suffixes;
 
 // Find the start of a tilde expansion in S, and return the index
 // of the tilde which starts the expansion.  Place the length of the
 // text which identified this tilde starter in LEN, excluding the
 // tilde itself.
 
 static size_t
@@ -216,17 +217,17 @@ isolate_tilde_prefix (const std::string&
 static std::string
 tilde_expand_word (const std::string& filename)
 {
   size_t f_len = filename.length ();
 
   if (f_len == 0 || filename[0] != '~')
     return filename;
 
-  // A leading `~/' or a bare `~' is *always* translated to the value
+  // A leading '~/' or a bare '~' is *always* translated to the value
   // of $HOME or the home directory of the current user, regardless of
   // any preexpansion hook.
 
   if (f_len == 1 || file_ops::is_dir_sep (filename[1]))
     return octave_env::get_home_directory () + filename.substr (1);
 
   std::string username = isolate_tilde_prefix (filename);
 
diff --git a/liboctave/file-ops.h b/liboctave/system/file-ops.h
rename from liboctave/file-ops.h
rename to liboctave/system/file-ops.h
diff --git a/liboctave/file-stat.cc b/liboctave/system/file-stat.cc
rename from liboctave/file-stat.cc
rename to liboctave/system/file-stat.cc
diff --git a/liboctave/file-stat.h b/liboctave/system/file-stat.h
rename from liboctave/file-stat.h
rename to liboctave/system/file-stat.h
diff --git a/liboctave/lo-sysdep.cc b/liboctave/system/lo-sysdep.cc
rename from liboctave/lo-sysdep.cc
rename to liboctave/system/lo-sysdep.cc
diff --git a/liboctave/lo-sysdep.h b/liboctave/system/lo-sysdep.h
rename from liboctave/lo-sysdep.h
rename to liboctave/system/lo-sysdep.h
diff --git a/liboctave/mach-info.cc b/liboctave/system/mach-info.cc
rename from liboctave/mach-info.cc
rename to liboctave/system/mach-info.cc
diff --git a/liboctave/mach-info.h b/liboctave/system/mach-info.h
rename from liboctave/mach-info.h
rename to liboctave/system/mach-info.h
diff --git a/liboctave/system/module.mk b/liboctave/system/module.mk
new file mode 100644
--- /dev/null
+++ b/liboctave/system/module.mk
@@ -0,0 +1,43 @@
+EXTRA_DIST += \
+  system/module.mk
+
+SYSTEM_INC = \
+  system/dir-ops.h \
+  system/file-ops.h \
+  system/file-stat.h \
+  system/lo-sysdep.h \
+  system/mach-info.h \
+  system/oct-env.h \
+  system/oct-group.h \
+  system/oct-openmp.h \
+  system/oct-passwd.h \
+  system/oct-syscalls.h \
+  system/oct-time.h \
+  system/oct-uname.h \
+  system/pathlen.h \
+  system/sysdir.h \
+  system/syswait.h
+
+SYSTEM_C_SRC = \
+  system/tempnam.c \
+  system/tempname.c
+
+SYSTEM_SRC = \
+  system/dir-ops.cc \
+  system/file-ops.cc \
+  system/file-stat.cc \
+  system/lo-sysdep.cc \
+  system/mach-info.cc \
+  system/oct-env.cc \
+  system/oct-group.cc \
+  system/oct-passwd.cc \
+  system/oct-syscalls.cc \
+  system/oct-time.cc \
+  system/oct-uname.cc \
+  $(SYSTEM_C_SRC)
+
+noinst_LTLIBRARIES += system/libsystem.la
+
+system_libsystem_la_SOURCES = $(SYSTEM_SRC)
+system_libsystem_la_CPPFLAGS = $(liboctave_la_CPPFLAGS)
+
diff --git a/liboctave/oct-env.cc b/liboctave/system/oct-env.cc
rename from liboctave/oct-env.cc
rename to liboctave/system/oct-env.cc
--- a/liboctave/oct-env.cc
+++ b/liboctave/system/oct-env.cc
@@ -229,17 +229,17 @@ octave_env::do_set_program_name (const s
     = prog_invocation_name.find_last_of (file_ops::dir_sep_chars ());
 
   // Also keep a shortened version of the program name.
   prog_name = (pos == std::string::npos)
     ? prog_invocation_name : prog_invocation_name.substr (pos+1);
 }
 
 // Return a pretty pathname.  If the first part of the pathname is the
-// same as $HOME, then replace that with `~'.
+// same as $HOME, then replace that with '~'.
 
 std::string
 octave_env::do_polite_directory_format (const std::string& name) const
 {
   std::string retval;
 
   std::string home_dir = do_get_home_directory ();
 
@@ -296,17 +296,17 @@ octave_env::do_rooted_relative_pathname 
     return true;
 
   if (len > 2 && s[0] == '.' && s[1] == '.' && file_ops::is_dir_sep (s[2]))
     return true;
 
   return false;
 }
 
-// Return the `basename' of the pathname in STRING (the stuff after
+// Return the 'basename' of the pathname in STRING (the stuff after
 // the last directory separator).  If STRING is not a full pathname,
 // simply return it.
 
 std::string
 octave_env::do_base_pathname (const std::string& s) const
 {
   if (! (do_absolute_pathname (s) || do_rooted_relative_pathname (s)))
     return s;
diff --git a/liboctave/oct-env.h b/liboctave/system/oct-env.h
rename from liboctave/oct-env.h
rename to liboctave/system/oct-env.h
diff --git a/liboctave/oct-group.cc b/liboctave/system/oct-group.cc
rename from liboctave/oct-group.cc
rename to liboctave/system/oct-group.cc
diff --git a/liboctave/oct-group.h b/liboctave/system/oct-group.h
rename from liboctave/oct-group.h
rename to liboctave/system/oct-group.h
diff --git a/liboctave/oct-openmp.h b/liboctave/system/oct-openmp.h
rename from liboctave/oct-openmp.h
rename to liboctave/system/oct-openmp.h
diff --git a/liboctave/oct-passwd.cc b/liboctave/system/oct-passwd.cc
rename from liboctave/oct-passwd.cc
rename to liboctave/system/oct-passwd.cc
diff --git a/liboctave/oct-passwd.h b/liboctave/system/oct-passwd.h
rename from liboctave/oct-passwd.h
rename to liboctave/system/oct-passwd.h
diff --git a/liboctave/oct-syscalls.cc b/liboctave/system/oct-syscalls.cc
rename from liboctave/oct-syscalls.cc
rename to liboctave/system/oct-syscalls.cc
diff --git a/liboctave/oct-syscalls.h b/liboctave/system/oct-syscalls.h
rename from liboctave/oct-syscalls.h
rename to liboctave/system/oct-syscalls.h
diff --git a/liboctave/oct-time.cc b/liboctave/system/oct-time.cc
rename from liboctave/oct-time.cc
rename to liboctave/system/oct-time.cc
diff --git a/liboctave/oct-time.h b/liboctave/system/oct-time.h
rename from liboctave/oct-time.h
rename to liboctave/system/oct-time.h
diff --git a/liboctave/oct-uname.cc b/liboctave/system/oct-uname.cc
rename from liboctave/oct-uname.cc
rename to liboctave/system/oct-uname.cc
diff --git a/liboctave/oct-uname.h b/liboctave/system/oct-uname.h
rename from liboctave/oct-uname.h
rename to liboctave/system/oct-uname.h
diff --git a/liboctave/pathlen.h b/liboctave/system/pathlen.h
rename from liboctave/pathlen.h
rename to liboctave/system/pathlen.h
diff --git a/liboctave/sysdir.h b/liboctave/system/sysdir.h
rename from liboctave/sysdir.h
rename to liboctave/system/sysdir.h
diff --git a/liboctave/syswait.h b/liboctave/system/syswait.h
rename from liboctave/syswait.h
rename to liboctave/system/syswait.h
diff --git a/liboctave/tempnam.c b/liboctave/system/tempnam.c
rename from liboctave/tempnam.c
rename to liboctave/system/tempnam.c
diff --git a/liboctave/tempname.c b/liboctave/system/tempname.c
rename from liboctave/tempname.c
rename to liboctave/system/tempname.c
diff --git a/liboctave/base-list.h b/liboctave/util/base-list.h
rename from liboctave/base-list.h
rename to liboctave/util/base-list.h
diff --git a/liboctave/byte-swap.h b/liboctave/util/byte-swap.h
rename from liboctave/byte-swap.h
rename to liboctave/util/byte-swap.h
diff --git a/liboctave/caseless-str.h b/liboctave/util/caseless-str.h
rename from liboctave/caseless-str.h
rename to liboctave/util/caseless-str.h
diff --git a/liboctave/cmd-edit.cc b/liboctave/util/cmd-edit.cc
rename from liboctave/cmd-edit.cc
rename to liboctave/util/cmd-edit.cc
--- a/liboctave/cmd-edit.cc
+++ b/liboctave/util/cmd-edit.cc
@@ -1271,17 +1271,17 @@ command_editor::filename_quoting_desired
 }
 
 // Return a string which will be printed as a prompt.  The string may
 // contain special characters which are decoded as follows:
 //
 //      \a      bell (ascii 07)
 //      \d      the date
 //      \e      escape (ascii 033)
-//      \h      the hostname up to the first `.'
+//      \h      the hostname up to the first '.'
 //      \H      the hostname
 //      \n      CRLF
 //      \r      CR
 //      \s      the name of the shell (program)
 //      \t      the time
 //      \T      the time in 12-hour hh:mm:ss format
 //      \@      the time in 12-hour hh:mm am/pm format
 //      \A      the time in 24-hour hh:mm format
diff --git a/liboctave/cmd-edit.h b/liboctave/util/cmd-edit.h
rename from liboctave/cmd-edit.h
rename to liboctave/util/cmd-edit.h
diff --git a/liboctave/cmd-hist.cc b/liboctave/util/cmd-hist.cc
rename from liboctave/cmd-hist.cc
rename to liboctave/util/cmd-hist.cc
--- a/liboctave/cmd-hist.cc
+++ b/liboctave/util/cmd-hist.cc
@@ -64,16 +64,18 @@ public:
   void do_process_histcontrol (const std::string&);
 
   std::string do_histcontrol (void) const;
 
   void do_add (const std::string&);
 
   void do_remove (int);
 
+  void do_clear (void);
+
   int do_where (void) const;
 
   int do_length (void) const;
 
   int do_max_input_history (void) const;
 
   int do_base (void) const;
 
@@ -196,16 +198,22 @@ gnu_history::do_add (const std::string& 
 }
 
 void
 gnu_history::do_remove (int n)
 {
   ::octave_remove_history (n);
 }
 
+void
+gnu_history::do_clear (void)
+{
+  ::octave_clear_history ();
+}
+
 int
 gnu_history::do_where (void) const
 {
   return ::octave_where_history ();
 }
 
 int
 gnu_history::do_length (void) const
@@ -582,16 +590,23 @@ command_history::add (const std::string&
 
 void
 command_history::remove (int n)
 {
   if (instance_ok ())
     instance->do_remove (n);
 }
 
+void
+command_history::clear (void)
+{
+  if (instance_ok ())
+    instance->do_clear ();
+}
+
 int
 command_history::where (void)
 {
   return (instance_ok ())
     ? instance->do_where () : 0;
 }
 
 int
@@ -802,16 +817,21 @@ command_history::do_add (const std::stri
 {
 }
 
 void
 command_history::do_remove (int)
 {
 }
 
+void
+command_history::do_clear (void)
+{
+}
+
 int
 command_history::do_where (void) const
 {
   return 0;
 }
 
 int
 command_history::do_length (void) const
diff --git a/liboctave/cmd-hist.h b/liboctave/util/cmd-hist.h
rename from liboctave/cmd-hist.h
rename to liboctave/util/cmd-hist.h
--- a/liboctave/cmd-hist.h
+++ b/liboctave/util/cmd-hist.h
@@ -60,16 +60,18 @@ public:
   static void ignore_entries (bool = true);
 
   static bool ignoring_entries (void);
 
   static void add (const std::string&);
 
   static void remove (int);
 
+  static void clear (void);
+
   static int where (void);
 
   static int length (void);
 
   static int max_input_history (void);
 
   static int base (void);
 
@@ -153,16 +155,18 @@ protected:
   virtual void do_ignore_entries (bool);
 
   virtual bool do_ignoring_entries (void) const;
 
   virtual void do_add (const std::string&);
 
   virtual void do_remove (int);
 
+  virtual void do_clear (void);
+
   virtual int do_where (void) const;
 
   virtual int do_length (void) const;
 
   virtual int do_max_input_history (void) const;
 
   virtual int do_base (void) const;
 
diff --git a/liboctave/data-conv.cc b/liboctave/util/data-conv.cc
rename from liboctave/data-conv.cc
rename to liboctave/util/data-conv.cc
--- a/liboctave/data-conv.cc
+++ b/liboctave/util/data-conv.cc
@@ -286,17 +286,17 @@ oct_data_conv::string_to_data_type
           if (s[pos] == '*')
             {
               block_size = atoi (s.c_str ());
               s = s.substr (pos+1);
             }
           else
             {
               (*current_liboctave_error_handler)
-                ("invalid repeat count in `%s'", str.c_str ());
+                ("invalid repeat count in '%s'", str.c_str ());
 
               return;
             }
         }
     }
 
   pos = s.find ('=');
 
@@ -359,17 +359,17 @@ oct_data_conv::string_to_data_type
       if (s[pos] == '*')
         {
           block_size = atoi (s.c_str ());
           s = s.substr (pos+1);
         }
       else
         {
           (*current_liboctave_error_handler)
-            ("invalid repeat count in `%s'", str.c_str ());
+            ("invalid repeat count in '%s'", str.c_str ());
 
           return;
         }
     }
 
   output_type = string_to_data_type (s);
 }
 
@@ -847,17 +847,17 @@ do_double_format_conversion (void *data,
         default:
           gripe_unrecognized_float_fmt ();
           break;
         }
       break;
 
     default:
       (*current_liboctave_error_handler)
-        ("impossible state reached in file `%s' at line %d",
+        ("impossible state reached in file '%s' at line %d",
          __FILE__, __LINE__);
       break;
     }
 }
 
 void
 do_float_format_conversion (void *data, octave_idx_type len,
                             oct_mach_info::float_format from_fmt,
@@ -974,17 +974,17 @@ do_float_format_conversion (void *data, 
         default:
           gripe_unrecognized_float_fmt ();
           break;
         }
       break;
 
     default:
       (*current_liboctave_error_handler)
-        ("impossible state reached in file `%s' at line %d",
+        ("impossible state reached in file '%s' at line %d",
          __FILE__, __LINE__);
       break;
     }
 }
 
 void
 do_float_format_conversion (void *data, size_t sz, octave_idx_type len,
                             oct_mach_info::float_format from_fmt,
@@ -997,17 +997,17 @@ do_float_format_conversion (void *data, 
       break;
 
     case sizeof (double):
       do_double_format_conversion (data, len, from_fmt, to_fmt);
       break;
 
     default:
       (*current_liboctave_error_handler)
-        ("impossible state reached in file `%s' at line %d",
+        ("impossible state reached in file '%s' at line %d",
          __FILE__, __LINE__);
       break;
     }
 }
 
 
 void
 read_doubles (std::istream& is, double *data, save_type type,
diff --git a/liboctave/data-conv.h b/liboctave/util/data-conv.h
rename from liboctave/data-conv.h
rename to liboctave/util/data-conv.h
diff --git a/liboctave/f2c-main.c b/liboctave/util/f2c-main.c
rename from liboctave/f2c-main.c
rename to liboctave/util/f2c-main.c
diff --git a/liboctave/functor.h b/liboctave/util/functor.h
rename from liboctave/functor.h
rename to liboctave/util/functor.h
diff --git a/liboctave/glob-match.cc b/liboctave/util/glob-match.cc
rename from liboctave/glob-match.cc
rename to liboctave/util/glob-match.cc
diff --git a/liboctave/glob-match.h b/liboctave/util/glob-match.h
rename from liboctave/glob-match.h
rename to liboctave/util/glob-match.h
--- a/liboctave/glob-match.h
+++ b/liboctave/util/glob-match.h
@@ -31,19 +31,19 @@ along with Octave; see the file COPYING.
 class
 OCTAVE_API
 glob_match
 {
 public:
 
   enum opts
   {
-    pathname = 1,  // No wildcard can ever match `/'.
+    pathname = 1,  // No wildcard can ever match '/'.
     noescape = 2,  // Backslashes don't quote special chars.
-    period = 4     // Leading `.' is matched only explicitly.
+    period = 4     // Leading '.' is matched only explicitly.
   };
 
   glob_match (const std::string& p,
               unsigned int xopts = pathname|noescape|period)
     : pat (p), fnmatch_flags (opts_to_fnmatch_flags (xopts)) { }
 
   glob_match (const string_vector& p = string_vector (),
               unsigned int xopts = pathname|noescape|period)
diff --git a/liboctave/kpse.cc b/liboctave/util/kpse.cc
rename from liboctave/kpse.cc
rename to liboctave/util/kpse.cc
--- a/liboctave/kpse.cc
+++ b/liboctave/util/kpse.cc
@@ -52,27 +52,27 @@ extern "C" {
 #ifndef _MSC_VER
 #define __STDC__ 1
 #include "win32lib.h"
 #endif
 #endif /* not WIN32 */
 
 #ifdef __DJGPP__
 #include <fcntl.h>      /* for long filenames' stuff */
-#include <dir.h>        /* for `getdisk' */
-#include <io.h>         /* for `setmode' */
+#include <dir.h>        /* for 'getdisk' */
+#include <io.h>         /* for 'setmode' */
 #endif
 }
 
 /* Some drivers have partially integrated kpathsea changes.  */
 #ifndef KPATHSEA
 #define KPATHSEA 32
 #endif
 
-/* System dependencies that are figured out by `configure'.  If we are
+/* System dependencies that are figured out by 'configure'.  If we are
    compiling standalone, we get our c-auto.h.  Otherwise, the package
    containing us must provide this (unless it can somehow generate ours
    from c-auto.in).  We use <...> instead of "..." so that the current
    cpp directory (i.e., kpathsea/) won't be searched. */
 
 /* If you want to find subdirectories in a directory with non-Unix
    semantics (specifically, if a directory with no subdirectories does
    not have exactly two links), define this.  */
@@ -106,17 +106,17 @@ extern "C" {
 #define DIR_SEP '/'
 #define DIR_SEP_STRING "/"
 #endif /* not DOSISH */
 #endif /* not DIR_SEP */
 
 #ifndef IS_DIR_SEP
 #define IS_DIR_SEP(ch) ((ch) == DIR_SEP)
 #endif
-#ifndef IS_DEVICE_SEP /* No `devices' on, e.g., Unix.  */
+#ifndef IS_DEVICE_SEP /* No 'devices' on, e.g., Unix.  */
 #define IS_DEVICE_SEP(ch) 0
 #endif
 #ifndef NAME_BEGINS_WITH_DEVICE
 #define NAME_BEGINS_WITH_DEVICE(name) 0
 #endif
 
 #include "lo-error.h"
 #include "oct-env.h"
@@ -271,17 +271,17 @@ static unsigned int kpathsea_debug = 0;
 
 /* ============================================================ */
 
 #endif /* WIN32 */
 
 /* Define common sorts of messages.  */
 
 /* This should be called only after a system call fails.  Don't exit
-   with status `errno', because that might be 256, which would mean
+   with status 'errno', because that might be 256, which would mean
    success (exit statuses are truncated to eight bits).  */
 #define FATAL_PERROR(str) \
   do \
     { \
       gnulib::fputs ("pathsearch: ", stderr); \
       perror (str); exit (EXIT_FAILURE); \
     } \
   while (0)
@@ -334,17 +334,17 @@ static str_llist_type *kpse_element_dirs
 static std::string kpse_expand (const std::string& s);
 
 static std::string kpse_expand_default (const std::string& path,
                                         const std::string& dflt);
 
 static string_vector kpse_db_search (const std::string& name,
                                      const std::string& path_elt, bool all);
 
-#include <ctime> /* for `time' */
+#include <ctime> /* for 'time' */
 
 static bool
 kpse_is_env_sep (char c)
 {
   return IS_ENV_SEP (c);
 }
 
 /* These routines just check the return status from standard library
@@ -706,17 +706,17 @@ log_search (const string_vector& filenam
 
           /* Only record absolute filenames, for privacy.  */
           if (log_file && kpse_absolute_p (filename.c_str (), false))
             gnulib::fprintf (log_file, "%lu %s\n",
                      static_cast<unsigned long> (time (0)),
                      filename.c_str ());
 
           /* And show them online, if debugging.  We've already started
-             the debugging line in `search', where this is called, so
+             the debugging line in 'search', where this is called, so
              just print the filename here, don't use DEBUGF.  */
           if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
             gnulib::fputs (filename.c_str (), stderr);
         }
     }
 }
 
 /* Concatenate each element in DIRS with NAME (assume each ends with a
@@ -763,17 +763,17 @@ dir_list_search (str_llist_type *dirs, c
    readable, return (a list containing) it; otherwise, return NULL.  */
 
 static string_vector
 absolute_search (const std::string& name)
 {
   string_vector ret_list;
   std::string found = kpse_readable_file (name);
 
-  /* Add `found' to the return list even if it's null; that tells
+  /* Add 'found' to the return list even if it's null; that tells
      the caller we didn't find anything.  */
   ret_list.append (found);
 
   return ret_list;
 }
 
 /* This is the hard case -- look for NAME in PATH.  If ALL is false,
    return the first file found.  Otherwise, search all elements of PATH.  */
@@ -825,18 +825,18 @@ path_search (const std::string& path, co
       found = first_search
         ? string_vector () : kpse_db_search (name, elt, all);
 
       /* Search the filesystem if (1) the path spec allows it, and either
          (2a) we are searching for texmf.cnf ; or
          (2b) no db exists; or
          (2c) no db's are relevant to this elt; or
          (3) MUST_EXIST && NAME was not in the db.
-         In (2*), `found' will be NULL.
-         In (3),  `found' will be an empty list. */
+         In (2*), 'found' will be NULL.
+         In (3),  'found' will be an empty list. */
 
       if (allow_disk_search && found.empty ())
         {
           str_llist_type *dirs = kpse_element_dirs (elt);
 
           if (dirs && *dirs)
             found = dir_list_search (dirs, name, all);
         }
@@ -907,17 +907,17 @@ search (const std::string& path, const s
         gnulib::putc ('\n', stderr);
     }
 
   return ret_list;
 }
 
 /* Search PATH for the first NAME.  */
 
-/* Call `kpse_expand' on NAME.  If the result is an absolute or
+/* Call 'kpse_expand' on NAME.  If the result is an absolute or
    explicitly relative filename, check whether it is a readable
    (regular) file.
 
    Otherwise, look in each of the directories specified in PATH (also do
    tilde and variable expansion on elements in PATH), using a prebuilt
    db (see db.h) if it's relevant for a given path element.
 
    If the prebuilt db doesn't exist, or if MUST_EXIST is true and NAME
@@ -935,19 +935,19 @@ kpse_path_search (const std::string& pat
                   bool must_exist)
 {
   string_vector ret_list = search (path, name, must_exist, false);
 
   return ret_list.empty () ? std::string () : ret_list[0];
 }
 
 /* Search all elements of PATH for files named NAME.  Not sure if it's
-   right to assert `must_exist' here, but it suffices now.  */
-
-/* Like `kpse_path_search' with MUST_EXIST true, but return a list of
+   right to assert 'must_exist' here, but it suffices now.  */
+
+/* Like 'kpse_path_search' with MUST_EXIST true, but return a list of
    all the filenames (or NULL if none), instead of taking the first.  */
 
 static string_vector
 kpse_all_path_search (const std::string& path, const std::string& name)
 {
   return search (path, name, true, true);
 }
 
@@ -1021,18 +1021,18 @@ path_find_first_of (const std::string& p
               /* Search the filesystem if (1) the path spec allows it,
                  and either
 
                    (2a) we are searching for texmf.cnf ; or
                    (2b) no db exists; or
                    (2c) no db's are relevant to this elt; or
                    (3) MUST_EXIST && NAME was not in the db.
 
-                 In (2*), `found' will be NULL.
-                 In (3),  `found' will be an empty list. */
+                 In (2*), 'found' will be NULL.
+                 In (3),  'found' will be an empty list. */
 
               if (allow_disk_search && found.empty ())
                 {
                   static str_llist_type *tmp = 0;
 
                   if (! tmp)
                     {
                       tmp = new str_llist_type;
@@ -1157,17 +1157,17 @@ kpse_path_find_first_of (const std::stri
   string_vector ret_list = find_first_of (path, names, must_exist, false);
 
   return ret_list.empty () ? std::string () : ret_list[0];
 }
 
 /* Search each element of PATH for each element of NAMES and return a
    list containing everything found, in the order found.  */
 
-/* Like `kpse_path_find_first_of' with MUST_EXIST true, but return a
+/* Like 'kpse_path_find_first_of' with MUST_EXIST true, but return a
    list of all the filenames (or NULL if none), instead of taking the
    first.  */
 
 static string_vector
 kpse_all_path_find_first_of (const std::string& path,
                              const string_vector& names)
 {
   return find_first_of (path, names, true, true);
@@ -1187,28 +1187,28 @@ kpse_tilde_expand (const std::string& na
 {
   std::string expansion;
 
   /* If no leading tilde, do nothing.  */
   if (name.empty () || name[0] != '~')
     {
       expansion = name;
 
-      /* If a bare tilde, return the home directory or `.'.  (Very
+      /* If a bare tilde, return the home directory or '.'.  (Very
          unlikely that the directory name will do anyone any good, but
          ...  */
     }
   else if (name.length () == 1)
     {
       expansion = octave_env::getenv ("HOME");
 
       if (expansion.empty ())
         expansion = ".";
 
-      /* If `~/', remove any trailing / or replace leading // in $HOME.
+      /* If '~/', remove any trailing / or replace leading // in $HOME.
          Should really check for doubled intermediate slashes, too.  */
     }
   else if (IS_DIR_SEP (name[1]))
     {
       unsigned c = 1;
       std::string home = octave_env::getenv ("HOME");
 
       if (home.empty ())
@@ -1221,35 +1221,35 @@ kpse_tilde_expand (const std::string& na
         home = home.substr (1);
 
       /* omit / after ~ */
       if (IS_DIR_SEP (home[home_len - 1]))
         c++;
 
       expansion = home + name.substr (c);
 
-      /* If `~user' or `~user/', look up user in the passwd database (but
+      /* If '~user' or '~user/', look up user in the passwd database (but
          OS/2 doesn't have this concept.  */
     }
   else
 #ifdef HAVE_PWD_H
     {
       unsigned c = 2;
 
       /* find user name */
       while (name.length () > c && ! IS_DIR_SEP (name[c]))
         c++;
 
       std::string user = name.substr (1, c-1);
 
       /* We only need the cast here for (deficient) systems
-         which do not declare `getpwnam' in <pwd.h>.  */
+         which do not declare 'getpwnam' in <pwd.h>.  */
       octave_passwd p = octave_passwd::getpwnam (user);
 
-      /* If no such user, just use `.'.  */
+      /* If no such user, just use '.'.  */
       std::string home = p ? p.dir () : std::string (".");
 
       if (home.empty ())
         home = ".";
 
       /* handle leading // */
       if (home.length () > 1 && IS_DIR_SEP (home[0]) && IS_DIR_SEP (home[1]))
         home = home.substr (1);
@@ -1351,21 +1351,21 @@ kpse_brace_expand_element (const std::st
       ret += x + ENV_SEP_STRING;
     }
 
   ret.resize (ret.length () - 1);
 
   return ret;
 }
 
-/* Do brace expansion and call `kpse_expand' on each element of the
+/* Do brace expansion and call 'kpse_expand' on each element of the
    result; return the final expansion (always in fresh memory, even if
-   no expansions were done).  We don't call `kpse_expand_default'
+   no expansions were done).  We don't call 'kpse_expand_default'
    because there is a whole sequence of defaults to run through; see
-   `kpse_init_format'.  */
+   'kpse_init_format'.  */
 
 static std::string
 kpse_brace_expand (const std::string& path)
 {
   /* Must do variable expansion first because if we have
        foo = .:~
        TEXINPUTS = $foo
      we want to end up with TEXINPUTS = .:/home/karl.
@@ -1389,18 +1389,18 @@ kpse_brace_expand (const std::string& pa
     ret.resize (len-1);
 
   return kpse_expand_kpse_dot (ret);
 }
 
 /* Expand all special constructs in a path, and include only the actually
    existing directories in the result. */
 
-/* Do brace expansion and call `kpse_expand' on each argument of the
-   result, then expand any `//' constructs.  The final expansion (always
+/* Do brace expansion and call 'kpse_expand' on each argument of the
+   result, then expand any '//' constructs.  The final expansion (always
    in fresh memory) is a path of all the existing directories that match
    the pattern. */
 
 static std::string
 kpse_path_expand (const std::string& path)
 {
   std::string ret;
   unsigned len;
@@ -1666,18 +1666,18 @@ brace_gobbler (const std::string& text, 
           /* We ignore an open brace surrounded by whitespace, and also
              an open brace followed immediately by a close brace, that
              was preceded with whitespace.  */
           if (c == '{' &&
               ((i == 0 || brace_whitespace (text[i-1])) &&
                (i+1 < text_len &&
                 (brace_whitespace (text[i+1]) || text[i+1] == '}'))))
             continue;
-          /* If this is being compiled as part of bash, ignore the `{'
-             in a `${}' construct */
+          /* If this is being compiled as part of bash, ignore the '{'
+             in a '${}' construct */
           if ((c != '{') || i == 0 || (text[i-1] != '$'))
             break;
         }
 
       if (c == '{')
         level++;
       else if (c == '}' && level)
         level--;
@@ -1709,18 +1709,18 @@ struct kpse_format_info_type
   std::string path_source;   /* Where the path started from.  */
   std::string override_path; /* From client environment variable.  */
   std::string client_path;   /* E.g., from dvips's config.ps.  */
   std::string cnf_path;      /* From texmf.cnf.  */
   std::string default_path;  /* If all else fails.  */
   string_vector suffix;      /* For kpse_find_file to check for/append.  */
 };
 
-/* The sole variable of that type, indexed by `kpse_file_format_type'.
-   Initialized by calls to `kpse_find_file' for `kpse_init_format'.  */
+/* The sole variable of that type, indexed by 'kpse_file_format_type'.
+   Initialized by calls to 'kpse_find_file' for 'kpse_init_format'.  */
 static kpse_format_info_type kpse_format_info;
 
 /* And EXPAND_DEFAULT calls kpse_expand_default on try_path and the
    present info->path.  */
 #define EXPAND_DEFAULT(try_path, source_string) \
   do \
     { \
       if (! try_path.empty ()) \
@@ -1788,21 +1788,21 @@ match (const std::string& filename_arg, 
         /* normal character nonmatch, quit */
         break;
     }
 
   /* If we've reached the end of PATH_ELT, check that we're at the last
      component of FILENAME, we've matched.  */
   if (! matched && *path_elt == 0)
     {
-      /* Probably PATH_ELT ended with `vf' or some such, and FILENAME
-         ends with `vf/ptmr.vf'.  In that case, we'll be at a
+      /* Probably PATH_ELT ended with 'vf' or some such, and FILENAME
+         ends with 'vf/ptmr.vf'.  In that case, we'll be at a
          directory separator.  On the other hand, if PATH_ELT ended
-         with a / (as in `vf/'), FILENAME being the same `vf/ptmr.vf',
-         we'll be at the `p'.  Upshot: if we're at a dir separator in
+         with a / (as in 'vf/'), FILENAME being the same 'vf/ptmr.vf',
+         we'll be at the 'p'.  Upshot: if we're at a dir separator in
          FILENAME, skip it.  But if not, that's ok, as long as there
          are no more dir separators.  */
 
       if (IS_DIR_SEP (*filename))
         filename++;
 
       while (*filename && !IS_DIR_SEP (*filename))
         filename++;
@@ -1869,32 +1869,32 @@ kpse_db_search (const std::string& name_
   std::string name = name_arg;
 
   /* If we failed to build the database (or if this is the recursive
      call to build the db path), quit.  */
   if (! db.buckets)
     return ret;
 
   /* When tex-glyph.c calls us looking for, e.g., dpi600/cmr10.pk, we
-     won't find it unless we change NAME to just `cmr10.pk' and append
-     `/dpi600' to PATH_ELT.  We are justified in using a literal `/'
+     won't find it unless we change NAME to just 'cmr10.pk' and append
+     '/dpi600' to PATH_ELT.  We are justified in using a literal '/'
      here, since that's what tex-glyph.c unconditionally uses in
      DPI_BITMAP_SPEC.  But don't do anything if the / begins NAME; that
      should never happen.  */
   std::string path_elt;
   size_t last_slash = name.rfind ('/');
   if (last_slash != std::string::npos && last_slash != 0)
     {
       std::string dir_part = name.substr (0, last_slash);
       name = name.substr (last_slash + 1);
     }
   else
     path_elt = orig_path_elt;
 
-  /* Don't bother doing any lookups if this `path_elt' isn't covered by
+  /* Don't bother doing any lookups if this 'path_elt' isn't covered by
      any of database directories.  We do this not so much because the
      extra couple of hash lookups matter -- they don't -- but rather
      because we want to return NULL in this case, so path_search can
      know to do a disk search.  */
   for (int e = 0; ! relevant && e < db_dir_list.length (); e++)
     relevant = elt_in_db (db_dir_list[e], path_elt);
 
   if (! relevant)
@@ -1912,17 +1912,17 @@ kpse_db_search (const std::string& name_
   aliases[0] = name;
 
   done = false;
   len = aliases.length ();
   for (int i = 0; i < len && !done; i++)
     {
       std::string atry = aliases[i];
 
-      /* We have an ls-R db.  Look up `atry'.  */
+      /* We have an ls-R db.  Look up 'atry'.  */
       string_vector db_dirs = hash_lookup (db, atry);
 
       /* For each filename found, see if it matches the path element.  For
          example, if we have .../cx/cmr10.300pk and .../ricoh/cmr10.300pk,
          and the path looks like .../cx, we don't want the ricoh file.  */
 
       int db_dirs_len = db_dirs.length ();
       for (int j = 0; j < db_dirs_len && !done; j++)
@@ -1942,18 +1942,18 @@ kpse_db_search (const std::string& name_
               std::string found;
               std::string tmp = kpse_readable_file (db_file);
               if (! tmp.empty ())
                 found = db_file;
               else
                 {
                   /* The hit in the DB doesn't exist in disk.  Now try
                      all its aliases.  For example, suppose we have a
-                     hierarchy on CD, thus `mf.bas', but ls-R contains
-                     `mf.base'.  Find it anyway.  Could probably work
+                     hierarchy on CD, thus 'mf.bas', but ls-R contains
+                     'mf.base'.  Find it anyway.  Could probably work
                      around this with aliases, but this is pretty easy
                      and shouldn't hurt.  The upshot is that if one of
                      the aliases actually exists, we use that.  */
 
                   int aliases_len = aliases.length ();
 
                   for (int k = 1; k < aliases_len && found.empty (); k++)
                     {
@@ -2223,18 +2223,18 @@ do_subdir (str_llist_type *str_list_ptr,
     return;
 
   /* Include top level before subdirectories, if nothing to match.  */
   if (post.empty ())
     dir_list_add (str_list_ptr, name);
   else
     {
       /* If we do have something to match, see if it exists.  For
-         example, POST might be `pk/ljfour', and they might have a
-         directory `$TEXMF/fonts/pk/ljfour' that we should find.  */
+         example, POST might be 'pk/ljfour', and they might have a
+         directory '$TEXMF/fonts/pk/ljfour' that we should find.  */
       name += post;
       expand_elt (str_list_ptr, name, elt_length);
       name.resize (elt_length);
     }
 
   proceed = 1;
 
   while (proceed)
@@ -2269,26 +2269,26 @@ do_subdir (str_llist_type *str_list_ptr,
     return;
 
   /* Include top level before subdirectories, if nothing to match.  */
   if (post.empty ())
     dir_list_add (str_list_ptr, name);
   else
     {
       /* If we do have something to match, see if it exists.  For
-         example, POST might be `pk/ljfour', and they might have a
-         directory `$TEXMF/fonts/pk/ljfour' that we should find.  */
+         example, POST might be 'pk/ljfour', and they might have a
+         directory '$TEXMF/fonts/pk/ljfour' that we should find.  */
       name += post;
       expand_elt (str_list_ptr, name, elt_length);
       name.resize (elt_length);
     }
 
   while ((e = gnulib::readdir (dir)))
     {
-      /* If it begins with a `.', never mind.  (This allows ``hidden''
+      /* If it begins with a '.', never mind.  (This allows "hidden"
          directories that the algorithm won't find.)  */
 
       if (e->d_name[0] != '.')
         {
           int links;
 
           /* Construct the potential subdirectory name.  */
           name += e->d_name;
@@ -2321,17 +2321,17 @@ do_subdir (str_llist_type *str_list_ptr,
 #ifdef ST_NLINK_TRICK
               else if (post.empty ())
                 /* Nothing to match, no recursive subdirectories to
                    look for: we're done with this branch.  Add it.  */
                 dir_list_add (str_list_ptr, name);
 #endif
             }
 
-          /* Remove the directory entry we just checked from `name'.  */
+          /* Remove the directory entry we just checked from 'name'.  */
           name.resize (elt_length);
         }
     }
 
   xclosedir (dir);
 #endif /* not WIN32 */
 }
 
@@ -2383,17 +2383,17 @@ expand_elt (str_llist_type *str_list_ptr
 /* Here is the entry point.  Returns directory list for ELT.  */
 
 /* Given a path element ELT, return a pointer to a NULL-terminated list
    of the corresponding (existing) directory or directories, with
    trailing slashes, or NULL.  If ELT is the empty string, check the
    current working directory.
 
    It's up to the caller to expand ELT.  This is because this routine is
-   most likely only useful to be called from `kpse_path_search', which
+   most likely only useful to be called from 'kpse_path_search', which
    has already assumed expansion has been done.  */
 
 static str_llist_type *
 kpse_element_dirs (const std::string& elt)
 {
   str_llist_type *ret;
 
   /* If given nothing, return nothing.  */
@@ -2488,30 +2488,30 @@ str_llist_float (str_llist_type *l, str_
      guaranteed this will terminate, since MOVER itself is currently
      unmoved, and it must be in L (by hypothesis).  */
   for (last_moved = 0, unmoved = *l; STR_LLIST_MOVED (*unmoved);
        last_moved = unmoved, unmoved = STR_LLIST_NEXT (*unmoved))
     ;
 
   /* If we are the first unmoved element, nothing to relink.  */
   if (unmoved != mover)
-    { /* Remember `mover's current successor, so we can relink `mover's
+    { /* Remember 'mover's current successor, so we can relink 'mover's
          predecessor to it.  */
       str_llist_elt_type *before_mover;
       str_llist_elt_type *after_mover = STR_LLIST_NEXT (*mover);
 
-      /* Find `mover's predecessor.  */
+      /* Find 'mover's predecessor.  */
       for (before_mover = unmoved; STR_LLIST_NEXT (*before_mover) != mover;
            before_mover = STR_LLIST_NEXT (*before_mover))
         ;
 
-      /* `before_mover' now links to `after_mover'.  */
+      /* 'before_mover' now links to 'after_mover'.  */
       STR_LLIST_NEXT (*before_mover) = after_mover;
 
-      /* Insert `mover' before `unmoved' and after `last_moved' (or at
+      /* Insert 'mover' before 'unmoved' and after 'last_moved' (or at
          the head of the list).  */
       STR_LLIST_NEXT (*mover) = unmoved;
       if (! last_moved)
         *l = mover;
       else
         STR_LLIST_NEXT (*last_moved) = mover;
     }
 
@@ -2539,27 +2539,27 @@ expanding (const std::string& var, bool 
 
 static bool
 expanding_p (const std::string& var)
 {
   return (expansions.find (var) != expansions.end ())
     ? expansions[var] : false;
 }
 
-/* Append the result of value of `var' to EXPANSION, where `var' begins
-   at START and ends at END.  If `var' is not set, do not complain.
+/* Append the result of value of 'var' to EXPANSION, where 'var' begins
+   at START and ends at END.  If 'var' is not set, do not complain.
    This is a subroutine for the more complicated expansion function.  */
 
 static void
 expand (std::string &expansion, const std::string& var)
 {
   if (expanding_p (var))
     {
       (*current_liboctave_warning_handler)
-        ("kpathsea: variable `%s' references itself (eventually)",
+        ("kpathsea: variable '%s' references itself (eventually)",
          var.c_str ());
     }
   else
     {
       /* Check for an environment variable.  */
       std::string value = octave_env::getenv (var);
 
       if (! value.empty ())
@@ -2599,17 +2599,17 @@ kpse_var_expand (const std::string& src)
 
   /* Copy everything but variable constructs.  */
   for (size_t i = 0; i < src_len; i++)
     {
       if (IS_VAR_START (src[i]))
         {
           i++;
 
-          /* Three cases: `$VAR', `${VAR}', `$<anything-else>'.  */
+          /* Three cases: '$VAR', '${VAR}', '$<anything-else>'.  */
           if (IS_VAR_CHAR (src[i]))
             {
               /* $V: collect name constituents, then expand.  */
               size_t var_end = i;
 
               do
                 {
                   var_end++;
@@ -2640,17 +2640,17 @@ kpse_var_expand (const std::string& src)
                   expand (expansion, src.substr (i, var_end - i));
                   i = var_end; /* will incr past } at top of loop*/
                 }
             }
           else
             {
               /* $<something-else>: error.  */
               (*current_liboctave_warning_handler)
-                ("%s: Unrecognized variable construct `$%c'",
+                ("%s: Unrecognized variable construct '$%c'",
                  src.c_str (), src[i]);
 
               /* Just ignore those chars and keep going.  */
             }
         }
       else
         expansion += src[i];
     }
diff --git a/liboctave/lo-array-gripes.cc b/liboctave/util/lo-array-gripes.cc
rename from liboctave/lo-array-gripes.cc
rename to liboctave/util/lo-array-gripes.cc
diff --git a/liboctave/lo-array-gripes.h b/liboctave/util/lo-array-gripes.h
rename from liboctave/lo-array-gripes.h
rename to liboctave/util/lo-array-gripes.h
diff --git a/liboctave/lo-cieee.c b/liboctave/util/lo-cieee.c
rename from liboctave/lo-cieee.c
rename to liboctave/util/lo-cieee.c
diff --git a/liboctave/lo-cutils.c b/liboctave/util/lo-cutils.c
rename from liboctave/lo-cutils.c
rename to liboctave/util/lo-cutils.c
--- a/liboctave/lo-cutils.c
+++ b/liboctave/util/lo-cutils.c
@@ -74,17 +74,17 @@ octave_w32_library_search (HINSTANCE han
 #endif
 
 OCTAVE_API pid_t
 octave_waitpid (pid_t pid, int *status, int options)
 {
   return WAITPID (pid, status, options);
 }
 
-static void
+static inline void
 gripe_missing_wait_macro (const char *id, int status)
 {
   (*current_liboctave_warning_handler)
     ("%s always returns false in this version of Octave; status = %d",
      id, status);
 }
 
 OCTAVE_API int
diff --git a/liboctave/lo-cutils.h b/liboctave/util/lo-cutils.h
rename from liboctave/lo-cutils.h
rename to liboctave/util/lo-cutils.h
diff --git a/liboctave/lo-ieee.cc b/liboctave/util/lo-ieee.cc
rename from liboctave/lo-ieee.cc
rename to liboctave/util/lo-ieee.cc
diff --git a/liboctave/lo-ieee.h b/liboctave/util/lo-ieee.h
rename from liboctave/lo-ieee.h
rename to liboctave/util/lo-ieee.h
diff --git a/liboctave/lo-macros.h b/liboctave/util/lo-macros.h
rename from liboctave/lo-macros.h
rename to liboctave/util/lo-macros.h
diff --git a/liboctave/lo-math.h b/liboctave/util/lo-math.h
rename from liboctave/lo-math.h
rename to liboctave/util/lo-math.h
diff --git a/liboctave/lo-traits.h b/liboctave/util/lo-traits.h
rename from liboctave/lo-traits.h
rename to liboctave/util/lo-traits.h
diff --git a/liboctave/lo-utils.cc b/liboctave/util/lo-utils.cc
rename from liboctave/lo-utils.cc
rename to liboctave/util/lo-utils.cc
--- a/liboctave/lo-utils.cc
+++ b/liboctave/util/lo-utils.cc
@@ -101,17 +101,17 @@ octave_putenv (const std::string& name, 
 
   char *new_item = static_cast<char*> (gnulib::malloc (new_len));
 
   sprintf (new_item, "%s=%s", name.c_str (), value.c_str ());
 
   // As far as I can see there's no way to distinguish between the
   // various errors; putenv doesn't have errno values.
 
-  if (putenv (new_item) < 0)
+  if (gnulib::putenv (new_item) < 0)
     (*current_liboctave_error_handler) ("putenv (%s) failed", new_item);
 }
 
 std::string
 octave_fgets (FILE *f)
 {
   bool eof;
   return octave_fgets (f, eof);
diff --git a/liboctave/lo-utils.h b/liboctave/util/lo-utils.h
rename from liboctave/lo-utils.h
rename to liboctave/util/lo-utils.h
diff --git a/liboctave/util/module.mk b/liboctave/util/module.mk
new file mode 100644
--- /dev/null
+++ b/liboctave/util/module.mk
@@ -0,0 +1,88 @@
+EXTRA_DIST += \
+  util/module.mk
+
+UTIL_INC = \
+  util/base-list.h \
+  util/byte-swap.h \
+  util/caseless-str.h \
+  util/cmd-edit.h \
+  util/cmd-hist.h \
+  util/data-conv.h \
+  util/functor.h \
+  util/glob-match.h \
+  util/lo-array-gripes.h \
+  util/lo-cutils.h \
+  util/lo-ieee.h \
+  util/lo-macros.h \
+  util/lo-math.h \
+  util/lo-traits.h \
+  util/lo-utils.h \
+  util/oct-alloc.h \
+  util/oct-base64.h \
+  util/oct-binmap.h \
+  util/oct-cmplx.h \
+  util/oct-glob.h \
+  util/oct-inttypes.h \
+  util/oct-locbuf.h \
+  util/oct-md5.h \
+  util/oct-mem.h \
+  util/oct-mutex.h \
+  util/oct-refcount.h \
+  util/oct-rl-edit.h \
+  util/oct-rl-hist.h \
+  util/oct-shlib.h \
+  util/oct-sort.h \
+  util/oct-sparse.h \
+  util/pathsearch.h \
+  util/regexp.h \
+  util/singleton-cleanup.h \
+  util/sparse-sort.h \
+  util/sparse-util.h \
+  util/statdefs.h \
+  util/str-vec.h \
+  util/sun-utils.h 
+
+UTIL_C_SRC = \
+  util/f2c-main.c \
+  util/lo-cieee.c \
+  util/lo-cutils.c \
+  util/oct-rl-edit.c \
+  util/oct-rl-hist.c 
+
+UTIL_SRC = \
+  util/cmd-edit.cc \
+  util/cmd-hist.cc \
+  util/data-conv.cc \
+  util/glob-match.cc \
+  util/lo-array-gripes.cc \
+  util/lo-ieee.cc \
+  util/lo-utils.cc \
+  util/oct-alloc.cc \
+  util/oct-base64.cc \
+  util/oct-glob.cc \
+  util/oct-inttypes.cc \
+  util/oct-locbuf.cc \
+  util/oct-md5.cc \
+  util/oct-mutex.cc \
+  util/oct-shlib.cc \
+  util/pathsearch.cc \
+  util/regexp.cc \
+  util/singleton-cleanup.cc \
+  util/sparse-sort.cc \
+  util/sparse-util.cc \
+  util/str-vec.cc \
+  $(UTIL_C_SRC)
+
+TEMPLATE_SRC += \
+  util/oct-sort.cc
+
+OTHER_INC += \
+  util/kpse.cc
+
+noinst_LTLIBRARIES += util/libutil.la
+
+util_libutil_la_SOURCES = $(UTIL_SRC)
+util_libutil_la_CPPFLAGS = \
+  $(liboctave_la_CPPFLAGS) \
+  $(SPARSE_XCPPFLAGS)
+
diff --git a/liboctave/oct-alloc.cc b/liboctave/util/oct-alloc.cc
rename from liboctave/oct-alloc.cc
rename to liboctave/util/oct-alloc.cc
diff --git a/liboctave/oct-alloc.h b/liboctave/util/oct-alloc.h
rename from liboctave/oct-alloc.h
rename to liboctave/util/oct-alloc.h
diff --git a/liboctave/util/oct-base64.cc b/liboctave/util/oct-base64.cc
new file mode 100644
--- /dev/null
+++ b/liboctave/util/oct-base64.cc
@@ -0,0 +1,90 @@
+/*
+
+Copyright (C) 2012 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <algorithm>
+
+#include <base64.h>
+
+#include "Array.h"
+#include "oct-base64.h"
+
+bool
+octave_base64_encode (const char *inc, const size_t inlen, char **out)
+{  
+  bool ret = false;
+
+  size_t outlen = base64_encode_alloc (inc, inlen, out);
+  
+  if (! *out)
+    {
+      if (outlen == 0 && inlen != 0)
+        (*current_liboctave_error_handler)
+          ("base64_encode: input array too large");
+      else
+        (*current_liboctave_error_handler)
+          ("base64_encode: memory allocation error");
+    }
+  else
+    ret = true;
+
+  return ret;
+}
+
+Array<double>
+octave_base64_decode (const std::string& str)
+{
+  Array<double> retval;
+
+  const char *inc = &(str[0]);
+
+  char *out;
+  size_t outlen;
+
+  bool ok = base64_decode_alloc (inc, str.length (), &out, &outlen);
+
+  if (! ok)
+    (*current_liboctave_error_handler)
+      ("base64_decode: input was not valid base64");
+  else if (! out)
+    (*current_liboctave_error_handler)
+      ("base64_decode: memory allocation error");
+  else
+    {
+      if ((outlen % (sizeof (double) / sizeof (char))) != 0)
+        (*current_liboctave_error_handler)
+          ("base64_decode: incorrect input size");
+      else
+        {
+          octave_idx_type len = (outlen * sizeof (char)) / sizeof (double);
+          retval.resize (dim_vector (1, len));
+          double *dout = reinterpret_cast<double*> (out);
+          std::copy (dout, dout + len, retval.fortran_vec ());
+        }
+    }
+
+  return retval;
+}
+
diff --git a/liboctave/util/oct-base64.h b/liboctave/util/oct-base64.h
new file mode 100644
--- /dev/null
+++ b/liboctave/util/oct-base64.h
@@ -0,0 +1,37 @@
+/*
+
+Copyright (C) 2012 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if !defined (octave_base64_h)
+#define octave_base64_h 1
+
+#include <string>
+
+template<class T> class Array;
+
+extern OCTAVE_API bool
+octave_base64_encode (const char *inc, const size_t inlen, char **out);
+
+extern OCTAVE_API Array<double>
+octave_base64_decode (const std::string& str);
+
+#endif
+
diff --git a/liboctave/oct-binmap.h b/liboctave/util/oct-binmap.h
rename from liboctave/oct-binmap.h
rename to liboctave/util/oct-binmap.h
diff --git a/liboctave/oct-cmplx.h b/liboctave/util/oct-cmplx.h
rename from liboctave/oct-cmplx.h
rename to liboctave/util/oct-cmplx.h
diff --git a/liboctave/oct-glob.cc b/liboctave/util/oct-glob.cc
rename from liboctave/oct-glob.cc
rename to liboctave/util/oct-glob.cc
diff --git a/liboctave/oct-glob.h b/liboctave/util/oct-glob.h
rename from liboctave/oct-glob.h
rename to liboctave/util/oct-glob.h
diff --git a/liboctave/oct-inttypes.cc b/liboctave/util/oct-inttypes.cc
rename from liboctave/oct-inttypes.cc
rename to liboctave/util/oct-inttypes.cc
diff --git a/liboctave/oct-inttypes.h b/liboctave/util/oct-inttypes.h
rename from liboctave/oct-inttypes.h
rename to liboctave/util/oct-inttypes.h
diff --git a/liboctave/oct-locbuf.cc b/liboctave/util/oct-locbuf.cc
rename from liboctave/oct-locbuf.cc
rename to liboctave/util/oct-locbuf.cc
diff --git a/liboctave/oct-locbuf.h b/liboctave/util/oct-locbuf.h
rename from liboctave/oct-locbuf.h
rename to liboctave/util/oct-locbuf.h
--- a/liboctave/oct-locbuf.h
+++ b/liboctave/util/oct-locbuf.h
@@ -169,17 +169,17 @@ public:
 
 #if 0 // defined (HAVE_DYNAMIC_AUTO_ARRAYS)
 
 // Maximum buffer size (in bytes) to be placed on the stack.
 
 #define OCTAVE_LOCAL_BUFFER_MAX_STACK_SIZE 8192
 
 // If we have automatic arrays, we use an automatic array if the size
-// is small enough.  To avoid possibly evaluating `size' multiple
+// is small enough.  To avoid possibly evaluating 'size' multiple
 // times, we first cache it.  Note that we always construct both the
 // stack array and the octave_local_buffer object, but only one of
 // them will be nonempty.
 
 #define OCTAVE_LOCAL_BUFFER(T, buf, size) \
   const size_t _bufsize_ ## buf = size; \
   const bool _lbufaut_ ## buf = _bufsize_ ## buf * sizeof (T) \
      <= OCTAVE_LOCAL_BUFFER_MAX_STACK_SIZE; \
diff --git a/liboctave/oct-md5.cc b/liboctave/util/oct-md5.cc
rename from liboctave/oct-md5.cc
rename to liboctave/util/oct-md5.cc
--- a/liboctave/oct-md5.cc
+++ b/liboctave/util/oct-md5.cc
@@ -16,17 +16,17 @@ for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
-#include "config.h"
+#include <config.h>
 #endif
 
 #include <cstdio>
 
 #include <string>
 #include <vector>
 
 #include "lo-error.h"
@@ -73,13 +73,13 @@ oct_md5_file (const std::string file)
       gnulib::fclose (ifile);
 
       if (! errflag)
         retval = oct_md5_result_to_str (buf);
       else
         (*current_liboctave_error_handler) ("internal error in md5_stream");
     }
   else
-    (*current_liboctave_error_handler) ("unable to open file `%s' for reading",
+    (*current_liboctave_error_handler) ("unable to open file '%s' for reading",
                                         file.c_str ());
 
   return retval;
 }
diff --git a/liboctave/oct-md5.h b/liboctave/util/oct-md5.h
rename from liboctave/oct-md5.h
rename to liboctave/util/oct-md5.h
diff --git a/liboctave/oct-mem.h b/liboctave/util/oct-mem.h
rename from liboctave/oct-mem.h
rename to liboctave/util/oct-mem.h
diff --git a/liboctave/oct-mutex.cc b/liboctave/util/oct-mutex.cc
rename from liboctave/oct-mutex.cc
rename to liboctave/util/oct-mutex.cc
diff --git a/liboctave/oct-mutex.h b/liboctave/util/oct-mutex.h
rename from liboctave/oct-mutex.h
rename to liboctave/util/oct-mutex.h
diff --git a/liboctave/oct-refcount.h b/liboctave/util/oct-refcount.h
rename from liboctave/oct-refcount.h
rename to liboctave/util/oct-refcount.h
diff --git a/liboctave/oct-rl-edit.c b/liboctave/util/oct-rl-edit.c
rename from liboctave/oct-rl-edit.c
rename to liboctave/util/oct-rl-edit.c
diff --git a/liboctave/oct-rl-edit.h b/liboctave/util/oct-rl-edit.h
rename from liboctave/oct-rl-edit.h
rename to liboctave/util/oct-rl-edit.h
diff --git a/liboctave/oct-rl-hist.c b/liboctave/util/oct-rl-hist.c
rename from liboctave/oct-rl-hist.c
rename to liboctave/util/oct-rl-hist.c
--- a/liboctave/oct-rl-hist.c
+++ b/liboctave/util/oct-rl-hist.c
@@ -205,16 +205,22 @@ octave_remove_history (int n)
     {
       if (discard->line)
         free (discard->line);
 
       free (discard);
     }
 }
 
+void
+octave_clear_history (void)
+{
+  clear_history ();
+}
+
 char *
 octave_history_goto_mark (int n)
 {
   HIST_ENTRY *h;
 
   char *retval = 0;
 
   if (history_set_pos (n))
diff --git a/liboctave/oct-rl-hist.h b/liboctave/util/oct-rl-hist.h
rename from liboctave/oct-rl-hist.h
rename to liboctave/util/oct-rl-hist.h
--- a/liboctave/oct-rl-hist.h
+++ b/liboctave/util/oct-rl-hist.h
@@ -61,16 +61,18 @@ extern int octave_read_history_range (co
 extern int octave_write_history (const char *);
 
 extern int octave_append_history (int, const char *);
 
 extern int octave_history_truncate_file (const char *, int);
 
 extern void octave_remove_history (int);
 
+extern void octave_clear_history (void);
+
 extern char *octave_history_goto_mark (int n);
 
 extern char *octave_history_get (int n);
 
 extern char **octave_history_list (int, int);
 
 extern void octave_replace_history_entry (int, const char *);
 
diff --git a/liboctave/oct-shlib.cc b/liboctave/util/oct-shlib.cc
rename from liboctave/oct-shlib.cc
rename to liboctave/util/oct-shlib.cc
--- a/liboctave/oct-shlib.cc
+++ b/liboctave/util/oct-shlib.cc
@@ -267,17 +267,17 @@ octave_shl_load_shlib::octave_shl_load_s
 {
   file = f;
 
   library = shl_load (file.c_str (), BIND_IMMEDIATE, 0L);
 
   if (! library)
     {
       using namespace std;
-      (*current_liboctave_error_handler) ("%s", strerror (errno));
+      (*current_liboctave_error_handler) ("%s", gnulib::strerror (errno));
     }
 }
 
 octave_shl_load_shlib::~octave_shl_load_shlib (void)
 {
   if (library)
     shl_unload (library);
 }
diff --git a/liboctave/oct-shlib.h b/liboctave/util/oct-shlib.h
rename from liboctave/oct-shlib.h
rename to liboctave/util/oct-shlib.h
diff --git a/liboctave/oct-sort.cc b/liboctave/util/oct-sort.cc
rename from liboctave/oct-sort.cc
rename to liboctave/util/oct-sort.cc
diff --git a/liboctave/oct-sort.h b/liboctave/util/oct-sort.h
rename from liboctave/oct-sort.h
rename to liboctave/util/oct-sort.h
diff --git a/liboctave/oct-sparse.h b/liboctave/util/oct-sparse.h
rename from liboctave/oct-sparse.h
rename to liboctave/util/oct-sparse.h
diff --git a/liboctave/pathsearch.cc b/liboctave/util/pathsearch.cc
rename from liboctave/pathsearch.cc
rename to liboctave/util/pathsearch.cc
diff --git a/liboctave/pathsearch.h b/liboctave/util/pathsearch.h
rename from liboctave/pathsearch.h
rename to liboctave/util/pathsearch.h
diff --git a/liboctave/regexp.cc b/liboctave/util/regexp.cc
rename from liboctave/regexp.cc
rename to liboctave/util/regexp.cc
--- a/liboctave/regexp.cc
+++ b/liboctave/util/regexp.cc
@@ -441,160 +441,184 @@ regexp::is_match (const string_vector& b
   Array<bool> retval (dim_vector (len, 1));
 
   for (octave_idx_type i = 0; i < buffer.length (); i++)
     retval(i) = is_match (buffer(i));
 
   return retval;
 }
 
+// Declare rep_token_t used in processing replacement string
+typedef struct
+  {
+    size_t pos;
+    int num;
+  } rep_token_t;
+
+
 std::string
 regexp::replace (const std::string& buffer, const std::string& replacement)
 {
   std::string retval;
 
+  regexp::match_data rx_lst = match (buffer);
+
+  size_t num_matches = rx_lst.size ();
+
+  if (num_matches == 0)
+    {
+      retval = buffer;
+      return retval;
+    }
+
   // Identify replacement tokens; build a vector of group numbers in
   // the replacement string so that we can quickly calculate the size
   // of the replacement.
 
-  int tokens = 0;
-  for (size_t i=1; i < replacement.size (); i++)
+  // FIXME: All code assumes that only 10 tokens ($0-$9) exist.
+  //        $11 represents $1 followed by the character '1' rather than
+  //        the eleventh capture buffer.
+
+  std::string repstr = replacement;
+  std::vector<rep_token_t> tokens;
+  tokens.reserve (5);  // Reserve memory for 5 pattern replacements
+
+  for (size_t i=0; i < repstr.size (); i++)
     {
-      if (replacement[i-1]=='$' && isdigit (replacement[i]))
+      if (repstr[i] == '\\')
         {
-          tokens++;
-          i++;
+          if (i < repstr.size () - 1 && repstr[i+1] == '$')
+            {
+              repstr.erase (i,1);  // erase backslash
+              i++;                 // skip over '$'
+              continue;
+            }
+          if (i < repstr.size () - 1 && repstr[i+1] == '\\')
+            {
+              repstr.erase (i,1);  // erase 1st backslash
+              continue;
+            }
         }
-    }
-  std::vector<int> token (tokens);
+      else if (repstr[i] == '$')
+        {
+          if (i < repstr.size () - 1 && isdigit (repstr[i+1]))
+            {
+              rep_token_t tmp_token;
 
-  int kk = 0;
-  for (size_t i = 1; i < replacement.size (); i++)
-    {
-      if (replacement[i-1]=='$' && isdigit (replacement[i]))
-        {
-          token[kk++] = replacement[i]-'0';
-          i++;
+              tmp_token.pos = i;
+              tmp_token.num = repstr[i+1]-'0';
+              tokens.push_back (tmp_token);
+            }
         }
     }
 
-  regexp::match_data rx_lst = match (buffer);
-
-  size_t sz = rx_lst.size ();
+  std::string rep;
+  int num_tokens = tokens.size ();
 
-  if (sz == 0)
-    {
-      retval = buffer;
-      return retval;
-    }
-
-  std::string rep;
-
-  if (tokens > 0)
+  if (num_tokens > 0)
     {
       // Determine replacement length
-      const size_t replen = replacement.size () - 2*tokens;
+      const size_t replen = repstr.size () - 2*num_tokens;
       int delta = 0;
       regexp::match_data::const_iterator p = rx_lst.begin ();
-      for (size_t i = 0; i < sz; i++)
+      for (size_t i = 0; i < num_matches; i++)
         {
           OCTAVE_QUIT;
 
           double start = p->start ();
           double end = p->end ();
 
           const Matrix pairs (p->token_extents ());
           size_t pairlen = 0;
-          for (int j = 0; j < tokens; j++)
+          for (int j = 0; j < num_tokens; j++)
             {
-              if (token[j] == 0)
+              if (tokens[j].num == 0)
                 pairlen += static_cast<size_t> (end - start) + 1;
-              else if (token[j] <= pairs.rows ())
-                pairlen += static_cast<size_t> (pairs(token[j]-1,1)
-                                                - pairs(token[j]-1,0)) + 1;
+              else if (tokens[j].num <= pairs.rows ())
+                pairlen += static_cast<size_t> (pairs(tokens[j].num-1,1)
+                                                - pairs(tokens[j].num-1,0)) + 1;
             }
           delta += (static_cast<int> (replen + pairlen)
                     - static_cast<int> (end - start + 1));
           p++;
         }
 
       // Build replacement string
       rep.reserve (buffer.size () + delta);
       size_t from = 0;
       p = rx_lst.begin ();
-      for (size_t i = 0; i < sz; i++)
+      for (size_t i = 0; i < num_matches; i++)
         {
           OCTAVE_QUIT;
 
           double start = p->start ();
           double end = p->end ();
 
           const Matrix pairs (p->token_extents ());
           rep.append (&buffer[from], static_cast<size_t> (start - 1) - from);
           from = static_cast<size_t> (end - 1) + 1;
 
-          for (size_t j = 1; j < replacement.size (); j++)
+          size_t cur_pos = 0;
+
+          for (int j = 0; j < num_tokens; j++)
             {
-              if (replacement[j-1]=='$' && isdigit (replacement[j]))
+              rep.append (&repstr[cur_pos], (tokens[j].pos) - cur_pos);
+              cur_pos = tokens[j].pos+2;
+
+              int k = tokens[j].num;
+              if (k == 0)
                 {
-                  int k = replacement[j]-'0';
-                  if (k == 0)
-                    {
-                      // replace with entire match
-                      rep.append (&buffer[static_cast<size_t> (end - 1)],
-                                  static_cast<size_t> (end - start) + 1);
-                    }
-                  else if (k <= pairs.rows ())
-                    {
-                      // replace with group capture
-                      rep.append (&buffer[static_cast<size_t> (pairs(k-1,0)-1)],
-                                  static_cast<size_t> (pairs(k-1,1)
-                                                       - pairs(k-1,0)) + 1);
-                    }
-                  else
-                    {
-                      // replace with nothing
-                    }
-                  j++;
+                  // replace with entire match
+                  rep.append (&buffer[static_cast<size_t> (end - 1)],
+                              static_cast<size_t> (end - start) + 1);
+                }
+              else if (k <= pairs.rows ())
+                {
+                  // replace with group capture
+                  rep.append (&buffer[static_cast<size_t> (pairs(k-1,0)-1)],
+                              static_cast<size_t> (pairs(k-1,1)
+                                                   - pairs(k-1,0)) + 1);
                 }
               else
-                rep.append (1, replacement[j-1]);
+                {
+                  // replace with nothing
+                }
+            }
+          if (cur_pos < repstr.size ())
+            rep.append (&repstr[cur_pos], repstr.size () - cur_pos);
 
-              if (j+1 == replacement.size ())
-                rep.append (1, replacement[j]);
-            }
           p++;
         }
       rep.append (&buffer[from], buffer.size () - from);
     }
   else
     {
-      // Determine replacement length
-      const size_t replen = replacement.size ();
+      // Determine repstr length
+      const size_t replen = repstr.size ();
       int delta = 0;
       regexp::match_data::const_iterator p = rx_lst.begin ();
-      for (size_t i = 0; i < sz; i++)
+      for (size_t i = 0; i < num_matches; i++)
         {
           OCTAVE_QUIT;
           delta += static_cast<int> (replen)
-            - static_cast<int> (p->end () - p->start () + 1);
+                   - static_cast<int> (p->end () - p->start () + 1);
           p++;
         }
 
       // Build replacement string
       rep.reserve (buffer.size () + delta);
       size_t from = 0;
       p = rx_lst.begin ();
-      for (size_t i = 0; i < sz; i++)
+      for (size_t i = 0; i < num_matches; i++)
         {
           OCTAVE_QUIT;
           rep.append (&buffer[from],
                       static_cast<size_t> (p->start () - 1) - from);
           from = static_cast<size_t> (p->end () - 1) + 1;
-          rep.append (replacement);
+          rep.append (repstr);
           p++;
         }
       rep.append (&buffer[from], buffer.size () - from);
     }
 
   retval = rep;
   return retval;
 }
diff --git a/liboctave/regexp.h b/liboctave/util/regexp.h
rename from liboctave/regexp.h
rename to liboctave/util/regexp.h
diff --git a/liboctave/singleton-cleanup.cc b/liboctave/util/singleton-cleanup.cc
rename from liboctave/singleton-cleanup.cc
rename to liboctave/util/singleton-cleanup.cc
diff --git a/liboctave/singleton-cleanup.h b/liboctave/util/singleton-cleanup.h
rename from liboctave/singleton-cleanup.h
rename to liboctave/util/singleton-cleanup.h
diff --git a/liboctave/sparse-sort.cc b/liboctave/util/sparse-sort.cc
rename from liboctave/sparse-sort.cc
rename to liboctave/util/sparse-sort.cc
diff --git a/liboctave/sparse-sort.h b/liboctave/util/sparse-sort.h
rename from liboctave/sparse-sort.h
rename to liboctave/util/sparse-sort.h
diff --git a/liboctave/sparse-util.cc b/liboctave/util/sparse-util.cc
rename from liboctave/sparse-util.cc
rename to liboctave/util/sparse-util.cc
--- a/liboctave/sparse-util.cc
+++ b/liboctave/util/sparse-util.cc
@@ -27,25 +27,29 @@ along with Octave; see the file COPYING.
 
 #include <stdio.h>
 #include <stdarg.h>
 #include "lo-error.h"
 #include "oct-sparse.h"
 #include "sparse-util.h"
 
 // FIXME this overload is here due to API change in SuiteSparse (3.1 -> 3.2)
+
+#ifdef HAVE_CHOLMOD
+
 void
 SparseCholError (int status, char *file, int line, char *message)
 {
   SparseCholError (status, file, line, message);
 }
 
 void
 SparseCholError (int status, const char *file, int line, const char *message)
 {
+
   // Ignore CHOLMOD_NOT_POSDEF, since we handle that in Fchol as an
   // error or exit status.
   if (status != CHOLMOD_NOT_POSDEF)
     {
       (*current_liboctave_warning_handler)("warning %i, at line %i in file %s",
                                            status, line, file);
 
       (*current_liboctave_warning_handler)(message);
@@ -58,16 +62,17 @@ SparseCholPrint (const char *fmt, ...)
   va_list args;
   va_start (args, fmt);
   int ret = gnulib::vfprintf (stderr, fmt, args);
   gnulib::fflush (stderr);
   va_end (args);
   return ret;
 }
 
+#endif //HAVE_CHOLMOD
 
 bool
 sparse_indices_ok (octave_idx_type *r, octave_idx_type *c,
                    octave_idx_type nrows, octave_idx_type ncols,
                    octave_idx_type nnz)
 {
   if (nnz > 0)
     {
diff --git a/liboctave/sparse-util.h b/liboctave/util/sparse-util.h
rename from liboctave/sparse-util.h
rename to liboctave/util/sparse-util.h
--- a/liboctave/sparse-util.h
+++ b/liboctave/util/sparse-util.h
@@ -19,21 +19,25 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_sparse_util_h)
 #define octave_sparse_util_h 1
 
+#ifdef HAVE_CHOLMOD
+
 // FIXME this overload is here due to API change in SuiteSparse (3.1 -> 3.2)
 extern OCTAVE_API void SparseCholError (int status, char *file,
                                         int line, char *message);
 extern OCTAVE_API void SparseCholError (int status, const char *file,
                                         int line, const char *message);
 extern OCTAVE_API int SparseCholPrint (const char *fmt, ...);
 
+#endif //HAVE_CHOLMOD
+
 extern OCTAVE_API bool
 sparse_indices_ok (octave_idx_type *r, octave_idx_type *c,
                    octave_idx_type nrows, octave_idx_type ncols,
                    octave_idx_type nnz);
 
 #endif
diff --git a/liboctave/statdefs.h b/liboctave/util/statdefs.h
rename from liboctave/statdefs.h
rename to liboctave/util/statdefs.h
diff --git a/liboctave/str-vec.cc b/liboctave/util/str-vec.cc
rename from liboctave/str-vec.cc
rename to liboctave/util/str-vec.cc
diff --git a/liboctave/str-vec.h b/liboctave/util/str-vec.h
rename from liboctave/str-vec.h
rename to liboctave/util/str-vec.h
diff --git a/liboctave/sun-utils.h b/liboctave/util/sun-utils.h
rename from liboctave/sun-utils.h
rename to liboctave/util/sun-utils.h
diff --git a/m4/acinclude.m4 b/m4/acinclude.m4
--- a/m4/acinclude.m4
+++ b/m4/acinclude.m4
@@ -69,31 +69,31 @@ dnl Check if C compiler handles FLAG com
 dnl arguments are specified, execute the second arg as shell commands.
 dnl Otherwise, add FLAG to CFLAGS if the compiler accepts the flag.
 dnl
 AC_DEFUN([OCTAVE_CC_FLAG], [
   ac_safe=`echo "$1" | sed 'y% ./+-:=%___p___%'`
   AC_MSG_CHECKING([whether ${CC-cc} accepts $1])
   AC_CACHE_VAL([octave_cv_cc_flag_$ac_safe],
     [AC_LANG_PUSH(C)
-    XCFLAGS="$CFLAGS"
+    ac_octave_save_CFLAGS="$CFLAGS"
     CFLAGS="$CFLAGS $1"
     AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])],
       [eval "octave_cv_cc_flag_$ac_safe=yes"],
       [eval "octave_cv_cc_flag_$ac_safe=no"])
-    CFLAGS="$XCFLAGS"
+    CFLAGS="$ac_octave_save_CFLAGS"
     AC_LANG_POP(C)
   ])
   if eval "test \"`echo '$octave_cv_cc_flag_'$ac_safe`\" = yes"; then
-    AC_MSG_RESULT(yes)
+    AC_MSG_RESULT([yes])
     ifelse([$2], , 
       [CFLAGS="$CFLAGS $1"
       AC_MSG_RESULT([adding $1 to CFLAGS])], [$2])
   else
-    AC_MSG_RESULT(no)
+    AC_MSG_RESULT([no])
     ifelse([$3], , , [$3])
   fi
 ])
 dnl
 dnl Check whether a math mapper function is available in <cmath>.
 dnl Will define HAVE_CMATH_FUNC if there is a double variant and
 dnl HAVE_CMATH_FUNCF if there is a float variant.
 dnl Currently capable of checking for functions with single 
@@ -138,16 +138,45 @@ AC_DEFUN([OCTAVE_CHECK_FUNC_CMATH], [
     AC_LANG_POP(C++)
   ])
   if eval "test \"`echo '$octave_cv_func_cmath_f'$ac_safe`\" = yes"; then
     AC_DEFINE(AS_TR_CPP([[HAVE_CMATH_][$1][F]]), 1,
       [Define to 1 if <cmath> provides float variant of $1.])
   fi
 ])
 dnl
+dnl Check whether Qscintilla FindFirst function is old (16 inputs) or
+dnl new (17 inputs).
+dnl FIXME: This test uses a version number.  It potentially could
+dnl        be re-written to actually call the function, but is it worth it?
+dnl
+AC_DEFUN([OCTAVE_CHECK_FUNC_FINDFIRST_MODERN], [
+  AC_CACHE_CHECK([whether Qscintilla FindFirst uses 17 input arguments],
+    [octave_cv_func_findfirst_modern],
+    [AC_LANG_PUSH(C++)
+    ac_octave_save_CPPFLAGS="$CPPFLAGS"
+    CPPFLAGS="-I$QT_INCDIR -I$QT_INCDIR/Qt $CPPFLAGS"
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+        #include <Qsci/qsciglobal.h>
+        ]], [[
+        #if QSCINTILLA_VERSION < 0x020600
+        #error Old FindFirst function found.
+        #endif
+        ]])],
+      octave_cv_func_findfirst_modern=yes,
+      octave_cv_func_findfirst_modern=no)
+    CPPFLAGS="$ac_octave_save_CPPFLAGS"
+    AC_LANG_POP(C++)
+  ])
+  if test $octave_cv_func_findfirst_modern = yes; then
+    AC_DEFINE(HAVE_FINDFIRST_MODERN, 1, 
+      [Define to 1 if Qscintilla FindFirst uses modern form with 17 inputs.])
+  fi
+])
+dnl
 dnl Check if Fortran compiler has the intrinsic function ISNAN.
 dnl
 AC_DEFUN([OCTAVE_CHECK_FUNC_FORTRAN_ISNAN], [
   AC_CACHE_CHECK([whether $F77 has the intrinsic function ISNAN],
     [octave_cv_func_fortran_isnan],
     [AC_LANG_PUSH(Fortran 77)
     AC_COMPILE_IFELSE(
 [[      program foo
@@ -182,36 +211,64 @@ AC_DEFUN([OCTAVE_CHECK_FUNC_GLUTESSCALLB
         ]], [[
         GLvoid (*func)(...);
         gluTessCallback(0, 0, func);
         ]])],
       octave_cv_func_glutesscallback_threedots=yes,
       octave_cv_func_glutesscallback_threedots=no)
     AC_LANG_POP(C++)
   ])
-  if test $octave_cv_func_glutesscallback_threedots = "yes"; then
+  if test $octave_cv_func_glutesscallback_threedots = yes; then
     AC_DEFINE(HAVE_GLUTESSCALLBACK_THREEDOTS, 1, 
       [Define to 1 if gluTessCallback is called with (...).])
   fi
 ])
 dnl
+dnl Check whether Qscintilla SetPlaceholderText function exists.
+dnl FIXME: This test uses a version number.  It potentially could
+dnl        be re-written to actually call the function, but is it worth it?
+dnl
+AC_DEFUN([OCTAVE_CHECK_FUNC_SETPLACEHOLDERTEXT], [
+  AC_CACHE_CHECK([whether Qt has SetPlaceholderText function],
+    [octave_cv_func_setplaceholdertext],
+    [AC_LANG_PUSH(C++)
+    ac_octave_save_CPPFLAGS="$CPPFLAGS"
+    CPPFLAGS="-I$QT_INCDIR $CPPFLAGS"
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+        #include <Qt/qglobal.h>
+        ]], [[
+        #if QT_VERSION < 0x040700
+        #error No SetPlacholderText function available.
+        #endif
+        ]])],
+      octave_cv_func_setplaceholdertext=yes,
+      octave_cv_func_setplaceholdertext=no)
+    CPPFLAGS="$ac_octave_save_CPPFLAGS"
+    AC_LANG_POP(C++)
+  ])
+  if test $octave_cv_func_setplaceholdertext = yes; then
+    AC_DEFINE(HAVE_SETPLACEHOLDERTEXT, 1, 
+      [Define to 1 if you have the Qt SetPlaceholderText function.])
+  fi
+])
+dnl
 dnl Check whether HDF5 library has version 1.6 API functions.
 dnl
 AC_DEFUN([OCTAVE_CHECK_HDF5_HAS_VER_16_API], [
   AC_CACHE_CHECK([whether HDF5 library has enforced version 1.6 API],
     [octave_cv_hdf5_has_ver_16_api],
     [AC_LINK_IFELSE([AC_LANG_PROGRAM([[
       #include <hdf5.h>
       ]], [[
       H5Eset_auto (0, 0);
       ]])],
       octave_cv_hdf5_has_ver_16_api=yes,
       octave_cv_hdf5_has_ver_16_api=no)
   ])
-  if test "$octave_cv_hdf5_has_ver_16_api" != "yes"; then
+  if test $octave_cv_hdf5_has_ver_16_api != yes; then
     AC_DEFINE(HAVE_HDF5_18, 1, [Define to 1 if >=HDF5-1.8 is available.])
   fi
 ])
 dnl
 dnl Usage:
 dnl OCTAVE_CHECK_LIB(LIBRARY, DOC-NAME, WARN-MSG, HEADER, FUNC,
 dnl                  LANG, DOC-STRING, EXTRA-CHECK)
 dnl
@@ -250,65 +307,66 @@ AC_DEFUN([OCTAVE_CHECK_LIB], [
     ;;
   esac
 
   [TEXINFO_]m4_toupper([$1])=
   warn_$1="$3"
   m4_set_add([summary_warning_list], [warn_$1])
 
   if test -n "$m4_toupper([$1])_LIBS"; then
-    octave_check_lib_save_CPPFLAGS="$CPPFLAGS"
+    ac_octave_save_CPPFLAGS="$CPPFLAGS"
+    ac_octave_save_LDFLAGS="$LDFLAGS"
+    ac_octave_save_LIBS="$LIBS"
     CPPFLAGS="$m4_toupper([$1])_CPPFLAGS $CPPFLAGS"
+    LDFLAGS="$m4_toupper([$1])_LDFLAGS $LDFLAGS"
+    LIBS="$m4_toupper([$1])_LIBS $LIBS"
     m4_ifnblank([$6], [AC_LANG_PUSH($6)])
-    octave_$1_check_for_lib=false
-    m4_ifblank([$4], [octave_$1_check_for_lib=true],
-               [AC_CHECK_HEADERS($4, [octave_$1_check_for_lib=true; break])])
-    if $octave_$1_check_for_lib; then
-      octave_check_lib_save_LDFLAGS="$LDFLAGS"
-      LDFLAGS="$m4_toupper([$1])_LDFLAGS $LDFLAGS"
-      octave_check_lib_save_LIBS="$LIBS"
-      LIBS="$m4_toupper([$1])_LIBS $LIBS"
-      octave_$1_ok=no
-      AC_MSG_CHECKING([for $5 in $m4_toupper([$1])_LIBS])
-      AC_LINK_IFELSE([AC_LANG_CALL([], [$5])],
-        [octave_$1_ok=yes])
-      AC_MSG_RESULT([$octave_$1_ok])
-      if test $octave_$1_ok = yes; then
+    ac_octave_$1_check_for_lib=false
+    m4_ifblank([$4], [ac_octave_$1_check_for_lib=true],
+               [AC_CHECK_HEADERS([$4], [ac_octave_$1_check_for_lib=true; break])])
+    if $ac_octave_$1_check_for_lib; then
+      AC_CACHE_CHECK([for $5 in $m4_toupper([$1])_LIBS],
+        [octave_cv_lib_$1],
+        [AC_LINK_IFELSE([AC_LANG_CALL([], [$5])],
+          [octave_cv_lib_$1=yes], [octave_cv_lib_$1=no])
+      ])
+      if test "$octave_cv_lib_$1" = yes; then
         m4_ifblank([$8], [
           warn_$1=
           AC_DEFINE([HAVE_]m4_toupper([$1]), 1,
             [Define to 1 if $2 is available.])
           [TEXINFO_]m4_toupper([$1])="@set [HAVE_]m4_toupper([$1])"], [$8])
       fi
-      LIBS="$octave_check_lib_save_LIBS"
-      LDFLAGS="$octave_check_lib_save_LDFLAGS"
     fi
     m4_ifnblank([$6], [AC_LANG_POP($6)])
-    CPPFLAGS="$octave_check_lib_save_CPPFLAGS"
+    CPPFLAGS="$ac_octave_save_CPPFLAGS"
+    LDFLAGS="$ac_octave_save_LDFLAGS"
+    LIBS="$ac_octave_save_LIBS"
   fi
+
   AC_SUBST(m4_toupper([$1])_LIBS)
   AC_SUBST([TEXINFO_]m4_toupper([$1]))
   if test -n "$warn_$1"; then
     AC_MSG_WARN([$warn_$1])
     m4_toupper([$1])_LIBS=
   fi
 ])
 dnl
 dnl Check whether ARPACK works (does not crash).
 dnl
 dnl Using a pure Fortran program doesn't seem to crash when linked
 dnl with the buggy ARPACK library but the C++ program does.  Maybe it
 dnl is the memory allocation that exposes the bug and using statically
 dnl allocated arrays in Fortran does not?
 dnl
 AC_DEFUN([OCTAVE_CHECK_LIB_ARPACK_OK], [
-  AC_LANG_PUSH(C++)
   AC_CACHE_CHECK([whether the arpack library works],
     [octave_cv_lib_arpack_ok],
-    [AC_RUN_IFELSE([AC_LANG_PROGRAM([[
+    [AC_LANG_PUSH(C++)
+    AC_RUN_IFELSE([AC_LANG_PROGRAM([[
 // External functions from ARPACK library
 extern "C" int
 F77_FUNC (dnaupd, DNAUPD) (int&, const char *, const int&, const char *,
                            int&, const double&, double*, const int&,
                            double*, const int&, int*, int*, double*,
                            double*, const int&, int&, long int, long int);
 
 extern "C" int
@@ -431,22 +489,24 @@ doit (void)
 ]], [[
 
   for (int i = 0; i < 10; i++)
     doit ();
     ]])],
     octave_cv_lib_arpack_ok=yes,
     octave_cv_lib_arpack_ok=no,
     octave_cv_lib_arpack_ok=yes)
+    AC_LANG_POP(C++)
   ])
-  AC_LANG_POP(C++)
-  if test "$octave_cv_lib_arpack_ok" = "yes"; then
+  if test $octave_cv_lib_arpack_ok = yes; then
     $1
+    :
   else
     $2
+    :
   fi
 ])
 dnl
 dnl Check whether using HDF5 DLL under Windows.  This is done by
 dnl testing for a data symbol in the HDF5 library, which would
 dnl require the definition of _HDF5USEDL_ under MSVC compiler.
 dnl
 AC_DEFUN([OCTAVE_CHECK_LIB_HDF5_DLL], [
@@ -470,17 +530,17 @@ AC_DEFUN([OCTAVE_CHECK_LIB_HDF5_DLL], [
           return x
         ]])],
         octave_cv_lib_hdf5_dll=yes,
         octave_cv_lib_hdf5_dll=no)
       CFLAGS="$save_CFLAGS"
       LIBS="$save_LIBS"
     ])
   ])
-  if test "$octave_cv_lib_hdf5_dll" = yes; then
+  if test $octave_cv_lib_hdf5_dll = yes; then
     AC_DEFINE(_HDF5USEDLL_, 1, [Define to 1 if using HDF5 dll (Win32).])
   fi
 ])
 dnl
 dnl Check for OpenGL.  If found, define OPENGL_LIBS.
 dnl
 dnl FIXME: The following tests should probably check for the
 dnl libraries separately.
@@ -495,26 +555,26 @@ AC_DEFUN([OCTAVE_CHECK_LIB_OPENGL], [
   OCTAVE_HAVE_FRAMEWORK(OpenGL, [[
     #include <OpenGL/gl.h>
     #include <OpenGL/glu.h>
     ]], [[
     GLint par; glGetIntegerv (GL_VIEWPORT, &par);
     ]],
     have_framework_opengl=yes, have_framework_opengl=no)
 
-  if test $have_framework_opengl = "yes"; then
+  if test $have_framework_opengl = yes; then
     AC_DEFINE(HAVE_FRAMEWORK_OPENGL, 1,
       [Define to 1 if framework OPENGL is available.])
     OPENGL_LIBS="-Wl,-framework -Wl,OpenGL"
     AC_MSG_NOTICE([adding -Wl,-framework -Wl,OpenGL to OPENGL_LIBS])
     OCTAVE_CHECK_FUNC_GLUTESSCALLBACK_THREEDOTS
   else
     case $canonical_host_type in
       *-*-mingw32* | *-*-msdosmsvc)
-        AC_CHECK_HEADERS(windows.h)
+        AC_CHECK_HEADERS([windows.h])
       ;;
     esac
     have_opengl_incs=no
     AC_CHECK_HEADERS([GL/gl.h OpenGL/gl.h],
       [AC_CHECK_HEADERS([GL/glu.h OpenGL/glu.h],
         [have_opengl_incs=yes; break], [], [
 #ifdef HAVE_WINDOWS_H
 #include <windows.h>
@@ -522,17 +582,17 @@ AC_DEFUN([OCTAVE_CHECK_LIB_OPENGL], [
       ])
       break
       ], [], [
 #ifdef HAVE_WINDOWS_H
 # include <windows.h>
 #endif
     ])
 
-    if test "$have_opengl_incs" = "yes"; then
+    if test "$have_opengl_incs" = yes; then
       case $canonical_host_type in
         *-*-mingw32* | *-*-msdosmsvc)
           save_LIBS="$LIBS"
           LIBS="$LIBS -lopengl32"
           AC_MSG_CHECKING([for glEnable in -lopengl32])
           AC_LINK_IFELSE([AC_LANG_PROGRAM([[
             #if HAVE_WINDOWS_H
             # include <windows.h>
@@ -543,24 +603,24 @@ AC_DEFUN([OCTAVE_CHECK_LIB_OPENGL], [
             # include <OpenGL/gl.h>
             #endif
             ]], [[ 
             glEnable(GL_SMOOTH);
             ]])], [OPENGL_LIBS="-lopengl32 -lglu32"])
 
           LIBS="$save_LIBS"
           if test "x$OPENGL_LIBS" != "x"; then
-            AC_MSG_RESULT(yes)
+            AC_MSG_RESULT([yes])
           else
-            AC_MSG_RESULT(no)
+            AC_MSG_RESULT([no])
           fi
           ;;
         *)
           ## Non-Mac, Non-Windows systems use this check
-          AC_CHECK_LIB(GL, [glEnable], [OPENGL_LIBS="-lGL -lGLU"])
+          AC_CHECK_LIB([GL], [glEnable], [OPENGL_LIBS="-lGL -lGLU"])
           ;;
       esac
     fi
   fi
   AC_SUBST(OPENGL_LIBS)
 ])
 dnl
 dnl Check whether Qhull works (does not crash).
@@ -606,51 +666,84 @@ AC_DEFUN([OCTAVE_CHECK_LIB_QHULL_OK], [
         coordT points[8] = { -0.5, -0.5, -0.5, 0.5, 0.5, -0.5, 0.5, 0.5 };
         boolT ismalloc = 0;
         return qh_new_qhull (dim, n, points, ismalloc, "qhull ", 0, stderr); 
       ]])],
       octave_cv_lib_qhull_ok=yes,
       octave_cv_lib_qhull_ok=no,
       octave_cv_lib_qhull_ok=yes)
   ])
-  if test "$octave_cv_lib_qhull_ok" = "yes"; then
+  if test $octave_cv_lib_qhull_ok = yes; then
     $1
+    :
   else
     $2
+    :
   fi
 ])
 dnl
+dnl Find a suitable termlib to use.
+dnl
+AC_DEFUN([OCTAVE_CHECK_LIB_TERMLIB], [
+  TERM_LIBS=
+  ac_octave_save_LIBS="$LIBS"
+  AC_SEARCH_LIBS([tputs],
+                 [ncurses curses termcap terminfo termlib],
+                 [], [])
+  LIBS="$ac_octave_save_LIBS"
+  case "$ac_cv_search_tputs" in
+    -l*)  
+      TERM_LIBS="$ac_cv_search_tputs"
+    ;;
+    no)
+      warn_termlibs="I couldn't find -ltermcap, -lterminfo, -lncurses, -lcurses, or -ltermlib!"
+      AC_MSG_WARN([$warn_termlibs])
+    ;;
+  esac
+
+dnl  Old code (9/9/2012).  Delete when new code is definitely proven.
+dnl
+dnl  for _termlib in ncurses curses termcap terminfo termlib; do
+dnl    AC_CHECK_LIB([${_termlib}], [tputs], [
+dnl      TERM_LIBS="-l${termlib}"
+dnl      octave_cv_lib_found_termlib=yes
+dnl      break])
+dnl  done
+
+  AC_SUBST(TERM_LIBS)
+])
+dnl
 dnl Check for support of OpenMP with a given compiler flag.
 dnl If found define HAVE_OPENMP and add the compile flag
 dnl to CFLAGS and CXXFLAGS.
 dnl
 AC_DEFUN([OCTAVE_CHECK_OPENMP], [
   AC_MSG_CHECKING([for support of OpenMP])
-  XCFLAGS="$CFLAGS"
+  ac_octave_save_CFLAGS="$CFLAGS"
   CFLAGS="$CFLAGS $1"
   AC_CACHE_VAL([octave_cv_check_openmp],
     [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
         #include <omp.h>
         #include <stdio.h>
         ]], [[
         int main(int argc, char* argv[])
         {
           _Pragma("omp parallel")  
           printf("Hello, world.\n");
           return 0;
         }
       ]])],
       octave_cv_openmp=yes, octave_cv_openmmp=no, octave_cv_openmp=no)
   ])
   AC_MSG_RESULT([$octave_cv_openmp])
-  if test "$octave_cv_openmp" = yes; then
+  if test $octave_cv_openmp = yes; then
     AC_DEFINE(HAVE_OPENMP, 1, [Define to 1 if compiler supports OpenMP.])
     CXXFLAGS="$CXXFLAGS $1"
   else
-    CFLAGS="$XCFLAGS"
+    CFLAGS="$ac_octave_save_CFLAGS"
   fi
 ])
 dnl
 dnl Check for the Qhull version.
 dnl
 AC_DEFUN([OCTAVE_CHECK_QHULL_VERSION], [
   AC_CACHE_CHECK([for qh_version in $QHULL_LIBS],
     [octave_cv_lib_qhull_version],
@@ -683,42 +776,42 @@ AC_DEFUN([OCTAVE_CHECK_QHULL_VERSION], [
         # include <poly.h>
         # include <io.h>
         #endif
         ]], [[
         const char *tmp = qh_version;
       ]])], 
       octave_cv_lib_qhull_version=yes, octave_cv_lib_qhull_version=no)
   ])
-  if test "$octave_cv_lib_qhull_version" = no; then
+  if test $octave_cv_lib_qhull_version = no; then
     AC_DEFINE(NEED_QHULL_VERSION, 1,
       [Define to 1 if the Qhull library needs a qh_version variable defined.])
   fi
 ])
 dnl
 dnl Check if the default Fortran INTEGER is 64 bits wide.
 dnl
 AC_DEFUN([OCTAVE_CHECK_SIZEOF_FORTRAN_INTEGER], [
   AC_CACHE_CHECK([whether $F77 generates correct size integers],
     [octave_cv_sizeof_fortran_integer],
-    [octave_fintsize_save_FFLAGS="$FFLAGS"
+    [ac_octave_save_FFLAGS="$FFLAGS"
     FFLAGS="$FFLAGS $F77_INTEGER_8_FLAG"
     AC_LANG_PUSH(Fortran 77)
     AC_COMPILE_IFELSE(
 [[      subroutine foo(n, in, out)
       integer n, in(n), out(n)
       integer i
       do 10 i = 1, n
         out(i) = in(i)
    10 continue
       return
       end
 ]],
       [mv conftest.$ac_objext fintsize.$ac_objext
-      octave_fintsize_save_LIBS="$LIBS"
+      ac_octave_save_LIBS="$LIBS"
       LIBS="fintsize.$ac_objext $[]_AC_LANG_PREFIX[]LIBS"
       AC_LANG_PUSH(C)
       AC_RUN_IFELSE([AC_LANG_PROGRAM([[
           #include <assert.h> ]], [[
           #ifdef USE_64_BIT_IDX_T
           #if IDX_TYPE_LONG
             typedef long octave_idx_type;
           #else
@@ -734,23 +827,23 @@ AC_DEFUN([OCTAVE_CHECK_SIZEOF_FORTRAN_IN
           in[0] = 42;
           F77_FUNC(foo,FOO) (&n, &in, &out);
           assert (in[0] == out[0] && in[1] == out[1]);
         ]])],
         octave_cv_sizeof_fortran_integer=yes,
         octave_cv_sizeof_fortran_integer=no,
         octave_cv_sizeof_fortran_integer=yes)
       AC_LANG_POP(C)
-      LIBS="$octave_fintsize_save_LIBS"
+      LIBS="$ac_octave_save_LIBS"
       rm -f conftest.$ac_objext fintsize.$ac_objext],
       [rm -f conftest.$ac_objext
       AC_MSG_FAILURE([cannot compile a simple Fortran program])
       octave_cv_sizeof_fortran_integer=no])
     AC_LANG_POP(Fortran 77)
-    FFLAGS="$octave_fintsize_save_FFLAGS"
+    FFLAGS="$ac_octave_save_FFLAGS"
   ])
 ])
 dnl
 dnl Add warning to final summary.
 dnl
 AC_DEFUN([OCTAVE_CONFIGURE_WARNING], [
   AC_MSG_WARN([$][$1])
   m4_set_add([summary_warning_list], [$1])
@@ -805,17 +898,17 @@ AC_DEFUN([OCTAVE_CXX_BROKEN_REINTERPRET_
         fptr psin = sin;
         void *vptr = reinterpret_cast<void *> (psin);
         psin = reinterpret_cast<fptr> (vptr);
       ]])],
       octave_cv_cxx_broken_reinterpret_cast=no,
       octave_cv_cxx_broken_reinterpret_cast=yes)
     AC_LANG_POP(C++)
   ])
-  if test $octave_cv_cxx_broken_reinterpret_cast = yes ; then
+  if test $octave_cv_cxx_broken_reinterpret_cast = yes; then
     AC_DEFINE(CXX_BROKEN_REINTERPRET_CAST, 1,
       [Define to 1 if C++ reinterpret_cast fails for function pointers.])
   fi
 ])
 dnl
 dnl Check if the C++ library has functions to access real and imaginary
 dnl parts of complex numbers independently via references.
 dnl
@@ -889,31 +982,31 @@ dnl Check if C++ compiler handles FLAG c
 dnl arguments are specified, execute the second arg as shell commands.
 dnl Otherwise, add FLAG to CXXFLAGS if the compiler accepts the flag.
 dnl
 AC_DEFUN([OCTAVE_CXX_FLAG], [
   ac_safe=`echo "$1" | sed 'y%./+-:=%__p___%'`
   AC_MSG_CHECKING([whether ${CXX-g++} accepts $1])
   AC_CACHE_VAL([octave_cv_cxx_flag_$ac_safe],
     [AC_LANG_PUSH(C++)
-    XCXXFLAGS="$CXXFLAGS"
+    ac_octave_save_CXXFLAGS="$CXXFLAGS"
     CXXFLAGS="$CXXFLAGS $1"
     AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])],
       eval "octave_cv_cxx_flag_$ac_safe=yes",
       eval "octave_cv_cxx_flag_$ac_safe=no")
-    CXXFLAGS="$XCXXFLAGS"
+    CXXFLAGS="$ac_octave_save_CXXFLAGS"
     AC_LANG_POP(C++)
   ])
   if eval "test \"`echo '$octave_cv_cxx_flag_'$ac_safe`\" = yes"; then
-    AC_MSG_RESULT(yes)
+    AC_MSG_RESULT([yes])
     ifelse([$2], ,
       [CXXFLAGS="$CXXFLAGS $1"
       AC_MSG_RESULT([adding $1 to CXXFLAGS])], [$2])
   else
-    AC_MSG_RESULT(no)
+    AC_MSG_RESULT([no])
     ifelse([$3], , , [$3])
   fi
 ])
 dnl
 dnl Check if the C++ library is ISO compliant.
 dnl FIXME: This is obviously very simplistic, and trivially fooled.
 dnl
 AC_DEFUN([OCTAVE_CXX_ISO_COMPLIANT_LIBRARY], [
@@ -1012,63 +1105,65 @@ AC_DEFUN([OCTAVE_CXX_PLACEMENT_DELETE], 
 ])
 dnl
 dnl Allow the user disable support for command line editing using GNU
 dnl readline.
 dnl
 AC_DEFUN([OCTAVE_ENABLE_READLINE], [
   USE_READLINE=true
   READLINE_LIBS=
-  AC_ARG_ENABLE(readline,
-    [AS_HELP_STRING([--enable-readline],
-      [use readline library (default is yes)])],
+  AC_ARG_ENABLE([readline],
+    [AS_HELP_STRING([--disable-readline],
+      [use readline library])],
     [if test "$enableval" = no; then
        USE_READLINE=false
        warn_readline="command editing and history features require GNU Readline"
      fi])
   if $USE_READLINE; then
-    save_LIBS="$LIBS"
+    dnl RHEL 5 and older systems require termlib set before enabling readline
+    AC_REQUIRE([OCTAVE_CHECK_LIB_TERMLIB])
+    ac_octave_save_LIBS="$LIBS"
     LIBS="$TERM_LIBS"
-    AC_CHECK_LIB(readline, rl_set_keyboard_input_timeout,
+    AC_CHECK_LIB([readline], [rl_set_keyboard_input_timeout],
       [READLINE_LIBS="-lreadline"
       AC_DEFINE(USE_READLINE, 1, [Define to 1 to use the readline library.])
       ],
       [AC_MSG_WARN([I need GNU Readline 4.2 or later])
       AC_MSG_ERROR([this is fatal unless you specify --disable-readline])
     ])
-    LIBS="$save_LIBS"
+    LIBS="$ac_octave_save_LIBS"
   fi
   AC_SUBST(READLINE_LIBS)
 ])
 dnl
 dnl Check if Fortran compiler handles FLAG command line option.  If
 dnl two arguments are specified, execute the second arg as shell
 dnl commands.  Otherwise, add FLAG to FFLAGS if the compiler accepts
 dnl the flag.
 dnl
 AC_DEFUN([OCTAVE_F77_FLAG], [
   ac_safe=`echo "$1" | sed 'y%./+-:=%__p___%'`
   AC_MSG_CHECKING([whether ${F77-g77} accepts $1])
-  AC_CACHE_VAL(octave_cv_f77_flag_$ac_safe, [
+  AC_CACHE_VAL([octave_cv_f77_flag_$ac_safe], [
     AC_LANG_PUSH(Fortran 77)
-    XFFLAGS="$FFLAGS"
+    ac_octave_save_FFLAGS="$FFLAGS"
     FFLAGS="$FFLAGS $1"
     AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])],
       eval "octave_cv_f77_flag_$ac_safe=yes",
       eval "octave_cv_f77_flag_$ac_safe=no")
-    FFLAGS="$XFFLAGS"
+    FFLAGS="$ac_octave_save_FFLAGS"
     AC_LANG_POP(Fortran 77)
   ])
   if eval "test \"`echo '$octave_cv_f77_flag_'$ac_safe`\" = yes"; then
-    AC_MSG_RESULT(yes)
+    AC_MSG_RESULT([yes])
     ifelse([$2], ,
       [FFLAGS="$FFLAGS $1"
       AC_MSG_RESULT([adding $1 to FFLAGS])], [$2])
   else
-    AC_MSG_RESULT(no)
+    AC_MSG_RESULT([no])
     ifelse([$3], , , [$3])
   fi
 ])
 dnl
 dnl Check whether fast signed integer arithmetics using bit tricks
 dnl can be used in oct-inttypes.h.  Defines HAVE_FAST_INT_OPS if
 dnl the following conditions hold:
 dnl 1. Signed numbers are represented by twos complement
@@ -1146,39 +1241,40 @@ dnl "-framework $1" for the given prolog
 dnl a source file.  Arguments 2 and 3 optionally can also be empty.
 dnl Add options (lower case letters $1) "--with-framework-$1" and
 dnl "--without-framework-$1".  If this test is successful then perform
 dnl $4, otherwise do $5.
 dnl
 AC_DEFUN([OCTAVE_HAVE_FRAMEWORK], [
   AC_MSG_CHECKING([whether ${LD-ld} accepts -framework $1])
   AC_CACHE_VAL([octave_cv_framework_$1],
-    [XLDFLAGS="$LDFLAGS"
+    [ac_octave_save_LDFLAGS="$LDFLAGS"
     LDFLAGS="$LDFLAGS -framework $1"
     AC_LANG_PUSH(C++)
     AC_LINK_IFELSE([AC_LANG_PROGRAM([$2], [$3])],
       eval "octave_cv_framework_$1=yes",
       eval "octave_cv_framework_$1=no")
     AC_LANG_POP(C++)
-    LDFLAGS="$XLDFLAGS"
+    LDFLAGS="$ac_octave_save_LDFLAGS"
   ])
-  if test "$octave_cv_framework_$1" = "yes"; then
-    AC_MSG_RESULT(yes)
+  if test "$octave_cv_framework_$1" = yes; then
+    AC_MSG_RESULT([yes])
     AC_ARG_WITH(framework-m4_tolower($1),
       [AS_HELP_STRING([--without-framework-m4_tolower($1)], 
         [don't use framework $1])],
          with_have_framework=$withval, with_have_framework=yes)
-    if test "$with_have_framework" = "yes"; then
+    if test "$with_have_framework" = yes; then
       [$4]
+      :
     else
       AC_MSG_NOTICE([framework rejected by --without-framework-m4_tolower($1)])
       [$5]
     fi
   else
-    AC_MSG_RESULT(no)
+    AC_MSG_RESULT([no])
     [$5]
   fi
 ])
 dnl
 dnl Figure out the hardware-vendor-os info.
 dnl
 dnl Hanging '])' in AC_MSG_WARN is for adding newline to output
 dnl
@@ -1216,17 +1312,17 @@ AC_DEFUN([OCTAVE_IEEE754_DATA_FORMAT], [
       octave_cv_ieee754_data_format=no,
       octave_cv_ieee754_data_format=yes)
   ])
   if test "$cross_compiling" = yes; then
     AC_MSG_RESULT([$octave_cv_ieee754_data_format assumed for cross compilation])
   else
     AC_MSG_RESULT([$octave_cv_ieee754_data_format])
   fi
-  if test "$octave_cv_ieee754_data_format" = yes; then
+  if test $octave_cv_ieee754_data_format = yes; then
     AC_DEFINE(HAVE_IEEE754_DATA_FORMAT, 1,
       [Define to 1 if your system uses IEEE 754 data format.])
   else
     ## If the format is unknown, then you will probably not have a
     ## useful system, so we will abort here.  Anyone wishing to
     ## experiment with building Octave on a system without IEEE
     ## floating point should be capable of removing this check and
     ## the one in the octave_ieee_init function in liboctave/lo-ieee.cc.
@@ -1272,17 +1368,17 @@ dnl Find desktop-file-install program.
 dnl
 AC_DEFUN([OCTAVE_PROG_DESKTOP_FILE_INSTALL], [
   AC_CHECK_PROG(DESKTOP_FILE_INSTALL, desktop-file-install, desktop-file-install, [])
   AC_SUBST(DESKTOP_FILE_INSTALL)
 ])
 dnl
 dnl Find find program.
 dnl
-# Prefer GNU find if found.
+## Prefer GNU find if found.
 AN_MAKEVAR([FIND],  [OCTAVE_PROG_FIND])
 AN_PROGRAM([gfind], [OCTAVE_PROG_FIND])
 AN_PROGRAM([find],  [OCTAVE_PROG_FIND])
 AC_DEFUN([OCTAVE_PROG_FIND], [
   AC_CHECK_PROGS(FIND, [gfind find])
 ])
 dnl
 dnl Check for flex.
@@ -1313,46 +1409,46 @@ lex.cc, which is the case if you're buil
   AC_SUBST(LFLAGS)
 ])
 dnl
 dnl Check for ghostscript.
 dnl
 AC_DEFUN([OCTAVE_PROG_GHOSTSCRIPT], [
   case "$canonical_host_type" in
     *-*-mingw* | *-*-msdosmsvc)
-      gs_names="gswin32c gs mgs"
+      ac_octave_gs_names="gswin32c gs mgs"
     ;;
     *)
-      gs_names="gs"
+      ac_octave_gs_names="gs"
     ;;
   esac
-  AC_CHECK_PROGS(GHOSTSCRIPT, [$gs_names])
+  AC_CHECK_PROGS(GHOSTSCRIPT, [$ac_octave_gs_names])
   if test -z "$GHOSTSCRIPT"; then
     GHOSTSCRIPT='$(top_srcdir)/build-aux/missing gs'
     warn_ghostscript="
 
 I didn't find ghostscript, so reconstructing figures for the manual
 will fail, and saving graphics in some output formats will fail when
 using Octave
 "
     OCTAVE_CONFIGURE_WARNING([warn_ghostscript])
   fi
   AC_SUBST(GHOSTSCRIPT)
 ])
 dnl
 dnl Check for gnuplot.
 dnl
 AC_DEFUN([OCTAVE_PROG_GNUPLOT], [
-  gp_names="gnuplot"
-  gp_default="gnuplot"
+  ac_octave_gp_names="gnuplot"
+  ac_octave_gp_default="gnuplot"
   if test "$cross_compiling" = yes; then
-    GNUPLOT="$gp_default"
+    GNUPLOT="$ac_octave_gp_default"
     AC_MSG_RESULT([assuming $GNUPLOT exists on $canonical_host_type host])
   else
-    AC_CHECK_PROGS(GNUPLOT, [$gp_names])
+    AC_CHECK_PROGS(GNUPLOT, [$ac_octave_gp_names])
     if test -z "$GNUPLOT"; then
       GNUPLOT="$gp_default"
       warn_gnuplot="
 
 gnuplot not found.  It isn't necessary to have gnuplot installed, but
 without native graphics or gnuplot you won't be able to use any of
 Octave's plotting commands.
 "
@@ -1393,24 +1489,24 @@ dnl
 dnl What pager should we use?
 dnl
 AC_DEFUN([OCTAVE_PROG_PAGER], [
   if test "$cross_compiling" = yes; then
     DEFAULT_PAGER=less
     AC_MSG_RESULT([assuming $DEFAULT_PAGER exists on $canonical_host_type host])
     AC_SUBST(DEFAULT_PAGER)
   else
-    octave_possible_pagers="less more page pg"
+    ac_octave_possible_pagers="less more page pg"
     case "$canonical_host_type" in
       *-*-cygwin* | *-*-mingw32* | *-*-msdosmsvc)
-        octave_possible_pagers="$octave_possible_pagers more.com"
+        ac_octave_possible_pagers="$ac_octave_possible_pagers more.com"
       ;;
     esac
 
-    AC_CHECK_PROGS(DEFAULT_PAGER, $octave_possible_pagers, [])
+    AC_CHECK_PROGS(DEFAULT_PAGER, [$ac_octave_possible_pagers], [])
     if test -z "$DEFAULT_PAGER"; then
       warn_less="I couldn't find \`less', \`more', \`page', or \`pg'"
       OCTAVE_CONFIGURE_WARNING([warn_less])
     fi
   fi
 ])
 dnl
 dnl Find Perl program.
@@ -1501,63 +1597,95 @@ AC_DEFUN([OCTAVE_PROG_TEXI2DVI], [
     TEXI2DVI='$(top_srcdir)/build-aux/missing texi2dvi'
     warn_texi2dvi="
 
 I didn't find texi2dvi, but it's only a problem if you need to
 reconstruct the DVI version of the manual
 "
     OCTAVE_CONFIGURE_WARNING([warn_texi2dvi])
   fi
+  TEXI2DVI="$TEXI2DVI"' --build-dir=t2d_cache'
   AC_SUBST(TEXI2DVI)
 ])
 dnl
 dnl Check for texi2pdf.
 dnl
 AC_DEFUN([OCTAVE_PROG_TEXI2PDF], [
   AC_REQUIRE([OCTAVE_PROG_TEXI2DVI])
   AC_CHECK_PROG(TEXI2PDF, texi2pdf, texi2pdf, [])
   if test -z "$TEXI2PDF"; then
-    missing=true;
+    ac_octave_missing=true;
     if test -n "$TEXI2DVI"; then
       TEXI2PDF="$TEXI2DVI --pdf"
-      missing=false;
+      ac_octave_missing=false;
     fi
   else
-    missing=false;
+    ac_octave_missing=false;
   fi
-  if $missing; then
+  if $ac_octave_missing; then
     TEXI2PDF='$(top_srcdir)/build-aux/missing texi2pdf'
     warn_texi2pdf="
 
 I didn't find texi2pdf, but it's only a problem if you need to
 reconstruct the PDF version of the manual
 "
     OCTAVE_CONFIGURE_WARNING([warn_texi2pdf])
   fi
+  TEXI2PDF="$TEXI2PDF"' --build-dir=t2d_cache'
   AC_SUBST(TEXI2PDF)
 ])
 dnl
 dnl Set default value for a variable and substitute it.
 dnl
 AC_DEFUN([OCTAVE_SET_DEFAULT], [
   ifelse($#, 2, [: ${$1=$2}
 ])dnl
   AC_MSG_RESULT([defining $1 to be $$1])
   AC_SUBST($1)
 ])
 dnl
+dnl Check whether SuiteSparse_time is required by UMFPACK.
+dnl UMFPACK >= 4 requires linking in another library for SuiteSparse_time.
+dnl
+dnl Macro assumes that the check for umfpack has already been performed.
+dnl
+AC_DEFUN([OCTAVE_UMFPACK_NEED_SUITESPARSE_TIME], [
+  AC_CACHE_CHECK([whether UMFPACK needs SuiteSparse_time function], 
+    [octave_cv_umfpack_need_suitesparse_time],
+    [AC_LANG_PUSH(C)
+    AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+        #if defined (HAVE_SUITESPARSE_UMFPACK_H)
+        # include <suitesparse/umfpack.h>
+        #elif defined (HAVE_UFSPARSE_UMFPACK_H)
+        # include <ufsparse/umfpack.h>
+        #elif defined (HAVE_UMFPACK_UMFPACK_H)
+        # include <umfpack/umfpack.h>
+        #elif defined (HAVE_UMFPACK_H)
+        # include <umfpack.h>
+        #endif
+        ]], [[
+        double stats [2];
+        umfpack_tic (stats);
+      ]])],
+      octave_cv_umfpack_need_suitesparse_time=no,
+      octave_cv_umfpack_need_suitesparse_time=yes)
+    AC_LANG_POP(C)
+  ])
+])
+dnl
 dnl Check for UMFPACK separately split complex matrix and RHS.
 dnl
 dnl Macro assumes that the check for umfpack has already been performed.
 dnl
 AC_DEFUN([OCTAVE_UMFPACK_SEPARATE_SPLIT], [
   AC_MSG_CHECKING([for UMFPACK separate complex matrix and rhs split])
-  AC_CACHE_VAL(octave_cv_umfpack_separate_split,
+  AC_CACHE_VAL([octave_cv_umfpack_separate_split],
     [AC_RUN_IFELSE([AC_LANG_SOURCE([[
         #include <stdlib.h>
+        #include <math.h>
         #if defined (HAVE_SUITESPARSE_UMFPACK_H)
         # include <suitesparse/umfpack.h>
         #elif defined (HAVE_UFSPARSE_UMFPACK_H)
         # include <ufsparse/umfpack.h>
         #elif defined (HAVE_UMFPACK_UMFPACK_H)
         # include <umfpack/umfpack.h>
         #elif defined (HAVE_UMFPACK_H)
         # include <umfpack.h>
@@ -1577,63 +1705,63 @@ AC_DEFUN([OCTAVE_UMFPACK_SEPARATE_SPLIT]
           void *Symbolic, *Numeric ;
           (void) umfpack_zi_symbolic (n, n, Ap, Ai, Ax, null, &Symbolic, null, null) ;
           (void) umfpack_zi_numeric (Ap, Ai, Ax, null, Symbolic, &Numeric, null, null) ;
           umfpack_zi_free_symbolic (&Symbolic) ;
           (void) umfpack_zi_solve (0, Ap, Ai, Ax, null, x, null, br, bi, 
                                    Numeric, null, null) ;
           umfpack_zi_free_numeric (&Numeric) ;
           for (i = 0; i < n; i++, x+=2) 
-            if (fabs(*x - i - 1.) > 1.e-13)
+            if (fabs (*x - i - 1.) > 1.e-13)
               return (1);
           return (0) ;
         }
       ]])],
       octave_cv_umfpack_separate_split=yes,
       octave_cv_umfpack_separate_split=no,
       octave_cv_umfpack_separate_split=yes)
   ])
   if test "$cross_compiling" = yes; then
     AC_MSG_RESULT([$octave_cv_umfpack_separate_split assumed for cross compilation])
   else
     AC_MSG_RESULT([$octave_cv_umfpack_separate_split])
   fi
-  if test "$octave_cv_umfpack_separate_split" = yes; then
+  if test $octave_cv_umfpack_separate_split = yes; then
     AC_DEFINE(UMFPACK_SEPARATE_SPLIT, 1, 
       [Define to 1 if the UMFPACK Complex solver allows matrix and RHS to be split independently.])
   fi
 ])
 dnl
 dnl Check for unordered map headers and whether tr1 namespace is
 dnl required.
 dnl
 AC_DEFUN([OCTAVE_UNORDERED_MAP_HEADERS], [
   AC_CHECK_HEADERS([unordered_map], [],
     [AC_CHECK_HEADERS([tr1/unordered_map])])
   AC_CACHE_CHECK([whether unordered_map requires tr1 namespace], 
     [octave_cv_header_require_tr1_namespace],
     [AC_LANG_PUSH(C++)
     octave_cv_header_require_tr1_namespace=no
-    if test "$ac_cv_header_unordered_map" = "yes"; then
+    if test $ac_cv_header_unordered_map = yes; then
       ## Have <unordered_map>, but still have to check whether
       ## tr1 namespace is required (like MSVC, for instance).
       AC_COMPILE_IFELSE(
         [AC_LANG_PROGRAM([[
           #include <unordered_map>
           ]], [[
           std::unordered_map<int,int> m;
         ]])],
         octave_cv_header_require_tr1_namespace=no, 
         octave_cv_header_require_tr1_namespace=yes)
-    elif test "$ac_cv_header_tr1_unordered_map" = "yes"; then
+    elif test $ac_cv_header_tr1_unordered_map = yes; then
       octave_cv_header_require_tr1_namespace=yes
     fi
     AC_LANG_POP(C++)
   ])
-  if test "$octave_cv_header_require_tr1_namespace" = "yes"; then
+  if test $octave_cv_header_require_tr1_namespace = yes; then
     AC_DEFINE(USE_UNORDERED_MAP_WITH_TR1, 1, 
       [Define to 1 if unordered_map requires the use of tr1 namespace.])
   fi
 ])
 
 dnl         End of macros written by Octave developers
 dnl ------------------------------------------------------------
 dnl
@@ -1832,169 +1960,8 @@ appropiate for your system) is correctly
 
   AC_SUBST([FT2_CFLAGS])
   AC_SUBST([FT2_LIBS])
 ])
 dnl end of freetype2.m4
 
 
 ##############################################################################
-##############################################################################
-
-# pkg.m4 - Macros to locate and utilise pkg-config.            -*- Autoconf -*-
-# 
-# Copyright ¬© 2004 Scott James Remnant <scott@netsplit.com>.
-#
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful, but
-# WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-# General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-#
-# As a special exception to the GNU General Public License, if you
-# distribute this file as part of a program that contains a
-# configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
-
-# PKG_PROG_PKG_CONFIG([MIN-VERSION])
-# ----------------------------------
-AC_DEFUN([PKG_PROG_PKG_CONFIG],
-[m4_pattern_forbid([^_?PKG_[A-Z_]+$])
-m4_pattern_allow([^PKG_CONFIG(_PATH)?$])
-AC_ARG_VAR([PKG_CONFIG], [path to pkg-config utility])dnl
-if test "x$ac_cv_env_PKG_CONFIG_set" != "xset"; then
-	AC_PATH_TOOL([PKG_CONFIG], [pkg-config])
-fi
-if test -n "$PKG_CONFIG"; then
-	_pkg_min_version=m4_default([$1], [0.9.0])
-	AC_MSG_CHECKING([pkg-config is at least version $_pkg_min_version])
-	if $PKG_CONFIG --atleast-pkgconfig-version $_pkg_min_version; then
-		AC_MSG_RESULT([yes])
-	else
-		AC_MSG_RESULT([no])
-		PKG_CONFIG=""
-	fi
-		
-fi[]dnl
-])# PKG_PROG_PKG_CONFIG
-
-# PKG_CHECK_EXISTS(MODULES, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])
-#
-# Check to see whether a particular set of modules exists.  Similar
-# to PKG_CHECK_MODULES(), but does not set variables or print errors.
-#
-#
-# Similar to PKG_CHECK_MODULES, make sure that the first instance of
-# this or PKG_CHECK_MODULES is called, or make sure to call
-# PKG_CHECK_EXISTS manually
-# --------------------------------------------------------------
-AC_DEFUN([PKG_CHECK_EXISTS],
-[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl
-if test -n "$PKG_CONFIG" && \
-    AC_RUN_LOG([$PKG_CONFIG --exists --print-errors "$1"]); then
-  m4_ifval([$2], [$2], [:])
-m4_ifvaln([$3], [else
-  $3])dnl
-fi])
-
-
-# _PKG_CONFIG([VARIABLE], [COMMAND], [MODULES])
-# ---------------------------------------------
-m4_define([_PKG_CONFIG],
-[if test -n "$PKG_CONFIG"; then
-    if test -n "$$1"; then
-        pkg_cv_[]$1="$$1"
-    else
-        PKG_CHECK_EXISTS([$3],
-                         [pkg_cv_[]$1=`$PKG_CONFIG --[]$2 "$3" 2>/dev/null`],
-			 [pkg_failed=yes])
-    fi
-else
-	pkg_failed=untried
-fi[]dnl
-])# _PKG_CONFIG
-
-# _PKG_SHORT_ERRORS_SUPPORTED
-# -----------------------------
-AC_DEFUN([_PKG_SHORT_ERRORS_SUPPORTED],
-[AC_REQUIRE([PKG_PROG_PKG_CONFIG])
-if $PKG_CONFIG --atleast-pkgconfig-version 0.20; then
-        _pkg_short_errors_supported=yes
-else
-        _pkg_short_errors_supported=no
-fi[]dnl
-])# _PKG_SHORT_ERRORS_SUPPORTED
-
-
-# PKG_CHECK_MODULES(VARIABLE-PREFIX, MODULES, [ACTION-IF-FOUND],
-# [ACTION-IF-NOT-FOUND])
-#
-#
-# Note that if there is a possibility the first call to
-# PKG_CHECK_MODULES might not happen, you should be sure to include an
-# explicit call to PKG_PROG_PKG_CONFIG in your configure.ac
-#
-#
-# --------------------------------------------------------------
-AC_DEFUN([PKG_CHECK_MODULES],
-[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl
-AC_ARG_VAR([$1][_CFLAGS], [C compiler flags for $1, overriding pkg-config])dnl
-AC_ARG_VAR([$1][_LIBS], [linker flags for $1, overriding pkg-config])dnl
-
-pkg_failed=no
-AC_MSG_CHECKING([for $1])
-
-_PKG_CONFIG([$1][_CFLAGS], [cflags], [$2])
-_PKG_CONFIG([$1][_LIBS], [libs], [$2])
-
-m4_define([_PKG_TEXT], [Alternatively, you may set the environment variables $1[]_CFLAGS
-and $1[]_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details.])
-
-if test $pkg_failed = yes; then
-        _PKG_SHORT_ERRORS_SUPPORTED
-        if test $_pkg_short_errors_supported = yes; then
-	        $1[]_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors "$2"`
-        else 
-	        $1[]_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "$2"`
-        fi
-	# Put the nasty error message in config.log where it belongs
-	echo "$$1[]_PKG_ERRORS" >&AS_MESSAGE_LOG_FD
-
-	ifelse([$4], , [AC_MSG_ERROR(dnl
-[Package requirements ($2) were not met:
-
-$$1_PKG_ERRORS
-
-Consider adjusting the PKG_CONFIG_PATH environment variable if you
-installed software in a non-standard prefix.
-
-_PKG_TEXT
-])],
-		[AC_MSG_RESULT([no])
-                $4])
-elif test $pkg_failed = untried; then
-	ifelse([$4], , [AC_MSG_FAILURE(dnl
-[The pkg-config script could not be found or is too old.  Make sure it
-is in your PATH or set the PKG_CONFIG environment variable to the full
-path to pkg-config.
-
-_PKG_TEXT
-
-To get pkg-config, see <http://pkg-config.freedesktop.org/>.])],
-		[$4])
-else
-	$1[]_CFLAGS=$pkg_cv_[]$1[]_CFLAGS
-	$1[]_LIBS=$pkg_cv_[]$1[]_LIBS
-        AC_MSG_RESULT([yes])
-	ifelse([$3], , :, [$3])
-fi[]dnl
-])# PKG_CHECK_MODULES
-dnl end of pkg.m4
-
diff --git a/m4/module.mk b/m4/module.mk
--- a/m4/module.mk
+++ b/m4/module.mk
@@ -5,9 +5,10 @@ EXTRA_DIST += \
   m4/ax_compare_version.m4 \
   m4/ax_lapack.m4	\
   m4/ax_pthread.m4 \
   m4/gnulib-cache.m4 \
   m4/libtool.m4 \
   m4/ltoptions.m4 \
   m4/ltsugar.m4 \
   m4/ltversion.m4 \
-  m4/lt~obsolete.m4
+  m4/lt~obsolete.m4 \
+  m4/pkg.m4
diff --git a/m4/pkg.m4 b/m4/pkg.m4
new file mode 100644
--- /dev/null
+++ b/m4/pkg.m4
@@ -0,0 +1,157 @@
+# pkg.m4 - Macros to locate and utilise pkg-config.            -*- Autoconf -*-
+# 
+# Copyright ¬© 2004 Scott James Remnant <scott@netsplit.com>.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# PKG_PROG_PKG_CONFIG([MIN-VERSION])
+# ----------------------------------
+AC_DEFUN([PKG_PROG_PKG_CONFIG],
+[m4_pattern_forbid([^_?PKG_[A-Z_]+$])
+m4_pattern_allow([^PKG_CONFIG(_PATH)?$])
+AC_ARG_VAR([PKG_CONFIG], [path to pkg-config utility])dnl
+if test "x$ac_cv_env_PKG_CONFIG_set" != "xset"; then
+	AC_PATH_TOOL([PKG_CONFIG], [pkg-config])
+fi
+if test -n "$PKG_CONFIG"; then
+	_pkg_min_version=m4_default([$1], [0.9.0])
+	AC_MSG_CHECKING([pkg-config is at least version $_pkg_min_version])
+	if $PKG_CONFIG --atleast-pkgconfig-version $_pkg_min_version; then
+		AC_MSG_RESULT([yes])
+	else
+		AC_MSG_RESULT([no])
+		PKG_CONFIG=""
+	fi
+		
+fi[]dnl
+])# PKG_PROG_PKG_CONFIG
+
+# PKG_CHECK_EXISTS(MODULES, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])
+#
+# Check to see whether a particular set of modules exists.  Similar
+# to PKG_CHECK_MODULES(), but does not set variables or print errors.
+#
+#
+# Similar to PKG_CHECK_MODULES, make sure that the first instance of
+# this or PKG_CHECK_MODULES is called, or make sure to call
+# PKG_CHECK_EXISTS manually
+# --------------------------------------------------------------
+AC_DEFUN([PKG_CHECK_EXISTS],
+[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl
+if test -n "$PKG_CONFIG" && \
+    AC_RUN_LOG([$PKG_CONFIG --exists --print-errors "$1"]); then
+  m4_ifval([$2], [$2], [:])
+m4_ifvaln([$3], [else
+  $3])dnl
+fi])
+
+
+# _PKG_CONFIG([VARIABLE], [COMMAND], [MODULES])
+# ---------------------------------------------
+m4_define([_PKG_CONFIG],
+[if test -n "$PKG_CONFIG"; then
+    if test -n "$$1"; then
+        pkg_cv_[]$1="$$1"
+    else
+        PKG_CHECK_EXISTS([$3],
+                         [pkg_cv_[]$1=`$PKG_CONFIG --[]$2 "$3" 2>/dev/null`],
+			 [pkg_failed=yes])
+    fi
+else
+	pkg_failed=untried
+fi[]dnl
+])# _PKG_CONFIG
+
+# _PKG_SHORT_ERRORS_SUPPORTED
+# -----------------------------
+AC_DEFUN([_PKG_SHORT_ERRORS_SUPPORTED],
+[AC_REQUIRE([PKG_PROG_PKG_CONFIG])
+if $PKG_CONFIG --atleast-pkgconfig-version 0.20; then
+        _pkg_short_errors_supported=yes
+else
+        _pkg_short_errors_supported=no
+fi[]dnl
+])# _PKG_SHORT_ERRORS_SUPPORTED
+
+
+# PKG_CHECK_MODULES(VARIABLE-PREFIX, MODULES, [ACTION-IF-FOUND],
+# [ACTION-IF-NOT-FOUND])
+#
+#
+# Note that if there is a possibility the first call to
+# PKG_CHECK_MODULES might not happen, you should be sure to include an
+# explicit call to PKG_PROG_PKG_CONFIG in your configure.ac
+#
+#
+# --------------------------------------------------------------
+AC_DEFUN([PKG_CHECK_MODULES],
+[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl
+AC_ARG_VAR([$1][_CFLAGS], [C compiler flags for $1, overriding pkg-config])dnl
+AC_ARG_VAR([$1][_LIBS], [linker flags for $1, overriding pkg-config])dnl
+
+pkg_failed=no
+AC_MSG_CHECKING([for $1])
+
+_PKG_CONFIG([$1][_CFLAGS], [cflags], [$2])
+_PKG_CONFIG([$1][_LIBS], [libs], [$2])
+
+m4_define([_PKG_TEXT], [Alternatively, you may set the environment variables $1[]_CFLAGS
+and $1[]_LIBS to avoid the need to call pkg-config.
+See the pkg-config man page for more details.])
+
+if test $pkg_failed = yes; then
+        _PKG_SHORT_ERRORS_SUPPORTED
+        if test $_pkg_short_errors_supported = yes; then
+	        $1[]_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors "$2"`
+        else 
+	        $1[]_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "$2"`
+        fi
+	# Put the nasty error message in config.log where it belongs
+	echo "$$1[]_PKG_ERRORS" >&AS_MESSAGE_LOG_FD
+
+	ifelse([$4], , [AC_MSG_ERROR(dnl
+[Package requirements ($2) were not met:
+
+$$1_PKG_ERRORS
+
+Consider adjusting the PKG_CONFIG_PATH environment variable if you
+installed software in a non-standard prefix.
+
+_PKG_TEXT
+])],
+		[AC_MSG_RESULT([no])
+                $4])
+elif test $pkg_failed = untried; then
+	ifelse([$4], , [AC_MSG_FAILURE(dnl
+[The pkg-config script could not be found or is too old.  Make sure it
+is in your PATH or set the PKG_CONFIG environment variable to the full
+path to pkg-config.
+
+_PKG_TEXT
+
+To get pkg-config, see <http://pkg-config.freedesktop.org/>.])],
+		[$4])
+else
+	$1[]_CFLAGS=$pkg_cv_[]$1[]_CFLAGS
+	$1[]_LIBS=$pkg_cv_[]$1[]_LIBS
+        AC_MSG_RESULT([yes])
+	ifelse([$3], , :, [$3])
+fi[]dnl
+])# PKG_CHECK_MODULES
diff --git a/run-octave.in b/run-octave.in
--- a/run-octave.in
+++ b/run-octave.in
@@ -42,39 +42,46 @@ d1_path=`echo "$d1_list" | $AWK '{ t = (
 d2_path=`echo "$d2_list" | $AWK '{ t = (s $0); s = t; } END { sub (/:$/, "", s); print s; }'`
 d3_path=`echo "$d3_list" | $AWK '{ t = (s $0); s = t; } END { sub (/:$/, "", s); print s; }'`
 
 octave_executable="$builddir/src/octave"
 
 LOADPATH="$d1_path:$d2_path:$d3_path"
 IMAGEPATH="$top_srcdir/scripts/image"
 DOCFILE="$builddir/doc/interpreter/doc-cache"
+BUILT_IN_DOCSTRINGS_FILE="$builddir/libinterp/DOCSTRINGS"
 TEXIMACROSFILE="$top_srcdir/doc/interpreter/macros.texi"
 INFOFILE="$top_srcdir/doc/interpreter/octave.info"
 
 ## Checking for string equality below with prepended x's in order to
 ## handle problems with empty strings.
 if [ $# -gt 0 ]; then
   if [ "x$1" = "x-g" ]; then
     driver="gdb --args"
     shift
   elif [ "x$1" = "x-gud" ]; then
     ## Frontends for gdb (e.g. Emacs's GUD mode) need --annotate=3
     driver="gdb --annotate=3 --args"
     shift
+  elif [ "x$1" = "x-gud2" ]; then
+    ## The latest version of gud needs -i=mi. There isn't a good way to check
+    ## this at configure time, so we just add a gdb2 flag
+    driver="gdb -i=mi --args"
+    shift
   elif [ "x$1" = "x-valgrind" ]; then
     driver="valgrind --tool=memcheck"
     shift
   elif [ "x$1" = "x-strace" ]; then
     driver="strace -o octave.trace"
     shift
   elif [ "x$1" = "x-cli" ]; then
     octave_executable="$builddir/src/octave-cli"
     shift
   fi
 fi
 
 OCTAVE_SITE_INITFILE="$top_srcdir/scripts/startup/main-rcfile" \
-OCTAVE_DEFAULT_QT_SETTINGS="$top_srcdir/gui/default-qt-settings" \
+OCTAVE_DEFAULT_QT_SETTINGS="$top_srcdir/libgui/default-qt-settings" \
   exec $builddir/libtool --mode=execute $driver \
     "$octave_executable" --no-init-path --path="$LOADPATH" \
     --image-path="$IMAGEPATH" --doc-cache-file="$DOCFILE" \
+    --built-in-docstrings-file="$BUILT_IN_DOCSTRINGS_FILE" \
     --texi-macros-file="$TEXIMACROSFILE" --info-file="$INFOFILE" "$@"
diff --git a/scripts/Makefile.am b/scripts/Makefile.am
--- a/scripts/Makefile.am
+++ b/scripts/Makefile.am
@@ -1,9 +1,9 @@
-# Makefile for octave's scripts directory
+# Makefile for Octave's scripts directory
 #
 # Copyright (C) 1993-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
diff --git a/scripts/audio/wavread.m b/scripts/audio/wavread.m
--- a/scripts/audio/wavread.m
+++ b/scripts/audio/wavread.m
@@ -71,16 +71,17 @@ function [y, samples_per_sec, bits_per_s
     fseek (fid, 0, "bof");
 
     ## Find RIFF chunk.
     riff_size = find_chunk (fid, "RIFF", file_size);
     riff_pos = ftell (fid);
     if (riff_size == -1)
       error ("wavread: file contains no RIFF chunk");
     endif
+    riff_size = min (riff_size, file_size - riff_pos);
 
     riff_type = char (fread (fid, 4))';
     if (! strcmp (riff_type, "WAVE"))
       error ("wavread: file contains no WAVE signature");
     endif
     riff_pos = riff_pos + 4;
     riff_size = riff_size - 4;
 
@@ -95,16 +96,17 @@ function [y, samples_per_sec, bits_per_s
     ## Find data chunk inside the RIFF chunk.
     ## We don't assume that it comes after the format chunk.
     fseek (fid, riff_pos, "bof");
     data_size = find_chunk (fid, "data", riff_size);
     data_pos = ftell (fid);
     if (data_size == -1)
       error ("wavread: file contains no data chunk");
     endif
+    data_size = min (data_size, file_size - data_pos);
 
     ### Read format chunk.
     fseek (fid, fmt_pos, "bof");
 
     ## Sample format code.
     format_tag = fread (fid, 1, "uint16", 0, BYTEORDER);
     if (format_tag != FORMAT_PCM && format_tag != FORMAT_IEEE_FLOAT)
       error ("wavread: sample format %#x is not supported", format_tag);
diff --git a/scripts/audio/wavwrite.m b/scripts/audio/wavwrite.m
--- a/scripts/audio/wavwrite.m
+++ b/scripts/audio/wavwrite.m
@@ -18,17 +18,18 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} wavwrite (@var{y}, @var{filename})
 ## @deftypefnx {Function File} {} wavwrite (@var{y}, @var{Fs}, @var{filename})
 ## @deftypefnx {Function File} {} wavwrite (@var{y}, @var{Fs}, @var{bps}, @var{filename})
 ## Write @var{y} to the canonical RIFF/WAVE sound file @var{filename}
 ## with sample rate @var{Fs} and bits per sample @var{bps}.  The
 ## default sample rate is 8000 Hz with 16-bits per sample.  Each column
-## of the data represents a separate channel.
+## of the data represents a separate channel.  If @var{y} is either a
+## row vector or a column vector, it is written as a single channel.
 ## @seealso{wavread}
 ## @end deftypefn
 
 ## Author: Michael Zeising <michael@michaels-website.de>
 ## Created: 06 December 2005
 
 function wavwrite (y, varargin)
 
@@ -45,39 +46,45 @@ function wavwrite (y, varargin)
   filename = varargin{end};
   if (nargin > 2)
     samples_per_sec = varargin{1};
     if (nargin > 3)
       bits_per_sample = varargin{2};
     endif
   endif
 
+  ## calculate filesize
+  [n, channels] = size (y);
+
+  ## allow y to be a row vector
+  if (n == 1)
+    n = channels;
+    channels = 1;
+  endif
+
   ## test arguments
-  if (columns (y) < 1)
+  if (channels < 1)
     error ("wavwrite: Y must have at least one column");
   endif
-  if (columns (y) > 0x7FFF)
+  if (channels > 0x7FFF)
     error ("wavwrite: Y has more than 32767 columns (too many for a WAV-file)");
   endif
 
   ## determine sample format
   switch (bits_per_sample)
     case 8
       format = "uint8";
     case 16
       format = "int16";
     case 32
       format = "int32";
     otherwise
       error ("wavwrite: sample resolution not supported");
   endswitch
 
-  ## calculate filesize
-  [n, channels] = size (y);
-
   ## size of data chunk
   ck_size = n*channels*(bits_per_sample/8);
 
   if (! ischar (filename))
     error ("wavwrite: expecting FILENAME to be a character string");
   endif
 
   ## open file for writing binary
@@ -169,15 +176,24 @@ endfunction
 %! wavwrite (A, 4000, 8, fname);
 %! [B, samples_per_sec, bits_per_sample] = wavread (fname);
 %! assert (A,B, 1/128);
 %! assert (samples_per_sec, 4000);
 %! assert (bits_per_sample, 8);
 %! unlink (fname);
 %
 %!test
-%! A = [-2:2];
+%! A = [-2:2]';
 %! wavwrite (A, fname);
 %! B = wavread (fname);
 %! B *= 32768;
-%! assert (B, [-32768 -32768 0 32767 32767]);
+%! assert (B, [-32768 -32768 0 32767 32767]');
+%! unlink (fname);
+%
+%!test
+%! A = [-1:0.1:1];
+%! wavwrite (A, fname);
+%! [B, samples_per_sec, bits_per_sample] = wavread (fname);
+%! assert (A', B, 1/2^15);
+%! assert (samples_per_sec, 8000);
+%! assert (bits_per_sample, 16);
 %! unlink (fname);
 
diff --git a/scripts/general/interp1.m b/scripts/general/interp1.m
--- a/scripts/general/interp1.m
+++ b/scripts/general/interp1.m
@@ -200,17 +200,17 @@ function yi = interp1 (x, y, varargin)
     jumps = x(1:end-1) == x(2:end);
     have_jumps = any (jumps);
     if (have_jumps)
       if (any (strcmp (method, {"nearest", "linear"})))
         if (any (jumps(1:nx-2) & jumps(2:nx-1)))
           error ("interp1: extra points in discontinuities");
         endif
       else
-        error ("interp1: discontinuities not supported for method `%s'", method);
+        error ("interp1: discontinuities not supported for method '%s'", method);
       endif
     endif
   endif
 
   ## Proceed with interpolating by all methods.
   switch (method)
   case "nearest"
     pp = mkpp ([x(1); (x(1:nx-1)+x(2:nx))/2; x(nx)], shiftdim (y, 1), szy(2:end));
diff --git a/scripts/general/interp2.m b/scripts/general/interp2.m
--- a/scripts/general/interp2.m
+++ b/scripts/general/interp2.m
@@ -392,25 +392,25 @@ function ZI = interp2 (varargin)
            + AY0  .* AX1  .* Z (sym_sub2ind (sz, L,   K-1)) ...
            + AY1  .* AX_2 .* Z (sym_sub2ind (sz, L-1, K+2)) ...
            + AY1  .* AX_1 .* Z (sym_sub2ind (sz, L-1, K+1)) ...
            + AY1  .* AX0  .* Z (sym_sub2ind (sz, L-1, K))   ...
            + AY1  .* AX1  .* Z (sym_sub2ind (sz, L-1, K-1));
         ZI (!inside) = extrapval;
 
       else
-        error ("interp2: input data must have `meshgrid' format");
+        error ("interp2: input data must have 'meshgrid' format");
       endif
 
     elseif (strcmp (method, "spline"))
       if (isgriddata (XI) && isgriddata (YI'))
         ZI = __splinen__ ({Y(:,1).', X(1,:)}, Z, {YI(:,1), XI(1,:)}, extrapval,
                         "spline");
       else
-        error ("interp2: input data must have `meshgrid' format");
+        error ("interp2: input data must have 'meshgrid' format");
       endif
     else
       error ("interp2: interpolation METHOD not recognized");
     endif
 
   endif
 endfunction
 
diff --git a/scripts/general/interp3.m b/scripts/general/interp3.m
--- a/scripts/general/interp3.m
+++ b/scripts/general/interp3.m
@@ -86,17 +86,17 @@ function vi = interp3 (varargin)
   endif
 
   if (nargs < 3 || (nargs == 4 && ! isvector (varargin{1})
                     && nargs == (ndims (varargin{1}) + 1)))
     v = varargin{1};
     if (ndims (v) != 3)
       error ("interp3: expect 3-dimensional array of values");
     endif
-    x = varargin (2:end);
+    x = varargin (2:nargs);
     if (any (! cellfun (@isvector, x)))
       for i = 2 : 3
         if (! size_equal (x{1}, x{i}))
           error ("interp3: dimensional mismatch");
         endif
         x{i} = permute (x{i}, [2, 1, 3]);
       endfor
       x{1} = permute (x{1}, [2, 1, 3]);
@@ -132,25 +132,58 @@ function vi = interp3 (varargin)
     vi = ipermute (interpn (x{:}, v, y{:}, method, extrapval), [2, 1, 3]);
   else
     error ("interp3: wrong number or incorrectly formatted input arguments");
   endif
 endfunction
 
 
 %!test
-%! x = y = z = -1:1;
+%! x = y = z = -1:1; y = y + 2;
 %! f = @(x,y,z) x.^2 - y - z.^2;
 %! [xx, yy, zz] = meshgrid (x, y, z);
 %! v = f (xx,yy,zz);
-%! xi = yi = zi = -1:0.5:1;
+%! xi = yi = zi = -1:0.5:1; yi = yi + 2.1;
 %! [xxi, yyi, zzi] = meshgrid (xi, yi, zi);
 %! vi = interp3 (x, y, z, v, xxi, yyi, zzi);
-%! [xxi, yyi, zzi] = ndgrid (xi, yi, zi);
-%! vi2 = interpn (x, y, z, v, xxi, yyi, zzi);
+%! [xxi, yyi, zzi] = ndgrid (yi, xi, zi);
+%! vi2 = interpn (y, x, z, v, xxi, yyi, zzi);
+%! tol = 10 * eps;
+%! assert (vi, vi2, tol);
+
+%!test
+%! x=z=1:2; y=1:3;xi=zi=.6:1.6; yi=1; v=ones([3,2,2]);  v(:,2,1)=[7 ;5;4];  v(:,1,2)=[2 ;3;5];
+%! [xxi3, yyi3, zzi3] = meshgrid (xi, yi, zi);
+%! [xxi, yyi, zzi] = ndgrid (yi, xi, zi);
+%! vi = interp3 (x, y, z, v, xxi3, yyi3, zzi3, "nearest");
+%! vi2 = interpn (y, x, z, v, xxi, yyi, zzi,"nearest");
+%! assert (vi, vi2);
+
+%!test
+%! x=z=1:2; y=1:3;xi=zi=.6:1.6; yi=1; v=ones([3,2,2]);  v(:,2,1)=[7 ;5;4];  v(:,1,2)=[2 ;3;5];
+%! vi = interp3 (x, y, z, v, xi+1, yi, zi, "nearest",3);
+%! vi2 = interpn (y, x, z, v, yi, xi+1, zi,"nearest", 3);
+%! assert (vi, vi2);
+
+%!test
+%! x=z=1:2; y=1:3;xi=zi=.6:1.6; yi=1; v=ones([3,2,2]);  v(:,2,1)=[7 ;5;4];  v(:,1,2)=[2 ;3;5];
+%! vi = interp3 (x, y, z, v, xi, yi, zi, "nearest");
+%! vi2 = interpn (y, x, z, v, yi, xi, zi,"nearest");
+%! assert (vi, vi2);
+
+%!test
+%! x=z=1:2; y=1:3;xi=zi=.6:1.6; yi=1; v=ones([3,2,2]);  v(:,2,1)=[7 ;5;4];  v(:,1,2)=[2 ;3;5];
+%! vi = interp3 (v, xi, yi, zi, "nearest",3);
+%! vi2 = interpn (v, yi, xi, zi,"nearest", 3);
+%! assert (vi, vi2);
+
+%!test
+%! xi=zi=.6:1.6; yi=1; v=ones([3,2,2]);  v(:,2,1)=[7 ;5;4];  v(:,1,2)=[2 ;3;5];
+%! vi = interp3 (v, xi, yi, zi, "nearest");
+%! vi2 = interpn (v, yi, xi, zi,"nearest");
 %! assert (vi, vi2);
 
 %!shared z, zout, tol
 %! z = zeros (3, 3, 3);
 %! zout = zeros (5, 5, 5);
 %! z(:,:,1) = [1 3 5; 3 5 7; 5 7 9];
 %! z(:,:,2) = z(:,:,1) + 2;
 %! z(:,:,3) = z(:,:,2) + 2;
diff --git a/scripts/general/repmat.m b/scripts/general/repmat.m
--- a/scripts/general/repmat.m
+++ b/scripts/general/repmat.m
@@ -35,34 +35,58 @@
 
 function x = repmat (A, m, n)
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
   if (nargin == 3)
-    if (! (isscalar (m) && isscalar (n)))
-      error ("repmat: with 3 arguments M and N must be scalar");
+    if (! isempty (m) && isempty (n))
+      m = m(:).';
+      n = 1;
+    elseif (isempty (m) && ! isempty (n))
+      m = n(:).';
+      n = 1;
+    elseif (isempty (m) && isempty (n))
+      m = n = 1;
+    else
+      if (all (size (m) > 1))
+        m = m(:,1);
+        if (numel (m) < 3)
+          n = n(end);
+        else
+          n = [];
+        endif
+      endif
+      if (all (size (n) > 1))
+        n = n(:,1);
+      endif
+      m = m(:).';
+      n = n(:).';
     endif
-    idx = [m, n];
   else
-    if (isscalar (m))
-      idx = [m, m];
+    if (isempty (m))
+      m = n = 1;
+    elseif (isscalar (m))
       n = m;
-    elseif (isvector (m) && length (m) > 1)
-      ## Ensure that we have a row vector
-      idx = m(:).';
+    elseif (ndims (m) > 2)
+      error ("repmat: M has more than 2 dimensions")
+    elseif (all (size (m) > 1))
+      m = m(:,1).';
+      n = [];
     else
-      error ("repmat: invalid dimensional argument");
+      m = m(:).';
+      n = [];
     endif
   endif
+  idx = [m, n];
 
   if (all (idx < 0))
-    error ("repmat: invalid dimensions");
+    error ("repmat: invalid dimensions")
   else
     idx = max (idx, 0);
   endif
 
   if (numel (A) == 1)
     ## optimize the scalar fill case.
     if (any (idx == 0))
       x = resize (A, idx);
@@ -96,16 +120,30 @@ function x = repmat (A, m, n)
     # add singleton dims
     aaidx(2,:) = 1;
     A = reshape (A, aaidx(:));
     x = reshape (A (cidx{:}), idx .* aidx);
   endif
 
 endfunction
 
+# Tests for ML compatibility
+%!shared x
+%! x = [1 2 3];
+%!assert (repmat (x, [3, 1]), repmat (x, 3, []))
+%!assert (repmat (x, [3, 1]), repmat (x, [], 3))
+%!assert (repmat (x, [1, 3]), repmat (x, [], [1, 3]))
+%!assert (repmat (x, [1, 3]), repmat (x, [1, 3], []))
+%!assert (repmat (x, [1 3]), repmat (x, [1 3; 3 3]))
+%!assert (repmat (x, [1 1 2]), repmat (x, [1 1; 1 3; 2 1]))
+%!assert (repmat (x, [1 3; 1 3], [1; 3]), repmat (x, [1 1 3]))
+%!assert (repmat (x, [1 1], 4), repmat (x, [1 3; 1 3], [1; 4]))
+%!assert (repmat (x, [1 1], 4), repmat (x, [1 3; 1 3], [1 2; 3 4]))
+%!assert (repmat (x, [1 1], 4), repmat (x, [1 1 4]));
+%!assert (repmat (x, [1 1], 4), repmat (x, 1, [1 4]));
 
 # Test various methods of providing size parameters
 %!shared x
 %! x = [1 2;3 4];
 %!assert (repmat (x, [1 1]), repmat (x, 1))
 %!assert (repmat (x, [3 3]), repmat (x, 3))
 %!assert (repmat (x, [1 1]), repmat (x, 1, 1))
 %!assert (repmat (x, [1 3]), repmat (x, 1, 3))
diff --git a/scripts/geometry/voronoi.m b/scripts/geometry/voronoi.m
--- a/scripts/geometry/voronoi.m
+++ b/scripts/geometry/voronoi.m
@@ -100,20 +100,17 @@ function [vx, vy] = voronoi (varargin)
     endif
   endif
 
   linespec = {"b"};
   if (narg <= nargin && ischar (varargin{narg}))
     linespec = varargin(narg);
   endif
 
-  lx = length (x);
-  ly = length (y);
-
-  if (lx != ly)
+  if (length (x) != length (y))
     error ("voronoi: X and Y must be vectors of the same length");
   endif
 
   ## Add box to approximate rays to infinity. For Voronoi diagrams the
   ## box can (and should) be close to the points themselves. To make the
   ## job of finding the exterior edges it should be at least two times the
   ## delta below however
   xmax = max (x(:));
@@ -128,45 +125,43 @@ function [vx, vy] = voronoi (varargin)
           xmax + scale * xdelta; xmax + scale * xdelta];
   ybox = [ymin - scale * ydelta; ymax + scale * ydelta; ...
           ymax + scale * ydelta; ymin - scale * ydelta];
 
   [p, c, infi] = __voronoi__ ("voronoi",
                               [[x(:) ; xbox(:)], [y(:); ybox(:)]],
                               opts{:});
 
-  idx = find (! infi);
-  ll = length (idx);
-  c = c(idx).';
-  k = sum (cellfun ("length", c));
+  c = c(! infi).';
+  ## Delete null entries which cause problems in next cellfun function
+  c(cellfun ("isempty", c)) = [];
   edges = cell2mat (cellfun (@(x) [x ; [x(end), x(1:end-1)]], c,
                              "uniformoutput", false));
 
   ## Identify the unique edges of the Voronoi diagram
   edges = sortrows (sort (edges).').';
-  edges = edges (:, [(edges(1, 1: end - 1) != edges(1, 2 : end) | ...
-                      edges(2, 1 :end - 1) != edges(2, 2 : end)), true]);
+  edges = edges(:, [(edges(1, 1 :end - 1) != edges(1, 2 : end) | ...
+                     edges(2, 1 :end - 1) != edges(2, 2 : end)), true]);
 
   ## Eliminate the edges of the diagram representing the box
-  poutside = (1 : rows (p)) ...
-      (p (:, 1) < xmin - xdelta | p (:, 1) > xmax + xdelta | ...
-       p (:, 2) < ymin - ydelta | p (:, 2) > ymax + ydelta);
-  edgeoutside = ismember (edges (1, :), poutside) & ...
-      ismember (edges (2, :), poutside);
-  edges (:, edgeoutside) = [];
+  poutside = (1:rows (p)) ...
+      (p(:, 1) < xmin - xdelta | p(:, 1) > xmax + xdelta | ...
+       p(:, 2) < ymin - ydelta | p(:, 2) > ymax + ydelta);
+  edgeoutside = ismember (edges(1, :), poutside) & ...
+                ismember (edges(2, :), poutside);
+  edges(:, edgeoutside) = [];
 
   ## Get points of the diagram
   Vvx = reshape (p(edges, 1), size (edges));
   Vvy = reshape (p(edges, 2), size (edges));
 
   if (nargout < 2)
+    h = plot (handl, Vvx, Vvy, linespec{:}, x, y, '+');
     lim = [xmin, xmax, ymin, ymax];
-    h = plot (handl, Vvx, Vvy, linespec{:}, x, y, '+');
-    axis (lim + 0.1 * [[-1, 1] * (lim (2) - lim (1)), ...
-                       [-1, 1] * (lim (4) - lim (3))]);
+    axis (lim + 0.1 * [[-1, 1] * xdelta, [-1, 1] * ydelta]);
     if (nargout == 1)
       vx = h;
     endif
   else
     vx = Vvx;
     vy = Vvy;
   endif
 
diff --git a/scripts/help/unimplemented.m b/scripts/help/__unimplemented__.m
rename from scripts/help/unimplemented.m
rename to scripts/help/__unimplemented__.m
--- a/scripts/help/unimplemented.m
+++ b/scripts/help/__unimplemented__.m
@@ -13,53 +13,82 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} unimplemented ()
-## Undocumented internal function.
+## @deftypefn {Function File} {@var{txt} =} unimplemented (@var{fcn})
+## Return specific help text for the unimplemented function @var{fcn}.
+## This is usually a suggestion for an existing compatible function to use in
+## place of @var{fcn}.
+##
+## This function is not called by users, but by the Octave interpreter when
+## it fails to recognize an input string as a valid function name.  See
+## @code{missing_function_hook} for using a different handler for this event.
+## @seealso{missing_function_hook}
 ## @end deftypefn
 
-function txt = unimplemented (fcn)
+
+function txt = __unimplemented__ (fcn)
+
+  if (nargin != 1)
+    print_usage ();
+  endif
 
   is_matlab_function = true;
 
   ## Some smarter cases, add more as needed.
   switch (fcn)
 
-  case "importdata"
-    txt = ["importdata is not implemented.  Similar functionality is ",...
-    "available through @code{load}, @code{dlmread}, @code{csvread}, ",...
-    "or @code{textscan}."];  
-
   case "quad2d"
     txt = ["quad2d is not implemented.  Consider using dblquad."];
 
   case "gsvd"
     txt = ["gsvd is not currently part of core Octave.  See the ",...
+    "linear-algebra package at ",...
+    "@url{http://octave.sourceforge.net/linear-algebra/}."];
+
+  case "funm"
+    txt = ["funm is not currently part of core Octave.  See the ",...
     "linear-algebra package at @url{http://octave.sf.net/linear-algebra/}."];
 
   case "linprog"
     txt = ["Octave does not currently provide linprog.  ",...
     "Linear programming problems may be solved using @code{glpk}.  ",...
     "Try @code{help glpk} for more info."];
 
   case {"ode113", "ode15i", "ode15s", "ode23", "ode23s", "ode23t", "ode45", "odeget", "odeset"}
     txt = ["Octave provides lsode for solving differential equations.  ",...
     "For more information try @code{help lsode}.  ",...
     "Matlab-compatible ODE functions are provided by the odepkg package.  ",...
-    "See @url{http://octave.sf.net/odepkg/}."];
+    "See @url{http://octave.sourceforge.net/odepkg/}."];
+
+  case {"javaArray", "javaMethod", "javaMethodEDT", "javaObject", "javaObjectEDT", "javaaddpath", "javaclasspath", "javarmpath"}
+    txt = ["Java objects and methods can be used with the java package. ",...
+    "See @url{http://octave.sf.net/java/}."];
+
+  case {"errordlg", "helpdlg", "inputdlg", "listdlg", "questdlg", "warndlg"}
+    txt = ["Several dialog functions are provided in the java package. ",...
+    "See @url{http://octave.sf.net/java/}."];
+
+  case {"xlsread", "xlsfinfo", "xlswrite", "wk1read", "wk1finfo", "wk1write"}
+    txt = ["Functions for spreadsheet style I/O (.xls .xlsx .sxc .ods .dbf .wk1 etc.) " , ...
+    "are provided in the io package. ",...
+    "See @url{http://octave.sf.net/io/}."];
+
+  case {"avifile", "aviinfo", "aviread"}
+    txt = ["Basic video file support is provided in the video package. ",...
+    "See @url{http://octave.sf.net/video/}."];
 
   otherwise
     if (ismember (fcn, missing_functions ()))
-      txt = sprintf ("the `%s' function is not yet implemented in Octave", fcn);
+      txt = sprintf ("the '%s' function is not yet implemented in Octave", fcn);
     else
       is_matlab_function = false;
       txt = "";
     endif
   endswitch
 
   if (is_matlab_function)
     txt = [txt, "\n\n@noindent\nPlease read ",...
@@ -87,19 +116,16 @@ function list = missing_functions ()
   "alphamap",
   "annotation",
   "audiodevinfo",
   "audioplayer",
   "audiorecorder",
   "aufinfo",
   "auread",
   "auwrite",
-  "avifile",
-  "aviinfo",
-  "aviread",
   "bar3",
   "bar3h",
   "bench",
   "bicgstabl",
   "brush",
   "builddocsearchdb",
   "bvp4c",
   "bvp5c",
@@ -162,34 +188,31 @@ function list = missing_functions ()
   "dither",
   "docopt",
   "docsearch",
   "dragrect",
   "dynamicprops",
   "echodemo",
   "ellipj",
   "ellipke",
-  "errordlg",
   "evalc",
   "exifread",
   "expint",
   "export2wsdlg",
   "figurepalette",
   "filebrowser",
   "fill3",
   "fitsinfo",
   "fitsread",
   "flow",
-  "fminsearch",
   "frame2im",
   "freqspace",
   "funm",
   "gallery",
   "gammaincinv",
-  "gco",
   "getframe",
   "getpixelposition",
   "grabcode",
   "graymon",
   "gsvd",
   "guidata",
   "guide",
   "guihandles",
@@ -199,65 +222,53 @@ function list = missing_functions ()
   "hdf5info",
   "hdf5read",
   "hdf5write",
   "hdfinfo",
   "hdfread",
   "hdftool",
   "helpbrowser",
   "helpdesk",
-  "helpdlg",
   "helpwin",
   "hgexport",
   "hgload",
   "hgsave",
   "hgsetget",
   "hgtransform",
   "hostid",
   "ilu",
   "im2frame",
   "im2java",
   "imapprox",
   "imformats",
   "import",
-  "importdata",
   "inmem",
   "inputParser",
-  "inputdlg",
   "inspect",
   "instrfind",
   "instrfindall",
   "interpstreamspeed",
   "iscom",
   "isinterface",
   "isjava",
   "isocaps",
   "isstudent",
-  "javaArray",
-  "javaMethod",
-  "javaMethodEDT",
-  "javaObject",
-  "javaObjectEDT",
-  "javaaddpath",
   "javachk",
-  "javaclasspath",
-  "javarmpath",
   "ldl",
   "libfunctions",
   "libfunctionsview",
   "libisloaded",
   "libpointer",
   "libstruct",
   "light",
   "lightangle",
   "lighting",
   "linkaxes",
   "linkdata",
   "linsolve",
-  "listdlg",
   "listfonts",
   "loadlibrary",
   "lscov",
   "lsqr",
   "makehgtform",
   "material",
   "matlabrc",
   "maxNumCompThreads",
@@ -316,17 +327,16 @@ function list = missing_functions ()
   "printopt",
   "printpreview",
   "profsave",
   "propedit",
   "propertyeditor",
   "publish",
   "qmr",
   "quad2d",
-  "questdlg",
   "rbbox",
   "reducepatch",
   "reducevolume",
   "resample",
   "root",
   "rotate",
   "rotate3d",
   "selectmoveresize",
@@ -387,38 +397,33 @@ function list = missing_functions ()
   "unmesh",
   "userpath",
   "validateattributes",
   "verLessThan",
   "viewmtx",
   "visdiff",
   "volumebounds",
   "waitfor",
-  "warndlg",
   "waterfall",
   "wavfinfo",
   "wavplay",
   "wavrecord",
   "web",
   "whatsnew",
   "wk1finfo",
   "wk1read",
   "wk1write",
   "workspace",
-  "xlsfinfo",
-  "xlsread",
-  "xlswrite",
   "xmlread",
   "xmlwrite",
   "xslt",
   "zoom",
   };
 endfunction
 
 
 %!test
-%! str = unimplemented ("no_name_function");
+%! str = __unimplemented__ ("no_name_function");
 %! assert (isempty (str));
-%! str = unimplemented ("quad2d");
+%! str = __unimplemented__ ("quad2d");
 %! assert (str(1:51), "quad2d is not implemented.  Consider using dblquad.");
-%! str = unimplemented ("MException");
-%! assert (str(1:58), "the `MException' function is not yet implemented in Octave");
- 
+%! str = __unimplemented__ ("MException");
+%! assert (str(1:58), "the 'MException' function is not yet implemented in Octave");
diff --git a/scripts/help/doc.m b/scripts/help/doc.m
--- a/scripts/help/doc.m
+++ b/scripts/help/doc.m
@@ -14,22 +14,22 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Command} {} doc @var{function_name}
 ## Display documentation for the function @var{function_name}
-## directly from an on-line version of
+## directly from an online version of
 ## the printed manual, using the GNU Info browser.  If invoked without
 ## any arguments, the manual is shown from the beginning.
 ##
 ## For example, the command @kbd{doc rand} starts the GNU Info browser
-## at the @code{rand} node in the on-line version of the manual.
+## at the @code{rand} node in the online version of the manual.
 ##
 ## Once the GNU Info browser is running, help for using it is available
 ## using the command @kbd{C-h}.
 ## @seealso{help}
 ## @end deftypefn
 
 ## Author: Soren Hauberg <soren@hauberg.org>
 ## Adapted-by: jwe
@@ -87,17 +87,17 @@ function retval = doc (fname)
 
     if (have_fname)
       status = system (sprintf ("%s --index-search \"%s\"", cmd, fname));
     endif
 
     if (! (have_fname && status == 0))
       status = system (cmd);
       if (status == 127)
-        warning ("unable to find info program `%s'", info_program ());
+        warning ("unable to find info program '%s'", info_program ());
       endif
     endif
 
     if (nargout > 0)
       retval = status;
     endif
 
   else
diff --git a/scripts/help/get_first_help_sentence.m b/scripts/help/get_first_help_sentence.m
--- a/scripts/help/get_first_help_sentence.m
+++ b/scripts/help/get_first_help_sentence.m
@@ -61,19 +61,19 @@ function [text, status] = get_first_help
   switch (lower (format))
     case "plain text"
       [text, status] = first_sentence_plain_text (help_text, max_len);
     case "texinfo"
       [text, status] = first_sentence_texinfo (help_text, max_len);
     case "html"
       [text, status] = first_sentence_html (help_text, max_len);
     case "not documented"
-      error ("get_first_help_sentence: `%s' is not documented\n", name);
+      error ("get_first_help_sentence: '%s' is not documented\n", name);
     case "not found"
-      error ("get_first_help_sentence: `%s' not found\n", name);
+      error ("get_first_help_sentence: '%s' not found\n", name);
     otherwise
       error ("get_first_help_sentence: internal error: unsupported help text format: '%s'\n", format);
   endswitch
 
   if (nargout <= 1 && status != 0)
     warning ("get_first_help_sentence: couldn't run makeinfo on '%s'", name);
   endif
 endfunction
diff --git a/scripts/help/help.m b/scripts/help/help.m
--- a/scripts/help/help.m
+++ b/scripts/help/help.m
@@ -95,17 +95,17 @@ function retval = help (name)
     switch (lower (format))
       case "plain text"
         status = 0;
       case "texinfo"
         [text, status] = __makeinfo__ (text, "plain text");
       case "html"
         [text, status] = strip_html_tags (text);
       case "not documented"
-        error ("help: `%s' is not documented\n", name);
+        error ("help: '%s' is not documented\n", name);
       case "not found"
         do_contents (name);
         return;
       otherwise
         error ("help: internal error: unsupported help text format: '%s'\n", format);
     endswitch
 
     ## Print text
@@ -192,17 +192,17 @@ function do_contents (name)
   endfor
 
   if (found)
     puts (__additional_help_message__ ());
   else
     msg = feval (missing_function_hook, name);
 
     if (isempty (msg))
-      msg = sprintf ("`%s' not found", name);
+      msg = sprintf ("'%s' not found", name);
     endif
 
     error ("help: %s\n", msg);
   endif
 
 endfunction
 
 
diff --git a/scripts/help/module.mk b/scripts/help/module.mk
--- a/scripts/help/module.mk
+++ b/scripts/help/module.mk
@@ -1,24 +1,24 @@
 FCN_FILE_DIRS += help
 
 help_PRIVATE_FCN_FILES = \
   help/private/__additional_help_message__.m \
   help/private/__strip_html_tags__.m
 
 help_FCN_FILES = \
   help/__makeinfo__.m \
+  help/__unimplemented__.m \
   help/doc.m \
   help/gen_doc_cache.m \
   help/get_first_help_sentence.m \
   help/help.m \
   help/lookfor.m \
   help/print_usage.m \
   help/type.m \
-  help/unimplemented.m \
   help/which.m \
   $(help_PRIVATE_FCN_FILES)
 
 FCN_FILES += $(help_FCN_FILES)
 
 PKG_ADD_FILES += help/PKG_ADD
 
 DIRSTAMP_FILES += help/$(octave_dirstamp)
diff --git a/scripts/help/print_usage.m b/scripts/help/print_usage.m
--- a/scripts/help/print_usage.m
+++ b/scripts/help/print_usage.m
@@ -28,24 +28,25 @@
 function print_usage (name)
   x = dbstack ();
   ## Handle input
   if (nargin == 0)
     ## Determine the name of the calling function
     if (numel (x) > 1)
       name = x (2).name;
     else
-      error ("print_usage: invalid function\n");
+      error ("Octave:invalid-context", "print_usage: invalid function\n");
     endif
     fullpath = evalin ("caller", "mfilename (""fullpath"")");
     if (strcmp (fullpath(end-length(name)+1:end), name))
       fullname = [fullpath, ".m"];
     endif
   elseif (!ischar (name))
-    error ("print_usage: input argument must be a string");
+    error ("Octave:invalid-input-arg",
+                                "print_usage: input argument must be a string");
   else
     fullname = name;
   endif
 
   ## Determine if we're called from top level.
   at_toplev = length (x) < 2 || (length (x) == 2 && strcmp (x(2).name, name));
 
   ## Do the actual work
@@ -54,42 +55,42 @@ function print_usage (name)
   switch (lower (format))
     case "plain text"
       [usage_string, status] = get_usage_plain_text (text, max_len);
     case "texinfo"
       [usage_string, status] = get_usage_texinfo (text, max_len);
     case "html"
       [usage_string, status] = get_usage_html (text, max_len);
     case "not documented"
-      error ("print_usage: `%s' is not documented\n", name);
+      error ("print_usage: '%s' is not documented\n", name);
     case "not found"
-      error ("print_usage: `%s' not found\n", name);
+      error ("print_usage: '%s' not found\n", name);
     otherwise
       error ("print_usage: internal error: unsupported help text format: '%s'\n", format);
   endswitch
 
   ## Raise the final error
   if (status != 0)
     warning ("print_usage: Texinfo formatting filter exited abnormally");
     warning ("print_usage: raw Texinfo source of help text follows...\n");
   endif
 
   if (at_toplev)
-    error ("Invalid call to %s.  Correct usage is:\n\n%s\n%s",
+    error ("Octave:invalid-fun-call", "Invalid call to %s.  Correct usage is:\n\n%s\n%s",
            name, usage_string, __additional_help_message__ ());
   else
     msg = sprintf ("Invalid call to %s.  Correct usage is:\n\n%s",
                    name, usage_string);
     ## Ensure that the error doesn't end up with a newline, as that disables
     ## backtraces.
     if (msg(end) == "\n")
       msg(end) = " ";
     endif
 
-    error (msg);
+    error ("Octave:invalid-fun-call", msg);
   endif
 
 endfunction
 
 function [retval, status] = get_usage_plain_text (help_text, max_len)
   ## Extract first line by searching for a double line-end.
   line_end_idx = strfind (help_text, "\n\n");
   retval = help_text (1:min ([line_end_idx , max_len, length(help_text)]));
@@ -134,9 +135,8 @@ function [retval, status] = get_usage_ht
 
   ## Extract first line with plain text method.
   retval = get_usage_plain_text (help_text, max_len);
 endfunction
 
 
 ## Stop reporting function as missing tests.  No good tests possible.
 %!assert (1)
-
diff --git a/scripts/help/private/__additional_help_message__.m b/scripts/help/private/__additional_help_message__.m
--- a/scripts/help/private/__additional_help_message__.m
+++ b/scripts/help/private/__additional_help_message__.m
@@ -23,17 +23,17 @@
 
 function msg = __additional_help_message__ ()
 
   if (suppress_verbose_help_message ())
     msg = "";
   else
     msg = "\
 Additional help for built-in functions and operators is\n\
-available in the on-line version of the manual.  Use the command\n\
-`doc <topic>' to search the manual index.\n\
+available in the online version of the manual.  Use the command\n\
+'doc <topic>' to search the manual index.\n\
 \n\
 Help and information about Octave is also available on the WWW\n\
 at http://www.octave.org and via the help@octave.org\n\
 mailing list.\n";
   endif
 
 endfunction
diff --git a/scripts/help/type.m b/scripts/help/type.m
--- a/scripts/help/type.m
+++ b/scripts/help/type.m
@@ -68,23 +68,23 @@ function retval = type (varargin)
         text = sprintf ("%s is a variable\n%s", name, desc);
       endif
     elseif (e == 2)
       ## m-file or ordinary file
       file = which (name);
       if (isempty (file))
         ## 'name' is an ordinary file, and not a function name.
         ## FIXME: Should we just print it anyway?
-        error ("type: `%s' undefined\n", name);
+        error ("type: '%s' undefined\n", name);
       endif
 
       ## Read the file
       fid = fopen (file, "r");
       if (fid < 0)
-        error ("type: couldn't open `%s' for reading", file);
+        error ("type: couldn't open '%s' for reading", file);
       endif
       contents = char (fread (fid).');
       fclose (fid);
 
       if (quiet)
         text = contents;
       else
         text = sprintf ("%s is the user-defined function defined from: %s\n\n%s",
@@ -94,17 +94,17 @@ function retval = type (varargin)
       text = sprintf ("%s is a dynamically-linked function", name);
     elseif (e == 5)
       text = sprintf ("%s is a built-in function", name);
     elseif (any (strcmp (__operators__ (), name)))
       text = sprintf ("%s is an operator", name);
     elseif (any (strcmp (__keywords__ (), name)))
       text = sprintf ("%s is a keyword", name);
     else
-      error ("type: `%s' undefined\n", name);
+      error ("type: '%s' undefined\n", name);
     endif
 
     ## Should we return the text or print if
     if (nargout == 0)
       disp (text);
     else
       retval {n} = text;
     endif
diff --git a/scripts/help/which.m b/scripts/help/which.m
--- a/scripts/help/which.m
+++ b/scripts/help/which.m
@@ -27,25 +27,25 @@ function varargout = which (varargin)
 
   if (nargin > 0 && iscellstr (varargin))
     m = __which__ (varargin{:});
 
     if (nargout == 0)
       for i = 1:nargin
         if (isempty (m(i).file))
           if (! isempty (m(i).type))
-            printf ("`%s' is a %s\n",
+            printf ("'%s' is a %s\n",
                     m(i).name, m(i).type);
           endif
         else
           if (isempty (m(i).type))
-            printf ("`%s' is the file %s\n",
+            printf ("'%s' is the file %s\n",
                     m(i).name, m(i).file);
           else
-            printf ("`%s' is a %s from the file %s\n",
+            printf ("'%s' is a %s from the file %s\n",
                     m(i).name, m(i).type, m(i).file);
           endif
         endif
       endfor
     else
       varargout = {m.file};
     endif
   else
diff --git a/scripts/image/cmpermute.m b/scripts/image/cmpermute.m
--- a/scripts/image/cmpermute.m
+++ b/scripts/image/cmpermute.m
@@ -49,19 +49,17 @@ function [Y, newmap] = cmpermute (X, map
     error ("cmpermute: X must be of class uint8 or double");
   endif
 
   if (! isreal (X) || issparse (X)
       || (isfloat (X) && (any (X(:) < 1 || any (X(:) != fix (X(:)))))))
     error ("cmpermute: X must be an indexed image");
   endif
 
-  if (! isnumeric (map) || iscomplex (map)
-      || ndims (map) != 2 || columns (map) != 3
-      || any (map(:) < 0) || any (map(:) > 1))
+  if (! iscolormap (map))
     error ("cmpermute: MAP must be a valid colormap");
   endif
 
   if (nargin < 3)
     index = randperm (rows (map));
   elseif (! isvector (index) || length (index) != rows (map))
     error ("cmpermute: invalid parameter INDEX");
   endif
diff --git a/scripts/image/cmunique.m b/scripts/image/cmunique.m
--- a/scripts/image/cmunique.m
+++ b/scripts/image/cmunique.m
@@ -63,19 +63,17 @@ function [Y, newmap] = cmunique (X, map)
   cls = class (X);
   ## FIXME: Documentation accepts only 3 classes.  Could easily add 'single'.
   if (! any (isa (X, {"uint8", "uint16", "double"})))
     error ("cmunique: X is of invalid data type '%s'", cls);
   endif
 
   if (nargin == 2)
     ## (X, map) case
-    if (! isnumeric (map) || iscomplex (map)
-        || ndims (map) != 2 || columns (map) != 3
-        || any (map(:) < 0) || any (map(:) > 1))
+    if (! iscolormap (map))
       error ("cmunique: MAP must be a valid colormap");
     endif
     [newmap,i,j] = unique (map, "rows");  # calculate unique colormap
     if (isa (X, "double"))
       Y = j(X);               # find new indices
     else
       Y = j(double (X) + 1);  # find new indices
     endif
diff --git a/scripts/image/imwrite.m b/scripts/image/imwrite.m
--- a/scripts/image/imwrite.m
+++ b/scripts/image/imwrite.m
@@ -156,23 +156,18 @@ function imwrite (img, varargin)
         img = uint8 (img - 1);
       endif
       if (nd != 2 && nd != 4)
         error ("imwrite: invalid size for indexed image");
       endif
     else
       error ("imwrite: %s: invalid class for indexed image data", img_class);
     endif
-    if (isa (map, "double"))
-      if (ndims (map) != 2 || columns (map) != 3)
-        error ("imwrite: invalid size for colormap");
-      endif
-    else
-      error ("imwrite: %s invalid class for indexed image colormap",
-             class (map));
+    if (! iscolormap (map))
+      error ("imwrite: invalid indexed image colormap");
     endif
 
     ## FIXME -- we should really be writing indexed images here but
     ## __magick_write__ needs to be fixed to handle them.
 
     [r, g, b] = ind2rgb (img, map);
     tmp = uint8 (cat (3, r, g, b) * 255);
 
diff --git a/scripts/image/ind2rgb.m b/scripts/image/ind2rgb.m
--- a/scripts/image/ind2rgb.m
+++ b/scripts/image/ind2rgb.m
@@ -41,17 +41,17 @@ function [R, G, B] = ind2rgb (x, map)
   endif
 
   ## Check if X is an indexed image.
   if (ndims (x) != 2 || any (x(:) != fix (x(:))) || min (x(:)) < 1)
     error ("ind2rgb: X must be an indexed image");
   endif
 
   ## Check the color map.
-  if (ndims (map) != 2 || columns (map) != 3)
+  if (! iscolormap (map))
     error ("ind2rgb: MAP must be a valid colormap");
   endif
 
   ## Do we have enough colors in the color map?
   maxidx = max (x(:));
   rm = rows (map);
   if (rm < maxidx)
     ## Pad with the last color in the map.
diff --git a/scripts/image/iscolormap.m b/scripts/image/iscolormap.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/iscolormap.m
@@ -0,0 +1,52 @@
+## Copyright (C) 2012 Carn√´ Draug
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {} iscolormap (@var{cmap})
+## Return true if @var{cmap} is a colormap.
+##
+## A colormap is an @var{n} row by 3 column matrix.  The columns contain red,
+## green, and blue intensities respectively.  All entries must be between 0
+## and 1 inclusive.
+##
+## @seealso{colormap, rgbplot}
+## @end deftypefn
+
+## Author: Carn√´ Draug <carandraug+dev@gmail.com>
+
+function retval = iscolormap (cmap)
+
+  if (nargin != 1)
+    print_usage;
+  endif
+
+  retval = (isnumeric (cmap) && isreal (cmap) &&
+            columns (cmap) == 3 && ndims (cmap) == 2 && isa (cmap, "double") &&
+            min (cmap(:)) >= 0 && max (cmap(:)) <= 1);
+
+endfunction
+
+
+%!assert (iscolormap (jet (64)))
+%!assert (iscolormap ({0 1 0}), false)
+%!assert (iscolormap ([0 1i 0]), false)
+%!assert (iscolormap (ones (3,4)), false)
+%!assert (iscolormap (ones (3,3,3)), false)
+%!assert (iscolormap (single (jet (64))), false)
+%!assert (iscolormap ([0 0 -2]), false)
+%!assert (iscolormap ([0 0 2]), false)
diff --git a/scripts/image/module.mk b/scripts/image/module.mk
--- a/scripts/image/module.mk
+++ b/scripts/image/module.mk
@@ -13,16 +13,17 @@ image_FCN_FILES = \
   image/copper.m \
   image/flag.m \
   image/gmap40.m \
   image/gray.m \
   image/gray2ind.m \
   image/hot.m \
   image/hsv.m \
   image/hsv2rgb.m \
+  image/iscolormap.m \
   image/image.m \
   image/imagesc.m \
   image/imfinfo.m \
   image/imread.m \
   image/imshow.m \
   image/imwrite.m \
   image/ind2gray.m \
   image/ind2rgb.m \
diff --git a/scripts/image/rgbplot.m b/scripts/image/rgbplot.m
--- a/scripts/image/rgbplot.m
+++ b/scripts/image/rgbplot.m
@@ -12,49 +12,50 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} rgbplot (@var{cmap})
+## @deftypefn  {Function File} {} rgbplot (@var{cmap})
+## @deftypefnx {Function File} {@var{h} =} rgbplot (@var{cmap})
 ## Plot the components of a colormap.
 ##
 ## The first column is plotted in red, the second column in green, and
 ## the third column in blue.  The values are between 0 and 1 and represent
 ## the intensity of the RGB components in the given indexed color.
+##
+## The optional return value @var{h} is a graphics handle to the created plot.
+##
 ## @seealso{colormap}
 ## @end deftypefn
 
-function rgbplot (cmap)
+function retval = rgbplot (cmap)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  if (! ismatrix (cmap) || ndims (cmap) != 2 || columns (cmap) != 3)
-    error ("rgbplot: CMAP must be a matrix of size Nx3");
-  elseif (any (cmap(:) < 0) || any (cmap(:) > 1))
-    error ("rgbplot: CMAP intensities must be in the range [0, 1]");
+  if (! iscolormap (cmap))
+    error ("rgbplot: CMAP must be a colormap");
   endif
 
-  plot (cmap(:,1),"r", cmap(:,2),"g", cmap(:,3),"b");
+  h = plot (cmap(:,1),"r", cmap(:,2),"g", cmap(:,3),"b");
   set (gca, 'ytick', 0:0.1:1);
   xlabel ("color index");
 
+  if (nargout > 0)
+    retval = h;
+  endif
+
 endfunction
 
 
 %!demo
 %! clf;
 %! rgbplot (ocean);
 
 %%test input validation
 %!error rgbplot ()
 %!error rgbplot (1,2)
-%!error <CMAP must be a matrix of size Nx3> rgbplot ({0 1 0})
-%!error <CMAP must be a matrix of size Nx3> rgbplot (ones (3,3,3))
-%!error <CMAP must be a matrix of size Nx3> rgbplot (ones (3,4))
-%!error <CMAP intensities must be in the range> rgbplot ([0 0 -2])
-%!error <CMAP intensities must be in the range> rgbplot ([0 0 2])
-
+%!error <CMAP must be a colormap> rgbplot ({0 1 0})
diff --git a/scripts/io/importdata.m b/scripts/io/importdata.m
new file mode 100644
--- /dev/null
+++ b/scripts/io/importdata.m
@@ -0,0 +1,414 @@
+## Copyright (C) 2012 Erik Kjellson
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {@var{A} =} importdata (@var{fname})
+## @deftypefnx {Function File} {@var{A} =} importdata (@var{fname}, @var{delimiter})
+## @deftypefnx {Function File} {@var{A} =} importdata (@var{fname}, @var{delimiter},  @var{header_rows})
+## @deftypefnx {Function File} {[@var{A}, @var{delimiter}] =} importdata (...)
+## @deftypefnx {Function File} {[@var{A}, @var{delimiter}, @var{header_rows}] =} importdata (...)
+## Importing data from file.
+##
+## Importing the contents of file @var{fname} into workspace.
+##
+## Input parameters:
+## @itemize
+## @item @var{fname}
+## The file name for the file to import.
+## 
+## @item @var{delimiter}
+## The character separating columns of data. Use @code{\t} for tab.
+## (Only valid for ascii files)
+##
+## @item @var{header_rows}
+## Number of header rows before the data begins. (Only valid for ascii files)
+## @end itemize
+##
+## Different file types are supported:
+## @itemize
+## @item Ascii table
+##
+## Importing ascii table using the specified number of header rows and
+## the specified delimiter.
+##
+## @item Image file
+##
+## @item @sc{Matlab} file
+##
+## @item Spreadsheet files (depending on external software)
+##
+## @item Wav file
+##
+## @end itemize
+##
+## @seealso{textscan, dlmread, csvread, load}
+## @end deftypefn
+
+## Author: Erik Kjellson <erikiiofph7@users.sourceforge.net>
+
+function [output, delimiter, header_rows] = importdata (varargin)
+
+  ## Default values
+  fname   = "";
+  delimiter  = "";
+  header_rows = -1;
+
+  ##########
+
+  ## Check input arguments
+
+  if (nargin < 1)
+    print_usage ();
+  endif
+
+  fname = varargin{1};
+  ## Check that the file name really is a string
+  if (! ischar (fname))
+    error ("importdata: file name needs to be a string");
+  endif
+  if ( strcmpi (fname, "-pastespecial"))
+    error ("importdata: option -pastespecial not implemented");
+  endif
+
+  if (nargin > 1)
+    delimiter = varargin{2};
+    ## Check that the delimiter really is a string
+    if (!ischar (delimiter))
+      error("importdata: delimiter needs to be a character");
+    endif
+    if (length (delimiter) > 1 && !strcmpi (delimiter, "\\t"))
+      error("importdata: delimiter cannot be longer than 1 character");
+    endif
+    if (strcmpi (delimiter, "\\"))
+      delimiter = "\\\\";
+    endif
+  endif
+
+  if (nargin > 2)
+    header_rows = varargin{3};
+    if (!isnumeric (header_rows) || header_rows < 0)
+      error ("importdata: number of header rows needs to be an integer number >= 0");
+    endif
+  endif
+
+  if (nargin > 3)
+    error ("importdata: too many input arguments");
+  endif
+
+  ##########
+
+  ## Check file format
+  ## Get the extension from the file name.
+  [d n fileExt v] = fileparts (fname);
+  ## Make sure file extension is in lower case.
+  fileExt = lower (fileExt);
+
+  switch fileExt
+    case {".au", ".snd"}
+      error (sprintf ("importdata: not implemented for file format %s", 
+                      fileExt));
+    case ".avi"
+      error (sprintf ("importdata: not implemented for file format %s", 
+                      fileExt));
+    case {".bmp", ".cur", ".gif", ".hdf", ".ico", ".jpe", ".jpeg", ".jpg", \
+          ".pbm", ".pcx", ".pgm", ".png", ".pnm", ".ppm", ".ras", \
+          ".tif", ".tiff", ".xwd"}
+      delimiter  = NaN;
+      header_rows = 0;
+      [output.cdata, output.colormap, output.alpha] = imread (fname);
+    case ".mat"
+      delimiter  = NaN;
+      header_rows = 0;
+      output = load (fname);
+    case {".wk1", ".xls", ".xlsx", ".dbf", ".pxl"}
+      ## If there's no Excel file support simply fall back to unimplemented.m
+      output = xlsread (fname);
+    case {".ods", ".sxc", ".fods", ".uos", ".xml"}
+      ## unimplemented.m only knows ML functions; odsread isn't one but is in OF
+      try
+        output = odsread (fname);
+      catch
+        ## Fall back to unimplemented.m.
+        output = xlsread (fname);
+      end_try_catch
+    case {".wav", ".wave"}
+      delimiter  = NaN;
+      header_rows = 0;
+      [output.data, output.fs] = wavread (fname);
+    otherwise
+      ## Assume the file is in ascii format.
+      [output, delimiter, header_rows]  = \
+          importdata_ascii (fname, delimiter, header_rows);
+  endswitch
+
+  ## If there are any empty fields in the output structure, then remove them
+  if (isstruct (output) && length (output) == 1)
+    fields = fieldnames (output);
+    for i=1:length (fields)
+      if (isempty (getfield (output, fields{i})))
+        output = rmfield (output, fields{i});
+      endif
+    endfor
+
+    ## If only one field is left, replace the structure with the field,
+    ## i.e. output = output.onlyFieldLeft
+
+    ## Update the list of fields
+    fields = fieldnames (output);
+    if (length (fields) == 1)
+      output = getfield (output, fields{1});
+    endif
+  endif
+endfunction
+
+
+########################################
+
+function [output, delimiter, header_rows] = \
+      importdata_ascii (fname, delimiter, header_rows)
+
+  ## Define the fields in the output structure so that the order will be
+  ## correct.
+
+  output.data       = [];
+  output.textdata   = [];
+  output.rowheaders = [];
+  output.colheaders = [];
+
+  ## Read file into string and count the number of header rows
+  file_content = fileread (fname);
+
+  ## Split the file into rows (using \r\n or \n as delimiters between rows).
+  file_content_rows = regexp (file_content, "\r?\n", "split");
+
+  ## FIXME: guess delimiter, if it isn't defined
+  if (isempty (delimiter))
+    error ("importdata: Guessing delimiter is not implemented yet, you have to specify it.");
+  endif
+
+  ## FIXME: A more intelligent way to count number of header rows. This
+  ## is needed e.g. when delimiter=' ' and the header contains spaces...
+
+  ## If number of header rows is undefined, then count the number of
+  ## header rows by step through row by row and look for the delimiter.
+  ## Assume that the header can't contain any delimiter.
+  if (header_rows < 0)
+    header_rows = 0;
+    for i=1:length (file_content_rows)
+      if (isempty (regexp(file_content_rows{i}, delimiter, "once")))
+        header_rows++;
+      else
+        ## Data part has begun and therefore no more header rows can be
+        ## found
+        break;
+      endif
+    endfor
+  endif
+
+  ## Put the header rows in output.textdata.
+  if (header_rows > 0)
+    output.textdata   = file_content_rows (1:header_rows)';
+  endif
+
+  ## If space is the delimiter, then remove spaces in the beginning of
+  ## each data row.
+  if (strcmpi (delimiter, " "))
+    for i=(header_rows+1):length (file_content_rows)
+      ## strtrim does not only remove the leading spaces but also the
+      ## tailing spaces, but that doesn't really matter.
+      file_content_rows{i} = strtrim (file_content_rows{i});
+    endfor
+  endif
+
+  ## Remove empty data rows. Go through them backwards so that you wont
+  ## get out of bounds.
+  for i=length (file_content_rows):-1:(header_rows + 1)
+    if (length (file_content_rows{i}) < 1)
+      file_content_rows = [file_content_rows(1:i-1), \
+                           file_content_rows(i+1:length(file_content_rows))];
+    endif
+  endfor
+
+  ## Count the number of data columns. If there are different number of
+  ## columns, use the greatest value.
+  data_columns = 0;
+  delimiter_pattern = delimiter;
+  ## If space is the delimiter, then multiple spaces should count as ONE
+  ## delimiter. Also ignore leading spaces.
+  if (strcmpi (delimiter, " "))
+    delimiter_pattern = ' +';
+  endif
+  for i=(header_rows+1):length(file_content_rows)
+    data_columns = max (data_columns,
+                        length (regexp (file_content_rows{i},
+                                        delimiter_pattern, "split")));
+  endfor
+
+  ## Go through the data and put it in either output.data or
+  ## output.textdata depending on if it is numeric or not.
+  output.data = NaN (length (file_content_rows) - header_rows, data_columns);
+  for i=(header_rows+1):length(file_content_rows)
+    ## Only use the row if it contains anything other than white-space
+    ## characters.
+    if (any (file_content_rows{i} != " "))
+      row_data = regexp (file_content_rows{i}, delimiter_pattern, "split");
+
+      for j=1:length(row_data)
+        ## Try to convert the column to a number, if it works put it in
+        ## output.data, otherwise in output.textdata
+        if (!isempty (row_data{j}))
+          data_numeric = str2double (row_data{j});
+          if (!isempty (data_numeric))
+            output.data(i-header_rows, j) = data_numeric;
+          else
+            output.textdata{i,j} = row_data{j};
+          endif
+        endif
+      endfor
+
+    endif
+  endfor
+
+  ## Check wether rowheaders or colheaders should be used
+  if ((header_rows == data_columns) && (size (output.textdata, 2) == 1))
+    output.rowheaders = output.textdata;
+  elseif (size (output.textdata, 2) == data_columns)
+    output.colheaders = output.textdata(end,:);
+  endif
+
+  ## When delimiter = "\\t" convert it to a tab, done for Matlab compatibility.
+  if (strcmp (delimiter, '\t'))
+    delimiter = "\t";
+  endif
+
+endfunction
+
+
+########################################
+
+%!test
+%! # Comma separated values
+%! A = [3.1 -7.2 0; 0.012 6.5 128];
+%! fn  = tmpnam ();
+%! fid = fopen (fn, "w");
+%! fputs (fid, "3.1,-7.2,0\n0.012,6.5,128");
+%! fclose (fid);
+%! [a,d,h] = importdata (fn, ",");
+%! unlink (fn);
+%! assert (a, A);
+%! assert (d, ",");
+%! assert (h, 0);
+
+%!test
+%! # Tab separated values
+%! A = [3.1 -7.2 0; 0.012 6.5 128];
+%! fn  = tmpnam ();
+%! fid = fopen (fn, "w");
+%! fputs (fid, "3.1\t-7.2\t0\n0.012\t6.5\t128");
+%! fclose (fid);
+%! [a,d,h] = importdata (fn, "\\t");
+%! unlink (fn);
+%! assert (a, A);
+%! assert (d, "\t");
+%! assert (h, 0);
+
+%!test
+%! # Space separated values, using multiple spaces to align in columns.
+%! A = [3.1 -7.2 0; 0.012 6.5 128];
+%! fn  = tmpnam ();
+%! fid = fopen (fn, "w");
+%! fprintf (fid, "%10.3f %10.3f %10.3f\n", A(1,:));
+%! fprintf (fid, "%10.3f %10.3f %10.3f\n", A(2,:));
+%! fclose (fid);
+%! [a,d,h] = importdata (fn, " ");
+%! unlink (fn);
+%! assert (a, A);
+%! assert (d, " ");
+%! assert (h, 0);
+
+%!test
+%! # Header
+%! A.data = [3.1 -7.2 0; 0.012 6.5 128];
+%! A.textdata = {"This is a header row."; \
+%!               "this row does not contain any data, but the next one does."};
+%! fn  = tmpnam ();
+%! fid = fopen (fn, "w");
+%! fputs (fid, [A.textdata{1} "\n"]);
+%! fputs (fid, [A.textdata{2} "\n"]);
+%! fputs (fid, "3.1\t-7.2\t0\n0.012\t6.5\t128");
+%! fclose (fid);
+%! [a,d,h] = importdata (fn, "\\t");
+%! unlink (fn);
+%! assert (a, A);
+%! assert (d, "\t");
+%! assert (h, 2);
+
+%!test
+%! # Ignore empty rows containing only spaces
+%! A = [3.1 -7.2 0; 0.012 6.5 128];
+%! fn  = tmpnam ();
+%! fid = fopen (fn, "w");
+%! fprintf (fid, "%10.3f %10.3f %10.3f\n", A(1,:));
+%! fputs (fid, "      ");
+%! fprintf (fid, "%10.3f %10.3f %10.3f\n", A(2,:));
+%! fclose (fid);
+%! [a,d,h] = importdata (fn, " ");
+%! unlink (fn);
+%! assert (a, A);
+%! assert (d, " ");
+%! assert (h, 0);
+
+%!test
+%! # Exponentials
+%! A = [3.1 -7.2 0; 0.012 6.5 128];
+%! fn  = tmpnam ();
+%! fid = fopen (fn, "w");
+%! fputs (fid, "+3.1e0\t-72E-1\t0\n12e-3\t6.5\t128");
+%! fclose (fid);
+%! [a,d,h] = importdata (fn, "\\t");
+%! unlink (fn);
+%! assert (a, A);
+%! assert (d, "\t");
+%! assert (h, 0);
+
+%!test
+%! # Missing values
+%! A = [3.1 NaN 0; 0.012 6.5 128];
+%! fn  = tmpnam ();
+%! fid = fopen (fn, "w");
+%! fputs (fid, "3.1\t\t0\n0.012\t6.5\t128");
+%! fclose (fid);
+%! [a,d,h] = importdata (fn, "\\t");
+%! unlink (fn);
+%! assert (a, A);
+%! assert (d, "\t");
+%! assert (h, 0);
+
+%!test
+%! # CRLF for line breaks
+%! A = [3.1 -7.2 0; 0.012 6.5 128];
+%! fn  = tmpnam ();
+%! fid = fopen (fn, "w");
+%! fputs (fid, "3.1\t-7.2\t0\r\n0.012\t6.5\t128");
+%! fclose (fid);
+%! [a,d,h] = importdata (fn, "\\t");
+%! unlink (fn);
+%! assert (a, A);
+%! assert (d, "\t");
+%! assert (h, 0);
+
diff --git a/scripts/io/module.mk b/scripts/io/module.mk
--- a/scripts/io/module.mk
+++ b/scripts/io/module.mk
@@ -1,16 +1,17 @@
 FCN_FILE_DIRS += io
 
 io_FCN_FILES = \
   io/beep.m \
   io/csvread.m \
   io/csvwrite.m \
   io/dlmwrite.m \
   io/fileread.m \
+  io/importdata.m \
   io/is_valid_file_id.m \
   io/strread.m \
   io/textscan.m \
   io/textread.m
 
 FCN_FILES += $(io_FCN_FILES)
 
 PKG_ADD_FILES += io/PKG_ADD
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -400,18 +400,20 @@ function varargout = strread (str, forma
     str = regexprep (str, rxp_wsp, ' ');
     ## Remove possible leading space at string
     if (str(1) == 32)
        str = str(2:end);
     endif
     ## Check for single delimiter followed/preceded by whitespace
     if (! isempty (delimiter_str))
       dlmstr = setdiff (delimiter_str, " ");
-      rxp_dlmwsp = sprintf ("( [%s]|[%s] )", dlmstr, dlmstr);
-      str = regexprep (str, rxp_dlmwsp, delimiter_str(1));
+      if (! isempty (dlmstr))
+        rxp_dlmwsp = sprintf ('( [%s] | [%s]|[%s] )', dlmstr, dlmstr, dlmstr);
+        str = regexprep (str, rxp_dlmwsp, delimiter_str(1));
+      endif
     endif
     ## Wipe leading and trailing whitespace on each line (it may be
     ## delimiter too)
     ## FIXME: Double strrep on str is enormously expensive of CPU time.
     ## Can this be eliminated
     if (! isempty (eol_char))
       str = strrep (str, [eol_char " "], eol_char);
       str = strrep (str, [" " eol_char], eol_char);
@@ -523,17 +525,17 @@ function varargout = strread (str, forma
             ## Next fmt_word is a literal...
             if (! index (words{iwrd}(iwrdp+1:end), fmt_words{ii+1}))
               ## ...but not found in current word => field uses rest of word
               nxt_wrd = 1;
             else
               ## ..or it IS found.  Add inferred width of current conversion field
               iwrdp += index (words{iwrd}(iwrdp+1:end), fmt_words{ii+1}) - 1;
             endif
-          elseif (iwrdp < iwrdl)
+          elseif (iwrdp <= iwrdl)
             ## No bordering literal to the right => field occupies (rest of) word
             nxt_wrd = 1;
           endif
 
         endif
 
         if (nxt_wrd)
           ++iwrd; iwrdp = 0;
@@ -951,16 +953,22 @@ endfunction
 
 %!test
 %! # Bug #35999
 %! [a, b, c] = strread ("", "%f");
 %! assert (isempty (a));
 %! assert (isempty (b));
 %! assert (isempty (c));
 
+%% bug #37023
+%!test
+%! [a, b] = strread (" 1. 1 \n  2 3 \n", "%f %f", "endofline", "\n");
+%! assert (a, [1; 2], 1e-15);
+%! assert (b, [1; 3], 1e-15);
+
 %% Unsupported format specifiers
 %!test
 %!error <format specifiers are not supported> strread ("a", "%c")
 %!error <format specifiers are not supported> strread ("a", "%*c %d")
 %!error <format specifiers are not supported> strread ("a", "%q")
 %!error <format specifiers are not supported> strread ("a", "%*q %d")
 %!error <format specifiers are not supported> strread ("a", "%[a]")
 %!error <format specifiers are not supported> strread ("a", "%*[a] %d")
diff --git a/scripts/io/textscan.m b/scripts/io/textscan.m
--- a/scripts/io/textscan.m
+++ b/scripts/io/textscan.m
@@ -397,8 +397,14 @@ endfunction
 %!error <must be a string> textscan ("Hello World", 2)
 %!error <cannot provide position information> [C, pos] = textscan ("Hello World")
 %!error <character value required> textscan ("Hello World", '%s', 'EndOfLine', 3)
 
 %! Test incomplete first data line
 %! R = textscan (['Empty1' char(10)], 'Empty%d %f');
 %! assert (R{1}, int32 (1));
 %! assert (isempty (R{2}), true);
+
+%% bug #37023 (actually a strread test)
+%!test
+%! data = textscan("   1. 1 \n 2 3\n", '%f %f');
+%! assert (data{1}, [1; 2], 1e-15);
+%! assert (data{2}, [1; 3], 1e-15);
diff --git a/scripts/miscellaneous/cast.m b/scripts/miscellaneous/cast.m
--- a/scripts/miscellaneous/cast.m
+++ b/scripts/miscellaneous/cast.m
@@ -28,17 +28,17 @@ function retval = cast (val, typ)
 
   if (nargin == 2)
     if (ischar (typ))
       if (any (strcmp (typ, {"int8"; "uint8"; "int16"; "uint16";
                              "int32"; "uint32"; "int64"; "uint64";
                              "double"; "single"; "logical"; "char"})))
         retval = feval (typ, val);
       else
-        error ("cast: type name `%s' is not a built-in type", typ);
+        error ("cast: type name '%s' is not a built-in type", typ);
       endif
     else
       error ("cast: expecting TYPE name as second argument");
     endif
   else
     print_usage ();
   endif
 
diff --git a/scripts/miscellaneous/dir.m b/scripts/miscellaneous/dir.m
--- a/scripts/miscellaneous/dir.m
+++ b/scripts/miscellaneous/dir.m
@@ -77,34 +77,34 @@ function retval = dir (directory)
     endif
 
     ## Determine the file list for the case where a single directory is
     ## specified.
     if (nf == 1)
       fn = flst{1};
       [st, err, msg] = stat (fn);
       if (err < 0)
-        warning ("dir: `stat (%s)' failed: %s", fn, msg);
+        warning ("dir: 'stat (%s)' failed: %s", fn, msg);
         nf = 0;
       elseif (S_ISDIR (st.mode))
         flst = readdir (flst{1});
         nf = length (flst);
         for i = 1:nf
           flst{i} = fullfile (fn, flst{i});
         endfor
       endif
     endif
 
     if (length (flst) > 0)
       ## Collect results.
       for i = nf:-1:1
         fn = flst{i};
         [st, err, msg] = lstat (fn);
         if (err < 0)
-          warning ("dir: `lstat (%s)' failed: %s", fn, msg);
+          warning ("dir: 'lstat (%s)' failed: %s", fn, msg);
         else
           ## If we are looking at a link that points to something,
           ## return info about the target of the link, otherwise, return
           ## info about the link itself.
           if (S_ISLNK (st.mode))
             [xst, err, msg] = stat (fn);
             if (! err)
               st = xst;
@@ -131,12 +131,12 @@ function retval = dir (directory)
   ## Return the output arguments.
   if (nargout > 0)
     ## Return the requested structure.
     retval = info;
   elseif (length (info) > 0)
     ## Print the structure to the screen.
     printf ("%s", list_in_columns ({info.name}));
   else
-    warning ("dir: nonexistent directory `%s'", directory);
+    warning ("dir: nonexistent directory '%s'", directory);
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -141,333 +141,382 @@
 ## @end table
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 
 ## Original version by Paul Kienzle distributed as free software in the
 ## public domain.
 
-function ret = edit (file, state)
+function ret = edit (varargin)
 
   ## Pick up globals or default them.
 
   persistent FUNCTION = struct ("EDITOR", cstrcat (EDITOR (), " %s"),
                                 "HOME", fullfile (default_home, "octave"),
                                 "AUTHOR", default_user(1),
                                 "EMAIL",  [],
                                 "LICENSE",  "GPL",
                                 "MODE", "async",
                                 "EDITINPLACE", false);
-  ## Make sure the state variables survive "clear functions".
+  ## Make sure the stateval variables survive "clear functions".
   mlock;
 
-  if (nargin == 2)
-    switch (toupper (file))
+  if (nargin == 1)
+    ## User has supplied one arg, this can be a single file name
+    ## or a cell array of strings containing multiple files to be
+    ## opened
+    if (iscellstr(varargin{1}))
+      ## If first arg is a cell array of strings, it becomes the
+      ## list of files to be edited
+      editfilelist = varargin{1};
+    elseif (ischar(varargin{1}))
+      ## If first arg is a string, create a cell array of strings
+      ## of length one (by copying the input cell array)
+      editfilelist = varargin(1);
+    else
+      error('edit: expected file to be a string or cell array of strings');
+    endif
+  elseif (nargin == 2)
+    ## User has supplied two arguments, these could be two file
+    ## names, or a combination of editor state name and new value
+    ## for that state, so first check for the various states
+    statevar = varargin{1};
+    stateval = varargin{2};
+    switch (toupper (statevar))
     case "EDITOR"
-      FUNCTION.EDITOR = state;
+      FUNCTION.EDITOR = stateval;
+      return
     case "HOME"
-      if (! isempty (state) && state(1) == "~")
-        state = [ default_home, state(2:end) ];
+      if (! isempty (stateval) && stateval(1) == "~")
+        stateval = [ default_home, stateval(2:end) ];
       endif
-      FUNCTION.HOME = state;
+      FUNCTION.HOME = stateval;
+      return
     case "AUTHOR"
-      FUNCTION.AUTHOR = state;
+      FUNCTION.AUTHOR = stateval;
+      return
     case "EMAIL"
-      FUNCTION.EMAIL = state;
+      FUNCTION.EMAIL = stateval;
+      return
     case "LICENSE"
-      FUNCTION.LICENSE = state;
+      FUNCTION.LICENSE = stateval;
+      return
     case "MODE"
-      if (strcmp (state, "sync") || strcmp (state, "async"))
-        FUNCTION.MODE = state;
+      if (strcmp (stateval, "sync") || strcmp (stateval, "async"))
+        FUNCTION.MODE = stateval;
       else
         error ('edit: expected "edit MODE sync|async"');
       endif
+      return
     case "EDITINPLACE"
-      if (ischar (state))
-        if (strcmpi (state, "true"))
-          state = true;
-        elseif (strcmpi (state, "false"))
-          state = false;
+      if (ischar (stateval))
+        if (strcmpi (stateval, "true"))
+          stateval = true;
+        elseif (strcmpi (stateval, "false"))
+          stateval = false;
         else
-          state = eval (state);
+          stateval = eval (stateval);
         endif
       endif
-      FUNCTION.EDITINPLACE = state;
+      FUNCTION.EDITINPLACE = stateval;
+      return
     case "GET"
-      if (isfield (FUNCTION, toupper (state)))
-        ret = FUNCTION.(toupper (state));
+      if (isfield (FUNCTION, toupper (stateval)))
+        ret = FUNCTION.(toupper (stateval));
       else
         ret = FUNCTION;
       endif
+      return
     otherwise
-      error ('edit: expected "edit EDITOR|HOME|AUTHOR|EMAIL|LICENSE|MODE val"');
+      ## If none of the states match, assume both inputs are
+      ## actually both file names to be opened
+      editfilelist = varargin;
     endswitch
-    return
+  elseif (nargin > 2)
+    if (iscellstr(varargin))
+      editfilelist = varargin;
+    else
+      error('edit: if supplying more than one input all inputs must be strings containing fiel names to open.');
+    endif
   endif
 
   ## Start the editor without a file if no file is given.
   if (nargin < 1)
     if (exist (FUNCTION.HOME, "dir") == 7 && (isunix () || ! ispc ()))
       system (cstrcat ("cd \"", FUNCTION.HOME, "\" ; ",
                       sprintf (FUNCTION.EDITOR, "")),
               [], FUNCTION.MODE);
     else
       system (sprintf (FUNCTION.EDITOR,""), [], FUNCTION.MODE);
     endif
     return;
   endif
 
-  ## Check whether the user is trying to edit a builtin of compiled function.
-  switch (exist (file))
-    case {3, 5}
-      error ("edit: unable to edit a built-in or compiled function");
-  endswitch
+  if (numel(editfilelist) > 1)
+
+    ## Call edit on each of the files in the list if there are more than 1
+    for i = 1:numel(editfilelist)
+      edit(editfilelist{i});
+    endfor
 
-  ## Checks for whether the file is
-  ## absolute or relative should be handled inside file_in_loadpath.
-  ## That way, it will be possible to look up files correctly given
-  ## partial path information.  For example, you should be able to
-  ## edit a particular overloaded function by doing any one of
-  ##
-  ##   edit classname/foo
-  ##   edit classname/foo.m
-  ##   edit @classname/foo
-  ##   edit @classname/foo.m
-  ##
-  ## This functionality is needed for other functions as well (at least
-  ## help and type; there may be more).  So the place to fix that is in
-  ## file_in_loadpath, possibly with some help from the load_path class.
+  else
+  
+    ## Only one file name was supplied, get it from the cell array
+    file = editfilelist{1};
 
-  ## The code below includes a portion that serves as a place-holder for
-  ## the changes suggested above.
+    ## Check whether the user is trying to edit a builtin or compiled function.
+    switch (exist (file))
+      case {3, 5}
+        error ("edit: unable to edit a built-in or compiled function");
+    endswitch
 
-  ## Create list of explicit and implicit file names.
-  filelist = {file};
-  ## If file has no extension, add file.m and file.cc to the list.
-  idx = rindex (file, ".");
-  if (idx == 0)
-    ## Create the list of files to look for
-    filelist = {file};
-    if (isempty (regexp (file, '\.m$')))
-      ## No ".m" at the end of the file, add to the list.
-      filelist{end+1} = cat (2, file, ".m");
-    endif
-    if (isempty (regexp (file, '\.cc$')))
-      ## No ".cc" at the end of the file, add to the list.
-      filelist{end+1} = cat (2, file, ".cc");
-    endif
-  endif
+    ## Checks for whether the file is
+    ## absolute or relative should be handled inside file_in_loadpath.
+    ## That way, it will be possible to look up files correctly given
+    ## partial path information.  For example, you should be able to
+    ## edit a particular overloaded function by doing any one of
+    ##
+    ##   edit classname/foo
+    ##   edit classname/foo.m
+    ##   edit @classname/foo
+    ##   edit @classname/foo.m
+    ##
+    ## This functionality is needed for other functions as well (at least
+    ## help and type; there may be more).  So the place to fix that is in
+    ## file_in_loadpath, possibly with some help from the load_path class.
 
-  ## If the file includes a path, it may be an overloaded function.
-  if (! strcmp (file, "@") && index (file, filesep))
-    ## No "@" at the beginning of the file, add to the list.
-    numfiles = numel (filelist);
-    for n = 1:numfiles
-      filelist{n+numfiles} = cat (2, "@", filelist{n});
-    endfor
-  endif
+    ## The code below includes a portion that serves as a place-holder for
+    ## the changes suggested above.
 
-  ## Search the entire path for the 1st instance of a file in the list.
-  fileandpath = "";
-  for n = 1:numel (filelist)
-    filetoedit = file_in_path (path, filelist{n});
-    if (! isempty (filetoedit))
-      ## The path is explicitly included.
-      fileandpath = filetoedit;
-      break;
+    ## Create list of explicit and implicit file names.
+    filelist = {file};
+    ## If file has no extension, add file.m and file.cc to the list.
+    idx = rindex (file, ".");
+    if (idx == 0)
+      ## Create the list of files to look for
+      filelist = {file};
+      if (isempty (regexp (file, '\.m$')))
+        ## No ".m" at the end of the file, add to the list.
+        filelist{end+1} = cat (2, file, ".m");
+      endif
+      if (isempty (regexp (file, '\.cc$')))
+        ## No ".cc" at the end of the file, add to the list.
+        filelist{end+1} = cat (2, file, ".cc");
+      endif
     endif
-  endfor
+
+    ## If the file includes a path, it may be an overloaded function.
+    if (! strcmp (file, "@") && index (file, filesep))
+      ## No "@" at the beginning of the file, add to the list.
+      numfiles = numel (filelist);
+      for n = 1:numfiles
+        filelist{n+numfiles} = cat (2, "@", filelist{n});
+      endfor
+    endif
 
-  if (! isempty (fileandpath))
-    ## If the file exists, then edit it.
-    if (FUNCTION.EDITINPLACE)
-      ## Edit in place even if it is protected.
-      system (sprintf (FUNCTION.EDITOR, cstrcat ("\"", fileandpath, "\"")),
-              [], FUNCTION.MODE);
-      return;
-    else
-      ## If the file is modifiable in place then edit it, otherwise make
-      ## a copy in HOME and then edit it.
-      fid = fopen (fileandpath, "r+t");
-      if (fid < 0)
-        from = fileandpath;
-        fileandpath = cstrcat (FUNCTION.HOME, from (rindex (from, filesep):end));
-        [status, msg] = copyfile (from, fileandpath, 1);
-        if (status == 0)
-          error (msg);
-        endif
-      else
-        fclose (fid);
+    ## Search the entire path for the 1st instance of a file in the list.
+    fileandpath = "";
+    for n = 1:numel (filelist)
+      filetoedit = file_in_path (path, filelist{n});
+      if (! isempty (filetoedit))
+        ## The path is explicitly included.
+        fileandpath = filetoedit;
+        break;
       endif
-      system (sprintf (FUNCTION.EDITOR, cstrcat ("\"", fileandpath, "\"")),
-              [], FUNCTION.MODE);
-      return;
-    endif
-  endif
+    endfor
 
-  ## If editing a new file that is neither a m-file or an oct-file,
-  ## just edit it.
-  fileandpath = file;
-  idx = rindex (file, ".");
-  name = file(1:idx-1);
-  ext = file(idx+1:end);
-  switch (ext)
-    case {"cc", "m"}
-      0;
-    otherwise
-      system (sprintf (FUNCTION.EDITOR, cstrcat ("\"", fileandpath, "\"")),
-              [], FUNCTION.MODE);
-      return;
-  endswitch
-
-  ## The file doesn't exist in path so create it, put in the function
-  ## template and edit it.
-
-  ## Guess the email name if it was not given.
-  if (isempty (FUNCTION.EMAIL))
-    host = getenv ("HOSTNAME");
-    if (isempty (host) && ispc ())
-      host = getenv ("COMPUTERNAME");
-    endif
-    if (isempty (host))
-      [status, host] = system ("uname -n");
-      ## trim newline from end of hostname
-      if (! isempty (host))
-        host = host(1:end-1);
+    if (! isempty (fileandpath))
+      ## If the file exists, then edit it.
+      if (FUNCTION.EDITINPLACE)
+        ## Edit in place even if it is protected.
+        system (sprintf (FUNCTION.EDITOR, cstrcat ("\"", fileandpath, "\"")),
+                [], FUNCTION.MODE);
+        return;
+      else
+        ## If the file is modifiable in place then edit it, otherwise make
+        ## a copy in HOME and then edit it.
+        fid = fopen (fileandpath, "r+t");
+        if (fid < 0)
+          from = fileandpath;
+          fileandpath = cstrcat (FUNCTION.HOME, from (rindex (from, filesep):end));
+          [status, msg] = copyfile (from, fileandpath, 1);
+          if (status == 0)
+            error (msg);
+          endif
+        else
+          fclose (fid);
+        endif
+        system (sprintf (FUNCTION.EDITOR, cstrcat ("\"", fileandpath, "\"")),
+                [], FUNCTION.MODE);
+        return;
       endif
     endif
-    if (isempty (host))
-      FUNCTION.EMAIL = " ";
-    else
-      FUNCTION.EMAIL = cstrcat ("<", default_user(0), "@", host, ">");
-    endif
-  endif
 
-  ## Fill in the revision string.
-  now = localtime (time);
-  revs = cstrcat ("Created: ", strftime ("%Y-%m-%d", now));
+    ## If editing a new file that is neither a m-file or an oct-file,
+    ## just edit it.
+    fileandpath = file;
+    idx = rindex (file, ".");
+    name = file(1:idx-1);
+    ext = file(idx+1:end);
+    switch (ext)
+      case {"cc", "m"}
+        0;
+      otherwise
+        system (sprintf (FUNCTION.EDITOR, cstrcat ("\"", fileandpath, "\"")),
+                [], FUNCTION.MODE);
+        return;
+    endswitch
 
-  ## Fill in the copyright string.
-  copyright = cstrcat (strftime ("Copyright (C) %Y ", now), FUNCTION.AUTHOR);
-
-  ## Fill in the author tag field.
-  author = cstrcat ("Author: ", FUNCTION.AUTHOR, " ", FUNCTION.EMAIL);
+    ## The file doesn't exist in path so create it, put in the function
+    ## template and edit it.
 
-  ## Fill in the header.
-  uclicense = toupper (FUNCTION.LICENSE);
-  switch (uclicense)
-    case "GPL"
-      head = cstrcat (copyright, "\n\n", "\
-This program is free software; you can redistribute it and/or modify\n\
-it under the terms of the GNU General Public License as published by\n\
-the Free Software Foundation; either version 3 of the License, or\n\
-(at your option) any later version.\n\
-\n\
-This program is distributed in the hope that it will be useful,\n\
-but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\
-GNU General Public License for more details.\n\
-\n\
-You should have received a copy of the GNU General Public License\n\
-along with Octave; see the file COPYING.  If not, see\n\
-<http://www.gnu.org/licenses/>.\
-");
-      tail = cstrcat (author, "\n", revs);
+    ## Guess the email name if it was not given.
+    if (isempty (FUNCTION.EMAIL))
+      host = getenv ("HOSTNAME");
+      if (isempty (host) && ispc ())
+        host = getenv ("COMPUTERNAME");
+      endif
+      if (isempty (host))
+        [status, host] = system ("uname -n");
+        ## trim newline from end of hostname
+        if (! isempty (host))
+          host = host(1:end-1);
+        endif
+      endif
+      if (isempty (host))
+        FUNCTION.EMAIL = " ";
+      else
+        FUNCTION.EMAIL = cstrcat ("<", default_user(0), "@", host, ">");
+      endif
+    endif
+
+    ## Fill in the revision string.
+    now = localtime (time);
+    revs = cstrcat ("Created: ", strftime ("%Y-%m-%d", now));
 
-    case "BSD"
-      head = cstrcat (copyright, "\n\n", "\
-This program is free software; redistribution and use in source and\n\
-binary forms, with or without modification, are permitted provided that\n\
-the following conditions are met:\n\
-\n\
-   1.Redistributions of source code must retain the above copyright\n\
-     notice, this list of conditions and the following disclaimer.\n\
-   2.Redistributions in binary form must reproduce the above copyright\n\
-     notice, this list of conditions and the following disclaimer in the\n\
-     documentation and/or other materials provided with the distribution.\n\
-\n\
-THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n\
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\
-ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n\
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n\
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n\
-OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n\
-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n\
-LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n\
-OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n\
-SUCH DAMAGE.\
-");
-      tail = cstrcat (author, "\n", revs);
+    ## Fill in the copyright string.
+    copyright = cstrcat (strftime ("Copyright (C) %Y ", now), FUNCTION.AUTHOR);
+
+    ## Fill in the author tag field.
+    author = cstrcat ("Author: ", FUNCTION.AUTHOR, " ", FUNCTION.EMAIL);
+
+    ## Fill in the header.
+    uclicense = toupper (FUNCTION.LICENSE);
+    switch (uclicense)
+      case "GPL"
+        head = cstrcat (copyright, "\n\n", "\
+  This program is free software; you can redistribute it and/or modify\n\
+  it under the terms of the GNU General Public License as published by\n\
+  the Free Software Foundation; either version 3 of the License, or\n\
+  (at your option) any later version.\n\
+  \n\
+  This program is distributed in the hope that it will be useful,\n\
+  but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\
+  GNU General Public License for more details.\n\
+  \n\
+  You should have received a copy of the GNU General Public License\n\
+  along with Octave; see the file COPYING.  If not, see\n\
+  <http://www.gnu.org/licenses/>.\
+  ");
+        tail = cstrcat (author, "\n", revs);
 
-    case "PD"
-      head = "";
-      tail = cstrcat (author, "\n", revs, "\n\n",
-                     "This program is granted to the public domain.");
+      case "BSD"
+        head = cstrcat (copyright, "\n\n", "\
+  This program is free software; redistribution and use in source and\n\
+  binary forms, with or without modification, are permitted provided that\n\
+  the following conditions are met:\n\
+  \n\
+     1.Redistributions of source code must retain the above copyright\n\
+       notice, this list of conditions and the following disclaimer.\n\
+     2.Redistributions in binary form must reproduce the above copyright\n\
+       notice, this list of conditions and the following disclaimer in the\n\
+       documentation and/or other materials provided with the distribution.\n\
+  \n\
+  THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n\
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\
+  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n\
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n\
+  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n\
+  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n\
+  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n\
+  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n\
+  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n\
+  SUCH DAMAGE.\
+  ");
+        tail = cstrcat (author, "\n", revs);
 
-    otherwise
-      head = "";
-      tail = cstrcat (copyright, "\n\n", FUNCTION.LICENSE, "\n",
-                     author, "\n", revs);
-  endswitch
+      case "PD"
+        head = "";
+        tail = cstrcat (author, "\n", revs, "\n\n",
+                       "This program is granted to the public domain.");
+
+      otherwise
+        head = "";
+        tail = cstrcat (copyright, "\n\n", FUNCTION.LICENSE, "\n",
+                       author, "\n", revs);
+    endswitch
 
-  ## Generate the function template.
-  exists = exist (name);
-  switch (ext)
-    case {"cc", "C", "cpp"}
-      if (isempty (head))
-        comment = cstrcat ("/*\n", tail, "\n\n*/\n\n");
-      else
-        comment = cstrcat ("/*\n", head, "\n\n", tail, "\n\n*/\n\n");
-      endif
-      ## If we are shadowing an m-file, paste the code for the m-file.
-      if (any (exists == [2, 103]))
-        code = cstrcat ("\\ ", strrep (type (name){1}, "\n", "\n// "));
-      else
-        code = " ";
-      endif
-      body = cstrcat ("#include <octave/oct.h>\n\n",
-                     "DEFUN_DLD(", name, ",args,nargout,\"\\\n",
-                     name, "\\n\\\n\")\n{\n",
-                     "  octave_value_list retval;\n",
-                     "  int nargin = args.length ();\n\n",
-                     code, "\n  return retval;\n}\n");
+    ## Generate the function template.
+    exists = exist (name);
+    switch (ext)
+      case {"cc", "C", "cpp"}
+        if (isempty (head))
+          comment = cstrcat ("/*\n", tail, "\n\n*/\n\n");
+        else
+          comment = cstrcat ("/*\n", head, "\n\n", tail, "\n\n*/\n\n");
+        endif
+        ## If we are shadowing an m-file, paste the code for the m-file.
+        if (any (exists == [2, 103]))
+          code = cstrcat ("\\ ", strrep (type (name){1}, "\n", "\n// "));
+        else
+          code = " ";
+        endif
+        body = cstrcat ("#include <octave/oct.h>\n\n",
+                       "DEFUN_DLD(", name, ",args,nargout,\"\\\n",
+                       name, "\\n\\\n\")\n{\n",
+                       "  octave_value_list retval;\n",
+                       "  int nargin = args.length ();\n\n",
+                       code, "\n  return retval;\n}\n");
 
-      text = cstrcat (comment, body);
-    case "m"
-      ## If we are editing a function defined on the fly, paste the
-      ## code.
-      if (any (exists == [2, 103]))
-        body = type (name){1};
-      else
-        body = cstrcat ("function [ ret ] = ", name, " ()\n\nendfunction\n");
-      endif
-      if (isempty (head))
-        comment = cstrcat ("## ", name, "\n\n",
-                           "## ", strrep (tail, "\n", "\n## "), "\n\n");
-      else
-        comment = cstrcat ("## ", strrep (head,"\n","\n## "), "\n\n", ...
-                           "## ", name, "\n\n", ...
-                           "## ", strrep (tail, "\n", "\n## "), "\n\n");
-      endif
-      text = cstrcat (comment, body);
-  endswitch
+        text = cstrcat (comment, body);
+      case "m"
+        ## If we are editing a function defined on the fly, paste the
+        ## code.
+        if (any (exists == [2, 103]))
+          body = type (name){1};
+        else
+          body = cstrcat ("function [ ret ] = ", name, " ()\n\nendfunction\n");
+        endif
+        if (isempty (head))
+          comment = cstrcat ("## ", name, "\n\n",
+                             "## ", strrep (tail, "\n", "\n## "), "\n\n");
+        else
+          comment = cstrcat ("## ", strrep (head,"\n","\n## "), "\n\n", ...
+                             "## ", name, "\n\n", ...
+                             "## ", strrep (tail, "\n", "\n## "), "\n\n");
+        endif
+        text = cstrcat (comment, body);
+    endswitch
 
-  ## Write the initial file (if there is anything to write)
-  fid = fopen (fileandpath, "wt");
-  if (fid < 0)
-    error ("edit: could not create %s", fileandpath);
+    ## Write the initial file (if there is anything to write)
+    fid = fopen (fileandpath, "wt");
+    if (fid < 0)
+      error ("edit: could not create %s", fileandpath);
+    endif
+    fputs (fid, text);
+    fclose (fid);
+
+    ## Finally we are ready to edit it!
+    system (sprintf (FUNCTION.EDITOR, cstrcat ("\"", fileandpath, "\"")),
+            [], FUNCTION.MODE);
+            
   endif
-  fputs (fid, text);
-  fclose (fid);
-
-  ## Finally we are ready to edit it!
-  system (sprintf (FUNCTION.EDITOR, cstrcat ("\"", fileandpath, "\"")),
-          [], FUNCTION.MODE);
 
 endfunction
 
 function ret = default_home ()
 
   ret = getenv ("HOME");
   if (isempty (ret))
     ret = glob ("~");
diff --git a/scripts/miscellaneous/info.m b/scripts/miscellaneous/info.m
--- a/scripts/miscellaneous/info.m
+++ b/scripts/miscellaneous/info.m
@@ -22,18 +22,19 @@
 ## @end deftypefn
 
 function info ()
 
   printf ("\n\
   Additional information about GNU Octave is available at\n\
   http://www.octave.org\n\
 \n\
-  Descriptions of mailing lists devoted to Octave are available at\n\
-  http://www.octave.org/archive.html\n\
+  Links to the mailing list and other resources for getting help with\n\
+  Octave are available at\n\
+  http://www.octave.org/support.html\n\
 \n\
   You may also find some information in the Octave Wiki at\n\
   http://wiki.octave.org\n\
 \n\
   Additional functionality can be enabled by using packages from\n\
   the Octave Forge project, which may be found at\n\
   http://octave.sourceforge.net\n\
 \n\
diff --git a/scripts/miscellaneous/license.m b/scripts/miscellaneous/license.m
--- a/scripts/miscellaneous/license.m
+++ b/scripts/miscellaneous/license.m
@@ -133,20 +133,20 @@ function retval = license (varargin)
         retval = ! isempty (found) && __octave_licenses__{found,3};
       else
         if (! isempty (found))
           if (strcmp (varargin{3}, "enable"))
             __octave_licenses__{found,3} = true;
           elseif (strcmp (varargin{3}, "disable"))
             __octave_licenses__{found,3} = false;
           else
-            error ("license: TOGGLE must be either `enable' or `disable'");
+            error ("license: TOGGLE must be either 'enable' or 'disable'");
           endif
         else
-          error ("license: FEATURE `%s' not found", feature);
+          error ("license: FEATURE '%s' not found", feature);
         endif
       endif
 
     elseif (strcmp (varargin{1}, "checkout"))
 
       if (nin != 2)
         usage ('retval = license ("checkout", feature)');
       endif
@@ -177,11 +177,11 @@ endfunction
 %!   license ("test", "Octave", "disable");
 %! endif
 
 %!assert (license ("checkout", "Octave"), true)
 
 %% Test input validation
 %!error license ("not_inuse")
 %!error <TOGGLE must be either> license ("test", "Octave", "not_enable")
-%!error <FEATURE `INVALID' not found> license ("test", "INVALID", "enable")
+%!error <FEATURE 'INVALID' not found> license ("test", "INVALID", "enable")
 %!error license ("not_test", "Octave", "enable")
 
diff --git a/scripts/miscellaneous/mkoctfile.m b/scripts/miscellaneous/mkoctfile.m
--- a/scripts/miscellaneous/mkoctfile.m
+++ b/scripts/miscellaneous/mkoctfile.m
@@ -82,28 +82,28 @@
 ##    ALL_CXXFLAGS              FLIBS
 ##    ALL_FFLAGS                FPICFLAG
 ##    ALL_LDFLAGS               INCFLAGS
 ##    BLAS_LIBS                 LAPACK_LIBS
 ##    CC                        LDFLAGS
 ##    CFLAGS                    LD_CXX
 ##    CPICFLAG                  LD_STATIC_FLAG
 ##    CPPFLAGS                  LFLAGS
-##    CXX                       LIBCRUFT
-##    CXXFLAGS                  LIBOCTAVE
-##    CXXPICFLAG                LIBOCTINTERP
-##    DEPEND_EXTRA_SED_PATTERN  LIBS
-##    DEPEND_FLAGS              OCTAVE_LIBS
-##    DL_LD                     OCTAVE_LINK_DEPS
-##    DL_LDFLAGS                OCT_LINK_DEPS
-##    EXEEXT                    RDYNAMIC_FLAG
-##    F77                       READLINE_LIBS
-##    F77_INTEGER_8_FLAG        SED
-##    FFLAGS                    XTRA_CFLAGS
-##    FFTW3_LDFLAGS             XTRA_CXXFLAGS
+##    CXX                       LIBOCTAVE       
+##    CXXFLAGS                  LIBOCTINTERP    
+##    CXXPICFLAG                LIBS            
+##    DEPEND_EXTRA_SED_PATTERN  OCTAVE_LIBS     
+##    DEPEND_FLAGS              OCTAVE_LINK_DEPS
+##    DL_LD                     OCT_LINK_DEPS   
+##    DL_LDFLAGS                RDYNAMIC_FLAG   
+##    EXEEXT                    READLINE_LIBS   
+##    F77                       SED             
+##    F77_INTEGER_8_FLAG        XTRA_CFLAGS     
+##    FFLAGS                    XTRA_CXXFLAGS   
+##    FFTW3_LDFLAGS             
 ##    FFTW3_LIBS
 ##    FFTW3F_LDFLAGS
 ##
 ## @end example
 ##
 ## @item --link-stand-alone
 ## Link a stand-alone executable file.
 ##
@@ -155,15 +155,15 @@ function [output, status] = mkoctfile (v
 
   if (nargout > 0)
     [output, status] = deal (out, sys);
   else
     printf ("%s", out);
   endif
 
   if (sys == 127)
-    warning ("unable to find mkoctfile in expected location: `%s'",
+    warning ("unable to find mkoctfile in expected location: '%s'",
              shell_script);
 
     warning ("mkoctfile exited with failure status");
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/recycle.m b/scripts/miscellaneous/recycle.m
--- a/scripts/miscellaneous/recycle.m
+++ b/scripts/miscellaneous/recycle.m
@@ -43,17 +43,17 @@ function retval = recycle (state)
 
   if (nargin == 1)
     if (ischar (state))
       if (strcmpi (state, "on"))
         error ("recycle: recycling files is not implemented");
       elseif (strcmpi (state, "off"))
         current_state = "off";
       else
-        error ("recycle: invalid value of STATE = `%s'", state);
+        error ("recycle: invalid value of STATE = '%s'", state);
       endif
     else
       error ("recycle: STATE must be a character string");
     endif
   endif
 
 endfunction
 
diff --git a/scripts/miscellaneous/rmappdata.m b/scripts/miscellaneous/rmappdata.m
--- a/scripts/miscellaneous/rmappdata.m
+++ b/scripts/miscellaneous/rmappdata.m
@@ -25,21 +25,35 @@
 
 function rmappdata (h, varargin)
 
   if (! (all (ishandle (h)) && iscellstr (varargin)))
     error ("rmappdata: invalid input");
   endif
 
   for nh = 1:numel (h)
-    appdata = get (h(nh), "__appdata__");
-    appdata = rmfield (appdata, varargin);
-    set (h(nh), "__appdata__", appdata);
+    if (isprop (h(nh), "__appdata__"))
+      appdata = get (h(nh), "__appdata__");
+      for v = 1:numel(varargin)
+        if (isfield (appdata, varargin{v}))
+          appdata = rmfield (appdata, varargin{v});
+        else
+          error ("rmappdata: appdata '%s' is not present")
+        endif
+      endfor
+      set (h(nh), "__appdata__", appdata);
+    endif
   endfor
 
 endfunction
 
-
 %!test
 %! setappdata (0, "hello", "world");
 %! rmappdata (0, "hello");
 %! assert (isappdata (0, "hello"), false);
 
+%!test
+%! setappdata (0, "data1", rand (3));
+%! setappdata (0, "data2", {"hello", "world"});
+%! rmappdata (0, "data1", "data2");
+%! assert (isappdata (0, "data1"), false);
+%! assert (isappdata (0, "data2"), false);
+
diff --git a/scripts/miscellaneous/tempdir.m b/scripts/miscellaneous/tempdir.m
--- a/scripts/miscellaneous/tempdir.m
+++ b/scripts/miscellaneous/tempdir.m
@@ -28,17 +28,17 @@ function dirname = tempdir ()
     dirname = P_tmpdir;
   endif
 
   if (! strcmp (dirname(end), filesep))
     dirname = cstrcat (dirname, filesep);
   endif
 
   if (! isdir (dirname))
-    warning ("tempdir: `%s' does not exist or is not a directory", dirname);
+    warning ("tempdir: '%s' does not exist or is not a directory", dirname);
   endif
 
 endfunction
 
 
 %!assert (ischar (tempdir ()))
 
 %!test
diff --git a/scripts/optimization/fminsearch.m b/scripts/optimization/fminsearch.m
--- a/scripts/optimization/fminsearch.m
+++ b/scripts/optimization/fminsearch.m
@@ -98,17 +98,17 @@ endfunction
 ##        The form of the initial simplex is determined by STOPIT(4):
 ##           STOPIT(4) = 0: regular simplex (sides of equal length, the default)
 ##           STOPIT(4) = 1: right-angled simplex.
 ##        Progress of the iteration is not shown if STOPIT(5) = 0 (default 1).
 ##           STOPIT(6) indicates the direction (ie. minimization or
 ##                   maximization.) Default is 1, maximization.
 ##                   set STOPIT(6)=-1 for minimization
 ##        If a non-empty fourth parameter string SAVIT is present, then
-##        `SAVE SAVIT x fmax nf' is executed after each inner iteration.
+##        'SAVE SAVIT x fmax nf' is executed after each inner iteration.
 ##        NB: x0 can be a matrix.  In the output argument, in SAVIT saves,
 ##            and in function calls, x has the same shape as x0.
 ##        NMSMAX(fun, x0, STOPIT, SAVIT, P1, P2,...) allows additional
 ##        arguments to be passed to fun, via feval(fun,x,P1,P2,...).
 ## References:
 ## N. J. Higham, Optimization by direct search in matrix computations,
 ##    SIAM J. Matrix Anal. Appl, 14(2): 317-333, 1993.
 ## C. T. Kelley, Iterative Methods for Optimization, Society for Industrial
@@ -252,17 +252,17 @@ function [x, fmax, nf] = nmsmax (fun, x,
     if (size_simplex <= tol)
       msg = sprintf ("Simplex size %9.4e <= %9.4e...quitting\n", ...
                       size_simplex, tol);
       break;
     endif
 
     ##  One step of the Nelder-Mead simplex algorithm
     ##  NJH: Altered function calls and changed CNT to NF.
-    ##       Changed each `fr < f(1)' type test to `>' for maximization
+    ##       Changed each 'fr < f(1)' type test to '>' for maximization
     ##       and re-ordered function values after sort.
 
     vbar = (sum (V(:,1:n)')/n)';  # Mean value
     vr = (1 + alpha)*vbar - alpha*V(:,n+1);
     x(:) = vr;
     fr = dirn * feval (fun,x,varargin{:});
     nf = nf + 1;
     vk = vr;  fk = fr; how = "reflect, ";
diff --git a/scripts/optimization/optimset.m b/scripts/optimization/optimset.m
--- a/scripts/optimization/optimset.m
+++ b/scripts/optimization/optimset.m
@@ -116,17 +116,17 @@ function retval = optimset (varargin)
       retval = cell2struct (repmat ({[]}, size (opts)), opts, 2);
     endif
   elseif (nargs == 1 && ischar (varargin{1}))
     ## Return defaults for named function.
     fcn = varargin{1};
     try
       retval = feval (fcn, "defaults");
     catch
-      error ("optimset: no defaults for function `%s'", fcn);
+      error ("optimset: no defaults for function '%s'", fcn);
     end_try_catch
   elseif (nargs == 2 && isstruct (varargin{1}) && isstruct (varargin{2}))
     ## Set slots in old from nonempties in new.  Should we be checking
     ## to ensure that the field names are expected?
     old = varargin{1};
     new = varargin{2};
     fnames = fieldnames (old);
     ## skip validation if we're in the internal query
diff --git a/scripts/pkg/private/fix_depends.m b/scripts/pkg/private/fix_depends.m
--- a/scripts/pkg/private/fix_depends.m
+++ b/scripts/pkg/private/fix_depends.m
@@ -36,17 +36,17 @@ function deps_cell = fix_depends (depend
     rpar = find (dep == ")");
     ## Does the dependency specify a version
     ## Example: package(>= version).
     if (length (lpar) == 1 && length (rpar) == 1)
       package = tolower (strtrim (dep(1:lpar-1)));
       sub = dep(lpar(1)+1:rpar(1)-1);
       parts = strsplit (sub, " ", true);
       if (length (parts) != 2)
-        error ("incorrect syntax for dependency `%s' in the DESCRIPTION file\n",
+        error ("incorrect syntax for dependency '%s' in the DESCRIPTION file\n",
                dep);
       endif
       operator = parts{1};
       if (! any (strcmp (operator, {">", ">=", "<=", "<", "=="})))
         error ("unsupported operator: %s", operator);
       endif
       version  = fix_version (parts{2});
 
diff --git a/scripts/pkg/private/get_description.m b/scripts/pkg/private/get_description.m
--- a/scripts/pkg/private/get_description.m
+++ b/scripts/pkg/private/get_description.m
@@ -46,17 +46,17 @@ function desc = get_description (filenam
       if (length (colon) == 0)
         disp ("skipping line");
       else
         colon = colon(1);
         keyword = tolower (strtrim (line(1:colon-1)));
         value = strtrim (line (colon+1:end));
         if (length (value) == 0)
             fclose (fid);
-            error ("The keyword `%s' of the package `%s' has an empty value",
+            error ("The keyword '%s' of the package '%s' has an empty value",
                     keyword, desc.name);
         endif
         desc.(keyword) = value;
       endif
     endif
     line = fgetl (fid);
   endwhile
   fclose (fid);
diff --git a/scripts/plot/__gnuplot_drawnow__.m b/scripts/plot/__gnuplot_drawnow__.m
--- a/scripts/plot/__gnuplot_drawnow__.m
+++ b/scripts/plot/__gnuplot_drawnow__.m
@@ -69,17 +69,17 @@ function __gnuplot_drawnow__ (h, term, f
     ##  Graphics terminal for display.
     plot_stream = get (h, "__plot_stream__");
     if (isempty (plot_stream))
       plot_stream = __gnuplot_open_stream__ (2, h);
       new_stream = true;
     else
       new_stream = false;
     endif
-    term = gnuplot_default_term ();
+    term = gnuplot_default_term (plot_stream);
     if (strcmp (term, "dumb"))
       ## popen2 eats stdout of gnuplot, use temporary file instead
       dumb_tmp_file = tmpnam ();
       enhanced = gnuplot_set_term (plot_stream (1), new_stream, h, ...
                                    term, dumb_tmp_file);
     else
       enhanced = gnuplot_set_term (plot_stream (1), new_stream, h, term);
     endif
@@ -109,17 +109,17 @@ function __gnuplot_drawnow__ (h, term, f
 
 endfunction
 
 function enhanced = gnuplot_set_term (plot_stream, new_stream, h, term, file)
   ## Generate the gnuplot "set terminal <term> ..." command.
   ## When "term" originates from print.m, it may include other options.
   if (nargin < 4)
     ## This supports the gnuplot graphics toolkit.
-    term = gnuplot_default_term ();
+    term = gnuplot_default_term (plot_stream);
     opts_str = "";
   else
     ## Get the one word terminal id and save the remaining as options to
     ## be passed on to gnuplot.  The terminal may respect the graphics
     ## toolkit.
     [term, opts_str] = gnuplot_trim_term (term);
     term = lower (term);
     if (strcmp (term, "lua"))
@@ -127,17 +127,17 @@ function enhanced = gnuplot_set_term (pl
       term = "tikz";
       opts_str = strrep (opts_str, "tikz", "");
     endif
   endif
 
   if (strfind (opts_str, "noenhanced"))
     enhanced = false;
   else
-    enhanced = gnuplot_is_enhanced_term (term);
+    enhanced = gnuplot_is_enhanced_term (plot_stream, term);
   endif
 
   ## Set the terminal.
   if (! isempty (term))
 
     if (enhanced)
       enh_str = "enhanced";
     else
@@ -324,20 +324,20 @@ function enhanced = gnuplot_set_term (pl
   else
     ## gnuplot will pick up the GNUTERM environment variable itself
     ## so no need to set the terminal type if not also setting the
     ## figure title, enhanced mode, or position.
   endif
 
 endfunction
 
-function term = gnuplot_default_term ()
+function term = gnuplot_default_term (plot_stream)
   term = getenv ("GNUTERM");
   ## If not specified, guess the terminal type.
-  if (isempty (term))
+  if (isempty (term) || ! __gnuplot_has_terminal__ (term, plot_stream))
     if (ismac ())
       term = "aqua";
     elseif (! isunix ())
       term = "windows";
     elseif (! isempty (getenv ("DISPLAY")))
       term = "x11";
     else
       term = "dumb";
@@ -353,34 +353,34 @@ function [term, opts] = gnuplot_trim_ter
     term = string;
     opts = "";
   else
     term = string(1:(n-1));
     opts = string((n+1):end);
   endif
 endfunction
 
-function have_enhanced = gnuplot_is_enhanced_term (term)
+function have_enhanced = gnuplot_is_enhanced_term (plot_stream, term)
   persistent enhanced_terminals;
   if (isempty (enhanced_terminals))
     ## Don't include pstex, pslatex or epslatex here as the TeX commands
     ## should not be interpreted in that case.
     enhanced_terminals = {"aqua", "canvas", "dumb", "emf", "gif", "jpeg", ...
                           "pdf", "pdfcairo", "pm", "png", "pngcairo", ...
-                          "postscript", "svg", "windows", "wxt", "x11"};
+                          "postscript", "qt", "svg", "windows", "wxt", "x11"};
   endif
-  if (nargin < 1)
+  if (nargin < 2)
     ## Determine the default gnuplot terminal.
-    term = gnuplot_default_term ();
+    term = gnuplot_default_term (plot_stream);
   endif
   have_enhanced = any (strncmp (enhanced_terminals, term, min (numel (term), 3)));
 endfunction
 
 function ret = output_to_screen (term)
-  ret = any (strcmpi ({"aqua", "dumb", "wxt", "x11", "windows", "pm"}, term));
+  ret = any (strcmpi ({"aqua", "dumb", "pm", "qt", "windows", "wxt", "x11"}, term));
 endfunction
 
 function retval = have_non_legend_axes (h)
   retval = false;
   all_axes = findall (h, "type", "axes");
   if (! isempty (all_axes))
     n_all_axes = numel (all_axes);
     all_axes_tags = get (all_axes, "tag");
diff --git a/scripts/plot/area.m b/scripts/plot/area.m
--- a/scripts/plot/area.m
+++ b/scripts/plot/area.m
@@ -13,97 +13,108 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} area (@var{x}, @var{y})
-## @deftypefnx {Function File} {} area (@var{x}, @var{y}, @var{lvl})
+## @deftypefn  {Function File} {} area (@var{y})
+## @deftypefnx {Function File} {} area (@var{x}, @var{y})
+## @deftypefnx {Function File} {} area (@dots{}, @var{lvl})
 ## @deftypefnx {Function File} {} area (@dots{}, @var{prop}, @var{val}, @dots{})
-## @deftypefnx {Function File} {} area (@var{y}, @dots{})
 ## @deftypefnx {Function File} {} area (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} area (@dots{})
-## Area plot of cumulative sum of the columns of @var{y}.  This shows the
-## contributions of a value to a sum, and is functionally similar to
+## Area plot of the columns of @var{y}.  This shows the
+## contributions of each column value to the row sum.  It is functionally similar to
 ## @code{plot (@var{x}, cumsum (@var{y}, 2))}, except that the area under
 ## the curve is shaded.
 ##
-## If the @var{x} argument is omitted it is assumed to be given by
+## If the @var{x} argument is omitted it defaults to 
 ## @code{1 : rows (@var{y})}.  A value @var{lvl} can be defined that determines
-## where the base level of the shading under the curve should be defined.
+## where the base level of the shading under the curve should be defined.  The
+## default level is 0.
 ##
-## Additional arguments to the @code{area} function are passed to
-## @code{patch}.
+## Additional arguments to the @code{area} function are passed directly to
+## @code{patch}.  
 ##
 ## The optional return value @var{h} is a graphics handle to the hggroup
-## object representing the area patch objects.
+## object representing the area patch objects.  The "BaseValue" property
+## of the hggroup can be used to adjust the level where shading begins.
+##
+## Example: Verify identity sin^2 + cos^2 = 1
+##
+## @example
+## t = linspace (0, 2*pi, 100)';
+## y = [sin(t).^2, cos(t).^2)];
+## area (t, y);
+## legend ('sin^2', 'cos^2', 'location', 'NorthEastOutside');  
+## @end example
 ## @seealso{plot, patch}
 ## @end deftypefn
 
 function h = area (varargin)
 
   [ax, varargin, nargin] = __plt_get_axis_arg__ ("area", varargin{:});
 
-  if (nargin > 0)
-    idx = 1;
-    x = y = [];
-    bv = 0;
-    args = {};
-    ## Check for (X) or (X,Y) arguments and possible base value.
-    if (nargin >= idx && ismatrix (varargin{idx}))
-      y = varargin{idx};
-      idx++;
-      if (nargin >= idx)
-        if (isscalar (varargin{idx}))
+  if (nargin == 0)
+    print_usage ();
+  endif
+
+  idx = 1;
+  x = y = [];
+  bv = 0;
+  args = {};
+  ## Check for (X) or (X,Y) arguments and possible base value.
+  if (nargin >= idx && ismatrix (varargin{idx}))
+    y = varargin{idx};
+    idx++;
+    if (nargin >= idx)
+      if (isscalar (varargin{idx}))
+        bv = varargin{idx};
+        idx++;
+      elseif (ismatrix (varargin{idx}))
+        x = y;
+        y = varargin{idx};
+        idx++;
+        if (nargin >= idx && isscalar (varargin{idx}))
           bv = varargin{idx};
           idx++;
-        elseif (ismatrix (varargin{idx}))
-          x = y;
-          y = varargin{idx};
-          idx++;
-          if (nargin >= idx && isscalar (varargin{idx}))
-            bv = varargin{idx};
-            idx++;
-          endif
         endif
       endif
-    else
-      print_usage ();
-    endif
-    ## Check for additional args.
-    if (nargin >= idx)
-      args = {varargin{idx:end}};
-    endif
-    newplot ();
-    if (isvector (y))
-      y = y(:);
-    endif
-    if (isempty (x))
-      x = repmat ([1:rows(y)]', 1, columns (y));
-    elseif (isvector (x))
-      x = repmat (x(:),  1, columns (y));
-    endif
-
-    oldax = gca ();
-    unwind_protect
-      axes (ax);
-      tmp = __area__ (ax, x, y, bv, args{:});
-    unwind_protect_cleanup
-      axes (oldax);
-    end_unwind_protect
-
-    if (nargout > 0)
-      h = tmp;
     endif
   else
     print_usage ();
   endif
+  ## Check for additional args.
+  if (nargin >= idx)
+    args = {varargin{idx:end}};
+  endif
+  newplot ();
+  if (isvector (y))
+    y = y(:);
+  endif
+  if (isempty (x))
+    x = repmat ([1:rows(y)]', 1, columns (y));
+  elseif (isvector (x))
+    x = repmat (x(:),  1, columns (y));
+  endif
+
+  oldax = gca ();
+  unwind_protect
+    axes (ax);
+    tmp = __area__ (ax, x, y, bv, args{:});
+  unwind_protect_cleanup
+    axes (oldax);
+  end_unwind_protect
+
+  if (nargout > 0)
+    h = tmp;
+  endif
 
 endfunction
 
 function retval = __area__ (ax, x, y, bv, varargin)
 
   y0 = bv * ones (1, rows (y));
   y0 = zeros (1, rows (y));
   retval = [];
@@ -152,19 +163,19 @@ function retval = __area__ (ax, x, y, bv
     endif
   endfor
 
 endfunction
 
 function update_props (h, d)
   kids = get (h, "children");
   set (kids, "edgecolor", get (h, "edgecolor"),
-       "linewidth", get (h, "linewidth"),
-       "linestyle", get (h, "linestyle"),
-       "facecolor", get (h, "facecolor"));
+             "linewidth", get (h, "linewidth"),
+             "linestyle", get (h, "linestyle"),
+             "facecolor", get (h, "facecolor"));
 endfunction
 
 function move_baseline (h, d)
   persistent recursion = false;
 
   ## Don't allow recursion
   if (! recursion)
     unwind_protect
@@ -201,8 +212,31 @@ function update_data (h, d)
     else
       y1 = y0 + y1;
       set (get (hh, "children"), "ydata", [y0(1); y1; flipud(y0)]);
     endif
 
     y0 = y1;
   endfor
 endfunction
+
+
+%!demo
+%! # Verify identity sin^2 + cos^2 = 1
+%! clf;
+%! t = linspace (0, 2*pi, 100)';
+%! y = [sin(t).^2, cos(t).^2];
+%! area (t, y);
+%! legend ('sin^2', 'cos^2', 'location', 'NorthEastOutside');  
+
+%!demo
+%! # Show effects of setting BaseValue
+%! clf;
+%! x = [-2:0.1:2]';
+%! y = x.^2 - 1;
+%! subplot (1, 2, 1)
+%! area (x, y);
+%! title ({'Parabola y = x^2 -1';'BaseValue = 0'});
+%! subplot (1, 2, 2)
+%! h = area (x, y);
+%! set (h, 'basevalue', -1);
+%! title ({'Parabola y = x^2 -1';'BaseValue = -1'});
+
diff --git a/scripts/plot/bar.m b/scripts/plot/bar.m
--- a/scripts/plot/bar.m
+++ b/scripts/plot/bar.m
@@ -90,10 +90,20 @@
 ## Author: jwe
 
 function varargout = bar (varargin)
   varargout = cell (nargout, 1);
   [varargout{:}] = __bar__ (true, "bar", varargin{:});
 endfunction
 
 
-%% FIXME: Need demo or test for function
+%!demo
+%! clf;
+%! y = rand (10, 1);
+%! bar (y);
 
+%!demo
+%! clf;
+%! h = bar (rand (5, 3));
+%! set (h(1), 'facecolor', 'r')
+%! set (h(2), 'facecolor', 'g')
+%! set (h(3), 'facecolor', 'b')
+
diff --git a/scripts/plot/barh.m b/scripts/plot/barh.m
--- a/scripts/plot/barh.m
+++ b/scripts/plot/barh.m
@@ -49,10 +49,20 @@
 ## Author: jwe
 
 function varargout = barh (varargin)
   varargout = cell (nargout, 1);
   [varargout{:}] = __bar__ (false, "barh", varargin{:});
 endfunction
 
 
-%% FIXME: Need demo or test for function
+%!demo
+%! clf;
+%! x = rand (10, 1);
+%! barh (x);
 
+%!demo
+%! clf;
+%! h = barh (rand (5, 3));
+%! set (h(1), 'facecolor', 'r')
+%! set (h(2), 'facecolor', 'g')
+%! set (h(3), 'facecolor', 'b')
+
diff --git a/scripts/plot/closereq.m b/scripts/plot/closereq.m
--- a/scripts/plot/closereq.m
+++ b/scripts/plot/closereq.m
@@ -25,17 +25,17 @@
 
 ## Author: jwe
 
 function closereq ()
 
   if (nargin == 0)
     cf = gcbf ();
     if (isempty (cf))
-      warning ("closereq: calling closereq from octave prompt is not supported, use `close' instead");
+      warning ("closereq: calling closereq from octave prompt is not supported, use 'close' instead");
       cf = get (0, "currentfigure");
     endif
     if (! isempty (cf) && isfigure (cf))
       delete (cf);
     endif
   else
     print_usage ();
   endif
diff --git a/scripts/plot/colstyle.m b/scripts/plot/colstyle.m
--- a/scripts/plot/colstyle.m
+++ b/scripts/plot/colstyle.m
@@ -76,15 +76,15 @@ endfunction
 %! [l, c, m, msg] = colstyle (".");
 %! assert (isempty (msg));
 %! assert (l, "none");
 %! assert (c, []);
 %! assert (m, ".");
 
 %!test
 %! [l, c, m, msg] = colstyle ("~");
-%! assert (msg, "colstyle: unrecognized format character: `~'");
+%! assert (msg, "colstyle: unrecognized format character: '~'");
 
 %% Test input validation
 %!error colstyle ()
 %!error colstyle (1, 2)
 %!error colstyle (1.5)
 
diff --git a/scripts/plot/copyobj.m b/scripts/plot/copyobj.m
--- a/scripts/plot/copyobj.m
+++ b/scripts/plot/copyobj.m
@@ -90,17 +90,17 @@ endfunction
 %! sombrero;
 %! colorbar ('peer', gca, 'NorthOutside');
 %! subplot (2,2,4);
 %! imagesc (rand (30, 30));
 %! text (15, 15, 'Rotated text', ...
 %!      'HorizontAlalignment', 'Center', 'Rotation', 30);
 %! hnew = copyobj (hdl);
 
-%!test
+%!testif HAVE_MAGICK
 %! h1 = figure ();
 %! set (h1, "visible", "off");
 %! x = 0:0.1:2*pi;
 %! y1 = sin (x);
 %! y2 = exp (x - 1);
 %! ax = plotyy (x,y1, x-1,y2, @plot, @semilogy);
 %! xlabel ("X");
 %! ylabel (ax(1), "Axis 1");
diff --git a/scripts/plot/gco.m b/scripts/plot/gco.m
--- a/scripts/plot/gco.m
+++ b/scripts/plot/gco.m
@@ -35,11 +35,11 @@
 ## callback can be interrupted by another callback and the current object
 ## can be modified.
 ##
 ##@seealso{gcbo, gcf}
 ##@end deftypefn
 
 function h = gco ()
 
-  h = get (gcf (), "currentobject");
+  h = get (get (0, "currentfigure"), "currentobject");
 
 endfunction
diff --git a/scripts/plot/legend.m b/scripts/plot/legend.m
--- a/scripts/plot/legend.m
+++ b/scripts/plot/legend.m
@@ -21,23 +21,24 @@
 ## @deftypefnx {Function File} {} legend (@var{matstr})
 ## @deftypefnx {Function File} {} legend (@var{cellstr})
 ## @deftypefnx {Function File} {} legend (@dots{}, "location", @var{pos})
 ## @deftypefnx {Function File} {} legend (@dots{}, "orientation", @var{orient})
 ## @deftypefnx {Function File} {} legend (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {} legend (@var{hobjs}, @dots{})
 ## @deftypefnx {Function File} {} legend (@var{hax}, @var{hobjs}, @dots{})
 ## @deftypefnx {Function File} {} legend ("@var{option}")
+## @deftypefnx {Function File} {[@var{hleg}, @var{hleg_obj}, @var{hplot}, @var{labels}] =} legend (@dots{})
 ##
 ## Display a legend for the axes with handle @var{hax}, or the current axes,
 ## using the specified strings as labels.  Legend entries may be specified
 ## as individual character string arguments, a character array, or a cell
 ## array of character strings.  If the handles, @var{hobjs}, are not specified
 ## then the legend's strings will be associated with the axes' descendants.
-## Legend works on line graphs, bar graphs, etc.
+## @code{legend} works on line graphs, bar graphs, etc.
 ## A plot must exist before legend is called.
 ##
 ## The optional parameter @var{pos} specifies the location of the legend
 ## as follows:
 ##
 ## @multitable @columnfractions 0.06 0.14 0.80
 ##
 ## @headitem @tab @var{pos} @tab
@@ -69,18 +70,18 @@
 ##
 ## @item
 ##
 ## @item @tab outside @tab
 ##   can be appended to any location string
 ## @end multitable
 ##
 ## The optional parameter @var{orient} determines if the key elements
-## are placed vertically or horizontally.  The allowed values are "vertical"
-## or "horizontal" with the default being "vertical".
+## are placed vertically or horizontally.  The allowed values are
+## "vertical" (default) or "horizontal".
 ##
 ## The following customizations are available using @var{option}:
 ##
 ## @table @asis
 ## @item "show"
 ##   Show legend on the plot
 ##
 ## @item "hide"
@@ -91,24 +92,45 @@
 ##
 ## @item "boxon"
 ##   Show a box around legend
 ##
 ## @item "boxoff"
 ##   Hide the box around legend
 ##
 ## @item "left"
-##   Place text to the left of the keys
+##   Place label text to the left of the keys
 ##
 ## @item "right"
-##   Place text to the right of the keys
+##   Place label text to the right of the keys
 ##
 ## @itemx "off"
 ##   Delete the legend object
 ## @end table
+##
+## The optional output values are
+##
+## @table @var
+## @item hleg
+##   The graphics handle of the legend object.
+##
+## @item hleg_obj
+##   Graphics handles to the text and line objects which make up the legend.
+##
+## @item hplot
+##   Graphics handles to the plot objects which were used in making the legend.
+##
+## @item labels
+##   A cell array of strings of the labels in the legend.
+## @end table 
+##
+## The legend label text is either provided in the call to @code{legend} or
+## is taken from the DisplayName property of graphics objects.  If no
+## labels or DisplayNames are available, then the label text is simply
+## "data1", "data2", @dots{}, "dataN".
 ## @end deftypefn
 
 function [hlegend2, hobjects2, hplot2, text_strings2] = legend (varargin)
 
   if (nargin > 0
       && (! ishandle (varargin{1})
           || (strcmp (get (varargin{1}, "type"), "axes")
               && ! strcmp (get (varargin{1}, "tag"), "legend"))))
@@ -117,88 +139,91 @@ function [hlegend2, hobjects2, hplot2, t
   else
     fig = get (0, "currentfigure");
     if (isempty (fig))
       fig = gcf ();
     endif
     ca = gca ();
   endif
 
+  ## Special handling for plotyy which has two axes objects
   if (ishandle (ca) && isprop (ca, "__plotyy_axes__"))
     plty = get (ca, "__plotyy_axes__");
     if (isscalar (plty) && ishandle (plty))
       ca = [ca, plty];
     elseif (iscell (plty))
       ca = [ca, plty{:}];
     elseif (all (ishandle (plty)))
       ca = [ca, plty(:).'];
     else
       error ("legend.m: This should not happen. File a bug report.");
     endif
     ## Remove duplicates while preserving order
     [~, n] = unique (ca);
-    ca = ca (sort (n));
+    ca = ca(sort (n));
   endif
 
   if (nargin > 0 && all (ishandle (varargin{1})))
     kids = flipud (varargin{1}(:));
     varargin(1) = [];
   else
     kids = ca;
-    kids (strcmp (get (ca, "tag"), "legend")) = [];
+    kids(strcmp (get (ca, "tag"), "legend")) = [];
     if (isscalar (kids))
       kids = get (kids, "children")(:);
     else
       kids = flipud ([get(kids, "children"){:}](:));
     endif
   endif
   nargs = numel (varargin);
   nkids = numel (kids);
 
   orientation = "default";
   position = "default";
   show = "create";
   textpos = "default";
   box = "default";
 
+  ## Process old way of specifying position with a number rather than a string.
   if (nargs > 0)
     pos = varargin{nargs};
     if (isnumeric (pos) && isscalar (pos) && pos == fix (pos))
       if (pos >= -1 && pos <= 4)
         position = [{"northeastoutside", "best", "northeast",
                      "northwest", "southwest", "southeast"}] {pos + 2};
         nargs--;
       else
         error ("legend: invalid position specified");
       endif
     endif
   endif
 
+  ## Find position and orientation property/value pairs
   while (nargs > 1)
     pos = varargin{nargs-1};
     str = varargin{nargs};
-    if (strcmpi (pos, "location")  && ischar (str))
+    if (strcmpi (pos, "location") && ischar (str))
       position = lower (str);
       nargs -= 2;
-    elseif (strcmpi (pos, "orientation")  && ischar (str))
+    elseif (strcmpi (pos, "orientation") && ischar (str))
       orientation = lower (str);
       nargs -= 2;
     else
       break;
     endif
   endwhile
 
   ## Validate the orientation
   switch (orientation)
-    case {"vertical", "horizontal","default"}
+    case {"vertical", "horizontal", "default"}
     otherwise
       error ("legend: unrecognized legend orientation");
   endswitch
 
-  ## Validate the position type is valid
+  ## Validate the position type
   outside = false;
   inout = strfind (position, "outside");
   if (! isempty (inout))
     outside = true;
     position = position(1:inout-1);
   else
     outside = false;
   endif
@@ -208,46 +233,55 @@ function [hlegend2, hobjects2, hplot2, t
           "southeast", "southwest", "default"}
     case "best"
       warning ("legend: 'Best' not yet implemented for location specifier\n");
       position = "northeast";
     otherwise
       error ("legend: unrecognized legend position");
   endswitch
 
+  ## Find any existing legend object on figure
   hlegend = [];
   fkids = get (fig, "children");
   for i = 1 : numel (fkids)
-    if (ishandle (fkids (i)) && strcmp (get (fkids (i), "type"), "axes")
-        && (strcmp (get (fkids (i), "tag"), "legend")))
-      udata = get (fkids (i), "userdata");
+    if (ishandle (fkids(i)) && strcmp (get (fkids(i), "type"), "axes")
+        && (strcmp (get (fkids(i), "tag"), "legend")))
+      udata = get (fkids(i), "userdata");
       if (! isempty (intersect (udata.handle, ca)))
-        hlegend = fkids (i);
+        hlegend = fkids(i);
         break;
       endif
     endif
   endfor
 
   if (nargs == 1)
     arg = varargin{1};
     if (ischar (arg))
       if (rows (arg) == 1)
-        str = tolower (deblank (arg));
+        str = tolower (strtrim (arg));
         switch (str)
-          case {"off"}
+          case "off"
             delete (hlegend);
-            return
-          case {"hide"}
+            return;
+          case "hide"
             show = "off";
             nargs--;
           case "show"
-            show = "on";
+            if (! isempty (hlegend))
+              show = "on";
+            else
+              show = "create";
+              textpos = "left";
+            endif
             nargs--;
           case "toggle"
-            if (isempty (hlegend) || strcmp (get (hlegend, "visible"), "off"))
+            if (isempty (hlegend))
+              show = "create";
+              textpos = "left";
+            elseif (strcmp (get (hlegend, "visible"), "off"))
               show = "on";
             else
               show = "off";
             endif
             nargs--;
           case "boxon"
             box = "on";
             nargs--;
@@ -255,33 +289,37 @@ function [hlegend2, hobjects2, hplot2, t
             box = "off";
             nargs--;
           case "left"
             textpos = "left";
             nargs--;
           case "right"
             textpos = "right";
             nargs--;
-          otherwise
         endswitch
       else
+        ## Character matrix of labels
         varargin = cellstr (arg);
         nargs = numel (varargin);
       endif
     elseif (iscellstr (arg))
+      ## Cell array of labels
       varargin = arg;
       nargs = numel (varargin);
     else
       error ("legend: expecting argument to be a character string");
     endif
   elseif (nargs > 1 && iscellstr (varargin{1}))
+    ## Cell array of labels followed by property/value pairs
     varargin = {varargin{1}{:}, varargin{2:end}};
     nargs = numel (varargin);
   endif
 
+  have_labels = (nargs > 0);
+
   if (strcmp (show, "off"))
     if (! isempty (hlegend))
       set (findobj (hlegend), "visible", "off");
       hlegend = [];
     endif
     hobjects = [];
     hplots  = [];
     text_strings = {};
@@ -292,24 +330,25 @@ function [hlegend2, hobjects2, hplot2, t
       set (hlegend, "visible", get (hlegend, "box"));
     else
       hobjects = [];
       hplots  = [];
       text_strings = {};
     endif
   elseif (strcmp (box, "on"))
     if (! isempty (hlegend))
-      set (hlegend, "visible", "on", "box", "on");
+      set (hlegend, "box", "on", "visible", "on");
     endif
   elseif (strcmp (box, "off"))
     if (! isempty (hlegend))
       set (hlegend, "box", "off", "visible", "off");
     endif
-  elseif (nargs == 0 && !(strcmp (position, "default") &&
-                          strcmp (orientation, "default")))
+  elseif (! have_labels && !(strcmp (position, "default") &&
+                             strcmp (orientation, "default")))
+    ## Changing location or orientation of existing legend
     if (! isempty (hlegend))
       hax = getfield (get (hlegend, "userdata"), "handle");
       [hplots, text_strings] = __getlegenddata__ (hlegend);
 
       if (strcmp (position, "default"))
         h = legend (hax, hplots, text_strings, "orientation", orientation);
       elseif (strcmp (orientation, "default"))
         if (outside)
@@ -324,121 +363,158 @@ function [hlegend2, hobjects2, hplot2, t
                       strcat (position, "outside"), "orientation", orientation);
         else
           h = legend (hax, hplots, text_strings, "location", position,
                       "orientation", orientation);
         endif
       endif
     endif
   else
+    ## Create new legend
     hobjects = [];
     hplots  = [];
     text_strings = {};
 
-    if (nargs > 0)
+    if (have_labels)
+      ## Check for valid data that can be labeled.
       have_data = false;
-      for k = 1:nkids
+      have_dname = false;
+      for k = 1 : nkids
         typ = get (kids(k), "type");
         if (strcmp (typ, "line") || strcmp (typ, "surface")
             || strcmp (typ, "patch") || strcmp (typ, "hggroup"))
           have_data = true;
           break;
         endif
       endfor
 
       if (! have_data)
         warning ("legend: plot data is empty; setting key labels has no effect");
       endif
-    endif
+    else
+      ## No labels.  Search for DisplayName property.
+      have_dname = false;
+      for k = 1 : nkids
+        hkid = kids(k);
+        typ = get (hkid, "type");
+        if (strcmp (typ, "line") || strcmp (typ, "surface")
+            || strcmp (typ, "patch"))
+          if (! isempty (get (hkid, "displayname")))
+            have_dname = true;
+            break;
+          endif
+        elseif (strcmp (typ, "hggroup"))
+          hgkids = get (hkid, "children");
+          for j = 1 : length (hgkids)
+            hgobj = get (hgkids(j));
+            if (isfield (hgobj, "displayname") && ! isempty (hgobj.displayname))
+              have_dname = true;
+              break;  # break from j-loop over hgkids
+            endif
+          endfor
+          if (have_dname)
+            break;  # break from k loop over nkids
+          endif
+        endif  # elseif hggroup
+      endfor   # for loop k = 1 : nkids
+    endif      # else branch of if (have_labels)
 
-    if (strcmp (textpos, "default"))
-      warned = false;
+    if (have_labels || ! have_dname)
       k = nkids;
+      if (! have_labels)
+        varargin = arrayfun (@(x) sprintf ("data%d", x), [1:nkids]', "uniformoutput", false);
+        nargs = nkids;
+      endif
       for i = 1 : nargs
         arg = varargin{i};
         if (ischar (arg))
           typ = get (kids(k), "type");
           while (k > 0
                  && ! (strcmp (typ, "line") || strcmp (typ, "surface")
                        || strcmp (typ, "patch") || strcmp (typ, "hggroup")))
             typ = get (kids(--k), "type");
           endwhile
           if (k > 0)
             if (strcmp (get (kids(k), "type"), "hggroup"))
               hgkids = get (kids(k), "children");
               for j = 1 : length (hgkids)
-                hgobj = get (hgkids (j));
+                hgobj = get (hgkids(j));
                 if (isfield (hgobj, "displayname"))
-                  set (hgkids(j), "displayname", arg);
+                  if (have_labels)
+                    set (hgkids(j), "displayname", arg);
+                  endif
                   hplots = [hplots, hgkids(j)];
                   text_strings = {text_strings{:}, arg};
                   break;
                 endif
               endfor
             else
-              set (kids(k), "displayname", arg);
+              if (have_labels)
+                set (kids(k), "displayname", arg);
+              endif
               hplots = [hplots, kids(k)];
               text_strings = {text_strings{:}, arg};
             endif
 
             if (--k == 0)
               break;
             endif
-          elseif (! warned)
-            break;
+          else
+            break;  # k = 0, no further handles to process
           endif
         else
           error ("legend: expecting argument to be a character string");
         endif
       endfor
-      if (i < nargs && ! warned)
+      if (have_labels && i < nargs)
         warning ("legend: ignoring extra labels");
       endif
     else
+      ## No labels specified but objects have DisplayName property set.
       k = nkids;
       while (k > 0)
         typ = get (kids(k), "type");
         while (k > 1
                && ! (strcmp (typ, "line") || strcmp (typ, "surface")
                      || strcmp (typ, "patch") || strcmp (typ, "hggroup")))
           typ = get (kids(--k), "type");
         endwhile
         if (! (strcmp (typ, "line") || strcmp (typ, "surface")
                || strcmp (typ, "patch") || strcmp (typ, "hggroup")))
           break
         endif
         if (k > 0)
           if (strcmp (get (kids(k), "type"), "hggroup"))
             hgkids = get (kids(k), "children");
             for j = 1 : length (hgkids)
-              hgobj = get (hgkids (j));
+              hgobj = get (hgkids(j));
               if (isfield (hgobj, "displayname")
                   && ! isempty (hgobj.displayname))
                 hplots = [hplots, hgkids(j)];
                 text_strings = {text_strings{:}, hgobj.displayname};
                 break;
               endif
             endfor
           else
-            if (! isempty (get (kids (k), "displayname")))
+            if (! isempty (get (kids(k), "displayname")))
               hplots = [hplots, kids(k)];
-              text_strings = {text_strings{:}, get(kids (k), "displayname")};
+              text_strings = {text_strings{:}, get(kids(k), "displayname")};
             endif
           endif
           if (--k == 0)
             break;
           endif
         endif
       endwhile
     endif
 
     if (isempty (hplots))
       if (! isempty (hlegend))
         fkids = get (fig, "children");
-        delete (fkids (fkids == hlegend));
+        delete (fkids(fkids == hlegend));
         hlegend = [];
         hobjects = [];
         hplots  = [];
         text_strings = {};
       endif
     else
       ## Preserve the old legend if it exists
       if (! isempty (hlegend))
@@ -519,59 +595,59 @@ function [hlegend2, hobjects2, hplot2, t
         endif
         ## Add text label to the axis first, checking their extents
         nentries = numel (hplots);
         texthandle = [];
         maxwidth = 0;
         maxheight = 0;
         for k = 1 : nentries
           if (strcmp (textpos, "right"))
-            texthandle = [texthandle, text(0, 0, text_strings {k},
+            texthandle = [texthandle, text(0, 0, text_strings{k},
                                            "horizontalalignment", "left",
                                            "userdata", hplots(k),
                                            "fontsize", ca_fontsize)];
           else
-            texthandle = [texthandle, text(0, 0, text_strings {k},
+            texthandle = [texthandle, text(0, 0, text_strings{k},
                                            "horizontalalignment", "right",
                                            "userdata", hplots(k),
                                            "fontsize", ca_fontsize)];
           endif
-          units = get (texthandle (end), "units");
+          units = get (texthandle(end), "units");
           unwind_protect
-            set (texthandle (end), "units", "points");
-            extents = get (texthandle (end), "extent");
-            maxwidth = max (maxwidth, extents (3));
-            maxheight = max (maxheight, extents (4));
+            set (texthandle(end), "units", "points");
+            extents = get (texthandle(end), "extent");
+            maxwidth = max (maxwidth, extents(3));
+            maxheight = max (maxheight, extents(4));
           unwind_protect_cleanup
-            set (texthandle (end), "units", units);
+            set (texthandle(end), "units", units);
           end_unwind_protect
         endfor
 
         num1 = nentries;
         if (strcmp (orientation, "vertical"))
           height = nentries * (ypad + maxheight);
           if (outside)
-            if (height > ca_pos (4))
+            if (height > ca_pos(4))
               ## Avoid shrinking the height of the axis to zero if outside
               num1 = ca_pos(4) / (maxheight + ypad) / 2;
             endif
           else
-            if (height > 0.9 * ca_pos (4))
+            if (height > 0.9 * ca_pos(4))
               num1 = 0.9 * ca_pos(4) / (maxheight + ypad);
             endif
           endif
         else
           width = nentries * (ypad + maxwidth);
           if (outside)
-            if (width > ca_pos (3))
+            if (width > ca_pos(3))
               ## Avoid shrinking the width of the axis to zero if outside
               num1 = ca_pos(3) / (maxwidth + ypad) / 2;
             endif
           else
-            if (width > 0.9 * ca_pos (3))
+            if (width > 0.9 * ca_pos(3))
               num1 = 0.9 * ca_pos(3) / (maxwidth + ypad);
             endif
           endif
         endif
         num2 = ceil (nentries / num1);
 
         xstep = 3 * xpad + (maxwidth + linelength);
         if (strcmp (textpos, "right"))
@@ -678,17 +754,17 @@ function [hlegend2, hobjects2, hplot2, t
         unwind_protect_cleanup
           set (hlegend, "units", units);
         end_unwind_protect
 
         ## Now write the line segments and place the text objects correctly
         xk = 0;
         yk = 0;
         for k = 1 : numel (hplots)
-          hobjects = [hobjects, texthandle (k)];
+          hobjects = [hobjects, texthandle(k)];
           switch (get (hplots(k), "type"))
           case "line"
             color = get (hplots(k), "color");
             style = get (hplots(k), "linestyle");
             if (! strcmp (style, "none"))
               l1 = line ("xdata", ([xoffset, xoffset + linelength] + xk * xstep) / lpos(3),
                          "ydata", [1, 1] .* (lpos(4) - yoffset - yk * ystep) / lpos(4),
                          "color", color, "linestyle", style, "marker", "none",
@@ -719,17 +795,17 @@ function [hlegend2, hobjects2, hplot2, t
             edgecolor = get (hplots(k), "edgecolor");
             cdata = get (hplots(k), "cdata");
             if (! strcmp (facecolor, "none") || ! strcmp (edgecolor, "none"))
               p1 = patch ("xdata", ([0, linelength, linelength, 0] +
                                    xoffset + xk * xstep) / lpos(3),
                          "ydata", (lpos(4) - yoffset -
                                    [yk-0.3, yk-0.3, yk+0.3, yk+0.3] .* ystep) / lpos(4),
                          "facecolor", facecolor, "edgecolor", edgecolor, "cdata", cdata,
-                         "userdata", hplots (k));
+                         "userdata", hplots(k));
               hobjects = [hobjects, p1];
             endif
           case "surface"
           endswitch
           set (texthandle (k), "position", [(txoffset + xk * xstep) / lpos(3), ...
                                             (lpos(4) - yoffset - yk * ystep) / lpos(4)]);
           if (strcmp (orientation, "vertical"))
             yk++;
@@ -748,26 +824,26 @@ function [hlegend2, hobjects2, hplot2, t
 
         ## Add an invisible text object to original axis
         ## that when it is destroyed will remove the legend
         t1 = text (0, 0, "", "parent", ca(1), "tag", "legend",
                    "handlevisibility", "off", "visible", "off",
                    "xliminclude", "off", "yliminclude", "off");
         set (t1, "deletefcn", {@deletelegend1, hlegend});
 
-        ## Resize the axis the legend is attached to if the
-        ## legend is "outside" the plot and create listener to
+        ## Resize the axis that the legend is attached to if the
+        ## legend is "outside" the plot and create a listener to
         ## resize axis to original size if the legend is deleted,
-        ## hidden or shown
+        ## hidden, or shown.
         if (outside)
           for i = 1 : numel (ca)
             units = get (ca(i), "units");
             unwind_protect
               set (ca(i), "units", "points");
-              set (ca (i), "position", new_pos);
+              set (ca(i), "position", new_pos);
             unwind_protect_cleanup
               set (ca(i), "units", units);
             end_unwind_protect
           endfor
 
           set (hlegend, "deletefcn", {@deletelegend2, ca, ...
                                       ca_pos, ca_outpos, t1, hplots});
           addlistener (hlegend, "visible", {@hideshowlegend, ca, ...
@@ -870,80 +946,80 @@ function hideshowlegend (h, d, ca, pos1,
         set (ca(i), "units", units);
       end_unwind_protect
     endif
   endfor
 endfunction
 
 function deletelegend1 (h, d, ca)
   if (ishandle (ca) && strcmp (get (ca, "type"), "axes")
-      && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"),"off"))
+      && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"), "off"))
       && strcmp (get (ca, "beingdeleted"), "off"))
     delete (ca);
   endif
 endfunction
 
 function deletelegend2 (h, d, ca, pos, outpos, t1, hplots)
   for i = 1 : numel (ca)
     if (ishandle (ca(i)) && strcmp (get (ca(i), "type"), "axes")
-        && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"),"off"))
+        && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"), "off"))
         && strcmp (get (ca(i), "beingdeleted"), "off"))
       if (!isempty (pos) && !isempty(outpos))
         units = get (ca(i), "units");
         unwind_protect
           set (ca(i), "units", "points");
           set (ca(i), "position", pos, "deletefcn", "");
         unwind_protect_cleanup
           set (ca(i), "units", units);
         end_unwind_protect
       endif
     endif
   endfor
   set (t1, "deletefcn", "");
   delete (t1);
   for i = 1 : numel (hplots)
-    if (strcmp (get (hplots (i), "type"), "line"))
-      dellistener (hplots (i), "color");
-      dellistener (hplots (i), "linestyle");
-      dellistener (hplots (i), "marker");
-      dellistener (hplots (i), "markeredgecolor");
-      dellistener (hplots (i), "markerfacecolor");
-      dellistener (hplots (i), "markersize");
-      dellistener (hplots (i), "displayname");
+    if (ishandle (hplots(i)) && strcmp (get (hplots (i), "type"), "line"))
+      dellistener (hplots(i), "color");
+      dellistener (hplots(i), "linestyle");
+      dellistener (hplots(i), "marker");
+      dellistener (hplots(i), "markeredgecolor");
+      dellistener (hplots(i), "markerfacecolor");
+      dellistener (hplots(i), "markersize");
+      dellistener (hplots(i), "displayname");
     endif
   endfor
 endfunction
 
 function updateline (h, d, hlegend, linelength)
   lm = [];
   ll = [];
   kids = get (hlegend, "children");
   for i = 1 : numel (kids)
-    if (get (kids (i), "userdata") == h
+    if (get (kids(i), "userdata") == h
         && strcmp (get (kids(i), "type"), "line"))
       if (strcmp (get (kids (i), "marker"), "none"))
-        ll = kids (i);
+        ll = kids(i);
       else
-        lm = kids (i);
+        lm = kids(i);
       endif
     endif
   endfor
 
   linestyle = get (h, "linestyle");
   marker = get (h, "marker");
   displayname = get (h, "displayname");
 
   if ((isempty (displayname)
        || (strcmp (marker, "none") && strcmp (linestyle, "none")))
        && (! isempty (lm) || isempty (ll)))
     ## An element was removed from the legend. Need to recall the
     ## legend function to recreate a new legend
     [hplots, text_strings] = __getlegenddata__ (hlegend);
     for i = 1 : numel (hplots)
-      if (hplots (i) == h)
+      if (hplots(i) == h)
         hplots(i) = [];
         text_strings(i) = [];
         break;
       endif
     endfor
     legend (hplots, text_strings);
   elseif ((!isempty (displayname)
            && (! strcmp (marker, "none") || ! strcmp (linestyle, "none")))
@@ -981,136 +1057,159 @@ function updateline (h, d, hlegend, line
             "marker", marker, "markeredgecolor", get (h, "markeredgecolor"),
             "markerfacecolor", get (h, "markerfacecolor"),
             "markersize", get (h, "markersize"), "linestyle", "none",
             "userdata", h, "parent", hlegend);
     endif
   endif
 endfunction
 
-%!demo
-%! plot (rand (2))
-%! legend ({'foo'}, 'bar', 'boxoff')
-%! title ('legend() should warn about an extra label')
-
-%!demo
-%! plot (rand (2,2)) ;
-%! h = legend ('a', 'b') ;
-%! legend ('right') ;
-%! set (h, 'textposition', 'left')
-%! set (h, 'textposition', 'right')
-%! set (h, 'textcolor', [1 0 1])
 
 %!demo
-%! clf;
-%! x = 0:1;
-%! plot (x,x,';I am Blue;', x,2*x,';I am Green;', x,3*x,';I am Red;');
-%! legend boxon
-%! legend hide
-%! legend show
+%! plot (rand (2));
+%! title ('legend called with cellstr and string inputs for labels');
+%! legend ({'foo'}, 'bar');
 
 %!demo
-%! clf;
-%! x = 0:1;
-%! plot (x, x, ';\alpha;',  ...
-%!       x, 2*x, ';\beta=2\alpha;',  ...
-%!       x, 3*x, ';\gamma=3\alpha;');
+%! plot (rand (3));
+%! title ('legend() without inputs creates default labels');
+%! legend ();
 
 %!demo
 %! clf;
 %! x = 0:1;
 %! plot (x,x,';I am Blue;', x,2*x, x,3*x,';I am Red;');
-%! title ('Blue and Green keys, with Green missing');
+%! title ('Blue and Red keys, with Green missing');
 
 %!demo
 %! clf;
 %! plot (1:10, 1:10, 1:10, fliplr (1:10));
 %! title ('incline is blue and decline is green');
 %! legend ({'I am blue', 'I am green'}, 'location', 'east');
 
 %!demo
 %! clf;
 %! plot (1:10, 1:10, 1:10, fliplr (1:10));
-%! title ('Legend is hidden')
-%! legend ({'I am blue', 'I am green'}, 'location', 'east');
-%! legend hide;
+%! title ('Legend with keys in horizontal orientation');
+%! legend ({'I am blue', 'I am green'}, 'location', 'east', 'orientation', 'horizontal');
+%! legend boxoff;
 
 %!demo
 %! clf;
 %! plot (1:10, 1:10, 1:10, fliplr (1:10));
 %! title ('Legend with box off');
 %! legend ({'I am blue', 'I am green'}, 'location', 'east');
 %! legend boxoff;
 
 %!demo
 %! clf;
 %! plot (1:10, 1:10, 1:10, fliplr (1:10));
-%! title ('Legend with text to the right');
+%! title ('Legend with text to the right of key');
 %! legend ({'I am blue', 'I am green'}, 'location', 'east');
 %! legend right;
 
 %!demo
 %! clf;
+%! plot (1:10, 1:10, 1:10, fliplr (1:10));
+%! title ('Using properties to have legend text shown to the right of key');
+%! h = legend ({'I am blue', 'I am green'}, 'location', 'east');
+%! legend ('left');
+%! set (h, 'textposition', 'right');
+%! set (h, 'textcolor', [1 0 1]);
+
+%!demo
+%! clf;
+%! plot (1:10, 1:10, 1:10, fliplr (1:10));
+%! title ('Legend is hidden')
+%! legend ({'I am blue', 'I am green'}, 'location', 'east');
+%! legend hide;
+
+%!demo
+%! clf;
+%! x = 0:1;
+%! plot (x,x,';I am Blue;', x,2*x,';I am Green;', x,3*x,';I am Red;');
+%! title ('labels embedded in call to plot');
+%! legend boxon
+%! legend hide
+%! legend show
+
+%!demo
+%! clf;
+%! x = 0:1;
+%! plot (x, x, ';\alpha;',  ...
+%!       x, 2*x, ';\beta=2\alpha;',  ...
+%!       x, 3*x, ';\gamma=3\alpha;');
+%! title ('labels with interpreted Greek text');
+
+%!demo
+%! clf;
+%! plot (rand (2));
+%! title ('Labels with TeX interpreter turned off');
+%! h = legend ('Hello_World', 'foo^bar');
+%! set (h, 'interpreter', 'none');
+
+%!demo
+%! clf;
 %! plot (1:10, 1:10);
 %! title ('a very long label can sometimes cause problems');
-%! legend ({'hello world'}, 'location', 'northeastoutside');
-
-%!demo
-%! clf;
-%! plot (1:10, 1:10);
-%! title ('a very long label can sometimes cause problems');
-%! legend ('hello world', 'location', 'northeastoutside');
+%! legend ('hello very big world', 'location', 'northeastoutside');
 
 %!demo
 %! clf;
 %! labels = {};
 %! colororder = get (gca, 'colororder');
 %! for i = 1:5
 %!   h = plot (1:100, i + rand (100,1)); hold on;
 %!   set (h, 'color', colororder(i,:));
 %!   labels = {labels{:}, ['Signal ', num2str(i)]};
 %! end
 %! hold off;
-%! title ('Signals with random offset and uniform noise');
+%! title ({'Signals with random offset and uniform noise';
+%!         'Legend shown below and outside of plot'});
 %! xlabel ('Sample Nr [k]'); ylabel ('Amplitude [V]');
 %! legend (labels, 'location', 'southoutside');
 
 %!demo
 %! clf;
 %! x = linspace (0, 10);
 %! plot (x, x);
 %! hold on;
 %! stem (x, x.^2, 'g');
+%! title ('First created object gets first label');
 %! legend ('linear');
 %! hold off;
 
 %!demo
 %! clf;
 %! x = linspace (0, 10);
 %! plot (x, x, x, x.^2);
+%! title ('First created object gets first label');
 %! legend ('linear');
 
 %!demo
 %! clf;
 %! x = linspace (0, 10);
 %! plot (x, x, x, x.^2);
+%! title ('Labels are applied in order of object creation');
 %! legend ('linear', 'quadratic');
 
 %!demo
 %! clf;
 %! rand_2x3_data1 = [0.341447, 0.171220, 0.284370; 0.039773, 0.731725, 0.779382];
 %! bar (rand_2x3_data1);
 %! ylim ([0 1.0]);
+%! title ('legend() works for bar graphs (hgobjects)');
 %! legend ({'1st Bar', '2nd Bar', '3rd Bar'});
 
 %!demo
 %! clf;
 %! rand_2x3_data2 = [0.44804, 0.84368, 0.23012; 0.72311, 0.58335, 0.90531];
 %! bar (rand_2x3_data2);
 %! ylim ([0 1.2]);
+%! title ('legend() works for bar graphs (hgobjects)');
 %! legend ('1st Bar', '2nd Bar', '3rd Bar');
 %! legend right;
 
 %!demo
 %! clf;
 %! x = 0:0.1:7;
 %! h = plot (x,sin(x), x,cos(x), x,sin(x.^2/10), x,cos(x.^2/10));
 %! title ('Only the sin() objects have keylabels');
@@ -1118,33 +1217,35 @@ endfunction
 
 %!demo
 %! clf;
 %! x = 0:0.1:10;
 %! plot (x, sin (x), ';sin (x);');
 %! hold all;
 %! plot (x, cos (x), ';cos (x);');
 %! hold off;
+%! title ('legend constructed from multiple plot calls');
 
 %!demo
 %! clf;
 %! x = 0:0.1:10;
 %! plot (x, sin (x), ';sin (x);');
 %! hold all;
 %! plot (x, cos (x), ';cos (x);');
 %! hold off;
-%! legend ({'sin (x)', 'cos (x)'}, 'location', 'northeastoutside');
+%! title ('Specified label text overrides previous labels');
+%! legend ({'Sine', 'Cosine'}, 'location', 'northeastoutside');
 
 %!demo
 %! clf;
 %! x = 0:10;
 %! plot (x, rand (11));
 %! xlabel ('Indices');
 %! ylabel ('Random Values');
-%! title ('Legend ''off'' should delete the legend');
+%! title ('Legend ''off'' deletes the legend');
 %! legend (cellstr (num2str ((1:10)')), 'location', 'northeastoutside');
 %! legend off;
 %! axis ([0, 10, 0 1]);
 
 %!demo
 %! clf;
 %! x = (1:5)';
 %! subplot (2,2,1);
@@ -1158,39 +1259,35 @@ endfunction
 %!  legend (cellstr (num2str (x)), 'location', 'southwestoutside');
 %! subplot (2,2,4);
 %!  plot (x, rand (numel (x)));
 %!  legend (cellstr (num2str (x)), 'location', 'southeastoutside');
 
 %!demo
 %! clf;
 %! plot (rand (2));
-%! title ('Warn of extra labels');
+%! title ('legend() will warn if extra labels are specified');
 %! legend ('Hello', 'World', 'interpreter', 'foobar');
 
 %!demo
-%! clf;
-%! plot (rand (2));
-%! title ('Turn off TeX interpreter');
-%! h = legend ('Hello_World', 'foo^bar');
-%! set (h, 'interpreter', 'none');
-
-%!demo
 %! x = 0:10;
 %! y1 = rand (size (x));
 %! y2 = rand (size (x));
 %! [ax, h1, h2] = plotyy (x, y1, x, y2);
+%! title ('plotyy legend test #1: Blue and Green labels');
 %! legend ([h1, h2], {'Blue', 'Green'}, 'location', 'south');
 
 %!demo
 %! x = 0:10;
 %! y1 = rand (size (x));
 %! y2 = rand (size (x));
 %! [ax, h1, h2] = plotyy (x, y1, x, y2);
+%! title ('plotyy legend test #2: Blue and Green labels');
 %! legend ({'Blue', 'Green'}, 'location', 'south');
 
 %!demo
 %! x = 0:10;
 %! y1 = rand (size (x));
 %! y2 = rand (size (x));
 %! [ax, h1, h2] = plotyy (x, y1, x, y2);
+%! title ('plotyy legend test #3: Blue and Green labels');
 %! legend ('Blue', 'Green', 'location', 'south');
 
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -16,113 +16,113 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} print ()
 ## @deftypefnx {Function File} {} print (@var{options})
 ## @deftypefnx {Function File} {} print (@var{filename}, @var{options})
 ## @deftypefnx {Function File} {} print (@var{h}, @var{filename}, @var{options})
-## Print a graph, or save it to a file.  Both output formatted for 
+## Print a plot, or save it to a file.  Both output formatted for 
 ## printing (PDF and PostScript), and many bitmapped and vector
 ## image formats are supported.
 ##
-## @var{h} specifies the figure handle.  If no handle is specified
-## the handle for the current figure is used.
-##
 ## @var{filename} defines the name of the output file.  If the
 ## file name has no suffix, one is inferred from the specified
 ## device and appended to the file name.  If no filename is
 ## specified, the output is sent to the printer.
 ##
-## For output to a printer, to a PostScript file, or a PDF file,
+## @var{h} specifies the figure handle.  If no handle is specified
+## the handle for the current figure is used.
+##
+## For output to a printer, PostScript file, or PDF file,
 ## the paper size is specified by the figure's @code{papersize}
 ## property.  The location and size of the image on the page are
 ## specified by the figure's @code{paperposition} property.  The
 ## orientation of the page is specified by the figure's
 ## @code{paperorientation} property.
 ##
 ## The width and height of images are specified by the figure's
 ## @code{paperpositon(3:4)} property values.
 ##
-## The @code{print} command supports several @var{options}:
+## The @code{print} command supports many @var{options}:
 ##
 ## @table @code
 ## @item -f@var{h}
 ##   Specify the handle, @var{h}, of the figure to be printed.  The
-##   default is the current figure.
+## default is the current figure.
 ##
 ## @item -P@var{printer}
-##   Set the @var{printer} name to which the graph is sent if no
-##   @var{filename} is specified.
+##   Set the @var{printer} name to which the plot is sent if no
+## @var{filename} is specified.
 ##
 ## @item -G@var{ghostscript_command}
-##   Specify the command for calling Ghostscript.  For Unix and Windows,
+##   Specify the command for calling Ghostscript.  For Unix and Windows
 ## the defaults are 'gs' and 'gswin32c', respectively.
 ##
 ## @item -color
 ## @itemx -mono
 ##   Monochrome or color output.
 ##
 ## @item -solid
 ## @itemx -dashed
-##   Forces all lines to be solid or dashed, respectively.
+##   Force all lines to be solid or dashed, respectively.
 ##
 ## @item -portrait
 ## @itemx -landscape
 ##   Specify the orientation of the plot for printed output.  For
 ## non-printed output the aspect ratio of the output corresponds to
 ## the plot area defined by the "paperposition" property in the
 ## orientation specified.  This options is equivalent to changing
 ## the figure's "paperorientation" property.
 ##
 ## @item -TextAlphaBits=@var{n}
 ## @itemx -GraphicsAlphaBits=@var{n}
 ##   Octave is able to produce output for various printers, bitmaps, and
 ## vector formats by using Ghostscript.
 ## For bitmap and printer output anti-aliasing is applied using
 ## Ghostscript's TextAlphaBits and GraphicsAlphaBits options.
 ## The default number of bits for each is 4.
-## Allowed values, for @var{N}, are 1, 2, or 4.
+## Allowed values for @var{N} are 1, 2, or 4.
 ##
 ## @item -d@var{device}
 ##   The available output format is specified by the option @var{device},
-##   and is one of:
+## and is one of:
 ##
 ##   @table @code
 ##   @item ps
 ##   @itemx ps2
 ##   @itemx psc
 ##   @itemx psc2
 ##     Postscript (level 1 and 2, mono and color).  The FLTK graphics
-##     toolkit generates Postscript level 3.0.
+## toolkit generates Postscript level 3.0.
 ##
 ##   @item eps
 ##   @itemx eps2
 ##   @itemx epsc
 ##   @itemx epsc2
 ##     Encapsulated postscript (level 1 and 2, mono and color).  The FLTK
 ## graphic toolkit generates Postscript level 3.0.
 ##
 ##   @item tex
 ##   @itemx epslatex
 ##   @itemx epslatexstandalone
 ##   @itemx pstex
 ##   @itemx pslatex
 ##   @itemx pdflatex
-##     Generate a @LaTeX{} (or @TeX{}) file for labels, and eps/ps/pdf
+##     Generate a @LaTeX{} (or @TeX{}) file for labels and eps/ps/pdf
 ## for graphics.  The file produced by @code{epslatexstandalone} can be
 ## processed directly by @LaTeX{}.  The other formats are intended to
 ## be included in a @LaTeX{} (or @TeX{}) document.  The @code{tex} device
 ## is the same as the @code{epslatex} device.  The @code{pdflatex} device
 ## is only available for the FLTK graphics toolkit.
 ##
 ##   @item tikz
-##     Generate a @LaTeX{} file using PGF/TikZ@.  For the FLTK the result is
-##   PGF.
+##     Generate a @LaTeX{} file using PGF/TikZ@.  For the FLTK toolkit
+## the result is PGF.
 ##
 ##   @item ill
 ##   @itemx aifm
 ##     Adobe Illustrator (Obsolete for Gnuplot versions > 4.2)
 ##
 ##   @item cdr
 ##   @itemx @nospell{corel}
 ##     CorelDraw
@@ -131,19 +131,19 @@
 ##     AutoCAD
 ##
 ##   @item emf
 ##   @itemx meta
 ##     Microsoft Enhanced Metafile
 ##
 ##   @item fig
 ##     XFig.  For the Gnuplot graphics toolkit, the additional options
-##     @option{-textspecial} or @option{-textnormal} can be used to control
-##     whether the special flag should be set for the text in
-##     the figure (default is @option{-textnormal}).
+## @option{-textspecial} or @option{-textnormal} can be used to control
+## whether the special flag should be set for the text in
+## the figure.  (default is @option{-textnormal})
 ##
 ##   @item hpgl
 ##     HP plotter language
 ##
 ##   @item mf
 ##     Metafont
 ##
 ##   @item png
@@ -203,62 +203,62 @@
 ## and devices are available.
 ##
 ##   When Ghostscript output is sent to a printer the size is determined
 ## by the figure's "papersize" property.  When the output
 ## is sent to a file the size is determined by the plot box defined by
 ## the figure's "paperposition" property.
 ##
 ## @itemx -append
-##   Appends the PS, or PDF output to a pre-existing file of the
+##   Append Postscript or PDF output to a pre-existing file of the
 ## same type.
 ##
 ## @itemx -r@var{NUM}
 ##   Resolution of bitmaps in pixels per inch.  For both metafiles and
-## SVG the default is the screen resolution, for other it is 150 dpi.
+## SVG the default is the screen resolution; for other formats it is 150 dpi.
 ## To specify screen resolution, use "-r0".
 ##
 ## @item -tight
-##   Forces a tight bounding box for eps-files.
+##   Force a tight bounding box for eps files.
 ##
 ## @item -@var{preview}
-##   Adds a preview to eps-files.  Supported formats are;
+##   Add a preview to eps files.  Supported formats are:
 ##
 ##   @table @code
 ##   @item -interchange
-##     Provides an interchange preview.
+##     Provide an interchange preview.
 ##
 ##   @item -metalfile
-##     Provides a metafile preview.
+##     Provide a metafile preview.
 ##
 ##   @item -pict
-##     Provides pict preview.
+##     Provide pict preview.
 ##
 ##   @item -tiff
-##     Provides a tiff preview.
+##     Provide a tiff preview.
 ##   @end table
 ##
 ## @item -S@var{xsize},@var{ysize}
-##   Plot size in pixels for EMF, GIF, JPEG, PBM, PNG and SVG@.  For
+##   Plot size in pixels for EMF, GIF, JPEG, PBM, PNG, and SVG@.  For
 ## PS, EPS, PDF, and other vector formats the plot size is in points.
 ## This option is equivalent to changing the size of the plot box
-## associated with "paperposition" property.  Using the command form of
-## the print function, you must quote the @var{xsize},@var{ysize}
-## option.  For example, by writing @w{@code{"-S640,480"}}.
+## associated with the "paperposition" property.  When using the command form
+## of the print function you must quote the @var{xsize},@var{ysize}
+## option.  For example, by writing @w{"-S640,480"}.
 ##
 ## @item -F@var{fontname}
 ## @itemx -F@var{fontname}:@var{size}
 ## @itemx -F:@var{size}
-##   Associates all text with the @var{fontname} and/or @var{fontsize}.
-## @var{fontname} is ignored for some devices; dxf, fig, hpgl, etc.
+##   Use @var{fontname} and/or @var{fontsize} for all text.
+## @var{fontname} is ignored for some devices: dxf, fig, hpgl, etc.
 ## @end table
 ##
 ## The filename and options can be given in any order.
 ##
-## Example: Print to a file, using the svg device.
+## Example: Print to a file using the svg device.
 ##
 ## @example
 ## @group
 ## figure (1);
 ## clf ();
 ## surf (peaks);
 ## print -dsvg figure1.svg
 ## @end group
diff --git a/scripts/plot/private/__bar__.m b/scripts/plot/private/__bar__.m
--- a/scripts/plot/private/__bar__.m
+++ b/scripts/plot/private/__bar__.m
@@ -212,30 +212,32 @@ function tmp = bars (ax, vertical, x, y,
                    "cdata", lev, "parent", hg);
       else
         h = patch (yb(:,:,i), xb(:,:,i), "parent", hg);
       endif
     endif
 
     if (i == 1)
       x_axis_range = get (ax, "xlim");
-      h_baseline = line (x_axis_range, [0, 0], "color", [0, 0, 0]);
+      h_baseline = line (x_axis_range, [base_value, base_value],
+                         "color", [0, 0, 0]);
       set (h_baseline, "handlevisibility", "off");
       set (h_baseline, "xliminclude", "off");
       addlistener (ax, "xlim", @update_xlim);
       addlistener (h_baseline, "ydata", @update_baseline);
       addlistener (h_baseline, "visible", @update_baseline);
     endif
 
     ## Setup the hggroup and listeners
     addproperty ("showbaseline", hg, "radio", "{on}|off");
     addproperty ("basevalue", hg, "data", base_value);
     addproperty ("baseline", hg, "data", h_baseline);
 
-    addlistener (hg, "showbaseline", @show_baseline);
+    addlistener (hg, "showbaseline", {@show_baseline, "showbl"});
+    addlistener (hg, "visible", {@show_baseline, "visib"});
     addlistener (hg, "basevalue", @move_baseline);
 
     addproperty ("barwidth", hg, "data", width);
     if (group)
       addproperty ("barlayout", hg, "radio", "stacked|{grouped}", "grouped");
     else
       addproperty ("barlayout", hg, "radio", "{stacked}|grouped", "stacked");
     endif
@@ -311,30 +313,37 @@ function update_baseline (h, d)
       endif
       if (! strcmpi (get (kids(i), "basevalue"), visible))
         set (kids (i), "basevalue", ydata);
       endif
     endif
   endfor
 endfunction
 
-function show_baseline (h, d)
+function show_baseline (h, d, prop = "")
   persistent recursion = false;
-
+  
   ## Don't allow recursion
   if (! recursion)
     unwind_protect
       recursion = true;
       hlist = get (h, "bargroup");
-      showbaseline = get (h, "showbaseline");
-      for hh = hlist(:)'
-        if (hh != h)
-          set (hh, "showbaseline", showbaseline);
+      if (strcmp (prop, "showbl"))
+        showbaseline = get (h, "showbaseline");
+        for hh = hlist(:)'
+          if (hh != h)
+            set (hh, "showbaseline", showbaseline);
+          endif
+        endfor
+      elseif (strcmp (prop, "visib"))
+        showbaseline = "on";
+        if (all (strcmp (get (hlist, "visible"), "off")))
+          showbaseline = "off";
         endif
-      endfor
+      endif
       set (get (h, "baseline"), "visible", showbaseline);
     unwind_protect_cleanup
       recursion = false;
     end_unwind_protect
   endif
 endfunction
 
 function move_baseline (h, d)
diff --git a/scripts/plot/private/__contour__.m b/scripts/plot/private/__contour__.m
--- a/scripts/plot/private/__contour__.m
+++ b/scripts/plot/private/__contour__.m
@@ -236,16 +236,18 @@ function add_patch_children (hg)
 
   if (strcmpi (filled, "on"))
 
     lvl_eps = get_lvl_eps (lev);
 
     ## Decode contourc output format.
     i1 = 1;
     ncont = 0;
+    cont_lev = [];
+    cont_area = [];
     while (i1 < columns (c))
       ncont++;
       cont_lev(ncont) = c(1, i1);
       cont_len(ncont) = c(2, i1);
       cont_idx(ncont) = i1+1;
       ii = i1+1:i1+cont_len(ncont);
       cont_area(ncont) = polyarea (c(1, ii), c(2, ii));
       i1 += c(2, i1) + 1;
diff --git a/scripts/plot/private/__fltk_print__.m b/scripts/plot/private/__fltk_print__.m
--- a/scripts/plot/private/__fltk_print__.m
+++ b/scripts/plot/private/__fltk_print__.m
@@ -56,17 +56,17 @@ function opts = __fltk_print__ (opts)
       name = opts.name(1:dot-1);
       if (dot < numel (opts.name)
           && any (strcmpi (opts.name(dot+1:end), {"eps", "ps", "pdf"})))
         ## If user provides eps/ps/pdf suffix, use it.
         suffix = opts.name(dot+1:end);
       endif
     else
       error ("print:invalid-suffix", 
-             "invalid suffix `%s' for device `%s'.",
+             "invalid suffix '%s' for device '%s'.",
              opts.name(dot:end), lower (opts.devopt));
     endif
     gl2ps_device = {sprintf("%snotxt", lower (suffix))};
     gl2ps_device{2} = "tex";
     if (dos_shell)
       ## FIXME - this will only work on MinGW with the MSYS shell
       pipeline = {sprintf("cat > %s-inc.%s", name, suffix)};
       pipeline{2} = sprintf ("cat > %s.tex", name);
diff --git a/scripts/plot/private/__gnuplot_print__.m b/scripts/plot/private/__gnuplot_print__.m
--- a/scripts/plot/private/__gnuplot_print__.m
+++ b/scripts/plot/private/__gnuplot_print__.m
@@ -71,17 +71,17 @@ function opts = __gnuplot_print__ (opts)
     dot = find (opts.name == ".", 1, "last");
     n = find (opts.devopt == "l", 1);
     suffix = opts.devopt(1:n-1);
     if (! isempty (dot))
       if (any (strcmpi (opts.name(dot:end), {strcat(".", suffix), ".tex", "."})))
         name = opts.name(1:dot-1);
       else
         error ("print:invalid-suffix", 
-               "invalid suffix `%s' for device `%s'.",
+               "invalid suffix '%s' for device '%s'.",
                opts.name(dot:end), lower (opts.devopt));
       endif
     endif
     if (strfind (opts.devopt, "standalone"))
       term = sprintf ("%s ",
                       strrep (opts.devopt, "standalone", " standalone"));
     else
       term = sprintf ("%s ", opts.devopt);
diff --git a/scripts/plot/private/__go_draw_axes__.m b/scripts/plot/private/__go_draw_axes__.m
--- a/scripts/plot/private/__go_draw_axes__.m
+++ b/scripts/plot/private/__go_draw_axes__.m
@@ -42,17 +42,17 @@ function __go_draw_axes__ (h, plot_strea
     ## Set to false for plotyy axes.
     ymirror = true;
     if (isfield (axis_obj, "__plotyy_axes__"))
       if (all (ishandle (axis_obj.__plotyy_axes__)))
         ymirror = false;
       else
         h = axis_obj.__plotyy_axes__;
         h = h(ishandle (h));
-        h = h(isprop (h, "__ploty_axes__"));
+        h = h(isprop (h, "__plotyy_axes__"));
         rmappdata (h, "__plotyy_axes__");
       endif
     endif
 
     nd = __calc_dimensions__ (h);
 
     if (strcmp (axis_obj.dataaspectratiomode, "manual")
         && strcmp (axis_obj.xlimmode, "manual")
@@ -437,16 +437,26 @@ function __go_draw_axes__ (h, plot_strea
 
     ximg_data = {};
     ximg_data_idx = 0;
 
     while (! isempty (kids))
 
       obj = get (kids(end));
 
+      if (isfield (obj, "xdata"))
+        obj.xdata = double (obj.xdata);
+      end
+      if (isfield (obj, "ydata"))
+        obj.ydata = double (obj.ydata);
+      end
+      if (isfield (obj, "zdata"))
+        obj.zdata = double (obj.zdata);
+      end
+
       if (isfield (obj, "units"))
         units = obj.units;
         unwind_protect
           set (kids(end), "units", "data");
           obj = get (kids(end));
         unwind_protect_cleanup
           set (kids(end), "units", units);
         end_unwind_protect
diff --git a/scripts/plot/private/__go_draw_figure__.m b/scripts/plot/private/__go_draw_figure__.m
--- a/scripts/plot/private/__go_draw_figure__.m
+++ b/scripts/plot/private/__go_draw_figure__.m
@@ -194,17 +194,17 @@ function __go_draw_figure__ (h, plot_str
         else
           fputs (plot_stream, "\nunset multiplot;\n");
         endif
       else
         fputs (plot_stream, "\nreset; clear;\n");
         fflush (plot_stream);
       endif
     else
-      error ("__go_draw_figure__: expecting figure object, found `%s'",
+      error ("__go_draw_figure__: expecting figure object, found '%s'",
              htype);
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
diff --git a/scripts/plot/private/__pie__.m b/scripts/plot/private/__pie__.m
--- a/scripts/plot/private/__pie__.m
+++ b/scripts/plot/private/__pie__.m
@@ -134,17 +134,17 @@ function hlist = __pie__ (caller, vararg
       else
         align = "right";
       endif
 
       hlist = [hlist; patch(xoff + [0, -sind(xn)], yoff + [0, cosd(xn)], i);
                text(xt, yt, labels{i}, "horizontalalignment", align)];
 
     else
-      error ("__pie__: unknown caller `%s'", caller);
+      error ("__pie__: unknown caller '%s'", caller);
     endif
   endfor
 
   addlistener (gca, "view", {@update_text_pos, hlist});
 
   if (strncmp (caller, "pie3", 4))
     axis ([-1.25, 1.25, -1.25, 1.25, -0.05, 0.4], "equal", "off");
     view (-37.5, 30);
diff --git a/scripts/plot/private/__pltopt__.m b/scripts/plot/private/__pltopt__.m
--- a/scripts/plot/private/__pltopt__.m
+++ b/scripts/plot/private/__pltopt__.m
@@ -214,17 +214,17 @@ function [options, valid] = __pltopt1__ 
           else
             valid = false;
             options = __default_plot_options__ ();
             return;
           endif
         endif
       else
         if (err_on_invalid)
-          error ("%s: unrecognized format character: `%s'", caller, topt);
+          error ("%s: unrecognized format character: '%s'", caller, topt);
         else
           valid = false;
           options = __default_plot_options__ ();
           return;
         endif
       endif
     endif
     opt(1:n) = [];
diff --git a/scripts/plot/private/__print_parse_opts__.m b/scripts/plot/private/__print_parse_opts__.m
--- a/scripts/plot/private/__print_parse_opts__.m
+++ b/scripts/plot/private/__print_parse_opts__.m
@@ -152,17 +152,17 @@ function arg_st = __print_parse_opts__ (
         endif
       elseif (length (arg) > 2 && arg(1:2) == "-S")
         arg_st.canvas_size = str2num (arg(3:end));
       elseif (length (arg) > 2 && arg(1:2) == "-r")
         arg_st.ghostscript.resolution = str2double (arg(3:end));
       elseif (length (arg) > 2 && arg(1:2) == "-f")
         arg_st.figure = str2num (arg(3:end));
       elseif (length (arg) >= 1 && arg(1) == "-")
-        error ("print: unknown option `%s'", arg);
+        error ("print: unknown option '%s'", arg);
       elseif (length (arg) > 0)
         arg_st.name = arg;
       endif
     elseif (isfigure (arg))
       arg_st.figure = arg;
     else
       error ("print: expecting inputs to be character string options or a figure handle");
     endif
@@ -495,17 +495,17 @@ function gs = __ghostscript_binary__ ()
 
 endfunction
 
 function bin = __find_binary__ (binary)
 
   persistent data = struct ()
 
   if (! isfield (data, binary))
-    ## Reinitialize when `user_binaries' is present.
+    ## Reinitialize when 'user_binaries' is present.
     data.(binary).bin = "";
     data.(binary).warn_on_absence = false;
   endif
 
   if (isempty (data.(binary).bin))
     if (isunix ())
       ## Unix - Includes Mac OSX and Cygwin.
       binaries = strcat (binary, {"", ".exe"});
diff --git a/scripts/plot/saveas.m b/scripts/plot/saveas.m
--- a/scripts/plot/saveas.m
+++ b/scripts/plot/saveas.m
@@ -97,11 +97,11 @@ function  saveas (h, filename, fmt = "pd
 
     if (isempty (ext))
       filename = strcat (filename, ".", fmt);
     endif
   endif
 
   prt_opt = strcat ("-d", tolower (fmt));
 
-  print (filename, prt_opt);
+  print (fig, filename, prt_opt);
 
 endfunction
diff --git a/scripts/plot/scatter.m b/scripts/plot/scatter.m
--- a/scripts/plot/scatter.m
+++ b/scripts/plot/scatter.m
@@ -14,17 +14,16 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} scatter (@var{x}, @var{y})
 ## @deftypefnx {Function File} {} scatter (@var{x}, @var{y}, @var{s})
-## @deftypefnx {Function File} {} scatter (@var{x}, @var{y}, @var{c})
 ## @deftypefnx {Function File} {} scatter (@var{x}, @var{y}, @var{s}, @var{c})
 ## @deftypefnx {Function File} {} scatter (@var{x}, @var{y}, @var{s}, @var{c}, @var{style})
 ## @deftypefnx {Function File} {} scatter (@var{x}, @var{y}, @var{s}, @var{c}, @var{prop}, @var{val})
 ## @deftypefnx {Function File} {} scatter (@dots{}, "filled")
 ## @deftypefnx {Function File} {} scatter (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} scatter (@dots{})
 ##
 ## Plot a scatter plot of the data.  A marker is plotted at each point
diff --git a/scripts/plot/shrinkfaces.m b/scripts/plot/shrinkfaces.m
--- a/scripts/plot/shrinkfaces.m
+++ b/scripts/plot/shrinkfaces.m
@@ -131,17 +131,17 @@ function [nf, nv] = shrinkfaces (varargi
   v = sqrt (sf) * (v - midpoints) + midpoints;
   f = reshape (1:sv, m, sv / m)';
   
   switch (nargout)
     case 0
       if (ishandle (p))
         ## avoid exceptions
         set (p, "FaceVertexCData", [], "CData", []);
-        set (p, "Vertices", v, "Faces", f, "FaceVertxCData", c);
+        set (p, "Vertices", v, "Faces", f, "FaceVertexCData", c);
       else
         nf = struct ("faces", f, "vertices", v, "facevertexcdata", c);
       endif
     case 1
       nf = struct ("faces", f, "vertices", v, "facevertexcdata", c);
     case 2
       nf = f;
       nv = v;
diff --git a/scripts/plot/subplot.m b/scripts/plot/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/subplot.m
@@ -201,17 +201,17 @@ function h = subplot (varargin)
             || strcmp (get (child, "tag"), "colorbar"))
           continue;
         endif
         if (align_axes)
           objpos = get (child, "position");
         else
           objpos = get (child, "outerposition");
         endif
-        if (all (objpos == pos) && ! replace_axes)
+        if (all (abs (objpos - pos) < eps) && ! replace_axes)
           ## If the new axes are in exactly the same position as an
           ## existing axes object, use the existing axes.
           found = true;
           tmp = child;
         else
           ## If the new axes overlap an old axes object, delete the old
           ## axes.
           x0 = pos(1);
diff --git a/scripts/plot/uigetdir.m b/scripts/plot/uigetdir.m
--- a/scripts/plot/uigetdir.m
+++ b/scripts/plot/uigetdir.m
@@ -18,32 +18,32 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{dirname} =} uigetdir ()
 ## @deftypefnx {Function File} {@var{dirname} =} uigetdir (@var{init_path})
 ## @deftypefnx {Function File} {@var{dirname} =} uigetdir (@var{init_path}, @var{dialog_name})
 ## Open a GUI dialog for selecting a directory.  If @var{init_path} is not
 ## given the current working directory is used.  @var{dialog_name} may be
 ## used to customize the dialog title.
-## @seealso{uigetfile}
+## @seealso{uigetfile, uiputfile}
 ## @end deftypefn
 
 ## Author: Kai Habel
 
 function dirname = uigetdir (init_path = pwd, dialog_name = "Select Directory to Open")
 
   defaulttoolkit = get (0, "defaultfigure__graphics_toolkit__");
   funcname = ["__uigetdir_", defaulttoolkit, "__"];
   functype = exist (funcname);
   if (! __is_function__ (funcname))
     funcname = "__uigetdir_fltk__";
     if (! __is_function__ (funcname))
       error ("uigetdir: fltk graphics toolkit required");
     elseif (! strcmp (defaulttoolkit, "gnuplot"))
-      warning ("uigetdir: no implementation for toolkit `%s', using `fltk' instead",
+      warning ("uigetdir: no implementation for toolkit '%s', using 'fltk' instead",
                defaulttoolkit);
     endif
   endif
 
   if (nargin > 2)
     print_usage ();
   endif
 
diff --git a/scripts/plot/uigetfile.m b/scripts/plot/uigetfile.m
--- a/scripts/plot/uigetfile.m
+++ b/scripts/plot/uigetfile.m
@@ -53,31 +53,32 @@
 ## @var{dialog_name} can be used to customize the dialog title.
 ## If @var{default_file} is given then it will be selected in the GUI dialog.
 ## If, in addition, a path is given it is also used as current path.
 ##
 ## The screen position of the GUI dialog can be set using the "Position" key
 ## and a 2-element vector containing the pixel coordinates.
 ## Two or more files can be selected when setting the "MultiSelect" key to "on".
 ## In that case @var{fname} is a cell array containing the files.
+## @seealso{uiputfile, uigetdir}
 ## @end deftypefn
 
 ## Author: Kai Habel
 
 function [retfile, retpath, retindex] = uigetfile (varargin)
 
   defaulttoolkit = get (0, "defaultfigure__graphics_toolkit__");
   funcname = ["__uigetfile_", defaulttoolkit, "__"];
   functype = exist (funcname);
   if (! __is_function__ (funcname))
     funcname = "__uigetfile_fltk__";
     if (! __is_function__ (funcname))
       error ("uigetfile: fltk graphics toolkit required");
     elseif (! strcmp (defaulttoolkit, "gnuplot"))
-      warning ("uigetfile: no implementation for toolkit `%s', using `fltk' instead",
+      warning ("uigetfile: no implementation for toolkit '%s', using 'fltk' instead",
                defaulttoolkit);
     endif
   endif
 
   if (nargin > 7)
     error ("uigetfile: number of input arguments must be less than eight");
   endif
 
diff --git a/scripts/plot/uiputfile.m b/scripts/plot/uiputfile.m
--- a/scripts/plot/uiputfile.m
+++ b/scripts/plot/uiputfile.m
@@ -44,31 +44,32 @@
 ##
 ## The filter string can also contain a semicolon separated list of filter
 ## extensions.
 ## Example: uiputfile (@{"*.gif;*.png;*.jpg", "Supported Picture Formats"@});
 ##
 ## @var{dialog_name} can be used to customize the dialog title.
 ## If @var{default_file} is given it is preselected in the GUI dialog.
 ## If, in addition, a path is given it is also used as current path.
+## @seealso{uigetfile, uigetdir}
 ## @end deftypefn
 
 ## Author: Kai Habel
 
 function [retfile, retpath, retindex] = uiputfile (varargin)
 
   defaulttoolkit = get (0, "defaultfigure__graphics_toolkit__");
   funcname = ["__uiputfile_", defaulttoolkit, "__"];
   functype = exist (funcname);
   if (! __is_function__ (funcname))
     funcname = "__uiputfile_fltk__";
     if (! __is_function__ (funcname))
       error ("uiputfile: fltk graphics toolkit required");
     elseif (! strcmp (defaulttoolkit, "gnuplot"))
-      warning ("uiputfile: no implementation for toolkit `%s', using `fltk' instead",
+      warning ("uiputfile: no implementation for toolkit '%s', using 'fltk' instead",
                defaulttoolkit);
     endif
   endif
 
   if (nargin > 3)
     print_usage ();
   endif
 
diff --git a/scripts/signal/stft.m b/scripts/signal/stft.m
--- a/scripts/signal/stft.m
+++ b/scripts/signal/stft.m
@@ -73,17 +73,17 @@ function [y, c] = stft (x, win_size, inc
     if (ischar (win_type))
       if (strcmp (win_type, "hanning"))
         win_type = 1;
       elseif (strcmp (win_type, "hamming"))
         win_type = 2;
       elseif (strcmp (win_type, "rectangle"))
         win_type = 3;
       else
-        error ("stft: unknown window type `%s'", win_type);
+        error ("stft: unknown window type '%s'", win_type);
       endif
     endif
   else
     print_usage ();
   endif
 
   ## Check whether X is a vector.
   [nr, nc] = size (x);
diff --git a/scripts/sparse/svds.m b/scripts/sparse/svds.m
--- a/scripts/sparse/svds.m
+++ b/scripts/sparse/svds.m
@@ -283,15 +283,15 @@ endfunction
 %!testif HAVE_ARPACK
 %! [u2,s2,v2,flag] = svds (zeros (10), k);
 %! assert (u2, eye (10, k));
 %! assert (s2, zeros (k));
 %! assert (v2, eye (10, 7));
 %!
 %!testif HAVE_ARPACK
 %! s = svds (speye (10));
-%! assert (s, ones (6, 1), 2*eps);
+%! assert (s, ones (6, 1), 4*eps);
 
 %!test
 %! ## Restore random number generator seeds at end of tests
 %! rand ("state", rand_state);
 %! randn ("state", randn_state);
 
diff --git a/scripts/specfun/perms.m b/scripts/specfun/perms.m
--- a/scripts/specfun/perms.m
+++ b/scripts/specfun/perms.m
@@ -33,42 +33,43 @@
 ##   1   3   2
 ##   2   3   1
 ##   3   1   2
 ##   3   2   1
 ## @end group
 ## @end example
 ## @end deftypefn
 
-function A = perms (v)
+function A = perms (w)
   if (nargin != 1)
     print_usage ();
   endif
-  v = v(:);
+  v = [1:length(w)]';
   n = length (v);
 
   if (n == 0)
-    A = [];
+    p = [];
   else
-    A = v(1);
+    p = v(1);
     for j = 2:n
-      B = A;
-      A = zeros (prod (2:j), n, class (v));
+      B = p;
+      p = zeros (prod (2:j), n);
       k = rows (B);
       idx = 1:k;
       for i = j:-1:1
-        A(idx,1:i-1) = B(:,1:i-1);
-        A(idx,i) = v(j);
-        A(idx,i+1:j) = B(:,i:j-1);
+        p(idx,1:i-1) = B(:,1:i-1);
+        p(idx,i) = v(j);
+        p(idx,i+1:j) = B(:,i:j-1);
         idx += k;
       endfor
     endfor
   endif
+  A = w(p);
 endfunction
 
 
 %!assert (perms ([1,2,3]), [1,2,3;2,1,3;1,3,2;2,3,1;3,1,2;3,2,1])
-%!assert (perms (1:3), perms ([1,2,3]))
+%!assert (perms ("abc"), ["abc"; "bac"; "acb"; "bca"; "cab"; "cba"])
 %!assert (perms (int8 ([1,2,3])), int8 ([1,2,3;2,1,3;1,3,2;2,3,1;3,1,2;3,2,1]))
 
 %!error perms ()
 %!error perms (1, 2)
 
diff --git a/scripts/statistics/base/mean.m b/scripts/statistics/base/mean.m
--- a/scripts/statistics/base/mean.m
+++ b/scripts/statistics/base/mean.m
@@ -108,34 +108,41 @@ function y = mean (x, opt1, opt2)
     endif
   endif
 
   n = sz(dim);
 
   if (strcmp (opt, "a"))
     y = sum (x, dim) / n;
   elseif (strcmp (opt, "g"))
-    y = prod (x, dim) .^ (1/n);
+    if (all (x(:) >= 0))
+      y = exp (sum (log (x), dim) ./ n);
+    else
+      error ("mean: X must not contain any negative values");
+    endif
   elseif (strcmp (opt, "h"))
     y = n ./ sum (1 ./ x, dim);
   else
-    error ("mean: option `%s' not recognized", opt);
+    error ("mean: option '%s' not recognized", opt);
   endif
 
 endfunction
 
 
 %!test
 %! x = -10:10;
 %! y = x';
 %! z = [y, y+10];
 %! assert (mean (x), 0);
 %! assert (mean (y), 0);
 %! assert (mean (z), [0, 10]);
 
+## Test small numbers
+%!assert (mean (repmat (0.1,1,1000), "g"), 0.1, 20*eps)
+
 %!assert (mean (magic (3), 1), [5, 5, 5])
 %!assert (mean (magic (3), 2), [5; 5; 5])
 %!assert (mean ([2 8], "g"), 4)
 %!assert (mean ([4 4 2], "h"), 3)
 %!assert (mean (logical ([1 0 1 1])), 0.75)
 %!assert (mean (single ([1 0 1 1])), single (0.75))
 
 %% Test input validation
diff --git a/scripts/statistics/tests/anova.m b/scripts/statistics/tests/anova.m
--- a/scripts/statistics/tests/anova.m
+++ b/scripts/statistics/tests/anova.m
@@ -45,24 +45,24 @@
 ## Description: One-way analysis of variance (ANOVA)
 
 function [pval, f, df_b, df_w] = anova (y, g)
 
   if ((nargin < 1) || (nargin > 2))
     print_usage ();
   elseif (nargin == 1)
     if (isvector (y))
-      error ("anova: for `anova (Y)', Y must not be a vector");
+      error ("anova: for 'anova (Y)', Y must not be a vector");
     endif
     [group_count, k] = size (y);
     n = group_count * k;
     group_mean = mean (y);
   else
     if (! isvector (y))
-      error ("anova: for `anova (Y, G)', Y must be a vector");
+      error ("anova: for 'anova (Y, G)', Y must be a vector");
     endif
     n = length (y);
     if (! isvector (g) || (length (g) != n))
       error ("anova: G must be a vector of the same length as Y");
     endif
     s = sort (g);
     i = find (s (2 : n) > s(1 : (n-1)));
     k = length (i) + 1;
diff --git a/scripts/statistics/tests/cor_test.m b/scripts/statistics/tests/cor_test.m
--- a/scripts/statistics/tests/cor_test.m
+++ b/scripts/statistics/tests/cor_test.m
@@ -108,27 +108,27 @@ function t = cor_test (x, y, alt, method
   elseif (m == "s")
     rho = spearman (x, y);
     t.method = "Spearman's rank correlation rho";
     t.params = [];
     t.stat = sqrt (n-1) * (rho - 6/(n^3-n));
     t.dist = "stdnormal";
     cdf = stdnormal_cdf (t.stat);
   else
-    error ("cor_test: METHOD `%s' not recognized", method);
+    error ("cor_test: METHOD '%s' not recognized", method);
   endif
 
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     t.pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
     t.pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     t.pval = cdf;
   else
-    error ("cor_test: alternative `%s' not recognized", alt);
+    error ("cor_test: alternative '%s' not recognized", alt);
   endif
 
   t.alternative = alt;
 
   if (nargout == 0)
     printf ("pval: %g\n", t.pval);
   endif
 
diff --git a/scripts/statistics/tests/t_test_regression.m b/scripts/statistics/tests/t_test_regression.m
--- a/scripts/statistics/tests/t_test_regression.m
+++ b/scripts/statistics/tests/t_test_regression.m
@@ -81,16 +81,16 @@ function [pval, t, df] = t_test_regressi
 
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
-    error ("t_test_regression: the value `%s' for alt is not possible", alt);
+    error ("t_test_regression: the value '%s' for alt is not possible", alt);
   endif
 
   if (nargout == 0)
     printf ("pval: %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/strings/strsplit.m b/scripts/strings/strsplit.m
--- a/scripts/strings/strsplit.m
+++ b/scripts/strings/strsplit.m
@@ -99,17 +99,17 @@ function cstr = strsplit (s, sep, strip_
   endif
 
 endfunction
 
 
 %!assert (strsplit ("road to hell", " "), {"road", "to", "hell"})
 %!assert (strsplit ("road to^hell", " ^"), {"road", "to", "hell"})
 %!assert (strsplit ("road   to--hell", " -", true), {"road", "to", "hell"})
-%!assert (strsplit (["a,bc";",de"], ","), {"a", "bc", ones(1,0), "de "})
+%!assert (strsplit (["a,bc";",de"], ","), {"a", "bc", char(ones(1,0)), "de "})
 %!assert (strsplit (["a,bc";",de"], ",", true), {"a", "bc", "de "})
 %!assert (strsplit (["a,bc";",de"], ", ", true), {"a", "bc", "de"})
 
 %% Test input validation
 %!error strsplit ()
 %!error strsplit ("abc")
 %!error strsplit ("abc", "b", true, 4)
 %!error <S and SEP must be string values> strsplit (123, "b")
diff --git a/scripts/testfun/demo.m b/scripts/testfun/demo.m
--- a/scripts/testfun/demo.m
+++ b/scripts/testfun/demo.m
@@ -96,17 +96,21 @@ function demo (name, n)
 
   if (nargin < 2)
     n = 0;
   elseif (ischar (n))
     n = str2double (n);
   endif
 
   [code, idx] = test (name, "grabdemo");
-  if (isempty (idx))
+
+  if (idx == -1)
+    warning ("no function %s found", name);
+    return;
+  elseif (isempty (idx))
     warning ("no demo available for %s", name);
     return;
   elseif (n >= length (idx))
     warning ("only %d demos available for %s", length (idx) - 1, name);
     return;
   endif
 
   if (n > 0)
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -166,17 +166,17 @@ function [__ret1, __ret2, __ret3, __ret4
       __file = "";
     else
       __file = __file{1};
     endif
   endif
   if (isempty (__file))
     if (__grabdemo)
       __ret1 = "";
-      __ret2 = [];
+      __ret2 = -1;
     else
       if (exist (__name) == 3)
         fprintf (__fid, "%s%s source code with tests for dynamically linked function not found\n", __signal_empty, __name);
       else
         fprintf (__fid, "%s%s does not exist in path\n", __signal_empty, __name);
       endif
       fflush (__fid);
       if (nargout > 0)
diff --git a/src/Makefile.am b/src/Makefile.am
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -17,75 +17,59 @@
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
 ## Search local directories before those specified by the user.
 AM_CPPFLAGS = \
-  -I$(srcdir)/../libinterp \
+  -I$(top_srcdir)/liboctave/array \
+  -I$(top_srcdir)/liboctave/cruft/misc \
+  -I$(top_srcdir)/liboctave/numeric \
+  -I$(top_srcdir)/liboctave/util \
+  -I$(top_srcdir)/libinterp \
+  -I$(top_builddir)/libinterp/interpfcn \
   -I$(top_builddir)/libgnu -I$(top_srcdir)/libgnu
 
-if AMCOND_BUILD_COMPILED_AUX_PROGRAMS
-bin_PROGRAMS = \
-  mkoctfile \
-  $(OCTAVE_PROGRAMS) \
-  octave-config
-
-mkoctfile_SOURCES =
-nodist_mkoctfile_SOURCES = mkoctfile.cc
-mkoctfile_LDADD = $(top_builddir)/libgnu/libgnu.la $(LIBS)
+AM_CFLAGS += $(WARN_CFLAGS)
 
-octave_config_SOURCES =
-nodist_octave_config_SOURCES = octave-config.cc
-octave_config_LDADD = \
-  corefcn/libcorefcn.la \
-	$(top_builddir)/libgnu/libgnu.la \
-	$(LIBS)
-
-BUILT_SOURCES_EXTRA = \
-  mkoctfile.cc \
-  octave-config.cc
-else
-bin_PROGRAMS = \
-  octave \
-  octave-cli
-
-bin_SCRIPTS = \
-  mkoctfile \
-  octave-config
-endif
+AM_CXXFLAGS += $(WARN_CXXFLAGS)
 
 EXTRA_DIST = \
   mkoctfile.in.cc \
   mkoctfile.in.sh \
   octave-config.in.cc \
   octave-config.in.sh
 
+DISTCLEANFILES =
+
+OCTAVE_BINARIES = \
+  octave \
+  octave-cli
+
 OCTAVE_CORE_LIBS = \
-  ../libinterp/liboctinterp.la \
-  ../liboctave/liboctave.la \
-  ../libcruft/libcruft.la
+  $(top_builddir)/libinterp/liboctinterp.la \
+  $(top_builddir)/liboctave/liboctave.la
 
-include ../libgui/src/link-deps.mk
+include ../libgui/link-deps.mk
 
 octave_cli_SOURCES = main-cli.cc
 
 octave_cli_LDADD = \
   $(OCTAVE_CORE_LIBS)
   $(OCTAVE_LINK_DEPS)
 
 octave_cli_LDFLAGS = \
   $(NO_UNDEFINED_LDFLAG) \
   $(OCTAVE_LINK_OPTS)
 
 if AMCOND_BUILD_GUI
   octave_SOURCES = main.cc
-  OCTAVE_GUI_LIBS = ../libgui/src/liboctgui.la
+  OCTAVE_GUI_LIBS = $(top_builddir)/libgui/liboctgui.la
   OCTAVE_GUI_CPPFLAGS = -I$(top_srcdir)/libgui/src
 else
   octave_SOURCES = main-cli.cc
   OCTAVE_GUI_LIBS =
   OCTAVE_GUI_CPPFLAGS =
 endif
 
 octave_CPPFLAGS = \
@@ -97,21 +81,50 @@ octave_LDADD = \
   $(OCTAVE_CORE_LIBS) \
   $(OCTAVE_GUI_LINK_DEPS)
 
 octave_LDFLAGS = \
   $(NO_UNDEFINED_LDFLAG) \
   $(OCTAVE_GUI_LINK_OPTS)
 
 if AMCOND_BUILD_COMPILED_AUX_PROGRAMS
+bin_PROGRAMS = \
+  $(OCTAVE_BINARIES) \
+  mkoctfile \
+  octave-config
+
+mkoctfile_SOURCES =
+nodist_mkoctfile_SOURCES = mkoctfile.cc
+mkoctfile_LDADD = $(top_builddir)/libgnu/libgnu.la $(LIBS)
+
+octave_config_SOURCES =
+nodist_octave_config_SOURCES = octave-config.cc
+octave_config_LDADD = \
+  $(top_builddir)/libinterp/corefcn/libcorefcn.la \
+  $(top_builddir)/libgnu/libgnu.la \
+  $(LIBS)
+
+DISTCLEANFILES += mkoctfile.cc octave-config.cc
+
+else
+bin_PROGRAMS = \
+  $(OCTAVE_BINARIES)
+
+bin_SCRIPTS = \
+  mkoctfile \
+  octave-config
+endif
+
+if AMCOND_BUILD_COMPILED_AUX_PROGRAMS
 octave-config.cc: octave-config.in.cc Makefile
 	@$(do_subst_default_vals)
 
 mkoctfile.cc: mkoctfile.in.cc Makefile
 	@$(do_subst_config_vals)
+
 else
 octave-config: octave-config.in.sh Makefile
 	@$(do_subst_default_vals)
 	chmod a+rx $@
 
 mkoctfile: mkoctfile.in.sh Makefile
 	@$(do_subst_config_vals)
 	chmod a+rx $@
diff --git a/src/main-cli.cc b/src/main-cli.cc
--- a/src/main-cli.cc
+++ b/src/main-cli.cc
@@ -19,19 +19,22 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <octave.h>
+#include "defaults.h"
+#include "octave.h"
 
 int
 main (int argc, char **argv)
 {
   octave_process_command_line (argc, argv);
 
+  install_defaults ();
+
   octave_initialize_interpreter (argc, argv, 0);
 
   return octave_execute_interpreter ();
 }
diff --git a/src/main.cc b/src/main.cc
--- a/src/main.cc
+++ b/src/main.cc
@@ -19,26 +19,29 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <octave.h>
-#include <octave-gui.h>
+#include "defaults.h"
+#include "octave.h"
+#include "octave-gui.h"
 
 int
 main (int argc, char **argv)
 {
   int retval = 0;
 
   octave_process_command_line (argc, argv);
 
+  install_defaults ();
+
   if (octave_starting_gui ())
     retval = octave_start_gui (argc, argv);
   else
     {
       octave_initialize_interpreter (argc, argv, 0);
 
       retval = octave_execute_interpreter ();
     }
diff --git a/src/mkoctfile.in.cc b/src/mkoctfile.in.cc
--- a/src/mkoctfile.in.cc
+++ b/src/mkoctfile.in.cc
@@ -20,16 +20,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #include <config.h>
 #endif
 
 #include <string>
+#include <cstring>
 #include <map>
 #include <list>
 #include <algorithm>
 #include <iostream>
 #include <fstream>
 #include <vector>
 #include <cstdlib>
 
@@ -43,41 +44,41 @@ along with Octave; see the file COPYING.
 
 using namespace std;
 
 static bool initialized = false;
 static map<string,string> vars;
 
 static string OCTAVE_VERSION = %OCTAVE_CONF_VERSION%;
 
-static std::string
-substitute_prefix (const std::string& s, const std::string& prefix,
-                   const std::string& new_prefix)
+static string
+substitute_prefix (const string& s, const string& prefix,
+                   const string& new_prefix)
 {
-  std::string retval = s;
+  string retval = s;
 
   if (!prefix.empty () && new_prefix != prefix)
     {
       int len = prefix.length ();
       if (retval.find (prefix) == 0)
         retval.replace (0, len, new_prefix);
     }
 
 #if defined (__WIN32__) && ! defined (_POSIX_VERSION)
-  std::replace (retval.begin (), retval.end (), '/', '\\');
+  replace (retval.begin (), retval.end (), '/', '\\');
 #endif
 
   return retval;
 }
 
 static string
 get_line (FILE *fp)
 {
   static vector<char> buf (100);
-  int idx = 0;
+  unsigned int idx = 0;
   char c;
 
   while (true)
     {
       c = static_cast<char> (fgetc (fp));
       if (c == '\n' || c == EOF)
         break;
       if (buf.size () <= idx)
@@ -118,17 +119,17 @@ initialize (void)
 
   initialized = true;
 
   vars["OCTAVE_HOME"] = get_variable ("OCTAVE_HOME", "");
 
 #if defined (__WIN32__) && ! defined (_POSIX_VERSION)
   int n = 1024;
 
-  std::string bin_dir (n, '\0');
+  string bin_dir (n, '\0');
 
   while (true)
     {
       int status = GetModuleFileName (0, &bin_dir[0], n);
 
       if (status < n)
         {
           bin_dir.resize (status);
@@ -149,20 +150,20 @@ initialize (void)
         vars["OCTAVE_HOME"] = bin_dir.substr (0, pos);
     }
 #endif
 
   vars["SED"] = get_variable ("SED", %OCTAVE_CONF_SED%);
 
   vars["OCTAVE_PREFIX"] = %OCTAVE_CONF_PREFIX%;
 
-  std::string DEFAULT_OCTINCLUDEDIR = %OCTAVE_CONF_OCTINCLUDEDIR%;
-  std::string DEFAULT_INCLUDEDIR = %OCTAVE_CONF_INCLUDEDIR%;
-  std::string DEFAULT_LIBDIR = %OCTAVE_CONF_LIBDIR%;
-  std::string DEFAULT_OCTLIBDIR = %OCTAVE_CONF_OCTLIBDIR%;
+  string DEFAULT_OCTINCLUDEDIR = %OCTAVE_CONF_OCTINCLUDEDIR%;
+  string DEFAULT_INCLUDEDIR = %OCTAVE_CONF_INCLUDEDIR%;
+  string DEFAULT_LIBDIR = %OCTAVE_CONF_LIBDIR%;
+  string DEFAULT_OCTLIBDIR = %OCTAVE_CONF_OCTLIBDIR%;
 
   if (! vars["OCTAVE_HOME"].empty ())
     {
       DEFAULT_OCTINCLUDEDIR
         = substitute_prefix (DEFAULT_OCTINCLUDEDIR, vars["OCTAVE_PREFIX"],
                              vars["OCTAVE_HOME"]);
 
       DEFAULT_INCLUDEDIR
@@ -179,28 +180,28 @@ initialize (void)
     }
 
   vars["OCTINCLUDEDIR"] = get_variable ("OCTINCLUDEDIR", DEFAULT_OCTINCLUDEDIR);
   vars["INCLUDEDIR"] = get_variable ("INCLUDEDIR", DEFAULT_INCLUDEDIR);
   vars["LIBDIR"] = get_variable ("LIBDIR", DEFAULT_LIBDIR);
   vars["OCTLIBDIR"] = get_variable ("OCTLIBDIR", DEFAULT_OCTLIBDIR);
 
 #if defined (__WIN32__) && ! defined (_POSIX_VERSION)
-  std::string DEFAULT_INCFLAGS
+  string DEFAULT_INCFLAGS
     = "-I" + quote_path (vars["OCTINCLUDEDIR"] + "\\..")
     + " -I" + quote_path (vars["OCTINCLUDEDIR"]);
 #else
-  std::string DEFAULT_INCFLAGS
+  string DEFAULT_INCFLAGS
     = "-I" + quote_path (vars["OCTINCLUDEDIR"] + "/..")
     + " -I" + quote_path (vars["OCTINCLUDEDIR"]);
 #endif
   if (vars["INCLUDEDIR"] != "/usr/include")
     DEFAULT_INCFLAGS += " -I" + quote_path (vars["INCLUDEDIR"]);
 
-  std::string DEFAULT_LFLAGS = "-L" + quote_path (vars["OCTLIBDIR"]);
+  string DEFAULT_LFLAGS = "-L" + quote_path (vars["OCTLIBDIR"]);
   if (vars["LIBDIR"] != "/usr/lib")
     DEFAULT_LFLAGS += " -L" + quote_path (vars["LIBDIR"]);
 
   vars["CPPFLAGS"] = get_variable ("CPPFLAGS", %OCTAVE_CONF_CPPFLAGS%);
   vars["INCFLAGS"] = get_variable ("INCFLAGS", DEFAULT_INCFLAGS);
   vars["F77"] = get_variable ("F77", %OCTAVE_CONF_F77%);
   vars["FFLAGS"] = get_variable ("FFLAGS", %OCTAVE_CONF_FFLAGS%);
   vars["FPICFLAG"] = get_variable ("FPICFLAG", %OCTAVE_CONF_FPICFLAG%);
@@ -218,17 +219,16 @@ initialize (void)
 
   vars["DL_LD"] = get_variable ("DL_LD", %OCTAVE_CONF_DL_LD%);
   vars["DL_LDFLAGS"] = get_variable ("DL_LDFLAGS", %OCTAVE_CONF_MKOCTFILE_DL_LDFLAGS%);
 
   vars["RDYNAMIC_FLAG"] = get_variable ("RDYNAMIC_FLAG", %OCTAVE_CONF_RDYNAMIC_FLAG%);
   vars["LIBOCTAVE"] = "-loctave";
   vars["LIBOCTINTERP"] = "-loctinterp";
   vars["READLINE_LIBS"] = "-lreadline";
-  vars["LIBCRUFT"] = "-lcruft";
   vars["LAPACK_LIBS"] = get_variable ("LAPACK_LIBS", %OCTAVE_CONF_LAPACK_LIBS%);
   vars["BLAS_LIBS"] = get_variable ("BLAS_LIBS", %OCTAVE_CONF_BLAS_LIBS%);
   vars["FFTW3_LDFLAGS"] = get_variable ("FFTW3_LDFLAGS", %OCTAVE_CONF_FFTW3_LDFLAGS%);
   vars["FFTW3_LIBS"] = get_variable ("FFTW3_LIBS", %OCTAVE_CONF_FFTW3_LIBS%);
   vars["FFTW3F_LDFLAGS"] = get_variable ("FFTW3F_LDFLAGS", %OCTAVE_CONF_FFTW3F_LDFLAGS%);
   vars["FFTW3F_LIBS"] = get_variable ("FFTW3F_LIBS", %OCTAVE_CONF_FFTW3F_LIBS%);
   vars["LIBS"] = get_variable ("LIBS", %OCTAVE_CONF_LIBS%);
   vars["FLIBS"] = get_variable ("FLIBS", %OCTAVE_CONF_FLIBS%);
@@ -249,17 +249,17 @@ initialize (void)
 
   vars["ALL_CXXFLAGS"] = vars["INCFLAGS"] + " " + vars["XTRA_CXXFLAGS"]
     + " " + vars["CXXFLAGS"];
 
   vars["ALL_LDFLAGS"] = vars["LD_STATIC_FLAG"] + " " + vars["CPICFLAG"]
     + " " + vars["LDFLAGS"];
 
   vars["OCTAVE_LIBS"] = vars["LIBOCTINTERP"] + " " + vars["LIBOCTAVE"]
-    + " " + vars["SPECIAL_MATH_LIB"] + " " + vars["LIBCRUFT"];
+    + " " + vars["SPECIAL_MATH_LIB"];
 
   vars["FFTW_LIBS"] = vars["FFTW3_LDFLAGS"] + " " + vars["FFTW3_LIBS"]
     + " " + vars["FFTW3F_LDFLAGS"] + " " + vars["FFTW3F_LIBS"];
 }
 
 static string usage_msg = "usage: mkoctfile [options] file ...";
 static string version_msg = "mkoctfile, version " + OCTAVE_VERSION;
 static bool debug = false;
@@ -302,30 +302,30 @@ static string help_msg =
 "                            ALL_CFLAGS                FLIBS\n"
 "                            ALL_CXXFLAGS              FPICFLAG\n"
 "                            ALL_FFLAGS                INCFLAGS\n"
 "                            ALL_LDFLAGS               LAPACK_LIBS\n"
 "                            BLAS_LIBS                 LDFLAGS\n"
 "                            CC                        LD_CXX\n"
 "                            CFLAGS                    LD_STATIC_FLAG\n"
 "                            CPICFLAG                  LFLAGS\n"
-"                            CPPFLAGS                  LIBCRUFT\n"
-"                            CXX                       LIBOCTAVE\n"
-"                            CXXFLAGS                  LIBOCTINTERP\n"
-"                            CXXPICFLAG                LIBS\n"
-"                            DEPEND_EXTRA_SED_PATTERN  OCTAVE_LIBS\n"
-"                            DEPEND_FLAGS              OCTAVE_LINK_DEPS\n"
-"                            DL_LD                     OCTAVE_LINK_OPTS\n"
-"                            DL_LDFLAGS                OCT_LINK_DEPS\n"
-"                            EXEEXT                    OCT_LINK_OPTS\n"
-"                            F77                       RDYNAMIC_FLAG\n"
-"                            F77_INTEGER_8_FLAG        READLINE_LIBS\n"
-"                            FFLAGS                    SED\n"
-"                            FFTW3_LDFLAGS             XTRA_CFLAGS\n"
-"                            FFTW3_LIBS                XTRA_CXXFLAGS\n"
+"                            CPPFLAGS                  LIBOCTAVE\n"       
+"                            CXX                       LIBOCTINTERP\n"    
+"                            CXXFLAGS                  LIBS\n"            
+"                            CXXPICFLAG                OCTAVE_LIBS\n"     
+"                            DEPEND_EXTRA_SED_PATTERN  OCTAVE_LINK_DEPS\n"
+"                            DEPEND_FLAGS              OCTAVE_LINK_OPTS\n"
+"                            DL_LD                     OCT_LINK_DEPS\n"   
+"                            DL_LDFLAGS                OCT_LINK_OPTS\n"   
+"                            EXEEXT                    RDYNAMIC_FLAG\n"   
+"                            F77                       READLINE_LIBS\n"   
+"                            F77_INTEGER_8_FLAG        SED\n"             
+"                            FFLAGS                    XTRA_CFLAGS\n"     
+"                            FFTW3_LDFLAGS             XTRA_CXXFLAGS\n"   
+"                            FFTW3_LIBS\n"      
 "                            FFTW3F_LDFLAGS\n"
 "                            FFTW3F_LIBS\n"
 "\n"
 "  --link-stand-alone      Link a stand-alone executable file.\n"
 "\n"
 "  --mex                   Assume we are creating a MEX file.  Set the\n"
 "                          default output extension to \".mex\".\n"
 "\n"
@@ -348,31 +348,33 @@ static string help_msg =
 #ifdef _MSC_VER
 "                            .lib  library file\n"
 #endif
 "\n";
 
 static string
 basename (const string& s, bool strip_path = false)
 {
+  string retval;
   size_t pos = s.rfind ('.');
-  string retval;
 
   if (pos == string::npos)
     retval = s;
   else
     retval = s.substr (0, pos);
+
   if (strip_path)
     {
       size_t p1 = retval.rfind ('/'), p2 = retval.rfind ('\\');
       pos = (p1 != string::npos && p2 != string::npos
              ? max (p1, p2) : (p2 != string::npos ? p2 : p1));
       if (pos != string::npos)
-        retval = retval.substr (0, pos);
+        retval = retval.substr (++pos, string::npos);
     }
+
   return retval;
 }
 
 inline bool
 starts_with (const string& s, const string& prefix)
 {
   return (s.length () >= prefix.length () && s.find (prefix) == 0);
 }
@@ -429,17 +431,16 @@ main (int argc, char **argv)
     {
       cout << version_msg << endl;
       return 0;
     }
 
   for (int i = 1; i < argc; i++)
     {
       string arg = argv[i];
-      size_t len = arg.length ();
 
       if (ends_with (arg, ".c"))
         {
           file = arg;
           cfiles.push_back (file);
         }
       else if (ends_with (arg, ".cc") || ends_with (arg, ".C")
                || ends_with (arg, ".cpp"))
@@ -601,23 +602,23 @@ main (int argc, char **argv)
 
           unlink (dfile.c_str ());
           string cmd = vars["CC"] + " " + vars["DEPEND_FLAGS"] + " "
             + vars["CPPFLAGS"] + " " + vars["ALL_CFLAGS"] + " "
             + incflags  + " " + defs + " " + quote_path (f);
 
           FILE *fd = popen (cmd.c_str (), "r");
           ofstream fo (dfile.c_str ());
-          int pos;
+          size_t pos;
           while (!feof (fd))
             {
               line = get_line (fd);
               if ((pos = line.rfind (".o:")) != string::npos)
                 {
-                  int spos = line.rfind ('/', pos);
+                  size_t spos = line.rfind ('/', pos);
                   string ofile = (spos == string::npos ? line.substr (0, pos+2) : line.substr (spos+1, pos-spos+1));
                   fo << "pic/" << ofile << " " << ofile << " " << dfile << line.substr (pos) << endl;
                 }
               else
                 fo << line << endl;
             }
           pclose (fd);
           fo.close ();
@@ -629,23 +630,23 @@ main (int argc, char **argv)
 
           unlink (dfile.c_str ());
           string cmd = vars["CC"] + " " + vars["DEPEND_FLAGS"] + " "
             + vars["CPPFLAGS"] + " " + vars["ALL_CXXFLAGS"] + " "
             + incflags  + " " + defs + " " + quote_path (f);
 
           FILE *fd = popen (cmd.c_str (), "r");
           ofstream fo (dfile.c_str ());
-          int pos;
+          size_t pos;
           while (!feof (fd))
             {
               line = get_line (fd);
               if ((pos = line.rfind (".o:")) != string::npos)
                 {
-                  int spos = line.rfind ('/', pos);
+                  size_t spos = line.rfind ('/', pos);
                   string ofile = (spos == string::npos ? line.substr (0, pos+2) : line.substr (spos+1, pos-spos+1));
                   fo << "pic/" << ofile << " " << ofile << " " << dfile << line.substr (pos+2) << endl;
                 }
               else
                 fo << line << endl;
             }
           pclose (fd);
           fo.close ();
@@ -746,34 +747,34 @@ main (int argc, char **argv)
         {
           if (!vars["LD_CXX"].empty ())
             {
               string cmd = vars["LD_CXX"] + " " + vars["CPPFLAGS"] + " "
                 + vars["ALL_CXXFLAGS"] + " " + vars["RDYNAMIC_FLAG"]
                 + " " + vars["ALL_LDFLAGS"] + " " +  pass_on_options
                 + " " + output_option + " " + objfiles + " " + libfiles
                 + " " + ldflags + " " + vars["LFLAGS"]
-                + " -loctinterp -loctave -lcruft "
+                + " -loctinterp -loctave "
                 + " " + vars["OCT_LINK_OPTS"]
                 + " " + vars["OCTAVE_LINK_DEPS"];
               result = run_command (cmd);
             }
           else
             {
               cerr << "mkoctfile: no way to link stand-alone executable file"
                    << endl;
               return 1;
             }
         }
       else
         {
           string cmd = vars["DL_LD"] + " " + vars["DL_LDFLAGS"] + " "
             + pass_on_options + " -o " + octfile + " " + objfiles + " "
             + libfiles + " " + ldflags + " " + vars["LFLAGS"]
-            + " -loctinterp -loctave -lcruft "
+            + " -loctinterp -loctave "
             + vars["OCT_LINK_OPTS"] + " " + vars["OCT_LINK_DEPS"];
           result = run_command (cmd);
         }
 
       if (strip)
         {
           string cmd = "strip " + octfile;
           result = run_command (cmd);
diff --git a/src/mkoctfile.in.sh b/src/mkoctfile.in.sh
--- a/src/mkoctfile.in.sh
+++ b/src/mkoctfile.in.sh
@@ -84,17 +84,16 @@ fi
 
 : ${DL_LD=%OCTAVE_CONF_DL_LD%}
 : ${DL_LDFLAGS=%OCTAVE_CONF_MKOCTFILE_DL_LDFLAGS%}
 
 : ${RDYNAMIC_FLAG=%OCTAVE_CONF_RDYNAMIC_FLAG%}
 : ${LIBOCTAVE=-loctave}
 : ${LIBOCTINTERP=-loctinterp}
 : ${READLINE_LIBS=-lreadline}
-: ${LIBCRUFT=-lcruft}
 : ${LAPACK_LIBS=%OCTAVE_CONF_LAPACK_LIBS%}
 : ${BLAS_LIBS=%OCTAVE_CONF_BLAS_LIBS%}
 : ${FFTW3_LDFLAGS=%OCTAVE_CONF_FFTW3_LDFLAGS%}
 : ${FFTW3_LIBS=%OCTAVE_CONF_FFTW3_LIBS%}
 : ${FFTW3F_LDFLAGS=%OCTAVE_CONF_FFTW3F_LDFLAGS%}
 : ${FFTW3F_LIBS=%OCTAVE_CONF_FFTW3F_LIBS%}
 : ${LIBS=%OCTAVE_CONF_LIBS%}
 : ${FLIBS=%OCTAVE_CONF_FLIBS%}
@@ -111,17 +110,17 @@ fi
 : ${ALL_FFLAGS="$FFLAGS $F77_INTEGER_8_FLAG"}
 
 : ${ALL_CFLAGS="$INCFLAGS $XTRA_CFLAGS $CFLAGS"}
 
 : ${ALL_CXXFLAGS="$INCFLAGS $XTRA_CXXFLAGS $CXXFLAGS"}
 
 : ${ALL_LDFLAGS="$LD_STATIC_FLAG $CPICFLAG $LDFLAGS"}
 
-: ${OCTAVE_LIBS="$LIBOCTINTERP $LIBOCTAVE $SPECIAL_MATH_LIB $LIBCRUFT"}
+: ${OCTAVE_LIBS="$LIBOCTINTERP $LIBOCTAVE $SPECIAL_MATH_LIB"}
 
 # Local variables.
 
 FFTW_LIBS="$FFTW3_LDFLAGS $FFTW3_LIBS $FFTW3F_LDFLAGS $FFTW3F_LIBS"
 
 usage_msg="usage: mkoctfile [options] file ..."
 
 version_msg="mkoctfile, version $OCTAVE_VERSION"
@@ -238,28 +237,28 @@ Options:
                             ALL_CXXFLAGS              FLIBS
                             ALL_FFLAGS                FPICFLAG
                             ALL_LDFLAGS               INCFLAGS
                             BLAS_LIBS                 LAPACK_LIBS
                             CC                        LDFLAGS
                             CFLAGS                    LD_CXX
                             CPICFLAG                  LD_STATIC_FLAG
                             CPPFLAGS                  LFLAGS
-                            CXX                       LIBCRUFT
-                            CXXFLAGS                  LIBOCTAVE
-                            CXXPICFLAG                LIBOCTINTERP
-                            DEPEND_EXTRA_SED_PATTERN  LIBS
-                            DEPEND_FLAGS              OCTAVE_LIBS
-                            DL_LD                     OCTAVE_LINK_DEPS
-                            DL_LDFLAGS                OCT_LINK_DEPS
-                            EXEEXT                    RDYNAMIC_FLAG
-                            F77                       READLINE_LIBS
-                            F77_INTEGER_8_FLAG        SED
-                            FFLAGS                    XTRA_CFLAGS
-                            FFTW3_LDFLAGS             XTRA_CXXFLAGS
+                            CXX                       LIBOCTAVE       
+                            CXXFLAGS                  LIBOCTINTERP    
+                            CXXPICFLAG                LIBS            
+                            DEPEND_EXTRA_SED_PATTERN  OCTAVE_LIBS     
+                            DEPEND_FLAGS              OCTAVE_LINK_DEPS
+                            DL_LD                     OCT_LINK_DEPS   
+                            DL_LDFLAGS                RDYNAMIC_FLAG   
+                            EXEEXT                    READLINE_LIBS   
+                            F77                       SED             
+                            F77_INTEGER_8_FLAG        XTRA_CFLAGS     
+                            FFLAGS                    XTRA_CXXFLAGS   
+                            FFTW3_LDFLAGS             
                             FFTW3_LIBS
                             FFTW3F_LDFLAGS
 
   -v, --verbose           Echo commands as they are executed.
 
   FILE                    Compile or link FILE.  Recognized file types are:
 
                             .c    C source
@@ -528,25 +527,25 @@ fi
 ##   eval $cmd
 ## fi
 
 # Link all the object files.
 
 if $link && [ -n "$objfiles" ]; then
   if $link_stand_alone; then
     if [ -n "$LD_CXX" ]; then
-      cmd="$LD_CXX $CPPFLAGS $ALL_CXXFLAGS $RDYNAMIC_FLAG $ALL_LDFLAGS $pass_on_options $output_option $objfiles $libfiles $ldflags $LFLAGS -loctinterp -loctave -lcruft $OCTAVE_LINK_OPTS $OCTAVE_LINK_DEPS"
+      cmd="$LD_CXX $CPPFLAGS $ALL_CXXFLAGS $RDYNAMIC_FLAG $ALL_LDFLAGS $pass_on_options $output_option $objfiles $libfiles $ldflags $LFLAGS -loctinterp -loctave $OCTAVE_LINK_OPTS $OCTAVE_LINK_DEPS"
       $dbg $cmd
       eval $cmd
     else
       echo "mkoctfile: no way to link stand-alone executable file" 1>&2
       exit 1
     fi
   else
-    cmd="$DL_LD $DL_LDFLAGS $pass_on_options -o $octfile $objfiles $libfiles $ldflags $LFLAGS -loctinterp -loctave -lcruft $OCT_LINK_OPTS $OCT_LINK_DEPS"
+    cmd="$DL_LD $DL_LDFLAGS $pass_on_options -o $octfile $objfiles $libfiles $ldflags $LFLAGS -loctinterp -loctave $OCT_LINK_OPTS $OCT_LINK_DEPS"
     $dbg $cmd
     eval $cmd
   fi
 
 # Maybe strip it.
 
   if $strip; then
     cmd="strip $octfile"
diff --git a/test/Makefile.am b/test/Makefile.am
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -1,9 +1,9 @@
-# Makefile for octave's test directory
+# Makefile for Octave's test directory
 #
 # Copyright (C) 1994-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
diff --git a/test/nest/module.mk b/test/nest/module.mk
--- a/test/nest/module.mk
+++ b/test/nest/module.mk
@@ -1,11 +1,12 @@
 nest_FCN_FILES = \
   nest/arg_nest.m \
   nest/arg_ret.m \
+  nest/nest_eval.m \
   nest/no_closure.m \
   nest/persistent_nest.m \
   nest/recursive_nest.m \
   nest/recursive_nest2.m \
   nest/recursive_nest3.m \
   nest/scope0.m \
   nest/scope1.m \
   nest/scope2.m \
diff --git a/test/nest/nest_eval.m b/test/nest/nest_eval.m
new file mode 100644
--- /dev/null
+++ b/test/nest/nest_eval.m
@@ -0,0 +1,8 @@
+function x = nest_eval (a, b)
+  eval (a);
+  nested ();
+
+  function nested ()
+    eval (b);
+  endfunction
+endfunction
diff --git a/test/nest/test_nest.m b/test/nest/test_nest.m
--- a/test/nest/test_nest.m
+++ b/test/nest/test_nest.m
@@ -42,12 +42,17 @@
 %! scope0;
 
 %!test
 %! scope1 (1);
 
 %!test
 %! scope3;
 
+%!assert (nest_eval ("x = 5;", "x = 6;"), 6);
+%!assert (nest_eval ("x = 5;", "y = 6;"), 5);
+%!assert (nest_eval ("x = -5; x = abs (x);", "y = 6;"), 5);
+
 %!error <D' undefined near line 7> scope2
 %!error <handles to nested functions are not yet supported> no_closure (0)
 %!error <handles to nested functions are not yet supported> no_closure (1)
-
+%!error <can not add variable "y" to a static workspace> nest_eval ("y = 5;", "")
+%!error <can not add variable "y" to a static workspace> nest_eval ("y;", "")
diff --git a/test/test_eval-catch.m b/test/test_eval-catch.m
--- a/test/test_eval-catch.m
+++ b/test/test_eval-catch.m
@@ -27,47 +27,47 @@
 %% test/octave.test/eval-catch/eval-catch-3.m
 %!test
 %! eval ("clear a; a; x = 0;", "x = 1;");
 %! assert (x, 1);
 
 %% test/octave.test/eval-catch/eval-catch-5.m
 %!test
 %! eval ("clear a; a; str = '';", "str=lasterr;");
-%! assert (lasterr()(1:13), "`a' undefined");
-%! assert (str(1:13), "`a' undefined");
+%! assert (lasterr()(1:13), "'a' undefined");
+%! assert (str(1:13), "'a' undefined");
 
 %% test/octave.test/eval-catch/eval-catch-6.m
 %!test
 %! eval ("error ('user-defined error'); str = '';", "str = lasterr;");
 %! assert (lasterr()(1:18), "user-defined error");
 %! assert (str(1:18), "user-defined error");
 
 %% test/octave.test/eval-catch/eval-catch-7.m
 %!function ms = mangle (s)
 %!  ## Wrap angle brackets around S.
 %!  ms = cstrcat ("<", s, ">");
 %!endfunction
 %!test
 %! eval ("clear a; a; str='';", "str = mangle (lasterr);");
-%! assert (mangle(lasterr)(1:14), "<`a' undefined");
-%! assert (str(1:14), "<`a' undefined");
+%! assert (mangle(lasterr)(1:14), "<'a' undefined");
+%! assert (str(1:14), "<'a' undefined");
 
 %% test/octave.test/eval-catch/eval-catch-8.m
 %!test
 %! eval ("eval (\"clear a; a;str1='';\", \"str1=lasterr;\"); clear b; b; str2='';",
 %! "str2 = lasterr;");
-%! assert (str1(1:13), "`a' undefined");
-%! assert (str2(1:13), "`b' undefined");
+%! assert (str1(1:13), "'a' undefined");
+%! assert (str2(1:13), "'b' undefined");
 
 %% test/octave.test/eval-catch/eval-catch-9.m
 %!test
 %! eval ("clear a; a; str1='';",
 %! "eval (\"clear b; b; str2='';\", \"str2=lasterr;\"); str1=lasterr;");
-%! assert (str1(1:13), "`b' undefined");
-%! assert (str2(1:13), "`b' undefined");
+%! assert (str1(1:13), "'b' undefined");
+%! assert (str2(1:13), "'b' undefined");
 
 %% test/octave.test/eval-catch/eval-catch-10.m
 %!test
 %! eval ("eval (\"clear a; a; str='';\",\"error (cstrcat (\\\"rethrow: \\\", lasterr));str='';\");",
 %! "str=lasterr;");
-%! assert (str(1:22), "rethrow: `a' undefined");
+%! assert (str(1:22), "rethrow: 'a' undefined");
 
diff --git a/test/test_try.m b/test/test_try.m
--- a/test/test_try.m
+++ b/test/test_try.m
@@ -58,19 +58,19 @@
 
 %% test/octave.test/try/try-5.m
 %!test
 %! try
 %!   clear a;
 %!   a;
 %!   error ("Shoudn't get here");
 %! catch
-%!   assert (lasterr()(1:13), "`a' undefined");
+%!   assert (lasterr()(1:13), "'a' undefined");
 %! end_try_catch
-%! assert (lasterr()(1:13), "`a' undefined");
+%! assert (lasterr()(1:13), "'a' undefined");
 
 %% test/octave.test/try/try-6.m
 %!test 
 %! try
 %!   error ("user-defined error");
 %! catch
 %!   assert (lasterr, "user-defined error");
 %! end_try_catch
@@ -81,59 +81,59 @@
 %!  ms = cstrcat ("<", s, ">");
 %!endfunction
 %!test
 %! try
 %!   clear a;
 %!   a;
 %!   error ("Shoudn't get here");
 %! catch
-%!   assert (mangle (lasterr)(1:14), "<`a' undefined");
+%!   assert (mangle (lasterr)(1:14), "<'a' undefined");
 %! end_try_catch
 
 %% test/octave.test/try/try-8.m
 %!test
 %! try
 %!   try
 %!     clear a;
 %!     a;
 %!     error ("Shoudn't get here");
 %!   catch
-%!     assert (lasterr()(1:13), "`a' undefined");
+%!     assert (lasterr()(1:13), "'a' undefined");
 %!   end_try_catch
 %!   clear b;
 %!   b;
 %!   error ("Shoudn't get here");
 %! catch
-%!   assert (lasterr()(1:13), "`b' undefined");
+%!   assert (lasterr()(1:13), "'b' undefined");
 %! end_try_catch
 
 %% test/octave.test/try/try-9.m
 %!test
 %! try
 %!   clear a;
 %!   a;
 %!   error ("Shoudn't get here");
 %! catch
 %!   try
-%!     assert (lasterr()(1:13), "`a' undefined");
+%!     assert (lasterr()(1:13), "'a' undefined");
 %!     clear b;
 %!     b;
 %!     error ("Shoudn't get here");
 %!   catch
-%!     assert (lasterr()(1:13), "`b' undefined");
+%!     assert (lasterr()(1:13), "'b' undefined");
 %!   end_try_catch
 %! end_try_catch
 
 %% test/octave.test/try/try-10.m
 %!test
 %! try
 %!   try
 %!     clear a;
 %!     a;
 %!     error ("Shoudn't get here");
 %!   catch
 %!     error (cstrcat ("rethrow: ", lasterr));
 %!   end_try_catch
 %! catch
-%!   assert (lasterr()(1:22), "rethrow: `a' undefined");
+%!   assert (lasterr()(1:22), "rethrow: 'a' undefined");
 %! end_try_catch
 
