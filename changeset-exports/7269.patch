# HG changeset patch
# User jwe
# Date 1197055581 0
#      Fri Dec 07 19:26:21 2007 +0000
# Node ID 3fade00a6ac775ba94fa103bbda02537a9d356b5
# Parent  47e4ebac1bfa7c4ef221af4e1053c27e2a084a36
[project @ 2007-12-07 19:26:20 by jwe]

diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -7632,34 +7632,40 @@ SparseComplexMatrix
 SparseComplexMatrix::cumsum (int dim) const
 {
   SPARSE_CUMSUM (SparseComplexMatrix, Complex, cumsum);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::prod (int dim) const
 {
-  SPARSE_REDUCTION_OP (SparseComplexMatrix, Complex, *=, 1.0, 1.0);
+  if ((rows() == 1 && dim == -1) || dim == 1)
+    return transpose (). prod (0). transpose();
+  else
+    {
+      SPARSE_REDUCTION_OP (SparseComplexMatrix, Complex, *=, 
+			   (cidx(j+1) - cidx(j) < nc ? 0.0 : 1.0), 1.0);
+    }
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::sum (int dim) const
 {
   SPARSE_REDUCTION_OP (SparseComplexMatrix, Complex, +=, 0.0, 0.0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::sumsq (int dim) const
 {
 #define ROW_EXPR \
-  Complex d = elem (i, j); \
-  tmp [i] += d * conj (d)
+  Complex d = data (i); \
+  tmp [ridx(i)] += d * conj (d)
 
 #define COL_EXPR \
-  Complex d = elem (i, j); \
+  Complex d = data (i); \
   tmp [j] += d * conj (d)
 
   SPARSE_BASE_REDUCTION_OP (SparseComplexMatrix, Complex, ROW_EXPR, 
 			    COL_EXPR, 0.0, 0.0);
 
 #undef ROW_EXPR
 #undef COL_EXPR
 }
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,28 @@
+2007-12-07  David Bateman  <dbateman@free.fr>
+
+	* Sparse-op-defs.h (SPARSE_SMS_CMP_OP, SPARSE_SMS_BOOL_OP,
+	SPARSE_SSM_CMP_OP, SPARSE_SSM_BOOL_OP, SPARSE_SMSM_CMP_OP, 
+	SPARSE_SMSM_BOOL_OP, SPARSE_BASE_REDUCTION_OP): Use sparse
+	indexing where possible rather than the elem method.
+	(SPARSE_REDUCTION_OP_ROW_EXPR, SPARSE_REDUCTION_OP_COL_EXPR,
+	SPARSE_ANY_ALL_OP_ROW_CODE, SPARSE_ANY_ALL_OP_COL_CODE):
+	Replace for new version of SPARSE_BASE_REDUCTION_OP.
+	(SPARSE_ALL_OP): Specialize the initial value, and only treat dim
+	= 0 directly.
+	* CSparse.cc (SparseComplexMatrix SparseComplexMatrix::sumsq (int)
+	const): Replace ROW_EXPR and COL_EXPR functions for new version of
+	SPARSE_BASE_REDUCTION_OP.
+	(SparseComplexMatrix SparseComplexMatrix::prod (int) const):
+	Specialize the initial value, and only treat dim = 0 directly.
+	* dSparse.cc (SparseMatrix SparseMatrix::sumsq (int) const):
+	ditto.
+	(SparseMatrix SparseMatrix::prod (int) const): ditto.
+
 2007-12-06  John W. Eaton  <jwe@octave.org>
 
 	* CMatrix.cc (ComplexMatrix::expm): Update pointers to internal
 	data for npp and dpp after assignments.
 	* dMatrix.cc (Matrix::expm): Use same method as ComplexMatrix::expm.
 
 2007-12-04  John W. Eaton  <jwe@octave.org>
 
diff --git a/liboctave/Sparse-op-defs.h b/liboctave/Sparse-op-defs.h
--- a/liboctave/Sparse-op-defs.h
+++ b/liboctave/Sparse-op-defs.h
@@ -98,68 +98,46 @@ along with Octave; see the file COPYING.
 #define SPARSE_SMS_EQNE_OP_DECLS(M, S, API) \
   SPARSE_CMP_OP_DECL (mx_el_eq, M, S, API); \
   SPARSE_CMP_OP_DECL (mx_el_ne, M, S, API);
 
 #define SPARSE_SMS_CMP_OP(F, OP, M, MZ, MC, S, SZ, SC)	\
   SparseBoolMatrix \
   F (const M& m, const S& s) \
   { \
-    /* Count num of non-zero elements */ \
-    octave_idx_type nel = 0; \
-    octave_idx_type nz = m.nnz (); \
-    if (MC (MZ) OP SC (s))   \
-      nel += m.numel() - nz; \
-    for (octave_idx_type i = 0; i < nz; i++) \
-      if (MC (m.data (i)) OP SC (s)) \
-        nel++;	\
-    \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
-    SparseBoolMatrix r (nr, nc, nel); \
+    SparseBoolMatrix r; \
     \
-    if (nr > 0 && nc > 0) \
+    if (MC (MZ) OP SC (s)) \
+      { \
+        r = SparseBoolMatrix (nr, nc, true); \
+	for (octave_idx_type j = 0; j < nc; j++) \
+	  for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
+            if (! (MC (m.data (i)) OP SC (s))) \
+              r.data (m.ridx (i) + j * nr) = false; \
+        r.maybe_compress (true); \
+      } \
+    else \
       { \
-	if (MC (MZ) OP SC (s))	\
-	  { \
-	    octave_idx_type ii = 0; \
-	    r.cidx (0) = 0; \
-	    for (octave_idx_type j = 0; j < nc; j++) \
-	      { \
-		for (octave_idx_type i = 0; i < nr; i++) \
-		  { \
-		    bool el =  MC (m.elem(i, j)) OP SC (s); \
-		    if (el) \
-		      { \
-			r.data(ii) = el; \
-			r.ridx(ii++) = i; \
-		      } \
-		  } \
-		r.cidx(j+1) = ii; \
-	      } \
-	  } \
-	else \
-	  { \
-	    octave_idx_type ii = 0; \
-	    r.cidx (0) = 0; \
-	    for (octave_idx_type j = 0; j < nc; j++) \
-	      { \
-		for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
-		  { \
-		    bool el =  MC (m.data(i)) OP SC (s); \
-		    if (el) \
-		      { \
-			r.data(ii) = el; \
-			r.ridx(ii++) = m.ridx(i); \
-		      } \
-		  } \
-		r.cidx(j+1) = ii; \
-	      } \
-	  } \
-      }	\
+        r = SparseBoolMatrix (nr, nc, m.nnz ()); \
+        r.cidx (0) = static_cast<octave_idx_type> (0); \
+        octave_idx_type nel = 0; \
+	for (octave_idx_type j = 0; j < nc; j++) \
+          { \
+	    for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
+              if (MC (m.data (i)) OP SC (s)) \
+                { \
+                  r.ridx (nel) = m.ridx (i); \
+                  r.data (nel++) = true; \
+                } \
+            r.cidx (j + 1) = nel; \
+          } \
+        r.maybe_compress (false); \
+      } \
     return r; \
   }
 
 #define SPARSE_SMS_CMP_OPS(M, MZ, CM, S, SZ, CS)	\
   SPARSE_SMS_CMP_OP (mx_el_lt, <,  M, MZ, CM, S, SZ, CS)	\
   SPARSE_SMS_CMP_OP (mx_el_le, <=, M, MZ, CM, S, SZ, CS)	\
   SPARSE_SMS_CMP_OP (mx_el_ge, >=, M, MZ, CM, S, SZ, CS)	\
   SPARSE_SMS_CMP_OP (mx_el_gt, >,  M, MZ, CM, S, SZ, CS)	\
@@ -173,67 +151,48 @@ along with Octave; see the file COPYING.
 #define SPARSE_SMS_BOOL_OP_DECLS(M, S, API) \
   SPARSE_BOOL_OP_DECL (mx_el_and, M, S, API); \
   SPARSE_BOOL_OP_DECL (mx_el_or,  M, S, API);
 
 #define SPARSE_SMS_BOOL_OP(F, OP, M, S, LHS_ZERO, RHS_ZERO) \
   SparseBoolMatrix \
   F (const M& m, const S& s) \
   { \
-    /* Count num of non-zero elements */ \
-    octave_idx_type nel = 0; \
-    octave_idx_type nz = m.nnz (); \
-    if (LHS_ZERO OP (s != RHS_ZERO)) \
-      nel += m.numel() - nz; \
-    for (octave_idx_type i = 0; i < nz; i++) \
-      if ((m.data(i) != LHS_ZERO) OP (s != RHS_ZERO))\
-        nel++;	\
-    \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
-    SparseBoolMatrix r (nr, nc, nel); \
+    SparseBoolMatrix r; \
     \
     if (nr > 0 && nc > 0) \
       { \
 	if (LHS_ZERO OP (s != RHS_ZERO)) \
 	  { \
-	    octave_idx_type ii = 0; \
-	    r.cidx (0) = 0; \
+            r = SparseBoolMatrix (nr, nc, true); \
 	    for (octave_idx_type j = 0; j < nc; j++) \
-	      { \
-		for (octave_idx_type i = 0; i < nr; i++) \
-		  { \
-		    bool el = (m.elem(i, j) != LHS_ZERO) OP (s != RHS_ZERO); \
-		    if (el) \
-		      { \
-			r.data(ii) = el; \
-			r.ridx(ii++) = i; \
-		      } \
-		  } \
-		r.cidx(j+1) = ii; \
-	      } \
-	  } \
+	      for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
+                if (! ((m.data(i) != LHS_ZERO) OP (s != RHS_ZERO))) \
+                  r.data (m.ridx (i) + j * nr) = false; \
+            r.maybe_compress (true); \
+          } \
 	else \
 	  { \
-	    octave_idx_type ii = 0; \
-	    r.cidx (0) = 0; \
+            r = SparseBoolMatrix (nr, nc, m.nnz ()); \
+            r.cidx (0) = static_cast<octave_idx_type> (0); \
+            octave_idx_type nel = 0; \
 	    for (octave_idx_type j = 0; j < nc; j++) \
-	      { \
-		for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
-		  { \
-		    bool el = (m.data(i) != LHS_ZERO) OP (s != RHS_ZERO); \
-		    if (el) \
-		      { \
-			r.data(ii) = el; \
-			r.ridx(ii++) = m.ridx(i); \
-		      } \
-		  } \
-		r.cidx(j+1) = ii; \
-	      } \
-	  } \
+              { \
+	        for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
+                  if ((m.data(i) != LHS_ZERO) OP (s != RHS_ZERO)) \
+                    { \
+                      r.ridx (nel) = m.ridx (i); \
+                      r.data (nel++) = true; \
+                    } \
+                r.cidx (j + 1) = nel; \
+              } \
+            r.maybe_compress (false); \
+          } \
       }	\
     return r; \
   }
 
 #define SPARSE_SMS_BOOL_OPS2(M, S, LHS_ZERO, RHS_ZERO) \
   SPARSE_SMS_BOOL_OP (mx_el_and, &&, M, S, LHS_ZERO, RHS_ZERO) \
   SPARSE_SMS_BOOL_OP (mx_el_or,  ||, M, S, LHS_ZERO, RHS_ZERO)
 
@@ -308,68 +267,46 @@ along with Octave; see the file COPYING.
 #define SPARSE_SSM_EQNE_OP_DECLS(S, M, API) \
   SPARSE_CMP_OP_DECL (mx_el_eq, S, M, API); \
   SPARSE_CMP_OP_DECL (mx_el_ne, S, M, API);
 
 #define SPARSE_SSM_CMP_OP(F, OP, S, SZ, SC, M, MZ, MC)	\
   SparseBoolMatrix \
   F (const S& s, const M& m) \
   { \
-    /* Count num of non-zero elements */ \
-    octave_idx_type nel = 0; \
-    octave_idx_type nz = m.nnz (); \
-    if (SC (s) OP MC (MZ))   \
-      nel += m.numel() - nz; \
-    for (octave_idx_type i = 0; i < nz; i++) \
-      if (SC (s) OP MC (m.data (i))) \
-        nel++;	\
-    \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
-    SparseBoolMatrix r (nr, nc, nel); \
+    SparseBoolMatrix r; \
     \
-    if (nr > 0 && nc > 0) \
+    if (SC (s) OP SC (MZ)) \
+      { \
+        r = SparseBoolMatrix (nr, nc, true); \
+	for (octave_idx_type j = 0; j < nc; j++) \
+	  for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
+            if (! (SC (s) OP MC (m.data (i)))) \
+              r.data (m.ridx (i) + j * nr) = false; \
+        r.maybe_compress (true); \
+      } \
+    else \
       { \
-	if (SC (s) OP MC (MZ))\
-	  { \
-	    octave_idx_type ii = 0; \
-	    r.cidx (0) = 0; \
-	    for (octave_idx_type j = 0; j < nc; j++) \
-	      { \
-		for (octave_idx_type i = 0; i < nr; i++) \
-		  { \
-		    bool el = SC (s) OP MC (m.elem(i, j)); \
-		    if (el) \
-		      { \
-			r.data(ii) = el; \
-			r.ridx(ii++) = i; \
-		      } \
-		  } \
-		r.cidx(j+1) = ii; \
-	      } \
-	  } \
-	else \
-	  { \
-	    octave_idx_type ii = 0; \
-	    r.cidx (0) = 0; \
-	    for (octave_idx_type j = 0; j < nc; j++) \
-	      { \
-		for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
-		  { \
-		    bool el =  SC (s) OP MC (m.data(i)); \
-		    if (el) \
-		      { \
-			r.data(ii) = el; \
-			r.ridx(ii++) = m.ridx(i); \
-		      } \
-		  } \
-		r.cidx(j+1) = ii; \
-	      } \
-	  } \
-      }	\
+        r = SparseBoolMatrix (nr, nc, m.nnz ()); \
+        r.cidx (0) = static_cast<octave_idx_type> (0); \
+        octave_idx_type nel = 0; \
+	for (octave_idx_type j = 0; j < nc; j++) \
+          { \
+	    for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
+              if (SC (s) OP MC (m.data (i))) \
+                { \
+                  r.ridx (nel) = m.ridx (i); \
+                  r.data (nel++) = true; \
+                } \
+            r.cidx (j + 1) = nel; \
+          } \
+        r.maybe_compress (false); \
+      } \
     return r; \
   }
 
 #define SPARSE_SSM_CMP_OPS(S, SZ, SC, M, MZ, MC)	\
   SPARSE_SSM_CMP_OP (mx_el_lt, <,  S, SZ, SC, M, MZ, MC)	\
   SPARSE_SSM_CMP_OP (mx_el_le, <=, S, SZ, SC, M, MZ, MC)	\
   SPARSE_SSM_CMP_OP (mx_el_ge, >=, S, SZ, SC, M, MZ, MC)	\
   SPARSE_SSM_CMP_OP (mx_el_gt, >,  S, SZ, SC, M, MZ, MC)	\
@@ -383,67 +320,48 @@ along with Octave; see the file COPYING.
 #define SPARSE_SSM_BOOL_OP_DECLS(S, M, API) \
   SPARSE_BOOL_OP_DECL (mx_el_and, S, M, API); \
   SPARSE_BOOL_OP_DECL (mx_el_or,  S, M, API); \
 
 #define SPARSE_SSM_BOOL_OP(F, OP, S, M, LHS_ZERO, RHS_ZERO) \
   SparseBoolMatrix \
   F (const S& s, const M& m) \
   { \
-    /* Count num of non-zero elements */ \
-    octave_idx_type nel = 0; \
-    octave_idx_type nz = m.nnz (); \
-    if ((s != LHS_ZERO) OP  RHS_ZERO) \
-      nel += m.numel() - nz; \
-    for (octave_idx_type i = 0; i < nz; i++) \
-      if ((s != LHS_ZERO) OP m.data(i) != RHS_ZERO) \
-        nel++;	\
-    \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
-    SparseBoolMatrix r (nr, nc, nel); \
+    SparseBoolMatrix r; \
     \
     if (nr > 0 && nc > 0) \
       { \
 	if ((s != LHS_ZERO) OP RHS_ZERO) \
 	  { \
-	    octave_idx_type ii = 0; \
-	    r.cidx (0) = 0; \
+            r = SparseBoolMatrix (nr, nc, true); \
 	    for (octave_idx_type j = 0; j < nc; j++) \
-	      { \
-		for (octave_idx_type i = 0; i < nr; i++) \
-		  { \
-		    bool el = (s != LHS_ZERO) OP (m.elem(i, j) != RHS_ZERO); \
-		    if (el) \
-		      { \
-			r.data(ii) = el; \
-			r.ridx(ii++) = i; \
-		      } \
-		  } \
-		r.cidx(j+1) = ii; \
-	      } \
-	  } \
+	      for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
+                if (! ((s != LHS_ZERO) OP (m.data(i) != RHS_ZERO))) \
+                  r.data (m.ridx (i) + j * nr) = false; \
+            r.maybe_compress (true); \
+          } \
 	else \
 	  { \
-	    octave_idx_type ii = 0; \
-	    r.cidx (0) = 0; \
+            r = SparseBoolMatrix (nr, nc, m.nnz ()); \
+            r.cidx (0) = static_cast<octave_idx_type> (0); \
+            octave_idx_type nel = 0; \
 	    for (octave_idx_type j = 0; j < nc; j++) \
-	      { \
-		for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
-		  { \
-		    bool el = (s != LHS_ZERO) OP (m.data(i) != RHS_ZERO); \
-		    if (el) \
-		      { \
-			r.data(ii) = el; \
-			r.ridx(ii++) = m.ridx(i); \
-		      } \
-		  } \
-		r.cidx(j+1) = ii; \
-	      } \
-	  } \
+              { \
+	        for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
+                  if ((s != LHS_ZERO) OP (m.data(i) != RHS_ZERO)) \
+                    { \
+                      r.ridx (nel) = m.ridx (i); \
+                      r.data (nel++) = true; \
+                    } \
+                r.cidx (j + 1) = nel; \
+              } \
+            r.maybe_compress (false); \
+          } \
       }	\
     return r; \
   }
 
 #define SPARSE_SSM_BOOL_OPS2(S, M, LHS_ZERO, RHS_ZERO) \
   SPARSE_SSM_BOOL_OP (mx_el_and, &&, S, M, LHS_ZERO, RHS_ZERO) \
   SPARSE_SSM_BOOL_OP (mx_el_or,  ||, S, M, LHS_ZERO, RHS_ZERO)
 
@@ -811,17 +729,17 @@ along with Octave; see the file COPYING.
   SPARSE_CMP_OP_DECL (mx_el_gt, M1, M2, API); \
   SPARSE_CMP_OP_DECL (mx_el_eq, M1, M2, API); \
   SPARSE_CMP_OP_DECL (mx_el_ne, M1, M2, API);
 
 #define SPARSE_SMSM_EQNE_OP_DECLS(M1, M2, API) \
   SPARSE_CMP_OP_DECL (mx_el_eq, M1, M2, API); \
   SPARSE_CMP_OP_DECL (mx_el_ne, M1, M2, API);
 
-#define SPARSE_SMSM_CMP_OP(F, OP, M1, C1, M2, C2)	\
+#define SPARSE_SMSM_CMP_OP(F, OP, M1, Z1, C1, M2, Z2, C2)	\
   SparseBoolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
     SparseBoolMatrix r; \
     \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
     \
@@ -839,61 +757,117 @@ along with Octave; see the file COPYING.
         extern OCTAVE_API SparseBoolMatrix F (const M1&, const double&); \
         extern OCTAVE_API SparseBoolMatrix F (const M1&, const Complex&); \
         r = F (m1, m2.elem(0,0)); \
       } \
     else if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
 	if (m1_nr != 0 || m1_nc != 0) \
 	  { \
-	    /* Count num of non-zero elements */ \
-	    octave_idx_type nel = 0; \
-	    for (octave_idx_type j = 0; j < m1_nc; j++) \
-	      for (octave_idx_type i = 0; i < m1_nr; i++) \
-		if (C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j))) \
-		  nel++; \
-            \
-            r = SparseBoolMatrix (m1_nr, m1_nc, nel); \
-            \
-	    octave_idx_type ii = 0; \
-	    r.cidx (0) = 0; \
-	    for (octave_idx_type j = 0; j < m1_nc; j++) \
+            if (C1 (Z1) OP C2 (Z2)) \
 	      { \
-	        for (octave_idx_type i = 0; i < m1_nr; i++) \
-		  { \
-		    bool el = C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j)); \
-		    if (el) \
-		      { \
-			r.data(ii) = el; \
-			r.ridx(ii++) = i; \
-		      } \
-		  } \
-		r.cidx(j+1) = ii; \
-	      } \
+                r = SparseBoolMatrix (m1_nr, m1_nc, true); \
+	        for (octave_idx_type j = 0; j < m1_nc; j++) \
+                  { \
+                     octave_idx_type i1 = m1.cidx (j); \
+                     octave_idx_type e1 = m1.cidx (j+1); \
+                     octave_idx_type i2 = m2.cidx (j); \
+                     octave_idx_type e2 = m2.cidx (j+1); \
+                     while (i1 < e1 || i2 < e2) \
+                       { \
+                         if (i1 == e1 || (i2 < e2 && m1.ridx(i1) > m2.ridx(i2))) \
+                           { \
+                             if (! (C1 (Z1) OP C2 (m2.data (i2)))) \
+                               r.data (m2.ridx (i2) + j * m1_nr) = false; \
+                             i2++; \
+                           } \
+                         else if (i2 == e2 || m1.ridx(i1) < m2.ridx(i2)) \
+                           { \
+                             if (! (C1 (m1.data (i1)) OP C2 (Z2))) \
+                               r.data (m1.ridx (i1) + j * m1_nr) = false; \
+                             i1++; \
+                           } \
+                         else \
+                           { \
+                             if (! (C1 (m1.data (i1)) OP C2 (m2.data (i2)))) \
+                               r.data (m1.ridx (i1) + j * m1_nr) = false; \
+                             i1++; \
+                             i2++; \
+                           } \
+                       } \
+                  } \
+                r.maybe_compress (true); \
+              } \
+            else \
+              { \
+                r = SparseBoolMatrix (m1_nr, m1_nc, m1.nnz () + m2.nnz ()); \
+                r.cidx (0) = static_cast<octave_idx_type> (0); \
+                octave_idx_type nel = 0; \
+	        for (octave_idx_type j = 0; j < m1_nc; j++) \
+                  { \
+                     octave_idx_type i1 = m1.cidx (j); \
+                     octave_idx_type e1 = m1.cidx (j+1); \
+                     octave_idx_type i2 = m2.cidx (j); \
+                     octave_idx_type e2 = m2.cidx (j+1); \
+                     while (i1 < e1 || i2 < e2) \
+                       { \
+                         if (i1 == e1 || (i2 < e2 && m1.ridx(i1) > m2.ridx(i2))) \
+                           { \
+                             if (C1 (Z1) OP C2 (m2.data (i2))) \
+                               { \
+                                 r.ridx (nel) = m2.ridx (i2); \
+                                 r.data (nel++) = true; \
+                               } \
+                             i2++; \
+                           } \
+                         else if (i2 == e2 || m1.ridx(i1) < m2.ridx(i2)) \
+                           { \
+                             if (C1 (m1.data (i1)) OP C2 (Z2)) \
+                               { \
+                                 r.ridx (nel) = m1.ridx (i1); \
+                                 r.data (nel++) = true; \
+                               } \
+                             i1++; \
+                           } \
+                         else \
+                           { \
+                             if (C1 (m1.data (i1)) OP C2 (m2.data (i2))) \
+                               { \
+                                 r.ridx (nel) = m1.ridx (i1); \
+                                 r.data (nel++) = true; \
+                               } \
+                             i1++; \
+                             i2++; \
+                           } \
+                       } \
+                     r.cidx (j + 1) = nel; \
+                  } \
+                r.maybe_compress (false); \
+              } \
 	  } \
       }	      \
     else \
       { \
 	if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
 	  gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
     return r; \
   }
 
 #define SPARSE_SMSM_CMP_OPS(M1, Z1, C1, M2, Z2, C2)  \
-  SPARSE_SMSM_CMP_OP (mx_el_lt, <,  M1, C1, M2, C2) \
-  SPARSE_SMSM_CMP_OP (mx_el_le, <=, M1, C1, M2, C2) \
-  SPARSE_SMSM_CMP_OP (mx_el_ge, >=, M1, C1, M2, C2) \
-  SPARSE_SMSM_CMP_OP (mx_el_gt, >,  M1, C1, M2, C2) \
-  SPARSE_SMSM_CMP_OP (mx_el_eq, ==, M1,   , M2,   ) \
-  SPARSE_SMSM_CMP_OP (mx_el_ne, !=, M1,   , M2,   )
+  SPARSE_SMSM_CMP_OP (mx_el_lt, <,  M1, Z1, C1, M2, Z2, C2) \
+  SPARSE_SMSM_CMP_OP (mx_el_le, <=, M1, Z1, C1, M2, Z2, C2) \
+  SPARSE_SMSM_CMP_OP (mx_el_ge, >=, M1, Z1, C1, M2, Z2, C2) \
+  SPARSE_SMSM_CMP_OP (mx_el_gt, >,  M1, Z1, C1, M2, Z2, C2) \
+  SPARSE_SMSM_CMP_OP (mx_el_eq, ==, M1, Z1,   , M2, Z2,   ) \
+  SPARSE_SMSM_CMP_OP (mx_el_ne, !=, M1, Z1,   , M2, Z2,   )
 
 #define SPARSE_SMSM_EQNE_OPS(M1, Z1, C1, M2, Z2, C2)  \
-  SPARSE_SMSM_CMP_OP (mx_el_eq, ==, M1,   , M2,   ) \
-  SPARSE_SMSM_CMP_OP (mx_el_ne, !=, M1,   , M2,   )
+  SPARSE_SMSM_CMP_OP (mx_el_eq, ==, M1, Z1,   , M2, Z2,   ) \
+  SPARSE_SMSM_CMP_OP (mx_el_ne, !=, M1, Z1,   , M2, Z2,   )
 
 #define SPARSE_SMSM_BOOL_OP_DECLS(M1, M2, API) \
   SPARSE_BOOL_OP_DECL (mx_el_and, M1, M2, API); \
   SPARSE_BOOL_OP_DECL (mx_el_or,  M1, M2, API);
 
 #define SPARSE_SMSM_BOOL_OP(F, OP, M1, M2, LHS_ZERO, RHS_ZERO) \
   SparseBoolMatrix \
   F (const M1& m1, const M2& m2) \
@@ -917,42 +891,59 @@ along with Octave; see the file COPYING.
         extern OCTAVE_API SparseBoolMatrix F (const M1&, const double&); \
         extern OCTAVE_API SparseBoolMatrix F (const M1&, const Complex&); \
         r = F (m1, m2.elem(0,0)); \
       } \
     else if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
 	if (m1_nr != 0 || m1_nc != 0) \
 	  { \
-	    /* Count num of non-zero elements */ \
-	    octave_idx_type nel = 0; \
-	    for (octave_idx_type j = 0; j < m1_nc; j++) \
-	      for (octave_idx_type i = 0; i < m1_nr; i++) \
-		if ((m1.elem(i, j) != LHS_ZERO) \
-		    OP (m2.elem(i, j) != RHS_ZERO)) \
-		  nel++; \
-            \
-            r = SparseBoolMatrix (m1_nr, m1_nc, nel); \
-            \
-	    octave_idx_type ii = 0; \
-	    r.cidx (0) = 0; \
+            r = SparseBoolMatrix (m1_nr, m1_nc, m1.nnz () + m2.nnz ()); \
+            r.cidx (0) = static_cast<octave_idx_type> (0); \
+            octave_idx_type nel = 0; \
 	    for (octave_idx_type j = 0; j < m1_nc; j++) \
-	      { \
-	        for (octave_idx_type i = 0; i < m1_nr; i++) \
-		  { \
-		    bool el = (m1.elem(i, j) != LHS_ZERO) \
-		      OP (m2.elem(i, j) != RHS_ZERO);	  \
-		    if (el) \
-		      { \
-			r.data(ii) = el; \
-			r.ridx(ii++) = i; \
-		      } \
-		  } \
-		r.cidx(j+1) = ii; \
-	      } \
+              { \
+                octave_idx_type i1 = m1.cidx (j); \
+                octave_idx_type e1 = m1.cidx (j+1); \
+                octave_idx_type i2 = m2.cidx (j); \
+                octave_idx_type e2 = m2.cidx (j+1); \
+                while (i1 < e1 || i2 < e2) \
+                  { \
+                    if (i1 == e1 || (i2 < e2 && m1.ridx(i1) > m2.ridx(i2))) \
+                      { \
+                        if (LHS_ZERO OP m2.data (i2) != RHS_ZERO) \
+                          { \
+                            r.ridx (nel) = m2.ridx (i2); \
+                            r.data (nel++) = true; \
+                          } \
+                        i2++; \
+                      } \
+                    else if (i2 == e2 || m1.ridx(i1) < m2.ridx(i2)) \
+                      { \
+                        if (m1.data (i1) != LHS_ZERO OP RHS_ZERO) \
+                          { \
+                            r.ridx (nel) = m1.ridx (i1); \
+                            r.data (nel++) = true; \
+                          } \
+                        i1++; \
+                      } \
+                    else \
+                      { \
+                        if (m1.data (i1) != LHS_ZERO OP m2.data(i2) != RHS_ZERO) \
+                          { \
+                            r.ridx (nel) = m1.ridx (i1); \
+                            r.data (nel++) = true; \
+                          } \
+                        i1++; \
+                        i2++; \
+                      } \
+                  } \
+                r.cidx (j + 1) = nel; \
+              } \
+            r.maybe_compress (false); \
 	  } \
       }	      \
     else \
       { \
 	if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
 	  gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
     return r; \
@@ -1572,25 +1563,28 @@ along with Octave; see the file COPYING.
   octave_idx_type nc = cols (); \
  \
   RET_TYPE retval; \
  \
   if (nr > 0 && nc > 0) \
     { \
       if ((nr == 1 && dim == -1) || dim == 1) \
 	{ \
+          /* Define j here to allow fancy definition for prod method */ \
+          octave_idx_type j = 0; \
 	  OCTAVE_LOCAL_BUFFER (EL_TYPE, tmp, nr); \
           \
 	  for (octave_idx_type i = 0; i < nr; i++) \
-	    { \
-	      tmp[i] = INIT_VAL; \
-	      for (octave_idx_type j = 0; j < nc; j++) \
-		{ \
-		  ROW_EXPR; \
-		} \
+	    tmp[i] = INIT_VAL; \
+	  for (j = 0; j < nc; j++) \
+            { \
+	      for (octave_idx_type i = cidx(j); i < cidx(j + 1); i++) \
+                { \
+	          ROW_EXPR; \
+                } \
 	    } \
 	  octave_idx_type nel = 0; \
 	  for (octave_idx_type i = 0; i < nr; i++) \
 	    if (tmp[i] != EL_TYPE ())  \
 	      nel++ ; \
 	  retval = RET_TYPE (nr, static_cast<octave_idx_type> (1), nel); \
 	  retval.cidx(0) = 0; \
 	  retval.cidx(1) = nel; \
@@ -1604,20 +1598,20 @@ along with Octave; see the file COPYING.
 	} \
       else \
 	{ \
 	  OCTAVE_LOCAL_BUFFER (EL_TYPE, tmp, nc); \
           \
 	  for (octave_idx_type j = 0; j < nc; j++) \
 	    { \
 	      tmp[j] = INIT_VAL; \
-	      for (octave_idx_type i = 0; i < nr; i++) \
-		{ \
+	      for (octave_idx_type i = cidx(j); i < cidx(j + 1); i++) \
+                { \
 		  COL_EXPR; \
-		} \
+                } \
 	    } \
 	  octave_idx_type nel = 0; \
 	  for (octave_idx_type i = 0; i < nc; i++) \
 	    if (tmp[i] != EL_TYPE ())  \
 	      nel++ ; \
 	  retval = RET_TYPE (static_cast<octave_idx_type> (1), nc, nel); \
 	  retval.cidx(0) = 0; \
 	  nel = 0; \
@@ -1684,50 +1678,57 @@ along with Octave; see the file COPYING.
 			   static_cast<octave_idx_type> (0)); \
     } \
   else \
     retval.resize (nr > 0, nc > 0); \
  \
   return retval
 
 #define SPARSE_REDUCTION_OP_ROW_EXPR(OP) \
-  tmp[i] OP elem (i, j)
+  tmp[ridx(i)] OP data (i)
 
 #define SPARSE_REDUCTION_OP_COL_EXPR(OP) \
-  tmp[j] OP elem (i, j)
+  tmp[j] OP data (i)
 
 #define SPARSE_REDUCTION_OP(RET_TYPE, EL_TYPE, OP, INIT_VAL, MT_RESULT)	\
   SPARSE_BASE_REDUCTION_OP (RET_TYPE, EL_TYPE, \
 			SPARSE_REDUCTION_OP_ROW_EXPR (OP), \
 			SPARSE_REDUCTION_OP_COL_EXPR (OP), \
 			INIT_VAL, MT_RESULT)
 
 #define SPARSE_ANY_ALL_OP_ROW_CODE(TEST_OP, TEST_TRUE_VAL) \
-  if (elem (i, j) TEST_OP 0.0) \
+  if (data (i) TEST_OP 0.0) \
     { \
       tmp[i] = TEST_TRUE_VAL; \
       break; \
     }
 
 #define SPARSE_ANY_ALL_OP_COL_CODE(TEST_OP, TEST_TRUE_VAL) \
-  if (elem (i, j) TEST_OP 0.0) \
+  if (data (i) TEST_OP 0.0) \
     { \
       tmp[j] = TEST_TRUE_VAL; \
       break; \
     }
 
-#define SPARSE_ANY_ALL_OP(DIM, INIT_VAL, TEST_OP, TEST_TRUE_VAL) \
+#define SPARSE_ANY_ALL_OP(DIM, INIT_VAL, MT_RESULT, TEST_OP, TEST_TRUE_VAL) \
   SPARSE_BASE_REDUCTION_OP (SparseBoolMatrix, char, \
 			SPARSE_ANY_ALL_OP_ROW_CODE (TEST_OP, TEST_TRUE_VAL), \
 			SPARSE_ANY_ALL_OP_COL_CODE (TEST_OP, TEST_TRUE_VAL), \
-			INIT_VAL, INIT_VAL)
+			INIT_VAL, MT_RESULT)
 
-#define SPARSE_ALL_OP(DIM) SPARSE_ANY_ALL_OP (DIM, true, ==, false)
+#define SPARSE_ALL_OP(DIM) \
+  if ((rows() == 1 && dim == -1) || dim == 1) \
+    return transpose (). all (0). transpose(); \
+  else \
+    { \
+      SPARSE_ANY_ALL_OP (DIM, (cidx(j+1) - cidx(j) < nc ? false : true), \
+			 true, ==, false); \
+    }
 
-#define SPARSE_ANY_OP(DIM) SPARSE_ANY_ALL_OP (DIM, false, !=, true)
+#define SPARSE_ANY_OP(DIM) SPARSE_ANY_ALL_OP (DIM, false, false, !=, true)
 
 #define SPARSE_SPARSE_MUL( RET_TYPE, RET_EL_TYPE, EL_TYPE ) \
   octave_idx_type nr = m.rows (); \
   octave_idx_type nc = m.cols (); \
   \
   octave_idx_type a_nr = a.rows (); \
   octave_idx_type a_nc = a.cols (); \
   \
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -7705,34 +7705,40 @@ SparseMatrix
 SparseMatrix::cumsum (int dim) const
 {
   SPARSE_CUMSUM (SparseMatrix, double, cumsum);
 }
 
 SparseMatrix
 SparseMatrix::prod (int dim) const
 {
-  SPARSE_REDUCTION_OP (SparseMatrix, double, *=, 1.0, 1.0);
+  if ((rows() == 1 && dim == -1) || dim == 1)
+    return transpose (). prod (0). transpose();
+  else
+    {
+      SPARSE_REDUCTION_OP (SparseMatrix, double, *=, 
+			   (cidx(j+1) - cidx(j) < nc ? 0.0 : 1.0), 1.0);
+    }
 }
 
 SparseMatrix
 SparseMatrix::sum (int dim) const
 {
   SPARSE_REDUCTION_OP (SparseMatrix, double, +=, 0.0, 0.0);
 }
 
 SparseMatrix
 SparseMatrix::sumsq (int dim) const
 {
 #define ROW_EXPR \
-  double d = elem (i, j); \
-  tmp[i] += d * d
+  double d = data (i); \
+  tmp[ridx(i)] += d * d
 
 #define COL_EXPR \
-  double d = elem (i, j); \
+  double d = data (i); \
   tmp[j] += d * d
 
   SPARSE_BASE_REDUCTION_OP (SparseMatrix, double, ROW_EXPR, COL_EXPR, 
 			    0.0, 0.0);
 
 #undef ROW_EXPR
 #undef COL_EXPR
 }
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,10 +1,20 @@
+2007-12-07  David Bateman  <dbateman@free.fr>
+
+	* plot/surf.m: Don't set facecolor property.
+
 2007-12-06  John W. Eaton  <jwe@octave.org>
 
+	* plot/print.m: Pass mono to drawnow.
+	* plot/drawnow.m: New arg, mono.  Pass it to __go_draw_figure__.
+	* plot/__go_draw_figure__.m: New arg, mono.  Pass it to __go_draw_axes.
+	* plot/__go_draw_axes__.m: New arg, mono.  If mono is true,
+	disable color specifications.
+
 	* general/issymmetric.m: Move tests here from test/test_number.m
 
 2007-12-06  Jason Riedy  <ejr@cs.berkeley.edu>
 
 	* general/issymmetric.m: To keep its argument sparse and the
 	function quick, use the infinity norm rather than the 2-norm.
 	Also measure the symmetric part rather than the Hermitian part.
 	* general/ishermitian.m: New file.  Measure the Hermitian part.
diff --git a/scripts/plot/__go_draw_axes__.m b/scripts/plot/__go_draw_axes__.m
--- a/scripts/plot/__go_draw_axes__.m
+++ b/scripts/plot/__go_draw_axes__.m
@@ -15,19 +15,19 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## Undocumented internal function.
 
 ## Author: jwe
 
-function __go_draw_axes__ (h, plot_stream, enhanced)
+function __go_draw_axes__ (h, plot_stream, enhanced, mono)
 
-  if (nargin == 3)
+  if (nargin == 4)
 
     axis_obj = get (h);
 
     parent_figure_obj = get (axis_obj.parent);
 
     persistent have_newer_gnuplot ...
       = compare_versions (__gnuplot_version__ (), "4.0", ">");
 
@@ -82,17 +82,17 @@ function __go_draw_axes__ (h, plot_strea
 	fprintf (plot_stream, "set title \"%s\" %s;\n",
 		 undo_string_escapes (tt), fontspec);
       endif
     endif
 
     if (! isempty (axis_obj.xlabel))
       t = get (axis_obj.xlabel);
       angle = t.rotation;
-      colorspec = get_text_colorspec (axis_obj.xcolor);
+      colorspec = get_text_colorspec (axis_obj.xcolor, mono);
       if (isempty (t.string))
 	fprintf (plot_stream, "unset xlabel;\n");
 	fprintf (plot_stream, "unset x2label;\n");
       else
 	[tt, f, s] = __maybe_munge_text__ (enhanced, t, "string",
 					   have_newer_gnuplot);
 	if (strcmp (f, "*"))
 	  fontspec = "";
@@ -118,17 +118,17 @@ function __go_draw_axes__ (h, plot_strea
 	  fprintf (plot_stream, "unset x2label;\n");
 	endif
       endif
     endif
 
     if (! isempty (axis_obj.ylabel))
       t = get (axis_obj.ylabel);
       angle = t.rotation;
-      colorspec = get_text_colorspec (axis_obj.ycolor);
+      colorspec = get_text_colorspec (axis_obj.ycolor, mono);
       if (isempty (t.string))
 	fprintf (plot_stream, "unset ylabel;\n");
 	fprintf (plot_stream, "unset y2label;\n");
       else
 	[tt, f, s] = __maybe_munge_text__ (enhanced, t, "string",
 					   have_newer_gnuplot);
 	if (strcmp (f, "*"))
 	  fontspec = "";
@@ -152,17 +152,17 @@ function __go_draw_axes__ (h, plot_strea
 	  fprintf (plot_stream, "unset y2label;\n");
 	endif
       endif
     endif
 
     if (! isempty (axis_obj.zlabel))
       t = get (axis_obj.zlabel);
       angle = t.rotation;
-      colorspec = get_text_colorspec (axis_obj.zcolor);
+      colorspec = get_text_colorspec (axis_obj.zcolor, mono);
       if (isempty (t.string))
 	fputs (plot_stream, "unset zlabel;\n");
       else
 	[tt, f, s] = __maybe_munge_text__ (enhanced, t, "string",
 					   have_newer_gnuplot);
 	if (strcmp (f, "*"))
 	  fontspec = "";
 	else
@@ -228,17 +228,17 @@ function __go_draw_axes__ (h, plot_strea
 
     if (strcmpi (axis_obj.zminorgrid, "on"))
       fputs (plot_stream, "set mztics 5;\n");
       fputs (plot_stream, "set grid mztics;\n");
     else
       fputs (plot_stream, "set grid nomztics;\n");
     endif
 
-    do_tics (axis_obj, plot_stream, ymirror);
+    do_tics (axis_obj, plot_stream, ymirror, mono);
 
     xlogscale = strcmpi (axis_obj.xscale, "log");
     if (xlogscale)
       fprintf (plot_stream, "set logscale %s;\n", xaxisloc);
     else
       fprintf (plot_stream, "unset logscale %s;\n", xaxisloc);
     endif
 
@@ -355,17 +355,18 @@ function __go_draw_axes__ (h, plot_strea
 	  parametric(data_idx) = true;
 	  have_cdata(data_idx) = false;
 	  if (isempty (obj.keylabel))
 	    titlespec{data_idx} = "title \"\"";
 	  else
 	    tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "keylabel", have_newer_gnuplot));
 	    titlespec{data_idx} = strcat ("title \"", tmp, "\"");
 	  endif
-	  [style, typ, with] = do_linestyle_command (obj, data_idx, plot_stream);
+	  [style, typ, with] = do_linestyle_command (obj, data_idx,
+						     mono, plot_stream);
 	  usingclause{data_idx} = "";
 	  if (have_newer_gnuplot || isnan (typ))
 	    withclause{data_idx} = sprintf ("with %s linestyle %d",
 					    style, data_idx);
 	  else
 	    withclause{data_idx} = sprintf ("with %s linetype %d",
 					    style, typ);
 	  endif
@@ -546,19 +547,24 @@ function __go_draw_axes__ (h, plot_strea
 		 else
 		   color = [0, 1, 0];
 		 endif
                else
 		 color = [0, 1, 0];
                endif
 
 	       if (have_newer_gnuplot)
-		 withclause{data_idx} ...
-		     = sprintf ("with filledcurve lc rgb \"#%02x%02x%02x\"",
-				round (255*color));
+		 if (mono)
+		   colorspec = "";
+		 else
+		   colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
+					round (255*color));
+		 endif
+		 withclause{data_idx} = sprintf ("with filledcurve %s",
+						 colorspec);
 	       else
 		 if (isequal (color, [0,0,0]))
 		   typ = -1;
 		 elseif (isequal (color, [1,0,0]))
 		   typ = 1;
 		 elseif (isequal (color, [0,1,0]))
 		   typ = 2;
 		 elseif (isequal (color, [0,0,1]))
@@ -725,19 +731,24 @@ function __go_draw_axes__ (h, plot_strea
 	       else
 		 ps = "";
 	       endif
 	     else
 	       ps = "";
 	     endif
 
 	     if (have_newer_gnuplot)
-	       withclause{data_idx} ...
-		   = sprintf ("with %s %s %s lc rgb \"#%02x%02x%02x\"",
-			      style, pt, ps, round (255*color));
+	       if (mono)
+		 colorspec = "";
+	       else
+		 colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
+				      round (255*color));
+	       endif
+	       withclause{data_idx} = sprintf ("with %s %s %s %s",
+					       style, pt, ps, colorspec);
 	     else
 	       if (isequal (color, [0,0,0]))
 		 typ = -1;
 	       elseif (isequal (color, [1,0,0]))
 		 typ = 1;
 	       elseif (isequal (color, [0,1,0]))
 		 typ = 2;
 	       elseif (isequal (color, [0,0,1]))
@@ -780,17 +791,17 @@ function __go_draw_axes__ (h, plot_strea
 	  nd = 3;
           if (! (strncmp (obj.edgecolor, "none", 4)
 		 && strncmp (obj.facecolor, "none", 4)))
 	    data_idx++;
 	    is_image_data(data_idx) = false;
 	    parametric(data_idx) = false;
 	    have_cdata(data_idx) = true;
 	    [style, typ, with] = do_linestyle_command (obj, data_idx,
-						       plot_stream);
+						       mono, plot_stream);
 	    if (isempty (obj.keylabel))
 	      titlespec{data_idx} = "title \"\"";
 	    else
 	      tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "keylabel", have_newer_gnuplot));
 	      titlespec{data_idx} = strcat ("title \"", tmp, "\"");
 	    endif
 	    usingclause{data_idx} = "";
 	    if (have_newer_gnuplot || isnan (typ))
@@ -894,19 +905,25 @@ function __go_draw_axes__ (h, plot_strea
                 edgecol = obj.edgecolor;
                 if (ischar (obj.edgecolor))
                   edgecol = [0,0,0];
                 endif
                 fprintf (plot_stream, "set pm3d at s hidden3d %d %s %s corners2color c3;\n", 
 			 data_idx, interp_str, dord);
 
 		if (have_newer_gnuplot)
+		  if (mono)
+		    colorspec = "";
+		  else
+		    colorspec = sprintf ("linecolor rgb \"#%02x%02x%02x\"",
+					 round (255*edgecol));
+		  endif
                   fprintf (plot_stream,
-                           "set style line %d linecolor rgb \"#%02x%02x%02x\" lw %f;\n",
-                           data_idx, round (255*edgecol), obj.linewidth);
+                           "set style line %d %s lw %f;\n",
+                           data_idx, colorspec, obj.linewidth);
 		else
 		  if (isequal (edgecol, [0,0,0]))
 		    typ = -1;
 		  elseif (isequal (edgecol, [1,0,0]))
 		    typ = 1;
 		  elseif (isequal (edgecol, [0,1,0]))
 		    typ = 2;
 		  elseif (isequal (edgecol, [0,0,1]))
@@ -945,17 +962,17 @@ function __go_draw_axes__ (h, plot_strea
 	  color = obj.color;
           if (strcmpi (units, "normalized"))
             units = "graph";
           else
             units = "";
           endif
 	  
 	  if (isnumeric (color))
-	    colorspec = get_text_colorspec (color);
+	    colorspec = get_text_colorspec (color, mono);
 	  endif
 
 	  if (nd == 3)
 	    fprintf (plot_stream,
 		     "set label \"%s\" at %s %.15g,%.15g,%.15g %s %s rotate by %f %s;\n",
 		     undo_string_escapes (label), units, lpos(1),
 		     lpos(2), lpos(3), fontspec, halign, angle, colorspec);
 	  else
@@ -1177,17 +1194,17 @@ function __go_draw_axes__ (h, plot_strea
     fflush (plot_stream);
 
   else
     print_usage ();
   endif
 
 endfunction
 
-function [style, typ, with] = do_linestyle_command (obj, idx, plot_stream)
+function [style, typ, with] = do_linestyle_command (obj, idx, mono, plot_stream)
 
   persistent have_newer_gnuplot ...
     = compare_versions (__gnuplot_version__ (), "4.0", ">");
 
   if (have_newer_gnuplot)
     fprintf (plot_stream, "set style line %d default;\n", idx);
   endif
   fprintf (plot_stream, "set style line %d", idx);
@@ -1195,18 +1212,20 @@ function [style, typ, with] = do_linesty
   found_style = false;
   typ = NaN;
   with = "";
 
   if (isfield (obj, "color"))
     color = obj.color;
     if (isnumeric (color))
       if (have_newer_gnuplot)
-	fprintf (plot_stream, " linecolor rgb \"#%02x%02x%02x\"",
-		 round (255*color));
+	if (! mono)
+	  fprintf (plot_stream, " linecolor rgb \"#%02x%02x%02x\"",
+		   round (255*color));
+	endif
       else
 	if (isequal (color, [0,0,0]))
 	  typ = -1;
 	elseif (isequal (color, [1,0,0]))
 	  typ = 1;
 	elseif (isequal (color, [0,1,0]))
 	  typ = 2;
 	elseif (isequal (color, [0,0,1]))
@@ -1393,45 +1412,46 @@ function __gnuplot_write_data__ (plot_st
 	endfor
       endif
     endif
   endif
   fputs (plot_stream, "e\n");
 
 endfunction
 
-function do_tics (obj, plot_stream, ymirror)
+function do_tics (obj, plot_stream, ymirror, mono)
   if (strcmpi (obj.xaxislocation, "top"))
     do_tics_1 (obj.xtickmode, obj.xtick, obj.xticklabelmode, obj.xticklabel,
-	       obj.xcolor, "x2", plot_stream, true);
+	       obj.xcolor, "x2", plot_stream, true, mono);
     do_tics_1 ("manual", [], obj.xticklabelmode, obj.xticklabel,
-	       obj.xcolor, "x", plot_stream, true);
+	       obj.xcolor, "x", plot_stream, true, mono);
   else
     do_tics_1 (obj.xtickmode, obj.xtick, obj.xticklabelmode, obj.xticklabel,
-	       obj.xcolor, "x", plot_stream, true);
+	       obj.xcolor, "x", plot_stream, true, mono);
     do_tics_1 ("manual", [], obj.xticklabelmode, obj.xticklabel,
-	       obj.xcolor, "x2", plot_stream, true);
+	       obj.xcolor, "x2", plot_stream, true, mono);
   endif
   if (strcmpi (obj.yaxislocation, "right"))
     do_tics_1 (obj.ytickmode, obj.ytick, obj.yticklabelmode, obj.yticklabel,
-	       obj.ycolor, "y2", plot_stream, ymirror);
+	       obj.ycolor, "y2", plot_stream, ymirror, mono);
     do_tics_1 ("manual", [], obj.yticklabelmode, obj.yticklabel,
-	       obj.ycolor, "y", plot_stream, ymirror);
+	       obj.ycolor, "y", plot_stream, ymirror, mono);
   else
     do_tics_1 (obj.ytickmode, obj.ytick, obj.yticklabelmode, obj.yticklabel,
-	       obj.ycolor, "y", plot_stream, ymirror);
+	       obj.ycolor, "y", plot_stream, ymirror, mono);
     do_tics_1 ("manual", [], obj.yticklabelmode, obj.yticklabel,
-	       obj.ycolor, "y2", plot_stream, ymirror);
+	       obj.ycolor, "y2", plot_stream, ymirror, mono);
   endif
   do_tics_1 (obj.ztickmode, obj.ztick, obj.zticklabelmode, obj.zticklabel,
-	     obj.zcolor, "z", plot_stream, true);
+	     obj.zcolor, "z", plot_stream, true, mono);
 endfunction
 
-function do_tics_1 (ticmode, tics, labelmode, labels, color, ax, plot_stream, mirror)
-  colorspec = get_text_colorspec (color);
+function do_tics_1 (ticmode, tics, labelmode, labels, color, ax,
+		    plot_stream, mirror, mono)
+  colorspec = get_text_colorspec (color, mono);
   if (strcmpi (ticmode, "manual"))
     if (isempty (tics))
       fprintf (plot_stream, "unset %stics;\n", ax);
     elseif (strcmpi (labelmode, "manual") && ! isempty (labels))
       if (ischar (labels))
 	labels = cellstr (labels);
       endif
       if (iscellstr (labels))
@@ -1473,23 +1493,27 @@ function do_tics_1 (ticmode, tics, label
     if (mirror)
       fprintf (plot_stream, "set %stics %s;\n", ax, colorspec);
     else
       fprintf (plot_stream, "set %stics nomirror %s;\n", ax, colorspec);
     endif
   endif
 endfunction
 
-function colorspec = get_text_colorspec (color)
+function colorspec = get_text_colorspec (color, mono)
   persistent have_newer_gnuplot ...
       = compare_versions (__gnuplot_version__ (), "4.0", ">");
 
   if (have_newer_gnuplot)
-    colorspec = sprintf ("textcolor rgb \"#%02x%02x%02x\"",
-			 round (255*color));
+    if (mono)
+      colorspec = "";
+    else
+      colorspec = sprintf ("textcolor rgb \"#%02x%02x%02x\"",
+			   round (255*color));
+    endif
   else
     if (isequal (color, [0,0,0]))
       typ = -1;
     elseif (isequal (color, [1,0,0]))
       typ = 1;
     elseif (isequal (color, [0,1,0]))
       typ = 2;
     elseif (isequal (color, [0,0,1]))
diff --git a/scripts/plot/__go_draw_figure__.m b/scripts/plot/__go_draw_figure__.m
--- a/scripts/plot/__go_draw_figure__.m
+++ b/scripts/plot/__go_draw_figure__.m
@@ -15,19 +15,19 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## Undocumented internal function.
 
 ## Author: jwe
 
-function __go_draw_figure__ (f, plot_stream, enhanced)
+function __go_draw_figure__ (f, plot_stream, enhanced, mono)
 
-  if (nargin == 3)
+  if (nargin == 4)
     if (strcmp (f.type, "figure"))
 
       ## Set figure properties here?
 
       kids = f.children;
       nkids = length (kids);
 
       if (nkids > 0)
@@ -51,17 +51,17 @@ function __go_draw_figure__ (f, plot_str
 	if (multiplot_mode)
 	  fputs (plot_stream, "set multiplot;\n");
 	endif
 
 	for i = 1:nkids
 	  obj = get (kids(i));
 	  switch (obj.type)
 	    case "axes"
-	      __go_draw_axes__ (kids (i), plot_stream, enhanced);
+	      __go_draw_axes__ (kids (i), plot_stream, enhanced, mono);
 	    otherwise
 	      error ("__go_draw_figure__: unknown object class, %s",
 		     obj.type);
 	  endswitch
 	endfor
 
 	if (multiplot_mode)
 	  fputs (plot_stream, "unset multiplot;\n");
diff --git a/scripts/plot/drawnow.m b/scripts/plot/drawnow.m
--- a/scripts/plot/drawnow.m
+++ b/scripts/plot/drawnow.m
@@ -22,40 +22,44 @@
 ##
 ## Octave automatically calls drawnow just before printing a prompt,
 ## when @code{sleep} or @code{pause} is called, or while waiting for
 ## command-line input.
 ## @end deftypefn
 
 ## Author: jwe
 
-function drawnow (term, file, debug_file)
+function drawnow (term, file, mono, debug_file)
 
   persistent drawnow_executing = 0;
 
   unwind_protect
 
     ## If this is a recursive call, do nothing.
     if (++drawnow_executing > 1)
       return;
     endif
 
-    if (nargin == 2 || nargin == 3)
+    if (nargin < 3)
+      mono = false;
+    endif
+
+    if (nargin >= 2 && nargin <= 4)
       h = get (0, "currentfigure");
       if (h)
 	f = get (h);
 	plot_stream = [];
 	fid = [];
 	unwind_protect
 	  [plot_stream, enhanced] = open_gnuplot_stream ([], term, file);
-	  __go_draw_figure__ (f, plot_stream, enhanced);	
-	  if (nargin == 3)
+	  __go_draw_figure__ (f, plot_stream, enhanced, mono);
+	  if (nargin == 4)
 	    fid = fopen (debug_file, "wb");
 	    enhanced = init_plot_stream (fid, [], term, file);
-	    __go_draw_figure__ (f, fid, enhanced);
+	    __go_draw_figure__ (f, fid, enhanced, mono);
 	  endif
 	unwind_protect_cleanup
 	  if (! isempty (plot_stream))
 	    pclose (plot_stream);
 	  endif
 	  if (! isempty (fid))
 	    fclose (fid);
 	  endif
@@ -72,17 +76,17 @@ function drawnow (term, file, debug_file
 	    figure_is_visible = strcmp (f.visible, "on");
 	    if (figure_is_visible)
 	      if (isempty (plot_stream))
 		[plot_stream, enhanced] = open_gnuplot_stream (h);
 		set (h, "__enhanced__", enhanced);
 	      else
 		enhanced = f.__enhanced__;
 	      endif
-	      __go_draw_figure__ (f, plot_stream, enhanced);
+	      __go_draw_figure__ (f, plot_stream, enhanced, mono);
 	    elseif (! isempty (plot_stream))
 	      pclose (plot_stream);
 	      set (h, "__plot_stream__", []);
 	      set (h, "__enhanced__", false);
 	    endif
 	    set (h, "__modified__", false);
 	  endif
 	endif
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -367,20 +367,22 @@ function print (varargin)
     options = "";
     if (! isempty (size))
       options = strcat (" size ", size);
     endif
     new_terminal = strcat ("svg", options);
 
   endif
 
+  mono = use_color < 0;
+
   if (debug)
-    drawnow (new_terminal, name, debug_file);
+    drawnow (new_terminal, name, mono, debug_file);
   else
-    drawnow (new_terminal, name);
+    drawnow (new_terminal, name, mono);
   endif
 
   if (! isempty (convertname))
     command = sprintf ("convert '%s' '%s'", name, convertname);
     [errcode, output] = system (command);
     unlink (name);
     if (errcode)
       error ("print: could not convert");
diff --git a/scripts/plot/ribbon.m b/scripts/plot/ribbon.m
--- a/scripts/plot/ribbon.m
+++ b/scripts/plot/ribbon.m
@@ -79,8 +79,13 @@ function h = ribbon (x, y, width)
 	 "ygrid", "on", "zgrid", "on");
   endif
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
+
+%!demo
+%! [x, y, z] = sombrero ();
+%! [x, y] = meshgrid (x, y);
+%! ribbon (y, z);
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,10 +1,13 @@
 2007-12-07  David Bateman  <dbateman@free.fr>
 
+	* data.cc (Fnorm): Don't return a scalar stored as a sparse
+	matrix. Convert it to a scalar.
+
 	* graphics.cc (check_limit_val): Delete.
 	(check_limit_vals): Simplify and no longer use check_limit_val.
 
 2007-12-05  John W. Eaton  <jwe@octave.org>
 
 	* version.h (OCTAVE_VERSION): Now 2.9.18+.
 
 2007-12-05  John W. Eaton  <jwe@octave.org>
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -2872,16 +2872,27 @@ p-norm of @var{a}, @code{(sum (abs (@var
 	    retval = feval ("__norm__", args);
 	}
       else
 	error ("norm: only valid for 2-D objects");
     }
   else
     print_usage ();
 
+  // Should not return a sparse type
+  if (retval(0).is_sparse_type ())
+    {
+      if (retval(0).type_name () == "sparse matrix") 
+	retval(0) = retval(0).matrix_value ();
+      else if (retval(0).type_name () == "sparse complex matrix")
+	retval(0) = retval(0).complex_matrix_value ();
+      else if (retval(0).type_name () == "sparse bool matrix")
+	retval(0) = retval(0).bool_matrix_value ();
+    }
+
   return retval;
 }
 
 #define UNARY_OP_DEFUN_BODY(F) \
  \
   octave_value retval; \
  \
   if (args.length () == 1) \
