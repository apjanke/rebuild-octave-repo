# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1497568506 14400
#      Thu Jun 15 19:15:06 2017 -0400
# Node ID 91c8f006ed8b1111dcbf4d0ae2374ba2f9a397a6
# Parent  2fe11412e785a87e085b16565fc732991327f204
remove additional functions from symbol_table class

Remove functions from symbol_table class that simply forward to
the corresponding function in the symbol_table::scope class.  Change
all uses to access these functions using a scope object.

diff --git a/examples/code/make_int.cc b/examples/code/make_int.cc
--- a/examples/code/make_int.cc
+++ b/examples/code/make_int.cc
@@ -17,17 +17,16 @@
 #include <octave/oct-obj.h>
 #include <octave/ops.h>
 #include <octave/ov-base.h>
 #include <octave/ov-typeinfo.h>
 #include <octave/ov.h>
 #include <octave/ov-scalar.h>
 #include <octave/pager.h>
 #include <octave/pr-output.h>
-#include <octave/symtab.h>
 #include <octave/variables.h>
 
 class octave_value_list;
 
 class tree_walker;
 
 // Integer values.
 
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -2415,44 +2415,47 @@ main_window::save_workspace_callback (co
   Fsave (ovl (file));
 }
 
 void
 main_window::load_workspace_callback (const std::string& file)
 {
   Fload (ovl (file));
 
- symbol_table& symtab
-   = octave::__get_symbol_table__ ("main_window::load_workspace_callback");
-
-  octave_link::set_workspace (true, symtab.workspace_info ());
+  symbol_table::scope *scope
+   = octave::__get_current_scope__ ("main_window::load_workspace_callback");
+
+  if (scope)
+    octave_link::set_workspace (true, scope->workspace_info ());
 }
 
 void
 main_window::clear_workspace_callback (void)
 {
   octave::interpreter& interp
     = octave::__get_interpreter__ ("main_window::clear_workspace_callback");
 
   Fclear (interp);
 }
 
 void
 main_window::rename_variable_callback (const main_window::name_pair& names)
 {
-  symbol_table& symtab
-    = octave::__get_symbol_table__ ("main_window::rename_variable_callback");
-
-  /* bool status = */ symtab.rename (names.first, names.second);
-
-  // if (status)
-  octave_link::set_workspace (true, symtab.workspace_info ());
-
-  //  else
-  //    ; // we need an octave_link action that runs a GUI error option.
+  symbol_table::scope *scope
+    = octave::__get_current_scope__ ("main_window::rename_variable_callback");
+
+  if (scope)
+    {
+      scope->rename (names.first, names.second);
+
+      octave_link::set_workspace (true, scope->workspace_info ());
+    }
+
+  // FIXME: if this action fails, do we need a way to display that info
+  // in the GUI?
 }
 
 void
 main_window::command_window_undo_callback (void)
 {
   octave::command_editor::undo ();
   octave::command_editor::redisplay ();
 }
diff --git a/libgui/src/workspace-view.cc b/libgui/src/workspace-view.cc
--- a/libgui/src/workspace-view.cc
+++ b/libgui/src/workspace-view.cc
@@ -368,20 +368,20 @@ void
 workspace_view::handle_contextmenu_copy_value (void)
 {
   QModelIndex index = view->currentIndex ();
 
   if (index.isValid ())
     {
       QString var_name = get_var_name (index);
 
-      symbol_table& symtab
-        = octave::__get_symbol_table__ ("workspace_view::handle_contextmenu_copy_value");
+      symbol_table::scope *scope
+        = octave::__get_current_scope__ ("workspace_view::handle_contextmenu_copy_value");
 
-      octave_value val = symtab.varval (var_name.toStdString ());
+      octave_value val = scope ? scope->varval (var_name.toStdString ()) : 0;
       std::ostringstream buf;
       val.print_raw (buf, true);
 
       QClipboard *clipboard = QApplication::clipboard ();
       clipboard->setText (QString::fromStdString (buf.str ()));
     }
 }
 
diff --git a/libinterp/corefcn/defun.cc b/libinterp/corefcn/defun.cc
--- a/libinterp/corefcn/defun.cc
+++ b/libinterp/corefcn/defun.cc
@@ -86,95 +86,101 @@ check_version (const std::string& versio
 
 void
 install_builtin_function (octave_builtin::fcn f, const std::string& name,
                           const std::string& file, const std::string& doc,
                           bool /* can_hide_function -- not yet implemented */)
 {
   octave_value fcn (new octave_builtin (f, name, file, doc));
 
-  symbol_table& symtab = octave::__get_symbol_table__ ("install_builtin_function");
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("install_builtin_function");
 
   symtab.install_built_in_function (name, fcn);
 }
 
 void
 install_builtin_function (octave_builtin::meth m, const std::string& name,
                           const std::string& file, const std::string& doc,
                           bool /* can_hide_function -- not yet implemented */)
 {
   octave_value fcn (new octave_builtin (m, name, file, doc));
 
-  symbol_table& symtab = octave::__get_symbol_table__ ("install_builtin_function");
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("install_builtin_function");
 
   symtab.install_built_in_function (name, fcn);
 }
 
 void
 install_dld_function (octave_dld_function::fcn f, const std::string& name,
                       const octave::dynamic_library& shl, const std::string& doc,
                       bool relative)
 {
   octave_dld_function *fcn = new octave_dld_function (f, shl, name, doc);
 
   if (relative)
     fcn->mark_relative ();
 
   octave_value fval (fcn);
 
-  symbol_table& symtab = octave::__get_symbol_table__ ("install_dld_function");
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("install_dld_function");
 
   symtab.install_built_in_function (name, fval);
 }
 
 void
 install_dld_function (octave_dld_function::meth m, const std::string& name,
                       const octave::dynamic_library& shl, const std::string& doc,
                       bool relative)
 {
   octave_dld_function *fcn = new octave_dld_function (m, shl, name, doc);
 
   if (relative)
     fcn->mark_relative ();
 
   octave_value fval (fcn);
 
-  symbol_table& symtab = octave::__get_symbol_table__ ("install_dld_function");
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("install_dld_function");
 
   symtab.install_built_in_function (name, fval);
 }
 
 void
 install_mex_function (void *fptr, bool fmex, const std::string& name,
                       const octave::dynamic_library& shl, bool relative)
 {
   octave_mex_function *fcn = new octave_mex_function (fptr, fmex, shl, name);
 
   if (relative)
     fcn->mark_relative ();
 
   octave_value fval (fcn);
 
-  symbol_table& symtab = octave::__get_symbol_table__ ("install_mex_function");
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("install_mex_function");
 
   symtab.install_built_in_function (name, fval);
 }
 
 void
 alias_builtin (const std::string& alias, const std::string& name)
 {
   symbol_table& symtab = octave::__get_symbol_table__ ("alias_builtin");
 
   symtab.alias_built_in_function (alias, name);
 }
 
 void
 install_builtin_dispatch (const std::string& name, const std::string& klass)
 {
-  symbol_table& symtab = octave::__get_symbol_table__ ("install_builtin_dispatch");
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("install_builtin_dispatch");
 
   symtab.install_built_in_dispatch (name, klass);
 }
 
 octave::dynamic_library
 get_current_shlib (void)
 {
   octave::dynamic_library retval;
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -1508,24 +1508,27 @@ disable escape sequence expansion use a 
         {
           octave_map old_warning_options = warning_options;
 
           symbol_table& symtab = interp.get_symbol_table ();
 
           if (nargin == 3 && argv[3] == "local"
               && ! symtab.at_top_level ())
             {
+              symbol_table::scope *scope
+                = symtab.require_current_scope ("warning");
+
               octave_scalar_map val = warning_query (arg2);
 
               octave_value curr_state = val.contents ("state");
 
               // FIXME: this might be better with a dictionary object.
 
               octave_value curr_warning_states
-                = symtab.varval (".saved_warning_states.");
+                = scope->varval (".saved_warning_states.");
 
               octave_map m;
 
               if (curr_warning_states.is_defined ())
                 m = curr_warning_states.map_value ();
               else
                 {
                   string_vector fields (2);
@@ -1563,17 +1566,17 @@ disable escape sequence expansion use a 
 
                   ids(nel) = arg2;
                   states(nel) = curr_state;
                 }
 
               m.contents ("identifier") = ids;
               m.contents ("state") = states;
 
-              symtab.assign (".saved_warning_states.", m);
+              scope->assign (".saved_warning_states.", m);
 
               // Now ignore the "local" argument and continue to
               // handle the current setting.
               nargin--;
             }
 
           if (nargin >= 2 && arg2 == "all")
             {
diff --git a/libinterp/corefcn/interpreter.cc b/libinterp/corefcn/interpreter.cc
--- a/libinterp/corefcn/interpreter.cc
+++ b/libinterp/corefcn/interpreter.cc
@@ -514,18 +514,24 @@ namespace octave
 
   interpreter::~interpreter (void)
   {
     cleanup ();
   }
 
   void interpreter::intern_nargin (octave_idx_type nargs)
   {
-    m_symbol_table.assign (".nargin.", nargs);
-    m_symbol_table.mark_hidden (".nargin.");
+    // FIXME: should this explicitly be top_scope?
+    symbol_table::scope *scope = m_symbol_table.current_scope ();
+
+    if (scope)
+      {
+        scope->assign (".nargin.", nargs);
+        scope->mark_hidden (".nargin.");
+      }
   }
 
   // Read the history file unless a command-line option inhibits that.
 
   void interpreter::initialize_history (bool read_history_file)
   {
     if (! m_history_initialized)
       {
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -116,19 +116,19 @@ strip_trailing_separators (const std::st
 static std::string
 find_private_file (const std::string& fname)
 {
   std::string retval;
 
   // Look in private directory corresponding to current function (if
   // any).
 
-  symbol_table& symtab = octave::__get_symbol_table__ ("find_private_file");
-
-  octave_user_function *curr_fcn = symtab.get_curr_fcn ();
+  symbol_table::scope *scope = octave::__get_current_scope__ ("find_private_file");
+
+  octave_user_function *curr_fcn = scope ? scope->function () : 0;
 
   if (curr_fcn)
     {
       // Even for private functions, dir_name doesn't contain the
       // "private" directory component so we append it here in all
       // cases.
 
       std::string dir_name = curr_fcn->dir_name ();
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -140,26 +140,30 @@ err_file_open (const std::string& fcn, c
 // Install a variable with name NAME and the value VAL in the
 // symbol table.  If GLOBAL is TRUE, make the variable global.
 
 static void
 install_loaded_variable (const std::string& name,
                          const octave_value& val,
                          bool global, const std::string& /*doc*/)
 {
-  symbol_table& symtab = octave::__get_symbol_table__ ("install_loaded_variable");
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("install_loaded_varaible");
+
+  symbol_table::scope *scope
+    = symtab.require_current_scope ("install_loaded_variable");
 
   if (global)
     {
-      symtab.clear (name);
-      symtab.mark_global (name);
+      scope->clear_variable (name);
+      scope->mark_global (name);
       symtab.global_assign (name, val);
     }
   else
-    symtab.assign (name, val);
+    scope->assign (name, val);
 }
 
 // Return TRUE if NAME matches one of the given globbing PATTERNS.
 
 static bool
 matches_patterns (const string_vector& patterns, int pat_idx,
                   int num_pat, const std::string& name)
 {
@@ -1267,22 +1271,27 @@ save_vars (const string_vector& argv, in
     }
   else if (argv[argv_idx] == "-struct")
     {
       if (++argv_idx >= argc)
         error ("save: missing struct name");
 
       std::string struct_name = argv[argv_idx];
 
-      symbol_table& symtab = octave::__get_symbol_table__ ("save_vars");
+      symbol_table::scope *scope = octave::__get_current_scope__ ("save_vars");
+
+      octave_value struct_var;
 
-      if (! symtab.is_variable (struct_name))
-        error ("save: no such variable: '%s'", struct_name.c_str ());
+      if (scope)
+        {
+          if (! scope->is_variable (struct_name))
+            error ("save: no such variable: '%s'", struct_name.c_str ());
 
-      octave_value struct_var = symtab.varval (struct_name);
+          struct_var = scope->varval (struct_name);
+        }
 
       if (! struct_var.isstruct () || struct_var.numel () != 1)
         error ("save: '%s' is not a scalar structure", struct_name.c_str ());
 
       octave_scalar_map struct_var_map = struct_var.scalar_map_value ();
 
       ++argv_idx;
 
@@ -1316,18 +1325,19 @@ save_vars (const string_vector& argv, in
 static void
 dump_octave_core (std::ostream& os, const char *fname, load_save_format fmt,
                   bool save_as_floats)
 {
   write_header (os, fmt);
 
   symbol_table& symtab = octave::__get_symbol_table__ ("dump_octave_core");
 
-  std::list<symbol_table::symbol_record> vars
-    = symtab.all_variables (symtab.top_scope ());
+  symbol_table::scope *top_scope = symtab.top_scope ();
+
+  std::list<symbol_table::symbol_record> vars = top_scope->all_variables ();
 
   double save_mem_size = 0;
 
   for (const auto& var : vars)
     {
       octave_value val = var.varval ();
 
       if (val.is_defined ())
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -3420,19 +3420,20 @@ mexGetVariable (const char *space, const
               octave::call_stack& cs
                 = octave::__get_call_stack__ ("mexGetVariable");
 
               cs.goto_base_frame ();
 
               frame.add_method (cs, &octave::call_stack::pop);
             }
 
-          symbol_table& symtab = octave::__get_symbol_table__ ("mexGetVariable");
-
-          val = symtab.varval (name);
+          symbol_table::scope *scope
+            = octave::__require_current_scope__ ("mexGetVariable");
+
+          val = scope->varval (name);
         }
       else
         mexErrMsgTxt ("mexGetVariable: symbol table does not exist");
     }
 
   if (val.is_defined ())
     {
       retval = mex_context->make_value (val);
@@ -3485,19 +3486,20 @@ mexPutVariable (const char *space, const
               octave::call_stack& cs
                 = octave::__get_call_stack__ ("mexPutVariable");
 
               cs.goto_base_frame ();
 
               frame.add_method (cs, &octave::call_stack::pop);
             }
 
-          symbol_table& symtab = octave::__get_symbol_table__ ("mexPutVariable");
-
-          symtab.assign (name, mxArray::as_octave_value (ptr));
+          symbol_table::scope *scope
+            = octave::__require_current_scope__ ("mexPutVariable");
+
+          scope->assign (name, mxArray::as_octave_value (ptr));
         }
       else
         mexErrMsgTxt ("mexPutVariable: symbol table does not exist");
     }
 
   return 0;
 }
 
diff --git a/libinterp/corefcn/octave-link.cc b/libinterp/corefcn/octave-link.cc
--- a/libinterp/corefcn/octave-link.cc
+++ b/libinterp/corefcn/octave-link.cc
@@ -64,20 +64,23 @@ octave_link::~octave_link (void)
 void
 octave_link::set_workspace (void)
 {
   if (enabled ())
     {
       symbol_table& symtab
         = octave::__get_symbol_table__ ("octave_link::set_workspace");
 
+      std::list<workspace_element> workspace_info;
+      symbol_table::scope *scope = symtab.current_scope ();
+      if (scope)
+        workspace_info = scope->workspace_info ();
 
       instance->do_set_workspace (symtab.at_top_level (),
-                                  instance->debugging,
-                                  symtab.workspace_info ());
+                                  instance->debugging, workspace_info);
     }
 }
 
 // OBJ should be an object of a class that is derived from the base
 // class octave_link, or 0 to disconnect the link.  It is the
 // responsibility of the caller to delete obj.
 
 void
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -52,65 +52,61 @@ along with Octave; see the file COPYING.
 
 octave_value symbol_table::dummy_octave_value;
 
 // Should Octave always check to see if function files have changed
 // since they were last compiled?
 static int Vignore_function_time_stamp = 1;
 
 void
-symbol_table::symbol_record::symbol_record_rep::clear (const scope *sid)
+symbol_table::symbol_record::symbol_record_rep::clear (scope *sid)
 {
   if (! (is_hidden () || is_inherited ())
       && sid == decl_scope ())
     {
       if (is_global ())
         unmark_global ();
 
-      symbol_table& symtab
-        = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::clear");
-
       if (is_persistent ())
         {
-          symtab.persistent_assign (name, varval ());
+          sid->persistent_assign (name, varval ());
 
           unmark_persistent ();
         }
 
       assign (octave_value ());
     }
 }
 
 void
 symbol_table::symbol_record::symbol_record_rep::init_persistent (void)
 {
-  symbol_table& symtab
-    = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::init_persistent");
+  symbol_table::scope *scope
+    = octave::__require_current_scope__ ("symbol_table::symbol_record::symbol_record_rep::init_persistent");
 
   if (! is_defined ())
     {
       mark_persistent ();
 
-      assign (symtab.persistent_varval (name));
+      assign (scope->persistent_varval (name));
     }
   // FIXME: this causes trouble with recursive calls.
   // else
   //   error ("unable to declare existing variable persistent");
 }
 
 void
 symbol_table::symbol_record::symbol_record_rep::erase_persistent (void)
 {
   unmark_persistent ();
 
-  symbol_table& symtab
-    = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::erase_persistent");
+  symbol_table::scope *scope
+    = octave::__require_current_scope__ ("symbol_table::symbol_record::symbol_record_rep::erase_persistent");
 
-
-  symtab.erase_persistent (name);
+  scope->erase_persistent (name);
 }
 
 symbol_table::symbol_record::symbol_record_rep *
 symbol_table::symbol_record::symbol_record_rep::dup (scope *new_scope) const
 {
   return new symbol_record_rep (new_scope, name, varval (), storage_class);
 }
 
@@ -150,40 +146,38 @@ symbol_table::symbol_record::symbol_reco
 
   return (p == symtab.m_global_symbols.end ()
           ? symtab.m_global_symbols[name] : p->second);
 }
 
 octave_value&
 symbol_table::symbol_record::symbol_record_rep::xpersistent_varref (void)
 {
-  symbol_table& symtab
-    = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::xpersistent_varref");
+  symbol_table::scope *scope
+    = octave::__get_current_scope__ ("symbol_table::symbol_record::symbol_record_rep::xpersistent_varref");
 
-  scope *s = symtab.current_scope ();
-
-  return s ? s->persistent_varref (name) : dummy_octave_value;
+  return scope ? scope->persistent_varref (name) : dummy_octave_value;
 }
 
 octave_value
 symbol_table::symbol_record::symbol_record_rep::xglobal_varval (void) const
 {
   symbol_table& symtab
     = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::xglobal_varval");
 
   return symtab.global_varval (name);
 }
 
 octave_value
 symbol_table::symbol_record::symbol_record_rep::xpersistent_varval (void) const
 {
-  symbol_table& symtab
-    = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::xpersistent_varval");
+  symbol_table::scope *scope
+    = octave::__get_current_scope__ ("symbol_table::symbol_record::symbol_record_rep::xpersistent_varval");
 
-  return symtab.persistent_varval (name);
+  return scope ? scope->persistent_varval (name) : octave_value ();
 }
 
 symbol_table::symbol_record::symbol_record (void)
   : rep (new symbol_record_rep (octave::__get_current_scope__ ("symbol_record"),
                                 "", octave_value (), local))
 
 { }
 
@@ -227,19 +221,17 @@ symbol_table::symbol_record::find (const
 }
 
 symbol_table::symbol_record
 symbol_table::dummy_symbol_record (static_cast<symbol_table::scope*> (nullptr));
 
 symbol_table::symbol_reference::symbol_reference (const symbol_record& record)
   : m_scope (0), m_context (0),m_sym (record)
 {
-  symbol_table& symtab = octave::__get_symbol_table__ ("symbol_reference");
-
-  m_scope = symtab.current_scope ();
+  m_scope = octave::__get_current_scope__ ("symbol_reference");
 }
 
 void
 symbol_table::symbol_reference::update (void) const
 {
   symbol_table::scope *curr_scope
     = octave::__get_current_scope__ ("symbol_reference::update");
 
@@ -801,20 +793,20 @@ symbol_table::fcn_info::fcn_info_rep::fi
 }
 
 octave_value
 symbol_table::fcn_info::fcn_info_rep::xfind (const octave_value_list& args,
                                              bool local_funcs)
 {
   if (local_funcs)
     {
-      symbol_table& symtab
-        = octave::__get_symbol_table__ ("symbol_table::fcn_info::fcn_info_rep::xfind");
+      symbol_table::scope *scope
+        = octave::__get_current_scope__ ("symbol_table::fcn_info::fcn_info_rep::xfind");
 
-      octave_user_function *current_fcn = symtab.get_curr_fcn ();
+      octave_user_function *current_fcn = scope ? scope->function () : 0;
 
       // Local function.
 
       if (current_fcn)
         {
           std::string fcn_file = current_fcn->fcn_file_name ();
 
           if (! fcn_file.empty ())
@@ -1005,20 +997,20 @@ symbol_table::fcn_info::fcn_info_rep::x_
 
   // Command-line function.
 
   if (cmdline_function.is_defined ())
     return cmdline_function;
 
   // Private function.
 
-  symbol_table& symtab
-    = octave::__get_symbol_table__ ("symbol_table::fcn_info::fcn_info_rep::x_builtin_find");
+  symbol_table::scope *scope
+    = octave::__get_current_scope__ ("symbol_table::fcn_info::fcn_info_rep::x_builtin_find");
 
-  octave_user_function *current_fcn = symtab.get_curr_fcn ();
+  octave_user_function *current_fcn = scope ? scope->function () : 0;
 
   if (current_fcn)
     {
       std::string dir_name = current_fcn->dir_name ();
 
       if (! dir_name.empty ())
         {
           str_val_iterator q = private_functions.find (dir_name);
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -209,17 +209,17 @@ public:
             retval = value_stack.size ();
           }
 
         return retval;
       }
 
       void clear (void) { clear (decl_scope ()); }
 
-      void clear (const scope *sid);
+      void clear (scope *sid);
 
       bool is_defined (void) const
       {
         return varval ().is_defined ();
       }
 
       bool is_valid (void) const
       {
@@ -274,17 +274,17 @@ public:
 
       void invalidate (void)
       {
         valid = false;
       }
 
       void erase_persistent (void);
 
-      const scope *decl_scope (void) const { return m_decl_scope; }
+      scope *decl_scope (void) { return m_decl_scope; }
 
       void set_curr_fcn (octave_user_function *fcn)
       {
         curr_fcn = fcn;
       }
 
       symbol_record_rep * dup (scope *new_scope) const;
 
@@ -406,17 +406,17 @@ public:
     }
 
     void push_context (scope *sid) { rep->push_context (sid); }
 
     size_t pop_context (scope *sid) { return rep->pop_context (sid); }
 
     void clear (void) { rep->clear (); }
 
-    void clear (const scope *sid) { rep->clear (sid); }
+    void clear (scope *sid) { rep->clear (sid); }
 
     bool is_defined (void) const
     {
       return rep->is_defined ();
     }
 
     bool is_undefined (void) const
     {
@@ -461,17 +461,17 @@ public:
     void unmark_added_static (void) { rep->unmark_added_static (); }
 
     void init_persistent (void) { rep->init_persistent (); }
 
     void erase_persistent (void) { rep->erase_persistent (); }
 
     void invalidate (void) { rep->invalidate (); }
 
-    const scope *decl_scope (void) const { return rep->decl_scope (); }
+    scope *decl_scope (void) { return rep->decl_scope (); }
 
     unsigned int xstorage_class (void) const { return rep->storage_class; }
 
     void set_curr_fcn (octave_user_function *fcn) { rep->set_curr_fcn (fcn); }
 
     void
     dump (std::ostream& os, const std::string& prefix = "") const
     {
@@ -900,16 +900,24 @@ public:
       delete m_global_scope;
     }
 
   scope *global_scope (void) { return m_global_scope; }
   scope *top_scope (void) { return m_top_scope; }
 
   scope *current_scope (void) { return m_current_scope; }
 
+  scope *require_current_scope (const std::string& who)
+  {
+    if (! m_current_scope)
+      error ("%s: missing scope", who.c_str ());
+
+    return m_current_scope;
+  }
+
   context_id current_context (void) const
   {
     return m_current_scope ? m_current_scope->current_context () : 0;
   }
 
   void set_scope (scope *sid)
   {
     set_scope_and_context (sid, 0);
@@ -934,78 +942,35 @@ public:
   symbol_record find_symbol (const std::string& name)
   {
     return find_symbol (name, m_current_scope);
   }
 
   void inherit (scope *recipient_scope, scope *donor_scope)
   {
     if (recipient_scope)
-      {
-        while (donor_scope)
-          {
-            recipient_scope->inherit (*donor_scope);
-
-            if (donor_scope->is_nested ())
-              donor_scope = donor_scope->parent_scope ();
-            else
-              break;
-          }
-      }
+      recipient_scope->inherit (donor_scope);
   }
 
-  void inherit (scope *sid)
+  void inherit (scope *recipient_scope)
   {
-    inherit (sid, m_current_scope);
+    inherit (recipient_scope, m_current_scope);
   }
 
   bool at_top_level (void) { return m_current_scope == m_top_scope; }
 
   // Find a value corresponding to the given name in the table.
   octave_value
     find (const std::string& name,
           const octave_value_list& args = octave_value_list (),
           bool skip_variables = false,
           bool local_funcs = true);
 
   octave_value builtin_find (const std::string& name);
 
-  void rename (const std::string& old_name, const std::string& new_name)
-  {
-    if (m_current_scope)
-      m_current_scope->rename (old_name, new_name);
-  }
-
-  void assign (const std::string& name,
-               const octave_value& value = octave_value ())
-  {
-    m_current_scope->assign (name, value);
-  }
-
-  // Convenience function to simplify
-  // octave_user_function::bind_automatic_vars
-
-  void force_assign (const std::string& name, const octave_value& value,
-                     scope *sid)
-  {
-    if (sid)
-      sid->assign (name, value, true);
-  }
-
-  void force_assign (const std::string& name,
-                     const octave_value& value = octave_value ())
-  {
-    m_current_scope->assign (name, value);
-  }
-
-  octave_value varval (const std::string& name)
-  {
-    return m_current_scope->varval (name);
-  }
-
   void
   global_assign (const std::string& name,
                  const octave_value& value = octave_value ())
 
   {
     global_symbols_iterator p = m_global_symbols.find (name);
 
     if (p == m_global_symbols.end ())
@@ -1030,41 +995,16 @@ public:
   }
 
   octave_value
   top_level_varval (const std::string& name)
   {
     return m_top_scope->varval (name);
   }
 
-  void
-    persistent_assign (const std::string& name,
-                       const octave_value& value = octave_value ())
-  {
-    if (m_current_scope)
-      m_current_scope->persistent_assign (name, value);
-  }
-
-  octave_value persistent_varval (const std::string& name)
-  {
-    return (m_current_scope
-            ? m_current_scope->persistent_varval (name) : octave_value ());
-  }
-
-  void erase_persistent (const std::string& name)
-  {
-    if (m_current_scope)
-      m_current_scope->erase_persistent (name);
-  }
-
-  bool is_variable (const std::string& name)
-  {
-    return m_current_scope ? m_current_scope->is_variable (name) : false;
-  }
-
   bool
     is_built_in_function_name (const std::string& name)
   {
     octave_value val = find_built_in_function (name);
 
     return val.is_defined ();
   }
 
@@ -1156,39 +1096,16 @@ public:
         fcn_info finfo (name);
 
         finfo.install_cmdline_function (fcn);
 
         m_fcn_table[name] = finfo;
       }
   }
 
-  // Install subfunction FCN named NAME.  SCOPE is the scope of the
-  // primary function corresponding to this subfunction.
-
-  void install_subfunction (const std::string& name, const octave_value& fcn,
-                            scope *parent_scope)
-  {
-    if (parent_scope)
-      parent_scope->install_subfunction (name, fcn);
-  }
-
-  void install_nestfunction (const std::string& name, const octave_value& fcn,
-                             scope *parent_scope)
-  {
-    if (parent_scope)
-      parent_scope->install_subfunction (name, fcn, true);
-  }
-
-  void update_nest (scope *sid)
-  {
-    if (sid)
-      sid->update_nest ();
-  }
-
   // Install local function FCN named NAME.  FILE_NAME is the name of
   // the file containing the local function.
 
   void install_local_function (const std::string& name,
                                const octave_value& fcn,
                                const std::string& file_name)
   {
     fcn_table_iterator p = m_fcn_table.find (name);
@@ -1246,81 +1163,51 @@ public:
         fcn_info finfo (name);
 
         finfo.install_built_in_function (fcn);
 
         m_fcn_table[name] = finfo;
       }
   }
 
-  void clear (const std::string& name)
-  {
-    clear_variable (name);
-  }
-
   void clear_all (bool force = false)
   {
-    clear_variables ();
-
-    clear_global_pattern ("*");
+    if (m_current_scope)
+      {
+        m_current_scope->clear_variables ();
+        m_current_scope->clear_global_pattern ("*");
+      }
 
     clear_functions (force);
   }
 
   // This is written as two separate functions instead of a single
   // function with default values so that it will work properly with
   // unwind_protect.
 
-  void clear_variables (scope *sid)
-  {
-    if (sid)
-      sid->clear_variables ();
-  }
-
-  void clear_variables (void)
-  {
-    clear_variables (m_current_scope);
-  }
-
-  void clear_objects (void)
-  {
-    if (m_current_scope)
-      m_current_scope->clear_objects ();
-  }
-
   void clear_functions (bool force = false)
   {
     fcn_table_iterator p = m_fcn_table.begin ();
 
     while (p != m_fcn_table.end ())
       (p++)->second.clear (force);
   }
 
   void clear_function (const std::string& name)
   {
     clear_user_function (name);
   }
 
-  void clear_global (const std::string& name)
-  {
-    if (m_current_scope)
-      m_current_scope->clear_global (name);
-  }
-
-  void clear_variable (const std::string& name)
-  {
-    if (m_current_scope)
-      m_current_scope->clear_variable (name);
-  }
-
   void clear_symbol (const std::string& name)
   {
     // FIXME: are we supposed to do both here?
 
-    clear_variable (name);
+    if (m_current_scope)
+      m_current_scope->clear_variable (name);
+
     clear_function (name);
   }
 
   void clear_function_pattern (const std::string& pat)
   {
     glob_match pattern (pat);
 
     fcn_table_iterator p = m_fcn_table.begin ();
@@ -1329,39 +1216,23 @@ public:
       {
         if (pattern.match (p->first))
           (p++)->second.clear_user_function ();
         else
           p++;
       }
   }
 
-  void clear_global_pattern (const std::string& pat)
-  {
-    if (m_current_scope)
-      m_current_scope->clear_global_pattern (pat);
-  }
-
-  void clear_variable_pattern (const std::string& pat)
-  {
-    if (m_current_scope)
-      m_current_scope->clear_variable_pattern (pat);
-  }
-
-  void clear_variable_regexp (const std::string& pat)
-  {
-    if (m_current_scope)
-      m_current_scope->clear_variable_regexp (pat);
-  }
-
   void clear_symbol_pattern (const std::string& pat)
   {
     // FIXME: are we supposed to do both here?
 
-    clear_variable_pattern (pat);
+    if (m_current_scope)
+      m_current_scope->clear_variable_pattern (pat);
+
     clear_function_pattern (pat);
   }
 
   void clear_user_function (const std::string& name)
   {
     fcn_table_iterator p = m_fcn_table.find (name);
 
     if (p != m_fcn_table.end ())
@@ -1455,55 +1326,16 @@ public:
     if (m_current_scope)
       m_current_scope->pop_context ();
   }
 
   // For unwind_protect where a pointer argument is needed.
 
   void pop_context (void *) { pop_context (); }
 
-  void mark_hidden (const std::string& name)
-  {
-    if (m_current_scope)
-      m_current_scope->mark_hidden (name);
-  }
-
-  void mark_global (const std::string& name)
-  {
-    if (m_current_scope)
-      m_current_scope->mark_global (name);
-  }
-
-  // exclude: Storage classes to exclude, you can OR them together
-  std::list<symbol_record>
-  all_variables (scope *sid, bool defined_only, unsigned int exclude)
-  {
-    return (sid
-            ? sid->all_variables (defined_only, exclude)
-            : std::list<symbol_record> ());
-  }
-
-  std::list<symbol_record>
-  all_variables (scope *sid, bool defined_only)
-  {
-    return all_variables (sid, defined_only, symbol_record::hidden);
-  }
-
-  std::list<symbol_record>
-  all_variables (scope *sid)
-  {
-    return all_variables (sid, true);
-  }
-
-  std::list<symbol_record>
-  all_variables (void)
-  {
-    return all_variables (m_current_scope);
-  }
-
   std::list<symbol_record> glob (const std::string& pattern)
   {
     return (m_current_scope
             ? m_current_scope->glob (pattern) : std::list<symbol_record> ());
   }
 
   std::list<symbol_record>
   glob_global_variables (const std::string& pattern)
@@ -1650,57 +1482,22 @@ public:
       }
 
     if (! retval.empty ())
       retval.sort ();
 
     return retval;
   }
 
-  bool is_local_variable (const std::string& name)
-  {
-    return m_current_scope ? m_current_scope->is_local_variable (name) : false;
-  }
-
-  bool is_global (const std::string& name)
-  {
-    return m_current_scope ? m_current_scope->is_global (name) : false;
-  }
-
-  std::list<workspace_element> workspace_info (void)
-  {
-    return (m_current_scope
-            ? m_current_scope->workspace_info ()
-            : std::list<workspace_element> ());
-  }
-
   void dump (std::ostream& os, scope *sid);
 
   void dump_global (std::ostream& os);
 
   void dump_functions (std::ostream& os);
 
-  void cache_name (scope *sid, const std::string& name)
-  {
-    if (sid)
-      sid->cache_name (name);
-  }
-  void stash_dir_name_for_subfunctions (scope *sid,
-                                        const std::string& dir_name)
-  {
-    if (sid)
-      sid->stash_dir_name_for_subfunctions (dir_name);
-  }
-
-  void set_parent (scope *child_scope, scope *parent_scope)
-  {
-    if (child_scope)
-      child_scope->set_parent (parent_scope);
-  }
-
   void add_to_parent_map (const std::string& classname,
                           const std::list<std::string>& parent_list)
   {
     m_parent_map[classname] = parent_list;
   }
 
   std::list<std::string>
   parent_classes (const std::string& dispatch_type)
@@ -1798,17 +1595,17 @@ public:
       table_iterator p = m_symbols.find (name);
 
       if (p == m_symbols.end ())
         return insert (name);
       else
         return p->second;
     }
 
-    void inherit (scope& donor_scope)
+    void inherit_internal (scope& donor_scope)
     {
       for (auto& nm_sr : m_symbols)
         {
           symbol_table::symbol_record& sr = nm_sr.second;
 
           if (! (sr.is_automatic () || sr.is_formal ()))
             {
               std::string nm = sr.name ();
@@ -1823,16 +1620,30 @@ public:
 
                       sr.mark_inherited ();
                     }
                 }
             }
         }
     }
 
+    void inherit (scope *donor_scope)
+    {
+      while (donor_scope)
+        {
+          inherit_internal (*donor_scope);
+
+          if (donor_scope->is_nested ())
+            donor_scope = donor_scope->parent_scope ();
+          else
+            break;
+        }
+    }
+
+
     octave_value
     find (const std::string& name, const octave_value_list& args,
           bool skip_variables, bool local_funcs);
 
     octave_value builtin_find (const std::string& name);
 
     symbol_table::symbol_record&
     insert (const std::string& name, bool force_add = false);
@@ -2054,17 +1865,18 @@ public:
     }
 
     void mark_global (const std::string& name)
     {
       insert (name).mark_global ();
     }
 
     std::list<symbol_table::symbol_record>
-    all_variables (bool defined_only, unsigned int exclude) const
+    all_variables (bool defined_only = true,
+                   unsigned int exclude = symbol_table::symbol_record::hidden) const
     {
       std::list<symbol_table::symbol_record> retval;
 
       for (const auto& nm_sr : m_symbols)
         {
           const symbol_table::symbol_record& sr = nm_sr.second;
 
           if ((defined_only && ! sr.is_defined ())
@@ -2153,16 +1965,22 @@ public:
 
       return p != m_symbols.end () && p->second.is_global ();
     }
 
     void install_subfunction (const std::string& name,
                               const octave_value& fval,
                               bool is_nested = false);
 
+    void install_nestfunction (const std::string& name,
+                               const octave_value& fval)
+    {
+      install_subfunction (name, fval, true);
+    }
+
     octave_value find_subfunction (const std::string& name) const;
 
     void lock_subfunctions (void)
     {
       for (auto& nm_sf : m_subfunctions)
         nm_sf.second.lock ();
     }
 
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -84,19 +84,21 @@ clear_function (const std::string& nm)
   symbol_table& symtab = octave::__get_symbol_table__ ("clear_function");
 
   symtab.clear_function (nm);
 }
 
 void
 clear_variable (const std::string& nm)
 {
-  symbol_table& symtab = octave::__get_symbol_table__ ("clear_variable");
-
-  symtab.clear_variable (nm);
+  symbol_table::scope *scope
+    = octave::__get_current_scope__ ("clear_variable");
+
+  if (scope)
+    scope->clear_variable (nm);
 }
 
 void
 clear_symbol (const std::string& nm)
 {
   symbol_table& symtab = octave::__get_symbol_table__ ("clear_symbol");
 
   symtab.clear_symbol (nm);
@@ -230,19 +232,20 @@ get_struct_elts (const std::string& text
 
 static inline bool
 is_variable (const std::string& name)
 {
   bool retval = false;
 
   if (! name.empty ())
     {
-      symbol_table& symtab = octave::__get_symbol_table__ ("is_variable");
-
-      octave_value val = symtab.varval (name);
+      symbol_table::scope *scope
+        = octave::__get_current_scope__ ("is_variable");
+
+      octave_value val = scope ? scope->varval (name) : octave_value ();
 
       retval = val.is_defined ();
     }
 
   return retval;
 }
 
 string_vector
@@ -351,21 +354,21 @@ static octave_value
 do_isglobal (const octave_value_list& args)
 {
   if (args.length () != 1)
     print_usage ();
 
   if (! args(0).is_string ())
     error ("isglobal: NAME must be a string");
 
-  symbol_table& symtab = octave::__get_symbol_table__ ("do_isglobal");
+  symbol_table::scope *scope = octave::__get_current_scope__ ("do_isglobal");
 
   std::string name = args(0).string_value ();
 
-  return symtab.is_global (name);
+  return scope && scope->is_global (name);
 }
 
 DEFUN (isglobal, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} isglobal (@var{name})
 Return true if @var{name} is a globally visible variable.
 
 For example:
@@ -409,17 +412,19 @@ symbol_exist (const std::string& name, c
   if (! (search_any || search_var || search_dir || search_file ||
          search_builtin || search_class))
     error ("exist: unrecognized type argument \"%s\"", type.c_str ());
 
   symbol_table& symtab = octave::__get_symbol_table__ ("symbol_exist");
 
   if (search_any || search_var)
     {
-      octave_value val = symtab.varval (name);
+      symbol_table::scope *scope = symtab.current_scope ();
+
+      octave_value val = scope ? scope->varval (name) : octave_value ();
 
       if (val.is_constant () || val.isobject ()
           || val.is_function_handle ()
           || val.is_anonymous_function ()
           || val.is_inline_function ())
         return 1;
 
       if (search_var)
@@ -690,19 +695,20 @@ them.
 %!error <NAME must be a string> exist (1)
 %!error <unrecognized type argument "foobar"> exist ("a", "foobar")
 
 */
 
 octave_value
 lookup_function_handle (const std::string& nm)
 {
-  symbol_table& symtab = octave::__get_symbol_table__ ("lookup_function_handle");
-
-  octave_value val = symtab.varval (nm);
+  symbol_table::scope *scope
+    = octave::__get_current_scope__ ("lookup_function_handle");
+
+  octave_value val = scope ? scope->varval (nm) : octave_value ();
 
   return val.is_function_handle () ? val : octave_value ();
 }
 
 octave_value
 get_global_value (const std::string& nm, bool silent)
 {
   symbol_table& symtab = octave::__get_symbol_table__ ("get_global_value");
@@ -1701,17 +1707,17 @@ do_who (octave::interpreter& interp, int
 
           symbol_table::scope tmp_scope;
 
           symtab.set_scope (&tmp_scope);
 
           cs.push (&tmp_scope, 0);
           frame.add_method (cs, &octave::call_stack::pop);
 
-          frame.add_method (symtab, &symbol_table::clear_variables);
+          frame.add_method (tmp_scope, &symbol_table::scope::clear_variables);
 
           octave::feval ("load", octave_value (nm), 0);
 
           std::string newmsg = std::string ("Variables in the file ")
                                + nm + ":\n\n";
 
           retval = do_who (interp, i, argv, return_list, verbose, newmsg);
 
@@ -1740,25 +1746,28 @@ do_who (octave::interpreter& interp, int
     {
       pats.resize (++npats);
       pats[0] = "*";
     }
 
   symbol_info_list symbol_stats;
   std::list<std::string> symbol_names;
 
+  symbol_table::scope *scope = symtab.current_scope ();
+
   for (int j = 0; j < npats; j++)
     {
       std::string pat = pats[j];
 
       if (have_regexp)
         {
-          std::list<symbol_table::symbol_record> tmp = global_only
-            ? symtab.regexp_global_variables (pat)
-            : symtab.regexp_variables (pat);
+          std::list<symbol_table::symbol_record> tmp
+            = (global_only
+               ? symtab.regexp_global_variables (pat)
+               : symtab.regexp_variables (pat));
 
           for (const auto& symrec : tmp)
             {
               if (symrec.is_variable ())
                 {
                   if (verbose)
                     symbol_stats.append (symrec);
                   else
@@ -1778,17 +1787,17 @@ do_who (octave::interpreter& interp, int
                   // expressions based on global values if the variable is
                   // global in the current scope because we currently have
                   // no way of looking up the base value in the global
                   // scope and then evaluating the arguments in the
                   // current scope.
 
                   std::string base_name = pat.substr (0, pos);
 
-                  if (symtab.is_variable (base_name))
+                  if (scope && scope->is_variable (base_name))
                     {
                       symbol_table::symbol_record sr
                         = symtab.find_symbol (base_name);
 
                       if (! global_only || sr.is_global ())
                         {
                           int parse_status;
 
@@ -1797,19 +1806,20 @@ do_who (octave::interpreter& interp, int
 
                           symbol_stats.append (sr, pat, expr_val);
                         }
                     }
                 }
             }
           else
             {
-              std::list<symbol_table::symbol_record> tmp = global_only
-                ? symtab.glob_global_variables (pat)
-                : symtab.glob_variables (pat);
+              std::list<symbol_table::symbol_record> tmp
+                = (global_only
+                   ? symtab.glob_global_variables (pat)
+                   : symtab.glob_variables (pat));
 
               for (const auto& symrec : tmp)
                 {
                   if (symrec.is_variable ())
                     {
                       if (verbose)
                         symbol_stats.append (symrec);
                       else
@@ -1985,19 +1995,21 @@ bind_ans (const octave_value& val, bool 
         {
           octave_value_list lst = val.list_value ();
 
           for (octave_idx_type i = 0; i < lst.length (); i++)
             bind_ans (lst(i), print);
         }
       else
         {
-          symbol_table& symtab = octave::__get_symbol_table__ ("bind_ans");
-
-          symtab.force_assign (ans, val);
+          symbol_table::scope *scope
+            = octave::__get_current_scope__ ("bind_ans");
+
+          if (scope)
+            scope->force_assign (ans, val);
 
           if (print)
             {
               octave_value_list args = ovl (val);
               args.stash_name_tags (string_vector (ans));
               octave::feval ("display", args);
             }
         }
@@ -2236,93 +2248,107 @@ do_clear_functions (const string_vector&
 }
 
 static void
 do_clear_globals (const string_vector& argv, int argc, int idx,
                   bool exclusive = false)
 {
   symbol_table& symtab = octave::__get_symbol_table__ ("do_clear_globals");
 
+  symbol_table::scope *scope = symtab.current_scope ();
+
+  if (! scope)
+    return;
+
   if (idx == argc)
     {
       string_vector gvars = symtab.global_variable_names ();
 
       int gcount = gvars.numel ();
 
       for (int i = 0; i < gcount; i++)
-        symtab.clear_global (gvars[i]);
+        scope->clear_global (gvars[i]);
     }
   else
     {
       if (exclusive)
         {
           string_vector gvars = symtab.global_variable_names ();
 
           int gcount = gvars.numel ();
 
           for (int i = 0; i < gcount; i++)
             {
               std::string nm = gvars[i];
 
               if (! name_matches_any_pattern (nm, argv, argc, idx))
-                symtab.clear_global (nm);
+                scope->clear_global (nm);
             }
         }
       else
         {
           while (idx < argc)
-            symtab.clear_global_pattern (argv[idx++]);
+            scope->clear_global_pattern (argv[idx++]);
         }
     }
 }
 
 static void
 do_clear_variables (const string_vector& argv, int argc, int idx,
                     bool exclusive = false, bool have_regexp = false)
 {
-  symbol_table& symtab = octave::__get_symbol_table__ ("do_clear_variables");
+  symbol_table::scope *scope
+    = octave::__get_current_scope__ ("do_clear_variables");
+
+  if (! scope)
+    return;
 
   if (idx == argc)
-    symtab.clear_variables ();
+    scope->clear_variables ();
   else
     {
       if (exclusive)
         {
-          string_vector lvars = symtab.variable_names ();
+          string_vector lvars = scope->variable_names ();
 
           int lcount = lvars.numel ();
 
           for (int i = 0; i < lcount; i++)
             {
               std::string nm = lvars[i];
 
               if (! name_matches_any_pattern (nm, argv, argc, idx, have_regexp))
-                symtab.clear_variable (nm);
+                scope->clear_variable (nm);
             }
         }
       else
         {
           if (have_regexp)
             while (idx < argc)
-              symtab.clear_variable_regexp (argv[idx++]);
+              scope->clear_variable_regexp (argv[idx++]);
           else
             while (idx < argc)
-              symtab.clear_variable_pattern (argv[idx++]);
+              scope->clear_variable_pattern (argv[idx++]);
         }
     }
 }
 
 static void
 do_clear_symbols (const string_vector& argv, int argc, int idx,
                   bool exclusive = false)
 {
   symbol_table& symtab = octave::__get_symbol_table__ ("do_clear_symbols");
 
   if (idx == argc)
-    symtab.clear_variables ();
+    {
+      symbol_table::scope *scope = symtab.current_scope ();
+
+      if (scope)
+        scope->clear_variables ();
+    }
   else
     {
       if (exclusive)
         {
           // FIXME: is this really what we want, or do we
           // somehow want to only clear the functions that are not
           // shadowed by local variables?  It seems that would be a
           // bit harder to do.
@@ -2338,44 +2364,50 @@ do_clear_symbols (const string_vector& a
     }
 }
 
 static void
 do_matlab_compatible_clear (const string_vector& argv, int argc, int idx)
 {
   // This is supposed to be mostly Matlab compatible.
 
-  symbol_table& symtab = octave::__get_symbol_table__ ("do_matlab_compatible_clear");
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("do_matlab_compatible_clear");
+
+  symbol_table::scope *scope = symtab.current_scope ();
+
+  if (! scope)
+    return;
 
   for (; idx < argc; idx++)
     {
       if (argv[idx] == "all"
-          && ! symtab.is_local_variable ("all"))
+          && ! scope->is_local_variable ("all"))
         {
           symtab.clear_all ();
         }
       else if (argv[idx] == "functions"
-               && ! symtab.is_local_variable ("functions"))
+               && ! scope->is_local_variable ("functions"))
         {
           do_clear_functions (argv, argc, ++idx);
         }
       else if (argv[idx] == "global"
-               && ! symtab.is_local_variable ("global"))
+               && ! scope->is_local_variable ("global"))
         {
           do_clear_globals (argv, argc, ++idx);
         }
       else if (argv[idx] == "variables"
-               && ! symtab.is_local_variable ("variables"))
+               && ! scope->is_local_variable ("variables"))
         {
-          symtab.clear_variables ();
+          scope->clear_variables ();
         }
       else if (argv[idx] == "classes"
-               && ! symtab.is_local_variable ("classes"))
+               && ! scope->is_local_variable ("classes"))
         {
-          symtab.clear_objects ();
+          scope->clear_objects ();
           octave_class::clear_exemplar_map ();
           symtab.clear_all ();
         }
       else
         {
           symtab.clear_symbol_pattern (argv[idx]);
         }
     }
@@ -2483,16 +2515,17 @@ without the dash as well.
       bool clear_globals = false;
       bool clear_variables = false;
       bool clear_objects = false;
       bool exclusive = false;
       bool have_regexp = false;
       bool have_dash_option = false;
 
       symbol_table& symtab = interp.get_symbol_table ();
+      symbol_table::scope *scope = symtab.current_scope ();
 
       while (++idx < argc)
         {
           if (argv[idx] == "-all" || argv[idx] == "-a")
             {
               CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
 
               have_dash_option = true;
@@ -2570,17 +2603,18 @@ without the dash as well.
                   do_clear_globals (argv, argc, idx, exclusive);
                 }
               else if (clear_variables)
                 {
                   do_clear_variables (argv, argc, idx, exclusive);
                 }
               else if (clear_objects)
                 {
-                  symtab.clear_objects ();
+                  if (scope)
+                    scope->clear_objects ();
                   octave_class::clear_exemplar_map ();
                   symtab.clear_all ();
                 }
               else
                 {
                   do_clear_symbols (argv, argc, idx, exclusive);
                 }
             }
@@ -2721,19 +2755,19 @@ DEFMETHOD (__varval__, interp, args, ,
 Return the value of the variable @var{name} directly from the symbol table.
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
   std::string name = args(0).xstring_value ("__varval__: first argument must be a variable name");
 
-  symbol_table& symtab = interp.get_symbol_table ();
-
-  return symtab.varval (args(0).string_value ());
+  symbol_table::scope *scope = interp.get_current_scope ();
+
+  return scope ? scope->varval (args(0).string_value ()) : octave_value ();
 }
 
 static std::string Vmissing_component_hook;
 
 DEFUN (missing_component_hook, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{val} =} missing_component_hook ()
 @deftypefnx {} {@var{old_val} =} missing_component_hook (@var{new_val})
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -1090,20 +1090,20 @@ public:
         if (! is_direct_superclass (cls, ctx))
           error ("`%s' is not a direct superclass of `%s'",
                  cname.c_str (), ctx.get_name ().c_str ());
 
         if (! is_constructed_object (mname))
           error ("cannot call superclass constructor with variable `%s'",
                  mname.c_str ());
 
-        symbol_table& symtab
-          = octave::__get_symbol_table__ ("octave_classdef_superclass_ref::call");
-
-        octave_value sym = symtab.varval (mname);
+        symbol_table::scope *scope
+          = octave::__require_current_scope__ ("octave_classdef_superclass_ref::call");
+
+        octave_value sym = scope->varval (mname);
 
         cls.run_constructor (to_cdef_ref (sym), idx);
 
         retval(0) = sym;
       }
     else
       {
         if (mname != meth_name)
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -81,19 +81,20 @@ const std::string octave_fcn_handle::ano
 octave_fcn_handle::octave_fcn_handle (const octave_value& f,
                                       const std::string& n)
   : fcn (f), nm (n), has_overloads (false)
 {
   octave_user_function *uf = fcn.user_function_value (true);
 
   if (uf && nm != anonymous)
     {
-      symbol_table& symtab = octave::__get_symbol_table__ ("octave_fcn_handle");
+      symbol_table::scope *uf_scope = uf->scope ();
 
-      symtab.cache_name (uf->scope (), nm);
+      if (uf_scope)
+        uf_scope->cache_name (nm);
     }
 
   if (uf && uf->is_nested_function () && ! uf->is_subfunction ())
     error ("handles to nested functions are not yet supported");
 }
 
 octave_value_list
 octave_fcn_handle::subsref (const std::string& type,
@@ -346,23 +347,22 @@ octave_fcn_handle::save_ascii (std::ostr
       os << nm << "\n";
 
       print_raw (os, true);
       os << "\n";
 
       if (fcn.is_undefined ())
         return false;
 
-      octave_user_function *f = fcn.user_function_value ();
+      std::list<symbol_table::symbol_record> vars;
 
-      symbol_table& symtab
-        = octave::__get_symbol_table__ ("octave_fcn_handle::save_ascii");
-
-      std::list<symbol_table::symbol_record> vars
-        = symtab.all_variables (f->scope ());
+      octave_user_function *f = fcn.user_function_value ();
+      symbol_table::scope *f_scope = f->scope ();
+      if (f_scope)
+        vars = f_scope->all_variables ();
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         {
           os << "# length: " << varlen << "\n";
 
           for (const auto& symrec : vars)
@@ -484,17 +484,22 @@ octave_fcn_handle::load_ascii (std::istr
 
               if (fh)
                 {
                   fcn = fh->fcn;
 
                   octave_user_function *uf = fcn.user_function_value (true);
 
                   if (uf)
-                    symtab.cache_name (uf->scope (), nm);
+                    {
+                      symbol_table::scope *uf_scope = uf->scope ();
+
+                      if (uf_scope)
+                        uf_scope->cache_name (nm);
+                    }
                 }
               else
                 success = false;
             }
           else
             success = false;
         }
       else
@@ -511,23 +516,22 @@ octave_fcn_handle::save_binary (std::ost
 {
   if (nm == anonymous)
     {
       std::ostringstream nmbuf;
 
       if (fcn.is_undefined ())
         return false;
 
-      octave_user_function *f = fcn.user_function_value ();
+      std::list<symbol_table::symbol_record> vars;
 
-      symbol_table& symtab
-        = octave::__get_symbol_table__ ("octave_fcn_handle::save_binary");
-
-      std::list<symbol_table::symbol_record> vars
-        = symtab.all_variables (f->scope ());
+      octave_user_function *f = fcn.user_function_value ();
+      symbol_table::scope *f_scope = f->scope ();
+      if (f_scope)
+        vars = f_scope->all_variables ();
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         nmbuf << nm << " " << varlen;
       else
         nmbuf << nm;
 
@@ -666,17 +670,22 @@ octave_fcn_handle::load_binary (std::ist
 
               if (fh)
                 {
                   fcn = fh->fcn;
 
                   octave_user_function *uf = fcn.user_function_value (true);
 
                   if (uf)
-                    symtab.cache_name (uf->scope (), nm);
+                    {
+                      symbol_table::scope *uf_scope = uf->scope ();
+
+                      if (uf_scope)
+                        uf_scope->cache_name (nm);
+                    }
                 }
               else
                 success = false;
             }
           else
             success = false;
         }
     }
@@ -789,23 +798,22 @@ octave_fcn_handle::save_hdf5 (octave_hdf
           H5Sclose (space_hid);
           H5Tclose (type_hid);
           H5Gclose (group_hid);
           return false;
         }
 
       H5Dclose (data_hid);
 
-      octave_user_function *f = fcn.user_function_value ();
+      std::list<symbol_table::symbol_record> vars;
 
-      symbol_table& symtab
-        = octave::__get_symbol_table__ ("octave_fcn_handle::load_hdf5");
-
-      std::list<symbol_table::symbol_record> vars
-        = symtab.all_variables (f->scope ());
+      octave_user_function *f = fcn.user_function_value ();
+      symbol_table::scope *f_scope = f->scope ();
+      if (f_scope)
+        vars = f_scope->all_variables ();
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         {
           hid_t as_id = H5Screate (H5S_SCALAR);
 
           if (as_id >= 0)
@@ -1197,17 +1205,22 @@ octave_fcn_handle::load_hdf5 (octave_hdf
 
               if (fh)
                 {
                   fcn = fh->fcn;
 
                   octave_user_function *uf = fcn.user_function_value (true);
 
                   if (uf)
-                    symtab.cache_name (uf->scope (), nm);
+                    {
+                      symbol_table::scope *uf_scope = uf->scope ();
+
+                      if (uf_scope)
+                        uf_scope->cache_name (nm);
+                    }
                 }
               else
                 success = false;
             }
           else
             success = false;
         }
 
@@ -1690,18 +1703,18 @@ make_fcn_handle (const std::string& nm, 
 %!      ">", "gt";
 %!      "&", "and";
 %!      "|", "or"};
 %! for i = 1:rows (x)
 %!   assert (functions (str2func (x{i,1})).function, x{i,2});
 %! endfor
 */
 
-DEFMETHOD (functions, interp, args, ,
-           doc: /* -*- texinfo -*-
+DEFUN (functions, args, ,
+       doc: /* -*- texinfo -*-
 @deftypefn {} {@var{s} =} functions (@var{fcn_handle})
 Return a structure containing information about the function handle
 @var{fcn_handle}.
 
 The structure @var{s} always contains these three fields:
 
 @table @asis
 @item function
@@ -1786,22 +1799,22 @@ particular output format.
     }
 
   std::string nm = fcn->fcn_file_name ();
 
   if (fh_nm == octave_fcn_handle::anonymous)
     {
       m.setfield ("file", nm);
 
-      octave_user_function *fu = fh->user_function_value ();
+      std::list<symbol_table::symbol_record> vars;
 
-      symbol_table& symtab = interp.get_symbol_table ();
-
-      std::list<symbol_table::symbol_record> vars
-        = symtab.all_variables (fu->scope ());
+      octave_user_function *fu = fh->user_function_value ();
+      symbol_table::scope *fu_scope = fu->scope ();
+      if (fu_scope)
+        vars = fu_scope->all_variables ();
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         {
           octave_scalar_map ws;
           for (const auto& symrec : vars)
             ws.assign (symrec.name (), symrec.varval ());
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -820,17 +820,18 @@ Programming Note: @code{nargin} does not
       octave::tree_parameter_list *param_list = fcn->parameter_list ();
 
       retval = (param_list ? param_list->length () : 0);
       if (fcn->takes_varargs ())
         retval = -1 - retval;
     }
   else
     {
-      retval = symtab.varval (".nargin.");
+      symbol_table::scope *scope = symtab.require_current_scope ("nargin");
+      retval = scope->varval (".nargin.");
 
       if (retval.is_undefined ())
         retval = 0;
     }
 
   return retval;
 }
 
@@ -945,17 +946,18 @@ returns -1 for all anonymous functions.
       if (fcn->takes_var_return ())
         retval = -1 - retval;
     }
   else
     {
       if (symtab.at_top_level ())
         error ("nargout: invalid call at top level");
 
-      retval = symtab.varval (".nargout.");
+      symbol_table::scope *scope = symtab.require_current_scope ("nargout");
+      retval = scope->varval (".nargout.");
 
       if (retval.is_undefined ())
         retval = 0;
     }
 
   return retval;
 }
 
@@ -1017,20 +1019,22 @@ element-by-element and a logical array i
   if (args.length () != 1)
     print_usage ();
 
   symbol_table& symtab = interp.get_symbol_table ();
 
   if (symtab.at_top_level ())
     error ("isargout: invalid call at top level");
 
-  int nargout1 = symtab.varval (".nargout.").int_value ();
+  symbol_table::scope *scope = symtab.require_current_scope ("isargout");
+
+  int nargout1 = scope->varval (".nargout.").int_value ();
 
   Matrix ignored;
-  octave_value tmp = symtab.varval (".ignored.");
+  octave_value tmp = scope->varval (".ignored.");
   if (tmp.is_defined ())
     ignored = tmp.matrix_value ();
 
   if (args(0).is_scalar_type ())
     {
       double k = args(0).double_value ();
 
       return ovl (isargout1 (nargout1, ignored, k));
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -2103,20 +2103,20 @@ namespace octave
     frame_stack.pop_front ();
   }
 
   symbol_table::scope *
   lexical_feedback::symbol_table_context::curr_scope (void) const
   {
     if (empty ())
       {
-        symbol_table& symtab
-          = octave::__get_symbol_table__ ("lexical_feedback::symbol_table_context::curr_scope");
-
-        return symtab.current_scope ();
+        symbol_table::scope *scope
+          = octave::__get_current_scope__ ("lexical_feedback::symbol_table_context::curr_scope");
+
+        return scope;
       }
     else
       return frame_stack.front ();
   }
 
   symbol_table::scope *
   lexical_feedback::symbol_table_context::parent_scope (void) const
   {
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -3391,50 +3391,50 @@ namespace octave
 
         std::string tmp = nm;
         if (! file.empty ())
           tmp += ": " + file;
 
         symbol_table& symtab
           = octave::__get_symbol_table__ ("base_parser::finish_function");
 
-        symtab.cache_name (fcn->scope (), tmp);
+
+        symbol_table::scope *fcn_scope = fcn->scope ();
+        fcn_scope->cache_name (tmp);
 
         if (lc)
           fcn->stash_leading_comment (lc);
 
         fcn->define_ret_list (ret_list);
 
         if (curr_fcn_depth > 1 || parsing_subfunctions)
           {
             fcn->stash_fcn_location (l, c);
 
+            octave_value ov_fcn (fcn);
+
             if (endfunction_found && function_scopes.size () > 1)
               {
                 symbol_table::scope *pscope = function_scopes.parent_scope ();
 
-                symtab.install_nestfunction (nm, octave_value (fcn), pscope);
+                pscope->install_nestfunction (nm, ov_fcn);
               }
             else
               {
                 fcn->mark_as_subfunction ();
                 subfunction_names.push_back (nm);
 
-                symtab.install_subfunction (nm, octave_value (fcn),
-                                            primary_fcn_scope);
+                primary_fcn_scope->install_subfunction (nm, ov_fcn);
                }
           }
 
-        if (fcn)
-          {
-            if (parsing_local_functions )
-              symtab.install_local_function (nm, octave_value (fcn), file);
-            else if (curr_fcn_depth == 1)
-              symtab.update_nest (fcn->scope ());
-          }
+        if (parsing_local_functions )
+          symtab.install_local_function (nm, octave_value (fcn), file);
+        else if (curr_fcn_depth == 1)
+          fcn_scope->update_nest ();
 
         if (! lexer.reading_fcn_file && curr_fcn_depth == 1)
           {
             // We are either reading a script file or defining a function
             // at the command line, so this definition creates a
             // tree_function object that is placed in the parse tree.
             // Otherwise, it is just inserted in the symbol table,
             // either as a subfunction or nested function (see above),
@@ -4567,21 +4567,19 @@ namespace octave
 
     if (retval)
       {
         retval->stash_dir_name (dir_name);
         retval->stash_package_name (package_name);
 
         if (retval->is_user_function ())
           {
-            symbol_table::scope *id = retval->scope ();
-
-            symbol_table& symtab = octave::__get_symbol_table__ ("load_fcn_from_file");
-
-            symtab.stash_dir_name_for_subfunctions (id, dir_name);
+            symbol_table::scope *scope = retval->scope ();
+
+            scope->stash_dir_name_for_subfunctions (dir_name);
           }
       }
 
     return retval;
   }
 }
 
 DEFMETHOD (autoload, interp, args, ,
@@ -5438,19 +5436,20 @@ may be either @qcode{"base"} or @qcode{"
     {
       // Put the check here so that we don't slow down assignments
       // generally.  Any that go through Octave's parser should have
       // already been checked.
 
       if (octave::is_keyword (nm))
         error ("assignin: invalid assignment to keyword '%s'", nm.c_str ());
 
-      symbol_table& symtab = interp.get_symbol_table ();
-
-      symtab.assign (nm, args(2));
+      symbol_table::scope *scope = interp.get_current_scope ();
+
+      if (scope)
+        scope->assign (nm, args(2));
     }
   else
     error ("assignin: invalid variable name in argument VARNAME");
 
   return retval;
 }
 
 /*
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -101,17 +101,17 @@ namespace octave
     symbol_table& symtab = m_interpreter.get_symbol_table ();
 
     symbol_table::scope *af_parent_scope
       = anon_fh.has_parent_scope () ? symtab.current_scope () : 0;
 
     symbol_table::scope *new_scope = af_scope ? af_scope->dup () : 0;
 
     if (new_scope && af_parent_scope)
-      symtab.inherit (new_scope, af_parent_scope);
+      new_scope->inherit (af_parent_scope);
 
     tree_parameter_list *param_list_dup
       = param_list ? param_list->dup (*new_scope) : 0;
 
     tree_parameter_list *ret_list = 0;
 
     tree_statement_list *stmt_list = 0;
 
@@ -121,18 +121,17 @@ namespace octave
         tree_statement *stmt = new tree_statement (expr_dup, 0);
         stmt_list = new tree_statement_list (stmt);
       }
 
     octave_user_function *af
       = new octave_user_function (new_scope, param_list_dup, ret_list,
                                   stmt_list);
 
-    if (af_parent_scope)
-      symtab.set_parent (new_scope, af_parent_scope);
+    new_scope->set_parent (af_parent_scope);
 
     octave_function *curr_fcn = m_call_stack.current ();
 
     if (curr_fcn)
       {
         // FIXME: maybe it would be better to just stash curr_fcn
         // instead of individual bits of info about it?
 
@@ -476,19 +475,20 @@ namespace octave
   tree_evaluator::initialize_undefined_parameter_list_elements
     (tree_parameter_list *param_list, const std::string& warnfor,
      int nargout, const octave_value& val)
   {
     bool warned = false;
 
     int count = 0;
 
-    symbol_table& symtab = m_interpreter.get_symbol_table ();
-
-    octave_value tmp = symtab.varval (".ignored.");
+    symbol_table::scope *scope
+      = m_interpreter.require_current_scope ("tree_evaluator::initialize_undefined_parameter_list_elements");
+
+    octave_value tmp = scope->varval (".ignored.");
     const Matrix ignored = (tmp.is_defined () ? tmp.matrix_value () : Matrix ());
 
     octave_idx_type k = 0;
 
     for (tree_decl_elt *elt : *param_list)
       {
         if (++count > nargout)
           break;
@@ -968,17 +968,20 @@ namespace octave
 
         symbol_table& symtab = m_interpreter.get_symbol_table ();
 
         symtab.install_cmdline_function (nm, fcn);
 
         // Make sure that any variable with the same name as the new
         // function is cleared.
 
-        symtab.assign (nm);
+        symbol_table::scope *scope = symtab.current_scope ();
+
+        if (scope)
+          scope->assign (nm);
       }
   }
 
   void
   tree_evaluator::visit_identifier (tree_identifier& expr)
   {
     octave_value_list retval;
 
diff --git a/libinterp/parse-tree/pt-fcn-handle.cc b/libinterp/parse-tree/pt-fcn-handle.cc
--- a/libinterp/parse-tree/pt-fcn-handle.cc
+++ b/libinterp/parse-tree/pt-fcn-handle.cc
@@ -78,16 +78,20 @@ namespace octave
     symbol_table::scope *af_scope = m_scope;
     symbol_table::scope *af_parent_scope = m_parent_scope;
 
     symbol_table& symtab
       = octave::__get_symbol_table__ ("tree_anon_fcn_handle::dup");
 
     symbol_table::scope *new_scope = af_scope ? af_scope->dup () : 0;
 
+    // FIXME: why should we inherit from the current scope here?  That
+    // doesn't seem right, but with the way things work now it appears
+    // to be required for bug-31371.tst to pass.
+
     if (new_scope)
       symtab.inherit (new_scope);
 
     tree_anon_fcn_handle *new_afh = new
       tree_anon_fcn_handle (param_list ? param_list->dup (*new_scope) : 0,
                             expr ? expr->dup (*new_scope) : 0,
                             new_scope, af_parent_scope, line (), column ());
 
diff --git a/libinterp/parse-tree/pt-jit.cc b/libinterp/parse-tree/pt-jit.cc
--- a/libinterp/parse-tree/pt-jit.cc
+++ b/libinterp/parse-tree/pt-jit.cc
@@ -113,19 +113,19 @@ static llvm::LLVMContext& context = llvm
 // is dead.
 class jit_break_exception : public std::exception
 { };
 
 // -------------------- jit_convert --------------------
 jit_convert::jit_convert (tree& tee, jit_type *for_bounds)
   : converting_function (false)
 {
-  symbol_table& symtab = octave::__get_symbol_table__ ("jit_convert::jit_convert");
-
-  initialize (symtab.current_scope ());
+  symbol_table::scope *scope = octave::__get_current_scope__ ("jit_convert::jit_convert");
+
+  initialize (scope);
 
   if (for_bounds)
     create_variable (next_for_bounds (false), for_bounds);
 
   try
     {
       visit (tee);
     }
@@ -2505,19 +2505,19 @@ jit_info::compile (tree_jit& tjit, tree&
 
 octave_value
 jit_info::find (const vmap& extra_vars, const std::string& vname) const
 {
   vmap::const_iterator iter = extra_vars.find (vname);
 
   if (iter == extra_vars.end ())
     {
-      symbol_table& symtab = octave::__get_symbol_table__ ("jit_convert::find");
-
-      return symtab.varval (vname);
+      symbol_table::scope *scope = octave::__require_current_scope__ ("jit_convert::find");
+
+      return scope->varval (vname);
     }
   else
     return *iter->second;
 }
 
 #endif
 
 DEFUN (jit_failcnt, args, nargout,
