# HG changeset patch
# User Michael Goffioul <michael.goffioul@gmail.com>
# Date 1360615526 18000
#      Mon Feb 11 15:45:26 2013 -0500
# Branch classdef
# Node ID fc3cb570ac4665de689c6cab34fa5ce26e6bf45f
# Parent  ebd2259c5df18997d96d049460a5312a53bada20
# Parent  a1e67cf915ba4aaf5d5e24d193614b28fe7c3d77
periodic merge of default to classdef.

diff --git a/.hgsubstate b/.hgsubstate
--- a/.hgsubstate
+++ b/.hgsubstate
@@ -1,1 +1,1 @@
-e2f98cc246bdb12f2d35366042d4aab61c3d54fe gnulib-hg
+0eef0a2a05e22ac8ef2aad06dda200f7def83396 gnulib-hg
diff --git a/.hgtags b/.hgtags
--- a/.hgtags
+++ b/.hgtags
@@ -66,8 +66,11 @@ ba4d6343524b406b0d15aee34579f80783581c54
 704f7895eef03008dd79848eb9da4bfb40787d73 release-3-6-0
 f947d2922febf12dcd1fb6e21b356756ecb54e55 rc-3-6-2-0
 4460c4fb20e6a5d3b1972fa737d4e00eb921545a rc-3-6-2-2
 551566201318bf615b27c60ccf9368f4844008bd release-3-6-2
 a95432e7309ca6fc776c02939264bb6d443f3525 release-3-6-3
 2e8eb9ac43a5f8cfaf0423814a312ed47cb80485 rc-3-6-4-0
 df1aceb8f0bc6b5b5062907931cc663467f57d93 ss-3-7-1
 858cbf6fc2ec1c232f5cf1d75dc344439b39a89c rc-3-6-4-1
+faefa1bea8ddae3cab170afdeab68d3d15c4e623 ss-3-7-2
+0000000000000000000000000000000000000000 ss-3-7-2
+23a7661e529ae9bfc91693618f8c314c31f695ca ss-3-7-2
diff --git a/Makefile.am b/Makefile.am
--- a/Makefile.am
+++ b/Makefile.am
@@ -34,16 +34,17 @@ EXTRA_DIST = \
   COPYING \
   ChangeLog \
   INSTALL \
   INSTALL.OCTAVE \
   NEWS \
   README \
   bootstrap \
   bootstrap.conf \
+  build-aux/find-files-with-tests.sh \
   build-aux/mk-opts.pl \
   build-aux/mkinstalldirs \
   build-aux/move-if-change \
   build-aux/OctJavaQry.class \
   etc/NEWS.1 \
   etc/NEWS.2 \
   etc/NEWS.3 \
   etc/OLD-ChangeLogs/ChangeLog \
diff --git a/bootstrap.conf b/bootstrap.conf
--- a/bootstrap.conf
+++ b/bootstrap.conf
@@ -39,16 +39,17 @@ gnulib_modules="
   fseek
   ftell
   getcwd
   gethostname
   getopt-gnu
   gettimeofday
   glob
   isatty
+  largefile
   link
   lstat
   malloc-gnu
   mkdir
   mkfifo
   mkostemp
   mktime
   nanosleep
diff --git a/build-aux/common.mk b/build-aux/common.mk
--- a/build-aux/common.mk
+++ b/build-aux/common.mk
@@ -151,31 +151,24 @@ DL_LD = @DL_LD@
 DL_LDFLAGS = @DL_LDFLAGS@
 
 SONAME_FLAGS = @SONAME_FLAGS@
 
 RDYNAMIC_FLAG = @RDYNAMIC_FLAG@
 
 NO_UNDEFINED_LDFLAG = @NO_UNDEFINED_LDFLAG@
 
+MKOCTFILE_AR = @MKOCTFILE_AR@
 MKOCTFILE_CC = @MKOCTFILE_CC@
 MKOCTFILE_CXX = @MKOCTFILE_CXX@
 MKOCTFILE_DL_LD = @MKOCTFILE_DL_LD@
 MKOCTFILE_DL_LDFLAGS = @MKOCTFILE_DL_LDFLAGS@
 MKOCTFILE_F77 = @MKOCTFILE_F77@
 MKOCTFILE_LD_CXX = @MKOCTFILE_LD_CXX@
-
-# List of libraries and their special compilation flags
-
-MKOCTFILE_CC = @MKOCTFILE_CC@
-MKOCTFILE_CXX = @MKOCTFILE_CXX@
-MKOCTFILE_DL_LD = @MKOCTFILE_DL_LD@
-MKOCTFILE_DL_LDFLAGS = @MKOCTFILE_DL_LDFLAGS@
-MKOCTFILE_F77 = @MKOCTFILE_F77@
-MKOCTFILE_LD_CXX = @MKOCTFILE_LD_CXX@
+MKOCTFILE_RANLIB = @MKOCTFILE_RANLIB@
 
 # List of libraries and their special compilation flags
 
 LIBOCTINTERP = @LIBOCTINTERP@
 LIBOCTAVE = @LIBOCTAVE@
 
 DL_LIBS = @DL_LIBS@
 FLIBS = @FLIBS@
@@ -344,16 +337,19 @@ datarootdir = @datarootdir@
 # and ${localfcnfiledir} are subdirectories of this.
 datadir = @datadir@
 
 libdir = @libdir@
 
 # Where to install and expect extra files like NEWS and doc-cache.
 octetcdir = @octetcdir@
 
+# Where to install and expect the language files for the gui.
+octlocaledir = @octlocaledir@
+
 # Where to install and expect libraries like liboctave.a, liboctinterp.a,
 # and other architecture-dependent data.
 octlibdir = @octlibdir@
 
 # Where to install and expect executable programs to be run by Octave
 # rather than directly by users.
 libexecdir = @libexecdir@
 
@@ -362,16 +358,19 @@ libexecdir = @libexecdir@
 includedir = @includedir@
 
 # Where to install Octave's man pages, and what extension they should
 # have.  The default is ${prefix}/man/man1
 mandir = @mandir@
 man1dir = @man1dir@
 man1ext = @man1ext@
 
+# Where to install test files.
+octtestsdir = @octtestsdir@
+
 # The full path to the default doc cache file.
 doc_cache_file = @doc_cache_file@
 
 # The full path to the default texi macros file.
 texi_macros_file_file = @texi_macros_file@
 
 # Where to install and expect the info files describing Octave..
 infodir = @infodir@
@@ -576,22 +575,24 @@ echo "making $@ from $<"
   -e "s|%OCTAVE_CONF_LIBS%|\"${LIBS}\"|" \
   -e "s|%OCTAVE_CONF_LLVM_CPPFLAGS%|\"${LLVM_CPPFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_LLVM_LDFLAGS%|\"${LLVM_LDFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_LLVM_LIBS%|\"${LLVM_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_LN_S%|\"${LN_S}\"|" \
   -e "s|%OCTAVE_CONF_MAGICK_CPPFLAGS%|\"${MAGICK_CPPFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_MAGICK_LDFLAGS%|\"${MAGICK_LDFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_MAGICK_LIBS%|\"${MAGICK_LIBS}\"|" \
+  -e 's|%OCTAVE_CONF_MKOCTFILE_AR%|\"${MKOCTFILE_AR}\"|' \
   -e 's|%OCTAVE_CONF_MKOCTFILE_CC%|\"${MKOCTFILE_CC}\"|' \
   -e 's|%OCTAVE_CONF_MKOCTFILE_CXX%|\"${MKOCTFILE_CXX}\"|' \
   -e 's|%OCTAVE_CONF_MKOCTFILE_DL_LD%|\"${MKOCTFILE_DL_LD}\"|' \
   -e 's|%OCTAVE_CONF_MKOCTFILE_DL_LDFLAGS%|\"${MKOCTFILE_DL_LDFLAGS}\"|' \
   -e 's|%OCTAVE_CONF_MKOCTFILE_F77%|\"${MKOCTFILE_F77}\"|' \
   -e 's|%OCTAVE_CONF_MKOCTFILE_LD_CXX%|\"${MKOCTFILE_LD_CXX}\"|' \
+  -e 's|%OCTAVE_CONF_MKOCTFILE_RANLIB%|\"${MKOCTFILE_RANLIB}\"|' \
   -e "s|%OCTAVE_CONF_OCTAVE_LINK_DEPS%|\"${OCTAVE_LINK_DEPS}\"|" \
   -e "s|%OCTAVE_CONF_OCTAVE_LINK_OPTS%|\"${OCTAVE_LINK_OPTS}\"|" \
   -e "s|%OCTAVE_CONF_OCTINCLUDEDIR%|\"${octincludedir}\"|" \
   -e "s|%OCTAVE_CONF_OCTLIBDIR%|\"${octlibdir}\"|" \
   -e "s|%OCTAVE_CONF_OCT_LINK_DEPS%|\"${OCT_LINK_DEPS}\"|" \
   -e "s|%OCTAVE_CONF_OCT_LINK_OPTS%|\"${OCT_LINK_OPTS}\"|" \
   -e "s|%OCTAVE_CONF_OPENGL_LIBS%|\"${OPENGL_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_PREFIX%|\"${prefix}\"|" \
@@ -673,16 +674,18 @@ echo "making $@ from $<"
   -e "s|%OCTAVE_LOCALVEROCTFILEDIR%|\"${localveroctfiledir}\"|" \
   -e "s|%OCTAVE_MAN1DIR%|\"${man1dir}\"|" \
   -e "s|%OCTAVE_MAN1EXT%|\"${man1ext}\"|" \
   -e "s|%OCTAVE_MANDIR%|\"${mandir}\"|" \
   -e "s|%OCTAVE_OCTFILEDIR%|\"${octfiledir}\"|" \
   -e "s|%OCTAVE_OCTETCDIR%|\"${octetcdir}\"|" \
   -e "s|%OCTAVE_OCTINCLUDEDIR%|\"${octincludedir}\"|" \
   -e "s|%OCTAVE_OCTLIBDIR%|\"${octlibdir}\"|" \
+  -e "s|%OCTAVE_OCTLOCALEDIR%|\"${octlocaledir}\"|" \
+  -e "s|%OCTAVE_OCTTESTSDIR%|\"${octtestsdir}\"|" \
   -e "s|%OCTAVE_STARTUPFILEDIR%|\"${startupfiledir}\"|" \
   -e "s|%OCTAVE_PREFIX%|\"${prefix}\"|" \
   -e "s|%OCTAVE_API_VERSION%|\"${api_version}\"|" \
   -e "s|%OCTAVE_RELEASE%|\"${OCTAVE_RELEASE}\"|" \
   -e "s|%OCTAVE_TEXI_MACROS_FILE%|\"${texi_macros_file}\"|" \
   -e "s|%OCTAVE_VERSION%|\"${version}\"|"
 $(simple_move_if_change_rule)
 endef
@@ -721,8 +724,22 @@ endef
 
 define do_script_uninstall
 for f in $(FCN_FILES_NO_DIR); \
   do rm -f $(DESTDIR)$(fcnfiledir)/$(script_sub_dir)/$$f; \
 done
 rm -f $(DESTDIR)$(fcnfiledir)/$(script_sub_dir)/PKG_ADD
 -rmdir $(DESTDIR)$(fcnfiledir)/$(script_sub_dir)
 endef
+
+define test-file-commands
+( echo "## DO NOT EDIT!  Generated automatically from $(<F) by Make."; grep '^%!' $< ) > $@-t
+mv $@-t $@
+endef
+
+%.cc-tst : %.cc
+	$(test-file-commands)
+
+%.yy-tst : %.yy
+	$(test-file-commands)
+
+%.ll-tst : %.ll
+	$(test-file-commands)
diff --git a/build-aux/find-files-with-tests.sh b/build-aux/find-files-with-tests.sh
new file mode 100755
--- /dev/null
+++ b/build-aux/find-files-with-tests.sh
@@ -0,0 +1,19 @@
+#! /bin/sh
+
+set -e
+SED=${SED:-sed}
+
+srcdir="$1"
+shift
+
+for arg
+do
+  if [ -f "$arg" ]; then
+    file="$arg"
+  else
+    file="$srcdir/$arg"
+  fi
+  if [ "`grep -l '^%!' $file`" ]; then
+    echo "$file" | $SED "s,\\$srcdir/,,";
+  fi
+done
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -14,24 +14,24 @@ dnl Copyright (C) 1993-2012 John W. Eato
 ### FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ### for more details.
 ### 
 ### You should have received a copy of the GNU General Public License
 ### along with Octave; see the file COPYING.  If not, see
 ### <http://www.gnu.org/licenses/>.
 
 AC_PREREQ([2.62])
-AC_INIT([GNU Octave], [3.7.1+], [http://octave.org/bugs.html], [octave])
+AC_INIT([GNU Octave], [3.7.2+], [http://octave.org/bugs.html], [octave])
 
 dnl PACKAGE_VERSION is set by the AC_INIT VERSION arg
 OCTAVE_VERSION="$PACKAGE_VERSION"
 OCTAVE_API_VERSION_NUMBER="48"
 OCTAVE_API_VERSION="api-v$OCTAVE_API_VERSION_NUMBER+"
-OCTAVE_RELEASE_DATE="2013-01-02"
-OCTAVE_COPYRIGHT="Copyright (C) 2012 John W. Eaton and others."
+OCTAVE_RELEASE_DATE="2013-02-09"
+OCTAVE_COPYRIGHT="Copyright (C) 2013 John W. Eaton and others."
 AC_SUBST(OCTAVE_VERSION)
 AC_SUBST(OCTAVE_API_VERSION_NUMBER)
 AC_SUBST(OCTAVE_API_VERSION)
 AC_SUBST(OCTAVE_RELEASE_DATE)
 AC_SUBST(OCTAVE_COPYRIGHT)
 
 dnl FIXME: We should auto-insert the Mercurial changeset ID into the
 dnl        AC_REVISION field whenever configure.ac is modified.
@@ -75,17 +75,19 @@ OCTAVE_SET_DEFAULT([localveroctfiledir],
   '$(libdir)/octave/$(version)/site/oct/$(canonical_host_type)')
 OCTAVE_SET_DEFAULT([octincludedir], '$(includedir)/octave-$(version)/octave')
 OCTAVE_SET_DEFAULT([fcnfiledir], '$(datadir)/octave/$(version)/m')
 OCTAVE_SET_DEFAULT([localfcnfiledir], '$(datadir)/octave/site/m')
 OCTAVE_SET_DEFAULT([localapifcnfiledir],
   '$(datadir)/octave/site/$(api_version)/m')
 OCTAVE_SET_DEFAULT([localverfcnfiledir], '$(datadir)/octave/$(version)/site/m')
 OCTAVE_SET_DEFAULT([octetcdir], '$(datadir)/octave/$(version)/etc')
+OCTAVE_SET_DEFAULT([octlocaledir], '$(datadir)/octave/$(version)/locale')
 OCTAVE_SET_DEFAULT([doc_cache_file], '$(octetcdir)/doc-cache')
+OCTAVE_SET_DEFAULT([octtestsdir], '$(octetcdir)/tests')
 OCTAVE_SET_DEFAULT([texi_macros_file], '$(octetcdir)/macros.texi')
 OCTAVE_SET_DEFAULT([imagedir], '$(datadir)/octave/$(version)/imagelib')
 OCTAVE_SET_DEFAULT([man1dir], '$(mandir)/man1')
 OCTAVE_SET_DEFAULT([man1ext], '.1')
 OCTAVE_SET_DEFAULT([infofile], '$(infodir)/octave.info')
 
 ### Check for programs used in building, installing, and running Octave.
 
@@ -807,16 +809,32 @@ LIBS="$save_LIBS"
 OCTAVE_CHECK_LIB(fftw3, FFTW3,
   [FFTW3 library not found.  The slower FFTPACK library will be used instead.],
   [fftw3.h], [fftw_plan_dft_1d])
 
 OCTAVE_CHECK_LIB(fftw3f, FFTW3F,
   [FFTW3F library not found.  The slower FFTPACK library will be used instead.],
   [fftw3.h], [fftwf_plan_dft_1d])
 
+## Check for the multithreaded FFTW library.
+## Fallback to singlethreaded if not found or disabled
+build_fftw_threads=true
+AC_ARG_ENABLE([fftw-threads],
+  [AS_HELP_STRING([--disable-fftw-threads],
+    [disable Multi-threaded FFTW])],
+  [if test "$enableval" = no; then
+     build_fftw_threads=false
+   fi],
+  [])
+
+if test $build_fftw_threads = true; then
+  OCTAVE_CHECK_FFTW_THREADS(fftw3, fftw_plan_with_nthreads)
+  OCTAVE_CHECK_FFTW_THREADS(fftw3f, fftwf_plan_with_nthreads)
+fi
+
 AM_CONDITIONAL([AMCOND_HAVE_FFTW],
   [test -n "$FFTW3_LIBS" && test -n "$FFTW3F_LIBS"])
 
 ## Subdirectory of liboctave/cruft to build if FFTW is not found.
 FFT_DIR="fftpack"
 AC_SUBST(FFT_DIR)
 
 ### Check for GLPK library and header.
@@ -1272,33 +1290,33 @@ OCTAVE_CHECK_LIB(amd, AMD,
   [suitesparse/amd.h ufsparse/amd.h amd/amd.h amd.h],
   [amd_postorder],
   [], [don't use AMD library, disable some sparse matrix functionality])
 
 ### Check for CAMD library
 
 OCTAVE_CHECK_LIB(camd, CAMD,
   [CAMD library not found.  This will result in some lack of functionality for sparse matrices.],
-  [suitesparse/camd.h ufsparse/camd.h amd/camd.h camd.h],
+  [suitesparse/camd.h ufsparse/camd.h camd/camd.h camd.h],
   [camd_postorder],
   [], [don't use CAMD library, disable some sparse matrix functionality])
 
 ### Check for COLAMD library
 
 OCTAVE_CHECK_LIB(colamd, COLAMD,
   [COLAMD library not found.  This will result in some lack of functionality for sparse matrices.],
-  [suitesparse/colamd.h ufsparse/colamd.h amd/colamd.h colamd.h],
+  [suitesparse/colamd.h ufsparse/colamd.h colamd/colamd.h colamd.h],
   [colamd],
   [], [don't use COLAMD library, disable some sparse matrix functionality])
 
 ### Check for CCOLAMD library
 
 OCTAVE_CHECK_LIB(ccolamd, CCOLAMD,
   [CCOLAMD library not found.  This will result in some lack of functionality for sparse matrices.],
-  [suitesparse/ccolamd.h ufsparse/ccolamd.h amd/ccolamd.h ccolamd.h],
+  [suitesparse/ccolamd.h ufsparse/ccolamd.h ccolamd/ccolamd.h ccolamd.h],
   [ccolamd],
   [], [don't use CCOLAMD library, disable some sparse matrix functionality])
 
 ### Check for CHOLMOD library.
 ### If your cholmod library requires cblas, then you will need to
 ### configure with --with-cholmod="-lcholmod -lcblas".
 
 save_LIBS="$LIBS"
@@ -1309,17 +1327,17 @@ OCTAVE_CHECK_LIB(cholmod, CHOLMOD,
   [cholmod_start],
   [], [don't use CHOLMOD library, disable some sparse matrix functionality])
 LIBS="$save_LIBS"
 
 ### Check for CXSparse library
 
 OCTAVE_CHECK_LIB(cxsparse, CXSparse,
   [CXSparse library not found.  This will result in some lack of functionality for sparse matrices.],
-  [suitesparse/cs.h ufsparse/cs.h amd/cs.h cs.h],
+  [suitesparse/cs.h ufsparse/cs.h cxsparse/cs.h cs.h],
   [cs_di_sqr],
   [C++], [don't use CXSparse library, disable some sparse matrix functionality])
 
 ### Check for UMFPACK library.
 
 save_LIBS="$LIBS"
 save_CPPFLAGS="$CPPFLAGS"
 LIBS="$AMD_LDFLAGS $AMD_LIBS $BLAS_LIBS $FLIBS $LIBS"
@@ -1809,43 +1827,48 @@ AC_SUBST(LD_CXX)
 AC_SUBST(RDYNAMIC_FLAG)
 AC_SUBST(ENABLE_DYNAMIC_LINKING)
 AC_SUBST(LIBOCTINTERP)
 AC_SUBST(LIBOCTAVE)
 
 
 if test "$cross_compiling" = yes && test -n "$ac_tool_prefix"; then
   CROSS_TOOL_PREFIX="$ac_tool_prefix"
+  MKOCTFILE_AR='$(shell echo $(AR) | sed "s,$(CROSS_TOOL_PREFIX),,")'
   MKOCTFILE_CC='$(shell echo $(CC) | sed "s,$(CROSS_TOOL_PREFIX),,")'
   MKOCTFILE_CXX='$(shell echo $(CXX) | sed "s,$(CROSS_TOOL_PREFIX),,")'
   MKOCTFILE_DL_LD='$(shell echo $(DL_LD) | sed "s,$(CROSS_TOOL_PREFIX),,")'
   MKOCTFILE_F77='$(shell echo $(F77) | sed "s,$(CROSS_TOOL_PREFIX),,")'
   MKOCTFILE_LD_CXX='$(shell echo $(LD_CXX) | sed "s,$(CROSS_TOOL_PREFIX),,")'
+  MKOCTFILE_RANLIB='$(shell echo $(RANLIB) | sed "s,$(CROSS_TOOL_PREFIX),,")'
 else
+  MKOCTFILE_AR="$AR"
   MKOCTFILE_CC="$CC"
   MKOCTFILE_CXX="$CXX"
   MKOCTFILE_DL_LD="$DL_LD"
   MKOCTFILE_F77="$F77"
   MKOCTFILE_LD_CXX="$LD_CXX"
+  MKOCTFILE_RANLIB="$RANLIB"
 fi
 AC_MSG_NOTICE([defining CROSS_TOOL_PREFIX to be $CROSS_TOOL_PREFIX])
+AC_MSG_NOTICE([defining MKOCTFILE_AR to be $MKOCTFILE_AR])
 AC_MSG_NOTICE([defining MKOCTFILE_CC to be $MKOCTFILE_CC])
 AC_MSG_NOTICE([defining MKOCTFILE_CXX to be $MKOCTFILE_CXX])
 AC_MSG_NOTICE([defining MKOCTFILE_DL_LD to be $MKOCTFILE_DL_LD])
 AC_MSG_NOTICE([defining MKOCTFILE_F77 to be $MKOCTFILE_F77])
 AC_MSG_NOTICE([defining MKOCTFILE_LD_CXX to be $MKOCTFILE_LD_CXX])
+AC_MSG_NOTICE([defining MKOCTFILE_RANLIB to be $MKOCTFILE_RANLIB])
 AC_SUBST(CROSS_TOOL_PREFIX)
+AC_SUBST(MKOCTFILE_AR)
 AC_SUBST(MKOCTFILE_CC)
 AC_SUBST(MKOCTFILE_CXX)
 AC_SUBST(MKOCTFILE_DL_LD)
 AC_SUBST(MKOCTFILE_F77)
 AC_SUBST(MKOCTFILE_LD_CXX)
-
-### Check for existence of various libraries
-
+AC_SUBST(MKOCTFILE_RANLIB)
 
 ### Check for existence of various libraries
 
 ## OS-specific test for dirent, opendir.
 case $host_os in
   mingw*)
     if test $have_msvc = yes; then
       AC_CHECK_LIB([dirent], [opendir])
@@ -2158,23 +2181,31 @@ fi
 AC_CHECK_DECLS([sys_siglist], [], [],
 [[#include <signal.h>
 /* NetBSD declares sys_siglist in unistd.h.  */
 #if HAVE_UNISTD_H
 # include <unistd.h>
 #endif
 ]])
 
-### Need to disable building documentation if gnuplot was not found,
-### unless it was already disabled previously.
-
-if test -n "$DOCDIR" && test -n "$warn_gnuplot"; then
-  DOCDIR=
-  warn_docs="building documentation disabled because gnuplot was not found; make dist will fail"
-  OCTAVE_CONFIGURE_WARNING([warn_docs])
+### Need to disable building documentation if either gnuplot or
+### makeinfo are missing.  Skip this warning if building docs was
+### disabled with a configure option.
+
+if test -n "$DOCDIR"; then
+  if test -n "$warn_gnuplot"; then
+    DOCDIR=
+    warn_docs_gnuplot="building documentation disabled because gnuplot was not found; make dist will fail"
+    OCTAVE_CONFIGURE_WARNING([warn_docs_gnuplot])
+  fi
+  if test -n "$warn_makeinfo"; then
+    DOCDIR=
+    warn_docs_makeinfo="building documentation disabled because makeinfo was not found; make dist will fail"
+    OCTAVE_CONFIGURE_WARNING([warn_docs_makeinfo])
+  fi
 fi
 AM_CONDITIONAL([AMCOND_BUILD_DOCS], [test -n "$DOCDIR"])
 
 ### Maybe add -Wall, -W, and -Wshadow to compiler flags now that we're
 ### done feature testing. 
 
 GCC_EXTRA_FLAGS="-Wall -W -Wshadow -Wformat -Wpointer-arith -Wmissing-prototypes -Wstrict-prototypes -Wwrite-strings -Wcast-align -Wcast-qual"
 
diff --git a/doc/interpreter/contributors.in b/doc/interpreter/contributors.in
--- a/doc/interpreter/contributors.in
+++ b/doc/interpreter/contributors.in
@@ -76,16 +76,17 @@ Michael D. Godfrey
 Michael Goffioul
 Glenn Golden
 Tomislav Goles
 Keith Goodman
 Brian Gough
 Steffen Groot
 Etienne Grossmann
 David Grundberg
+Kyle Guinn
 Peter Gustafson
 Kai Habel
 Patrick Häcker
 William P. Y. Hadisoeseno
 Jaroslav Hajek
 Benjamin Hall
 Kim Hansen
 Søren Hauberg
diff --git a/doc/interpreter/mkoctfile.1 b/doc/interpreter/mkoctfile.1
--- a/doc/interpreter/mkoctfile.1
+++ b/doc/interpreter/mkoctfile.1
@@ -90,39 +90,39 @@ Create a MEX file.  Set the default outp
 .B \-o \fIfile\fP\fR,\fB \-\-output \fIfile\fP
 Output file name.  Default extension is \fB.oct\fP (or \fB.mex\fP if \-\-mex is
 specified) unless linking a stand-alone executable.
 .TP
 .B \-p \fIVAR\fP\fR,\fB \-\-print \fIVAR\fP
 Print configuration variable \fIVAR\fP.  Recognized variables are:
 .RS
 .Vb
-    ALL_CFLAGS                FFTW3F_LIBS
-    ALL_CXXFLAGS              FLIBS
-    ALL_FFLAGS                FPICFLAG
-    ALL_LDFLAGS               INCFLAGS
+    ALL_CFLAGS                FFTW3F_LDFLAGS
+    ALL_CXXFLAGS              FFTW3F_LIBS
+    ALL_FFLAGS                FLIBS
+    ALL_LDFLAGS               FPICFLAG
+    AR                        INCFLAGS
     BLAS_LIBS                 LAPACK_LIBS
     CC                        LDFLAGS
     CFLAGS                    LD_CXX
     CPICFLAG                  LD_STATIC_FLAG
     CPPFLAGS                  LFLAGS
     CXX                       LIBOCTAVE
-    CXXFLAGS                  LIBOCTINTERP    
-    CXXPICFLAG                LIBS            
-    DEPEND_EXTRA_SED_PATTERN  OCTAVE_LIBS     
+    CXXFLAGS                  LIBOCTINTERP
+    CXXPICFLAG                LIBS
+    DEPEND_EXTRA_SED_PATTERN  OCTAVE_LIBS
     DEPEND_FLAGS              OCTAVE_LINK_DEPS
-    DL_LD                     OCT_LINK_DEPS   
-    DL_LDFLAGS                RDYNAMIC_FLAG   
-    EXEEXT                    READLINE_LIBS   
-    F77                       SED             
-    F77_INTEGER_8_FLAG        XTRA_CFLAGS     
-    FFLAGS                    XTRA_CXXFLAGS   
-    FFTW3_LDFLAGS                             
-    FFTW3_LIBS                                
-    FFTW3F_LDFLAGS
+    DL_LD                     OCT_LINK_DEPS
+    DL_LDFLAGS                RANLIB
+    EXEEXT                    RDYNAMIC_FLAG
+    F77                       READLINE_LIBS
+    F77_INTEGER_8_FLAG        SED
+    FFLAGS                    XTRA_CFLAGS
+    FFTW3_LDFLAGS             XTRA_CXXFLAGS
+    FFTW3_LIBS
 .Ve
 .RE
 .TP
 .B \-v\fR,\fB --verbose
 Echo commands as they are executed.
 .TP
 .B file
 Compile or link file.  Recognized file types are
diff --git a/doc/interpreter/oop.txi b/doc/interpreter/oop.txi
--- a/doc/interpreter/oop.txi
+++ b/doc/interpreter/oop.txi
@@ -651,16 +651,18 @@ polynomial class constructor would be mo
 @EXAMPLEFILE(@polynomial/polynomial_superiorto.m)
 @end group
 @end example
 
 Note that user classes always have higher precedence than built-in
 Octave types.  So in fact marking our polynomial class higher than the 
 "double" class is in fact not necessary.
 
+When faced with two objects that have the same precedence, Octave will use the
+method of the object that appears first on the list of arguments.
 
 @node Inheritance and Aggregation
 @section Inheritance and Aggregation
 
 Using classes to build new classes is supported by octave through the
 use of both inheritance and aggregation.
 
 Class inheritance is provided by octave using the @code{class}
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -131,16 +131,20 @@ shown in @ref{fig:hist}.
 @end float
 
 @DOCSTRING(bar)
 
 @DOCSTRING(barh)
 
 @DOCSTRING(hist)
 
+@DOCSTRING(stemleaf)
+
+@DOCSTRING(printd)
+
 @DOCSTRING(stairs)
 
 @DOCSTRING(stem)
 
 @DOCSTRING(stem3)
 
 @DOCSTRING(scatter)
 
diff --git a/etc/HACKING b/etc/HACKING
--- a/etc/HACKING
+++ b/etc/HACKING
@@ -223,17 +223,17 @@ An overview of the directory layout of O
 
       octave-adapter souce files for the octave layer for threadsafe
                      communication with the octave interpreter.
       qtinfo         source files for the Qt texinfo browser.
 
       icons          icon files that will be compiled into the
                      executable via a resource file.
 
-    qterminal        subrepository for the qterminal Qt terminal widget.
+    qterminal        Qt terminal widget
 
     languages        translation files and list of translators.
 
     kb-layouts       various files need by the qterminal widget that has
                      been derived from Konsole.
       
 
   scripts       -- functions written in the Octave language
diff --git a/libgui/Makefile.am b/libgui/Makefile.am
--- a/libgui/Makefile.am
+++ b/libgui/Makefile.am
@@ -21,18 +21,26 @@
 include $(top_srcdir)/build-aux/common.mk
 
 AUTOMAKE_OPTIONS = subdir-objects
 
 MOC_CPPFLAGS =
 
 octlib_LTLIBRARIES = liboctgui.la
 
-EXTRA_DIST = default-qt-settings
+locales = \
+  languages/be_BY.qm \
+  languages/de_DE.qm \
+  languages/en_US.qm \
+  languages/es_ES.qm \
+  languages/pt_BR.qm \
+  languages/ru_RU.qm \
+  languages/uk_UA.qm
 
+EXTRA_DIST = default-qt-settings $(locales)
 CLEANFILES =
 
 BUILT_SOURCES =
 
 noinst_HEADERS =
 
 noinst_LTLIBRARIES =
 
@@ -65,16 +73,18 @@ liboctgui_version_info = $(liboctgui_cur
 liboctgui_la_LDFLAGS = \
   -version-info $(liboctgui_version_info) \
   $(NO_UNDEFINED_LDFLAG) \
   -bindir $(bindir) \
   $(LIBOCTGUI_LINK_OPTS)
 
 octetc_DATA = default-qt-settings
 
+octlocale_DATA = $(locales)
+
 moc-%.cc: %.h
 	@MOC@ -o$@ $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(MOC_CPPFLAGS) $(liboctgui_la_CPPFLAGS) $<
 
 ui-%.h: %.ui
 	@UIC@ -o $@ $<
 
 qrc-%.cc: %.qrc
 	@RCC@ -o $@ $<
diff --git a/libgui/languages/generic.qm b/libgui/languages/en_US.qm
rename from libgui/languages/generic.qm
rename to libgui/languages/en_US.qm
diff --git a/libgui/languages/generic.ts b/libgui/languages/en_US.ts
rename from libgui/languages/generic.ts
rename to libgui/languages/en_US.ts
diff --git a/libgui/languages/translators b/libgui/languages/translators
--- a/libgui/languages/translators
+++ b/libgui/languages/translators
@@ -1,9 +1,11 @@
 # Below Octave GUI translators are listed with their e-mails
-# to be able inform them about generic translation file changes
+# to be able to inform them about generic translation file changes.
+# The gerenic file that can be used as a template for new
+# translation files is en_US.ts
 be_BY Mihas Varantsou <meequz@gmail.com>
 de_DE Jacob Dawid <jacob.dawid@googlemail.com>
 en_US Jacob Dawid <jacob.dawid@googlemail.com>
 es_ES Valentin Ortega-Clavero <arcanos3030@gmail.com>
 pt_BE Júlio Hoffimann Mendes <julio.hoffimann@gmail.com>
 ru_RU Andriy Shinkarchuck <adriano32.gnu@gmail.com>
 uk_UA Andriy Shinkarchuck <adriano32.gnu@gmail.com>
diff --git a/libgui/src/m-editor/file-editor-interface.h b/libgui/src/m-editor/file-editor-interface.h
--- a/libgui/src/m-editor/file-editor-interface.h
+++ b/libgui/src/m-editor/file-editor-interface.h
@@ -38,21 +38,23 @@ class file_editor_interface : public QDo
     setObjectName ("FileEditor");
 
     connect (this, SIGNAL (visibilityChanged (bool)), this,
              SLOT (handle_visibility_changed (bool)));
   }
 
   virtual ~file_editor_interface () { }
 
+  virtual QMenu *get_mru_menu ( ) = 0;
   virtual QMenu *debug_menu () = 0;
   virtual QToolBar *toolbar () = 0;
 
   virtual void handle_entered_debug_mode () = 0;
   virtual void handle_quit_debug_mode () = 0;
+  virtual void set_focus () = 0;
 
 public slots:
   virtual void request_new_file () = 0;
   virtual void request_open_file () = 0;
   virtual void request_open_file (const QString& fileName) = 0;
 
 signals:
   void active_changed (bool active);
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -137,18 +137,17 @@ file_editor_tab::~file_editor_tab ()
   delete _edit_area;
 }
 
 void
 file_editor_tab::closeEvent (QCloseEvent *e)
 {
   // ignore close event if file is not saved and user cancels
   // closing this window
-  if (check_file_modified ("Close File",
-                           QMessageBox::Cancel) == QMessageBox::Cancel)
+  if (check_file_modified () == QMessageBox::Cancel)
     {
       e->ignore ();
     }
   else
     {
       e->accept();
     }
 }
@@ -254,16 +253,25 @@ file_editor_tab::update_lexer ()
   // TODO: Autoindent not working as it should
   lexer->setAutoIndentStyle (QsciScintilla::AiMaintain ||
                              QsciScintilla::AiOpening  ||
                              QsciScintilla::AiClosing);
 
   _edit_area->setLexer (lexer);
 }
 
+// slot for fetab_set_focus: sets the focus to the current edit area
+void
+file_editor_tab::set_focus (const QWidget* ID)
+{
+  if (ID != this)
+    return;
+  _edit_area->setFocus ();
+}
+
 void
 file_editor_tab::undo (const QWidget* ID)
 {
   if (ID != this)
     return;
 
   _edit_area->undo ();
 }
@@ -610,16 +618,18 @@ file_editor_tab::find (const QWidget* ID
   if (!_find_dialog->isVisible ())
     {
       _find_dialog->setGeometry (_find_dialog_geometry);
       _find_dialog->show ();
       _find_dialog_is_visible = true;
     }
 
   _find_dialog->activateWindow ();
+  _find_dialog->init_search_text ();
+
 }
 
 void
 file_editor_tab::do_comment_selected_text (bool comment)
 {
   if ( _edit_area->hasSelectedText() )
     {
       int lineFrom, lineTo, colFrom, colTo, i;
@@ -644,54 +654,64 @@ file_editor_tab::do_comment_selected_tex
       _edit_area->endUndoAction ();
     }
 }
 
 void
 file_editor_tab::update_window_title (bool modified)
 {
   QString title ("");
+  QString tooltip ("");
   if (_file_name.isEmpty () || _file_name.at (_file_name.count () - 1) == '/')
-    title = UNNAMED_FILE;
+    title = tr("<unnamed>");
   else
-    title = _file_name;
-  if ( !_long_title )
     {
-      QFileInfo file(_file_name);
-      title = file.fileName();
+      if ( _long_title )
+        title = _file_name;
+      else
+        {
+          QFileInfo file(_file_name);
+          title = file.fileName();
+          tooltip = _file_name;
+        }
     }
 
   if ( modified )
     {
-      emit file_name_changed (title.prepend("* "));
+      emit file_name_changed (title.prepend("* "), tooltip);
     }
   else
-    emit file_name_changed (title);
+    emit file_name_changed (title, tooltip);
 }
 
 void
 file_editor_tab::handle_copy_available(bool enableCopy)
 {
   _copy_available = enableCopy;
   emit editor_state_changed (_copy_available, QDir::cleanPath (_file_name));
 }
 
 int
-file_editor_tab::check_file_modified (const QString&, int)
+file_editor_tab::check_file_modified ()
 {
   int decision = QMessageBox::Yes;
   if (_edit_area->isModified ())
     {
       // File is modified but not saved, ask user what to do.  The file
       // editor tab can't be made parent because it may be deleted depending
       // upon the response.  Instead, change the _edit_area to read only.
       QMessageBox* msgBox = new QMessageBox (
-              QMessageBox::Warning, tr ("Octave Editor"),
-              tr ("The file \'%1\' has been modified. Do you want to save the changes?").
-              arg (_file_name), QMessageBox::Yes | QMessageBox::No, 0);
+          QMessageBox::Warning, tr ("Octave Editor"),
+          tr ("The file\n"
+              "%1\n"
+              "is about to be closed but has been modified.\n"
+              "Do you want to cancel closing, save or discard the changes?").
+          arg (_file_name),
+          QMessageBox::Save | QMessageBox::Cancel | QMessageBox::Discard, 0);
+      msgBox->setDefaultButton (QMessageBox::Save);
       _edit_area->setReadOnly (true);
       connect (msgBox, SIGNAL (finished (int)),
                this, SLOT (handle_file_modified_answer (int)));
       msgBox->setWindowModality (Qt::NonModal);
       msgBox->setAttribute (Qt::WA_DeleteOnClose);
       msgBox->show ();
       return (QMessageBox::Cancel);
     }
@@ -702,22 +722,22 @@ file_editor_tab::check_file_modified (co
     }
  
   return (decision);
 }
 
 void
 file_editor_tab::handle_file_modified_answer (int decision)
 {
-  if (decision == QMessageBox::Yes)
+  if (decision == QMessageBox::Save)
     {
       // Save file, then remove from editor.
       save_file (_file_name, true);
     }
-  else if (decision == QMessageBox::No)
+  else if (decision == QMessageBox::Discard)
     {
       // User doesn't want to save, just remove from editor.
       emit tab_remove_request ();
     }
   else
     {
       // User canceled, allow editing again.
       _edit_area->setReadOnly (false);
@@ -849,17 +869,17 @@ file_editor_tab::save_file_as (bool remo
         }
       else
         {
           // The file name is actually the directory name from the
           // constructor argument.
           fileDialog->setDirectory (_file_name);
         }
     }
-  fileDialog->setNameFilter (SAVE_FILE_FILTER);
+  fileDialog->setNameFilter (tr("Octave Files (*.m);;All Files (*.*)"));
   fileDialog->setDefaultSuffix ("m");
   fileDialog->setAcceptMode (QFileDialog::AcceptSave);
   fileDialog->setViewMode (QFileDialog::Detail);
   if (remove_on_success)
     {
       connect (fileDialog, SIGNAL (fileSelected (const QString&)),
                this, SLOT (handle_save_file_as_answer_close (const QString&)));
       connect (fileDialog, SIGNAL (rejected ()),
@@ -880,17 +900,18 @@ file_editor_tab::message_duplicate_file_
 {
   // Could overwrite the file here (and tell user the file was
   // overwritten), but the user could have unintentionally
   // selected the same name not intending to overwrite.
 
   // Create a NonModal message about error.
   QMessageBox* msgBox = new QMessageBox (
           QMessageBox::Critical, tr ("Octave Editor"),
-          tr ("File not saved!  You've selected a file name\n\n     %1\n\nwhich is the same as the current file name.  Use ""Save"" to overwrite.  (Could allow overwriting, with message, if that is what folks want.)").
+          tr ("File not saved! The selected file name\n%1\n"
+              "is the same as the current file name").
           arg (saveFileName),
           QMessageBox::Ok, 0);
   msgBox->setWindowModality (Qt::NonModal);
   msgBox->setAttribute (Qt::WA_DeleteOnClose);
   msgBox->show ();
 }
 
 void
@@ -953,22 +974,30 @@ file_editor_tab::file_has_changed (const
       connect (msgBox, SIGNAL (finished (int)),
                this, SLOT (handle_file_reload_answer (int)));
       msgBox->setWindowModality (Qt::WindowModal);
       msgBox->setAttribute (Qt::WA_DeleteOnClose);
       msgBox->show ();
     }
   else
     {
-      // Create a WindowModal message that blocks the edit area
-      // by making _edit_area parent.
+      QString modified = "";
+      if (_edit_area->isModified ())
+        modified = tr ("\n\nWarning: The contents in the editor is modified!");
+      // Create a WindowModal message. The file editor tab can't be made
+      // parent because it may be deleted depending upon the response.
+      // Instead, change the _edit_area to read only.
       QMessageBox* msgBox = new QMessageBox (
               QMessageBox::Warning, tr ("Octave Editor"),
-              tr ("It seems that \'%1\' has been deleted or renamed. Do you want to save it now?").
-              arg (_file_name), QMessageBox::Save | QMessageBox::Close, this);
+              tr ("It seems that the file\n"
+                  "%1\n"
+                  "has been deleted or renamed. Do you want to save it now?%2").
+              arg (_file_name).arg (modified),
+              QMessageBox::Save | QMessageBox::Close, 0);
+      _edit_area->setReadOnly (true);
       connect (msgBox, SIGNAL (finished (int)),
                this, SLOT (handle_file_resave_answer (int)));
       msgBox->setWindowModality (Qt::WindowModal);
       msgBox->setAttribute (Qt::WA_DeleteOnClose);
       msgBox->show ();
     }
 }
 
@@ -1068,31 +1097,31 @@ file_editor_tab::handle_file_reload_answ
     { // do not reload: readd to the file watche
       _file_system_watcher.addPath (_file_name);
     }
 }
 
 void
 file_editor_tab::handle_file_resave_answer (int decision)
 {
+  // check decision of user in dialog
   if (decision == QMessageBox::Save)
     {
-      save_file (_file_name);
+      save_file (_file_name);  // readds file to watcher in set_file_name ()
+      _edit_area->setReadOnly (false);  // delete read only flag
     }
   else
     {
-      if (close ())
-        {
-          emit tab_remove_request ();
-          return;  // Don't touch member variables after removal
-        }
+      // Definitely close the file.
+      // Set modified to false to prevent the dialog box when the close event
+      // is posted. If the user cancels the close in this dialog the tab is
+      // left open with a non-existing file.
+      _edit_area->setModified (false);
+      close ();
     }
-
-  // Start watching file once again.
-  _file_system_watcher.addPath (_file_name);
 }
 
 void
 file_editor_tab::set_debugger_position (int line)
 {
   _edit_area->markerDeleteAll (debugger_position);
   if (line > 0)
     {
diff --git a/libgui/src/m-editor/file-editor-tab.h b/libgui/src/m-editor/file-editor-tab.h
--- a/libgui/src/m-editor/file-editor-tab.h
+++ b/libgui/src/m-editor/file-editor-tab.h
@@ -47,16 +47,17 @@ public slots:
   void notice_settings ();
   /** Will initiate close if associated with the identifier tag. */
   void conditional_close (const QWidget* ID);
   /** Change to a different editor tab by identifier tag. */
   void change_editor_state (const QWidget* ID);
   /** Simply transmit file name. */
   void file_name_query (const QWidget* ID);
 
+  void set_focus (const QWidget* ID);
   void undo (const QWidget* ID);
   void redo (const QWidget* ID);
   void copy (const QWidget* ID);
   void cut (const QWidget* ID);
   void paste (const QWidget* ID);
   void save_file (const QWidget* ID);
   void save_file (const QWidget* ID, const QString& fileName, bool remove_on_success);
   void save_file_as (const QWidget* ID);
@@ -80,17 +81,17 @@ public slots:
   void set_modified (bool modified = true);
 
   QString load_file (const QString& fileName);
   void new_file ();
 
   void file_has_changed (const QString& fileName);
 
 signals:
-  void file_name_changed (const QString& fileName);
+  void file_name_changed (const QString& fileName, const QString& toolTip);
   void editor_state_changed (bool copy_available, const QString& fileName);
   void tab_remove_request ();
   void add_filename_to_list (const QString& fileName);
   void mru_add_file (const QString& file_name);
   void editor_check_conflict_save (const QString& saveFileName, bool remove_on_success);
   void process_octave_code (const QString& command);
 
 protected:
@@ -127,17 +128,17 @@ private:
   void save_file (const QString& saveFileName, bool remove_on_success = false);
   void save_file_as (bool remove_on_success = false);
   void message_duplicate_file_name (const QString& fileName);
 
   void update_lexer ();
   void request_add_breakpoint (int line);
   void request_remove_breakpoint (int line);
 
-  int check_file_modified (const QString& msg, int cancelButton);
+  int check_file_modified ();
   void do_comment_selected_text (bool comment);
 
   void run_file_callback (void);
   void add_breakpoint_callback (const bp_info& info);
   void remove_breakpoint_callback (const bp_info& info);
   void remove_all_breakpoints_callback (const bp_info& info);
 
   QsciScintilla *       _edit_area;
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -57,16 +57,33 @@ file_editor::~file_editor ()
   fetFileNames.clear ();
   if (settings->value ("editor/restoreSession",true).toBool ())
     {
       // Have all file editor tabs signal what their file names are.
       emit fetab_file_name_query (0);
     }
   settings->setValue ("editor/savedSessionTabs", fetFileNames);
   settings->sync ();
+
+  if (_mru_file_menu)
+    delete _mru_file_menu;
+}
+
+// set focus to editor and its current tab
+void
+file_editor::set_focus ()
+{
+  if (!isVisible ())
+    setVisible (true);
+  setFocus ();
+  activateWindow ();
+  raise ();
+  QWidget *fileEditorTab = _tab_widget->currentWidget ();
+  if (fileEditorTab)
+    emit fetab_set_focus (fileEditorTab);
 }
 
 QMenu *
 file_editor::debug_menu ()
 {
   return _debug_menu;
 }
 
@@ -93,31 +110,32 @@ file_editor::request_new_file ()
 {
   // New file isn't a file_editor_tab function since the file
   // editor tab has yet to be created and there is no object to
   // pass a signal to.  Hence, functionality is here.
 
   file_editor_tab *fileEditorTab = new file_editor_tab (ced);
   if (fileEditorTab)
     {
-      add_file_editor_tab (fileEditorTab, UNNAMED_FILE);
-      fileEditorTab->new_file ();
+      add_file_editor_tab (fileEditorTab, "");  // new tab with empty title
+      fileEditorTab->new_file ();               // title is updated here
+      set_focus ();                             // focus editor and new tab
     }
 }
 
 void
 file_editor::request_open_file ()
 {
   // Open file isn't a file_editor_tab function since the file
   // editor tab has yet to be created and there is no object to
   // pass a signal to.  Hence, functionality is here.
 
   // Create a NonModal message.
   QFileDialog* fileDialog = new QFileDialog (this);
-  fileDialog->setNameFilter (SAVE_FILE_FILTER);
+  fileDialog->setNameFilter (tr("Octave Files (*.m);;All Files (*.*)"));
   fileDialog->setAcceptMode (QFileDialog::AcceptOpen);
   fileDialog->setViewMode (QFileDialog::Detail);
   fileDialog->setDirectory (ced);
   connect (fileDialog, SIGNAL (fileSelected (const QString&)),
            this, SLOT (request_open_file (const QString&)));
   fileDialog->setWindowModality (Qt::NonModal);
   fileDialog->setAttribute (Qt::WA_DeleteOnClose);
   fileDialog->show ();
@@ -185,16 +203,17 @@ file_editor::request_open_file (const QS
                       tr ("Could not open file %1 for read:\n%2.").
                       arg (openFileName).arg (result),
                       QMessageBox::Ok, 0);
               msgBox->setWindowModality (Qt::NonModal);
               msgBox->setAttribute (Qt::WA_DeleteOnClose);
               msgBox->show ();
             }
         }
+      set_focus ();  // really show editor and the current editor tab
     }
 }
 
 // open a file from the mru list
 void
 file_editor::request_mru_open_file ()
 {
   QAction *action = qobject_cast<QAction *>(sender ());
@@ -406,26 +425,27 @@ file_editor::mru_menu_update ()
       _mru_files.removeLast ();
     // save actual mru-list in settings
     QSettings *settings = resource_manager::get_settings ();
     // FIXME -- what should happen if settings is 0?
     settings->setValue ("editor/mru_file_list",_mru_files);
 }
 
 void
-file_editor::handle_file_name_changed (const QString& fileName)
+file_editor::handle_file_name_changed (const QString& fileName, const QString& toolTip)
 {
   QObject *fileEditorTab = sender();
   if (fileEditorTab)
     {
       for(int i = 0; i < _tab_widget->count (); i++)
         {
           if (_tab_widget->widget (i) == fileEditorTab)
             {
               _tab_widget->setTabText (i, fileName);
+              _tab_widget->setTabToolTip (i, toolTip);
             }
         }
     }
 }
 
 void
 file_editor::handle_tab_close_request (int index)
 {
@@ -626,22 +646,22 @@ file_editor::construct ()
 
   // menu bar
   QMenu *fileMenu = new QMenu (tr ("&File"), _menu_bar);
   fileMenu->addAction (new_action);
   fileMenu->addAction (open_action);
   fileMenu->addAction (save_action);
   fileMenu->addAction (save_as_action);
   fileMenu->addSeparator ();
-  QMenu *mru_file_menu = new QMenu (tr ("Open &Recent"), fileMenu);
+  _mru_file_menu = new QMenu (tr ("&Recent Editor Files"), fileMenu);
   for (int i = 0; i < MaxMRUFiles; ++i)
     {
-      mru_file_menu->addAction (_mru_file_actions[i]);
+      _mru_file_menu->addAction (_mru_file_actions[i]);
     }
-  fileMenu->addMenu (mru_file_menu);
+  fileMenu->addMenu (_mru_file_menu);
   _menu_bar->addMenu (fileMenu);
 
   QMenu *editMenu = new QMenu (tr ("&Edit"), _menu_bar);
   editMenu->addAction (undo_action);
   editMenu->addAction (redo_action);
   editMenu->addSeparator ();
   editMenu->addAction (_copy_action);
   editMenu->addAction (_cut_action);
@@ -749,18 +769,18 @@ file_editor::construct ()
 }
 
 void
 file_editor::add_file_editor_tab (file_editor_tab *f, const QString &fn)
 {
   _tab_widget->addTab (f, fn);
 
   // Signals from the file editor_tab
-  connect (f, SIGNAL (file_name_changed (const QString&)),
-           this, SLOT (handle_file_name_changed (const QString&)));
+  connect (f, SIGNAL (file_name_changed (const QString&, const QString&)),
+           this, SLOT (handle_file_name_changed (const QString&, const QString&)));
   connect (f, SIGNAL (editor_state_changed (bool, const QString&)),
            this, SLOT (handle_editor_state_changed (bool, const QString&)));
   connect (f, SIGNAL (tab_remove_request ()),
            this, SLOT (handle_tab_remove_request ()));
   connect (f, SIGNAL (add_filename_to_list (const QString&)),
            this, SLOT (handle_add_filename_to_list (const QString&)));
   connect (f, SIGNAL (editor_check_conflict_save (const QString&, bool)),
            this, SLOT (check_conflict_save (const QString&, bool)));
@@ -814,13 +834,15 @@ file_editor::add_file_editor_tab (file_e
   connect (this, SIGNAL (fetab_remove_all_breakpoints (const QWidget*)),
            f, SLOT (remove_all_breakpoints (const QWidget*)));
   connect (this, SIGNAL (fetab_comment_selected_text (const QWidget*)),
            f, SLOT (comment_selected_text (const QWidget*)));
   connect (this, SIGNAL (fetab_uncomment_selected_text (const QWidget*)),
            f, SLOT (uncomment_selected_text (const QWidget*)));
   connect (this, SIGNAL (fetab_find (const QWidget*)),
            f, SLOT (find (const QWidget*)));
+  connect (this, SIGNAL (fetab_set_focus (const QWidget*)),
+           f, SLOT (set_focus (const QWidget*)));
 
   _tab_widget->setCurrentWidget (f);
 }
 
 #endif
diff --git a/libgui/src/m-editor/file-editor.h b/libgui/src/m-editor/file-editor.h
--- a/libgui/src/m-editor/file-editor.h
+++ b/libgui/src/m-editor/file-editor.h
@@ -28,37 +28,37 @@ along with Octave; see the file COPYING.
 #include <QMenuBar>
 #include <QStatusBar>
 #include <QCloseEvent>
 #include <QTabWidget>
 
 #include "file-editor-interface.h"
 #include "file-editor-tab.h"
 
-const char UNNAMED_FILE[]     = "<unnamed>";
-const char SAVE_FILE_FILTER[] = "Octave Files (*.m);;All Files (*.*)";
 enum editor_markers
   {
     bookmark,
     breakpoint,
     debugger_position
   };
 
 class file_editor : public file_editor_interface
 {
   Q_OBJECT
 
   public:
   file_editor (QWidget *p);
   ~file_editor ();
   void loadFile (const QString& fileName);
 
+  QMenu *           get_mru_menu ( ) { return _mru_file_menu; }
   QMenu *           debug_menu ();
   QToolBar *        toolbar ();
 
+  void set_focus ();
   void handle_entered_debug_mode ();
   void handle_quit_debug_mode ();
 
 signals:
   void fetab_settings_changed ();
   void fetab_close_request (const QWidget* ID);
   void fetab_change_request (const QWidget* ID);
   void fetab_file_name_query (const QWidget* ID);
@@ -80,16 +80,17 @@ signals:
   void fetab_remove_bookmark (const QWidget* ID);
   void fetab_toggle_breakpoint (const QWidget* ID);
   void fetab_next_breakpoint (const QWidget* ID);
   void fetab_previous_breakpoint (const QWidget* ID);
   void fetab_remove_all_breakpoints (const QWidget* ID);
   void fetab_comment_selected_text (const QWidget* ID);
   void fetab_uncomment_selected_text (const QWidget* ID);
   void fetab_find (const QWidget* ID);
+  void fetab_set_focus (const QWidget* ID);
 
 public slots:
   void request_new_file ();
   void request_open_file ();
   void request_mru_open_file ();
 
   void request_undo ();
   void request_redo ();
@@ -108,17 +109,17 @@ public slots:
   void request_next_breakpoint ();
   void request_previous_breakpoint ();
   void request_remove_breakpoint ();
 
   void request_comment_selected_text ();
   void request_uncomment_selected_text ();
   void request_find ();
 
-  void handle_file_name_changed (const QString& fileName);
+  void handle_file_name_changed (const QString& fileName, const QString& toolTip);
   void handle_tab_close_request (int index);
   void handle_tab_remove_request ();
   void handle_add_filename_to_list (const QString& fileName);
   void active_tab_changed (int index);
   void handle_editor_state_changed (bool enableCopy, const QString& fileName);
   void handle_mru_add_file (const QString& file_name);
   void check_conflict_save (const QString& fileName, bool remove_on_success);
 
@@ -145,14 +146,15 @@ private:
   QMenu *           _debug_menu;
   QAction *         _copy_action;
   QAction *         _cut_action;
   QAction *         _run_action;
   QTabWidget *      _tab_widget;
   int               _marker_breakpoint;
 
   enum { MaxMRUFiles = 10 };
+  QMenu *_mru_file_menu;
   QAction *_mru_file_actions[MaxMRUFiles];
   QStringList _mru_files;
 
 };
 
 #endif // FILEEDITORMDISUBWINDOW_H
diff --git a/libgui/src/m-editor/find-dialog.cc b/libgui/src/m-editor/find-dialog.cc
--- a/libgui/src/m-editor/find-dialog.cc
+++ b/libgui/src/m-editor/find-dialog.cc
@@ -125,16 +125,31 @@ find_dialog::find_dialog (QsciScintilla*
   main_layout->addLayout (left_layout, 0, 0);
   main_layout->addWidget (_button_box, 0, 1);
   main_layout->addWidget (_extension, 1, 0, 1, 2);
   setLayout (main_layout);
 
   _extension->hide ();
 }
 
+
+// initialize search text with selected text if this is in one single line
+void
+find_dialog::init_search_text ()
+{
+  if (_edit_area->hasSelectedText ())
+    {
+      int lbeg, lend, cbeg, cend;
+      _edit_area->getSelection(&lbeg,&cbeg,&lend,&cend);
+      if (lbeg == lend)
+        _search_line_edit->setText (_edit_area->selectedText ());
+    }
+}
+
+
 void
 find_dialog::search_next ()
 {
   int line = -1, col = -1;
 
   _find_result_available = false;
   if (_from_start_check_box->isChecked ())
     {
diff --git a/libgui/src/m-editor/find-dialog.h b/libgui/src/m-editor/find-dialog.h
--- a/libgui/src/m-editor/find-dialog.h
+++ b/libgui/src/m-editor/find-dialog.h
@@ -52,16 +52,17 @@ class QLabel;
 class QLineEdit;
 class QPushButton;
 
 class find_dialog : public QDialog
 {
   Q_OBJECT
   public:
   find_dialog (QsciScintilla* edit_area, QWidget *parent = 0);
+  void init_search_text ();
 
 private slots:
   void search_next ();
   void replace ();
   void replace_all ();
 
 private:
   QLabel            *_search_label;
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -95,35 +95,32 @@ main_window::~main_window ()
     delete _workspace_view;
 }
 
 void
 main_window::new_file ()
 {
 #ifdef HAVE_QSCINTILLA
   _file_editor->request_new_file ();
-  focus_editor ();
 #endif
 }
 
 void
 main_window::open_file ()
 {
 #ifdef HAVE_QSCINTILLA
   _file_editor->request_open_file ();
-  focus_editor ();
 #endif
 }
 
 void
 main_window::open_file (const QString& file_name)
 {
 #ifdef HAVE_QSCINTILLA
   _file_editor->request_open_file (file_name);
-  focus_editor ();
 #endif
 }
 
 void
 main_window::report_status_message (const QString& statusMessage)
 {
   _status_bar->showMessage (statusMessage, 1000);
 }
@@ -161,38 +158,44 @@ main_window::handle_clear_history_reques
 {
   octave_link::post_event (this, &main_window::clear_history_callback);
 }
 
 void
 main_window::handle_command_double_clicked (const QString& command)
 {
   _terminal->sendText (command);
-  _terminal->setFocus ();
+  focus_command_window ();
+}
+
+void
+main_window::open_online_documentation_page ()
+{
+  QDesktopServices::openUrl (QUrl ("http://gnu.org/software/octave/doc/interpreter"));
 }
 
 void
 main_window::open_bug_tracker_page ()
 {
   QDesktopServices::openUrl (QUrl ("http://bugs.octave.org"));
 }
 
 void
+main_window::open_octave_forge_page ()
+{
+  QDesktopServices::openUrl (QUrl ("http://octave.sourceforge.net/"));
+}
+
+void
 main_window::open_agora_page ()
 {
   QDesktopServices::openUrl (QUrl ("http://agora.octave.org/"));
 }
 
 void
-main_window::open_octave_forge_page ()
-{
-  QDesktopServices::openUrl (QUrl ("http://octave.sourceforge.net/"));
-}
-
-void
 main_window::process_settings_dialog_request ()
 {
   settings_dialog *settingsDialog = new settings_dialog (this);
   int change_settings = settingsDialog->exec ();
   if (change_settings == QDialog::Accepted)
     {
       settingsDialog->write_changed_settings ();
       emit settings_changed ();
@@ -388,28 +391,23 @@ main_window::focus_workspace ()
       _workspace_view->setVisible (true);
     }
 
   _workspace_view->setFocus ();
   _workspace_view->activateWindow ();
   _workspace_view->raise ();
 }
 
+
 void
 main_window::focus_editor ()
 {
 #ifdef HAVE_QSCINTILLA
-  if (!_file_editor->isVisible ())
-    {
-      _file_editor->setVisible (true);
-    }
-
-  _file_editor->setFocus ();
-  _file_editor->activateWindow ();
-  _file_editor->raise ();
+  // call own function of editor in order to set focus to the current editor tab
+  _file_editor->set_focus ();
 #endif
 }
 
 void
 main_window::focus_documentation ()
 {
   if (!_documentation_dock_widget->isVisible ())
     {
@@ -417,16 +415,66 @@ main_window::focus_documentation ()
     }
 
   _documentation_dock_widget->setFocus ();
   _documentation_dock_widget->activateWindow ();
   _documentation_dock_widget->raise ();
 }
 
 void
+main_window::handle_command_window_visible (bool visible)
+{
+  // if widget is changed to visible and is not floating
+  if (visible && !_terminal_dock_widget->isFloating ())
+    focus_command_window ();
+}
+
+void
+main_window::handle_command_history_visible (bool visible)
+{
+  // if changed to visible and widget is not floating
+  if (visible && !_history_dock_widget->isFloating ())
+    focus_command_history ();
+}
+
+void
+main_window::handle_current_directory_visible (bool visible)
+{
+  // if changed to visible and widget is not floating
+  if (visible && !_files_dock_widget->isFloating ())
+    focus_current_directory ();
+}
+
+void
+main_window::handle_workspace_visible (bool visible)
+{
+  // if changed to visible and widget is not floating
+  if (visible && !_workspace_view->isFloating ())
+    focus_workspace ();
+}
+
+void
+main_window::handle_editor_visible (bool visible)
+{
+  // if changed to visible and widget is not floating
+#ifdef HAVE_QSCINTILLA
+  if (visible && !_file_editor->isFloating ())
+    focus_editor ();
+#endif
+}
+
+void
+main_window::handle_documentation_visible (bool visible)
+{
+  // if changed to visible and widget is not floating
+  if (visible && !_documentation_dock_widget->isFloating ())
+    focus_documentation ();
+}
+
+void
 main_window::handle_entered_debug_mode ()
 {
   setWindowTitle ("Octave (Debugging)");
   _debug_continue->setEnabled (true);
   _debug_step_into->setEnabled (true);
   _debug_step_over->setEnabled (true);
   _debug_step_out->setEnabled (true);
   _debug_quit->setEnabled (true);
@@ -562,16 +610,40 @@ main_window::write_settings ()
   for (int i=0; i<_current_directory_combo_box->count (); i++)
     {
       curr_dirs.append (_current_directory_combo_box->itemText (i));
     }
   settings->setValue ("MainWindow/current_directory_list",curr_dirs);
   settings->sync ();
 }
 
+
+// Connecting the signals emitted when the visibility of a widget changes.
+// This has to be done after the window is shown (see octave-gui.cc)
+void
+main_window::connect_visibility_changed ()
+{
+  connect (_terminal_dock_widget, SIGNAL (visibilityChanged (bool)),
+           this,                  SLOT (handle_command_window_visible (bool)));
+  connect (_workspace_view,       SIGNAL (visibilityChanged (bool)),
+           this,                  SLOT (handle_workspace_visible (bool)));
+  connect (_history_dock_widget,  SIGNAL (visibilityChanged (bool)),
+           this,                  SLOT (handle_command_history_visible (bool)));
+  connect (_files_dock_widget,    SIGNAL (visibilityChanged (bool)),
+           this,                  SLOT (handle_current_directory_visible (bool)));
+#ifdef HAVE_QSCINTILLA
+  connect (_file_editor,          SIGNAL (visibilityChanged (bool)),
+           this,                  SLOT (handle_editor_visible (bool)));
+#endif
+  connect (_documentation_dock_widget,  SIGNAL (visibilityChanged (bool)),
+           this,                  SLOT (handle_documentation_visible (bool)));
+}
+
+
+// Main subroutine of the constructor
 void
 main_window::construct ()
 {
   _closing = false;   // flag for editor files when closed
   setWindowIcon (QIcon(":/actions/icons/logo.png"));
 
   // Setup dockable widgets and the status bar.
   _workspace_view           = new workspace_view (this);
@@ -642,96 +714,107 @@ main_window::construct ()
   new_model_action->setEnabled (false); // TODO: Make this work.
   QAction *new_gui_action = new_menu->addAction (tr ("GUI"));
   new_gui_action->setEnabled (false); // TODO: Make this work.
 
   QAction *open_action
     = file_menu->addAction (QIcon(":/actions/icons/fileopen.png"), tr ("Open..."));
   open_action->setShortcut (Qt::ControlModifier + Qt::Key_O);
 
+  file_menu->addMenu(_file_editor->get_mru_menu ());
+
   QAction *close_command_window_action
     = file_menu->addAction (tr ("Close Command Window"));
   close_command_window_action->setShortcut (Qt::ControlModifier + Qt::Key_W);
   close_command_window_action->setEnabled (false); // TODO: Make this work.
 
-  file_menu->addSeparator ();
+  file_menu->addSeparator (); /////
+
   QAction *import_data_action
     = file_menu->addAction (tr ("Import Data..."));
   import_data_action->setEnabled (false); // TODO: Make this work.
 
   QAction *save_workspace_action
     = file_menu->addAction (tr ("Save Workspace..."));
   save_workspace_action->setShortcut (Qt::ControlModifier + Qt::Key_S);
-  file_menu->addSeparator ();
+
+  file_menu->addSeparator (); /////
 
   QAction *preferences_action
     = file_menu->addAction (QIcon(":/actions/icons/configure.png"),
                             tr ("Preferences..."));
-  file_menu->addSeparator ();
+
+  file_menu->addSeparator (); /////
+
   QAction *page_setup_action
     = file_menu->addAction (tr ("Page Setup..."));
   page_setup_action->setEnabled (false); // TODO: Make this work.
   QAction *print_action
     = file_menu->addAction (tr ("Print"));
   print_action->setShortcut (Qt::ControlModifier + Qt::Key_P);
   print_action->setEnabled (false); // TODO: Make this work.
   QAction *print_selection_action
     = file_menu->addAction (tr ("Print Selection..."));
   print_selection_action->setEnabled (false); // TODO: Make this work.
 
-  file_menu->addSeparator ();
+  file_menu->addSeparator (); /////
+
   QAction *exit_action = file_menu->addAction (tr ("Exit"));
   exit_action->setShortcut (Qt::ControlModifier + Qt::Key_Q);
 
 
   QMenu *edit_menu = menuBar ()->addMenu (tr ("&Edit"));
   QAction *undo_action
     = edit_menu->addAction (QIcon(":/actions/icons/undo.png"), tr ("Undo"));
   undo_action->setShortcut (QKeySequence::Undo);
 
   QAction *redo_action
     = edit_menu->addAction (QIcon(":/actions/icons/redo.png"), tr ("Redo"));
   redo_action->setShortcut (QKeySequence::Redo);
-  edit_menu->addSeparator ();
+
+  edit_menu->addSeparator (); /////
 
   QAction *cut_action
     = edit_menu->addAction (QIcon(":/actions/icons/editcut.png"), tr ("Cut"));
   cut_action->setShortcut (Qt::ControlModifier + Qt::ShiftModifier + Qt::Key_X);
 
   QAction *copy_action
     = edit_menu->addAction (QIcon(":/actions/icons/editcopy.png"), tr ("Copy"));
   copy_action->setShortcut (Qt::ControlModifier + Qt::ShiftModifier + Qt::Key_C);
 
   QAction *paste_action
     = edit_menu->addAction (QIcon(":/actions/icons/editpaste.png"), tr ("Paste"));
   paste_action->setShortcut (Qt::ControlModifier + Qt::ShiftModifier + Qt::Key_V);
 
   QAction *paste_to_workspace_action
     = edit_menu->addAction (tr ("Paste To Workspace..."));
   paste_to_workspace_action->setEnabled (false); // TODO: Make this work.
-  edit_menu->addSeparator ();
+
+  edit_menu->addSeparator (); /////
 
   QAction *select_all_action
     = edit_menu->addAction (tr ("Select All"));
   select_all_action->setEnabled (false); // TODO: Make this work.
   QAction *delete_action
     = edit_menu->addAction (tr ("Delete"));
   delete_action->setShortcut (Qt::Key_Delete);
   delete_action->setEnabled (false); // TODO: Make this work.
-  edit_menu->addSeparator ();
+
+  edit_menu->addSeparator (); /////
 
   QAction *find_action
     = edit_menu->addAction (tr ("Find..."));
   find_action->setEnabled (false); // TODO: Make this work.
   QAction *find_files_action
     = edit_menu->addAction (tr ("Find Files..."));
   find_files_action->setShortcut (Qt::ControlModifier + Qt::ShiftModifier
                                   + Qt::Key_F);
   find_files_action->setEnabled (false); // TODO: Make this work.
-  edit_menu->addSeparator ();
+
+  edit_menu->addSeparator (); /////
 
   QAction *clear_command_window_action
     = edit_menu->addAction (tr ("Clear Command Window"));
   clear_command_window_action->setEnabled (false); // TODO: Make this work.
   QAction *clear_command_history
     = edit_menu->addAction(tr ("Clear Command History"));
   QAction * clear_workspace_action
     = edit_menu->addAction (tr ("Clear Workspace"));
@@ -765,19 +848,19 @@ main_window::construct ()
   _debug_continue = _debug_menu->addAction (QIcon (":/actions/icons/db_cont.png"), tr ("Continue"));
   _debug_continue->setEnabled (false);
 #ifdef HAVE_QSCINTILLA
   _file_editor->debug_menu ()->addAction (_debug_continue);
   _file_editor->toolbar ()->addAction (_debug_continue);
 #endif
   _debug_continue->setShortcut (Qt::Key_F5);
 
-  _debug_menu->addSeparator ();
+  _debug_menu->addSeparator (); /////
 #ifdef HAVE_QSCINTILLA
-  _file_editor->debug_menu ()->addSeparator ();
+  _file_editor->debug_menu ()->addSeparator (); /////
 #endif
 
   _debug_quit = _debug_menu->addAction (QIcon (":/actions/icons/db_stop.png"), tr ("Exit Debug Mode"));
   _debug_quit->setEnabled (false);
 #ifdef HAVE_QSCINTILLA
   _file_editor->debug_menu ()->addAction (_debug_quit);
   _file_editor->toolbar ()->addAction (_debug_quit);
 #endif
@@ -818,17 +901,17 @@ main_window::construct ()
   show_editor_action->setCheckable (true);
   show_editor_action->setShortcut (Qt::ControlModifier + Qt::ShiftModifier
                                    + Qt::Key_4);
 
   QAction * show_documentation_action = window_menu->addAction (tr ("Show Documentation"));
   show_documentation_action->setCheckable (true);
   show_documentation_action->setShortcut (Qt::ControlModifier + Qt::ShiftModifier
                                           + Qt::Key_5);
-  window_menu->addSeparator ();
+  window_menu->addSeparator (); /////
 
   QAction * command_window_action
     = window_menu->addAction (tr ("Command Window"));
   command_window_action->setShortcut (Qt::ControlModifier + Qt::Key_0);
 
   QAction * history_action
     = window_menu->addAction (tr ("Command History"));
   history_action->setShortcut (Qt::ControlModifier + Qt::Key_1);
@@ -844,46 +927,61 @@ main_window::construct ()
   QAction * editor_action
     = window_menu->addAction (tr ("Editor"));
   editor_action->setShortcut (Qt::ControlModifier + Qt::Key_4);
 
   QAction * documentation_action
     = window_menu->addAction (tr ("Documentation"));
   documentation_action->setShortcut (Qt::ControlModifier + Qt::Key_5);
 
-  window_menu->addSeparator ();
+  window_menu->addSeparator (); /////
+
   QAction * reset_windows_action
     = window_menu->addAction (tr ("Reset Windows"));
   reset_windows_action->setEnabled (false); // TODO: Make this work.
 
   // Help menu
   QMenu *   help_menu = menuBar ()->addMenu (tr ("&Help"));
+  QMenu * documentation_menu
+    = help_menu->addMenu (tr ("Documentation"));
+  QAction * ondisk_documentation_action
+    = documentation_menu->addAction (tr ("On Disk"));
+  QAction * online_documentation_action
+    = documentation_menu->addAction (tr ("Online"));
+
+  help_menu->addSeparator (); /////
+
   QAction * report_bug_action
     = help_menu->addAction (tr ("Report Bug"));
+  QAction * octave_forge_action
+    = help_menu->addAction (tr ("Visit Octave Forge"));
   QAction * agora_action
     = help_menu->addAction (tr ("Visit Agora"));
-  QAction * octave_forge_action
-    = help_menu->addAction (tr ("Visit Octave Forge"));
-  help_menu->addSeparator ();
+
+  help_menu->addSeparator (); /////
 
   QAction * about_octave_action
     = help_menu->addAction (tr ("About Octave"));
 
   // Toolbars
   QToolBar *main_tool_bar = addToolBar ("Main");
   main_tool_bar->setObjectName ("MainToolBar");
   main_tool_bar->addAction (new_script_action);
   main_tool_bar->addAction (open_action);
-  main_tool_bar->addSeparator ();
+
+  main_tool_bar->addSeparator (); /////
+
   main_tool_bar->addAction (cut_action);
   main_tool_bar->addAction (copy_action);
   main_tool_bar->addAction (paste_action);
   main_tool_bar->addAction (undo_action);
   main_tool_bar->addAction (redo_action);
-  main_tool_bar->addSeparator ();
+
+  main_tool_bar->addSeparator (); /////
+
   // addWidget takes ownership of the objects so there is no
   // need to delete these upon destroying this main_window.
   main_tool_bar->addWidget (new QLabel (tr ("Current Directory:")));
   main_tool_bar->addWidget (_current_directory_combo_box);
   main_tool_bar->addWidget (current_directory_tool_button);
   main_tool_bar->addWidget (current_directory_up_tool_button);
 
   connect (qApp,                        SIGNAL (aboutToQuit ()),
@@ -891,22 +989,24 @@ main_window::construct ()
   connect (preferences_action,          SIGNAL (triggered ()),
            this,                        SLOT   (process_settings_dialog_request ()));
   connect (exit_action,                 SIGNAL (triggered ()),
            this,                        SLOT   (close ()));
   connect (new_script_action,           SIGNAL (triggered ()),
            this,                        SLOT   (new_file ()));
   connect (open_action,                 SIGNAL (triggered ()),
            this,                        SLOT   (open_file ()));
+  connect (online_documentation_action, SIGNAL (triggered ()),
+           this,                        SLOT   (open_online_documentation_page ()));
   connect (report_bug_action,           SIGNAL (triggered ()),
            this,                        SLOT   (open_bug_tracker_page ()));
+  connect (octave_forge_action,         SIGNAL (triggered ()),
+           this,                        SLOT   (open_octave_forge_page ()));
   connect (agora_action,                SIGNAL (triggered ()),
            this,                        SLOT   (open_agora_page ()));
-  connect (octave_forge_action,         SIGNAL (triggered ()),
-           this,                        SLOT   (open_octave_forge_page ()));
   connect (about_octave_action,         SIGNAL (triggered ()),
            this,                        SLOT   (show_about_octave ()));
   connect (show_command_window_action,  SIGNAL (toggled (bool)),
            _terminal_dock_widget,       SLOT   (setVisible (bool)));
   connect (_terminal_dock_widget,       SIGNAL (active_changed (bool)),
            show_command_window_action,  SLOT   (setChecked (bool)));
   connect (show_workspace_action,       SIGNAL (toggled (bool)),
            _workspace_view,             SLOT   (setVisible (bool)));
@@ -938,16 +1038,18 @@ main_window::construct ()
   connect (history_action,              SIGNAL (triggered ()),
            this,                        SLOT (focus_command_history ()));
   connect (file_browser_action,         SIGNAL (triggered ()),
            this,                        SLOT (focus_current_directory ()));
   connect (editor_action,               SIGNAL (triggered ()),
            this,                        SLOT (focus_editor ()));
   connect (documentation_action,        SIGNAL (triggered ()),
            this,                        SLOT (focus_documentation ()));
+  connect (ondisk_documentation_action, SIGNAL (triggered ()),
+           this,                        SLOT (focus_documentation ()));
 
   connect (reset_windows_action,        SIGNAL (triggered ()),
            this,                        SLOT   (reset_windows ()));
 #ifdef HAVE_QSCINTILLA
   connect (this,                        SIGNAL (settings_changed ()),
            _file_editor,                SLOT   (notice_settings ()));
 #endif
   connect (this,                        SIGNAL (settings_changed ()),
diff --git a/libgui/src/main-window.h b/libgui/src/main-window.h
--- a/libgui/src/main-window.h
+++ b/libgui/src/main-window.h
@@ -81,19 +81,20 @@ public slots:
   void handle_save_workspace_request ();
   void handle_load_workspace_request ();
   void handle_clear_workspace_request ();
   void handle_clear_history_request ();
   void handle_command_double_clicked (const QString& command);
   void new_file ();
   void open_file ();
   void open_file (const QString& file_name);
+  void open_online_documentation_page ();
   void open_bug_tracker_page ();
+  void open_octave_forge_page ();
   void open_agora_page ();
-  void open_octave_forge_page ();
   void process_settings_dialog_request ();
   void show_about_octave ();
   void notice_settings ();
   void prepare_for_quit ();
   void reset_windows ();
   void current_working_directory_has_changed (const QString& directory);
   void change_current_working_directory ();
   void set_current_working_directory (const QString& directory);
@@ -101,27 +102,34 @@ public slots:
   void current_working_directory_entered ();
 
   void focus_command_window ();
   void focus_command_history ();
   void focus_current_directory ();
   void focus_workspace ();
   void focus_editor ();
   void focus_documentation ();
+  void handle_command_window_visible (bool);
+  void handle_command_history_visible (bool);
+  void handle_current_directory_visible (bool);
+  void handle_workspace_visible (bool);
+  void handle_editor_visible (bool);
+  void handle_documentation_visible (bool);
 
   void handle_entered_debug_mode ();
   void handle_quit_debug_mode ();
   void debug_continue ();
   void debug_step_into ();
   void debug_step_over ();
   void debug_step_out ();
   void debug_quit ();
 
   void read_settings ();
   void write_settings ();
+  void connect_visibility_changed ();
 
 protected:
   void closeEvent (QCloseEvent * closeEvent);
 
 private:
   void construct ();
   void establish_octave_link ();
 
diff --git a/libgui/src/octave-adapter/octave-main-thread.cc b/libgui/src/octave-adapter/octave-main-thread.cc
--- a/libgui/src/octave-adapter/octave-main-thread.cc
+++ b/libgui/src/octave-adapter/octave-main-thread.cc
@@ -19,16 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include <clocale>
 #include <string>
 
 #include "octave.h"
 
 #include "octave-main-thread.h"
 #include "octave-link.h"
 
 octave_main_thread::octave_main_thread () : QThread ()
diff --git a/libgui/src/octave-gui.cc b/libgui/src/octave-gui.cc
--- a/libgui/src/octave-gui.cc
+++ b/libgui/src/octave-gui.cc
@@ -21,17 +21,16 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <QtGui/QApplication>
 #include <QTranslator>
-#include <QSettings>
 
 #include <iostream>
 
 #include "lo-utils.h"
 #include "oct-env.h"
 #include "syswait.h"
 
 #include "welcome-wizard.h"
@@ -90,30 +89,29 @@ octave_start_gui (int argc, char *argv[]
       if (resource_manager::is_first_run ())
         {
           welcome_wizard welcomeWizard;
           welcomeWizard.exec ();
           resource_manager::reload_settings ();
         }
       else
         {
-          QSettings *settings = resource_manager::get_settings ();
-
-          // FIXME -- what should happen if settings is 0?
-
-          QString language = settings->value ("language").toString ();
+          // install translators for the gui and qt text
+          QTranslator gui_translator, qt_translator;
+          resource_manager::config_translators (&gui_translator,&qt_translator);
+          application.installTranslator (&qt_translator);
+          application.installTranslator (&gui_translator);
 
-          QString translatorFile = resource_manager::find_translator_file (language);
-          QTranslator translator;
-          translator.load (translatorFile);
-          application.installTranslator (&translator);
-
+          // update network-settings
           resource_manager::update_network_settings ();
 
+          // create main window, read settings, and show window
           main_window w;
-          w.read_settings ();  // Get the widget settings after construction and before showing
+          w.read_settings ();  // get widget settings after construction
+                               // but before showing
           w.show ();
           w.focus_command_window ();
-
+          w.connect_visibility_changed (); // connect signals for changes in
+                                           // visibility not before w is shown
           return application.exec ();
         }
     }
 }
diff --git a/libgui/src/resource-manager.cc b/libgui/src/resource-manager.cc
--- a/libgui/src/resource-manager.cc
+++ b/libgui/src/resource-manager.cc
@@ -24,16 +24,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include <string>
 
 #include <QFile>
 #include <QDir>
 #include <QNetworkProxy>
+ #include <QLibraryInfo>
 
 #include "error.h"
 #include "file-ops.h"
 #include "oct-env.h"
 #include "singleton-cleanup.h"
 
 #include "defaults.h"
 
@@ -47,21 +48,41 @@ resource_manager::resource_manager (void
   do_reload_settings ();
 }
 
 resource_manager::~resource_manager (void)
 {
   delete settings;
 }
 
+
 QString
-resource_manager::find_translator_file (const QString& language)
+resource_manager::get_gui_translation_dir (void)
 {
-  // TODO: Quick hack to be able to test language files.
-  return QString ("libgui/languages/%1.qm").arg (language);
+  // get environment variable for the locale dir (e.g. from run-octave)
+  std::string dldir = octave_env::getenv ("OCTAVE_LOCALE_DIR");
+  if (dldir.empty ())
+    dldir = Voct_locale_dir; // env-var empty, load the default location
+  return QString::fromStdString (dldir);
+}
+
+void
+resource_manager::config_translators (QTranslator *qt_tr,QTranslator *gui_tr)
+{
+  QSettings *settings = resource_manager::get_settings ();
+  // FIXME -- what should happen if settings is 0?
+  // get the locale from the settings
+  QString language = settings->value ("language","SYSTEM").toString ();
+  if (language == "SYSTEM")
+      language = QLocale::system().name();    // get system wide locale
+  // load the translator file for qt strings
+  qt_tr->load("qt_" + language,
+              QLibraryInfo::location(QLibraryInfo::TranslationsPath));
+  // load the translator file for gui strings
+  gui_tr->load (language, get_gui_translation_dir ());
 }
 
 bool
 resource_manager::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
diff --git a/libgui/src/resource-manager.h b/libgui/src/resource-manager.h
--- a/libgui/src/resource-manager.h
+++ b/libgui/src/resource-manager.h
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 
 #ifndef RESOURCEMANAGER_H
 #define RESOURCEMANAGER_H
 
 #include <QDesktopServices>
 #include <QIcon>
 #include <QMap>
 #include <QSettings>
-
+#include <QTranslator>
 
 class resource_manager
 {
 protected:
 
   resource_manager (void);
 
 public:
@@ -56,17 +56,19 @@ public:
   }
 
   static void set_settings (const QString& file)
   {
     if (instance_ok ())
       instance->do_set_settings (file);
   }
 
-  static QString find_translator_file (const QString& language);
+  static QString get_gui_translation_dir (void);
+
+  static void config_translators (QTranslator*, QTranslator*);
 
   static void update_network_settings (void)
   {
     if (instance_ok ())
       instance->do_update_network_settings ();
   }
 
   static bool is_first_run (void)
diff --git a/libgui/src/settings-dialog.cc b/libgui/src/settings-dialog.cc
--- a/libgui/src/settings-dialog.cc
+++ b/libgui/src/settings-dialog.cc
@@ -23,26 +23,47 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "resource-manager.h"
 #include "settings-dialog.h"
 #include "ui-settings-dialog.h"
 #include <QSettings>
+#include <QDir>
+#include <QFileInfo>
 
 settings_dialog::settings_dialog (QWidget *p):
   QDialog (p), ui (new Ui::settings_dialog)
 {
   ui->setupUi (this);
 
   QSettings *settings = resource_manager::get_settings ();
-
   // FIXME -- what should happen if settings is 0?
 
+  // look for available language files and the actual settings
+  QString qm_dir_name = resource_manager::get_gui_translation_dir ();
+  QDir qm_dir (qm_dir_name);
+  QFileInfoList qm_files = qm_dir.entryInfoList (QStringList ("*.qm"),
+                                                 QDir::Files | QDir::Readable,
+                                                 QDir::Name);
+  for (int i = 0; i < qm_files.length (); i++)    // insert available languages
+    ui->comboBox_language->addItem (qm_files.at (i).baseName ());
+  ui->comboBox_language->insertItem (0,tr("System setting")); // System at beginning
+  ui->comboBox_language->insertSeparator (1);         // separator after System
+  QString language = settings->value ("language","SYSTEM").toString ();
+  if (language == "SYSTEM")
+    language = tr("System setting");
+  int selected = ui->comboBox_language->findText (language);
+  if (selected >= 0)
+    ui->comboBox_language->setCurrentIndex (selected);
+  else
+    ui->comboBox_language->setCurrentIndex (0);  // System is default
+
+  // which icon has to be selected
   QString widget_icon_set =
       settings->value ("DockWidgets/widget_icon_set","NONE").toString ();
   ui->general_icon_octave-> setChecked (true);  // the default (if invalid set)
   ui->general_icon_octave-> setChecked (widget_icon_set == "NONE");
   ui->general_icon_graphic-> setChecked (widget_icon_set == "GRAPHIC");
   ui->general_icon_letter-> setChecked (widget_icon_set == "LETTER");
 
   ui->useCustomFileEditor->setChecked (settings->value ("useCustomFileEditor").toBool ());
@@ -99,25 +120,33 @@ settings_dialog::~settings_dialog ()
 {
   delete ui;
 }
 
 void
 settings_dialog::write_changed_settings ()
 {
   QSettings *settings = resource_manager::get_settings ();
-
   // FIXME -- what should happen if settings is 0?
 
+  // the icon set
   QString widget_icon_set = "NONE";
   if (ui->general_icon_letter->isChecked ())
     widget_icon_set = "LETTER";
   else if (ui->general_icon_graphic->isChecked ())
     widget_icon_set = "GRAPHIC";
   settings->setValue ("DockWidgets/widget_icon_set",widget_icon_set);
+
+  // language
+  QString language = ui->comboBox_language->currentText ();
+  if (language == tr("System setting"))
+    language = "SYSTEM";
+  settings->setValue ("language", language);
+
+  // other settings
   settings->setValue ("useCustomFileEditor", ui->useCustomFileEditor->isChecked ());
   settings->setValue ("customFileEditor", ui->customFileEditor->text ());
   settings->setValue ("editor/showLineNumbers", ui->editor_showLineNumbers->isChecked ());
   settings->setValue ("editor/highlightCurrentLine", ui->editor_highlightCurrentLine->isChecked ());
   settings->setValue ("editor/codeCompletion", ui->editor_codeCompletion->isChecked ());
   settings->setValue ("editor/fontName", ui->editor_fontName->currentFont().family());
   settings->setValue ("editor/fontSize", ui->editor_fontSize->value());
   settings->setValue ("editor/longWindowTitle", ui->editor_longWindowTitle->isChecked());
@@ -133,16 +162,17 @@ settings_dialog::write_changed_settings 
   settings->setValue ("useProxyServer", ui->useProxyServer->isChecked ());
   settings->setValue ("proxyType", ui->proxyType->currentText ());
   settings->setValue ("proxyHostName", ui->proxyHostName->text ());
   settings->setValue ("proxyPort", ui->proxyPort->text ());
   settings->setValue ("proxyUserName", ui->proxyUserName->text ());
   settings->setValue ("proxyPassword", ui->proxyPassword->text ());
   settings->setValue ("terminal/cursorBlinking", ui->terminal_cursorBlinking->isChecked ());
 
+  // the cursor
   QString cursorType;
   switch (ui->terminal_cursorType->currentIndex ())
     {
     case 0: cursorType = "ibeam"; break;
     case 1: cursorType = "block"; break;
     case 2: cursorType = "underline";  break;
     }
   settings->setValue ("terminal/cursorType", cursorType);
diff --git a/libgui/src/settings-dialog.ui b/libgui/src/settings-dialog.ui
--- a/libgui/src/settings-dialog.ui
+++ b/libgui/src/settings-dialog.ui
@@ -36,85 +36,122 @@
      </property>
      <widget class="QWidget" name="tab_4">
       <property name="enabled">
        <bool>true</bool>
       </property>
       <attribute name="title">
        <string>General</string>
       </attribute>
-      <widget class="QGroupBox" name="groupBox">
+      <widget class="QWidget" name="verticalLayoutWidget">
        <property name="geometry">
         <rect>
-         <x>10</x>
+         <x>9</x>
          <y>10</y>
-         <width>551</width>
-         <height>81</height>
+         <width>561</width>
+         <height>131</height>
         </rect>
        </property>
-       <property name="sizePolicy">
-        <sizepolicy hsizetype="Expanding" vsizetype="Minimum">
-         <horstretch>0</horstretch>
-         <verstretch>0</verstretch>
-        </sizepolicy>
-       </property>
-       <property name="title">
-        <string>Icon set for dock widget</string>
-       </property>
-       <property name="alignment">
-        <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignTop</set>
-       </property>
-       <property name="flat">
-        <bool>false</bool>
-       </property>
-       <property name="checkable">
-        <bool>false</bool>
-       </property>
-       <widget class="QRadioButton" name="general_icon_octave">
-        <property name="geometry">
-         <rect>
-          <x>0</x>
-          <y>20</y>
-          <width>151</width>
-          <height>21</height>
-         </rect>
-        </property>
-        <property name="text">
-         <string>Octave logo only</string>
-        </property>
-        <property name="checked">
-         <bool>true</bool>
-        </property>
-       </widget>
-       <widget class="QRadioButton" name="general_icon_letter">
-        <property name="geometry">
-         <rect>
-          <x>0</x>
-          <y>40</y>
-          <width>151</width>
-          <height>21</height>
-         </rect>
-        </property>
-        <property name="text">
-         <string>Letter icons</string>
-        </property>
-       </widget>
-       <widget class="QRadioButton" name="general_icon_graphic">
-        <property name="geometry">
-         <rect>
-          <x>0</x>
-          <y>60</y>
-          <width>151</width>
-          <height>21</height>
-         </rect>
-        </property>
-        <property name="text">
-         <string>Graphic  icons</string>
-        </property>
-       </widget>
+       <layout class="QVBoxLayout" name="verticalLayout_7">
+        <item>
+         <layout class="QHBoxLayout" name="horizontalLayout_6">
+          <item>
+           <widget class="QLabel" name="label_2">
+            <property name="text">
+             <string>Language (requires restart)</string>
+            </property>
+           </widget>
+          </item>
+          <item>
+           <widget class="QComboBox" name="comboBox_language">
+            <property name="insertPolicy">
+             <enum>QComboBox::InsertAtBottom</enum>
+            </property>
+           </widget>
+          </item>
+          <item>
+           <spacer name="horizontalSpacer_3">
+            <property name="orientation">
+             <enum>Qt::Horizontal</enum>
+            </property>
+            <property name="sizeHint" stdset="0">
+             <size>
+              <width>40</width>
+              <height>20</height>
+             </size>
+            </property>
+           </spacer>
+          </item>
+         </layout>
+        </item>
+        <item>
+         <widget class="QGroupBox" name="groupBox">
+          <property name="sizePolicy">
+           <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
+            <horstretch>0</horstretch>
+            <verstretch>0</verstretch>
+           </sizepolicy>
+          </property>
+          <property name="title">
+           <string>Icon set for dock widgets</string>
+          </property>
+          <property name="alignment">
+           <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignVCenter</set>
+          </property>
+          <property name="flat">
+           <bool>false</bool>
+          </property>
+          <property name="checkable">
+           <bool>false</bool>
+          </property>
+          <widget class="QRadioButton" name="general_icon_octave">
+           <property name="geometry">
+            <rect>
+             <x>0</x>
+             <y>20</y>
+             <width>151</width>
+             <height>21</height>
+            </rect>
+           </property>
+           <property name="text">
+            <string>Octave logo only</string>
+           </property>
+           <property name="checked">
+            <bool>true</bool>
+           </property>
+          </widget>
+          <widget class="QRadioButton" name="general_icon_letter">
+           <property name="geometry">
+            <rect>
+             <x>0</x>
+             <y>40</y>
+             <width>151</width>
+             <height>21</height>
+            </rect>
+           </property>
+           <property name="text">
+            <string>Letter icons</string>
+           </property>
+          </widget>
+          <widget class="QRadioButton" name="general_icon_graphic">
+           <property name="geometry">
+            <rect>
+             <x>0</x>
+             <y>60</y>
+             <width>151</width>
+             <height>21</height>
+            </rect>
+           </property>
+           <property name="text">
+            <string>Graphic  icons</string>
+           </property>
+          </widget>
+         </widget>
+        </item>
+       </layout>
       </widget>
      </widget>
      <widget class="QWidget" name="tab">
       <attribute name="title">
        <string>Editor</string>
       </attribute>
       <layout class="QVBoxLayout" name="verticalLayout_6">
        <item>
diff --git a/libinterp/Makefile.am b/libinterp/Makefile.am
--- a/libinterp/Makefile.am
+++ b/libinterp/Makefile.am
@@ -225,16 +225,26 @@ DLL_CXXDEFS = @OCTINTERP_DLL_DEFS@
 ## FIXME -- Shouldn't the build stop if CPP fails here?
 %.df: %.cc
 	$(CXXCPP) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	  $(AM_CPPFLAGS) $(JAVA_CPPFLAGS) $(CPPFLAGS) \
 	  $(AM_CXXFLAGS) $(CXXFLAGS) \
 	  -DMAKE_BUILTINS $< | $(srcdir)/mkdefs $(srcdir) $< > $@-t
 	mv $@-t $@
 
+## Rules to build test files
+
+TST_FILES_SRC := $(shell $(top_srcdir)/build-aux/find-files-with-tests.sh "$(srcdir)" $(DIST_SRC) $(DLDFCN_SRC))
+
+TST_FILES := $(addsuffix -tst,$(TST_FILES_SRC))
+
+libinterptestsdir := $(octtestsdir)/libinterp
+
+nobase_libinterptests_DATA = $(TST_FILES)
+
 ## Override Automake's rule that forces a .hh extension on us even
 ## though we don't want it.  It would be super awesome if automake
 ## would allow users to choose the header file extension.
 .yy.cc:
 	$(am__skipyacc) $(SHELL) $(YLWRAP) $< y.tab.c $@ y.tab.h $*.h y.output $*.output -- $(YACCCOMPILE)
 
 ## Special rules:
 ## Mostly for sources which must be built before rest of compilation.
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -64,17 +64,24 @@ along with Octave; see the file COPYING.
 #include "ov-fcn-handle.h"
 
 static octave_value_list
 get_output_list (octave_idx_type count, octave_idx_type nargout,
                  const octave_value_list& inputlist,
                  octave_value& func,
                  octave_value& error_handler)
 {
-  octave_value_list tmp = func.do_multi_index_op (nargout, inputlist);
+  octave_value_list tmp;
+  try {
+    tmp = func.do_multi_index_op (nargout, inputlist);
+  }
+  catch (octave_execution_exception) {
+    if (error_handler.is_defined ())
+      error_state = 1;
+  }
 
   if (error_state)
     {
       if (error_handler.is_defined ())
         {
           octave_scalar_map msg;
           msg.assign ("identifier", last_error_id ());
           msg.assign ("message", last_error_message ());
@@ -991,16 +998,17 @@ v = cellfun (@@det, a); # faster\n\
 %!assert (cellfun ("size", {zeros([1,2,3]),1}, 2), [2,1])
 %!assert (cellfun ("size", {zeros([1,2,3]),1}, 3), [3,1])
 %!assert (cellfun (@atan2, {1,1}, {1,2}), [atan2(1,1), atan2(1,2)])
 %!assert (cellfun (@atan2, {1,1}, {1,2},"UniformOutput", false), {atan2(1,1), atan2(1,2)})
 %!assert (cellfun (@sin, {1,2;3,4}), sin ([1,2;3,4]))
 %!assert (cellfun (@atan2, {1,1;1,1}, {1,2;1,2}), atan2 ([1,1;1,1],[1,2;1,2]))
 %!error cellfun (@factorial, {-1,3})
 %!assert (cellfun (@factorial,{-1,3},"ErrorHandler",@(x,y) NaN), [NaN,6])
+%!assert (cellfun (@(x) x(2),{[1],[1,2]},"ErrorHandler",@(x,y) NaN), [NaN,2])
 %!test
 %! [a,b,c] = cellfun (@fileparts, {fullfile("a","b","c.d"), fullfile("e","f","g.h")}, "UniformOutput", false);
 %! assert (a, {fullfile("a","b"), fullfile("e","f")});
 %! assert (b, {"c", "g"});
 %! assert (c, {".d", ".h"});
 
 %!error cellfun (1)
 %!error cellfun ("isclass", 1)
@@ -1128,17 +1136,18 @@ arrayfun (@@str2num, [1234],\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
   int nargout1 = (nargout < 1 ? 1 : nargout);
 
   if (nargin < 2)
     {
-      error ("arrayfun: function requires at least 2 arguments");
+      error_with_id ("Octave:invalid-fun-call", 
+                     "arrayfun: function requires at least 2 arguments");
       print_usage ();
       return retval;
     }
 
   octave_value func = args(0);
   bool symbol_table_lookup = false;
 
   if (func.is_string ())
@@ -1159,17 +1168,19 @@ arrayfun (@@str2num, [1234],\n\
           if (ptr_func && ! error_state)
             func = octave_value (ptr_func, true);
         }
       else
         {
           func = symbol_table::find_function (name);
 
           if (func.is_undefined ())
-            error ("arrayfun: invalid function NAME: %s", name.c_str ());
+            error_with_id ("Octave:invalid-input-arg",
+                           "arrayfun: invalid function NAME: %s",
+                           name.c_str ());
 
           symbol_table_lookup = true;
         }
 
       if (error_state)
         return retval;
     }
 
@@ -1237,17 +1248,18 @@ arrayfun (@@str2num, [1234],\n\
             {
               fdims = inputs[j].dims ();
               k = inputs[j].numel ();
 
               for (int i = j+1; i < nargin; i++)
                 {
                   if (mask[i] && inputs[i].dims () != fdims)
                     {
-                      error ("arrayfun: dimensions mismatch");
+                      error_with_id ("Octave:invalid-input-arg", 
+                                     "arrayfun: dimensions mismatch");
                       return retval;
                     }
                 }
               break;
             }
         }
 
 
@@ -1284,17 +1296,18 @@ arrayfun (@@str2num, [1234],\n\
                 = get_output_list (count, nargout, inputlist, func,
                                    error_handler);
 
               if (error_state)
                 return retval;
 
               if (nargout > 0 && tmp.length () < nargout)
                 {
-                  error ("arrayfun: function returned fewer than nargout values");
+                  error_with_id ("Octave:invalid-fun-call", 
+                                 "arrayfun: function returned fewer than nargout values");
                   return retval;
                 }
 
               if  (nargout > 0
                    || (nargout == 0
                        && tmp.length () > 0 && tmp(0).is_defined ()))
                 {
                   int num_to_copy = tmp.length ();
@@ -1309,17 +1322,18 @@ arrayfun (@@str2num, [1234],\n\
                           if (tmp(j).is_defined ())
                             {
                               octave_value val = tmp(j);
 
                               if (val.numel () == 1)
                                 retv[j] = val.resize (fdims);
                               else
                                 {
-                                  error ("arrayfun: all values must be scalars when UniformOutput = true");
+                                  error_with_id ("Octave:invalid-fun-call",
+                                                 "arrayfun: all values must be scalars when UniformOutput = true");
                                   break;
                                 }
                             }
                         }
                     }
                   else
                     {
                       for (int j = 0; j < num_to_copy; j++)
@@ -1336,17 +1350,18 @@ arrayfun (@@str2num, [1234],\n\
                                       retv[j].assign (octave_value::op_asn_eq,
                                                       idx_type, idx_list, val);
 
                                       if (error_state)
                                         break;
                                     }
                                   else
                                     {
-                                      error ("arrayfun: all values must be scalars when UniformOutput = true");
+                                      error_with_id ("Octave:invalid-fun-call",
+                                                     "arrayfun: all values must be scalars when UniformOutput = true");
                                       break;
                                     }
                                 }
                             }
                         }
                     }
                 }
 
@@ -1394,17 +1409,18 @@ arrayfun (@@str2num, [1234],\n\
                 = get_output_list (count, nargout, inputlist, func,
                                    error_handler);
 
               if (error_state)
                 return retval;
 
               if (nargout > 0 && tmp.length () < nargout)
                 {
-                  error ("arrayfun: function returned fewer than nargout values");
+                  error_with_id ("Octave:invalid-fun-call", 
+                                 "arrayfun: function returned fewer than nargout values");
                   return retval;
                 }
 
               if  (nargout > 0
                    || (nargout == 0
                        && tmp.length () > 0 && tmp(0).is_defined ()))
                 {
                   int num_to_copy = tmp.length ();
@@ -1425,17 +1441,18 @@ arrayfun (@@str2num, [1234],\n\
               retval.resize (nargout1);
 
               for (int j = 0; j < nargout1; j++)
                 retval(j) = results[j];
             }
         }
     }
   else
-    error ("arrayfun: argument NAME must be a string or function handle");
+    error_with_id ("Octave:invalid-fun-call", 
+                   "arrayfun: argument NAME must be a string or function handle");
 
   return retval;
 }
 
 /*
 %!function r = __f11 (x)
 %!  global __arrayfun_test_num_outputs__;
 %!  __arrayfun_test_num_outputs__ = nargout;
diff --git a/libinterp/corefcn/kron.cc b/libinterp/corefcn/kron.cc
--- a/libinterp/corefcn/kron.cc
+++ b/libinterp/corefcn/kron.cc
@@ -172,16 +172,23 @@ do_kron (const octave_value& a, const oc
 }
 
 octave_value
 dispatch_kron (const octave_value& a, const octave_value& b)
 {
   octave_value retval;
   if (a.is_perm_matrix () && b.is_perm_matrix ())
     retval = do_kron<PermMatrix, PermMatrix> (a, b);
+  else if (a.is_sparse_type () || b.is_sparse_type ())
+    {
+      if (a.is_complex_type () || b.is_complex_type ())
+        retval = do_kron<SparseComplexMatrix, SparseComplexMatrix> (a, b);
+      else
+        retval = do_kron<SparseMatrix, SparseMatrix> (a, b);
+    }
   else if (a.is_diag_matrix ())
     {
       if (b.is_diag_matrix () && a.rows () == a.columns ()
           && b.rows () == b.columns ())
         {
           // We have two diagonal matrices, the product of those will be
           // another diagonal matrix.  To do that efficiently, extract
           // the diagonals as vectors and compute the product.  That
@@ -209,23 +216,16 @@ dispatch_kron (const octave_value& a, co
           if (a.is_complex_type ())
             retval = do_kron<ComplexDiagMatrix, ComplexMatrix> (a, b);
           else if (b.is_complex_type ())
             retval = do_kron<DiagMatrix, ComplexMatrix> (a, b);
           else
             retval = do_kron<DiagMatrix, Matrix> (a, b);
         }
     }
-  else if (a.is_sparse_type () || b.is_sparse_type ())
-    {
-      if (a.is_complex_type () || b.is_complex_type ())
-        retval = do_kron<SparseComplexMatrix, SparseComplexMatrix> (a, b);
-      else
-        retval = do_kron<SparseMatrix, SparseMatrix> (a, b);
-    }
   else if (a.is_single_type () || b.is_single_type ())
     {
       if (a.is_complex_type ())
         retval = do_kron<FloatComplexMatrix, FloatComplexMatrix> (a, b);
       else if (b.is_complex_type ())
         retval = do_kron<FloatMatrix, FloatComplexMatrix> (a, b);
       else
         retval = do_kron<FloatMatrix, FloatMatrix> (a, b);
diff --git a/libinterp/corefcn/quadcc.cc b/libinterp/corefcn/quadcc.cc
--- a/libinterp/corefcn/quadcc.cc
+++ b/libinterp/corefcn/quadcc.cc
@@ -28,21 +28,22 @@ along with Octave; see the file COPYING.
 #include "parse.h"
 #include "variables.h"
 
 #include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-//#include "oct.h"
-//#include "defun.h"
 
-/* Define the size of the interval heap. */
-#define cquad_heapsize                  200
+/* Extended debugging */
+#define DEBUG_QUADCC 0
+
+/* Define the minimum size of the interval heap. */
+#define min_cquad_heapsize  200 
 
 
 /* Data of a single interval */
 typedef struct
 {
   double a, b;
   double c[64];
   double fx[33];
@@ -1546,24 +1547,20 @@ Mathematical Software, Vol. 37, Issue 3,
 
   /* Some constants that we will need. */
   static const int n[4] = { 4, 8, 16, 32 };
   static const int skip[4] = { 8, 4, 2, 1 };
   static const int idx[4] = { 0, 5, 14, 31 };
   static const double w = M_SQRT2 / 2;
   static const int ndiv_max = 20;
 
-  /* The interval heap. */
-  cquad_ival ivals[cquad_heapsize];
-  int heap[cquad_heapsize];
-
   /* Arguments left and right */
   int nargin = args.length ();
   octave_function *fcn;
-  double a, b, tol, iivals[cquad_heapsize], *sing;
+  double a, b, tol, *sing;
 
   /* Variables needed for transforming the integrand. */
   bool wrap = false;
   double xw;
 
   /* Stuff we will need to call the integrand. */
   octave_value_list fargs, fvals;
 
@@ -1583,139 +1580,147 @@ Mathematical Software, Vol. 37, Issue 3,
       print_usage ();
       return retval;
     }
 
   if (args(0).is_function_handle () || args(0).is_inline_function ())
     fcn = args(0).function_value ();
   else
     {
-       std::string fcn_name = unique_symbol_name ("__quadcc_fcn_");
+       std::string fcn_name = unique_symbol_name ("__quadcc_fcn__");
        std::string fname = "function y = ";
        fname.append (fcn_name);
        fname.append ("(x) y = ");
        fcn = extract_function (args(0), "quadcc", fcn_name, fname,
                                "; endfunction");
     }
 
-  if (!args(1).is_real_scalar ())
+  if (! args(1).is_real_scalar ())
     {
       error ("quadcc: lower limit of integration (A) must be a single real scalar");
       return retval;
     }
   else
     a = args(1).double_value ();
 
-  if (!args(2).is_real_scalar ())
+  if (! args(2).is_real_scalar ())
     {
       error ("quadcc: upper limit of integration (B) must be a single real scalar");
       return retval;
     }
   else
     b = args(2).double_value ();
 
   if (nargin < 4 || args(3).is_empty ())
     tol = 1.0e-6;
-  else if (!args(3).is_real_scalar () || args(3).double_value () <= 0)
+  else if (! args(3).is_real_scalar () || args(3).double_value () <= 0)
     {
       error ("quadcc: tolerance (TOL) must be a single real scalar > 0");
       return retval;
     }
   else
     tol = args(3).double_value ();
 
   if (nargin < 5)
     {
       nivals = 1;
-      iivals[0] = a;
-      iivals[1] = b;
     }
   else if (!(args(4).is_real_scalar () || args(4).is_real_matrix ()))
     {
       error ("quadcc: list of singularities (SING) must be a vector of real values");
       return retval;
     }
   else
     {
-      nivals = 1 + args(4).length ();
-      if (nivals > cquad_heapsize)
-        {
-          error ("quadcc: maximum number of singular points is limited to %i",
-                 cquad_heapsize-1);
-          return retval;
-        }
+      nivals = 1 + args(4).numel ();
+    }
+
+  int cquad_heapsize = (nivals >= min_cquad_heapsize ? nivals + 1 
+                                                     : min_cquad_heapsize);
+  /* The interval heap. */
+  OCTAVE_LOCAL_BUFFER (cquad_ival, ivals, cquad_heapsize);
+  OCTAVE_LOCAL_BUFFER (double, iivals, cquad_heapsize);
+  OCTAVE_LOCAL_BUFFER (int, heap, cquad_heapsize);
+
+  if (nivals == 1)
+    {
+      iivals[0] = a;
+      iivals[1] = b;
+    }
+  else
+    {
+      // Intervals around singularities
       sing = args(4).array_value ().fortran_vec ();
       iivals[0] = a;
-      for (i = 0; i < nivals - 2; i++)
+      for (i = 0; i < nivals - 1; i++)
         iivals[i + 1] = sing[i];
       iivals[nivals] = b;
     }
 
   /* If a or b are +/-Inf, transform the integral. */
   if (xisinf (a) || xisinf (b))
     {
       wrap = true;
-      for (i = 0; i <= nivals; i++)
+      for (i = 0; i < nivals + 1; i++)
         if (xisinf (iivals[i]))
           iivals[i] = gnulib::copysign (1.0, iivals[i]);
         else
           iivals[i] = 2.0 * atan (iivals[i]) / M_PI;
     }
 
 
   /* Initialize the heaps. */
   for (i = 0; i < cquad_heapsize; i++)
     heap[i] = i;
 
-
   /* Create the first interval(s). */
   igral = 0.0;
   err = 0.0;
   for (j = 0; j < nivals; j++)
     {
 
       /* Initialize the interval. */
       iv = &(ivals[heap[j]]);
       m = (iivals[j] + iivals[j + 1]) / 2;
       h = (iivals[j + 1] - iivals[j]) / 2;
       nnans = 0;
       ColumnVector ex (33);
       if (wrap)
         {
           for (i = 0; i <= n[3]; i++)
-            ex (i) = tan (M_PI / 2 * (m + xi[i] * h));
+            ex(i) = tan (M_PI / 2 * (m + xi[i] * h));
         }
       else
         {
           for (i = 0; i <= n[3]; i++)
-            ex (i) = m + xi[i] * h;
+            ex(i) = m + xi[i] * h;
         }
       fargs(0) = ex;
       fvals = feval (fcn, fargs, 1);
-      if (fvals.length () != 1 || !fvals(0).is_real_matrix ())
+      if (fvals.length () != 1 || ! fvals(0).is_real_matrix ())
         {
           error ("quadcc: integrand F must return a single, real-valued vector");
           return retval;
         }
       Matrix effex = fvals(0).matrix_value ();
       if (effex.length () != ex.length ())
         {
           error ("quadcc: integrand F must return a single, real-valued vector of the same size as the input");
           return retval;
         }
       for (i = 0; i <= n[3]; i++)
         {
-          iv->fx[i] = effex (i);
+          iv->fx[i] = effex(i);
           if (wrap)
             {
               xw = ex(i);
               iv->fx[i] *= (1.0 + xw * xw) * M_PI / 2;
             }
           neval++;
-          if (!xfinite (iv->fx[i]))
+          if (! xfinite (iv->fx[i]))
             {
               nans[nnans++] = i;
               iv->fx[i] = 0.0;
             }
         }
       Vinvfx (iv->fx, &(iv->c[idx[3]]), 3);
       Vinvfx (iv->fx, &(iv->c[idx[2]]), 2);
       Vinvfx (iv->fx, &(iv->c[0]), 0);
@@ -1777,70 +1782,71 @@ Mathematical Software, Vol. 37, Issue 3,
       /* Allow the user to interrupt. */
       OCTAVE_QUIT;
 
       /* Put our finger on the interval with the largest error. */
       iv = &(ivals[heap[0]]);
       m = (iv->a + iv->b) / 2;
       h = (iv->b - iv->a) / 2;
 
-/*      printf
+#if (DEBUG_QUADCC)
+      printf
         ("quadcc: processing ival %i (of %i) with [%e,%e] int=%e, err=%e, depth=%i\n",
          heap[0], nivals, iv->a, iv->b, iv->igral, iv->err, iv->depth);
-*/
+#endif
+
       /* Should we try to increase the degree? */
       if (iv->depth < 3)
         {
 
           /* Keep tabs on some variables. */
           d = ++iv->depth;
 
           /* Get the new (missing) function values */
           {
             ColumnVector ex (n[d] / 2);
             if (wrap)
               {
                 for (i = 0; i < n[d] / 2; i++)
-                  ex (i) =
-                    tan (M_PI / 2 * (m + xi[(2 * i + 1) * skip[d]] * h));
+                  ex(i) = tan (M_PI / 2 * (m + xi[(2 * i + 1) * skip[d]] * h));
               }
             else
               {
                 for (i = 0; i < n[d] / 2; i++)
-                  ex (i) = m + xi[(2 * i + 1) * skip[d]] * h;
+                  ex(i) = m + xi[(2 * i + 1) * skip[d]] * h;
               }
             fargs(0) = ex;
             fvals = feval (fcn, fargs, 1);
-            if (fvals.length () != 1 || !fvals(0).is_real_matrix ())
+            if (fvals.length () != 1 || ! fvals(0).is_real_matrix ())
               {
                 error ("quadcc: integrand F must return a single, real-valued vector");
                 return retval;
               }
             Matrix effex = fvals(0).matrix_value ();
             if (effex.length () != ex.length ())
               {
                 error ("quadcc: integrand F must return a single, real-valued vector of the same size as the input");
                 return retval;
               }
             neval += effex.length ();
             for (i = 0; i < n[d] / 2; i++)
               {
                 j = (2 * i + 1) * skip[d];
-                iv->fx[j] = effex (i);
+                iv->fx[j] = effex(i);
                 if (wrap)
                   {
                     xw = ex(i);
                     iv->fx[j] *= (1.0 + xw * xw) * M_PI / 2;
                   }
               }
           }
           nnans = 0;
           for (i = 0; i <= 32; i += skip[d])
             {
-              if (!xfinite (iv->fx[i]))
+              if (! xfinite (iv->fx[i]))
                 {
                   nans[nnans++] = i;
                   iv->fx[i] = 0.0;
                 }
             }
 
           /* Compute the new coefficients. */
           Vinvfx (iv->fx, &(iv->c[idx[d]]), d);
@@ -1883,34 +1889,35 @@ Mathematical Software, Vol. 37, Issue 3,
 
 
       /* Should we drop this interval? */
       if ((m + h * xi[0]) >= (m + h * xi[1])
           || (m + h * xi[31]) >= (m + h * xi[32])
           || iv->err < fabs (iv->igral) * std::numeric_limits<double>::epsilon () * 10)
         {
 
-/*          printf
+#if (DEBUG_QUADCC)
+          printf
             ("quadcc: dropping ival %i (of %i) with [%e,%e] int=%e, err=%e, depth=%i\n",
              heap[0], nivals, iv->a, iv->b, iv->igral, iv->err,
              iv->depth);
-*/
+#endif
+
           /* Keep this interval's contribution */
           err_final += iv->err;
           igral_final += iv->igral;
           /* Swap with the last element on the heap */
           t = heap[nivals - 1];
           heap[nivals - 1] = heap[0];
           heap[0] = t;
           nivals--;
           /* Fix up the heap */
           i = 0;
           while (2 * i + 1 < nivals)
             {
-
               /* Get the kids */
               j = 2 * i + 1;
               /* If the j+1st entry exists and is larger than the jth,
                  use it instead. */
               if (j + 1 < nivals
                   && ivals[heap[j + 1]].err >= ivals[heap[j]].err)
                 j++;
               /* Do we need to move the ith entry up? */
@@ -1943,52 +1950,52 @@ Mathematical Software, Vol. 37, Issue 3,
           ivl->rdepth = iv->rdepth + 1;
           ivl->fx[0] = iv->fx[0];
           ivl->fx[32] = iv->fx[16];
           {
             ColumnVector ex (n[0] - 1);
             if (wrap)
               {
                 for (i = 0; i < n[0] - 1; i++)
-                  ex (i) = tan (M_PI / 2 * (ml + xi[(i + 1) * skip[0]] * hl));
+                  ex(i) = tan (M_PI / 2 * (ml + xi[(i + 1) * skip[0]] * hl));
               }
             else
               {
                 for (i = 0; i < n[0] - 1; i++)
-                  ex (i) = ml + xi[(i + 1) * skip[0]] * hl;
+                  ex(i) = ml + xi[(i + 1) * skip[0]] * hl;
               }
             fargs(0) = ex;
             fvals = feval (fcn, fargs, 1);
-            if (fvals.length () != 1 || !fvals(0).is_real_matrix ())
+            if (fvals.length () != 1 || ! fvals(0).is_real_matrix ())
               {
                 error ("quadcc: integrand F must return a single, real-valued vector");
                 return retval;
               }
             Matrix effex = fvals(0).matrix_value ();
             if (effex.length () != ex.length ())
               {
                 error ("quadcc: integrand F must return a single, real-valued vector of the same size as the input");
                 return retval;
               }
             neval += effex.length ();
             for (i = 0; i < n[0] - 1; i++)
               {
                 j = (i + 1) * skip[0];
-                ivl->fx[j] = effex (i);
+                ivl->fx[j] = effex(i);
                 if (wrap)
                   {
                     xw = ex(i);
                     ivl->fx[j] *= (1.0 + xw * xw) * M_PI / 2;
                   }
               }
           }
           nnans = 0;
           for (i = 0; i <= 32; i += skip[0])
             {
-              if (!xfinite (ivl->fx[i]))
+              if (! xfinite (ivl->fx[i]))
                 {
                   nans[nnans++] = i;
                   ivl->fx[i] = 0.0;
                 }
             }
           Vinvfx (ivl->fx, ivl->c, 0);
           if (nnans > 0)
             {
@@ -2039,52 +2046,52 @@ Mathematical Software, Vol. 37, Issue 3,
           ivr->rdepth = iv->rdepth + 1;
           ivr->fx[0] = iv->fx[16];
           ivr->fx[32] = iv->fx[32];
           {
             ColumnVector ex (n[0] - 1);
             if (wrap)
               {
                 for (i = 0; i < n[0] - 1; i++)
-                  ex (i) = tan (M_PI / 2 * (mr + xi[(i + 1) * skip[0]] * hr));
+                  ex(i) = tan (M_PI / 2 * (mr + xi[(i + 1) * skip[0]] * hr));
               }
             else
               {
                 for (i = 0; i < n[0] - 1; i++)
-                  ex (i) = mr + xi[(i + 1) * skip[0]] * hr;
+                  ex(i) = mr + xi[(i + 1) * skip[0]] * hr;
               }
             fargs(0) = ex;
             fvals = feval (fcn, fargs, 1);
-            if (fvals.length () != 1 || !fvals(0).is_real_matrix ())
+            if (fvals.length () != 1 || ! fvals(0).is_real_matrix ())
               {
                 error ("quadcc: integrand F must return a single, real-valued vector");
                 return retval;
               }
             Matrix effex = fvals(0).matrix_value ();
             if (effex.length () != ex.length ())
               {
                 error ("quadcc: integrand F must return a single, real-valued vector of the same size as the input");
                 return retval;
               }
             neval += effex.length ();
             for (i = 0; i < n[0] - 1; i++)
               {
                 j = (i + 1) * skip[0];
-                ivr->fx[j] = effex (i);
+                ivr->fx[j] = effex(i);
                 if (wrap)
                   {
                     xw = ex(i);
                     ivr->fx[j] *= (1.0 + xw * xw) * M_PI / 2;
                   }
               }
           }
           nnans = 0;
           for (i = 0; i <= 32; i += skip[0])
             {
-              if (!xfinite (ivr->fx[i]))
+              if (! xfinite (ivr->fx[i]))
                 {
                   nans[nnans++] = i;
                   ivr->fx[i] = 0.0;
                 }
             }
           Vinvfx (ivr->fx, ivr->c, 0);
           if (nnans > 0)
             {
@@ -2190,26 +2197,26 @@ Mathematical Software, Vol. 37, Issue 3,
                   heap[j] = heap[i];
                   heap[i] = t;
                   i = j;
                 }
             }
 
         }
 
-      /* If the heap is about to overflow, remove the last two
-         intervals. */
+      /* If the heap is about to overflow, remove the last two intervals. */
       while (nivals > cquad_heapsize - 2)
         {
           iv = &(ivals[heap[nivals - 1]]);
-/*          printf
+#if (DEBUG_QUADCC)
+          printf
             ("quadcc: dropping ival %i (of %i) with [%e,%e] int=%e, err=%e, depth=%i\n",
              heap[0], nivals, iv->a, iv->b, iv->igral, iv->err,
              iv->depth);
-*/
+#endif
           err_final += iv->err;
           igral_final += iv->igral;
           nivals--;
         }
 
       /* Collect the value of the integral and error. */
       igral = igral_final;
       err = err_final;
@@ -2217,25 +2224,27 @@ Mathematical Software, Vol. 37, Issue 3,
         {
           igral += ivals[heap[i]].igral;
           err += ivals[heap[i]].err;
         }
 
     }
 
   /* Dump the contents of the heap. */
-/*  for (i = 0; i < nivals; i++)
+#if (DEBUG_QUADCC)
+  for (i = 0; i < nivals; i++)
     {
       iv = &(ivals[heap[i]]);
       printf
         ("quadcc: ival %i (%i) with [%e,%e], int=%e, err=%e, depth=%i, rdepth=%i, ndiv=%i\n",
          i, heap[i], iv->a, iv->b, iv->igral, iv->err, iv->depth,
          iv->rdepth, iv->ndiv);
     }
-*/
+#endif
+
   /* Clean up and present the results. */
   if (nargout > 2)
     retval(2) = neval;
   if (nargout > 1)
     retval(1) = err;
   retval(0) = igral;
   /* All is well that ends well. */
   return retval;
@@ -2260,17 +2269,17 @@ Mathematical Software, Vol. 37, Issue 3,
 %!  nan_locs = [-3*pi/4, -pi/4, 0, pi/3, pi/2, pi];
 %!  y = sin (x);
 %!  idx = min (abs (bsxfun (@minus, x(:), nan_locs)), [], 2); 
 %!  y(idx < 1e-10) = NaN;
 %!endfunction 
 
 %!test
 %! [q, err, npoints] = quadcc ("__nansin", -pi, pi); 
-%! assert (q, 0, eps);
+%! assert (q, 0, 1e-6);
 %! assert (err, 0, 15*eps);
 
 %% Test input validation
 %!error (quadcc ())
 %!error (quadcc (@sin))
 %!error (quadcc (@sin, 0))
 %!error (quadcc (@sin, ones (2), pi))
 %!error (quadcc (@sin, -i, pi))
diff --git a/libinterp/dldfcn/fftw.cc b/libinterp/dldfcn/fftw.cc
--- a/libinterp/dldfcn/fftw.cc
+++ b/libinterp/dldfcn/fftw.cc
@@ -33,16 +33,18 @@ along with Octave; see the file COPYING.
 #include "ov.h"
 
 DEFUN_DLD (fftw, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{method} =} fftw (\"planner\")\n\
 @deftypefnx {Loadable Function} {} fftw (\"planner\", @var{method})\n\
 @deftypefnx {Loadable Function} {@var{wisdom} =} fftw (\"dwisdom\")\n\
 @deftypefnx {Loadable Function} {} fftw (\"dwisdom\", @var{wisdom})\n\
+@deftypefnx {Loadable Function} {} fftw (\"threads\", @var{nthreads})\n\
+@deftypefnx {Loadable Function} {@var{nthreads} =} fftw (\"threads\")\n\
 \n\
 Manage @sc{fftw} wisdom data.  Wisdom data can be used to significantly\n\
 accelerate the calculation of the FFTs, but implies an initial cost\n\
 in its calculation.  When the @sc{fftw} libraries are initialized, they read\n\
 a system wide wisdom file (typically in @file{/etc/fftw/wisdom}), allowing\n\
 wisdom to be shared between applications other than Octave.  Alternatively,\n\
 the @code{fftw} function can be used to import wisdom.  For example,\n\
 \n\
@@ -55,17 +57,17 @@ will save the existing wisdom used by Oc
 This string can then be saved to a file and restored using the @code{save}\n\
 and @code{load} commands respectively.  This existing wisdom can be\n\
 reimported as follows\n\
 \n\
 @example\n\
 fftw (\"dwisdom\", @var{wisdom})\n\
 @end example\n\
 \n\
-If @var{wisdom} is an empty matrix, then the wisdom used is cleared.\n\
+If @var{wisdom} is an empty string, then the wisdom used is cleared.\n\
 \n\
 During the calculation of Fourier transforms further wisdom is generated.\n\
 The fashion in which this wisdom is generated is also controlled by\n\
 the @code{fftw} function.  There are five different manners in which the\n\
 wisdom can be treated:\n\
 \n\
 @table @asis\n\
 @item \"estimate\"\n\
@@ -105,16 +107,27 @@ or set by using\n\
 @example\n\
 fftw (\"planner\", @var{method})\n\
 @end example\n\
 \n\
 Note that calculated wisdom will be lost when restarting Octave.  However,\n\
 the wisdom data can be reloaded if it is saved to a file as described\n\
 above.  Saved wisdom files should not be used on different platforms since\n\
 they will not be efficient and the point of calculating the wisdom is lost.\n\
+\n\
+The number of threads used for computing the plans and executing the\n\
+transforms can be set with\n\
+\n\
+@example\n\
+fftw (\"threads\", @var{NTHREADS})\n\
+@end example\n\
+\n\
+Note that octave must be compiled with multi-threaded FFTW support for this feature.\n\
+The number of processors available to the current process is used per default.\n\
+\n\
 @seealso{fft, ifft, fft2, ifft2, fftn, ifftn}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
@@ -122,159 +135,216 @@ they will not be efficient and the point
       print_usage ();
       return retval;
     }
 
 #if defined (HAVE_FFTW)
   if (args(0).is_string ())
     {
       std::string arg0 = args(0).string_value ();
-
       if (!error_state)
         {
-          // Use STL function to convert to lower case
-          std::transform (arg0.begin (), arg0.end (), arg0.begin (), tolower);
-
-          if (nargin == 2)
+          if (arg0 == "planner")
             {
-              std::string arg1 = args(1).string_value ();
-              if (!error_state)
+              if (nargin == 2)  //planner setter
                 {
-                  if (arg0 == "planner")
+                  if (args(1).is_string ())
                     {
-                      std::transform (arg1.begin (), arg1.end (),
-                                      arg1.begin (), tolower);
-                      octave_fftw_planner::FftwMethod meth
-                        = octave_fftw_planner::UNKNOWN;
-                      octave_float_fftw_planner::FftwMethod methf
-                        = octave_float_fftw_planner::UNKNOWN;
-
-                      if (arg1 == "estimate")
-                        {
-                          meth = octave_fftw_planner::ESTIMATE;
-                          methf = octave_float_fftw_planner::ESTIMATE;
-                        }
-                      else if (arg1 == "measure")
-                        {
-                          meth = octave_fftw_planner::MEASURE;
-                          methf = octave_float_fftw_planner::MEASURE;
-                        }
-                      else if (arg1 == "patient")
-                        {
-                          meth = octave_fftw_planner::PATIENT;
-                          methf = octave_float_fftw_planner::PATIENT;
-                        }
-                      else if (arg1 == "exhaustive")
-                        {
-                          meth = octave_fftw_planner::EXHAUSTIVE;
-                          methf = octave_float_fftw_planner::EXHAUSTIVE;
-                        }
-                      else if (arg1 == "hybrid")
-                        {
-                          meth = octave_fftw_planner::HYBRID;
-                          methf = octave_float_fftw_planner::HYBRID;
-                        }
-                      else
-                        error ("unrecognized planner METHOD");
-
+                      // Use STL function to convert to lower case
+                      std::transform (arg0.begin (), arg0.end (), arg0.begin (), tolower);
+                      std::string arg1 = args(1).string_value ();
                       if (!error_state)
                         {
-                          meth = octave_fftw_planner::method (meth);
-                          octave_float_fftw_planner::method (methf);
+                          std::transform (arg1.begin (), arg1.end (),
+                                          arg1.begin (), tolower);
+                          octave_fftw_planner::FftwMethod meth
+                            = octave_fftw_planner::UNKNOWN;
+                          octave_float_fftw_planner::FftwMethod methf
+                            = octave_float_fftw_planner::UNKNOWN;
 
-                          if (meth == octave_fftw_planner::MEASURE)
-                            retval = octave_value ("measure");
-                          else if (meth == octave_fftw_planner::PATIENT)
-                            retval = octave_value ("patient");
-                          else if (meth == octave_fftw_planner::EXHAUSTIVE)
-                            retval = octave_value ("exhaustive");
-                          else if (meth == octave_fftw_planner::HYBRID)
-                            retval = octave_value ("hybrid");
+                          if (arg1 == "estimate")
+                            {
+                              meth = octave_fftw_planner::ESTIMATE;
+                              methf = octave_float_fftw_planner::ESTIMATE;
+                            }
+                          else if (arg1 == "measure")
+                            {
+                              meth = octave_fftw_planner::MEASURE;
+                              methf = octave_float_fftw_planner::MEASURE;
+                            }
+                          else if (arg1 == "patient")
+                            {
+                              meth = octave_fftw_planner::PATIENT;
+                              methf = octave_float_fftw_planner::PATIENT;
+                            }
+                          else if (arg1 == "exhaustive")
+                            {
+                              meth = octave_fftw_planner::EXHAUSTIVE;
+                              methf = octave_float_fftw_planner::EXHAUSTIVE;
+                            }
+                          else if (arg1 == "hybrid")
+                            {
+                              meth = octave_fftw_planner::HYBRID;
+                              methf = octave_float_fftw_planner::HYBRID;
+                            }
                           else
-                            retval = octave_value ("estimate");
+                            error ("unrecognized planner METHOD");
+
+                          if (!error_state)
+                            {
+                              meth = octave_fftw_planner::method (meth);
+                              octave_float_fftw_planner::method (methf);
+
+                              if (meth == octave_fftw_planner::MEASURE)
+                                retval = octave_value ("measure");
+                              else if (meth == octave_fftw_planner::PATIENT)
+                                retval = octave_value ("patient");
+                              else if (meth == octave_fftw_planner::EXHAUSTIVE)
+                                retval = octave_value ("exhaustive");
+                              else if (meth == octave_fftw_planner::HYBRID)
+                                retval = octave_value ("hybrid");
+                              else
+                                retval = octave_value ("estimate");
+                            }
                         }
                     }
-                  else if (arg0 == "dwisdom")
-                    {
-                      char *str = fftw_export_wisdom_to_string ();
-
-                      if (arg1.length () < 1)
-                        fftw_forget_wisdom ();
-                      else if (! fftw_import_wisdom_from_string (arg1.c_str ()))
-                        error ("could not import supplied WISDOM");
-
-                      if (!error_state)
-                        retval = octave_value (std::string (str));
-
-                      free (str);
-                    }
-                  else if (arg0 == "swisdom")
-                    {
-                      char *str = fftwf_export_wisdom_to_string ();
-
-                      if (arg1.length () < 1)
-                        fftwf_forget_wisdom ();
-                      else if (! fftwf_import_wisdom_from_string (arg1.c_str ()))
-                        error ("could not import supplied WISDOM");
-
-                      if (!error_state)
-                        retval = octave_value (std::string (str));
-
-                      free (str);
-                    }
                   else
-                    error ("unrecognized argument");
+                    error ("fftw planner expects a string value as METHOD");
                 }
-            }
-          else
-            {
-              if (arg0 == "planner")
+              else //planner getter
                 {
                   octave_fftw_planner::FftwMethod meth =
                     octave_fftw_planner::method ();
 
                   if (meth == octave_fftw_planner::MEASURE)
                     retval = octave_value ("measure");
                   else if (meth == octave_fftw_planner::PATIENT)
                     retval = octave_value ("patient");
                   else if (meth == octave_fftw_planner::EXHAUSTIVE)
                     retval = octave_value ("exhaustive");
                   else if (meth == octave_fftw_planner::HYBRID)
                     retval = octave_value ("hybrid");
                   else
                     retval = octave_value ("estimate");
                 }
-              else if (arg0 == "dwisdom")
+            }
+          else if (arg0 == "dwisdom")
+            {
+              if (nargin == 2)  //dwisdom setter
+                {
+                  if (args(1).is_string ())
+                    {
+                      // Use STL function to convert to lower case
+                      std::transform (arg0.begin (), arg0.end (), arg0.begin (), tolower);
+                      std::string arg1 = args(1).string_value ();
+                      if (!error_state)
+                        {
+                          char *str = fftw_export_wisdom_to_string ();
+
+                          if (arg1.length () < 1)
+                            fftw_forget_wisdom ();
+                          else if (! fftw_import_wisdom_from_string (arg1.c_str ()))
+                            error ("could not import supplied WISDOM");
+
+                          if (!error_state)
+                            retval = octave_value (std::string (str));
+
+                          free (str);
+                        }
+                    }
+                }
+              else //dwisdom getter
                 {
                   char *str = fftw_export_wisdom_to_string ();
                   retval = octave_value (std::string (str));
                   free (str);
                 }
-              else if (arg0 == "swisdom")
+            }
+          else if (arg0 == "swisdom")
+            {
+              //swisdom uses fftwf_ functions (float), dwisdom fftw_ (real)
+              if (nargin == 2)  //swisdom setter
+                {
+                  if (args(1).is_string ())
+                    {
+                      // Use STL function to convert to lower case
+                      std::transform (arg0.begin (), arg0.end (), arg0.begin (), tolower);
+                      std::string arg1 = args(1).string_value ();
+                      if (!error_state)
+                        {
+                          char *str = fftwf_export_wisdom_to_string ();
+
+                          if (arg1.length () < 1)
+                            fftwf_forget_wisdom ();
+                          else if (! fftwf_import_wisdom_from_string (arg1.c_str ()))
+                            error ("could not import supplied WISDOM");
+
+                          if (!error_state)
+                            retval = octave_value (std::string (str));
+
+                          free (str);
+                        }
+                    }
+                }
+              else //swisdom getter
                 {
                   char *str = fftwf_export_wisdom_to_string ();
                   retval = octave_value (std::string (str));
                   free (str);
                 }
-              else
-                error ("unrecognized argument");
             }
+          else if (arg0 == "threads")
+            {
+              if (nargin == 2)  //threads setter
+                {
+                  if (args(1).is_real_scalar ())
+                    {
+                      int nthreads = args(1).int_value();
+                      if ( nthreads >= 1)
+                        {
+#if defined (HAVE_FFTW3_THREADS)
+                          octave_fftw_planner::threads (nthreads);
+#else
+                          warning ("this copy of Octave was not configured to use the multithreaded fftw libraries.");
+#endif
+#if defined (HAVE_FFTW3F_THREADS)
+                          octave_float_fftw_planner::threads (nthreads);
+#else
+                          warning ("this copy of Octave was not configured to use the multithreaded fftwf libraries.");
+#endif
+                        }
+                      else
+                        error ("number of threads must be >=1");
+                    }
+                  else
+                    error ("setting threads needs one integer argument.");
+                }
+              else //threads getter
+#if defined (HAVE_FFTW3_THREADS)              
+                retval = octave_value (octave_fftw_planner::threads());
+#else
+                retval = 1;
+#endif
+            }
+          else
+            error ("unrecognized argument");
         }
     }
+  else
+    error ("unrecognized argument");
 #else
 
   warning ("fftw: this copy of Octave was not configured to use the FFTW3 planner");
 
 #endif
 
   return retval;
 }
 
 /*
-
 %!testif HAVE_FFTW
 %! def_method = fftw ("planner");
 %! unwind_protect
 %!   method = "estimate";
 %!   fftw ("planner", method);
 %!   assert (fftw ("planner"), method);
 %!   method = "measure";
 %!   fftw ("planner", method);
@@ -290,9 +360,17 @@ they will not be efficient and the point
 %!   assert (fftw ("planner"), method);
 %! unwind_protect_cleanup
 %!   fftw ("planner", def_method);
 %! end_unwind_protect
 
 %!error <Invalid call to fftw> fftw ();
 %!error <Invalid call to fftw> fftw ("planner", "estimate", "measure");
 
+%!testif HAVE_FFTW3_THREADS
+%! n = fftw ("threads");
+%! unwind_protect
+%!   fftw ("threads", 3);
+%!   assert (fftw ("threads"), 3);
+%! unwind_protect_cleanup
+%!   fftw ("threads", n);
+%! end_unwind_protect
  */
diff --git a/libinterp/interp-core/c-file-ptr-stream.cc b/libinterp/interp-core/c-file-ptr-stream.cc
--- a/libinterp/interp-core/c-file-ptr-stream.cc
+++ b/libinterp/interp-core/c-file-ptr-stream.cc
@@ -188,25 +188,25 @@ c_file_ptr_buf::buf_close (void)
       retval = cf (f);
       f = 0;
     }
 
   return retval;
 }
 
 int
-c_file_ptr_buf::seek (long offset, int origin)
+c_file_ptr_buf::seek (off_t offset, int origin)
 {
-  return f ? gnulib::fseek (f, offset, origin) : -1;
+  return f ? gnulib::fseeko (f, offset, origin) : -1;
 }
 
-long
+off_t
 c_file_ptr_buf::tell (void)
 {
-  return f ? gnulib::ftell (f) : -1;
+  return f ? gnulib::ftello (f) : -1;
 }
 
 int
 c_file_ptr_buf::file_close (FILE *f)
 {
   return gnulib::fclose (f);
 }
 
diff --git a/libinterp/interp-core/c-file-ptr-stream.h b/libinterp/interp-core/c-file-ptr-stream.h
--- a/libinterp/interp-core/c-file-ptr-stream.h
+++ b/libinterp/interp-core/c-file-ptr-stream.h
@@ -69,19 +69,19 @@ public:
   int sync (void);
 
   int flush (void);
 
   int buf_close (void);
 
   int file_number () const { return f ? fileno (f) : -1; }
 
-  int seek (long offset, int origin);
+  int seek (off_t offset, int origin);
 
-  long tell (void);
+  off_t tell (void);
 
   void clear (void) { if (f) clearerr (f); }
 
   static int file_close (FILE *f);
 
 protected:
 
   FILE *f;
@@ -112,20 +112,20 @@ public:
     : STREAM_T (0), buf (new BUF_T (f, cf)) { STREAM_T::init (buf); }
 
   ~c_file_ptr_stream (void) { delete buf; buf = 0; }
 
   BUF_T *rdbuf (void) { return buf; }
 
   void stream_close (void) { if (buf) buf->buf_close (); }
 
-  int seek (long offset, int origin)
+  int seek (off_t offset, int origin)
     { return buf ? buf->seek (offset, origin) : -1; }
 
-  long tell (void) { return buf ? buf->tell () : -1; }
+  off_t tell (void) { return buf ? buf->tell () : -1; }
 
   void clear (void) { if (buf) buf->clear (); STREAM_T::clear (); }
 
 private:
 
   BUF_T *buf;
 
   // No copying!
@@ -187,20 +187,20 @@ public:
   int sync (void);
 
   int flush (void);
 
   int buf_close (void);
 
   int file_number () const { return -1; }
 
-  int seek (long offset, int origin)
-    { return f ? gzseek (f, offset, origin) : -1; }
+  int seek (off_t offset, int origin)
+    { return f ? gzseek (f, offset, origin) >= 0 : -1; }
 
-  long tell (void) { return f ? gztell (f) : -1; }
+  off_t tell (void) { return f ? gztell (f) : -1; }
 
   void clear (void) { if (f) gzclearerr (f); }
 
   static int file_close (gzFile f) { return ::gzclose (f); }
 
 protected:
 
   gzFile f;
diff --git a/libinterp/interp-core/oct-fstrm.cc b/libinterp/interp-core/oct-fstrm.cc
--- a/libinterp/interp-core/oct-fstrm.cc
+++ b/libinterp/interp-core/oct-fstrm.cc
@@ -57,25 +57,25 @@ octave_fstream::octave_fstream (const st
 
   if (! fs)
     error (gnulib::strerror (errno));
 }
 
 // Position a stream at OFFSET relative to ORIGIN.
 
 int
-octave_fstream::seek (long, int)
+octave_fstream::seek (off_t, int)
 {
   error ("fseek: invalid_operation");
   return -1;
 }
 
 // Return current stream position.
 
-long
+off_t
 octave_fstream::tell (void)
 {
   error ("ftell: invalid_operation");
   return -1;
 }
 
 // Return non-zero if EOF has been reached on this stream.
 
diff --git a/libinterp/interp-core/oct-fstrm.h b/libinterp/interp-core/oct-fstrm.h
--- a/libinterp/interp-core/oct-fstrm.h
+++ b/libinterp/interp-core/oct-fstrm.h
@@ -41,21 +41,21 @@ public:
   static octave_stream
   create (const std::string& nm_arg,
           std::ios::openmode arg_md = std::ios::in|std::ios::out,
           oct_mach_info::float_format flt_fmt
             = oct_mach_info::native_float_format ());
 
   // Position a stream at OFFSET relative to ORIGIN.
 
-  int seek (long offset, int origin);
+  int seek (off_t offset, int origin);
 
   // Return current stream position.
 
-  long tell (void);
+  off_t tell (void);
 
   // Return non-zero if EOF has been reached on this stream.
 
   bool eof (void) const;
 
   void do_close (void);
 
   // The name of the file.
diff --git a/libinterp/interp-core/oct-iostrm.cc b/libinterp/interp-core/oct-iostrm.cc
--- a/libinterp/interp-core/oct-iostrm.cc
+++ b/libinterp/interp-core/oct-iostrm.cc
@@ -25,25 +25,25 @@ along with Octave; see the file COPYING.
 #endif
 
 #include "error.h"
 #include "oct-iostrm.h"
 
 // Position a stream at OFFSET relative to ORIGIN.
 
 int
-octave_base_iostream::seek (long, int)
+octave_base_iostream::seek (off_t, int)
 {
   invalid_operation ();
   return -1;
 }
 
 // Return current stream position.
 
-long
+off_t
 octave_base_iostream::tell (void)
 {
   invalid_operation ();
   return -1;
 }
 
 // Return non-zero if EOF has been reached on this stream.
 
diff --git a/libinterp/interp-core/oct-iostrm.h b/libinterp/interp-core/oct-iostrm.h
--- a/libinterp/interp-core/oct-iostrm.h
+++ b/libinterp/interp-core/oct-iostrm.h
@@ -35,21 +35,21 @@ public:
   octave_base_iostream (const std::string& n = std::string (),
                         std::ios::openmode m = std::ios::in|std::ios::out,
                         oct_mach_info::float_format ff
                           = oct_mach_info::native_float_format ())
     : octave_base_stream (m, ff), nm (n) { }
 
   // Position a stream at OFFSET relative to ORIGIN.
 
-  int seek (long offset, int origin);
+  int seek (off_t offset, int origin);
 
   // Return current stream position.
 
-  long tell (void);
+  off_t tell (void);
 
   // Return non-zero if EOF has been reached on this stream.
 
   bool eof (void) const;
 
   // The name of the file.
 
   std::string name (void) const { return nm; }
diff --git a/libinterp/interp-core/oct-stdstrm.h b/libinterp/interp-core/oct-stdstrm.h
--- a/libinterp/interp-core/oct-stdstrm.h
+++ b/libinterp/interp-core/oct-stdstrm.h
@@ -38,22 +38,22 @@ public:
                          = oct_mach_info::native_float_format (),
                        typename BUF_T::close_fcn cf = BUF_T::file_close)
     : octave_base_stream (m, ff), nm (n), md (m),
       s (f ? new STREAM_T (f, cf) : 0), fnum (fid)
   { }
 
   // Position a stream at OFFSET relative to ORIGIN.
 
-  int seek (long offset, int origin)
+  int seek (off_t offset, int origin)
     { return s ? s->seek (offset, origin) : -1; }
 
   // Return current stream position.
 
-  long tell (void) { return s ? s->tell () : -1; }
+  off_t tell (void) { return s ? s->tell () : -1; }
 
   // Return non-zero if EOF has been reached on this stream.
 
   bool eof (void) const { return s ? s->eof () : true; }
 
   // The name of the file.
 
   std::string name (void) const { return nm; }
diff --git a/libinterp/interp-core/oct-stream.cc b/libinterp/interp-core/oct-stream.cc
--- a/libinterp/interp-core/oct-stream.cc
+++ b/libinterp/interp-core/oct-stream.cc
@@ -1023,20 +1023,20 @@ octave_base_stream::getl (octave_idx_typ
 }
 
 std::string
 octave_base_stream::gets (octave_idx_type max_len, bool& err, const std::string& who)
 {
   return do_gets (max_len, err, false, who);
 }
 
-long
-octave_base_stream::skipl (long num, bool& err, const std::string& who)
+off_t
+octave_base_stream::skipl (off_t num, bool& err, const std::string& who)
 {
-  long cnt = -1;
+  off_t cnt = -1;
 
   if ((interactive || forced_interactive) && file_number () == 0)
     {
       ::error ("%s: unable to read from stdin while running interactively",
                who.c_str ());
 
       return count;
     }
@@ -2811,31 +2811,31 @@ octave_stream::gets (const octave_value&
     }
 
   if (! error_state)
     retval = gets (max_len, err, who);
 
   return retval;
 }
 
-long
-octave_stream::skipl (long count, bool& err, const std::string& who)
+off_t
+octave_stream::skipl (off_t count, bool& err, const std::string& who)
 {
-  long retval = -1;
+  off_t retval = -1;
 
   if (stream_ok ())
     retval = rep->skipl (count, err, who);
 
   return retval;
 }
 
-long
+off_t
 octave_stream::skipl (const octave_value& tc_count, bool& err, const std::string& who)
 {
-  long retval = -1;
+  off_t retval = -1;
 
   err = false;
 
   int conv_err = 0;
 
   int count = 1;
 
   if (tc_count.is_defined ())
@@ -2856,35 +2856,35 @@ octave_stream::skipl (const octave_value
 
   if (! error_state)
     retval = skipl (count, err, who);
 
   return retval;
 }
 
 int
-octave_stream::seek (long offset, int origin)
+octave_stream::seek (off_t offset, int origin)
 {
   int status = -1;
 
   if (stream_ok ())
     {
       clearerr ();
 
       // Find current position so we can return to it if needed.
 
-      long orig_pos = rep->tell ();
+      off_t orig_pos = rep->tell ();
 
       // Move to end of file.  If successful, find the offset of the end.
 
       status = rep->seek (0, SEEK_END);
 
       if (status == 0)
         {
-          long eof_pos = rep->tell ();
+          off_t eof_pos = rep->tell ();
 
           if (origin == SEEK_CUR)
             {
               // Move back to original position, otherwise we will be
               // seeking from the end of file which is probably not the
               // original location.
 
               rep->seek (orig_pos, SEEK_SET);
@@ -2894,17 +2894,17 @@ octave_stream::seek (long offset, int or
           // of existing file.
 
           status = rep->seek (offset, origin);
 
           if (status == 0)
             {
               // Where are we after moving to desired position?
 
-              long desired_pos = rep->tell ();
+              off_t desired_pos = rep->tell ();
 
               // I don't think save_pos can be less than zero, but we'll
               // check anyway...
 
               if (desired_pos > eof_pos || desired_pos < 0)
                 {
                   // Seek outside bounds of file.  Failure should leave
                   // position unchanged.
@@ -2930,17 +2930,20 @@ octave_stream::seek (long offset, int or
 }
 
 int
 octave_stream::seek (const octave_value& tc_offset,
                      const octave_value& tc_origin)
 {
   int retval = -1;
 
-  long xoffset = tc_offset.long_value (true);
+  // FIXME -- should we have octave_value methods that handle off_t
+  // explicitly?
+  octave_int64 val = tc_offset.int64_scalar_value ();
+  off_t xoffset = val.value ();
 
   if (! error_state)
     {
       int conv_err = 0;
 
       int origin = SEEK_SET;
 
       if (tc_origin.is_string ())
@@ -2984,20 +2987,20 @@ octave_stream::seek (const octave_value&
         error ("fseek: invalid value for origin");
     }
   else
     error ("fseek: invalid value for offset");
 
   return retval;
 }
 
-long
+off_t
 octave_stream::tell (void)
 {
-  long retval = -1;
+  off_t retval = -1;
 
   if (stream_ok ())
     retval = rep->tell ();
 
   return retval;
 }
 
 int
@@ -3556,27 +3559,27 @@ octave_stream::write (const Array<T>& da
         {
           std::ostream& os = *osp;
 
           if (skip != 0 && (i % block_size) == 0)
             {
               // Seek to skip when inside bounds of existing file.
               // Otherwise, write NUL to skip.
 
-              long orig_pos = tell ();
+              off_t orig_pos = tell ();
 
               seek (0, SEEK_END);
 
-              long eof_pos = tell ();
+              off_t eof_pos = tell ();
 
               // Is it possible for this to fail to return us to the
               // original position?
               seek (orig_pos, SEEK_SET);
 
-              long remaining = eof_pos - orig_pos;
+              off_t remaining = eof_pos - orig_pos;
 
               if (remaining < skip)
                 {
                   seek (0, SEEK_END);
 
                   // FIXME -- probably should try to write larger
                   // blocks...
 
diff --git a/libinterp/interp-core/oct-stream.h b/libinterp/interp-core/oct-stream.h
--- a/libinterp/interp-core/oct-stream.h
+++ b/libinterp/interp-core/oct-stream.h
@@ -340,21 +340,21 @@ public:
 
   virtual ~octave_base_stream (void) { }
 
   // The remaining functions are not specific to input or output only,
   // and must be provided by the derived classes.
 
   // Position a stream at OFFSET relative to ORIGIN.
 
-  virtual int seek (long offset, int origin) = 0;
+  virtual int seek (off_t offset, int origin) = 0;
 
   // Return current stream position.
 
-  virtual long tell (void) = 0;
+  virtual off_t tell (void) = 0;
 
   // Return TRUE if EOF has been reached on this stream.
 
   virtual bool eof (void) const = 0;
 
   // The name of the file.
 
   virtual std::string name (void) const = 0;
@@ -455,17 +455,17 @@ private:
   // Functions that are defined for all input streams (input streams
   // are those that define is).
 
   std::string do_gets (octave_idx_type max_len, bool& err, bool strip_newline,
                        const std::string& who /* = "gets" */);
 
   std::string getl (octave_idx_type max_len, bool& err, const std::string& who /* = "getl" */);
   std::string gets (octave_idx_type max_len, bool& err, const std::string& who /* = "gets" */);
-  long skipl (long count, bool& err, const std::string& who /* = "skipl" */);
+  off_t skipl (off_t count, bool& err, const std::string& who /* = "skipl" */);
 
   octave_value do_scanf (scanf_format_list& fmt_list, octave_idx_type nr, octave_idx_type nc,
                          bool one_elt_size_spec, octave_idx_type& count,
                          const std::string& who /* = "scanf" */);
 
   octave_value scanf (const std::string& fmt, const Array<double>& size,
                       octave_idx_type& count, const std::string& who /* = "scanf" */);
 
@@ -519,23 +519,23 @@ public:
   std::string getl (octave_idx_type max_len, bool& err, const std::string& who /* = "getl" */);
   std::string getl (const octave_value& max_len, bool& err,
                     const std::string& who /* = "getl" */);
 
   std::string gets (octave_idx_type max_len, bool& err, const std::string& who /* = "gets" */);
   std::string gets (const octave_value& max_len, bool& err,
                     const std::string& who /* = "gets" */);
 
-  long skipl (long count, bool& err, const std::string& who /* = "skipl" */);
-  long skipl (const octave_value& count, bool& err, const std::string& who /* = "skipl" */);
+  off_t skipl (off_t count, bool& err, const std::string& who /* = "skipl" */);
+  off_t skipl (const octave_value& count, bool& err, const std::string& who /* = "skipl" */);
 
-  int seek (long offset, int origin);
+  int seek (off_t offset, int origin);
   int seek (const octave_value& offset, const octave_value& origin);
 
-  long tell (void);
+  off_t tell (void);
 
   int rewind (void);
 
   bool is_open (void) const;
 
   void close (void);
 
   octave_value read (const Array<double>& size, octave_idx_type block_size,
diff --git a/libinterp/interp-core/oct-strstrm.cc b/libinterp/interp-core/oct-strstrm.cc
--- a/libinterp/interp-core/oct-strstrm.cc
+++ b/libinterp/interp-core/oct-strstrm.cc
@@ -24,25 +24,25 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "oct-strstrm.h"
 
 // Position a stream at OFFSET relative to ORIGIN.
 
 int
-octave_base_strstream::seek (long, int)
+octave_base_strstream::seek (off_t, int)
 {
   error ("fseek: invalid operation");
   return -1;
 }
 
 // Return current stream position.
 
-long
+off_t
 octave_base_strstream::tell (void)
 {
   error ("ftell: invalid operation");
   return -1;
 }
 
 octave_stream
 octave_istrstream::create (const char *data, std::ios::openmode arg_md,
diff --git a/libinterp/interp-core/oct-strstrm.h b/libinterp/interp-core/oct-strstrm.h
--- a/libinterp/interp-core/oct-strstrm.h
+++ b/libinterp/interp-core/oct-strstrm.h
@@ -35,21 +35,21 @@ public:
 
   octave_base_strstream (std::ios::openmode m = std::ios::out,
                          oct_mach_info::float_format ff
                            = oct_mach_info::native_float_format ())
     : octave_base_stream (m, ff) { }
 
   // Position a stream at OFFSET relative to ORIGIN.
 
-  int seek (long, int);
+  int seek (off_t, int);
 
   // Return current stream position.
 
-  virtual long tell (void);
+  virtual off_t tell (void);
 
   // The name of the file.
 
   std::string name (void) const { return std::string (); }
 
   virtual std::streambuf *rdbuf (void) = 0;
 
   virtual bool bad (void) const = 0;
@@ -99,17 +99,17 @@ public:
   // Return non-zero if EOF has been reached on this stream.
 
   bool eof (void) const { return is.eof (); }
 
   std::istream *input_stream (void) { return &is; }
 
   std::ostream *output_stream (void) { return 0; }
 
-  long tell (void) { return is.tellg (); }
+  off_t tell (void) { return is.tellg (); }
 
   std::streambuf *rdbuf (void) { return is ? is.rdbuf () : 0; }
 
   bool bad (void) const { return is.bad (); }
 
   void clear (void) { is.clear (); }
 
 protected:
diff --git a/libinterp/interp-core/xgl2ps.c b/libinterp/interp-core/xgl2ps.c
--- a/libinterp/interp-core/xgl2ps.c
+++ b/libinterp/interp-core/xgl2ps.c
@@ -15,18 +15,20 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
-// Wrapper for "imported" file gl2ps.c so that config.h will be included
-// before any other system or gnulib headers.
+/*
+ * Wrapper for "imported" file gl2ps.c so that config.h will be included
+ * before any other system or gnulib headers.
+ */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #if defined (HAVE_OPENGL)
 
 #include "gl2ps.c"
diff --git a/libinterp/interpfcn/defaults.cc b/libinterp/interpfcn/defaults.cc
--- a/libinterp/interpfcn/defaults.cc
+++ b/libinterp/interpfcn/defaults.cc
@@ -70,16 +70,17 @@ std::string Vlocal_ver_oct_file_dir;
 std::string Vlocal_api_oct_file_dir;
 std::string Vlocal_oct_file_dir;
 
 std::string Vlocal_ver_fcn_file_dir;
 std::string Vlocal_api_fcn_file_dir;
 std::string Vlocal_fcn_file_dir;
 
 std::string Voct_etc_dir;
+std::string Voct_locale_dir;
 
 std::string Voct_file_dir;
 std::string Vfcn_file_dir;
 
 std::string Vimage_dir;
 
 // The path that will be searched for programs that we execute.
 // (--exec-path path)
@@ -219,16 +220,22 @@ set_default_image_dir (void)
 
 static void
 set_default_oct_etc_dir (void)
 {
   Voct_etc_dir = subst_octave_home (OCTAVE_OCTETCDIR);
 }
 
 static void
+set_default_oct_locale_dir (void)
+{
+  Voct_locale_dir = subst_octave_home (OCTAVE_OCTLOCALEDIR);
+}
+
+static void
 set_default_oct_file_dir (void)
 {
   Voct_file_dir = subst_octave_home (OCTAVE_OCTFILEDIR);
 }
 
 static void
 set_default_bin_dir (void)
 {
@@ -423,16 +430,17 @@ install_defaults (void)
   set_default_local_api_oct_file_dir ();
   set_default_local_oct_file_dir ();
 
   set_default_local_ver_fcn_file_dir ();
   set_default_local_api_fcn_file_dir ();
   set_default_local_fcn_file_dir ();
 
   set_default_oct_etc_dir ();
+  set_default_oct_locale_dir ();
 
   set_default_fcn_file_dir ();
   set_default_oct_file_dir ();
 
   set_default_image_dir ();
 
   set_default_bin_dir ();
 
diff --git a/libinterp/interpfcn/defaults.in.h b/libinterp/interpfcn/defaults.in.h
--- a/libinterp/interpfcn/defaults.in.h
+++ b/libinterp/interpfcn/defaults.in.h
@@ -151,24 +151,32 @@ along with Octave; see the file COPYING.
 #ifndef OCTAVE_OCTFILEDIR
 #define OCTAVE_OCTFILEDIR %OCTAVE_OCTFILEDIR%
 #endif
 
 #ifndef OCTAVE_OCTETCDIR
 #define OCTAVE_OCTETCDIR %OCTAVE_OCTETCDIR%
 #endif
 
+#ifndef OCTAVE_OCTLOCALEDIR
+#define OCTAVE_OCTLOCALEDIR %OCTAVE_OCTLOCALEDIR%
+#endif
+
 #ifndef OCTAVE_OCTINCLUDEDIR
 #define OCTAVE_OCTINCLUDEDIR %OCTAVE_OCTINCLUDEDIR%
 #endif
 
 #ifndef OCTAVE_OCTLIBDIR
 #define OCTAVE_OCTLIBDIR %OCTAVE_OCTLIBDIR%
 #endif
 
+#ifndef OCTAVE_OCTTESTSDIR
+#define OCTAVE_OCTTESTSDIR %OCTAVE_OCTTESTSDIR%
+#endif
+
 #ifndef OCTAVE_PREFIX
 #define OCTAVE_PREFIX %OCTAVE_PREFIX%
 #endif
 
 #ifndef OCTAVE_STARTUPFILEDIR
 #define OCTAVE_STARTUPFILEDIR %OCTAVE_STARTUPFILEDIR%
 #endif
 
@@ -190,16 +198,17 @@ extern OCTINTERP_API std::string Vlocal_
 extern OCTINTERP_API std::string Vlocal_api_oct_file_dir;
 extern OCTINTERP_API std::string Vlocal_oct_file_dir;
 
 extern OCTINTERP_API std::string Vlocal_ver_fcn_file_dir;
 extern OCTINTERP_API std::string Vlocal_api_fcn_file_dir;
 extern OCTINTERP_API std::string Vlocal_fcn_file_dir;
 
 extern OCTINTERP_API std::string Voct_etc_dir;
+extern OCTINTERP_API std::string Voct_locale_dir;
 
 extern OCTINTERP_API std::string Voct_file_dir;
 extern OCTINTERP_API std::string Vfcn_file_dir;
 
 extern OCTINTERP_API std::string Vimage_dir;
 
 // Name of the editor to be invoked by the edit_history command.
 extern OCTINTERP_API std::string VEDITOR;
diff --git a/libinterp/interpfcn/file-io.cc b/libinterp/interpfcn/file-io.cc
--- a/libinterp/interpfcn/file-io.cc
+++ b/libinterp/interpfcn/file-io.cc
@@ -431,17 +431,17 @@ Returns the number of lines skipped (end
       octave_stream os = octave_stream_list::lookup (args(0), who);
 
       if (! error_state)
         {
           octave_value count_arg = (nargin == 2) ? args(1) : octave_value ();
 
           bool err = false;
 
-          long tmp = os.skipl (count_arg, err, who);
+          off_t tmp = os.skipl (count_arg, err, who);
 
           if (! (error_state || err))
             retval = tmp;
         }
     }
   else
     print_usage ();
 
diff --git a/libinterp/interpfcn/oct-hist.cc b/libinterp/interpfcn/oct-hist.cc
--- a/libinterp/interpfcn/oct-hist.cc
+++ b/libinterp/interpfcn/oct-hist.cc
@@ -86,17 +86,17 @@ default_history_file (void)
                              ".octave_hist");
 
   return file;
 }
 
 static int
 default_history_size (void)
 {
-  int size = 1024;
+  int size = 1000;
 
   std::string env_size = octave_env::getenv ("OCTAVE_HISTSIZE");
 
   if (! env_size.empty ())
     {
       int val;
 
       if (sscanf (env_size.c_str (), "%d", &val) == 1)
@@ -369,33 +369,31 @@ get_int_arg (const octave_value& arg, in
 static std::string
 mk_tmp_hist_file (const octave_value_list& args,
                   bool insert_curr, const char *warn_for)
 {
   std::string retval;
 
   string_vector hlist = command_history::list ();
 
-  int hist_count = hlist.length ();
+  int hist_count = hlist.length () - 1;  // switch to zero-based indexing
 
   // The current command line is already part of the history list by
   // the time we get to this point.  Delete it from the list.
 
-  hist_count -= 2;
-
   if (! insert_curr)
     command_history::remove (hist_count);
 
-  hist_count--;
+  hist_count--;  // skip last entry in history list
 
   // If no numbers have been specified, the default is to edit the
   // last command in the history list.
 
+  int hist_beg = hist_count;
   int hist_end = hist_count;
-  int hist_beg = hist_count;
 
   bool reverse = false;
 
   // Process options.
 
   int nargin = args.length ();
 
   bool usage_error = false;
@@ -431,19 +429,17 @@ mk_tmp_hist_file (const octave_value_lis
   if (usage_error)
     {
       usage ("%s [first] [last]", warn_for);
       return retval;
     }
 
   if (hist_end < hist_beg)
     {
-      int t = hist_end;
-      hist_end = hist_beg;
-      hist_beg = t;
+      std::swap (hist_end, hist_beg);
       reverse = true;
     }
 
   std::string name = octave_tempnam ("", "oct-");
 
   std::fstream file (name.c_str (), std::ios::out);
 
   if (! file)
@@ -491,20 +487,28 @@ do_edit_history (const octave_value_list
   cmd.append ("\"");
 
   // Ignore interrupts while we are off editing commands.  Should we
   // maybe avoid using system()?
 
   volatile octave_interrupt_handler old_interrupt_handler
     = octave_ignore_interrupts ();
 
-  system (cmd.c_str ());
+  int status = system (cmd.c_str ());
 
   octave_set_interrupt_handler (old_interrupt_handler);
 
+  // Check if text edition was successfull.  Abort the operation
+  // in case of failure.
+  if (status != EXIT_SUCCESS)
+    {
+      error ("edit_history: text editor command failed");
+      return;
+    }
+
   // Write the commands to the history file since source_file
   // disables command line history while it executes.
 
   std::fstream file (name.c_str (), std::ios::in);
 
   char *line;
   int first = 1;
   while ((line = edit_history_readline (file)) != 0)
@@ -519,16 +523,18 @@ do_edit_history (const octave_value_list
 
       if (first)
         {
           first = 0;
           edit_history_repl_hist (line);
         }
       else
         edit_history_add_hist (line);
+
+      delete [] line;
     }
 
   file.close ();
 
   // Turn on command echo, so the output from this will make better
   // sense.
 
   unwind_protect frame;
@@ -724,17 +730,17 @@ the history list, subject to the value o
   return retval;
 }
 
 DEFUN (history_size, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} history_size ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} history_size (@var{new_val})\n\
 Query or set the internal variable that specifies how many entries\n\
-to store in the history file.  The default value is @code{1024},\n\
+to store in the history file.  The default value is @code{1000},\n\
 but may be overridden by the environment variable @w{@env{OCTAVE_HISTSIZE}}.\n\
 @seealso{history_file, history_timestamp_format_string, saving_history}\n\
 @end deftypefn")
 {
   int old_history_size = command_history::size ();
 
   int tmp = old_history_size;
 
diff --git a/libinterp/interpfcn/sysdep.cc b/libinterp/interpfcn/sysdep.cc
--- a/libinterp/interpfcn/sysdep.cc
+++ b/libinterp/interpfcn/sysdep.cc
@@ -648,19 +648,18 @@ returning the empty string if no key is 
     {
       Fdrawnow ();
 
       int c = octave_kbhit (args.length () == 0);
 
       if (c == -1)
         c = 0;
 
-      char *s = new char [2];
-      s[0] = c;
-      s[1] = '\0';
+      char s[2] = {c, '\0'};
+
       retval = s;
     }
 
   return retval;
 }
 
 DEFUN (pause, args, ,
   "-*- texinfo -*-\n\
diff --git a/libinterp/interpfcn/toplev.cc b/libinterp/interpfcn/toplev.cc
--- a/libinterp/interpfcn/toplev.cc
+++ b/libinterp/interpfcn/toplev.cc
@@ -1409,16 +1409,17 @@ specified option.\n\
       { true, "localveroctfiledir", OCTAVE_LOCALVEROCTFILEDIR },
       { true, "man1dir", OCTAVE_MAN1DIR },
       { false, "man1ext", OCTAVE_MAN1EXT },
       { true, "mandir", OCTAVE_MANDIR },
       { true, "octfiledir", OCTAVE_OCTFILEDIR },
       { true, "octetcdir", OCTAVE_OCTETCDIR },
       { true, "octincludedir", OCTAVE_OCTINCLUDEDIR },
       { true, "octlibdir", OCTAVE_OCTLIBDIR },
+      { true, "octtestsdir", OCTAVE_OCTTESTSDIR },
       { true, "prefix", OCTAVE_PREFIX },
       { true, "startupfiledir", OCTAVE_STARTUPFILEDIR },
       { false, "version", OCTAVE_VERSION },
       { false, 0, 0 }
     };
 
   if (! initialized)
     {
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -640,17 +640,18 @@ DEFUNX ("inline", Finline, args, ,
 @deftypefnx {Built-in Function} {} inline (@var{str}, @var{n})\n\
 Create an inline function from the character string @var{str}.\n\
 If called with a single argument, the arguments of the generated\n\
 function are extracted from the function itself.  The generated\n\
 function arguments will then be in alphabetical order.  It should\n\
 be noted that i, and j are ignored as arguments due to the\n\
 ambiguity between their use as a variable or their use as an inbuilt\n\
 constant.  All arguments followed by a parenthesis are considered\n\
-to be functions.\n\
+to be functions. If no arguments are found, a function taking a single\n\
+argument named @code{x} will be created.\n\
 \n\
 If the second and subsequent arguments are character strings,\n\
 they are the names of the arguments of the function.\n\
 \n\
 If the second argument is an integer @var{n}, the arguments are\n\
 @code{\"x\"}, @code{\"P1\"}, @dots{}, @code{\"P@var{N}\"}.\n\
 @seealso{argnames, formula, vectorize}\n\
 @end deftypefn")
@@ -747,25 +748,29 @@ If the second argument is an integer @va
 
                       tmp_arg = std::string ();
                       is_arg = false;
                     }
                 }
 
               // Sort the arguments into ascii order.
               fargs.sort ();
+
+              if (fargs.length () == 0)
+                fargs.append (std::string ("x"));
+
             }
           else if (nargin == 2 && args(1).is_numeric_type ())
             {
-              if (! args(1).is_scalar_type ()) 
+              if (! args(1).is_scalar_type ())
                 {
                   error ("inline: N must be an integer");
                   return retval;
                 }
-              
+
               int n = args(1).int_value ();
 
               if (! error_state)
                 {
                   if (n >= 0)
                     {
                       fargs.resize (n+1);
 
@@ -820,19 +825,21 @@ If the second argument is an integer @va
   return retval;
 }
 
 /*
 %!shared fn
 %! fn = inline ("x.^2 + 1");
 %!assert (feval (fn, 6), 37)
 %!assert (fn (6), 37)
-## FIXME: Need tests for other 2 calling forms of inline()
+%!assert (feval (inline ("sum (x(:))"), [1 2; 3 4]), 10)
+%!assert (feval (inline ("sqrt (x^2 + y^2)", "x", "y"), 3, 4), 5)
+%!assert (feval (inline ("exp (P1*x) + P2", 3), 3, 4, 5), exp(3*4) + 5)
 
-## Test input validation 
+## Test input validation
 %!error inline ()
 %!error <STR argument must be a string> inline (1)
 %!error <N must be an integer> inline ("2", ones (2,2))
 %!error <N must be a positive integer> inline ("2", -1)
 %!error <expecting string arguments> inline ("2", "x", -1, "y")
 */
 
 DEFUN (formula, args, ,
diff --git a/liboctave/Makefile.am b/liboctave/Makefile.am
--- a/liboctave/Makefile.am
+++ b/liboctave/Makefile.am
@@ -70,16 +70,18 @@ nodist_octinclude_HEADERS = \
 noinst_LTLIBRARIES =
 
 ## C++ files that are #included, not compiled
 OTHER_INC =
 
 ## C++ files with templates that are #included, not compiled
 TEMPLATE_SRC =
 
+## A list of all files that could include tests
+
 include array/module.mk
 include numeric/module.mk
 include operators/module.mk
 include system/module.mk
 include util/module.mk
 
 ## liboctave merely collects a bunch of compiled convenience libraries.
 ## It has no source code itself.
@@ -112,10 +114,26 @@ liboctave_version_info = $(liboctave_cur
 
 liboctave_la_LDFLAGS = \
   -version-info $(liboctave_version_info) \
   $(NO_UNDEFINED_LDFLAG) \
   @XTRA_CRUFT_SH_LDFLAGS@ \
   -bindir $(bindir) \
   $(LIBOCTAVE_LINK_OPTS)
 
+## Rules to build test files
+
+LIBOCTAVE_TST_SRC = \
+  $(array_libarray_la_SOURCES) \
+  $(numeric_libnumeric_la_SOURCES) \
+  $(system_libsystem_la_SOURCES) \
+  $(util_libutil_la_SOURCES)
+
+TST_FILES_SRC := $(shell $(top_srcdir)/build-aux/find-files-with-tests.sh "$(srcdir)" $(LIBOCTAVE_TST_SRC))
+
+TST_FILES := $(addsuffix -tst,$(TST_FILES_SRC))
+
+liboctavetestsdir := $(octtestsdir)/liboctave
+
+nobase_liboctavetests_DATA = $(TST_FILES)
+
 DISTCLEANFILES += $(BUILT_INCS)
 
diff --git a/liboctave/numeric/oct-fftw.cc b/liboctave/numeric/oct-fftw.cc
--- a/liboctave/numeric/oct-fftw.cc
+++ b/liboctave/numeric/oct-fftw.cc
@@ -30,16 +30,20 @@ along with Octave; see the file COPYING.
 #include <vector>
 
 #include "lo-error.h"
 #include "oct-fftw.h"
 #include "quit.h"
 #include "oct-locbuf.h"
 #include "singleton-cleanup.h"
 
+#if defined (HAVE_FFTW3_THREADS)
+#include "nproc.h"
+#endif
+
 octave_fftw_planner *octave_fftw_planner::instance = 0;
 
 // Helper class to create and cache FFTW plans for both 1D and
 // 2D. This implementation defaults to using FFTW_ESTIMATE to create
 // the plans, which in theory is suboptimal, but provides quite
 // reasonable performance in practice.
 
 // Also note that if FFTW_ESTIMATE is not used then the planner in FFTW3
@@ -60,16 +64,26 @@ octave_fftw_planner::octave_fftw_planner
     rsimd_align (false)
 {
   plan[0] = plan[1] = 0;
   d[0] = d[1] = s[0] = s[1] = r[0] = r[1] = h[0] = h[1] = 0;
   simd_align[0] = simd_align[1] = false;
   inplace[0] = inplace[1] = false;
   n[0] = n[1] = dim_vector ();
 
+#if defined (HAVE_FFTW3_THREADS)
+  int init_ret = fftw_init_threads ();
+  if (!init_ret)
+    (*current_liboctave_error_handler) ("Error initializing FFTW threads");
+  //Use number of processors available to the current process
+  //This can be later changed with fftw ("threads", nthreads)
+  nthreads = num_processors (NPROC_CURRENT);
+  fftw_plan_with_nthreads (nthreads);
+#endif
+
   // If we have a system wide wisdom file, import it.
   fftw_import_system_wisdom ();
 }
 
 octave_fftw_planner::~octave_fftw_planner (void)
 {
   fftw_plan *plan_p;
 
@@ -390,16 +404,26 @@ octave_float_fftw_planner::octave_float_
     rsimd_align (false)
 {
   plan[0] = plan[1] = 0;
   d[0] = d[1] = s[0] = s[1] = r[0] = r[1] = h[0] = h[1] = 0;
   simd_align[0] = simd_align[1] = false;
   inplace[0] = inplace[1] = false;
   n[0] = n[1] = dim_vector ();
 
+#if defined (HAVE_FFTW3F_THREADS)
+  int init_ret = fftwf_init_threads ();
+  if (!init_ret)
+    (*current_liboctave_error_handler) ("Error initializing FFTW3F threads");
+  //Use number of processors available to the current process
+  //This can be later changed with fftw ("threads", nthreads)
+  nthreads = num_processors (NPROC_CURRENT);
+  fftwf_plan_with_nthreads (nthreads);
+#endif
+
   // If we have a system wide wisdom file, import it.
   fftwf_import_system_wisdom ();
 }
 
 octave_float_fftw_planner::~octave_float_fftw_planner (void)
 {
   fftwf_plan *plan_p;
 
diff --git a/liboctave/numeric/oct-fftw.h b/liboctave/numeric/oct-fftw.h
--- a/liboctave/numeric/oct-fftw.h
+++ b/liboctave/numeric/oct-fftw.h
@@ -93,16 +93,34 @@ public:
 
   static FftwMethod method (FftwMethod _meth)
   {
     static FftwMethod dummy;
 
     return instance_ok () ? instance->do_method (_meth) : dummy;
   }
 
+#if defined (HAVE_FFTW3F_THREADS)
+  static void threads (int _nthreads)
+  {
+    if (instance_ok () && _nthreads != threads ())
+      {
+        instance->nthreads = _nthreads;
+        fftw_plan_with_nthreads (_nthreads);
+        //Clear the current plans
+        instance->rplan = instance->plan[0] = instance->plan[1] = 0;
+      }
+  }
+
+  static int threads ()
+  {
+    return instance_ok () ? instance->nthreads : 0;
+  }
+#endif
+
 private:
 
   // No copying!
 
   octave_fftw_planner (const octave_fftw_planner&);
 
   octave_fftw_planner& operator = (const octave_fftw_planner&);
 
@@ -164,16 +182,21 @@ private:
 
   // howmany
   octave_idx_type rh;
 
   // dims
   dim_vector rn;
 
   bool rsimd_align;
+
+#if defined (HAVE_FFTW3_THREADS)
+  //number of threads when compiled with Multi-threading support
+  int nthreads;
+#endif
 };
 
 class
 OCTAVE_API
 octave_float_fftw_planner
 {
 protected:
 
@@ -230,16 +253,34 @@ public:
 
   static FftwMethod method (FftwMethod _meth)
   {
     static FftwMethod dummy;
 
     return instance_ok () ? instance->do_method (_meth) : dummy;
   }
 
+#if defined (HAVE_FFTW3F_THREADS)
+  static void threads (int _nthreads)
+  {
+    if (instance_ok () && _nthreads != threads ())
+      {
+        instance->nthreads = _nthreads;
+        fftwf_plan_with_nthreads (_nthreads);
+        //Clear the current plans
+        instance->rplan = instance->plan[0] = instance->plan[1] = 0;
+      }
+  }
+
+  static int threads ()
+  {
+    return instance_ok () ? instance->nthreads : 0;
+  }
+#endif
+
 private:
 
   // No copying!
 
   octave_float_fftw_planner (const octave_float_fftw_planner&);
 
   octave_float_fftw_planner& operator = (const octave_float_fftw_planner&);
 
@@ -301,16 +342,21 @@ private:
 
   // howmany
   octave_idx_type rh;
 
   // dims
   dim_vector rn;
 
   bool rsimd_align;
+
+#if defined (HAVE_FFTW3F_THREADS)
+  //number of threads when compiled with Multi-threading support
+  int nthreads;
+#endif
 };
 
 class
 OCTAVE_API
 octave_fftw
 {
 public:
 
diff --git a/liboctave/numeric/randmtzig.c b/liboctave/numeric/randmtzig.c
--- a/liboctave/numeric/randmtzig.c
+++ b/liboctave/numeric/randmtzig.c
@@ -632,17 +632,17 @@ oct_rande (void)
     create_ziggurat_tables ();
 
   while (1)
     {
       ZIGINT ri = ERANDI;
       const int idx = (int)(ri & 0xFF);
       const double x = ri * we[idx];
       if (ri < ke[idx])
-        return x;               // 98.9% of the time we return here 1st try
+        return x;               /* 98.9% of the time we return here 1st try */
       else if (idx == 0)
         {
           /* As stated in Marsaglia and Tsang
            *
            * For the exponential tail, the method of Marsaglia[5] provides:
            * x = r - ln(U);
            */
           return ZIGGURAT_EXP_R - log (RANDU);
@@ -799,17 +799,17 @@ oct_float_rande (void)
     create_ziggurat_float_tables ();
 
   while (1)
     {
       ZIGINT ri = ERANDI;
       const int idx = (int)(ri & 0xFF);
       const float x = ri * fwe[idx];
       if (ri < fke[idx])
-        return x;               // 98.9% of the time we return here 1st try
+        return x;               /* 98.9% of the time we return here 1st try */
       else if (idx == 0)
         {
           /* As stated in Marsaglia and Tsang
            *
            * For the exponential tail, the method of Marsaglia[5] provides:
            * x = r - ln(U);
            */
           return ZIGGURAT_EXP_R - log (RANDU);
diff --git a/liboctave/util/cmd-hist.cc b/liboctave/util/cmd-hist.cc
--- a/liboctave/util/cmd-hist.cc
+++ b/liboctave/util/cmd-hist.cc
@@ -187,18 +187,24 @@ gnu_history::do_histcontrol (void) const
 void
 gnu_history::do_add (const std::string& s)
 {
   if (! do_ignoring_entries ())
     {
       if (s.empty ()
           || (s.length () == 1 && (s[0] == '\r' || s[0] == '\n')))
         return;
+     
+      // Strip newline before adding to list
+      std::string stmp = s;
+      int stmp_len = stmp.length ();
+      if (stmp[stmp_len - 1] == '\n')
+        stmp.resize (stmp_len - 1);
 
-      lines_this_session += ::octave_add_history (s.c_str (), history_control);
+      lines_this_session += ::octave_add_history (stmp.c_str (), history_control);
     }
 }
 
 void
 gnu_history::do_remove (int n)
 {
   ::octave_remove_history (n);
 }
diff --git a/m4/acinclude.m4 b/m4/acinclude.m4
--- a/m4/acinclude.m4
+++ b/m4/acinclude.m4
@@ -88,16 +88,67 @@ AC_DEFUN([OCTAVE_CC_FLAG], [
       [CFLAGS="$CFLAGS $1"
       AC_MSG_RESULT([adding $1 to CFLAGS])], [$2])
   else
     AC_MSG_RESULT([no])
     ifelse([$3], , , [$3])
   fi
 ])
 dnl
+dnl Check whether the FFTW library supports multi-threading. This macro
+dnl should be called once per FFTW precision passing in the library
+dnl variant (e.g. "fftw3") and a function in the thread support API
+dnl (e.g. "fftw_plan_with_nthreads"). Depending on how FFTW was built,
+dnl the thread functions could be compiled into the main FFTW library or
+dnl could be a separate add-on library that is passed to the linker
+dnl ahead of the main FFTW library.
+dnl
+AC_DEFUN([OCTAVE_CHECK_FFTW_THREADS], [
+  ac_octave_save_CPPFLAGS="$CPPFLAGS"
+  ac_octave_save_LDFLAGS="$LDFLAGS"
+  ac_octave_save_LIBS="$LIBS"
+  CPPFLAGS="$m4_toupper([$1])_CPPFLAGS $CPPFLAGS"
+  LDFLAGS="$m4_toupper([$1])_LDFLAGS $LDFLAGS"
+  LIBS="$m4_toupper([$1])_LIBS $LIBS"
+  AC_CACHE_CHECK([for $1 multi-threading support],
+    [octave_cv_[$1]_threads_lib],
+    [AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+      #include <fftw3.h>
+      ]], [[
+      $2 (2);
+      ]])],
+      [octave_cv_[$1]_threads_lib=yes],
+      [LIBS="-l[$1]_threads $LIBS"
+      AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+        #include <fftw3.h>
+        ]], [[
+        $2 (2);
+        ]])],
+        [octave_cv_[$1]_threads_lib="-l[$1]_threads"],
+        [octave_cv_[$1]_threads_lib=no])
+    ])
+  ])
+  case $octave_cv_[$1]_threads_lib in
+    -l*)
+      m4_toupper([$1])_LIBS="$octave_cv_[$1]_threads_lib $m4_toupper([$1])_LIBS"
+      ;;
+    no)
+      AC_MSG_WARN([No $1 multi-threading support found.])
+      AC_MSG_WARN([The single-threaded library will be used instead.])
+      ;;
+  esac
+  if test $octave_cv_[$1]_threads_lib != no; then
+    AC_DEFINE([HAVE_]m4_toupper([$1])[_THREADS], 1,
+      [Define to 1 if ]m4_toupper([$1])[ has multi-threading support.])
+  fi
+  CPPFLAGS="$ac_octave_save_CPPFLAGS"
+  LDFLAGS="$ac_octave_save_LDFLAGS"
+  LIBS="$ac_octave_save_LIBS"
+])
+dnl
 dnl Check whether a math mapper function is available in <cmath>.
 dnl Will define HAVE_CMATH_FUNC if there is a double variant and
 dnl HAVE_CMATH_FUNCF if there is a float variant.
 dnl Currently capable of checking for functions with single 
 dnl argument and returning bool/int/real.
 dnl
 AC_DEFUN([OCTAVE_CHECK_FUNC_CMATH], [
   ac_safe=`echo "$1" | sed 'y% ./+-:=%___p___%'`
@@ -1481,17 +1532,22 @@ dnl
 dnl Check for makeinfo.
 dnl
 AC_DEFUN([OCTAVE_PROG_MAKEINFO], [
   dnl use MKINFO, not MAKEINFO, for variable name because Automake
   dnl automatically defines a value for MAKEINFO even when it does not
   dnl exist which will then fool the 'test -z' line.
   AC_CHECK_PROG(MKINFO, makeinfo, makeinfo, [])
   if test -z "$MKINFO"; then
-    AC_MSG_ERROR([makeinfo program required for reading documentation])
+    warn_makeinfo="
+
+I didn't find makeinfo, which is required for reading documentation.
+You may install a copy later for Octave to use.
+"
+    OCTAVE_CONFIGURE_WARNING([warn_makeinfo])
   fi
 ])
 dnl
 dnl What pager should we use?
 dnl
 AC_DEFUN([OCTAVE_PROG_PAGER], [
   if test "$cross_compiling" = yes; then
     DEFAULT_PAGER=less
diff --git a/run-octave.in b/run-octave.in
--- a/run-octave.in
+++ b/run-octave.in
@@ -58,31 +58,32 @@ if [ $# -gt 0 ]; then
     driver="gdb --args"
     shift
   elif [ "x$1" = "x-gud" ]; then
     ## Frontends for gdb (e.g. Emacs's GUD mode) need --annotate=3
     driver="gdb --annotate=3 --args"
     shift
   elif [ "x$1" = "x-gud2" ]; then
     ## The latest version of gud needs -i=mi. There isn't a good way to check
-    ## this at configure time, so we just add a gdb2 flag
+    ## this at configure time, so we just add a gud2 flag
     driver="gdb -i=mi --args"
     shift
   elif [ "x$1" = "x-valgrind" ]; then
     driver="valgrind --tool=memcheck"
     shift
   elif [ "x$1" = "x-strace" ]; then
     driver="strace -o octave.trace"
     shift
   elif [ "x$1" = "x-cli" ]; then
     octave_executable="$builddir/src/octave-cli"
     shift
   fi
 fi
 
 OCTAVE_SITE_INITFILE="$top_srcdir/scripts/startup/main-rcfile" \
 OCTAVE_DEFAULT_QT_SETTINGS="$top_srcdir/libgui/default-qt-settings" \
+OCTAVE_LOCALE_DIR="$top_srcdir/libgui/languages" \
 OCTAVE_JAVA_DIR="$builddir/scripts/java" \
   exec $builddir/libtool --mode=execute $driver \
     "$octave_executable" --no-init-path --path="$LOADPATH" \
     --image-path="$IMAGEPATH" --doc-cache-file="$DOCFILE" \
     --built-in-docstrings-file="$BUILT_IN_DOCSTRINGS_FILE" \
     --texi-macros-file="$TEXIMACROSFILE" --info-file="$INFOFILE" "$@"
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -238,20 +238,21 @@ function ret = edit (varargin)
       error('edit: if supplying more than one input all inputs must be strings containing fiel names to open.');
     endif
   endif
 
   ## Start the editor without a file if no file is given.
   if (nargin < 1)
     if (exist (FUNCTION.HOME, "dir") == 7 && (isunix () || ! ispc ()))
       system (cstrcat ("cd \"", FUNCTION.HOME, "\" ; ",
-                      sprintf (FUNCTION.EDITOR, "")),
+                      sprintf (undo_string_escapes (FUNCTION.EDITOR), "")),
               [], FUNCTION.MODE);
     else
-      system (sprintf (FUNCTION.EDITOR,""), [], FUNCTION.MODE);
+      system (sprintf (undo_string_escapes (FUNCTION.EDITOR), ""),
+              [], FUNCTION.MODE);
     endif
     return;
   endif
 
   if (numel(editfilelist) > 1)
 
     ## Call edit on each of the files in the list if there are more than 1
     for i = 1:numel(editfilelist)
@@ -323,50 +324,53 @@ function ret = edit (varargin)
         break;
       endif
     endfor
 
     if (! isempty (fileandpath))
       ## If the file exists, then edit it.
       if (FUNCTION.EDITINPLACE)
         ## Edit in place even if it is protected.
-        system (sprintf (FUNCTION.EDITOR, cstrcat ("\"", fileandpath, "\"")),
+        system (sprintf (undo_string_escapes (FUNCTION.EDITOR),
+                         cstrcat ("\"", fileandpath, "\"")),
                 [], FUNCTION.MODE);
         return;
       else
         ## If the file is modifiable in place then edit it, otherwise make
         ## a copy in HOME and then edit it.
         fid = fopen (fileandpath, "r+t");
         if (fid < 0)
           from = fileandpath;
           fileandpath = cstrcat (FUNCTION.HOME, from (rindex (from, filesep):end));
           [status, msg] = copyfile (from, fileandpath, 1);
           if (status == 0)
             error (msg);
           endif
         else
           fclose (fid);
         endif
-        system (sprintf (FUNCTION.EDITOR, cstrcat ("\"", fileandpath, "\"")),
+        system (sprintf (undo_string_escapes (FUNCTION.EDITOR),
+                         cstrcat ("\"", fileandpath, "\"")),
                 [], FUNCTION.MODE);
         return;
       endif
     endif
 
     ## If editing a new file that is neither a m-file or an oct-file,
     ## just edit it.
     fileandpath = file;
     idx = rindex (file, ".");
     name = file(1:idx-1);
     ext = file(idx+1:end);
     switch (ext)
       case {"cc", "m"}
         0;
       otherwise
-        system (sprintf (FUNCTION.EDITOR, cstrcat ("\"", fileandpath, "\"")),
+        system (sprintf (undo_string_escapes (FUNCTION.EDITOR),
+                         cstrcat ("\"", fileandpath, "\"")),
                 [], FUNCTION.MODE);
         return;
     endswitch
 
     ## The file doesn't exist in path so create it, put in the function
     ## template and edit it.
 
     ## Guess the email name if it was not given.
@@ -507,17 +511,18 @@ function ret = edit (varargin)
     fid = fopen (fileandpath, "wt");
     if (fid < 0)
       error ("edit: could not create %s", fileandpath);
     endif
     fputs (fid, text);
     fclose (fid);
 
     ## Finally we are ready to edit it!
-    system (sprintf (FUNCTION.EDITOR, cstrcat ("\"", fileandpath, "\"")),
+    system (sprintf (undo_string_escapes (FUNCTION.EDITOR),
+                     cstrcat ("\"", fileandpath, "\"")),
             [], FUNCTION.MODE);
             
   endif
 
 endfunction
 
 function ret = default_home ()
 
diff --git a/scripts/optimization/fsolve.m b/scripts/optimization/fsolve.m
--- a/scripts/optimization/fsolve.m
+++ b/scripts/optimization/fsolve.m
@@ -91,17 +91,17 @@
 ## As an inherent property of the algorithm, Jacobian is always requested for a
 ## solution vector whose residual vector is already known, and it is the last
 ## accepted successful step.  Often this will be one of the last two calls, but
 ## not always.  If the savings by reusing intermediate results from residual
 ## calculation in Jacobian calculation are significant, the best strategy is to
 ## employ OutputFcn: After a vector is evaluated for residuals, if OutputFcn is
 ## called with that vector, then the intermediate results should be saved for
 ## future Jacobian evaluation, and should be kept until a Jacobian evaluation
-## is requested or until outputfcn is called with a different vector, in which
+## is requested or until OutputFcn is called with a different vector, in which
 ## case they should be dropped in favor of this most recent vector.  A short
 ## example how this can be achieved follows:
 ##
 ## @example
 ## function [fvec, fjac] = user_func (x, optimvalues, state)
 ## persistent sav = [], sav0 = [];
 ## if (nargin == 1)
 ##   ## evaluation call
diff --git a/scripts/pkg/private/configure_make.m b/scripts/pkg/private/configure_make.m
--- a/scripts/pkg/private/configure_make.m
+++ b/scripts/pkg/private/configure_make.m
@@ -23,38 +23,38 @@
 ## @end deftypefn
 
 function configure_make (desc, packdir, verbose)
   ## Perform ./configure, make, make install in "src".
   if (exist (fullfile (packdir, "src"), "dir"))
     src = fullfile (packdir, "src");
     octave_bindir = octave_config_info ("bindir");
     ver = version ();
-    mkoctfile = fullfile (octave_bindir, sprintf ("mkoctfile-%s", ver));
-    octave_config = fullfile (octave_bindir, sprintf ("octave-config-%s", ver));
+    mkoctfile_program = fullfile (octave_bindir, sprintf ("mkoctfile-%s", ver));
+    octave_config_program = fullfile (octave_bindir, sprintf ("octave-config-%s", ver));
     octave_binary = fullfile (octave_bindir, sprintf ("octave-%s", ver));
-    cenv = {"MKOCTFILE"; mkoctfile;
-            "OCTAVE_CONFIG"; octave_config;
+    cenv = {"MKOCTFILE"; mkoctfile_program;
+            "OCTAVE_CONFIG"; octave_config_program;
             "OCTAVE"; octave_binary;
             "INSTALLDIR"; desc.dir};
     scenv = sprintf ("%s=\"%s\" ", cenv{:});
     ## Configure.
     if (exist (fullfile (src, "configure"), "file"))
       flags = "";
       if (isempty (getenv ("CC")))
-        flags = cstrcat (flags, " CC=\"", octave_config_info ("CC"), "\"");
+        flags = cstrcat (flags, " CC=\"", mkoctfile ("-p", "CC"), "\"");
       endif
       if (isempty (getenv ("CXX")))
-        flags = cstrcat (flags, " CXX=\"", octave_config_info ("CXX"), "\"");
+        flags = cstrcat (flags, " CXX=\"", mkoctfile ("-p", "CXX"), "\"");
       endif
       if (isempty (getenv ("AR")))
-        flags = cstrcat (flags, " AR=\"", octave_config_info ("AR"), "\"");
+        flags = cstrcat (flags, " AR=\"", mkoctfile ("-p", "AR"), "\"");
       endif
       if (isempty (getenv ("RANLIB")))
-        flags = cstrcat (flags, " RANLIB=\"", octave_config_info ("RANLIB"), "\"");
+        flags = cstrcat (flags, " RANLIB=\"", mkoctfile ("-p", "RANLIB"), "\"");
       endif
       [status, output] = shell (cstrcat ("cd '", src, "'; ", scenv,
                                          "./configure --prefix=\"",
                                          desc.dir, "\"", flags));
       if (status != 0)
         rmdir (desc.dir, "s");
         error ("the configure script returned the following error: %s", output);
       elseif (verbose)
diff --git a/scripts/pkg/private/get_forge_pkg.m b/scripts/pkg/private/get_forge_pkg.m
--- a/scripts/pkg/private/get_forge_pkg.m
+++ b/scripts/pkg/private/get_forge_pkg.m
@@ -34,40 +34,40 @@ function [ver, url] = get_forge_pkg (nam
     error ("get_forge_pkg: package NAME must be a string");
   elseif (! all (isalnum (name) | name == "-" | name == "." | name == "_"))
     error ("get_forge_pkg: invalid package name: %s", name);
   endif
 
   name = tolower (name);
 
   ## Try to download package's index page.
-  [html, succ] = urlread (sprintf ("http://octave.sourceforge.net/%s/index.html", name));
+  [html, succ] = urlread (sprintf ("http://packages.octave.org/%s/index.html", name));
   if (succ)
     ## Remove blanks for simpler matching.
     html(isspace(html)) = [];
     ## Good. Let's grep for the version.
     pat = "<tdclass=""package_table"">PackageVersion:</td><td>([\\d.]*)</td>";
     t = regexp (html, pat, "tokens");
     if (isempty (t) || isempty (t{1}))
       error ("get_forge_pkg: could not read version number from package's page");
     else
       ver = t{1}{1};
       if (nargout > 1)
         # Build download string.
-        urlbase = "http://downloads.sourceforge.net/octave/%s-%s.tar.gz?download";
-        url = sprintf (urlbase, name, ver);
-        ## Verify that the string exists on the page.
-        if (isempty (strfind (html, url)))
+        pkg_file = sprintf ("%s-%s.tar.gz", name, ver);
+        url = cstrcat ("http://packages.octave.org/download/", pkg_file);
+        ## Verify that the package string exists on the page.
+        if (isempty (strfind (html, pkg_file)))
           warning ("get_forge_pkg: download URL not verified");
         endif
       endif
     endif
   else
     ## Try get the list of all packages.
-    [html, succ] = urlread ("http://octave.sourceforge.net/packages.php");
+    [html, succ] = urlread ("http://packages.octave.org/packages.php");
     if (succ)
       t = regexp (html, "<div class=""package"" id=""(\\w+)"">", "tokens");
       t = horzcat (t{:});
       if (any (strcmp (t, name)))
         error ("get_forge_pkg: package NAME exists, but index page not available");
       else
         ## Try a simplistic method to determine close names.
         dist = cellfun (@(n) length (setdiff (name, n)), t);
diff --git a/scripts/pkg/private/list_forge_packages.m b/scripts/pkg/private/list_forge_packages.m
--- a/scripts/pkg/private/list_forge_packages.m
+++ b/scripts/pkg/private/list_forge_packages.m
@@ -18,17 +18,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{list} =} list_forge_packages ()
 ## Undocumented internal function.
 ## @end deftypefn
 
 function list = list_forge_packages ()
-  [list, succ] = urlread ("http://octave.sourceforge.net/list_packages.php");
+  [list, succ] = urlread ("http://packages.octave.org/list_packages.php");
   if (succ)
     list = strsplit (list, " \n\t", true);
   else
     error ("pkg: could not read URL, please verify internet connection");
   endif
   if (nargout == 0)
     page_screen_output (false, "local");
     puts ("OctaveForge provides these packages:\n");
diff --git a/scripts/plot/legend.m b/scripts/plot/legend.m
--- a/scripts/plot/legend.m
+++ b/scripts/plot/legend.m
@@ -869,16 +869,17 @@ function [hlegend2, hobjects2, hplot2, t
                "orientation", orientation, "textposition", textpos);
         else
           set (hlegend, "location", position, "orientation", orientation,
                "textposition", textpos);
         endif
         if (addprops)
           addlistener (hlegend, "edgecolor", @updatelegendtext);
           addlistener (hlegend, "textcolor", @updatelegendtext);
+          addlistener (hlegend, "fontsize", @updatelegendtext);
           addlistener (hlegend, "interpreter", @updatelegendtext);
           addlistener (hlegend, "location", @updatelegend);
           addlistener (hlegend, "orientation", @updatelegend);
           addlistener (hlegend, "string", @updatelegend);
           addlistener (hlegend, "textposition", @updatelegend);
         endif
       unwind_protect_cleanup
         set (fig, "currentaxes", curaxes);
@@ -910,17 +911,20 @@ function updatelegend (h, d)
 endfunction
 
 function updatelegendtext (h, d)
   hax = get (h, "userdata").handle;
   kids = get (h, "children");
   text_kids = findobj (kids, "-property", "interpreter", "type", "text");
   interpreter = get (h, "interpreter");
   textcolor = get (h, "textcolor");
-  set (text_kids, "interpreter", interpreter, "color", textcolor);
+  fontsize = get (h, "fontsize");
+  set (text_kids, "interpreter", interpreter,
+                  "fontsize", fontsize,
+                  "color", textcolor);
 endfunction
 
 function hideshowlegend (h, d, ca, pos1, pos2)
   isvisible = strcmp (get (h, "visible"), "off");
   if (! isvisible)
     kids = get (h, "children");
     for i = 1 : numel (kids)
       if (! strcmp (get (kids(i), "visible"), "off"))
diff --git a/scripts/plot/module.mk b/scripts/plot/module.mk
--- a/scripts/plot/module.mk
+++ b/scripts/plot/module.mk
@@ -145,16 +145,17 @@ plot_FCN_FILES = \
   plot/pie.m \
   plot/pie3.m \
   plot/plot.m \
   plot/plot3.m \
   plot/plotmatrix.m \
   plot/plotyy.m \
   plot/polar.m \
   plot/print.m \
+  plot/printd.m \
   plot/quiver.m \
   plot/quiver3.m \
   plot/rectangle.m \
   plot/refresh.m \
   plot/refreshdata.m \
   plot/ribbon.m \
   plot/rose.m \
   plot/saveas.m \
@@ -169,16 +170,17 @@ plot_FCN_FILES = \
   plot/shrinkfaces.m \
   plot/slice.m \
   plot/sombrero.m \
   plot/specular.m \
   plot/sphere.m \
   plot/stairs.m \
   plot/stem.m \
   plot/stem3.m \
+  plot/stemleaf.m \
   plot/struct2hdl.m \
   plot/subplot.m \
   plot/surf.m \
   plot/surface.m \
   plot/surfc.m \
   plot/surfl.m \
   plot/surfnorm.m \
   plot/tetramesh.m \
diff --git a/scripts/plot/printd.m b/scripts/plot/printd.m
new file mode 100644
--- /dev/null
+++ b/scripts/plot/printd.m
@@ -0,0 +1,101 @@
+## Copyright (C) 2013 Michael D. Godfrey
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or
+## modify it under the terms of the GNU General Public
+## License as published by the Free Software Foundation;
+## either version 3 of the License, or (at your option) any
+## later version.
+##
+## Octave is distributed in the hope that it will be useful,
+## but WITHOUT ANY WARRANTY; without even the implied
+## warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+## PURPOSE. See the GNU General Public License for more
+## details.
+##
+## You should have received a copy of the GNU General Public
+## License along with Octave; see the file COPYING. If not,
+## see <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {} printd (@var{obj}, @var{filename})
+##
+## Convert any object acceptable to @code{disp} into the format
+## selected by the suffix of @var{filename}.
+##
+## This function is intended to facilitate manipulation of the output
+## of functions such as @code{stemleaf}.
+## @seealso{stemleaf}
+## @end deftypefn
+
+## Author: Michael D. Godfrey <michaeldgodfrey@gmail.com>
+## Description: Convert objects into other file formats.
+
+function printd (obj, filename)
+  ## Convert any object acceptable to disp() into various display formats.
+  ## obj is the input object.
+  ## filename is the output file (with required suffix).
+
+  ## Extract .suffix from filename
+  if ((sufix = rindex (filename, ".")) <= 0)
+    error ("The output filename: %s requires a suffix.\nOptions are: pdf ps eps txt jpg jpeg", filename);
+  endif
+  opt = substr (filename, sufix+1);
+  [pf, tempf, mag] = mkstemp ("oct-XXXXXX", 1);  # Safe version of tmpnam()
+  fprintf (pf, "%s", disp (obj));
+  frewind (pf);
+
+  ## It seems best to only use convert for image output.  Its ps and pdf
+  ## are badly rendered.
+  opt = lower (opt);
+  switch opt
+    case {"pdf"}
+      enscr = sprintf (
+                       "enscript --no-header -o %s.ps %s ; ps2pdf %s.ps %s.pdf; mv %s.pdf %s;exit",...
+                       tempf, tempf, tempf, tempf, tempf, filename);
+      system (enscr);
+      delete ([tempf ".ps"]);
+    case {"ps"}
+      enscr = sprintf ("enscript --no-header -o %s %s ; exit", filename, tempf);
+      system (enscr);
+    case {"eps"}
+      enscr = sprintf (
+                       "enscript --no-header -o %s.ps %s ; ps2eps --ignoreBB %s.ps; mv %s.eps %s; exit",...
+                       tempf, tempf, tempf, tempf, filename);
+      system (enscr);
+      delete ([tempf ".ps"]);
+    case {"txt"}
+      enscr = sprintf ("cp %s %s", tempf, filename);
+      system (enscr);
+    case {"jpg" "jpeg"}
+      enscr = sprintf ("convert -trim txt:%s  jpg:%s", tempf, filename);
+      system (enscr);
+    otherwise
+      fclose (pf);
+      delete (tempf);
+      error ("Unknown conversion type: %s.\nOptions are: pdf ps eps txt jpg jpeg", opt);
+
+  endswitch
+  fclose (pf);
+  delete (tempf);
+  printf ("%s file %s written\n", opt, filename);
+endfunction
+
+%!demo
+%!  r2 = ["stem step: 10, data: unsorted.\nHinges:    lo: 12, hi: 42\n";...
+%! "   1 | 22118";"   2 | 28";"   3 | 98";"   4 | 244";"   5 | 2"];
+%! printd (r2, "test_p.txt");
+%! system ("cat test_p.txt");
+%! delete ("test_p.txt");
+
+%!test
+%! r2 = ["stem step: 10, data: unsorted.\nHinges:    lo: 12, hi: 42\n";...
+%! "   1 | 22118";"   2 | 28";"   3 | 98";"   4 | 244";"   5 | 2"];
+%! printd (r2, "test_p.txt");
+%! r4 = fileread ("test_p.txt");
+%! delete ("test_p.txt");
+%! r2 = disp (r2);
+%! assert (r4, r2)
+
+
diff --git a/scripts/plot/private/__go_draw_axes__.m b/scripts/plot/private/__go_draw_axes__.m
--- a/scripts/plot/private/__go_draw_axes__.m
+++ b/scripts/plot/private/__go_draw_axes__.m
@@ -1586,17 +1586,29 @@ function __go_draw_axes__ (h, plot_strea
           pos = "";
       endswitch
       if (__gnuplot_has_feature__ ("key_has_font_properties"))
         [fontname, fontsize] = get_fontname_and_size (hlgnd);
         fontspec = create_fontspec (fontname, fontsize, gnuplot_term);
       else
         fontspec = "";
       endif
-      colorspec = get_text_colorspec (hlgnd.textcolor, mono);
+      textcolors = get (findobj (hlgnd.children, "type", "text"), "color");
+      if (iscell (textcolors))
+        textcolors = cell2mat (textcolors);
+        textcolors = unique (textcolors, "rows");
+      endif
+      if (rows (textcolors) > 1)
+        ## Gnuplot is unable to assign arbitrary colors to each text entry
+        ## for the key/legend.  But, the text color can be set to match the
+        ## color of the plot object.
+        colorspec = "textcolor variable";
+      else
+        colorspec = get_text_colorspec (textcolors, mono);
+      endif
       fprintf (plot_stream, "set key %s %s;\nset key %s %s %s %s %s;\n",
                inout, pos, box, reverse, horzvert, fontspec, colorspec);
     else
       fputs (plot_stream, "unset key;\n");
     endif
     fputs (plot_stream, "set style data lines;\n");
 
     cmap = [cmap; addedcmap];
@@ -2345,17 +2357,17 @@ function str = no_super_sub_scripts (str
     str = char (labels);
   endif
 endfunction
 
 function str = __tex2enhanced__ (str, fnt, it, bld)
   persistent sym = __setup_sym_table__ ();
   persistent flds = fieldnames (sym);
 
-  [s, e, m] = regexp (str,'\\\\([a-zA-Z]+|0)','start','end','matches');
+  [s, e, m] = regexp (str, "\\\\([a-zA-Z]+|0)", "start", "end", "matches");
 
   for i = length (s) : -1 : 1
     ## special case for "\0"  and replace with "{/Symbol \306}'
     if (strncmp (m{i}, '\0', 2))
       str = cstrcat (str(1:s(i) - 1), '{/Symbol \306}', str(s(i) + 2:end));
     else
       f = m{i}(2:end);
       if (isfield (sym, f))
diff --git a/scripts/plot/stemleaf.m b/scripts/plot/stemleaf.m
new file mode 100644
--- /dev/null
+++ b/scripts/plot/stemleaf.m
@@ -0,0 +1,318 @@
+## Copyright (C) 2013 Michael D. Godfrey
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or
+## modify it under the terms of the GNU General Public
+## License as published by the Free Software Foundation;
+## either version 3 of the License, or (at your option) any
+## later version.
+##
+## Octave is distributed in the hope that it will be useful,
+## but WITHOUT ANY WARRANTY; without even the implied
+## warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+## PURPOSE. See the GNU General Public License for more
+## details.
+##
+## You should have received a copy of the GNU General Public
+## License along with Octave; see the file COPYING. If not,
+## see <http://www.gnu.org/licenses/>.
+
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {} stemleaf (@var{x})
+## @deftypefnx {Function File} {@var{plot} =} stemleaf (@var{x}, @var{opt})
+##
+## Compute and display a stem and leaf plot of the vector @var{x}.
+##
+## The @var{x} vector is converted to integer by @var{x} = @code{fix} (@var{x}). 
+## If an output argument is provided, the plot is returned as
+## an array of strings.  The first element is the heading
+## followed by an element for each stem.
+## The default stem step is 10.  
+## The @var{x} vector should be integers.  It will be treated so that
+## the last digit is the leaf value and the other digits are
+## the stems.
+## The leaf digits are not sorted.  If sorted leaf values
+## are wanted, use @code{sort} (@var{x}) before calling @code{stemleaf} (@var{x}).
+## The stem and leaf plot is described in: Ch. 3,
+## Exploratory Data Analysis by J. W. Tukey, Addison-Wesley, 1977.
+## @seealso{hist, printd}
+## @end deftypefn
+
+## Author: Michael D. Godfrey <michaeldgodfrey@gmail.com>
+## Description: Compute stem and leaf plot
+
+function varargout = stemleaf (x, stem_unit)
+  ## Compute and display a stem and leaf plot of the vector x. The x
+  ## vector is converted to integer by x = fix(x). If an output argument
+  ## is provided, the plot is returned as an array of strings.  The
+  ## first element is the heading followed by an element for each stem.
+  ##
+  ## The default stem step is 10.  If stem_unit is provided the stem
+  ## step is set to: 10^(stem_unit+1) The x vector should be integers.
+  ## It will be treated so that the last digit is the leaf value and the
+  ## other digits are the stems.
+  ##
+  ## When we first implemented stem and leaf plots in the early 1960's
+  ## there was some discussion about sorting vs. leaving the leaf
+  ## entries in the original order in the data. We decided in favor or
+  ## sorting the leaves for most purposes. This is the choice
+  ## implemented in the SNAP/IEDA system that was written at that time.
+  ##
+  ## SNAP/IEDA and particularly its stem and leaf plotting were further
+  ## developed by Hale Trotter, David Hoagland (at Princeton and MIT)
+  ## and others.
+  ##
+  ## Tukey, in EDA, generally uses unsorted leaves.  In addition, he
+  ## described a wide range of additional display formats.  This
+  ## implementation does not sort the leaves, but if the x vector is
+  ## sorted then the leaves come out sorted.  A simple display format is
+  ## used.
+  ##
+  ## I doubt if providing other options is worthwhile.  The code can
+  ## quite easily be modified to provide specific display results.  Or,
+  ## the returned output string can be edited. The returned output is an
+  ## array of strings with each row containing a line of the plot
+  ## preceded by the lines of header text as the first row.  This
+  ## facilitates annotation.
+  ##
+  ## Note that the code has some added complexity due to the need to
+  ## distinguish both + and - 0 stems. The +- stem values are essential
+  ## for all plots which span 0. After dealing with +-0 stems, the added
+  ## complexity of putting +- data values in the correct stem is minor,
+  ## but the sign of 0 leaves must be checked.  And, the cases where the
+  ## stems start or end at +- 0 must also be considered.
+  ##
+  ## The fact that IEEE floating point defines +- 0 helps make this
+  ## easier.
+  ##
+  ##
+  ## Michael D. Godfrey   January 2013
+
+  ## More could be implemented for better data scaling. And, of course,
+  ## other options for the kinds of plots described by Tukey could be
+  ## provided. This may best be left to users.
+
+  if (nargin >= 2)
+    stem_step = 10^(stem_unit+1);
+  else
+    stem_step = 10;
+  endif
+  if (any (x == int32 (x)) == 0)
+    printf ('Input vector truncated to integer values.\n')
+    x = fix (x);
+  endif
+
+  ## Avoid use of int32 due to:
+
+  ##  floor (int32 (-44)/10) == -4 and floor (int32 (-46)/10) = -5 !!!
+  ##  x  = sort (fix (x));  % User can decide about sorting x.
+  ##  x  = fix (x);
+  ##  %Adjust scale if too small.
+  ##  while any(abs((fix(x) - x)) >= abs(x/100))
+  ##    x =10*x;
+  ##  endwhile
+
+  ## Note that IEEE 754 states that -+ 0 should compare equal. This has
+  ## led to C sort (and therefore Octave) treating them as equal.  Thus,
+  ## sort([ -1 0 -0 1]) yields: -1 0 -0 1. and, sort([-1 -0 0 1])
+  ## yields: -1 -0 0 1. This means that stem-and-leaf plotting cannot
+  ## rely on sort to order the data as needed for display.
+
+  if (all((sort(x) == x)) == 1)
+    hsort = 'sorted.';
+  else
+    hsort = 'unsorted.';
+  endif
+  nx = max (size (x));
+  ## Determine stem values
+  if (min(x) < 0)
+    if (signbit(max(x)) == 0)     # max is positive
+      stems = [fix(min(x)/stem_step)-1 : -1 -0];
+      stems = [stems 0 : fix(max(x)/stem_step)+1 ];
+    else
+      if (max(x) < 0)
+        stems = [(fix(min(x)/stem_step)-1) : fix(max(x)/stem_step)];
+      else
+        stems = [(fix(min(x)/stem_step)-1) : -1 -0];
+        stems = [stems 0 : fix(max(x)/stem_step)];
+      endif
+    endif
+  else                            # All stems are > 0
+    stems = [fix(min(x)/stem_step) : fix(max(x)/stem_step) + 1];
+  endif
+  ##stems
+  ##x
+  nstems = max(size(stems));
+  ## compute hinges at +- 1.5 * quartiles
+  ## this requires sorted data!
+  xs = sort (x);                   # Note that sort preserves -0
+  threeh = 1.5;
+  two    = 2.0;
+  j  = idivide(nx, 4, "fix") + 1;  # Use F95 truncation.
+  k  = nx - j + 1;
+  hl = xs (j);
+  hu = xs (k);
+  if ( (nx + 1) ==  (4 * j) ) 
+    hl = (xs (j + 1) + hl) / two;
+    hu = (xs (k - 1) + hu) / two;
+  endif
+
+  ##     ::::::::  determine h-spread (dh) and fences  ::::::::
+  dh = hu - hl;
+  fu = hu + threeh * dh;
+  fl = hl - threeh * dh;
+
+  ##     ::::::::  find value adjacent to lower fence  ::::::::
+  for i = 1:j
+    if ( xs (i) >= fl ) 
+      continue; 
+    endif
+  endfor
+  ilow = i;
+  xlo = xs (ilow);
+
+  ##     :::::::: find value adjacent to upper fence  ::::::::
+  for  i = 1:j
+    if ( xs (nx -i + 1) <= fu )
+      continue;
+    endif
+  endfor
+
+  ihi = nx - i + 1;
+  xhi = xs (ihi);
+
+  ## Heading for output:
+  plot_out = "";
+  plot_out = [plot_out sprintf("stem step: %i, data: %s\nHinges:    lo: %g, hi: %g\n",
+                               stem_step, hsort, xlo, xhi)];
+
+  ## This may appear to be a good place to use vectorization using the
+  ## stem and data arrays but the necessary special case treatment of 0
+  ## and -0 seems to result in little reduction of complexity, and since
+  ## this algorithm is for small data vectors only there would be
+  ## practically no performance improvement.
+
+  ## Determine leaves for each stem:
+  for kx = 2:nstems
+    line_out = "";
+    steml    = "";
+    ## Build a string of leaf digits for stem(kx) if stem(kx) <= 0, or
+    ## stem(kx-1) if stem(kx) > 0
+
+    ## stems -+ 0 have to be handled as special cases.
+    for xi = 1:nx
+      if(signbit(stems(kx)) == 1)
+        t1 = ((x(xi) <= stems(kx)*10) && (x(xi) > (stems(kx-1)*10)));
+      else
+        t1 = ((x(xi) < stems(kx)*10) && (x(xi) >= (stems(kx-1)*10)));
+      endif
+      ## Special tests for stem -+ 0
+      if ((stems(kx) == 0) && signbit(stems(kx)) && (x(xi) == 0)) && !signbit(x(xi))
+        t1 = 0;
+      endif
+      if ((stems(kx-1) == 0) && !signbit(stems(kx-1)) && (x(xi) == 0)) && signbit(x(xi))
+        t1 = 0;
+      endif
+      ## Create line as a string
+      if t1
+        if (stems(kx) <= 0)
+          xz =  abs (x(xi) - stems(kx)*10);
+        else
+          xz =  abs (x(xi) - stems(kx-1)*10);
+        endif
+        if ((stems(kx) == 0) && signbit(stems(kx)))
+          steml = [steml sprintf("%d", abs(x(xi) - stems(kx)*10))];
+        else
+          steml = [steml sprintf("%d", xz)];
+        endif
+      endif    %  t1
+    endfor    % xi = 1:nx
+
+    ## Set correct -0
+    if ((stems(kx) == 0) && signbit(stems(kx)))
+      line_out = [line_out sprintf("  -0 | %s",  steml)];  % -0 stem.
+    else
+      if( stems(kx) < 0)
+        line_out = [line_out sprintf("%4d | %s", stems(kx), steml)];
+      else
+        if stems(kx) > 0
+          line_out = [line_out sprintf("%4d | %s", stems(kx-1), steml)];
+        endif
+      endif
+    endif
+    plot_out = [plot_out; line_out];
+  endfor    % kx = 2:nstems
+  if (nargout == 0)
+    rows = size (plot_out)(1);
+    cols = size (plot_out)(2);
+    for k = 1:rows
+      printf("%s\n", plot_out(k,1:cols));
+    endfor
+  else
+    varargout{1} = plot_out;
+  endif
+endfunction
+
+%!demo
+%! ## Unsorted plot:
+%! x = [-22 12 -28 52  39 -2 12 10 11 11 42 38 44 18 44];
+%! stemleaf (x, 0);
+
+%!demo
+%! ## Sorted leaves:
+%! x = [-22 12 -28 52  39 -2 12 10 11 11 42 38 44 18 44];
+%! y = sort(x);
+%! stemleaf (y, 0);
+
+%!demo
+%! ## More data (sorted)
+%! x = [-22 12 -28 52  39 -2 12 10 11 11 42 38 44 18 44 37 113 124 37 48 127 36 29 31 125 139 131 115 105 132 104 123 35 113 122 42 117 119 58 109 23 105 63 27 44 105 99 41 128 121 116 125 32 61 37 127 29 113 121 58 114 126 53 114 96 25 109 7 31 141 46 -13 71 43 117 116 27 7 68 40 31 115 124 42 128 52 71 118 117 38 27 106 33 117 116 111 40 119 47 105 57 122 109 124 115 43 120 43 27 27 18 28 48 125 107 114 34 133 45 120 30 127 31 116 146 21 23 30 10 20 21 30 0 100 110 1 20 0 ];
+%! y = sort(x);
+%! stemleaf (y, 0);
+
+%!test
+%! ## test minus to plus
+%! x = [-22 12 -28 52  39 -2 12 10 11 11 42 38 44 18 44 37 113 124 37 48 127 36 29 31 125 139 131 115 105 132 104 123 35 113 122 42 117 119 58 109 23 105 63 27 44 105 99 41 128 121 116 125 32 61 37 127 29 113 121 58 114 126 53 114 96 25 109 7 31 141 46 -13 71 43 117 116 27 7 68 40 31 115 124 42 128 52 71 118 117 38 27 106 33 117 116 111 40 119 47 105 57 122 109 124 115 43 120 43 27 27 18 28 48 125 107 114 34 133 45 120 30 127 31 116 146 21 23 30 10 20 21 30 0 100 110 1 20 0 ];
+%! x = sort(x);
+%! r2 = ["stem step: 10, data: sorted.\nHinges:    lo: 30, hi: 116\n";...
+%! "  -2 | 82";"  -1 | 3";"  -0 | 2";"   0 | 00177";...
+%! "   1 | 00112288";"   2 | 001133577777899";...
+%! "   3 | 000111123456777889";"   4 | 00122233344456788";...
+%! "   5 | 223788";"   6 | 138";"   7 | 11";"   8 | ";...
+%! "   9 | 69";"  10 | 04555567999";"  11 | 0133344455566667777899";...
+%! "  12 | 0011223444555677788";"  13 | 1239";"  14 | 16"];
+%! rx = stemleaf (x, 0);
+%! assert(r2, rx);
+%!test
+%! ## positive values above 0
+%! x = [22 12 28 52  39 12 11 11 42 38 44 18 44 ];
+%! r2 = ["stem step: 10, data: unsorted.\nHinges:    lo: 12, hi: 42\n";...
+%! "   1 | 22118";"   2 | 28";"   3 | 98";"   4 | 244";"   5 | 2"];
+%! rx = stemleaf (x, 0);
+%! assert(r2, rx);
+%!test
+%! ## negative values below 0
+%! x = [22 12 28 52  39 12 11 11 42 38 44 18 44];
+%! x = -x;
+%! r2 = ["stem step: 10, data: unsorted.\nHinges:    lo: -42, hi: -12\n";...
+%! "  -5 | 2";"  -4 | 244";"  -3 | 98";"  -2 | 28";"  -1 | 22118"];
+%! rx = stemleaf (x, 0);
+%! assert(r2, rx);
+%!test
+%! ## positive values from 0
+%! x = [22 12 28 52  39 2 12 0 11 11 42 38 44 18 44];
+%! r2 = ["stem step: 10, data: unsorted.\nHinges:    lo: 11, hi: 42\n";...
+%! "   0 | 20";"   1 | 22118";"   2 | 28";"   3 | 98";"   4 | 244";"   5 | 2"];
+%! rx = stemleaf (x, 0);
+%! assert(r2, rx);
+%!test
+%! ## negative values from 0
+%! x = [22 12 28 52  39 2 12 0 11 11 42 38 44 18 44];
+%! x = -x;
+%! r2 = ["stem step: 10, data: unsorted.\nHinges:    lo: -42, hi: -11\n";...
+%! "  -5 | 2";"  -4 | 244";"  -3 | 98";"  -2 | 28";"  -1 | 22118";"  -0 | 20"];
+%! rx = stemleaf (x, 0);
+%! assert(r2, rx);
+
diff --git a/scripts/plot/struct2hdl.m b/scripts/plot/struct2hdl.m
--- a/scripts/plot/struct2hdl.m
+++ b/scripts/plot/struct2hdl.m
@@ -143,16 +143,18 @@ function [h, pout] = struct2hdl (s, p=[]
   elseif (strcmp (s.type, "text"))
     h = createtext (s, par);
   elseif (strcmp (s.type, "image"))
     h = createimage (s, par);
   elseif (strcmp (s.type, "surface"))
     h = createsurface (s, par);
   elseif (strcmp (s.type, "hggroup"))
     [h, s, p] = createhg (s, p, par, hilev);
+  else
+    error ("struct2hdl: %s objects are not implemented yet", s.type)
   endif
 
   ## children
   p = [p [s.handle; h]];  # [original; new]
   kids = s.children;
   nkids = length (kids);
   ii = 0;
   while (nkids)
diff --git a/scripts/testfun/__printf_assert__.m b/scripts/testfun/__printf_assert__.m
new file mode 100644
--- /dev/null
+++ b/scripts/testfun/__printf_assert__.m
@@ -0,0 +1,27 @@
+## Copyright (C) 2005-2012 David Bateman
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {} __printf_assert__ (@dots{})
+## Undocumented internal function.
+## @end deftypefn
+
+function __printf_assert__ (varargin)
+  global _assert_printf;
+  _assert_printf = cat (2, _assert_printf, sprintf (varargin{:}));
+endfunction
diff --git a/scripts/testfun/__prog_output_assert__.m b/scripts/testfun/__prog_output_assert__.m
new file mode 100644
--- /dev/null
+++ b/scripts/testfun/__prog_output_assert__.m
@@ -0,0 +1,34 @@
+## Copyright (C) 2005-2012 David Bateman
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {} __prog_output_assert__ (@var{str})
+## Undocumented internal function.
+## @end deftypefn
+
+function ret = __prog_output_assert__ (str)
+  global _assert_printf;
+  if (isempty (_assert_printf))
+    ret = isempty (str);
+  elseif (_assert_printf(end) == "\n")
+    ret = strcmp (_assert_printf(1:(end-1)), str);
+  else
+    ret = strcmp (_assert_printf, str);
+  endif
+  _assert_printf = "";
+endfunction
diff --git a/scripts/testfun/__run_test_suite__.m b/scripts/testfun/__run_test_suite__.m
new file mode 100644
--- /dev/null
+++ b/scripts/testfun/__run_test_suite__.m
@@ -0,0 +1,285 @@
+## Copyright (C) 2005-2012 David Bateman
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {} __run_test_suite__ (@var{fcndirs}, @var{fixedtestdirs})
+## Undocumented internal function.
+## @end deftypefn
+
+function __run_test_suite__ (fcndirs, fixedtestdirs)
+  testsdir = octave_config_info ("octtestsdir");
+  libinterptestdir = fullfile (testsdir, "libinterp");
+  liboctavetestdir = fullfile (testsdir, "liboctave");
+  fixedtestdir = fullfile (testsdir, "fixed");
+  fcnfiledir = octave_config_info ("fcnfiledir");
+  if (nargin == 0)
+    fcndirs = { libinterptestdir, liboctavetestdir, fcnfiledir };
+    fixedtestdirs = { fixedtestdir };
+  endif
+  global files_with_no_tests = {};
+  global files_with_tests = {};
+  ## FIXME -- these names don't really make sense if we are running
+  ## tests for an installed copy of Octave.
+  global topsrcdir = fcnfiledir;
+  global topbuilddir = testsdir;
+  pso = page_screen_output ();
+  warn_state = warning ("query", "quiet");
+  warning ("on", "quiet");
+  try
+    page_screen_output (0);
+    warning ("off", "Octave:deprecated-function");
+    fid = fopen ("fntests.log", "wt");
+    if (fid < 0)
+      error ("could not open fntests.log for writing");
+    endif
+    test ("", "explain", fid);
+    dp = dn = dxf = dsk = 0;
+    puts ("\nIntegrated test scripts:\n\n");
+    for i = 1:length (fcndirs)
+      [p, n, xf, sk] = run_test_script (fid, fcndirs{i});
+      dp += p;
+      dn += n;
+      dxf += xf;
+      dsk += sk;
+    endfor
+    puts ("\nFixed test scripts:\n\n");
+    for i = 1:length (fixedtestdirs)
+      [p, n, xf, sk] = run_test_dir (fid, fixedtestdirs{i});
+      dp += p;
+      dn += n;
+      dxf += xf;
+      dsk += sk;
+    endfor
+    puts ("\nSummary:\n\n");
+    nfail = dn - dp;
+    printf ("  PASS    %6d\n", dp);
+    printf ("  FAIL    %6d\n", nfail);
+    if (dxf > 0)
+      printf ("  XFAIL   %6d\n", dxf);
+    endif
+    if (dsk > 0)
+      printf ("  SKIPPED %6d\n", dsk);
+    endif
+    puts ("\n");
+    puts ("See the file test/fntests.log for additional details.\n");
+    if (dxf > 0)
+      puts ("\n");
+      puts ("Expected failures (listed as XFAIL above) are known bugs.\n");
+      puts ("Please help improve Octave by contributing fixes for them.\n");
+    endif
+    if (dsk > 0)
+      puts ("\n");
+      puts ("Tests are most often skipped because the features they require\n");
+      puts ("have been disabled.  Features are most often disabled because\n");
+      puts ("they require dependencies that were not present when Octave\n");
+      puts ("was built.  The configure script should have printed a summary\n");
+      puts ("at the end of its run indicating which dependencies were not found.\n");
+    endif
+
+    ## Weed out deprecated and private functions
+    weed_idx = cellfun (@isempty, regexp (files_with_tests, '\bdeprecated\b|\bprivate\b', 'once'));
+    files_with_tests = files_with_tests(weed_idx);
+    weed_idx = cellfun (@isempty, regexp (files_with_no_tests, '\bdeprecated\b|\bprivate\b', 'once'));
+    files_with_no_tests = files_with_no_tests(weed_idx);
+
+    report_files_with_no_tests (files_with_tests, files_with_no_tests, ".m");
+
+    puts ("\nPlease help improve Octave by contributing tests for\n");
+    puts ("these files (see the list in the file fntests.log).\n\n");
+
+    fprintf (fid, "\nFiles with no tests:\n\n%s",
+            list_in_columns (files_with_no_tests, 80));
+    fclose (fid);
+
+    page_screen_output (pso);
+    warning (warn_state.state, "quiet");
+  catch
+    page_screen_output (pso);
+    warning (warn_state.state, "quiet");
+    disp (lasterr ());
+  end_try_catch
+endfunction
+
+function print_test_file_name (nm)
+  filler = repmat (".", 1, 55-length (nm));
+  printf ("  %s %s", nm, filler);
+endfunction
+
+function print_pass_fail (n, p)
+  if (n > 0)
+    printf (" PASS %4d/%-4d", p, n);
+    nfail = n - p;
+    if (nfail > 0)
+      printf (" FAIL %d", nfail);
+    endif
+  endif
+  puts ("\n");
+endfunction
+
+function retval = has_functions (f)
+  n = length (f);
+  if (n > 3 && strcmp (f((end-2):end), ".cc"))
+    fid = fopen (f);
+    if (fid >= 0)
+      str = fread (fid, "*char")';
+      fclose (fid);
+      retval = ! isempty (regexp (str,'^(DEFUN|DEFUN_DLD)\b', 'lineanchors'));
+    else
+      error ("fopen failed: %s", f);
+    endif
+  elseif (n > 2 && strcmp (f((end-1):end), ".m"))
+    retval = true;
+  else
+    retval = false;
+  endif
+endfunction
+
+function retval = has_tests (f)
+  fid = fopen (f);
+  if (fid >= 0)
+    str = fread (fid, "*char")';
+    fclose (fid);
+    retval = ! isempty (regexp (str, '^%!(assert|error|fail|test|warning)', "lineanchors"));
+  else
+    error ("fopen failed: %s", f);
+  endif
+endfunction
+
+function retval = has_demos (f)
+  fid = fopen (f);
+  if (fid >= 0)
+    str = fread (fid, "*char")';
+    fclose (fid);
+    retval = ! isempty (regexp (str, '^%!demo', "lineanchors"));
+  else
+    error ("fopen failed: %s", f);
+  endif
+endfunction
+
+function [dp, dn, dxf, dsk] = run_test_dir (fid, d);
+  global files_with_tests;
+  global files_with_no_tests;
+  lst = dir (d);
+  dp = dn = dxf = dsk = 0;
+  for i = 1:length (lst)
+    nm = lst(i).name;
+    if (lst(i).isdir
+        && ! strcmp (nm, ".") && ! strcmp (nm, "..")
+        && ! strcmp (nm, "private") && nm(1) != "@"
+        && ! strcmp (nm, "CVS"))
+      [p, n, xf, sk] = run_test_dir (fid, [d, filesep, nm]);
+      dp += p;
+      dn += n;
+      dxf += xf;
+      dsk += sk;
+    endif
+  endfor
+  saved_dir = pwd ();
+  unwind_protect
+    chdir (d);
+    for i = 1:length (lst)
+      nm = lst(i).name;
+      if (length (nm) > 4 && strcmp (nm((end-3):end), ".tst"))
+        p = n = xf = sk = 0;
+        ffnm = fullfile (d, nm);
+        if (has_tests (ffnm))
+          print_test_file_name (nm);
+          [p, n, xf, sk] = test (nm, "quiet", fid);
+          print_pass_fail (n, p);
+          files_with_tests(end+1) = ffnm;
+        ##elseif (has_demos (ffnm))
+        ##  files_with_tests(end+1) = ffnm;
+        else
+          files_with_no_tests(end+1) = ffnm;
+        endif
+        dp += p;
+        dn += n;
+        dxf += xf;
+        dsk += sk;
+      endif
+    endfor
+  unwind_protect_cleanup
+    chdir (saved_dir);
+  end_unwind_protect
+endfunction
+
+function [dp, dn, dxf, dsk] = run_test_script (fid, d);
+  global files_with_tests;
+  global files_with_no_tests;
+  global topsrcdir;
+  global topbuilddir;
+  lst = dir (d);
+  dp = dn = dxf = dsk = 0;
+  for i = 1:length (lst)
+    nm = lst(i).name;
+    if (lst(i).isdir && ! strcmp (nm, ".") && ! strcmp (nm, "..")
+        && ! strcmp (nm, "CVS"))
+      [p, n, xf, sk] = run_test_script (fid, [d, filesep, nm]);
+      dp += p;
+      dn += n;
+      dxf += xf;
+      dsk += sk;
+    endif
+  endfor
+  for i = 1:length (lst)
+    nm = lst(i).name;
+    ## Ignore hidden files
+    if (nm(1) == '.')
+      continue
+    endif
+    f = fullfile (d, nm);
+    if ((length (nm) > 2 && strcmp (nm((end-1):end), ".m"))
+        || (length (nm) > 4
+            && (strcmp (nm((end-3):end), "-tst")
+                || strcmp (nm((end-3):end), ".tst"))))
+      p = n = xf = 0;
+      ## Only run if it contains %!test, %!assert %!error or %!warning
+      if (has_tests (f))
+        tmp = strrep (f, [topsrcdir, filesep], "");
+        tmp = strrep (tmp, [topbuilddir, filesep], "");
+        print_test_file_name (tmp);
+        [p, n, xf, sk] = test (f, "quiet", fid);
+        print_pass_fail (n, p);
+        dp += p;
+        dn += n;
+        dxf += xf;
+        dsk += sk;
+        files_with_tests(end+1) = f;
+      ##elseif (has_demos (f))
+      ##  files_with_tests(end+1) = f;
+      else
+        ## To reduce the list length, only mark .cc files that contain
+        ## DEFUN definitions.
+        files_with_no_tests(end+1) = f;
+      endif
+    endif
+  endfor 
+  ##  printf("%s%s -> passes %d of %d tests\n", ident, d, dp, dn);
+endfunction
+
+function n = num_elts_matching_pattern (lst, pat)
+  n = sum (cellfun (@(x) !isempty (x), regexp (lst, pat, 'once')));
+endfunction
+
+function report_files_with_no_tests (with, without, typ)
+  pat = cstrcat ('\', typ, "$");
+  n_with = num_elts_matching_pattern (with, pat);
+  n_without = num_elts_matching_pattern (without, pat);
+  n_tot = n_with + n_without;
+  printf ("\n%d (of %d) %s files have no tests.\n", n_without, n_tot, typ);
+endfunction
diff --git a/scripts/testfun/module.mk b/scripts/testfun/module.mk
--- a/scripts/testfun/module.mk
+++ b/scripts/testfun/module.mk
@@ -1,11 +1,14 @@
 FCN_FILE_DIRS += testfun
 
 testfun_FCN_FILES = \
+  testfun/__printf_assert__.m \
+  testfun/__prog_output_assert__.m \
+  testfun/__run_test_suite__.m \
   testfun/assert.m \
   testfun/demo.m \
   testfun/example.m \
   testfun/fail.m \
   testfun/rundemos.m \
   testfun/runtests.m \
   testfun/speed.m \
   testfun/test.m
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -766,26 +766,26 @@ endfunction
 
 %!warning <warning message> warning ('warning message');
 
 %!## test of shared variables
 %!shared a                # create a shared variable
 %!test   a=3;             # assign to a shared variable
 %!test   assert (a,3)     # variable should equal 3
 %!shared b,c              # replace shared variables
-%!test assert (!exist ("a"));  # a no longer exists
+%!test assert (!exist ("a", "var"));  # a no longer exists
 %!test assert (isempty (b));   # variables start off empty
 %!shared a,b,c            # recreate a shared variable
 %!test assert (isempty (a));   # value is empty even if it had a previous value
 %!test a=1; b=2; c=3;   # give values to all variables
 %!test assert ([a,b,c],[1,2,3]); # test all of them together
 %!test c=6;             # update a value
 %!test assert ([a, b, c],[1, 2, 6]); # show that the update sticks
 %!shared                     # clear all shared variables
-%!test assert (!exist ("a")) # show that they are cleared
+%!test assert (!exist ("a", "var")) # show that they are cleared
 %!shared a,b,c               # support for initializer shorthand
 %! a=1; b=2; c=4;
 
 %!function x = __test_a (y)
 %! x = 2*y;
 %!endfunction
 %!assert (__test_a (2),4);       # Test a test function
 
@@ -830,16 +830,16 @@ endfunction
 % !test   syntax errors)     # syntax errors fail properly
 % !shared garbage in         # variables must be comma separated
 % !error  syntax++error      # error test fails on syntax errors
 % !error  "succeeds.";       # error test fails if code succeeds
 % !error <wrong pattern> error("message")  # error pattern must match
 % !demo   with syntax error  # syntax errors in demo fail properly
 % !shared a,b,c
 % !demo                      # shared variables not available in demo
-% ! assert(exist("a"))
+% ! assert(exist("a", "var"))
 % !error
 % ! test('/etc/passwd');
 % ! test("nonexistent file");
 % ! ## These don't signal an error, so the test for an error fails. Note
 % ! ## that the call doesn't reference the current fid (it is unavailable),
 % ! ## so of course the informational message is not printed in the log.
 
diff --git a/src/mkoctfile.in.cc b/src/mkoctfile.in.cc
--- a/src/mkoctfile.in.cc
+++ b/src/mkoctfile.in.cc
@@ -209,16 +209,19 @@ initialize (void)
   vars["CFLAGS"] = get_variable ("CFLAGS", %OCTAVE_CONF_CFLAGS%);
   vars["CPICFLAG"] = get_variable ("CPICFLAG", %OCTAVE_CONF_CPICFLAG%);
   vars["CXX"] = get_variable ("CXX", %OCTAVE_CONF_MKOCTFILE_CXX%);
   vars["CXXFLAGS"] = get_variable ("CXXFLAGS", %OCTAVE_CONF_CXXFLAGS%);
   vars["CXXPICFLAG"] = get_variable ("CXXPICFLAG", %OCTAVE_CONF_CXXPICFLAG%);
   vars["XTRA_CFLAGS"] = get_variable ("XTRA_CFLAGS", %OCTAVE_CONF_XTRA_CFLAGS%);
   vars["XTRA_CXXFLAGS"] = get_variable ("XTRA_CXXFLAGS", %OCTAVE_CONF_XTRA_CXXFLAGS%);
 
+  vars["AR"] = get_variable ("AR", %OCTAVE_CONF_MKOCTFILE_AR%);
+  vars["RANLIB"] = get_variable ("RANLIB", %OCTAVE_CONF_MKOCTFILE_RANLIB%);
+
   vars["DEPEND_FLAGS"] = get_variable ("DEPEND_FLAGS", %OCTAVE_CONF_DEPEND_FLAGS%);
   vars["DEPEND_EXTRA_SED_PATTERN"] = get_variable ("DEPEND_EXTRA_SED_PATTERN", %OCTAVE_CONF_DEPEND_EXTRA_SED_PATTERN%);
 
   vars["DL_LD"] = get_variable ("DL_LD", %OCTAVE_CONF_MKOCTFILE_DL_LD%);
   vars["DL_LDFLAGS"] = get_variable ("DL_LDFLAGS", %OCTAVE_CONF_MKOCTFILE_DL_LDFLAGS%);
 
   vars["RDYNAMIC_FLAG"] = get_variable ("RDYNAMIC_FLAG", %OCTAVE_CONF_RDYNAMIC_FLAG%);
   vars["LIBOCTAVE"] = "-loctave";
@@ -294,40 +297,39 @@ static string help_msg =
 "                          (or .mex if --mex is specified) unless linking\n"
 "                          a stand-alone executable.\n"
 "\n"
 "  -g                      Enable debugging options for compilers.\n"
 "\n"
 "  -p VAR, --print VAR     Print configuration variable VAR.  Recognized\n"
 "                          variables are:\n"
 "\n"
-"                            ALL_CFLAGS                FLIBS\n"
-"                            ALL_CXXFLAGS              FPICFLAG\n"
-"                            ALL_FFLAGS                INCFLAGS\n"
-"                            ALL_LDFLAGS               LAPACK_LIBS\n"
-"                            BLAS_LIBS                 LDFLAGS\n"
-"                            CC                        LD_CXX\n"
-"                            CFLAGS                    LD_STATIC_FLAG\n"
-"                            CPICFLAG                  LFLAGS\n"
-"                            CPPFLAGS                  LIBOCTAVE\n"       
-"                            CXX                       LIBOCTINTERP\n"    
-"                            CXXFLAGS                  LIBS\n"            
-"                            CXXPICFLAG                OCTAVE_LIBS\n"     
-"                            DEPEND_EXTRA_SED_PATTERN  OCTAVE_LINK_DEPS\n"
-"                            DEPEND_FLAGS              OCTAVE_LINK_OPTS\n"
-"                            DL_LD                     OCT_LINK_DEPS\n"   
-"                            DL_LDFLAGS                OCT_LINK_OPTS\n"   
-"                            EXEEXT                    RDYNAMIC_FLAG\n"   
-"                            F77                       READLINE_LIBS\n"   
-"                            F77_INTEGER_8_FLAG        SED\n"             
-"                            FFLAGS                    XTRA_CFLAGS\n"     
-"                            FFTW3_LDFLAGS             XTRA_CXXFLAGS\n"   
-"                            FFTW3_LIBS\n"      
-"                            FFTW3F_LDFLAGS\n"
-"                            FFTW3F_LIBS\n"
+"                            ALL_CFLAGS                FFTW3F_LDFLAGS\n"
+"                            ALL_CXXFLAGS              FFTW3F_LIBS\n"
+"                            ALL_FFLAGS                FLIBS\n"
+"                            ALL_LDFLAGS               FPICFLAG\n"
+"                            AR                        INCFLAGS\n"
+"                            BLAS_LIBS                 LAPACK_LIBS\n"
+"                            CC                        LDFLAGS\n"
+"                            CFLAGS                    LD_CXX\n"
+"                            CPICFLAG                  LD_STATIC_FLAG\n"
+"                            CPPFLAGS                  LFLAGS\n"
+"                            CXX                       LIBOCTAVE\n"
+"                            CXXFLAGS                  LIBOCTINTERP\n"
+"                            CXXPICFLAG                LIBS\n"
+"                            DEPEND_EXTRA_SED_PATTERN  OCTAVE_LIBS\n"
+"                            DEPEND_FLAGS              OCTAVE_LINK_DEPS\n"
+"                            DL_LD                     OCT_LINK_DEPS\n"
+"                            DL_LDFLAGS                RANLIB\n"
+"                            EXEEXT                    RDYNAMIC_FLAG\n"
+"                            F77                       READLINE_LIBS\n"
+"                            F77_INTEGER_8_FLAG        SED\n"
+"                            FFLAGS                    XTRA_CFLAGS\n"
+"                            FFTW3_LDFLAGS             XTRA_CXXFLAGS\n"
+"                            FFTW3_LIBS\n"
 "\n"
 "  --link-stand-alone      Link a stand-alone executable file.\n"
 "\n"
 "  --mex                   Assume we are creating a MEX file.  Set the\n"
 "                          default output extension to \".mex\".\n"
 "\n"
 "  -s, --strip             Strip output file.\n"
 "\n"
diff --git a/src/mkoctfile.in.sh b/src/mkoctfile.in.sh
--- a/src/mkoctfile.in.sh
+++ b/src/mkoctfile.in.sh
@@ -74,16 +74,19 @@ fi
 : ${CFLAGS=%OCTAVE_CONF_CFLAGS%}
 : ${CPICFLAG=%OCTAVE_CONF_CPICFLAG%}
 : ${CXX=%OCTAVE_CONF_MKOCTFILE_CXX%}
 : ${CXXFLAGS=%OCTAVE_CONF_CXXFLAGS%}
 : ${CXXPICFLAG=%OCTAVE_CONF_CXXPICFLAG%}
 : ${XTRA_CFLAGS=%OCTAVE_CONF_XTRA_CFLAGS%}
 : ${XTRA_CXXFLAGS=%OCTAVE_CONF_XTRA_CXXFLAGS%}
 
+: ${AR=%OCTAVE_CONF_MKOCTFILE_AR%}
+: ${RANLIB=%OCTAVE_CONF_MKOCTFILE_RANLIB%}
+
 : ${DEPEND_FLAGS=%OCTAVE_CONF_DEPEND_FLAGS%}
 : ${DEPEND_EXTRA_SED_PATTERN=%OCTAVE_CONF_DEPEND_EXTRA_SED_PATTERN%}
 
 : ${DL_LD=%OCTAVE_CONF_MKOCTFILE_DL_LD%}
 : ${DL_LDFLAGS=%OCTAVE_CONF_MKOCTFILE_DL_LDFLAGS%}
 
 : ${RDYNAMIC_FLAG=%OCTAVE_CONF_RDYNAMIC_FLAG%}
 : ${LIBOCTAVE=-loctave}
@@ -228,39 +231,40 @@ Options:
 
   -o FILE, --output FILE  Output file name.  Default extension is .oct
                           (or .mex if --mex is specified) unless linking
                           a stand-alone executable.
 
   -p VAR, --print VAR     Print configuration variable VAR.  Recognized
                           variables are:
 
-                            ALL_CFLAGS                FFTW3F_LIBS
-                            ALL_CXXFLAGS              FLIBS
-                            ALL_FFLAGS                FPICFLAG
-                            ALL_LDFLAGS               INCFLAGS
+                            ALL_CFLAGS                FFTW3F_LDFLAGS
+                            ALL_CXXFLAGS              FFTW3F_LIBS
+                            ALL_FFLAGS                FLIBS
+                            ALL_LDFLAGS               FPICFLAG
+                            AR                        INCFLAGS
                             BLAS_LIBS                 LAPACK_LIBS
                             CC                        LDFLAGS
                             CFLAGS                    LD_CXX
                             CPICFLAG                  LD_STATIC_FLAG
                             CPPFLAGS                  LFLAGS
-                            CXX                       LIBOCTAVE       
-                            CXXFLAGS                  LIBOCTINTERP    
-                            CXXPICFLAG                LIBS            
-                            DEPEND_EXTRA_SED_PATTERN  OCTAVE_LIBS     
+                            CXX                       LIBOCTAVE
+                            CXXFLAGS                  LIBOCTINTERP
+                            CXXPICFLAG                LIBS
+                            DEPEND_EXTRA_SED_PATTERN  OCTAVE_LIBS
                             DEPEND_FLAGS              OCTAVE_LINK_DEPS
-                            DL_LD                     OCT_LINK_DEPS   
-                            DL_LDFLAGS                RDYNAMIC_FLAG   
-                            EXEEXT                    READLINE_LIBS   
-                            F77                       SED             
-                            F77_INTEGER_8_FLAG        XTRA_CFLAGS     
-                            FFLAGS                    XTRA_CXXFLAGS   
-                            FFTW3_LDFLAGS             
+                            DL_LD                     OCT_LINK_DEPS
+                            DL_LDFLAGS                RANLIB
+                            EXEEXT                    RDYNAMIC_FLAG
+                            F77                       READLINE_LIBS
+                            F77_INTEGER_8_FLAG        SED
+                            FFLAGS                    XTRA_CFLAGS
+                            FFTW3_LDFLAGS             XTRA_CXXFLAGS
                             FFTW3_LIBS
-                            FFTW3F_LDFLAGS
+                          
 
   -v, --verbose           Echo commands as they are executed.
 
   FILE                    Compile or link FILE.  Recognized file types are:
 
                             .c    C source
                             .cc   C++ source
                             .C    C++ source
diff --git a/test/Makefile.am b/test/Makefile.am
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -17,72 +17,88 @@
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
 FCN_FILES = \
   fntests.m \
-  test_args.m \
-  test_bug_31371.m \
-  test_diag_perm.m \
-  test_error.m \
-  test_eval-catch.m \
-  test_for.m \
-  test_func.m \
-  test_global.m \
-  test_if.m \
-  test_index.m \
-  test_io.m \
-  test_line_continue.m \
-  test_logical_index.m \
-  test_null_assign.m \
-  test_parser.m \
-  test_prefer.m \
-  test_range.m \
-  test_recursion.m \
-  test_return.m \
-  test_slice.m \
-  test_struct.m \
-  test_switch.m \
-  test_system.m \
-  test_transpose.m \
-  test_try.m \
-  test_unwind.m \
-  test_while.m
+  args.tst \
+  bug-31371.tst \
+  diag-perm.tst \
+  error.tst \
+  eval-catch.tst \
+  for.tst \
+  func.tst \
+  global.tst \
+  if.tst \
+  index.tst \
+  io.tst \
+  line-continue.tst \
+  logical-index.tst \
+  null-assign.tst \
+  parser.tst \
+  prefer.tst \
+  range.tst \
+  recursion.tst \
+  return.tst \
+  slice.tst \
+  struct.tst \
+  switch.tst \
+  system.tst \
+  transpose.tst \
+  try.tst \
+  unwind.tst \
+  while.tst
 
 include bug-35448/module.mk
 include bug-36025/module.mk
+include bug-38236/module.mk
 include classdef/module.mk
 include classes/module.mk
 include class-concat/module.mk
 include ctor-vs-method/module.mk
 include fcn-handle-derived-resolution/module.mk
 include nest/module.mk
 
-check: test_sparse.m test_bc_overloads.m
+check: sparse.tst bc-overload-tests.stamp
 	$(top_builddir)/run-octave --norc --silent --no-history $(srcdir)/fntests.m $(srcdir)
 
-test_sparse.m: build_sparse_tests.sh
-	$(srcdir)/build_sparse_tests.sh
+sparse.tst: build-sparse-tests.sh
+	$(srcdir)/build-sparse-tests.sh
+
+GENERATED_BC_OVERLOADS_DIRS := \
+  $(shell $(srcdir)/build-bc-overload-tests.sh --list-dirs)
 
-test_bc_overloads.m: build_bc_overload_tests.sh bc_overloads_expected
-	$(srcdir)/build_bc_overload_tests.sh $(srcdir)/bc_overloads_expected
+GENERATED_BC_OVERLOADS_FILES := \
+  $(shell $(srcdir)/build-bc-overload-tests.sh --list-files)
+
+bc-overload-tests.stamp: build-bc-overload-tests.sh bc-overloads-expected
+	$(srcdir)/build-bc-overload-tests.sh $(srcdir)/bc-overloads-expected
+	touch $@
+
+BUILT_SOURCES = bc-overload-tests.stamp
 
 EXTRA_DIST = \
-  build_sparse_tests.sh \
-  build_bc_overload_tests.sh \
-  bc_overloads_expected \
+  build-sparse-tests.sh \
+  build-bc-overload-tests.sh \
+  bc-overloads-expected \
   build_bc_overloads_expected.m \
   $(FCN_FILES)
 
 CLEANFILES = \
-  test_sparse.m \
-  test_bc_overloads.m \
-  tbcover.m
+  sparse.tst \
+  bc-overload-tests.stamp \
+  $(GENERATED_BC_OVERLOADS_FILES)
 
 DISTCLEANFILES = \
   fntests.log
-        
+
+fixedtestsdir := $(octtestsdir)/fixed
+
+nobase_fixedtests_DATA = \
+  sparse.tst \
+  $(GENERATED_BC_OVERLOADS_FILES) \
+  $(filter-out fntests.m, $(FCN_FILES))
+
 clean-local:
-	-rm -rf @double @logical @int8 @uint64 @int64 @cell @single @int32 \
-	@uint8 @uint16 @uint32 @struct @int16 @function_handle @char
+	-rm -rf $(GENERATED_BC_OVERLOADS_DIRS)
diff --git a/test/test_args.m b/test/args.tst
rename from test/test_args.m
rename to test/args.tst
diff --git a/test/bc_overloads_expected b/test/bc-overloads-expected
rename from test/bc_overloads_expected
rename to test/bc-overloads-expected
diff --git a/test/test_bug_31371.m b/test/bug-31371.tst
rename from test/test_bug_31371.m
rename to test/bug-31371.tst
diff --git a/test/bug-35448/test_bug_35448.m b/test/bug-35448/bug-35448.tst
rename from test/bug-35448/test_bug_35448.m
rename to test/bug-35448/bug-35448.tst
diff --git a/test/bug-35448/module.mk b/test/bug-35448/module.mk
--- a/test/bug-35448/module.mk
+++ b/test/bug-35448/module.mk
@@ -1,7 +1,7 @@
 bug_35448_FCN_FILES = \
   bug-35448/fA.m \
   bug-35448/fB.m \
   bug-35448/fC.m \
-  bug-35448/test_bug_35448.m
+  bug-35448/bug-35448.tst
 
 FCN_FILES += $(bug_35448_FCN_FILES)
diff --git a/test/bug-36025/test_bug_36025.m b/test/bug-36025/bug-36025.tst
rename from test/bug-36025/test_bug_36025.m
rename to test/bug-36025/bug-36025.tst
diff --git a/test/bug-36025/module.mk b/test/bug-36025/module.mk
--- a/test/bug-36025/module.mk
+++ b/test/bug-36025/module.mk
@@ -1,7 +1,7 @@
 bug_36025_FCN_FILES = \
   bug-36025/@testclass/one.m \
   bug-36025/@testclass/testclass.m \
   bug-36025/@testclass/two.m \
-  bug-36025/test_bug_36025.m
+  bug-36025/bug-36025.tst
 
 FCN_FILES += $(bug_36025_FCN_FILES)
diff --git a/test/bug-38236/bug-38236.tst b/test/bug-38236/bug-38236.tst
new file mode 100644
--- /dev/null
+++ b/test/bug-38236/bug-38236.tst
@@ -0,0 +1,3 @@
+%!test
+%! u_vr
+
diff --git a/test/bug-38236/df_vr.m b/test/bug-38236/df_vr.m
new file mode 100644
--- /dev/null
+++ b/test/bug-38236/df_vr.m
@@ -0,0 +1,2 @@
+# df_vr.m
+vr = 7;
diff --git a/test/bug-38236/module.mk b/test/bug-38236/module.mk
new file mode 100644
--- /dev/null
+++ b/test/bug-38236/module.mk
@@ -0,0 +1,6 @@
+bug_38236_FCN_FILES = \
+  bug-38236/df_vr.m \
+  bug-38236/u_vr.m \
+  bug-38236/bug-38236.tst
+
+FCN_FILES += $(bug_38236_FCN_FILES)
diff --git a/test/bug-38236/u_vr.m b/test/bug-38236/u_vr.m
new file mode 100644
--- /dev/null
+++ b/test/bug-38236/u_vr.m
@@ -0,0 +1,17 @@
+# u_vr.m
+
+cmd = "\
+function __demo__ () \
+  df_vr; \
+  v = vr * 2; \
+endfunction \
+";
+
+for ii = 1:2
+  unwind_protect
+    eval (cmd);
+    __demo__;
+  unwind_protect_cleanup
+    clear __demo__
+  end_unwind_protect
+endfor
\ No newline at end of file
diff --git a/test/build_bc_overload_tests.sh b/test/build-bc-overload-tests.sh
rename from test/build_bc_overload_tests.sh
rename to test/build-bc-overload-tests.sh
--- a/test/build_bc_overload_tests.sh
+++ b/test/build-bc-overload-tests.sh
@@ -32,17 +32,39 @@ CLASSES="
   uint32
   uint64
   struct
   cell
   function_handle
 "
 
 if [ $# -eq 1 ]; then
-  expected_results_file="$1"
+  case "$1" in
+    --list-files)
+      echo tbcover.m
+      echo bc-overloads.tst
+      for class in $CLASSES; do
+        echo @$class/tbcover.m
+      done
+      exit
+    ;;
+    --list-dirs)
+      for class in $CLASSES; do
+        echo @$class
+      done
+      exit
+    ;;
+    --list-classes)
+      echo $CLASSES
+      exit
+    ;;
+    *)
+      expected_results_file="$1"
+    ;;
+  esac
 else
   echo "usage: build_bc_overload_tests.sh expected-results-file" 1>&2
   exit 1
 fi
 
 for class in $CLASSES; do
   DIR="@$class"
   test -d $DIR || mkdir $DIR || { echo "error: could not create $DIR"; exit; }
@@ -60,17 +82,17 @@ cat > tbcover.m << EOF
 function s = tbcover (x, y)
   s = 'none';
 EOF
 
 if test "$1" = "overloads_only" ; then
   exit
 fi
 
-cat > test_bc_overloads.m << EOF
+cat > bc-overloads.tst << EOF
 ## !!! DO NOT EDIT !!!
 ## THIS IS AN AUTOMATICALLY GENERATED FILE
 ## modify build_bc_overload_tests.sh to generate the tests you need.
 
 %!shared ex
 %! ex.double = 1;
 %! ex.single = single(1);
 %! ex.logical = true;
@@ -86,26 +108,26 @@ cat > test_bc_overloads.m << EOF
 %! ex.cell = {};
 %! ex.struct = struct ();
 %! ex.function_handle = @numel;
 
 EOF
 
 cat $expected_results_file | \
 while read cl1 cl2 clr ; do
-  cat >> test_bc_overloads.m << EOF
+  cat >> bc-overloads.tst << EOF
 %% Name call
 %!assert (tbcover (ex.$cl1, ex.$cl2), "$clr")
 %% Handle call
 %!assert ((@tbcover) (ex.$cl1, ex.$cl2), "$clr")
 
 EOF
 done
 
-cat >> test_bc_overloads.m << EOF
+cat >> bc-overloads.tst << EOF
 %%test handles through cellfun
 %!test
 %! f = fieldnames (ex);
 %! n = numel (f);
 %! s = c1 = c2 = cell (n);
 %! for i = 1:n
 %!   for j = 1:n
 %!     c1{i,j} = ex.(f{i});
diff --git a/test/build_sparse_tests.sh b/test/build-sparse-tests.sh
rename from test/build_sparse_tests.sh
rename to test/build-sparse-tests.sh
--- a/test/build_sparse_tests.sh
+++ b/test/build-sparse-tests.sh
@@ -17,22 +17,22 @@
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 # Some tests are commented out because they are known to be broken!
 # Search for "# fails"   
 
 # ./build_sparse_tests.sh preset
-#    creates test_sparse.m with preset tests.
-#    Use "test test_sparse" from octave to run the tests.
+#    creates sparse.tst with preset tests.
+#    Use "test sparse.tst" from octave to run the tests.
 #
 # ./build_sparse_tests.sh random
-#    Creates test_sprandom.m with randomly generated matrices.
-#    Use "test test_sprandom" from octave to run the tests.
+#    Creates sprandom.tst with randomly generated matrices.
+#    Use "test sprandom.tst" from octave to run the tests.
 
 # build_sparse_tests.sh generates tests for real and complex sparse matrices.
 # Also, we want to run both fixed tests with known outputs (quick tests)
 # and longer tests with unknown outputs (thorough tests).  This requires
 # two sets of tests -- one which uses preset matrices and another which
 # uses randomly generated matrices.
 #
 # The tests are mostly identical for each case but the code is different,
@@ -109,19 +109,19 @@
 case $1 in
     random) preset=false ;;
     preset) preset=true ;;
     '') preset=true ;;
     *) echo "build_sparse_tests.sh random|preset" && exit 1 ;;
 esac
 
 if $preset; then
-    TESTS=test_sparse.m
+    TESTS=sparse.tst
 else
-    TESTS=test_sprandom.m
+    TESTS=sprandom.tst
 fi
 
 # create initial file
 cat >$TESTS <<EOF
 ## !!! DO NOT EDIT !!!
 ## THIS IS AN AUTOMATICALLY GENERATED FILE
 ## modify build_sparse_tests.sh to generate the tests you need.
 EOF
@@ -233,17 +233,17 @@ gen_function() {
     if $preset; then
 	cat >>$TESTS <<EOF
 ##
 ## test_sparse
 ##
 ##    run preset sparse tests.  All should pass.
 function [passes, tests] = test_sparse
   disp ("writing test output to sptest.log");
-  test ("test_sparse", "normal", "sptest.log");
+  test ("sparse.tst", "normal", "sptest.log");
 endfunction
 
 EOF
     else
 	cat >>$TESTS <<EOF
 ##
 ## test_sprandom
 ##
@@ -253,17 +253,17 @@ EOF
 ##    total_passes += passes;
 ##    total_tests += tests;
 ##  end
 ##  The test log is appended to sprandomtest.log
 function [passes,total] = test_sprandom
   warning ("untested --- fix the source in build_sparse_tests.sh");
   disp ("appending test output to sprandomtest.log");
   fid = fopen ("sprandomtest.log", "at");
-  test ("test_sprandom", "normal", fid);
+  test ("sprandom.tst", "normal", fid);
   ##[passes, total] = test("sprandomtest","normal",fid);
   fclose (fid);
 endfunction
 
 EOF
     fi
     
 }
diff --git a/test/class-concat/test_class_concat.m b/test/class-concat/class-concat.tst
rename from test/class-concat/test_class_concat.m
rename to test/class-concat/class-concat.tst
diff --git a/test/class-concat/module.mk b/test/class-concat/module.mk
--- a/test/class-concat/module.mk
+++ b/test/class-concat/module.mk
@@ -1,5 +1,5 @@
 class_concat_FCN_FILES = \
   class-concat/@foo/foo.m \
-  class-concat/test_class_concat.m
+  class-concat/class-concat.tst
 
 FCN_FILES += $(class_concat_FCN_FILES)
diff --git a/test/classdef/test_classdef.m b/test/classdef/classdef.tst
rename from test/classdef/test_classdef.m
rename to test/classdef/classdef.tst
diff --git a/test/classdef/module.mk b/test/classdef/module.mk
--- a/test/classdef/module.mk
+++ b/test/classdef/module.mk
@@ -1,7 +1,7 @@
 classdef_FCN_FILES = \
   classdef/foo_method_changes_property_size.m \
   classdef/foo_static_method_constant_property.m \
   classdef/foo_value_class.m \
-  classdef/test_classdef.m
+  classdef/classdef.tst
 
 FCN_FILES += $(classdef_FCN_FILES)
diff --git a/test/classes/@Snork/double.m b/test/classes/@Snork/double.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@Snork/double.m
@@ -0,0 +1,6 @@
+function x = double(snk)
+
+  x = snk.gick;
+
+end
+
diff --git a/test/classes/@Snork/eq.m b/test/classes/@Snork/eq.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@Snork/eq.m
@@ -0,0 +1,8 @@
+function b = eq(s1, s2)
+
+  x1 = double(s1);
+  x2 = double(s2);
+
+  b = isequal(x1, x2);
+
+end
\ No newline at end of file
diff --git a/test/classes/@Snork/ge.m b/test/classes/@Snork/ge.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@Snork/ge.m
@@ -0,0 +1,8 @@
+function b = ge(s1, s2)
+
+  x1 = double(s1);
+  x2 = double(s2);
+
+  b = (x1(1) >= x2(1));
+
+end
diff --git a/test/classes/@Snork/gt.m b/test/classes/@Snork/gt.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@Snork/gt.m
@@ -0,0 +1,8 @@
+function b = gt(s1, s2)
+
+  x1 = double(s1);
+  x2 = double(s2);
+
+  b = (x1(1) > x2(1));
+
+end
diff --git a/test/classes/@Snork/horzcat.m b/test/classes/@Snork/horzcat.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@Snork/horzcat.m
@@ -0,0 +1,8 @@
+function s = horzcat(s1, s2)
+
+  x1 = double(s1);
+  x2 = double(s2);
+
+  s = Snork([x1 x2]);
+
+end
diff --git a/test/classes/@Snork/ldivide.m b/test/classes/@Snork/ldivide.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@Snork/ldivide.m
@@ -0,0 +1,8 @@
+function s = ldivide(s1, s2)
+
+  x1 = double(s1);
+  x2 = double(s2);
+
+  s = Snork(x1 .\ x2);
+
+end
diff --git a/test/classes/@Snork/le.m b/test/classes/@Snork/le.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@Snork/le.m
@@ -0,0 +1,8 @@
+function b = le(s1, s2)
+
+  x1 = double(s1);
+  x2 = double(s2);
+
+  b = (x1(1) <= x2(1));
+
+end
diff --git a/test/classes/@Snork/lt.m b/test/classes/@Snork/lt.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@Snork/lt.m
@@ -0,0 +1,8 @@
+function b = lt(s1, s2)
+
+  x1 = double(s1);
+  x2 = double(s2);
+
+  b = (x1(1) < x2(1));
+
+end
diff --git a/test/classes/@Snork/minus.m b/test/classes/@Snork/minus.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@Snork/minus.m
@@ -0,0 +1,8 @@
+function s = minus(s1, s2)
+
+  x1 = double(s1);
+  x2 = double(s2);
+
+  s = Snork(x1 - x2);
+
+end
diff --git a/test/classes/@Snork/mldivide.m b/test/classes/@Snork/mldivide.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@Snork/mldivide.m
@@ -0,0 +1,8 @@
+function s = mldivide(s1, s2)
+
+  x1 = double(s1);
+  x2 = double(s2);
+
+  s = Snork(x1 \ x2);
+
+end
diff --git a/test/classes/@Snork/mpower.m b/test/classes/@Snork/mpower.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@Snork/mpower.m
@@ -0,0 +1,10 @@
+function s = mpower(s1, x)
+
+  if ~isa(s1, 'Snork') || isa(x, 'Snork')
+    error('mpower Snork!!!');
+  end
+
+  s = s1;
+  s.gick = s.gick ^ x;
+
+end
diff --git a/test/classes/@Snork/mrdivide.m b/test/classes/@Snork/mrdivide.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@Snork/mrdivide.m
@@ -0,0 +1,8 @@
+function s = mrdivide(s1, s2)
+
+  x1 = double(s1);
+  x2 = double(s2);
+
+  s = Snork(x1 / x2);
+
+end
diff --git a/test/classes/@Snork/mtimes.m b/test/classes/@Snork/mtimes.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@Snork/mtimes.m
@@ -0,0 +1,8 @@
+function s = mtimes(s1, s2)
+
+  x1 = double(s1);
+  x2 = double(s2);
+
+  s = Snork(x1 * x2);
+
+end
diff --git a/test/classes/@Snork/ne.m b/test/classes/@Snork/ne.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@Snork/ne.m
@@ -0,0 +1,5 @@
+function b = ne(s1, s2)
+
+  b = ~(s1 == s2);
+
+end
diff --git a/test/classes/@Snork/plus.m b/test/classes/@Snork/plus.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@Snork/plus.m
@@ -0,0 +1,8 @@
+function s = plus(s1, s2)
+
+  x1 = double(s1);
+  x2 = double(s2);
+
+  s = Snork(x1 + x2);
+
+end
\ No newline at end of file
diff --git a/test/classes/@Snork/power.m b/test/classes/@Snork/power.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@Snork/power.m
@@ -0,0 +1,10 @@
+function s = power(s1, x)
+
+  if ~isa(s1, 'Snork') || isa(x, 'Snork')
+    error('power Snork!!!');
+  end
+
+  s = s1;
+  s.gick = s.gick .^ x;
+
+end
diff --git a/test/classes/@Snork/rdivide.m b/test/classes/@Snork/rdivide.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@Snork/rdivide.m
@@ -0,0 +1,8 @@
+function s = rdivide(s1, s2)
+
+  x1 = double(s1);
+  x2 = double(s2);
+
+  s = Snork(x1 ./ x2);
+
+end
diff --git a/test/classes/@Snork/times.m b/test/classes/@Snork/times.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@Snork/times.m
@@ -0,0 +1,8 @@
+function s = times(s1, s2, s3)
+
+  x1 = double(s1);
+  x2 = double(s2);
+
+  s = Snork(x1 .* x2);
+
+end
diff --git a/test/classes/@Snork/uminus.m b/test/classes/@Snork/uminus.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@Snork/uminus.m
@@ -0,0 +1,6 @@
+function s = uminus(s1)
+
+  s = s1;
+  s.gick = - s.gick;
+
+end
\ No newline at end of file
diff --git a/test/classes/@Snork/uplus.m b/test/classes/@Snork/uplus.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@Snork/uplus.m
@@ -0,0 +1,5 @@
+function s = uplus(s1)
+
+  s = s1;
+
+end
diff --git a/test/classes/@Snork/vertcat.m b/test/classes/@Snork/vertcat.m
new file mode 100644
--- /dev/null
+++ b/test/classes/@Snork/vertcat.m
@@ -0,0 +1,8 @@
+function s = vertcat(s1, s2)
+
+  x1 = double(s1);
+  x2 = double(s2);
+
+  s = Snork([x1; x2]);
+
+end
diff --git a/test/classes/test_classes.m b/test/classes/classes.tst
rename from test/classes/test_classes.m
rename to test/classes/classes.tst
--- a/test/classes/test_classes.m
+++ b/test/classes/classes.tst
@@ -1,8 +1,9 @@
+## Copyright (C) 2013 Julien Bect
 ## Copyright (C) 2009-2012 Robert T. Short
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
@@ -11,191 +12,307 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-%%  Test script for legacy OOP.
-%%  Requires the path to contain the test classes.
+%% Test script for legacy OOP.
+%% Requires the path to contain the test classes.
 %%
-%%  Note: This script and all classes are also intended to run
-%%        in MATLAB to test compatibility.  Don't break that!
+%% Note: This script and all classes are also intended to run
+%%       in MATLAB to test compatibility.  Don't break that!
 %%
-%%  To Do:  This script tests to ensure that things done correctly work
-%%          corrrectly.  It should also check that things done incorrectly
-%%          error properly.
+%%       Note(JBect, 2013/01/27) : in order to ease to process of testing
+%%       Matlab compatibility, the syntax assert(observed, expected) should
+%%       be avoided. I use assert(isequal(observed, expected) instead.
 %%
-%%  The classes used for the tests reside in the test directory.
+%% To Do:  This script tests to ensure that things done correctly work
+%%         corrrectly.  It should also check that things done incorrectly
+%%         error properly.
+%%
+%% The classes used for the tests reside in the test directory.
 %%
-%%  The classes provide the ability to test most of the major features
-%%  of the legacy OOP facilities.  There are a number of classes, mostly
-%%  kind of the same, that create a hierarchy.
+%% The classes provide the ability to test most of the major features
+%% of the legacy OOP facilities.  There are a number of classes, mostly
+%% kind of the same, that create a hierarchy.
 
-%%  Test the Snork class.  The Snork class has a number of the standard
-%%  methods that the others don't so we can test indexing and other
-%%  features.
+%% Test the Snork class.  The Snork class has a number of the standard
+%% methods that the others don't so we can test indexing and other
+%% features.
 %!shared snk, snk1, snk2
 %!test snk = Snork();
-%!  assert(gick(snk),1)
-%!  assert(snk.gick,1)
-%!  assert(snk(2),1);
-%!  assert(snk{end},3);
-%!test snk = gick(snk,2);
-%!  assert(gick(snk),2)
-%!test snk = set(snk,'gick',7);
-%!  assert(get(snk, 'gick'), 7)
+%! assert (isequal (gick (snk), 1));
+%! assert (isequal (snk.gick, 1));
+%! assert (isequal (snk(2), 1));
+%! assert (isequal (snk{end}, 3));
+%!test snk = gick (snk, 2);
+%! assert (isequal (gick (snk), 2));
+%!test snk = set (snk, 'gick', 7);
+%! assert (isequal (get (snk, 'gick'), 7));
 %!test snk.gick = 4;
-%! assert(gick(snk),4)
-%!   snk(1) = 3;
+%! assert (isequal (gick (snk),4));
+%!  snk(1) = 3;
 %!test snk{end} = 9;
-%!  assert(cack(snk),[3 1 2 9])
-%!  assert(getStash(snk),1)             % Check private functions.
-%!  assert(isobject(snk))
-%!  assert(class(snk),'Snork')
-%!  assert(isa(snk,'Snork'))
-%!  assert(~isa(snk,'Sneetch'))
-%!  assert(ismethod(snk,'gick'))
-%!  assert(~ismethod(snk,'bletch'))
-%!  assert(exist('snk'))
-%!  assert(~exist('blink'))
+%! assert (isequal (cack (snk), [3 1 2 9]));
+%! assert (isequal (getStash (snk), 1));             % Check private functions.
+%! assert (isobject (snk));
+%! assert (isequal (class (snk), 'Snork'));
+%! assert (isa (snk, 'Snork'));
+%! assert (~isa (snk, 'Sneetch'));
+%! assert (ismethod (snk, 'gick'));
+%! assert (~ismethod (snk, 'bletch'));
+%! assert (exist ('snk') == 1);
+%! assert (exist ('blink') == 0);
 %!test snk1 = Snork(snk);
-%!  assert(class(snk1),'Snork')
-%!  assert(gick(snk1),4)
+%! assert (isequal (class (snk1), 'Snork'));
+%! assert (isequal (gick (snk1), 4));
 %!test snk2 = Snork(-3);
-%!  assert(class(snk2),'Snork')
-%!  assert(gick(snk2),-3)
-%!test x=[1 2 3 4];
-%!  assert(x(snk),1);
-%% x=methods('Snork');                   % Need to test the methods function.
+%! assert (isequal (class (snk2), 'Snork'));
+%! assert (isequal (gick (snk2), -3));
+%!test x = [1 2 3 4];
+%! assert (isequal (x(snk), 1));
+
+%% x = methods ('Snork');                % Need to test the methods function.
 %% save temp snk;
-%% load temp                             % This load causes a segment fault.
-%% assert(cack(snk),[-1 -2 -3 -4]);      % This is a major bug!
+%% load temp                             % This load causes a segfault.
+%% assert (isequal (cack(snk), [-1 -2 -3 -4]));      % This is a major bug!
 
 %% The Spork class is a near clone of Snork but without as many standard
 %% methods.  We are testing no new octave features, but this is makes
 %% sure that we haven't bollixed up the Spork class if we should make
 %% changes.  We use Spork in the class hierarchy.
 %!shared sprk
 %!test sprk = Spork();
-%!  assert(geek(sprk),1)
-%!test sprk = geek(sprk,3);
-%!  assert(geek(sprk),3)
-%!test sprk = set(sprk,'geek',7);
-%!  assert(get(sprk, 'geek'), 7)
-%!  assert(class(sprk),'Spork');
-%!  assert(isa(sprk,'Spork'))
+%! assert (isequal (geek (sprk), 1));
+%!test sprk = geek (sprk, 3);
+%! assert (isequal (geek (sprk), 3));
+%!test sprk = set (sprk,'geek',7);
+%! assert (isequal (get (sprk, 'geek'), 7));
+%! assert (isequal (class (sprk), 'Spork'));
+%! assert (isa (sprk, 'Spork'));
 
 %%  The Blork class is a near clone of Snork but without as many standard
 %%  methods.  We are testing no new octave features, but this is makes
 %%  sure that we haven't bollixed up the Blork class if we should make
 %%  changes.  We use Blork in the class hierarchy.
 %!shared blrk
 %!test blrk = Blork();
-%!  assert(bleek(blrk),1)
-%!test blrk = bleek(blrk,3);
-%!  assert(bleek(blrk),3)
-%!test blrk = set(blrk,'bleek',13);
-%!  assert(get(blrk, 'bleek'), 13)
-%!  assert(class(blrk),'Blork');
-%!  assert(isa(blrk,'Blork'))
+%! assert (isequal (bleek(blrk), 1));
+%!test blrk = bleek (blrk, 3);
+%! assert (isequal (bleek (blrk), 3));
+%!test blrk = set (blrk, 'bleek', 13);
+%! assert (isequal (get (blrk, 'bleek'), 13));
+%! assert (isequal (class (blrk), 'Blork'));
+%! assert (isa (blrk, 'Blork'));
 
 %%  The Cork class is a near clone of Snork but without as many standard
 %%  methods.  We are testing no new octave features, but this is makes
 %%  sure that we haven't bollixed up the Cork class if we should make
 %%  changes.  We use Cork in the class hierarchy.
 %!shared crk
 %!test crk = Cork(23);
-%!  assert(click(crk),23)
+%! assert (isequal (click(crk), 23));
 %!test crk = click(crk,3);
-%!  assert(click(crk),3)
-%!test crk = set(crk,'click',13);
-%!  assert(get(crk, 'click'), 13)
-%!  assert(class(crk),'Cork');
-%!  assert(isa(crk,'Cork'))
+%! assert (isequal (click(crk), 3));
+%!test crk = set (crk, 'click', 13);
+%! assert (isequal (get (crk, 'click'), 13));
+%! assert (isequal (class (crk), 'Cork'));
+%! assert (isa (crk, 'Cork'));
 
 %%  The Dork class tests single inheritance.
 %!shared drk
 %!test drk = Dork();
-%!  assert(gack(drk),0)
-%!test drk = gack(drk,-2);
-%!  assert(gack(drk),-2)
-%!test drk = gick(drk,2);
-%!  assert(gick(drk),2);
-%!test drk = set(drk, 'gick',3, 'gack',-3);
-%!  assert(get(drk, 'gick'), 3)
-%!  assert(get(drk, 'gack'), -3)
-%!  assert(class(drk),'Dork')
-%!  assert(isa(drk,'Dork'))
-%!  assert(isa(drk,'Snork'))
-%!  assert(getStash(drk),2)
+%! assert (isequal (gack (drk),0));
+%!test drk = gack (drk,-2);
+%! assert (isequal (gack (drk),-2));
+%!test drk = gick (drk,2);
+%! assert (isequal (gick (drk),2));
+%!test drk = set (drk, 'gick',3, 'gack',-3);
+%! assert (isequal (get (drk, 'gick'), 3));
+%! assert (isequal (get (drk, 'gack'), -3));
+%! assert (isequal (class (drk), 'Dork'));
+%! assert (isa (drk, 'Dork'));
+%! assert (isa (drk, 'Snork'));
+%! assert (isequal (getStash (drk), 2));
 %!test drk1 = Dork(drk);
-%!  assert(class(drk1),'Dork')
-%!  assert(isa(drk1,'Snork'))
-%!  assert(gick(drk1),3)
-%!  assert(gack(drk1),-3)
-%!test drk2 = Dork(-4,4);
-%!  assert(class(drk2),'Dork')
-%!  assert(isa(drk2,'Snork'))
-%!  assert(gick(drk2),-4)
-%!  assert(gack(drk2),4)
+%! assert (isequal (class (drk1), 'Dork'));
+%! assert (isa (drk1, 'Snork'));
+%! assert (isequal (gick (drk1), 3));
+%! assert (isequal (gack (drk1), -3));
+%!test drk2 = Dork(-4, 4);
+%! assert (isequal (class (drk2), 'Dork'));
+%! assert (isa (drk2, 'Snork'));
+%! assert (isequal (gick (drk2), -4));
+%! assert (isequal (gack (drk2), 4));
 
 %%  The Pork class is essentially a clone of Dork.  It is used as part
 %%  of the multiple inheritance test.
 %!shared prk, drk
 %!test prk = Pork();
-%!  assert(geek(prk),1)
-%!  assert(gurk(prk),0)
-%!test prk = gurk(prk,-3);
-%!  assert(gurk(prk),-3)
-%!test prk = geek(prk,9);
-%!  assert(geek(prk),9)
-%!  assert(class(prk),'Pork')
-%!  assert(isa(prk,'Pork'))
-%!  assert(isa(prk,'Spork'))
+%! assert (isequal (geek (prk), 1));
+%! assert (isequal (gurk (prk), 0));
+%!test prk = gurk (prk,-3);
+%! assert (isequal (gurk (prk), -3));
+%!test prk = geek (prk,9);
+%! assert (isequal (geek (prk), 9));
+%! assert (isequal (class (prk), 'Pork'));
+%! assert (isa (prk, 'Pork'));
+%! assert (isa (prk, 'Spork'));
 %!test drk = Dork();                   % Precedence.
-%!  assert(bling(drk,prk),2)
-%!  assert(bling(prk,drk),2)
-  
+%! assert (isequal (bling (drk, prk), 2));
+%! assert (isequal (bling (prk, drk), 2));
+
 %%  The Gork class tests aggregation and multiple inheritance.
 %!shared grk
 %!test grk = Gork();
-%!  assert(gick(grk),1)
-%!  assert(geek(grk),1)
-%!  assert(gack(grk),0)
-%!  assert(gurk(grk),0)
-%!  assert(bleek(grk),1)
-%!  assert(gark(grk),-2)
-%!  assert(click(cork(grk)),17)
-%!  assert(class(cork(grk)),'Cork')
-%!test grk = gick(grk,3);
-%!test grk = geek(grk,4);
-%!test grk = gack(grk,-9);
-%!test grk = gurk(grk,-8);
-%!test grk = bleek(grk,-7);
-%!test grk = gark(grk,-6);
-%!test grk = cork(grk,click(cork(grk),23));
-%!  assert(gick(grk),3)
-%!  assert(geek(grk),4)
-%!  assert(gack(grk),-9)
-%!  assert(gurk(grk),-8)
-%!  assert(bleek(grk),-7)
-%!  assert(gark(grk),-6)
-%!  assert(click(cork(grk)),23)
+%! assert (isequal (gick (grk), 1));
+%! assert (isequal (geek (grk), 1));
+%! assert (isequal (gack (grk), 0));
+%! assert (isequal (gurk (grk), 0));
+%! assert (isequal (bleek (grk), 1));
+%! assert (isequal (gark(grk), -2));
+%! assert (isequal (click (cork (grk)), 17));
+%! assert (isequal (class (cork (grk)), 'Cork'));
+%!test grk = gick (grk, 3);
+%!test grk = geek (grk, 4);
+%!test grk = gack (grk, -9);
+%!test grk = gurk (grk, -8);
+%!test grk = bleek (grk, -7);
+%!test grk = gark (grk, -6);
+%!test grk = cork (grk, click (cork (grk), 23));
+%! assert (isequal (gick (grk), 3));
+%! assert (isequal (geek (grk), 4));
+%! assert (isequal (gack (grk), -9));
+%! assert (isequal (gurk (grk), -8));
+%! assert (isequal (bleek (grk), -7));
+%! assert (isequal (gark (grk), -6));
+%! assert (isequal (click (cork (grk)), 23));
 %!test
-%!    cork1 = Cork(13);
-%!    grk = set(grk, 'gick',-5, 'gack',-6, 'gark',-7, 'cork',cork1);
-%!  assert(get(grk,'gick'),-5)
-%!  assert(get(grk,'gack'),-6)
-%!  assert(get(grk,'gark'),-7)
-%!  assert(click(get(grk, 'cork')),13);
-%!test grk = set(grk, 'cork',12);
-%!  assert(click(get(grk, 'cork')),12);
-%!  assert(class(cork(grk)),'Cork')
-%!  assert(class(grk),'Gork')
-%!  assert(isa(grk,'Gork'))
-%!  assert(isa(grk,'Dork'))
-%!  assert(isa(grk,'Pork'))
-%!  assert(isa(grk,'Blork'))
-%!  assert(isa(grk,'Snork'))
-%!  assert(isa(grk,'Spork'))
+%! cork1 = Cork(13);
+%! grk = set (grk, 'gick', -5, 'gack', -6, 'gark', -7, 'cork', cork1);
+%! assert (isequal (get (grk, 'gick'), -5));
+%! assert (isequal (get (grk, 'gack'), -6));
+%! assert (isequal (get (grk, 'gark'), -7));
+%! assert (isequal (click(get (grk, 'cork')), 13));
+%!test grk = set (grk, 'cork', 12);
+%! assert (isequal (click(get (grk, 'cork')),12));
+%! assert (isequal (class (cork(grk)), 'Cork'));
+%! assert (isequal (class (grk), 'Gork'));
+%! assert (isa (grk, 'Gork'));
+%! assert (isa (grk, 'Dork'));
+%! assert (isa (grk, 'Pork'));
+%! assert (isa (grk, 'Blork'));
+%! assert (isa (grk, 'Snork'));
+%! assert (isa (grk, 'Spork'));
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%% Testing (some) overloaded operators %%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+%% Common variables for testing overloaded operators
+%!shared x1, x2, x3, s1, s2, s3
+%!  x1 = 1 + rand(3);    s1 = Snork(x1);
+%!  x2 = 1 + rand(3);    s2 = Snork(x2);
+%!  x3 = diag([1 2 3]);  s3 = Snork(x3);
+
+%% Test overloaded plus (+) and uplus (unitary +) for the Snork class
+%!test  s = s1 + s2;  assert (isa (s, 'Snork') && isequal (s.gick, x1 + x2));
+%!test  s = s1 + x2;  assert (isa (s, 'Snork') && isequal (s.gick, x1 + x2));
+%!test  s = x1 + s2;  assert (isa (s, 'Snork') && isequal (s.gick, x1 + x2));
+%!test  s = +s1;      assert (isequal (s, s1));
+
+%% Test overloaded minus (-) for the Snork class
+%!test  s = s1 - s2;  assert (isa (s, 'Snork') && isequal (s.gick, x1 - x2));
+%!test  s = s1 - x2;  assert (isa (s, 'Snork') && isequal (s.gick, x1 - x2));
+%!test  s = x1 - s2;  assert (isa (s, 'Snork') && isequal (s.gick, x1 - x2));
+%!test  s = -s1;      assert (isequal (s, Snork(-x1)));
+
+%% Test overloaded mtimes (*) for the Snork class
+%!test  s = s1 * s2;  assert (isa (s, 'Snork') && isequal (s.gick, x1 * x2));
+%!test  s = s1 * x2;  assert (isa (s, 'Snork') && isequal (s.gick, x1 * x2));
+%!test  s = x1 * s2;  assert (isa (s, 'Snork') && isequal (s.gick, x1 * x2));
+
+%% Test overloaded times (.*) for the Snork class
+%!test  s = s1 .* s2;  assert (isa (s, 'Snork') && isequal (s.gick, x1 .* x2));
+%!test  s = s1 .* x2;  assert (isa (s, 'Snork') && isequal (s.gick, x1 .* x2));
+%!test  s = x1 .* s2;  assert (isa (s, 'Snork') && isequal (s.gick, x1 .* x2));
+
+%% Test overloaded mpower (^) for the Snork class
+%!test  s = s1 ^ 3;   assert (isa (s, 'Snork') && isequal (s.gick, x1 ^ 3));
+%!error <mpower Snork!!!>  s = s1 ^ s1;
+%!error <mpower Snork!!!>  s = 20 ^ s1;
+
+%% Test overloaded power (.^) for the Snork class
+%!test  s = s1 .^ 2;   assert (isa (s, 'Snork') && isequal (s.gick, x1 .^ 2));
+%!error <power Snork!!!>  s = s1 .^ s1;
+%!error <power Snork!!!>  s = 20 .^ s1;
+
+%% Test overloaded rdivide (./) for the Snork class
+%!test  s = s1 ./ s2;  assert (isa (s, 'Snork') && isequal (s.gick, x1 ./ x2));
+%!test  s = s1 ./ x2;  assert (isa (s, 'Snork') && isequal (s.gick, x1 ./ x2));
+%!test  s = x1 ./ s2;  assert (isa (s, 'Snork') && isequal (s.gick, x1 ./ x2));
+
+%% Test overloaded ldivide (.\) for the Snork class
+%!test  s = s1 .\ s2;  assert (isa (s, 'Snork') && isequal (s.gick, x1 .\ x2));
+%!test  s = s1 .\ x2;  assert (isa (s, 'Snork') && isequal (s.gick, x1 .\ x2));
+%!test  s = x1 .\ s2;  assert (isa (s, 'Snork') && isequal (s.gick, x1 .\ x2));
+
+%% Test overloaded mrdivide (/) for the Snork class
+%!test  s = s1 / s3;  assert (isa (s, 'Snork') && isequal (s.gick, x1 / x3));
+%!test  s = s1 / x3;  assert (isa (s, 'Snork') && isequal (s.gick, x1 / x3));
+%!test  s = x1 / s3;  assert (isa (s, 'Snork') && isequal (s.gick, x1 / x3));
+
+%% Test overloaded mldivide (\) for the Snork class
+%!test  s = s3 \ s2;  assert (isa (s, 'Snork') && isequal (s.gick, x3 \ x2));
+%!test  s = s3 \ x2;  assert (isa (s, 'Snork') && isequal (s.gick, x3 \ x2));
+%!test  s = x3 \ s2;  assert (isa (s, 'Snork') && isequal (s.gick, x3 \ x2));
+
+%% Test overloaded eq (==) for the Snork class
+%!assert (s1 == s1)
+%!assert (s1 == x1)
+%!assert (x1 == s1)
+%!assert (~(s1 == (s1 + 1)))
+%!assert (~(s1 == (x1 + 1)))
+%!assert (~(x1 == (s1 + 1)))
+
+%% Test overloaded ne (~=) for the Snork class
+%!assert (~(s1 ~= s1))
+%!assert (~(s1 ~= x1))
+%!assert (~(x1 ~= s1))
+%!assert (s1 ~= (s1 + 1))
+%!assert (x1 ~= (s1 + 1))
+%!assert (s1 ~= (x1 + 1))
+
+%% Test overloaded lt (<) for the Snork class
+%!assert (s1 < (s1 + 1))
+%!assert (s1 < (x1 + 1))
+%!assert (x1 < (s1 + 1))
+
+%% Test overloaded gt (>) for the Snork class
+%!assert (s1 > (s1 - 1))
+%!assert (s1 > (x1 - 1))
+%!assert (x1 > (s1 - 1))
+
+%% Test overloaded lt (<=) for the Snork class
+%!assert (s1 <= (s1 + 1))
+%!assert (s1 <= (x1 + 1))
+%!assert (x1 <= (s1 + 1))
+
+%% Test overloaded gt (>=) for the Snork class
+%!assert (s1 >= (s1 - 1))
+%!assert (s1 >= (x1 - 1))
+%!assert (x1 >= (s1 - 1))
+
+%% Test overloaded vertcat() for the Snork class
+%% See bug #38170 (http://savannah.gnu.org/bugs/?38170)
+%!test   s = [s1; s2];  assert (isa (s, 'Snork') && isequal (s.gick, [x1; x2]));
+%!xtest  s = [s1; x2];  assert (isa (s, 'Snork') && isequal (s.gick, [x1; x2]));
+%!xtest  s = [x1; s2];  assert (isa (s, 'Snork') && isequal (s.gick, [x1; x2]));
+
+%% Test overloaded horzcat() for the Snork class
+%% See bug #38170 (http://savannah.gnu.org/bugs/?38170)
+%!test   s = [s1 s2];  assert (isa (s, 'Snork') && isequal (s.gick, [x1 x2]));
+%!xtest  s = [s1 x2];  assert (isa (s, 'Snork') && isequal (s.gick, [x1 x2]));
+%!xtest  s = [x1 s2];  assert (isa (s, 'Snork') && isequal (s.gick, [x1 x2]));
+
diff --git a/test/classes/module.mk b/test/classes/module.mk
--- a/test/classes/module.mk
+++ b/test/classes/module.mk
@@ -32,32 +32,53 @@ classes_FCN_FILES = \
   classes/@Pork/gurk.m \
   classes/@Pork/private/myStash.m \
   classes/@Pork/set.m \
   classes/@Sneetch/Sneetch.m \
   classes/@Sneetch/display.m \
   classes/@Snork/Snork.m \
   classes/@Snork/cack.m \
   classes/@Snork/display.m \
+  classes/@Snork/double.m \
   classes/@Snork/end.m \
+  classes/@Snork/eq.m \
+  classes/@Snork/ge.m \
   classes/@Snork/get.m \
   classes/@Snork/getStash.m \
   classes/@Snork/gick.m \
+  classes/@Snork/gt.m \
+  classes/@Snork/horzcat.m \
+  classes/@Snork/ldivide.m \
+  classes/@Snork/le.m \
   classes/@Snork/loadobj.m \
+  classes/@Snork/lt.m \
+  classes/@Snork/minus.m \
+  classes/@Snork/mldivide.m \
+  classes/@Snork/mpower.m \
+  classes/@Snork/mrdivide.m \
+  classes/@Snork/mtimes.m \
+  classes/@Snork/ne.m \
+  classes/@Snork/plus.m \
+  classes/@Snork/power.m \
   classes/@Snork/private/myStash.m \
+  classes/@Snork/rdivide.m \
   classes/@Snork/saveobj.m \
   classes/@Snork/set.m \
   classes/@Snork/subsasgn.m \
   classes/@Snork/subsindex.m \
   classes/@Snork/subsref.m \
+  classes/@Snork/times.m \
+  classes/@Snork/uminus.m \
+  classes/@Snork/uplus.m \
+  classes/@Snork/vertcat.m \
   classes/@Spork/Spork.m \
   classes/@Spork/cack.m \
   classes/@Spork/display.m \
   classes/@Spork/geek.m \
   classes/@Spork/get.m \
   classes/@Spork/getStash.m \
   classes/@Spork/loadobj.m \
   classes/@Spork/private/myStash.m \
   classes/@Spork/saveobj.m \
   classes/@Spork/set.m \
-  classes/test_classes.m
+  classes/classes.tst
 
 FCN_FILES += $(classes_FCN_FILES)
diff --git a/test/ctor-vs-method/test_ctor_vs_method.m b/test/ctor-vs-method/ctor-vs-method.tst
rename from test/ctor-vs-method/test_ctor_vs_method.m
rename to test/ctor-vs-method/ctor-vs-method.tst
diff --git a/test/ctor-vs-method/module.mk b/test/ctor-vs-method/module.mk
--- a/test/ctor-vs-method/module.mk
+++ b/test/ctor-vs-method/module.mk
@@ -1,11 +1,11 @@
 ctor_vs_method_FCN_FILES = \
   ctor-vs-method/@derived/derived.m \
   ctor-vs-method/@derived/parent.m \
   ctor-vs-method/@other/other.m \
   ctor-vs-method/@other/parent.m \
   ctor-vs-method/@parent/method.m \
   ctor-vs-method/@parent/parent.m \
   ctor-vs-method/__trace__.m \
-  ctor-vs-method/test_ctor_vs_method.m
+  ctor-vs-method/ctor-vs-method.tst
 
 FCN_FILES += $(ctor_vs_method_FCN_FILES)
diff --git a/test/test_diag_perm.m b/test/diag-perm.tst
rename from test/test_diag_perm.m
rename to test/diag-perm.tst
diff --git a/test/test_error.m b/test/error.tst
rename from test/test_error.m
rename to test/error.tst
diff --git a/test/test_eval-catch.m b/test/eval-catch.tst
rename from test/test_eval-catch.m
rename to test/eval-catch.tst
diff --git a/test/fcn-handle-derived-resolution/test_fcn_handle_derived_resolution.m b/test/fcn-handle-derived-resolution/fcn-handle-derived-resolution.tst
rename from test/fcn-handle-derived-resolution/test_fcn_handle_derived_resolution.m
rename to test/fcn-handle-derived-resolution/fcn-handle-derived-resolution.tst
diff --git a/test/fcn-handle-derived-resolution/module.mk b/test/fcn-handle-derived-resolution/module.mk
--- a/test/fcn-handle-derived-resolution/module.mk
+++ b/test/fcn-handle-derived-resolution/module.mk
@@ -1,11 +1,11 @@
 fcn_handle_derived_resolution_FCN_FILES = \
   fcn-handle-derived-resolution/@derived/derived.m \
   fcn-handle-derived-resolution/@other/getsize_arrayfun.m \
   fcn-handle-derived-resolution/@other/getsize_cellfun.m \
   fcn-handle-derived-resolution/@other/getsize_loop.m \
   fcn-handle-derived-resolution/@other/other.m \
   fcn-handle-derived-resolution/@parent/numel.m \
   fcn-handle-derived-resolution/@parent/parent.m \
-  fcn-handle-derived-resolution/test_fcn_handle_derived_resolution.m
+  fcn-handle-derived-resolution/fcn-handle-derived-resolution.tst
 
 FCN_FILES += $(fcn_handle_derived_resolution_FCN_FILES)
diff --git a/test/fntests.m b/test/fntests.m
--- a/test/fntests.m
+++ b/test/fntests.m
@@ -36,281 +36,20 @@ topsrcdir = canonicalize_file_name (full
 topbuilddir = canonicalize_file_name (fullfile (currdir, ".."));
 
 if (strcmp (currdir, srcdir))
   testdirs = {srcdir};
 else
   testdirs = {currdir, srcdir};
 endif
 
-src_tree = canonicalize_file_name (fullfile (topsrcdir, "libinterp"));
-liboctave_tree = canonicalize_file_name (fullfile (topsrcdir, "liboctave"));
+src_tree = canonicalize_file_name (fullfile (topbuilddir, "libinterp"));
+liboctave_tree = canonicalize_file_name (fullfile (topbuilddir, "liboctave"));
 script_tree = canonicalize_file_name (fullfile (topsrcdir, "scripts"));
 local_script_tree = canonicalize_file_name (fullfile (currdir, "../scripts"));
 
 fundirs = {src_tree, liboctave_tree, script_tree};
 
 if (! strcmp (currdir, srcdir))
   fundirs{end+1} = local_script_tree;
 endif
 
-function print_test_file_name (nm)
-  filler = repmat (".", 1, 55-length (nm));
-  printf ("  %s %s", nm, filler);
-endfunction
-
-function print_pass_fail (n, p)
-  if (n > 0)
-    printf (" PASS %4d/%-4d", p, n);
-    nfail = n - p;
-    if (nfail > 0)
-      printf (" FAIL %d", nfail);
-    endif
-  endif
-  puts ("\n");
-endfunction
-
-function retval = has_functions (f)
-  n = length (f);
-  if (n > 3 && strcmp (f((end-2):end), ".cc"))
-    fid = fopen (f);
-    if (fid >= 0)
-      str = fread (fid, "*char")';
-      fclose (fid);
-      retval = ! isempty (regexp (str,'^(DEFUN|DEFUN_DLD)\b', 'lineanchors'));
-    else
-      error ("fopen failed: %s", f);
-    endif
-  elseif (n > 2 && strcmp (f((end-1):end), ".m"))
-    retval = true;
-  else
-    retval = false;
-  endif
-endfunction
-
-function retval = has_tests (f)
-  fid = fopen (f);
-  if (fid >= 0)
-    str = fread (fid, "*char")';
-    fclose (fid);
-    retval = ! isempty (regexp (str, '^%!(assert|error|fail|test|warning)', "lineanchors"));
-  else
-    error ("fopen failed: %s", f);
-  endif
-endfunction
-
-function retval = has_demos (f)
-  fid = fopen (f);
-  if (fid >= 0)
-    str = fread (fid, "*char")';
-    fclose (fid);
-    retval = ! isempty (regexp (str, '^%!demo', "lineanchors"));
-  else
-    error ("fopen failed: %s", f);
-  endif
-endfunction
-
-function [dp, dn, dxf, dsk] = run_test_dir (fid, d);
-  global files_with_tests;
-  global files_with_no_tests;
-  lst = dir (d);
-  dp = dn = dxf = dsk = 0;
-  for i = 1:length (lst)
-    nm = lst(i).name;
-    if (lst(i).isdir
-        && ! strcmp (nm, ".") && ! strcmp (nm, "..")
-        && ! strcmp (nm, "private") && nm(1) != "@"
-        && ! strcmp (nm, "CVS"))
-      [p, n, xf, sk] = run_test_dir (fid, [d, filesep, nm]);
-      dp += p;
-      dn += n;
-      dxf += xf;
-      dsk += sk;
-    endif
-  endfor
-  saved_dir = pwd ();
-  unwind_protect
-    chdir (d);
-    for i = 1:length (lst)
-      nm = lst(i).name;
-      if (length (nm) > 5 && strcmp (nm(1:5), "test_")
-          && strcmp (nm((end-1):end), ".m"))
-        p = n = xf = sk = 0;
-        ffnm = fullfile (d, nm);
-        if (has_tests (ffnm))
-          print_test_file_name (nm);
-          [p, n, xf, sk] = test (nm(1:(end-2)), "quiet", fid);
-          print_pass_fail (n, p);
-          files_with_tests(end+1) = ffnm;
-        ##elseif (has_demos (ffnm))
-        ##  files_with_tests(end+1) = ffnm;
-        else
-          files_with_no_tests(end+1) = ffnm;
-        endif
-        dp += p;
-        dn += n;
-        dxf += xf;
-        dsk += sk;
-      endif
-    endfor
-  unwind_protect_cleanup
-    chdir (saved_dir);
-  end_unwind_protect
-endfunction
-
-function [dp, dn, dxf, dsk] = run_test_script (fid, d);
-  global files_with_tests;
-  global files_with_no_tests;
-  global topsrcdir;
-  global topbuilddir;
-  lst = dir (d);
-  dp = dn = dxf = dsk = 0;
-  for i = 1:length (lst)
-    nm = lst(i).name;
-    if (lst(i).isdir && ! strcmp (nm, ".") && ! strcmp (nm, "..")
-        && ! strcmp (nm, "CVS"))
-      [p, n, xf, sk] = run_test_script (fid, [d, filesep, nm]);
-      dp += p;
-      dn += n;
-      dxf += xf;
-      dsk += sk;
-    endif
-  endfor
-  for i = 1:length (lst)
-    nm = lst(i).name;
-    ## Ignore hidden files
-    if (nm(1) == '.')
-      continue
-    endif
-    f = fullfile (d, nm);
-    if ((length (nm) > 2 && strcmp (nm((end-1):end), ".m")) || 
-        (length (nm) > 3 && strcmp (nm((end-2):end), ".cc")))
-      p = n = xf = 0;
-      ## Only run if it contains %!test, %!assert %!error or %!warning
-      if (has_tests (f))
-        tmp = strrep (f, [topsrcdir, filesep], "");
-        tmp = strrep (tmp, [topbuilddir, filesep], ["..", filesep]);
-        print_test_file_name (tmp);
-        [p, n, xf, sk] = test (f, "quiet", fid);
-        print_pass_fail (n, p);
-        dp += p;
-        dn += n;
-        dxf += xf;
-        dsk += sk;
-        files_with_tests(end+1) = f;
-      ##elseif (has_demos (f))
-      ##  files_with_tests(end+1) = f;
-      elseif (has_functions (f))
-        ## To reduce the list length, only mark .cc files that contain
-        ## DEFUN definitions.
-        files_with_no_tests(end+1) = f;
-      endif
-    endif
-  endfor 
-  ##  printf("%s%s -> passes %d of %d tests\n", ident, d, dp, dn);
-endfunction
-
-function printf_assert (varargin)
-  global _assert_printf;
-  _assert_printf = cat (2, _assert_printf, sprintf (varargin{:}));
-endfunction
-
-function ret = prog_output_assert (str)
-  global _assert_printf;
-  if (isempty (_assert_printf))
-    ret = isempty (str);
-  elseif (_assert_printf(end) == "\n")
-    ret = strcmp (_assert_printf(1:(end-1)), str);
-  else
-    ret = strcmp (_assert_printf, str);
-  endif
-  _assert_printf = "";
-endfunction
-
-function n = num_elts_matching_pattern (lst, pat)
-  n = sum (cellfun (@(x) !isempty (x), regexp (lst, pat, 'once')));
-endfunction
-
-function report_files_with_no_tests (with, without, typ)
-  pat = cstrcat ('\', typ, "$");
-  n_with = num_elts_matching_pattern (with, pat);
-  n_without = num_elts_matching_pattern (without, pat);
-  n_tot = n_with + n_without;
-  printf ("\n%d (of %d) %s files have no tests.\n", n_without, n_tot, typ);
-endfunction
-
-pso = page_screen_output ();
-warn_state = warning ("query", "quiet");
-warning ("on", "quiet");
-try
-  page_screen_output (0);
-  warning ("off", "Octave:deprecated-function");
-  fid = fopen ("fntests.log", "wt");
-  if (fid < 0)
-    error ("could not open fntests.log for writing");
-  endif
-  test ("", "explain", fid);
-  dp = dn = dxf = dsk = 0;
-  puts ("\nIntegrated test scripts:\n\n");
-  for i = 1:length (fundirs)
-    [p, n, xf, sk] = run_test_script (fid, fundirs{i});
-    dp += p;
-    dn += n;
-    dxf += xf;
-    dsk += sk;
-  endfor
-  puts ("\nFixed test scripts:\n\n");
-  for i = 1:length (testdirs)
-    [p, n, xf, sk] = run_test_dir (fid, testdirs{i});
-    dp += p;
-    dn += n;
-    dxf += xf;
-    dsk += sk;
-  endfor
-  puts ("\nSummary:\n\n");
-  nfail = dn - dp;
-  printf ("  PASS    %6d\n", dp);
-  printf ("  FAIL    %6d\n", nfail);
-  if (dxf > 0)
-    printf ("  XFAIL   %6d\n", dxf);
-  endif
-  if (dsk > 0)
-    printf ("  SKIPPED %6d\n", dsk);
-  endif
-  puts ("\n");
-  puts ("See the file test/fntests.log for additional details.\n");
-  if (dxf > 0)
-    puts ("\n");
-    puts ("Expected failures (listed as XFAIL above) are known bugs.\n");
-    puts ("Please help improve Octave by contributing fixes for them.\n");
-  endif
-  if (dsk > 0)
-    puts ("\n");
-    puts ("Tests are most often skipped because the features they require\n");
-    puts ("have been disabled.  Features are most often disabled because\n");
-    puts ("they require dependencies that were not present when Octave\n");
-    puts ("was built.  The configure script should have printed a summary\n");
-    puts ("at the end of its run indicating which dependencies were not found.\n");
-  endif
-
-  ## Weed out deprecated and private functions
-  weed_idx = cellfun (@isempty, regexp (files_with_tests, '\bdeprecated\b|\bprivate\b', 'once'));
-  files_with_tests = files_with_tests(weed_idx);
-  weed_idx = cellfun (@isempty, regexp (files_with_no_tests, '\bdeprecated\b|\bprivate\b', 'once'));
-  files_with_no_tests = files_with_no_tests(weed_idx);
-
-  report_files_with_no_tests (files_with_tests, files_with_no_tests, ".m");
-  report_files_with_no_tests (files_with_tests, files_with_no_tests, ".cc");
-
-  puts ("\nPlease help improve Octave by contributing tests for\n");
-  puts ("these files (see the list in the file fntests.log).\n\n");
-
-  fprintf (fid, "\nFiles with no tests:\n\n%s",
-          list_in_columns (files_with_no_tests, 80));
-  fclose (fid);
-
-  page_screen_output (pso);
-  warning (warn_state.state, "quiet");
-catch
-  page_screen_output (pso);
-  warning (warn_state.state, "quiet");
-  disp (lasterr ());
-end_try_catch
+__run_test_suite__ (fundirs, testdirs);
diff --git a/test/test_for.m b/test/for.tst
rename from test/test_for.m
rename to test/for.tst
--- a/test/test_for.m
+++ b/test/for.tst
@@ -14,92 +14,92 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %% test/octave.test/for/for-1.m
 %!test
 %! for i = 1
-%!   printf_assert ("%d", i);
+%!   __printf_assert__ ("%d", i);
 %! end
-%! printf_assert ("\n");
-%! assert (prog_output_assert ("1"));
+%! __printf_assert__ ("\n");
+%! assert (__prog_output_assert__ ("1"));
 
 %% test/octave.test/for/for-2.m
 %!test
 %! for i = 1:4
-%!   printf_assert ("%d", i);
+%!   __printf_assert__ ("%d", i);
 %! endfor
-%! printf_assert ("\n");
-%! assert (prog_output_assert ("1234"));
+%! __printf_assert__ ("\n");
+%! assert (__prog_output_assert__ ("1234"));
 
 %% test/octave.test/for/for-3.m
 %!test
 %! for i = [1,2,3,4]
-%!   printf_assert ("%d", i);
+%!   __printf_assert__ ("%d", i);
 %! endfor
-%! printf_assert ("\n");
-%! assert (prog_output_assert ("1234"));
+%! __printf_assert__ ("\n");
+%! assert (__prog_output_assert__ ("1234"));
 
 %% test/octave.test/for/for-4.m
 %!test
 %! for i = [1,2;3,4]
-%!   printf_assert ("%d", i(1,1));
-%!   printf_assert ("%d", i(2,1));
+%!   __printf_assert__ ("%d", i(1,1));
+%!   __printf_assert__ ("%d", i(2,1));
 %! endfor
-%! printf_assert ("\n");
-%! assert (prog_output_assert ("1324"));
+%! __printf_assert__ ("\n");
+%! assert (__prog_output_assert__ ("1324"));
 
 %% test/octave.test/for/for-5.m
 %!test
 %! for i = I
-%!   printf_assert ("%d", imag (i));
+%!   __printf_assert__ ("%d", imag (i));
 %! endfor
-%! printf_assert ("\n");
-%! assert (prog_output_assert ("1"));
+%! __printf_assert__ ("\n");
+%! assert (__prog_output_assert__ ("1"));
 
 %% test/octave.test/for/for-6.m
 %!test
 %! for i = [1,2,3,4]*I
-%!   printf_assert ("%d", imag (i));
+%!   __printf_assert__ ("%d", imag (i));
 %! endfor
-%! printf_assert ("\n");
-%! assert (prog_output_assert ("1234"));
+%! __printf_assert__ ("\n");
+%! assert (__prog_output_assert__ ("1234"));
 
 %% test/octave.test/for/for-7.m
 %!test
 %! for i = [1,2;3,4]*I
-%!   printf_assert ("%d", imag (i(1,1)));
-%!   printf_assert ("%d", imag (i(2,1)));
+%!   __printf_assert__ ("%d", imag (i(1,1)));
+%!   __printf_assert__ ("%d", imag (i(2,1)));
 %! endfor
-%! printf_assert ("\n");
-%! assert (prog_output_assert ("1324"));
+%! __printf_assert__ ("\n");
+%! assert (__prog_output_assert__ ("1324"));
 
 %% test/octave.test/for/for-8.m
 %!test
 %! for i = [1,2,3,4]
 %!   if (i > 2)
 %!     break;
 %!   endif
-%!   printf_assert ("%d", i);
+%!   __printf_assert__ ("%d", i);
 %! endfor
-%! printf_assert ("\n");
-%! assert (prog_output_assert ("12"));
+%! __printf_assert__ ("\n");
+%! assert (__prog_output_assert__ ("12"));
 
 %% test/octave.test/for/for-9.m
 %!test
 %! for i = [1,2,3,4]
 %!   if (i < 3)
 %!     continue;
 %!   endif
-%!   printf_assert ("%d", i);
+%!   __printf_assert__ ("%d", i);
 %! endfor
-%! printf_assert ("\n");
-%! assert (prog_output_assert ("34"));
+%! __printf_assert__ ("\n");
+%! assert (__prog_output_assert__ ("34"));
 
 %!test
 %! a = [1,3;2,4];
 %! j = 0;
 %! for i = cat (3, a, 4 + a)
 %!   assert (i, [1;2] + 2*j++)
 %! endfor
 
diff --git a/test/test_func.m b/test/func.tst
rename from test/test_func.m
rename to test/func.tst
diff --git a/test/test_global.m b/test/global.tst
rename from test/test_global.m
rename to test/global.tst
diff --git a/test/test_if.m b/test/if.tst
rename from test/test_if.m
rename to test/if.tst
--- a/test/test_if.m
+++ b/test/if.tst
@@ -16,72 +16,72 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %% test/octave.test/if/if-1.m
 %!test
 %! i = 0;
 %! if (i == 0)
 %!   i++;
-%!   printf_assert ("%d\n", i);
+%!   __printf_assert__ ("%d\n", i);
 %! endif
-%! assert (prog_output_assert ("1"));
+%! assert (__prog_output_assert__ ("1"));
 
 %% test/octave.test/if/if-2.m
 %!test
 %! if (eye (2))
-%!   printf_assert ("fail\n");
+%!   __printf_assert__ ("fail\n");
 %! else
-%!   printf_assert ("pass\n");
+%!   __printf_assert__ ("pass\n");
 %! end
-%! assert (prog_output_assert ("pass"));
+%! assert (__prog_output_assert__ ("pass"));
 
 %% test/octave.test/if/if-3.m
 %!test
 %! x = 2;
 %! if (eye (2))
-%!   printf_assert ("fail\n");
+%!   __printf_assert__ ("fail\n");
 %! elseif (x)
-%!   printf_assert ("pass\n");
+%!   __printf_assert__ ("pass\n");
 %! endif
-%! assert (prog_output_assert ("pass"));
+%! assert (__prog_output_assert__ ("pass"));
 
 %% test/octave.test/if/if-4.m
 %!test
 %! x = 0;
 %! y = -2;
 %! if (eye (2))
-%!   printf_assert ("fail\n");
+%!   __printf_assert__ ("fail\n");
 %! elseif (x)
-%!   printf_assert ("fail\n");
+%!   __printf_assert__ ("fail\n");
 %! elseif (y)
-%!   printf_assert ("pass\n");
+%!   __printf_assert__ ("pass\n");
 %! end
-%! assert (prog_output_assert ("pass"));
+%! assert (__prog_output_assert__ ("pass"));
 
 %% test/octave.test/if/if-5.m
 %!test
 %! x = 0;
 %! y = -2;
 %! if (eye (2))
-%!   printf_assert ("fail\n");
+%!   __printf_assert__ ("fail\n");
 %! elseif (x)
-%!   printf_assert ("fail\n");
+%!   __printf_assert__ ("fail\n");
 %! elseif (x)
-%!   printf_assert ("fail\n");
+%!   __printf_assert__ ("fail\n");
 %! else
-%!   printf_assert ("pass\n");
+%!   __printf_assert__ ("pass\n");
 %! endif
-%! assert (prog_output_assert ("pass"));
+%! assert (__prog_output_assert__ ("pass"));
 
 %% test/octave.test/if/if-6.m
 %!test
 %! x = 0;
 %! y = -2;
 %! if (y)
-%!   printf_assert ("pass\n");
+%!   __printf_assert__ ("pass\n");
 %! elseif (x)
-%!   printf_assert ("fail\n");
+%!   __printf_assert__ ("fail\n");
 %! elseif (x)
-%!   printf_assert ("fail\n");
+%!   __printf_assert__ ("fail\n");
 %! end
-%! assert (prog_output_assert ("pass"));
+%! assert (__prog_output_assert__ ("pass"));
 
diff --git a/test/test_index.m b/test/index.tst
rename from test/test_index.m
rename to test/index.tst
diff --git a/test/test_io.m b/test/io.tst
rename from test/test_io.m
rename to test/io.tst
--- a/test/test_io.m
+++ b/test/io.tst
@@ -347,35 +347,35 @@
 %!     elseif (j == 2)
 %!       mode_list = ["w+"; "r+"; "a+"];
 %!     endif
 %!     nm = tmpnam ();
 %!     for k = 1:3
 %!       mode = deblank (mode_list (k,:));
 %!       [id, err] = fopen (nm, mode, arch);
 %!       if (id < 0)
-%!         printf_assert ("open failed: %s (%s, %s): %s\n", nm, mode, arch, err);
+%!         __printf_assert__ ("open failed: %s (%s, %s): %s\n", nm, mode, arch, err);
 %!         status = 0;
 %!         break;
 %!       else
 %!         fclose (id);
 %!       endif
 %!       tmp_mode = cstrcat (mode, "b");
 %!       [id, err] = fopen (nm, tmp_mode, arch);
 %!       if (id < 0)
-%!         printf_assert ("open failed: %s (%s, %s): %s\n", nm, tmp_mode, arch, err);
+%!         __printf_assert__ ("open failed: %s (%s, %s): %s\n", nm, tmp_mode, arch, err);
 %!         status = 0;
 %!         break;
 %!       else
 %!         fclose (id);
 %!       endif
 %!       tmp_mode = cstrcat (mode, "t");
 %!       [id, err] = fopen (nm, tmp_mode, arch);
 %!       if (id < 0)
-%!         printf_assert ("open failed: %s (%s, %s): %s\n", nm, tmp_mode, arch, err);
+%!         __printf_assert__ ("open failed: %s (%s, %s): %s\n", nm, tmp_mode, arch, err);
 %!         status = 0;
 %!         break;
 %!       else
 %!         fclose (id);
 %!       endif
 %!     endfor
 %!     unlink (nm);
 %!     if (status == 0)
@@ -394,17 +394,17 @@
 %! s.a = 1;
 %! fail ("fopen (s)");
 
 %% test/octave.test/io/fopen-3.m
 %!error fopen ("foo", "x")
 
 %% test/octave.test/io/fopen-4.m
 %! fopen ("foo", "wb", "noodle");
-%! assert (prog_output_assert ("error:"));
+%! assert (__prog_output_assert__ ("error:"));
 
 %% test/octave.test/io/fopen-5.m
 %!error <Invalid call to fopen> fopen ()
 
 %% test/octave.test/io/fopen-6.m
 %!error <Invalid call to fopen> fopen ("foo", "wb", "native", 1)
 
 %% test/octave.test/io/fclose-1.m
@@ -447,23 +447,23 @@
 %!   id = fopen (nm, "rb");
 %!   if (id > 0)
 %!     x = zeros (1, n);
 %!     for i = 1:n
 %!       x(i) = fread (id, [1, 1], deblank (type_list(i,:)));
 %!     endfor
 %!     
 %!     if (x == 1:n)
-%!       printf_assert ("ok\n");
+%!       __printf_assert__ ("ok\n");
 %!     endif
 %!   endif
 %! endif
 %! 
 %! unlink (nm);
-%! assert (prog_output_assert ("ok"));
+%! assert (__prog_output_assert__ ("ok"));
 
 %% test/octave.test/io/file-pos-1.m
 %!test
 %! nm = tmpnam ();
 %! id = fopen (nm, "wb");
 %! if (id > 0)
 %!   fprintf (id, "%d\n", 1:100);
 %!   fclose (id);
diff --git a/test/test_line_continue.m b/test/line-continue.tst
rename from test/test_line_continue.m
rename to test/line-continue.tst
diff --git a/test/test_logical_index.m b/test/logical-index.tst
rename from test/test_logical_index.m
rename to test/logical-index.tst
diff --git a/test/nest/module.mk b/test/nest/module.mk
--- a/test/nest/module.mk
+++ b/test/nest/module.mk
@@ -1,21 +1,21 @@
-nest_FCN_FILES = \
+nest_fcn_files = \
   nest/arg_nest.m \
   nest/arg_ret.m \
   nest/nest_eval.m \
   nest/no_closure.m \
   nest/persistent_nest.m \
   nest/recursive_nest.m \
   nest/recursive_nest2.m \
   nest/recursive_nest3.m \
   nest/scope0.m \
   nest/scope1.m \
   nest/scope2.m \
   nest/scope3.m \
   nest/script_nest.m \
   nest/script_nest_script.m \
-  nest/test_nest.m \
+  nest/nest.tst \
   nest/varg_nest.m \
   nest/varg_nest2.m
 
 FCN_FILES += $(nest_FCN_FILES)
 
diff --git a/test/nest/test_nest.m b/test/nest/nest.tst
rename from test/nest/test_nest.m
rename to test/nest/nest.tst
diff --git a/test/test_null_assign.m b/test/null-assign.tst
rename from test/test_null_assign.m
rename to test/null-assign.tst
diff --git a/test/test_parser.m b/test/parser.tst
rename from test/test_parser.m
rename to test/parser.tst
diff --git a/test/test_prefer.m b/test/prefer.tst
rename from test/test_prefer.m
rename to test/prefer.tst
diff --git a/test/test_range.m b/test/range.tst
rename from test/test_range.m
rename to test/range.tst
diff --git a/test/test_recursion.m b/test/recursion.tst
rename from test/test_recursion.m
rename to test/recursion.tst
diff --git a/test/test_return.m b/test/return.tst
rename from test/test_return.m
rename to test/return.tst
diff --git a/test/test_slice.m b/test/slice.tst
rename from test/test_slice.m
rename to test/slice.tst
diff --git a/test/test_struct.m b/test/struct.tst
rename from test/test_struct.m
rename to test/struct.tst
diff --git a/test/test_switch.m b/test/switch.tst
rename from test/test_switch.m
rename to test/switch.tst
diff --git a/test/test_system.m b/test/system.tst
rename from test/test_system.m
rename to test/system.tst
--- a/test/test_system.m
+++ b/test/system.tst
@@ -34,39 +34,39 @@
 %!test
 %! tic ();
 %! sleep (2);
 %! assert (toc () > 0);
 
 %% test/octave.test/system/pause-1.m
 %!test
 %! pause (0);
-%! printf_assert ("ok\n");
-%! assert (prog_output_assert ("ok"));
+%! __printf_assert__ ("ok\n");
+%! assert (__prog_output_assert__ ("ok"));
 
 %% test/octave.test/system/pause-2.m
 %!error <Invalid call to pause> pause (1, 2)
 
 %% test/octave.test/system/sleep-1.m
 %!test
 %! sleep (0);
-%! printf_assert ("ok\n");
-%! assert (prog_output_assert ("ok"));
+%! __printf_assert__ ("ok\n");
+%! assert (__prog_output_assert__ ("ok"));
 
 %% test/octave.test/system/sleep-2.m
 %!error <Invalid call to sleep> sleep ()
 
 %% test/octave.test/system/sleep-3.m
 %!error <Invalid call to sleep> sleep (1, 2)
 
 %% test/octave.test/system/usleep-1.m
 %!test
 %! usleep (0);
-%! printf_assert ("ok\n");
-%! assert (prog_output_assert ("ok"));
+%! __printf_assert__ ("ok\n");
+%! assert (__prog_output_assert__ ("ok"));
 
 %% test/octave.test/system/usleep-2.m
 %!error <Invalid call to usleep> usleep ()
 
 %% test/octave.test/system/usleep-3.m
 %!error <Invalid call to usleep> usleep (1, 2)
 
 %% test/octave.test/system/rename-1.m
diff --git a/test/test_transpose.m b/test/transpose.tst
rename from test/test_transpose.m
rename to test/transpose.tst
diff --git a/test/test_try.m b/test/try.tst
rename from test/test_try.m
rename to test/try.tst
diff --git a/test/test_unwind.m b/test/unwind.tst
rename from test/test_unwind.m
rename to test/unwind.tst
diff --git a/test/test_while.m b/test/while.tst
rename from test/test_while.m
rename to test/while.tst
--- a/test/test_while.m
+++ b/test/while.tst
@@ -16,55 +16,55 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %% test/octave.test/while/while-1.m
 %!test
 %! i = 0;
 %! while (eye (2))
 %!   i++;
-%!   printf_assert ("%d\n", i);
+%!   __printf_assert__ ("%d\n", i);
 %! endwhile
-%! assert (prog_output_assert (""));
+%! assert (__prog_output_assert__ (""));
 
 %% test/octave.test/while/while-2.m
 %!test
 %! i = 5;
 %! while (--i)
-%!   printf_assert ("%d", i);
+%!   __printf_assert__ ("%d", i);
 %! endwhile
-%! printf_assert ("\n");
-%! assert (prog_output_assert ("4321"));
+%! __printf_assert__ ("\n");
+%! assert (__prog_output_assert__ ("4321"));
 
 %% test/octave.test/while/while-3.m
 %!test
 %! i = 5;
 %! while (i)
 %!   i--;
-%!   printf_assert ("%d", i);
+%!   __printf_assert__ ("%d", i);
 %! endwhile
-%! printf_assert ("\n");
-%! assert (prog_output_assert ("43210"));
+%! __printf_assert__ ("\n");
+%! assert (__prog_output_assert__ ("43210"));
 
 %% test/octave.test/while/while-4.m
 %!test
 %! i = 0;
 %! while (i++ < 20)
 %!   if (i > 2)
 %!     break;
 %!   endif
-%!   printf_assert ("%d", i);
+%!   __printf_assert__ ("%d", i);
 %! endwhile
-%! printf_assert ("\n");
-%! assert (prog_output_assert ("12"));
+%! __printf_assert__ ("\n");
+%! assert (__prog_output_assert__ ("12"));
 
 %% test/octave.test/while/while-5.m
 %!test
 %! i = 0;
 %! while (++i < 5)
 %!   if (i < 3)
 %!     continue;
 %!   endif
-%!   printf_assert ("%d", i);
+%!   __printf_assert__ ("%d", i);
 %! endwhile
-%! printf_assert ("\n");
-%! assert (prog_output_assert ("34"));
+%! __printf_assert__ ("\n");
+%! assert (__prog_output_assert__ ("34"));
 
