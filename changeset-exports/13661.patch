# HG changeset patch
# User Jordi Gutiérrez Hermoso <jordigh@octave.org>
# Date 1315458403 18000
#      Thu Sep 08 00:06:43 2011 -0500
# Node ID 8a1896fb82d4aa81be717429b51057b2fd2ca127
# Parent  632f653a29a0fcd69759525aa7968f37d4c9b1d5
# Parent  7600200a54c890d31c13255511c53aff41ea5a25
Merge with Savannah

diff --git a/.dir-locals.el b/.dir-locals.el
--- a/.dir-locals.el
+++ b/.dir-locals.el
@@ -1,5 +1,10 @@
-((nil . ((indent-tabs-mode . nil)
-         (fill-column . 72)))
- (c-default-mode "gnu")
+((nil .
+      ((c-file-style . "gnu")
+       (indent-tabs-mode . nil)
+       (fill-column . 72)
+       (eval . (when (string-match "\\.h\\'" (buffer-file-name))
+                 (unless (string-match "/gnulib/" (buffer-file-name))
+                   (c++-mode)
+                   (c-set-style "gnu"))))))
  (change-log-mode . ((indent-tabs-mode . t)))
  (makefile-mode . ((indent-tabs-mode . t))))
diff --git a/doc/interpreter/contributors.in b/doc/interpreter/contributors.in
--- a/doc/interpreter/contributors.in
+++ b/doc/interpreter/contributors.in
@@ -140,16 +140,17 @@ Jens-Uwe Mager
 Ricardo Marranita
 Orestes Mas
 Makoto Matsumoto
 Tatsuro Matsuoka
 Laurent Mazet
 G. D. McBain
 Alexander Mamonov
 Christoph Mayer
+Júlio Hoffimann Mendes
 Thorsten Meyer
 Petr Mikulik
 Stefan Monnier
 Antoine Moreau
 Kai P. Mueller
 Hannes Müller
 Victor Munoz
 Carmen Navarrete
diff --git a/liboctave/CColVector.cc b/liboctave/CColVector.cc
--- a/liboctave/CColVector.cc
+++ b/liboctave/CColVector.cc
@@ -237,17 +237,17 @@ ColumnVector
 ComplexColumnVector::abs (void) const
 {
   return do_mx_unary_map<double, Complex, std::abs> (*this);
 }
 
 ComplexColumnVector
 conj (const ComplexColumnVector& a)
 {
-  return do_mx_unary_map<Complex, Complex, std::conj> (a);
+  return do_mx_unary_map<Complex, Complex, std::conj<double> > (a);
 }
 
 // resize is the destructive equivalent for this one
 
 ComplexColumnVector
 ComplexColumnVector::extract (octave_idx_type r1, octave_idx_type r2) const
 {
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -916,17 +916,17 @@ ComplexMatrix::stack (const ComplexDiagM
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 conj (const ComplexMatrix& a)
 {
-  return do_mx_unary_map<Complex, Complex, std::conj> (a);
+  return do_mx_unary_map<Complex, Complex, std::conj<double> > (a);
 }
 
 // resize is the destructive equivalent for this one
 
 ComplexMatrix
 ComplexMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
 {
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -755,17 +755,17 @@ boolNDArray
 ComplexNDArray::isfinite (void) const
 {
   return do_mx_unary_map<bool, Complex, xfinite> (*this);
 }
 
 ComplexNDArray
 conj (const ComplexNDArray& a)
 {
-  return do_mx_unary_map<Complex, Complex, std::conj> (a);
+  return do_mx_unary_map<Complex, Complex, std::conj<double> > (a);
 }
 
 ComplexNDArray&
 ComplexNDArray::insert (const NDArray& a, octave_idx_type r, octave_idx_type c)
 {
   dim_vector a_dv = a.dims ();
 
   int n = a_dv.length ();
diff --git a/liboctave/CRowVector.cc b/liboctave/CRowVector.cc
--- a/liboctave/CRowVector.cc
+++ b/liboctave/CRowVector.cc
@@ -229,17 +229,17 @@ ComplexColumnVector
 ComplexRowVector::transpose (void) const
 {
   return MArray<Complex>::transpose ();
 }
 
 ComplexRowVector
 conj (const ComplexRowVector& a)
 {
-  return do_mx_unary_map<Complex, Complex, std::conj> (a);
+  return do_mx_unary_map<Complex, Complex, std::conj<double> > (a);
 }
 
 // resize is the destructive equivalent for this one
 
 ComplexRowVector
 ComplexRowVector::extract (octave_idx_type c1, octave_idx_type c2) const
 {
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
diff --git a/liboctave/fCColVector.cc b/liboctave/fCColVector.cc
--- a/liboctave/fCColVector.cc
+++ b/liboctave/fCColVector.cc
@@ -237,17 +237,17 @@ FloatColumnVector
 FloatComplexColumnVector::abs (void) const
 {
   return do_mx_unary_map<float, FloatComplex, std::abs> (*this);
 }
 
 FloatComplexColumnVector
 conj (const FloatComplexColumnVector& a)
 {
-  return do_mx_unary_map<FloatComplex, FloatComplex, std::conj> (a);
+  return do_mx_unary_map<FloatComplex, FloatComplex, std::conj<float> > (a);
 }
 
 // resize is the destructive equivalent for this one
 
 FloatComplexColumnVector
 FloatComplexColumnVector::extract (octave_idx_type r1, octave_idx_type r2) const
 {
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
diff --git a/liboctave/fCMatrix.cc b/liboctave/fCMatrix.cc
--- a/liboctave/fCMatrix.cc
+++ b/liboctave/fCMatrix.cc
@@ -918,17 +918,17 @@ FloatComplexMatrix::stack (const FloatCo
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 FloatComplexMatrix
 conj (const FloatComplexMatrix& a)
 {
-  return do_mx_unary_map<FloatComplex, FloatComplex, std::conj> (a);
+  return do_mx_unary_map<FloatComplex, FloatComplex, std::conj<float> > (a);
 }
 
 // resize is the destructive equivalent for this one
 
 FloatComplexMatrix
 FloatComplexMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
 {
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
diff --git a/liboctave/fCNDArray.cc b/liboctave/fCNDArray.cc
--- a/liboctave/fCNDArray.cc
+++ b/liboctave/fCNDArray.cc
@@ -752,17 +752,17 @@ boolNDArray
 FloatComplexNDArray::isfinite (void) const
 {
   return do_mx_unary_map<bool, FloatComplex, xfinite> (*this);
 }
 
 FloatComplexNDArray
 conj (const FloatComplexNDArray& a)
 {
-  return do_mx_unary_map<FloatComplex, FloatComplex, std::conj> (a);
+  return do_mx_unary_map<FloatComplex, FloatComplex, std::conj<float> > (a);
 }
 
 FloatComplexNDArray&
 FloatComplexNDArray::insert (const NDArray& a, octave_idx_type r, octave_idx_type c)
 {
   dim_vector a_dv = a.dims ();
 
   int n = a_dv.length ();
diff --git a/liboctave/fCRowVector.cc b/liboctave/fCRowVector.cc
--- a/liboctave/fCRowVector.cc
+++ b/liboctave/fCRowVector.cc
@@ -229,17 +229,17 @@ FloatComplexColumnVector
 FloatComplexRowVector::transpose (void) const
 {
   return MArray<FloatComplex>::transpose ();
 }
 
 FloatComplexRowVector
 conj (const FloatComplexRowVector& a)
 {
-  return do_mx_unary_map<FloatComplex, FloatComplex, std::conj> (a);
+  return do_mx_unary_map<FloatComplex, FloatComplex, std::conj<float> > (a);
 }
 
 // resize is the destructive equivalent for this one
 
 FloatComplexRowVector
 FloatComplexRowVector::extract (octave_idx_type c1, octave_idx_type c2) const
 {
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
diff --git a/scripts/plot/cla.m b/scripts/plot/cla.m
--- a/scripts/plot/cla.m
+++ b/scripts/plot/cla.m
@@ -85,19 +85,18 @@ function cla (varargin)
   axis ("auto");
 
   ## Set the current axis back to where it was upon entry.
   axes (oldhax);
 
 endfunction
 
 %!test
-%! hf = figure (1, "visible", "off");
-%! unwind_protect
-%!   clf
+%! hf = figure (1232, "visible", "off");
+%! unwind_protect 
 %!   plot (1:10)
 %!   cla ()
 %!   kids = get (gca, "children");
 %!   cla ()
 %! unwind_protect_cleanup
 %!   close (hf)
 %! end_unwind_protect
 %! assert (numel (kids), 0)
diff --git a/scripts/plot/clf.m b/scripts/plot/clf.m
--- a/scripts/plot/clf.m
+++ b/scripts/plot/clf.m
@@ -76,13 +76,20 @@ function clf (varargin)
 
 endfunction
 
 %!test
 %! hf = figure (1232, "visible", "off");
 %! unwind_protect  
 %!   l = line;
 %!   assert (!isempty (get (gcf, "children")));
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+
+%!test
+%! hf = figure (1232, "visible", "off");
+%! unwind_protect  
 %!   clf;
 %!   assert (isempty (get (gcf, "children")));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
diff --git a/scripts/plot/findall.m b/scripts/plot/findall.m
--- a/scripts/plot/findall.m
+++ b/scripts/plot/findall.m
@@ -41,14 +41,14 @@ function h = findall (varargin)
     set (0, "showhiddenhandles", shh);
   end_unwind_protect
 
 endfunction
 
 %!test
 %! hf = figure (1232, "visible", "off");
 %! unwind_protect  
-%!   h = findall;
-%!   all_handles = {"uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "root"; "figure"};
+%!   h = findall (hf);
+%!   all_handles = {"uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "figure"};
 %!   assert (get (h, 'type'), all_handles)
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
diff --git a/scripts/plot/findobj.m b/scripts/plot/findobj.m
--- a/scripts/plot/findobj.m
+++ b/scripts/plot/findobj.m
@@ -243,17 +243,16 @@ function h = findobj (varargin)
   h = reshape (h, [numel(h), 1]);
 endfunction
 
 %!test
 %! fign = 1232;
 %! hf = figure (fign, "visible", "off");
 %! unwind_protect  
 %!   l = line;
-%!   obj = findobj ("type", "line");
+%!   obj = findobj (hf, "type", "line");
 %!   assert (l, obj);
-%!   assert (gca, findobj ("type", "axes"));
-%!   assert (fign, findobj ("type", "figure"));
-%!   assert (0, findobj ("type", "root"));
-%!   assert (isempty (findobj ("type", "xyzxyz")));
+%!   assert (gca, findobj (hf, "type", "axes"));
+%!   assert (fign, findobj (hf, "type", "figure"));
+%!   assert (isempty (findobj (hf, "type", "xyzxyz")));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
diff --git a/scripts/plot/gcf.m b/scripts/plot/gcf.m
--- a/scripts/plot/gcf.m
+++ b/scripts/plot/gcf.m
@@ -52,14 +52,12 @@ function h = gcf ()
     print_usage ();
   endif
 
 endfunction
 
 %!test
 %! hf = figure (1232, "visible", "off");
 %! unwind_protect  
-%!   line;
-%!   clf;
-%!   assert (isempty (get (gcf, "children")));
+%!   assert (gcf, 1232);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
diff --git a/scripts/plot/line.m b/scripts/plot/line.m
--- a/scripts/plot/line.m
+++ b/scripts/plot/line.m
@@ -45,14 +45,14 @@ endfunction
 
 %!test
 %! hf = figure (1232, "visible", "off");
 %! unwind_protect  
 %!   h = line;
 %!   assert (get (h, "xdata"), [0 1], eps);
 %!   assert (get (h, "ydata"), [0 1], eps);
 %!   assert (get (h, "type"), "line");
-%!   assert (get (h, "color"), [0 0 0]);
-%!   assert (get (h, "linestyle"), "-");
-%!   assert (get (h, "linewidth"), 0.5, eps);
+%!   assert (get (h, "color"), get(0,'defaultlinecolor'));
+%!   assert (get (h, "linestyle"), get(0,'defaultlinelinestyle'));
+%!   assert (get (h, "linewidth"), get(0,'defaultlinelinewidth'), eps);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
diff --git a/scripts/plot/loglog.m b/scripts/plot/loglog.m
--- a/scripts/plot/loglog.m
+++ b/scripts/plot/loglog.m
@@ -56,15 +56,52 @@ function retval = loglog (varargin)
     endif
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
 %!demo
+%! clf ();
 %! t = 1:0.01:10;
 %! x = sort ((t .* (1 + rand (size (t)))) .^ 2);
 %! y = ((t .* (1 + rand (size (t)))) .^ 2);
 %! loglog (x, y);
 
-## Remove from test statistics.  No real tests possible.
-%!assert (1)
+%!demo
+%! clf ();
+%! a = logspace (-5, 1, 10);
+%! b =-logspace (-5, 1, 10);
+%! 
+%! subplot (1, 2, 1)
+%! loglog (a, b)
+%! xlabel ('loglog (a, b)')
+%! 
+%! subplot (1, 2, 2)
+%! loglog (a, abs (b))
+%! set (gca, 'ydir', 'reverse')
+%! xlabel ('loglog (a, abs (b))')
+
+%!test
+%! hf = figure (1232, "visible", "off");
+%! unwind_protect  
+%!   a = logspace (-5, 1, 10);
+%!   b = logspace (-5, 1, 10);
+%!   loglog (a, b)
+%!   assert (get (gca, "yscale"), "log");
+%!   assert (get (gca, "xscale"), "log");
+%! unwind_protect_cleanup
+%! close (hf);
+%! end_unwind_protect
+
+%!test
+%! hf = figure (1232, "visible", "off");
+%! unwind_protect  
+%!   a = logspace (-5, 1, 10);
+%!   b =-logspace (-5, 1, 10);
+%!   loglog (a, b)
+%!   axis tight
+%!   assert (all (get (gca, "ytick") < 0));
+%! unwind_protect_cleanup
+%! close (hf);
+%! end_unwind_protect
+
diff --git a/scripts/plot/semilogx.m b/scripts/plot/semilogx.m
--- a/scripts/plot/semilogx.m
+++ b/scripts/plot/semilogx.m
@@ -60,10 +60,47 @@ function retval = semilogx (varargin)
 
 endfunction
 
 %!demo
 %! x = 1:0.01:10;
 %! y = (x .* (1 + rand (size (x)))) .^ 2;
 %! semilogx (y, x);
 
-## Remove from test statistics.  No real tests possible.
-%!assert (1)
+%!demo
+%! clf ();
+%! a = logspace (-5, 1, 10);
+%! b =-logspace (-5, 1, 10);
+%! 
+%! subplot (1, 2, 1)
+%! semilogx (b, a)
+%! xlabel ('semilogx (a, b)')
+%! 
+%! subplot (1, 2, 2)
+%! semilogx (abs (b), a)
+%! set (gca, 'ydir', 'reverse')
+%! xlabel ('semilogx (a, abs (b))')
+
+%!test
+%! hf = figure (1232, "visible", "off");
+%! unwind_protect  
+%!   a = logspace (-5, 1, 10);
+%!   b = logspace (-5, 1, 10);
+%!   semilogx (a, b)
+%!   assert (get (gca, "xscale"), "log");
+%!   assert (get (gca, "yscale"), "linear");
+%! unwind_protect_cleanup
+%! close (hf);
+%! end_unwind_protect
+
+%!test
+%! hf = figure (1232, "visible", "off");
+%! unwind_protect  
+%!   a = logspace (-5, 1, 10);
+%!   b =-logspace (-5, 1, 10);
+%!   semilogx (a, b)
+%!   axis tight
+%!   assert (all (get (gca, "ytick") < 0));
+%! unwind_protect_cleanup
+%! close (hf);
+%! end_unwind_protect
+
+
diff --git a/scripts/plot/semilogy.m b/scripts/plot/semilogy.m
--- a/scripts/plot/semilogy.m
+++ b/scripts/plot/semilogy.m
@@ -61,10 +61,47 @@ function retval = semilogy (varargin)
 
 endfunction
 
 %!demo
 %! x = 1:0.01:10;
 %! y = (x .* (1 + rand (size (x)))) .^ 2;
 %! semilogy (x, y);
 
-## Remove from test statistics.  No real tests possible.
-%!assert (1)
+%!demo
+%! clf ();
+%! a = logspace (-5, 1, 10);
+%! b =-logspace (-5, 1, 10);
+%! 
+%! subplot (1, 2, 1)
+%! semilogy (a, b)
+%! xlabel ('semilogy (a, b)')
+%! 
+%! subplot (1, 2, 2)
+%! semilogy (a, abs (b))
+%! set (gca, 'ydir', 'reverse')
+%! xlabel ('semilogy (a, abs (b))')
+
+%!test
+%! hf = figure (1232, "visible", "off");
+%! unwind_protect  
+%!   a = logspace (-5, 1, 10);
+%!   b = logspace (-5, 1, 10);
+%!   semilogy (a, b)
+%!   assert (get (gca, "yscale"), "log");
+%!   assert (get (gca, "xscale"), "linear");
+%! unwind_protect_cleanup
+%! close (hf);
+%! end_unwind_protect
+
+%!test
+%! hf = figure (1232, "visible", "off");
+%! unwind_protect  
+%!   a = logspace (-5, 1, 10);
+%!   b =-logspace (-5, 1, 10);
+%!   semilogy (a, b)
+%!   axis tight
+%!   assert (all (get (gca, "ytick") < 0));
+%! unwind_protect_cleanup
+%! close (hf);
+%! end_unwind_protect
+
+
diff --git a/scripts/plot/whitebg.m b/scripts/plot/whitebg.m
--- a/scripts/plot/whitebg.m
+++ b/scripts/plot/whitebg.m
@@ -140,24 +140,28 @@ function whitebg (varargin)
           && strcmp (defs.defaultaxescolor, "none"))
         set (0, "defaultaxescolor", color);
       endif
     endif
   endif
 endfunction
 
 %!test
+%! dac = get (0, "defaultaxescolor");
+%! dfc = get (0, "defaultfigurecolor");
 %! set (0, "defaultaxescolor", [1 1 1]);
 %! set (0, "defaultfigurecolor", [1 1 1]);
 %! hf = figure (1232, "visible", "off");
 %! unwind_protect  
 %!   l = line;
 %!   assert (get (hf, "color"), [1 1 1]);
 %!   assert (get (gca, "color"), [1 1 1]);
 %!   whitebg;
 %!   assert (get (hf, "color"), [0 0 0]);
 %!   assert (get (gca, "color"), [0 0 0]);
 %!   whitebg([0.2 0.2 0.2])
 %!   assert (get (hf, "color"), [0 0 0]);
 %!   assert (get (gca, "color"), [0.2 0.2 0.2]);
 %! unwind_protect_cleanup
 %!   close (hf);
+%!   set (0, "defaultaxescolor", dac);
+%!   set (0, "defaultfigurecolor", dfc);
 %! end_unwind_protect
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -5179,18 +5179,18 @@ axes::properties::get_axis_limits (doubl
   double max_val = xmax;
 
   if (! (xisinf (min_val) || xisinf (max_val)))
     {
       if (logscale)
         {
           if (xisinf (min_pos))
             {
-              // warning ("axis: logscale with no positive values to plot");
-              return retval;
+              // FIXME -- need to handle log plots with all negative data.
+              return default_lim ();
             }
 
           if (min_val <= 0)
             {
               warning ("axis: omitting nonpositive data in log plot");
               min_val = min_pos;
             }
           // FIXME -- maybe this test should also be relative?
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -45,16 +45,17 @@ along with Octave; see the file COPYING.
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-range.h"
 #include "ov-re-mat.h"
 #include "ov-scalar.h"
 #include "ov-str-mat.h"
 #include "ov-fcn-handle.h"
 #include "parse.h"
+#include "pr-output.h"
 #include "utils.h"
 #include "variables.h"
 
 builtin_type_t btyp_mixed_numeric (builtin_type_t x, builtin_type_t y)
 {
   builtin_type_t retval = btyp_unknown;
 
   if (x == btyp_bool)
@@ -414,33 +415,35 @@ octave_base_value::print_name_tag (std::
   indent (os);
 
   if (print_as_scalar ())
     os << name << " = ";
   else
     {
       os << name << " =";
       newline (os);
-      newline (os);
+      if (! Vcompact_format)
+        newline (os);
+
       retval = true;
     }
 
   return retval;
 }
 
 void
 octave_base_value::print_with_name (std::ostream& output_buf,
                                     const std::string& name,
                                     bool print_padding)
 {
   bool pad_after = print_name_tag (output_buf, name);
 
   print (output_buf);
 
-  if (print_padding && pad_after)
+  if (print_padding  && pad_after && ! Vcompact_format)
     newline (output_buf);
 }
 
 void
 octave_base_value::print_info (std::ostream& os,
                                const std::string& /* prefix */) const
 {
   os << "no info for type: " << type_name () << "\n";
diff --git a/src/ov-class.cc b/src/ov-class.cc
--- a/src/ov-class.cc
+++ b/src/ov-class.cc
@@ -1015,17 +1015,18 @@ octave_class::print_raw (std::ostream& o
 bool
 octave_class::print_name_tag (std::ostream& os, const std::string& name) const
 {
   bool retval = false;
 
   indent (os);
   os << name << " =";
   newline (os);
-  newline (os);
+  if (! Vcompact_format)
+    newline (os);
 
   return retval;
 }
 
 void
 octave_class::print_with_name (std::ostream& os, const std::string& name,
                                bool)
 {
diff --git a/src/ov-cx-sparse.cc b/src/ov-cx-sparse.cc
--- a/src/ov-cx-sparse.cc
+++ b/src/ov-cx-sparse.cc
@@ -899,17 +899,17 @@ octave_sparse_complex_matrix::map (unary
       ARRAY_MAPPER (acosh, Complex, ::acosh);
       ARRAY_MAPPER (angle, double, std::arg);
       ARRAY_MAPPER (arg, double, std::arg);
       ARRAY_MAPPER (asin, Complex, ::asin);
       ARRAY_MAPPER (asinh, Complex, ::asinh);
       ARRAY_MAPPER (atan, Complex, ::atan);
       ARRAY_MAPPER (atanh, Complex, ::atanh);
       ARRAY_MAPPER (ceil, Complex, ::ceil);
-      ARRAY_MAPPER (conj, Complex, std::conj);
+      ARRAY_MAPPER (conj, Complex, std::conj<double>);
       ARRAY_MAPPER (cos, Complex, std::cos);
       ARRAY_MAPPER (cosh, Complex, std::cosh);
       ARRAY_MAPPER (exp, Complex, std::exp);
       ARRAY_MAPPER (expm1, Complex, ::expm1);
       ARRAY_MAPPER (fix, Complex, ::fix);
       ARRAY_MAPPER (floor, Complex, ::floor);
       ARRAY_MAPPER (log, Complex, std::log);
       ARRAY_MAPPER (log2, Complex, xlog2);
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -365,17 +365,19 @@ octave_range::print_name_tag (std::ostre
   indent (os);
 
   if (n == 0 || n == 1)
     os << name << " = ";
   else
     {
       os << name << " =";
       newline (os);
-      newline (os);
+      if (! Vcompact_format)
+        newline (os);
+
       retval = true;
     }
 
   return retval;
 }
 
 // Skip white space and comments on stream IS.
 
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -1330,21 +1330,24 @@ octave_scalar_struct::print_raw (std::os
   if (Vstruct_levels_to_print >= 0)
     {
       bool max_depth_reached = Vstruct_levels_to_print-- == 0;
 
       bool print_fieldnames_only = max_depth_reached;
 
       increment_indent_level ();
 
-      newline (os);
+      if (! Vcompact_format)
+        newline (os);
+
       indent (os);
       os << "scalar structure containing the fields:";
       newline (os);
-      newline (os);
+      if (! Vcompact_format)
+        newline (os);
 
       increment_indent_level ();
 
       string_vector key_list = map.fieldnames ();
 
       for (octave_idx_type i = 0; i < key_list.length (); i++)
         {
           std::string key = key_list[i];
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -2685,35 +2685,16 @@ install_types (void)
   octave_float_complex_diag_matrix::register_type ();
   octave_perm_matrix::register_type ();
   octave_null_matrix::register_type ();
   octave_null_str::register_type ();
   octave_null_sq_str::register_type ();
   octave_lazy_index::register_type ();
 }
 
-#if 0
-DEFUN (cast, args, ,
-  "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} cast (@var{val}, @var{type})\n\
-Convert @var{val} to the new data type @var{type}.\n\
-@seealso{class, typeinfo}\n\
-@end deftypefn")
-{
-  octave_value retval;
-
-  if (args.length () == 2)
-    error ("cast: not implemented");
-  else
-    print_usage ();
-
-  return retval;
-}
-#endif
-
 DEFUN (sizeof, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} sizeof (@var{val})\n\
 Return the size of @var{val} in bytes.\n\
 @seealso{whos}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -2721,16 +2702,22 @@ Return the size of @var{val} in bytes.\n
   if (args.length () == 1)
     retval = args(0).byte_size ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+%!assert (sizeof (uint64 (ones (3))), 72)
+%!assert (sizeof (double (zeros (2,4))), 64)
+%!assert (sizeof ({"foo", "bar", "baaz"}), 10)
+*/
+
 DEFUN (subsref, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} subsref (@var{val}, @var{idx})\n\
 Perform the subscripted element selection operation according to\n\
 the subscript specified by @var{idx}.\n\
 \n\
 The subscript @var{idx} is expected to be a structure array with\n\
 fields @samp{type} and @samp{subs}.  Valid values for @samp{type}\n\
@@ -2829,8 +2816,68 @@ Note that this is the same as writing @c
       if (! error_state)
         retval = arg0.subsasgn (type, idx, args(2));
     }
   else
     print_usage ();
 
   return retval;
 }
+
+/*
+%!test
+%! a = reshape ([1:25], 5,5);
+%! idx1 = substruct ( "()", {3, 3});
+%! idx2 = substruct ( "()", {2:2:5, 2:2:5});
+%! idx3 = substruct ( "()", {":", [1,5]});
+%! assert (subsref (a, idx1), 13)
+%! assert (subsref (a, idx2), [7 17; 9 19])
+%! assert (subsref (a, idx3), [1:5; 21:25]')
+%! a = subsasgn (a, idx1, 0);
+%! a = subsasgn (a, idx2, 0);
+%! a = subsasgn (a, idx3, 0);
+%! b = [0    6   11   16    0
+%!      0    0   12    0    0
+%!      0    8    0   18    0
+%!      0    0   14    0    0
+%!      0   10   15   20    0];
+%! assert (a,b);
+
+%!test
+%! c = num2cell (reshape ([1:25],5,5));
+%! idx1 = substruct  ( "{}", {3, 3});
+%! idx2 = substruct  ( "()", {2:2:5, 2:2:5});
+%! idx3 = substruct  ( "()", {":", [1,5]});
+%! idx2p = substruct  ( "{}", {2:2:5, 2:2:5});
+%! idx3p = substruct  ( "{}", {":", [1,5]});
+%! assert ({ subsref(c, idx1) }, {13})
+%! assert ({ subsref(c, idx2p) }, {7 9 17 19})
+%! assert ({ subsref(c, idx3p) }, num2cell ([1:5, 21:25]))
+%! c = subsasgn (c, idx1, 0);
+%! c = subsasgn (c, idx2, 0);
+%! c = subsasgn (c, idx3, 0);
+%! d = {0    6   11   16    0
+%!      0    0   12    0    0
+%!      0    8    0   18    0
+%!      0    0   14    0    0
+%!      0   10   15   20    0};
+%! assert (c,d);
+
+%!test
+%! s.a = "ohai";
+%! s.b = "dere";
+%! s.c = 42;
+%! idx1 = substruct (".", "a");
+%! idx2 = substruct (".", "b");
+%! idx3 = substruct (".", "c");
+%! assert (subsref (s, idx1), "ohai")
+%! assert (subsref (s, idx2), "dere")
+%! assert (subsref (s, idx3), 42)
+%! s = subsasgn (s, idx1, "Hello");
+%! s = subsasgn (s, idx2, "There");
+%! s = subsasgn (s, idx3, 163);
+%! t.a = "Hello";
+%! t.b = "There";
+%! t.c = 163;
+%! assert (s, t)
+
+*/
+
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -982,19 +982,18 @@ public:
 
   void print_raw (std::ostream& os,
                           bool pr_as_read_syntax = false) const
     { rep->print_raw (os, pr_as_read_syntax); }
 
   bool print_name_tag (std::ostream& os, const std::string& name) const
     { return rep->print_name_tag (os, name); }
 
-  void print_with_name (std::ostream& os, const std::string& name,
-                        bool print_padding = true) const
-    { rep->print_with_name (os, name, print_padding); }
+  void print_with_name (std::ostream& os, const std::string& name) const
+  { rep->print_with_name (os, name, true); }
 
   int type_id (void) const { return rep->type_id (); }
 
   std::string type_name (void) const { return rep->type_name (); }
 
   std::string class_name (void) const { return rep->class_name (); }
 
   // Unary and binary operations.
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -98,17 +98,17 @@ static bool bank_format = false;
 
 // TRUE means print data in hexadecimal format.
 static int hex_format = 0;
 
 // TRUE means print data in binary-bit-pattern format.
 static int bit_format = 0;
 
 // TRUE means don't put newlines around the column number headers.
-static bool compact_format = false;
+bool Vcompact_format = false;
 
 // TRUE means use an e format.
 static bool print_e = false;
 
 // TRUE means use a g format.
 static bool print_g = false;
 
 // TRUE means print E instead of e for exponent field.
@@ -1653,47 +1653,47 @@ pr_scale_header (std::ostream& os, doubl
     {
       os << "  "
          << std::setw (8) << std::setprecision (1)
          << std::setiosflags (std::ios::scientific|std::ios::left)
          << scale
          << std::resetiosflags (std::ios::scientific|std::ios::left)
          << " *\n";
 
-      if (! compact_format)
+      if (! Vcompact_format)
         os << "\n";
     }
 }
 
 static void
 pr_col_num_header (std::ostream& os, octave_idx_type total_width, int max_width,
                    octave_idx_type lim, octave_idx_type col, int extra_indent)
 {
   if (total_width > max_width && Vsplit_long_rows)
     {
       if (col != 0)
         {
-          if (compact_format)
+          if (Vcompact_format)
             os << "\n";
           else
             os << "\n\n";
         }
 
       octave_idx_type num_cols = lim - col;
 
       os << std::setw (extra_indent) << "";
 
       if (num_cols == 1)
         os << " Column " << col + 1 << ":\n";
       else if (num_cols == 2)
         os << " Columns " << col + 1 << " and " << lim << ":\n";
       else
         os << " Columns " << col + 1 << " through " << lim << ":\n";
 
-      if (! compact_format)
+      if (! Vcompact_format)
         os << "\n";
     }
 }
 
 template <class T>
 /* static */ inline void
 pr_plus_format (std::ostream& os, const T& val)
 {
@@ -1951,17 +1951,20 @@ octave_print_internal (std::ostream& os,
                   os << " ]";
               else
                 os << " ...\n";
             }
           os << ")";
         }
       else
         {
-          os << "Diagonal Matrix\n\n";
+          os << "Diagonal Matrix\n";
+          if (! Vcompact_format)
+            os << "\n";
+
           pr_scale_header (os, scale);
 
           // kluge. Get the true width of a number.
           int zero_fw;
 
             {
               std::ostringstream tmp_oss;
               pr_float (tmp_oss, 0.0, fw, scale);
@@ -1994,105 +1997,107 @@ octave_print_internal (std::ostream& os,
 
                   if (i < nr - 1)
                     os << "\n";
                 }
             }
         }
     }
 }
-#define PRINT_ND_ARRAY(os, nda, NDA_T, ELT_T, MAT_T) \
-  do \
-    { \
-      if (nda.is_empty ()) \
-        print_empty_nd_array (os, nda.dims (), pr_as_read_syntax); \
-      else \
-        { \
- \
-          int ndims = nda.ndims (); \
- \
-          dim_vector dims = nda.dims (); \
- \
-          Array<octave_idx_type> ra_idx (dim_vector (ndims, 1), 0);\
- \
-          octave_idx_type m = 1; \
- \
-          for (int i = 2; i < ndims; i++) \
-            m *= dims(i); \
- \
-          octave_idx_type nr = dims(0); \
-          octave_idx_type nc = dims(1); \
- \
-          for (octave_idx_type i = 0; i < m; i++) \
-            { \
-              octave_quit (); \
- \
-              std::string nm = "ans"; \
- \
-              if (m > 1) \
-                { \
-                  nm += "(:,:,"; \
- \
-                  std::ostringstream buf; \
- \
-                  for (int k = 2; k < ndims; k++) \
-                    { \
-                      buf << ra_idx(k) + 1; \
- \
-                      if (k < ndims - 1) \
-                        buf << ","; \
-                      else \
-                        buf << ")"; \
-                    } \
- \
-                  nm += buf.str (); \
-                } \
- \
-              Array<idx_vector> idx (dim_vector (ndims, 1)); \
- \
-              idx(0) = idx_vector (':'); \
-              idx(1) = idx_vector (':'); \
- \
-              for (int k = 2; k < ndims; k++) \
-                idx(k) = idx_vector (ra_idx(k)); \
- \
-              octave_value page \
-                = MAT_T (Array<ELT_T> (nda.index (idx), dim_vector (nr, nc))); \
- \
-              if (i != m - 1) \
-                { \
-                  page.print_with_name (os, nm); \
-                } \
-              else \
-                { \
-                  page.print_name_tag (os, nm); \
-                  page.print_raw (os); \
-                } \
-              \
-              if (i < m) \
-                NDA_T::increment_index (ra_idx, dims, 2); \
-            } \
-        } \
-    } \
-  while (0)
+
+template <typename NDA_T, typename ELT_T, typename MAT_T>
+void print_nd_array(std::ostream& os, const NDA_T& nda,
+                    bool pr_as_read_syntax)
+{
+
+  if (nda.is_empty ())
+    print_empty_nd_array (os, nda.dims (), pr_as_read_syntax);
+  else
+    {
+
+      int ndims = nda.ndims ();
+
+      dim_vector dims = nda.dims ();
+
+      Array<octave_idx_type> ra_idx (dim_vector (ndims, 1), 0);
+
+      octave_idx_type m = 1;
+
+      for (int i = 2; i < ndims; i++)
+        m *= dims(i);
+
+      octave_idx_type nr = dims(0);
+      octave_idx_type nc = dims(1);
+
+      for (octave_idx_type i = 0; i < m; i++)
+        {
+          octave_quit ();
+
+          std::string nm = "ans";
+
+          if (m > 1)
+            {
+              nm += "(:,:,";
+
+              std::ostringstream buf;
+
+              for (int k = 2; k < ndims; k++)
+                {
+                  buf << ra_idx(k) + 1;
+
+                  if (k < ndims - 1)
+                    buf << ",";
+                  else
+                    buf << ")";
+                }
+
+              nm += buf.str ();
+            }
+
+          Array<idx_vector> idx (dim_vector (ndims, 1));
+
+          idx(0) = idx_vector (':');
+          idx(1) = idx_vector (':');
+
+          for (int k = 2; k < ndims; k++)
+            idx(k) = idx_vector (ra_idx(k));
+
+          octave_value page
+            = MAT_T (Array<ELT_T> (nda.index (idx), dim_vector (nr, nc)));
+
+          if (i != m - 1)
+            {
+              page.print_with_name (os, nm);
+            }
+          else
+            {
+              page.print_name_tag (os, nm);
+              page.print_raw (os);
+            }
+
+          if (i < m)
+            NDA_T::increment_index (ra_idx, dims, 2);
+        }
+    }
+}
 
 void
 octave_print_internal (std::ostream& os, const NDArray& nda,
                        bool pr_as_read_syntax, int extra_indent)
 {
   switch (nda.ndims ())
     {
     case 1:
     case 2:
       octave_print_internal (os, nda.matrix_value (),
                              pr_as_read_syntax, extra_indent);
       break;
 
     default:
-      PRINT_ND_ARRAY (os, nda, NDArray, double, Matrix);
+      print_nd_array <NDArray, double, Matrix> (os, nda, pr_as_read_syntax);
       break;
     }
 }
 
 template <>
 /* static */ inline void
 pr_plus_format<> (std::ostream& os, const Complex& c)
 {
@@ -2362,17 +2367,20 @@ octave_print_internal (std::ostream& os,
                   os << " ]";
               else
                 os << " ...\n";
             }
           os << ")";
         }
       else
         {
-          os << "Diagonal Matrix\n\n";
+          os << "Diagonal Matrix\n";
+          if (! Vcompact_format)
+            os << "\n";
+
           pr_scale_header (os, scale);
 
           // kluge. Get the true width of a number.
           int zero_fw;
 
             {
               std::ostringstream tmp_oss;
               pr_complex (tmp_oss, Complex (0.0), r_fw, i_fw, scale);
@@ -2507,17 +2515,19 @@ octave_print_internal (std::ostream& os,
               else
                 os << " ...\n";
             }
           if (! colp) os << ", :";
           os << ")";
         }
       else
         {
-          os << "Permutation Matrix\n\n";
+          os << "Permutation Matrix\n";
+          if (! Vcompact_format)
+            os << "\n";
 
           for (octave_idx_type col = 0; col < nc; col += inc)
             {
               octave_idx_type lim = col + inc < nc ? col + inc : nc;
 
               pr_col_num_header (os, total_width, max_width, lim, col,
                                  extra_indent);
 
@@ -2550,17 +2560,18 @@ octave_print_internal (std::ostream& os,
     {
     case 1:
     case 2:
       octave_print_internal (os, nda.matrix_value (),
                              pr_as_read_syntax, extra_indent);
       break;
 
     default:
-      PRINT_ND_ARRAY (os, nda, ComplexNDArray, Complex, ComplexMatrix);
+      print_nd_array <ComplexNDArray, Complex,
+                      ComplexMatrix> (os, nda, pr_as_read_syntax);
       break;
     }
 }
 
 void
 octave_print_internal (std::ostream& os, bool d, bool pr_as_read_syntax)
 {
   octave_print_internal (os, double (d), pr_as_read_syntax);
@@ -2751,17 +2762,18 @@ octave_print_internal (std::ostream& os,
     {
     case 1:
     case 2:
       octave_print_internal (os, nda.matrix_value (),
                              pr_as_read_syntax, extra_indent);
       break;
 
     default:
-      PRINT_ND_ARRAY (os, nda, boolNDArray, bool, boolMatrix);
+      print_nd_array<boolNDArray, bool,
+                     boolMatrix> (os, nda, pr_as_read_syntax);
       break;
     }
 }
 
 void
 octave_print_internal (std::ostream& os, const charMatrix& chm,
                        bool pr_as_read_syntax,
                        int /* extra_indent FIXME */,
@@ -2817,17 +2829,18 @@ octave_print_internal (std::ostream& os,
     {
     case 1:
     case 2:
       octave_print_internal (os, nda.matrix_value (),
                              pr_as_read_syntax, extra_indent, pr_as_string);
       break;
 
     default:
-      PRINT_ND_ARRAY (os, nda, charNDArray, char, charMatrix);
+      print_nd_array <charNDArray, char,
+                      charMatrix> (os, nda, pr_as_read_syntax);
       break;
     }
 }
 
 void
 octave_print_internal (std::ostream& os, const std::string& s,
                        bool pr_as_read_syntax, int extra_indent)
 {
@@ -2835,18 +2848,18 @@ octave_print_internal (std::ostream& os,
 
   octave_print_internal (os, nda, pr_as_read_syntax, extra_indent);
 }
 
 void
 octave_print_internal (std::ostream& os, const Array<std::string>& nda,
                        bool pr_as_read_syntax, int /* extra_indent */)
 {
-  // FIXME -- this mostly duplicates the code in the
-  // PRINT_ND_ARRAY macro.
+  // FIXME -- this mostly duplicates the code in the print_nd_array<>
+  // function. Can fix this with std::is_same from C++11.
 
   if (nda.is_empty ())
     print_empty_nd_array (os, nda.dims (), pr_as_read_syntax);
   else if (nda.length () == 1)
     {
       os << nda(0);
     }
   else
@@ -2899,17 +2912,19 @@ octave_print_internal (std::ostream& os,
           Array<std::string> page (nda.index (idx), dim_vector (nr, nc));
 
           // FIXME -- need to do some more work to put these
           // in neatly aligned columns...
 
           octave_idx_type n_rows = page.rows ();
           octave_idx_type n_cols = page.cols ();
 
-          os << nm << " =\n\n";
+          os << nm << " =\n";
+          if (! Vcompact_format)
+            os << "\n";
 
           for (octave_idx_type ii = 0; ii < n_rows; ii++)
             {
               for (octave_idx_type jj = 0; jj < n_cols; jj++)
                 os << "  " << page(ii,jj);
 
               os << "\n";
             }
@@ -3104,18 +3119,18 @@ PRINT_INT_SCALAR_INTERNAL (uint32_t)
 PRINT_INT_SCALAR_INTERNAL (int64_t)
 PRINT_INT_SCALAR_INTERNAL (uint64_t)
 
 template <class T>
 /* static */ inline void
 octave_print_internal_template (std::ostream& os, const intNDArray<T>& nda,
                                 bool pr_as_read_syntax, int extra_indent)
 {
-  // FIXME -- this mostly duplicates the code in the
-  // PRINT_ND_ARRAY macro.
+  // FIXME -- this mostly duplicates the code in the print_nd_array<>
+  // function. Can fix this with std::is_same from C++11.
 
   if (nda.is_empty ())
     print_empty_nd_array (os, nda.dims (), pr_as_read_syntax);
   else if (nda.length () == 1)
     octave_print_internal_template (os, nda(0), pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
       int ndims = nda.ndims ();
@@ -3147,17 +3162,19 @@ octave_print_internal_template (std::ost
                   if (k < ndims - 1)
                     buf << ",";
                   else
                     buf << ")";
                 }
 
               nm += buf.str ();
 
-              os << nm << " =\n\n";
+              os << nm << " =\n";
+              if (! Vcompact_format)
+                os << "\n";
             }
 
           Array<idx_vector> idx (dim_vector (ndims, 1));
 
           idx(0) = idx_vector (':');
           idx(1) = idx_vector (':');
 
           for (int k = 2; k < ndims; k++)
@@ -3252,17 +3269,19 @@ octave_print_internal_template (std::ost
                   if (k < ndims - 1)
                     buf << ",";
                   else
                     buf << ")";
                 }
 
               nm += buf.str ();
 
-              os << nm << " =\n\n";
+              os << nm << " =\n";
+              if (! Vcompact_format)
+                os << "\n";
             }
 
           Array<idx_vector> idx (dim_vector (ndims, 1));
 
           idx(0) = idx_vector (':');
           idx(1) = idx_vector (':');
 
           for (int k = 2; k < ndims; k++)
@@ -3534,17 +3553,17 @@ static void
 init_format_state (void)
 {
   free_format = false;
   plus_format = false;
   rat_format = false;
   bank_format = false;
   hex_format = 0;
   bit_format = 0;
-  compact_format = false;
+  Vcompact_format = false;
   print_e = false;
   print_big_e = false;
   print_g = false;
   print_eng = false;
 }
 
 static void
 set_output_prec_and_fw (int prec, int fw)
@@ -3709,21 +3728,21 @@ set_format_style (int argc, const string
         }
       else if (arg == "none")
         {
           init_format_state ();
           free_format = true;
         }
       else if (arg == "compact")
         {
-          compact_format = true;
+          Vcompact_format = true;
         }
       else if (arg == "loose")
         {
-          compact_format = false;
+          Vcompact_format = false;
         }
       else
         error ("format: unrecognized format state `%s'", arg.c_str ());
     }
   else
     {
       init_format_state ();
       set_output_prec_and_fw (5, 10);
@@ -3885,22 +3904,22 @@ as the ratio of small integers.\n\
 For example, with the @samp{rat} format,\n\
 @code{pi} is displayed as @code{355/113}.\n\
 @end table\n\
 \n\
 The following two options affect the display of all matrices.\n\
 \n\
 @table @code\n\
 @item compact\n\
-Remove extra blank space around column number labels producing more compact\n\
-output with more data per page.\n\
+Remove blank lines around column number labels and between\n\
+matrices producing more compact output with more data per page.\n\
 \n\
 @item loose\n\
-Insert blank lines above and below column number labels to produce a more\n\
-readable output with less data per page.  (default).\n\
+Insert blank lines above and below column number labels and between matrices\n\
+to produce a more readable output with less data per page.  (default).\n\
 @end table\n\
 @seealso{fixed_point_format, output_max_field_width, output_precision, split_long_rows, rats}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
 
diff --git a/src/pr-output.h b/src/pr-output.h
--- a/src/pr-output.h
+++ b/src/pr-output.h
@@ -251,9 +251,12 @@ octave_print_internal (std::ostream& os,
                        bool pr_as_read_syntax = false,
                        int extra_indent = 0,
                        bool pr_as_string = false);
 
 // TRUE means that the dimensions of empty objects should be printed
 // like this: x = [](2x0).
 extern bool Vprint_empty_dimensions;
 
+// TRUE means don't put empty lines in output
+extern bool Vcompact_format;
+
 #endif
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -1363,17 +1363,19 @@ octave_vsnprintf (const char *fmt, va_li
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE_FOR_VSNPRINTF;
 
       nchars = octave_raw_vsnprintf (buf, size, fmt, saved_args);
 
       va_end (saved_args);
 
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-      if (nchars > -1 && nchars < size)
+      // Cast to avoid signed/unsigned comparison is safe due to
+      // short-circuiting
+      if (nchars > -1 && static_cast<size_t>(nchars) < size)
         break;
       else
         {
           delete [] buf;
 
           size = nchars + 1;;
 
           buf = new char [size];
