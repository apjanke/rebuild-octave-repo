# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1447017267 18000
#      Sun Nov 08 16:14:27 2015 -0500
# Node ID 5f04bfc7c17ab3f05026cff5e0dd42c18a9b7c9c
# Parent  e468e4211df9429af853c52bbe5283a8f99e781b
backout changeset 18f38ed43962

diff --git a/libinterp/corefcn/daspk.cc b/libinterp/corefcn/daspk.cc
--- a/libinterp/corefcn/daspk.cc
+++ b/libinterp/corefcn/daspk.cc
@@ -85,17 +85,17 @@ daspk_user_function (const ColumnVector&
       if (tlen > 0 && tmp(0).is_defined ())
         {
           if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
             {
               warning ("daspk: ignoring imaginary part returned from user-supplied function");
               warned_fcn_imaginary = true;
             }
 
-          retval = tmp(0).vector_value ();
+          retval = ColumnVector (tmp(0).vector_value ());
 
           if (tlen > 1)
             ires = tmp(1).int_value ();
 
           if (error_state || retval.numel () == 0)
             gripe_user_supplied_eval ("daspk");
         }
       else
@@ -388,30 +388,42 @@ parameters for @code{daspk}.\n\
                             daspk_fcn = 0;
                           }
                       }
                   }
                 }
             }
         }
 
-      if (! daspk_fcn)
+      if (error_state || ! daspk_fcn)
         DASPK_ABORT ();
 
-      ColumnVector state = args(1).vector_value ("expecting state vector as second argument");
+      ColumnVector state = ColumnVector (args(1).vector_value ());
+
+      if (error_state)
+        DASPK_ABORT1 ("expecting state vector as second argument");
+
+      ColumnVector deriv (args(2).vector_value ());
 
-      ColumnVector deriv = args(2).vector_value ("expecting derivative vector as third argument");
+      if (error_state)
+        DASPK_ABORT1 ("expecting derivative vector as third argument");
 
-      ColumnVector out_times = args(3).vector_value ("expecting output time vector as fourth argument");
+      ColumnVector out_times (args(3).vector_value ());
+
+      if (error_state)
+        DASPK_ABORT1 ("expecting output time vector as fourth argument");
 
       ColumnVector crit_times;
       int crit_times_set = 0;
       if (nargin > 4)
         {
-          crit_times = args(4).vector_value ("expecting critical time vector as fifth argument");
+          crit_times = ColumnVector (args(4).vector_value ());
+
+          if (error_state)
+            DASPK_ABORT1 ("expecting critical time vector as fifth argument");
 
           crit_times_set = 1;
         }
 
       if (state.numel () != deriv.numel ())
         DASPK_ABORT1 ("x and xdot must have the same size");
 
       double tzero = out_times (0);
diff --git a/libinterp/corefcn/dasrt.cc b/libinterp/corefcn/dasrt.cc
--- a/libinterp/corefcn/dasrt.cc
+++ b/libinterp/corefcn/dasrt.cc
@@ -84,19 +84,19 @@ dasrt_user_f (const ColumnVector& x, con
       if (tmp.length () > 0 && tmp(0).is_defined ())
         {
           if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
             {
               warning ("dasrt: ignoring imaginary part returned from user-supplied function");
               warned_fcn_imaginary = true;
             }
 
-          retval = tmp(0).vector_value ("dasrt: evaluation of user-supplied function failed");
+          retval = ColumnVector (tmp(0).vector_value ());
 
-          if (retval.numel () == 0)
+          if (error_state || retval.numel () == 0)
             gripe_user_supplied_eval ("dasrt");
         }
       else
         gripe_user_supplied_eval ("dasrt");
     }
 
   return retval;
 }
@@ -124,19 +124,19 @@ dasrt_user_cf (const ColumnVector& x, do
       if (tmp.length () > 0 && tmp(0).is_defined ())
         {
           if (! warned_cf_imaginary && tmp(0).is_complex_type ())
             {
               warning ("dasrt: ignoring imaginary part returned from user-supplied constraint function");
               warned_cf_imaginary = true;
             }
 
-          retval = tmp(0).vector_value ("dasrt: evaluation of user-supplied function failed");
+          retval = ColumnVector (tmp(0).vector_value ());
 
-          if (retval.numel () == 0)
+          if (error_state || retval.numel () == 0)
             gripe_user_supplied_eval ("dasrt");
         }
       else
         gripe_user_supplied_eval ("dasrt");
     }
 
   return retval;
 }
@@ -472,17 +472,17 @@ parameters for @code{dasrt}.\n\
 
             default:
               DASRT_ABORT1
                 ("first arg should be a string or 2-element string array");
             }
         }
     }
 
-  if (! dasrt_f)
+  if (error_state || (! dasrt_f))
     DASRT_ABORT;
 
   DAERTFunc func (dasrt_user_f);
 
   argp++;
 
   if (args(1).is_function_handle () || args(1).is_inline_function ())
     {
@@ -501,34 +501,44 @@ parameters for @code{dasrt}.\n\
       if (! dasrt_cf)
         DASRT_ABORT1 ("expecting function name as argument 2");
 
       argp++;
 
       func.set_constraint_function (dasrt_user_cf);
     }
 
-  ColumnVector state = args(argp).vector_value ("expecting state vector as argument %d", ++argp);
+  ColumnVector state (args(argp++).vector_value ());
+
+  if (error_state)
+    DASRT_ABORT2 ("expecting state vector as argument %d", argp);
+
+  ColumnVector stateprime (args(argp++).vector_value ());
 
-  ColumnVector stateprime = args(argp).vector_value ("expecting time derivative of state vector as argument %d", argp);
-  argp++;
+  if (error_state)
+    DASRT_ABORT2 ("expecting time derivative of state vector as argument %d",
+                  argp);
 
-  ColumnVector out_times = args(argp).vector_value ("expecting output time vector as %s argument %d", argp);
-  argp++;
+  ColumnVector out_times (args(argp++).vector_value ());
+
+  if (error_state)
+    DASRT_ABORT2 ("expecting output time vector as %s argument %d", argp);
 
   double tzero = out_times (0);
 
   ColumnVector crit_times;
 
   bool crit_times_set = false;
 
   if (argp < nargin)
     {
-      crit_times = args(argp).vector_value ("expecting critical time vector as argument %d", argp);
-      argp++;
+      crit_times = ColumnVector (args(argp++).vector_value ());
+
+      if (error_state)
+        DASRT_ABORT2 ("expecting critical time vector as argument %d", argp);
 
       crit_times_set = true;
     }
 
   if (dasrt_j)
     func.set_jacobian_function (dasrt_user_j);
 
   DASRT_result output;
diff --git a/libinterp/corefcn/dassl.cc b/libinterp/corefcn/dassl.cc
--- a/libinterp/corefcn/dassl.cc
+++ b/libinterp/corefcn/dassl.cc
@@ -85,22 +85,22 @@ dassl_user_function (const ColumnVector&
       if (tlen > 0 && tmp(0).is_defined ())
         {
           if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
             {
               warning ("dassl: ignoring imaginary part returned from user-supplied function");
               warned_fcn_imaginary = true;
             }
 
-          retval = tmp(0).vector_value ();
+          retval = ColumnVector (tmp(0).vector_value ());
 
           if (tlen > 1)
             ires = tmp(1).int_value ();
 
-          if (retval.numel () == 0)
+          if (error_state || retval.numel () == 0)
             gripe_user_supplied_eval ("dassl");
         }
       else
         gripe_user_supplied_eval ("dassl");
     }
 
   return retval;
 }
@@ -136,17 +136,17 @@ dassl_user_jacobian (const ColumnVector&
           if (! warned_jac_imaginary && tmp(0).is_complex_type ())
             {
               warning ("dassl: ignoring imaginary part returned from user-supplied jacobian function");
               warned_jac_imaginary = true;
             }
 
           retval = tmp(0).matrix_value ();
 
-          if (retval.numel () == 0)
+          if (error_state || retval.numel () == 0)
             gripe_user_supplied_eval ("dassl");
         }
       else
         gripe_user_supplied_eval ("dassl");
     }
 
   return retval;
 }
@@ -389,30 +389,42 @@ parameters for @code{dassl}.\n\
                             dassl_fcn = 0;
                           }
                       }
                   }
                 }
             }
         }
 
-      if (! dassl_fcn)
+      if (error_state || ! dassl_fcn)
         DASSL_ABORT ();
 
-      ColumnVector state = args(1).vector_value ("expecting state vector as second argument");
+      ColumnVector state = ColumnVector (args(1).vector_value ());
+
+      if (error_state)
+        DASSL_ABORT1 ("expecting state vector as second argument");
+
+      ColumnVector deriv (args(2).vector_value ());
 
-      ColumnVector deriv = args(2).vector_value ("expecting derivative vector as third argument");
+      if (error_state)
+        DASSL_ABORT1 ("expecting derivative vector as third argument");
 
-      ColumnVector out_times = args(3).vector_value ("expecting output time vector as fourth argument");
+      ColumnVector out_times (args(3).vector_value ());
+
+      if (error_state)
+        DASSL_ABORT1 ("expecting output time vector as fourth argument");
 
       ColumnVector crit_times;
       int crit_times_set = 0;
       if (nargin > 4)
         {
-          crit_times = args(4).vector_value ("expecting critical time vector as fifth argument");
+          crit_times = ColumnVector (args(4).vector_value ());
+
+          if (error_state)
+            DASSL_ABORT1 ("expecting critical time vector as fifth argument");
 
           crit_times_set = 1;
         }
 
       if (state.numel () != deriv.numel ())
         DASSL_ABORT1 ("x and xdot must have the same size");
 
       double tzero = out_times (0);
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -1316,46 +1316,51 @@ static octave_value
 do_fread (octave_stream& os, const octave_value& size_arg,
           const octave_value& prec_arg, const octave_value& skip_arg,
           const octave_value& arch_arg, octave_idx_type& count)
 {
   octave_value retval;
 
   count = -1;
 
-  Array<double> size = size_arg.vector_value ("fread: invalid SIZE specified");
-
-  std::string prec = prec_arg.string_value ("fread: PRECISION must be a string");
-
-  int block_size = 1;
-  oct_data_conv::data_type input_type;
-  oct_data_conv::data_type output_type;
-
-  oct_data_conv::string_to_data_type (prec, block_size,
-                                      input_type, output_type);
+  Array<double> size = size_arg.vector_value ();
 
   if (! error_state)
     {
-      int skip = skip_arg.int_value (true);
+      std::string prec = prec_arg.string_value ("fread: PRECISION must be a string");
+
+      int block_size = 1;
+      oct_data_conv::data_type input_type;
+      oct_data_conv::data_type output_type;
+
+      oct_data_conv::string_to_data_type (prec, block_size,
+                                          input_type, output_type);
 
       if (! error_state)
         {
-          std::string arch = arch_arg.string_value ("fread: ARCH architecture type must be a string");
+          int skip = skip_arg.int_value (true);
+
+          if (! error_state)
+            {
+              std::string arch = arch_arg.string_value ("fread: ARCH architecture type must be a string");
 
-          oct_mach_info::float_format flt_fmt
-            = oct_mach_info::string_to_float_format (arch);
+              oct_mach_info::float_format flt_fmt
+                = oct_mach_info::string_to_float_format (arch);
 
-          retval = os.read (size, block_size, input_type,
-                            output_type, skip, flt_fmt, count);
+              retval = os.read (size, block_size, input_type,
+                                output_type, skip, flt_fmt, count);
+            }
+          else
+            error ("fread: SKIP must be an integer");
         }
       else
-        error ("fread: SKIP must be an integer");
+        error ("fread: invalid PRECISION specified");
     }
   else
-    error ("fread: invalid PRECISION specified");
+    error ("fread: invalid SIZE specified");
 
   return retval;
 }
 
 DEFUN (fread, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} fread (@var{fid})\n\
 @deftypefnx {Built-in Function} {@var{val} =} fread (@var{fid}, @var{size})\n\
diff --git a/libinterp/corefcn/filter.cc b/libinterp/corefcn/filter.cc
--- a/libinterp/corefcn/filter.cc
+++ b/libinterp/corefcn/filter.cc
@@ -435,185 +435,205 @@ H(z) = ---------------------\n\
 
   if (args(0).is_complex_type ()
       || args(1).is_complex_type ()
       || args(2).is_complex_type ()
       || (nargin >= 4 && args(3).is_complex_type ()))
     {
       if (isfloat)
         {
-          FloatComplexColumnVector b (args(0).float_complex_vector_value (errmsg));
-          FloatComplexColumnVector a (args(1).float_complex_vector_value (errmsg));
+          FloatComplexColumnVector b (args(0).float_complex_vector_value ());
+          FloatComplexColumnVector a (args(1).float_complex_vector_value ());
 
           FloatComplexNDArray x (args(2).float_complex_array_value ());
 
-          FloatComplexNDArray si;
-
-          if (nargin == 3 || args(3).is_empty ())
-            {
-              octave_idx_type a_len = a.numel ();
-              octave_idx_type b_len = b.numel ();
-
-              octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
-
-              dim_vector si_dims = x.dims ();
-              for (int i = dim; i > 0; i--)
-                si_dims(i) = si_dims(i-1);
-              si_dims(0) = si_len;
-
-              si.resize (si_dims, 0.0);
-            }
-          else
-            {
-              si = args(3).float_complex_array_value ();
-
-              if (si.is_vector () && x.is_vector ())
-                si = si.reshape (dim_vector (si.numel (), 1));
-            }
-
           if (! error_state)
             {
-              FloatComplexNDArray y (filter (b, a, x, si, dim));
+              FloatComplexNDArray si;
+
+              if (nargin == 3 || args(3).is_empty ())
+                {
+                  octave_idx_type a_len = a.numel ();
+                  octave_idx_type b_len = b.numel ();
+
+                  octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
+
+                  dim_vector si_dims = x.dims ();
+                  for (int i = dim; i > 0; i--)
+                    si_dims(i) = si_dims(i-1);
+                  si_dims(0) = si_len;
 
-              if (nargout == 2)
-                retval(1) = si;
+                  si.resize (si_dims, 0.0);
+                }
+              else
+                {
+                  si = args(3).float_complex_array_value ();
+
+                  if (si.is_vector () && x.is_vector ())
+                    si = si.reshape (dim_vector (si.numel (), 1));
+                }
 
-              retval(0) = y;
+              if (! error_state)
+                {
+                  FloatComplexNDArray y (filter (b, a, x, si, dim));
+
+                  if (nargout == 2)
+                    retval(1) = si;
+
+                  retval(0) = y;
+                }
+              else
+                error (errmsg);
             }
           else
             error (errmsg);
         }
       else
         {
-          ComplexColumnVector b (args(0).complex_vector_value (errmsg));
-          ComplexColumnVector a (args(1).complex_vector_value (errmsg));
+          ComplexColumnVector b (args(0).complex_vector_value ());
+          ComplexColumnVector a (args(1).complex_vector_value ());
 
           ComplexNDArray x (args(2).complex_array_value ());
 
-          ComplexNDArray si;
-
-          if (nargin == 3 || args(3).is_empty ())
-            {
-              octave_idx_type a_len = a.numel ();
-              octave_idx_type b_len = b.numel ();
-
-              octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
-
-              dim_vector si_dims = x.dims ();
-              for (int i = dim; i > 0; i--)
-                si_dims(i) = si_dims(i-1);
-              si_dims(0) = si_len;
-
-              si.resize (si_dims, 0.0);
-            }
-          else
-            {
-              si = args(3).complex_array_value ();
-
-              if (si.is_vector () && x.is_vector ())
-                si = si.reshape (dim_vector (si.numel (), 1));
-            }
-
           if (! error_state)
             {
-              ComplexNDArray y (filter (b, a, x, si, dim));
+              ComplexNDArray si;
+
+              if (nargin == 3 || args(3).is_empty ())
+                {
+                  octave_idx_type a_len = a.numel ();
+                  octave_idx_type b_len = b.numel ();
+
+                  octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
+
+                  dim_vector si_dims = x.dims ();
+                  for (int i = dim; i > 0; i--)
+                    si_dims(i) = si_dims(i-1);
+                  si_dims(0) = si_len;
 
-              if (nargout == 2)
-                retval(1) = si;
+                  si.resize (si_dims, 0.0);
+                }
+              else
+                {
+                  si = args(3).complex_array_value ();
+
+                  if (si.is_vector () && x.is_vector ())
+                    si = si.reshape (dim_vector (si.numel (), 1));
+                }
 
-              retval(0) = y;
+              if (! error_state)
+                {
+                  ComplexNDArray y (filter (b, a, x, si, dim));
+
+                  if (nargout == 2)
+                    retval(1) = si;
+
+                  retval(0) = y;
+                }
+              else
+                error (errmsg);
             }
           else
             error (errmsg);
         }
     }
   else
     {
       if (isfloat)
         {
-          FloatColumnVector b (args(0).float_vector_value (errmsg));
-          FloatColumnVector a (args(1).float_vector_value (errmsg));
+          FloatColumnVector b (args(0).float_vector_value ());
+          FloatColumnVector a (args(1).float_vector_value ());
 
           FloatNDArray x (args(2).float_array_value ());
 
-          FloatNDArray si;
-
-          if (nargin == 3 || args(3).is_empty ())
-            {
-              octave_idx_type a_len = a.numel ();
-              octave_idx_type b_len = b.numel ();
-
-              octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
-
-              dim_vector si_dims = x.dims ();
-              for (int i = dim; i > 0; i--)
-                si_dims(i) = si_dims(i-1);
-              si_dims(0) = si_len;
-
-              si.resize (si_dims, 0.0);
-            }
-          else
-            {
-              si = args(3).float_array_value ();
-
-              if (si.is_vector () && x.is_vector ())
-                si = si.reshape (dim_vector (si.numel (), 1));
-            }
-
           if (! error_state)
             {
-              FloatNDArray y (filter (b, a, x, si, dim));
+              FloatNDArray si;
+
+              if (nargin == 3 || args(3).is_empty ())
+                {
+                  octave_idx_type a_len = a.numel ();
+                  octave_idx_type b_len = b.numel ();
+
+                  octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
+
+                  dim_vector si_dims = x.dims ();
+                  for (int i = dim; i > 0; i--)
+                    si_dims(i) = si_dims(i-1);
+                  si_dims(0) = si_len;
 
-              if (nargout == 2)
-                retval(1) = si;
+                  si.resize (si_dims, 0.0);
+                }
+              else
+                {
+                  si = args(3).float_array_value ();
+
+                  if (si.is_vector () && x.is_vector ())
+                    si = si.reshape (dim_vector (si.numel (), 1));
+                }
 
-              retval(0) = y;
+              if (! error_state)
+                {
+                  FloatNDArray y (filter (b, a, x, si, dim));
+
+                  if (nargout == 2)
+                    retval(1) = si;
+
+                  retval(0) = y;
+                }
+              else
+                error (errmsg);
             }
           else
             error (errmsg);
         }
       else
         {
-          ColumnVector b (args(0).vector_value (errmsg));
-          ColumnVector a (args(1).vector_value (errmsg));
+          ColumnVector b (args(0).vector_value ());
+          ColumnVector a (args(1).vector_value ());
 
           NDArray x (args(2).array_value ());
 
-          NDArray si;
-
-          if (nargin == 3 || args(3).is_empty ())
-            {
-              octave_idx_type a_len = a.numel ();
-              octave_idx_type b_len = b.numel ();
-
-              octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
-
-              dim_vector si_dims = x.dims ();
-              for (int i = dim; i > 0; i--)
-                si_dims(i) = si_dims(i-1);
-              si_dims(0) = si_len;
-
-              si.resize (si_dims, 0.0);
-            }
-          else
-            {
-              si = args(3).array_value ();
-
-              if (si.is_vector () && x.is_vector ())
-                si = si.reshape (dim_vector (si.numel (), 1));
-            }
-
           if (! error_state)
             {
-              NDArray y (filter (b, a, x, si, dim));
+              NDArray si;
+
+              if (nargin == 3 || args(3).is_empty ())
+                {
+                  octave_idx_type a_len = a.numel ();
+                  octave_idx_type b_len = b.numel ();
+
+                  octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
+
+                  dim_vector si_dims = x.dims ();
+                  for (int i = dim; i > 0; i--)
+                    si_dims(i) = si_dims(i-1);
+                  si_dims(0) = si_len;
 
-              if (nargout == 2)
-                retval(1) = si;
+                  si.resize (si_dims, 0.0);
+                }
+              else
+                {
+                  si = args(3).array_value ();
+
+                  if (si.is_vector () && x.is_vector ())
+                    si = si.reshape (dim_vector (si.numel (), 1));
+                }
 
-              retval(0) = y;
+              if (! error_state)
+                {
+                  NDArray y (filter (b, a, x, si, dim));
+
+                  if (nargout == 2)
+                    retval(1) = si;
+
+                  retval(0) = y;
+                }
+              else
+                error (errmsg);
             }
           else
             error (errmsg);
         }
     }
 
   return retval;
 }
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -9843,109 +9843,114 @@ being @qcode{\"portrait\"}.\n\
 
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin > 0)
     {
       // get vector of graphics handles
-      ColumnVector hcv (args(0).vector_value ("set: expecting graphics handle as first argument"));
-
-      bool request_drawnow = false;
-
-      // loop over graphics objects
-      for (octave_idx_type n = 0; n < hcv.numel (); n++)
-        {
-          graphics_object go = gh_manager::get_object (hcv(n));
-
-          if (go)
-            {
-              if (nargin == 3
-                  && args(1).is_cellstr () && args(2).is_cell ())
+      ColumnVector hcv (args(0).vector_value ());
+
+      if (! error_state)
+        {
+          bool request_drawnow = false;
+
+          // loop over graphics objects
+          for (octave_idx_type n = 0; n < hcv.numel (); n++)
+            {
+              graphics_object go = gh_manager::get_object (hcv(n));
+
+              if (go)
                 {
-                  if (args(2).cell_value ().rows () == 1)
+                  if (nargin == 3
+                      && args(1).is_cellstr () && args(2).is_cell ())
                     {
-                      go.set (args(1).cellstr_value (),
-                              args(2).cell_value (), 0);
-                    }
-                  else if (hcv.numel () == args(2).cell_value ().rows ())
-                    {
-                      go.set (args(1).cellstr_value (),
-                              args(2).cell_value (), n);
+                      if (args(2).cell_value ().rows () == 1)
+                        {
+                          go.set (args(1).cellstr_value (),
+                                  args(2).cell_value (), 0);
+                        }
+                      else if (hcv.numel () == args(2).cell_value ().rows ())
+                        {
+                          go.set (args(1).cellstr_value (),
+                                  args(2).cell_value (), n);
+                        }
+                      else
+                        {
+                          error ("set: number of graphics handles must match number of value rows (%d != %d)",
+                                 hcv.numel (), args(2).cell_value ().rows ());
+                          break;
+
+                        }
                     }
-                  else
+                  else if (nargin == 2 && args(1).is_map ())
                     {
-                      error ("set: number of graphics handles must match number of value rows (%d != %d)",
-                             hcv.numel (), args(2).cell_value ().rows ());
-                      break;
-
+                      go.set (args(1).map_value ());
                     }
-                }
-              else if (nargin == 2 && args(1).is_map ())
-                {
-                  go.set (args(1).map_value ());
-                }
-              else if (nargin == 2 && args(1).is_string ())
-                {
-                  std::string property = args(1).string_value ();
-
-                  octave_map pmap = go.values_as_struct ();
-
-                  if (go.has_readonly_property (property))
-                    if (nargout != 0)
-                      retval = Matrix ();
-                    else
-                      octave_stdout << "set: " << property
-                                    <<" is read-only" << std::endl;
-                  else if (pmap.isfield (property))
+                  else if (nargin == 2 && args(1).is_string ())
+                    {
+                      std::string property = args(1).string_value ();
+
+                      octave_map pmap = go.values_as_struct ();
+
+                      if (go.has_readonly_property (property))
+                        if (nargout != 0)
+                          retval = Matrix ();
+                        else
+                          octave_stdout << "set: " << property
+                                        <<" is read-only" << std::endl;
+                      else if (pmap.isfield (property))
+                        {
+                          if (nargout != 0)
+                            retval = pmap.getfield (property)(0);
+                          else
+                            {
+                              std::string s = go.value_as_string (property);
+
+                              octave_stdout << s;
+                            }
+                        }
+                      else
+                        {
+                          error ("set: unknown property");
+                          break;
+                        }
+                    }
+                  else if (nargin == 1)
                     {
                       if (nargout != 0)
-                        retval = pmap.getfield (property)(0);
+                        retval = go.values_as_struct ();
                       else
                         {
-                          std::string s = go.value_as_string (property);
+                          std::string s = go.values_as_string ();
 
                           octave_stdout << s;
                         }
                     }
                   else
                     {
-                      error ("set: unknown property");
-                      break;
-                    }
-                }
-              else if (nargin == 1)
-                {
-                  if (nargout != 0)
-                    retval = go.values_as_struct ();
-                  else
-                    {
-                      std::string s = go.values_as_string ();
-
-                      octave_stdout << s;
+                      go.set (args.splice (0, 1));
+                      request_drawnow = true;
                     }
                 }
               else
                 {
-                  go.set (args.splice (0, 1));
-                  request_drawnow = true;
+                  error ("set: invalid handle (= %g)", hcv(n));
+                  break;
                 }
-            }
-          else
-            {
-              error ("set: invalid handle (= %g)", hcv(n));
-              break;
-            }
-
-          request_drawnow = true;
-        }
-
-      if (request_drawnow)
-        Vdrawnow_requested = true;
+
+              request_drawnow = true;
+            }
+
+          if (request_drawnow)
+            Vdrawnow_requested = true;
+        }
+      else
+        error ("set: expecting graphics handle as first argument");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 static std::string
@@ -9990,93 +9995,98 @@ lists respectively.\n\
   if (nargin == 1 || nargin == 2)
     {
       if (args(0).is_empty ())
         {
           retval = Matrix ();
           return retval;
         }
 
-      ColumnVector hcv (args(0).vector_value ("get: expecting graphics handle as first argument"));
-
-      octave_idx_type len = hcv.numel ();
-
-      if (nargin == 1 && len > 1)
-        {
-          std::string typ0 = get_graphics_object_type (hcv(0));
-
-          for (octave_idx_type n = 1; n < len; n++)
-            {
-              std::string typ = get_graphics_object_type (hcv(n));
-
-              if (typ != typ0)
+      ColumnVector hcv (args(0).vector_value ());
+
+      if (! error_state)
+        {
+          octave_idx_type len = hcv.numel ();
+
+          if (nargin == 1 && len > 1)
+            {
+              std::string typ0 = get_graphics_object_type (hcv(0));
+
+              for (octave_idx_type n = 1; n < len; n++)
                 {
-                  error ("get: vector of handles must all have same type");
-                  break;
-                }
-            }
-        }
-
-      if (nargin > 1 && args(1).is_cellstr ())
-        {
-          Array<std::string> plist = args(1).cellstr_value ("get: expecting property name or cell array of property names as second argument");
-
-          octave_idx_type plen = plist.numel ();
-
-          use_cell_format = true;
-
-          vals.resize (dim_vector (len, plen));
-
-          for (octave_idx_type n = 0; n < len; n++)
-            {
-              graphics_object go = gh_manager::get_object (hcv(n));
-
-              if (go)
-                {
-                  for (octave_idx_type m = 0; m < plen; m++)
+                  std::string typ = get_graphics_object_type (hcv(n));
+
+                  if (typ != typ0)
                     {
-                      caseless_str property = plist(m);
-
-                      vals(n, m) = go.get (property);
+                      error ("get: vector of handles must all have same type");
+                      break;
                     }
                 }
-              else
+            }
+
+          if (nargin > 1 && args(1).is_cellstr ())
+            {
+              Array<std::string> plist = args(1).cellstr_value ("get: expecting property name or cell array of property names as second argument");
+
+              octave_idx_type plen = plist.numel ();
+
+              use_cell_format = true;
+
+              vals.resize (dim_vector (len, plen));
+
+              for (octave_idx_type n = 0; n < len; n++)
                 {
-                  error ("get: invalid handle (= %g)", hcv(n));
-                  break;
+                  graphics_object go = gh_manager::get_object (hcv(n));
+
+                  if (go)
+                    {
+                      for (octave_idx_type m = 0; m < plen; m++)
+                        {
+                          caseless_str property = plist(m);
+
+                          vals(n, m) = go.get (property);
+                        }
+                    }
+                  else
+                    {
+                      error ("get: invalid handle (= %g)", hcv(n));
+                      break;
+                    }
+                }
+            }
+          else
+            {
+              caseless_str property;
+
+              if (nargin > 1)
+                property = args(1).string_value ("get: expecting property name or cell array of property names as second argument");
+
+              vals.resize (dim_vector (len, 1));
+
+              for (octave_idx_type n = 0; n < len; n++)
+                {
+                  graphics_object go = gh_manager::get_object (hcv(n));
+
+                  if (go)
+                    {
+                      if (nargin == 1)
+                        vals(n) = go.get ();
+                      else
+                        vals(n) = go.get (property);
+                    }
+                  else
+                    {
+                      error ("get: invalid handle (= %g)", hcv(n));
+                      break;
+                    }
                 }
             }
         }
       else
-        {
-          caseless_str property;
-
-          if (nargin > 1)
-            property = args(1).string_value ("get: expecting property name or cell array of property names as second argument");
-
-          vals.resize (dim_vector (len, 1));
-
-          for (octave_idx_type n = 0; n < len; n++)
-            {
-              graphics_object go = gh_manager::get_object (hcv(n));
-
-              if (go)
-                {
-                  if (nargin == 1)
-                    vals(n) = go.get ();
-                  else
-                    vals(n) = go.get (property);
-                }
-              else
-                {
-                  error ("get: invalid handle (= %g)", hcv(n));
-                  break;
-                }
-            }
-        }
+        error ("get: expecting graphics handle as first argument");
     }
   else
     print_usage ();
 
   if (use_cell_format)
     retval = vals;
   else
     {
@@ -10121,34 +10131,39 @@ Undocumented internal function.\n\
   octave_value retval;
 
   Cell vals;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      ColumnVector hcv (args(0).vector_value ("get: expecting graphics handle as first argument"));
-
-      octave_idx_type len = hcv.numel ();
-
-      vals.resize (dim_vector (len, 1));
-
-      for (octave_idx_type n = 0; n < len; n++)
-        {
-          graphics_object go = gh_manager::get_object (hcv(n));
-
-          if (go)
-            vals(n) = go.get (true);
-          else
-            {
-              error ("get: invalid handle (= %g)", hcv(n));
-              break;
-            }
-        }
+      ColumnVector hcv (args(0).vector_value ());
+
+      if (! error_state)
+        {
+          octave_idx_type len = hcv.numel ();
+
+          vals.resize (dim_vector (len, 1));
+
+          for (octave_idx_type n = 0; n < len; n++)
+            {
+              graphics_object go = gh_manager::get_object (hcv(n));
+
+              if (go)
+                vals(n) = go.get (true);
+              else
+                {
+                  error ("get: invalid handle (= %g)", hcv(n));
+                  break;
+                }
+            }
+        }
+      else
+        error ("get: expecting graphics handle as first argument");
     }
   else
     print_usage ();
 
   octave_idx_type len = vals.numel ();
 
   if (len > 1)
     retval = vals;
diff --git a/libinterp/corefcn/lsode.cc b/libinterp/corefcn/lsode.cc
--- a/libinterp/corefcn/lsode.cc
+++ b/libinterp/corefcn/lsode.cc
@@ -81,19 +81,19 @@ lsode_user_function (const ColumnVector&
       if (tmp.length () > 0 && tmp(0).is_defined ())
         {
           if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
             {
               warning ("lsode: ignoring imaginary part returned from user-supplied function");
               warned_fcn_imaginary = true;
             }
 
-          retval = tmp(0).vector_value ("lsode: evaluation of user-supplied function failed");
+          retval = ColumnVector (tmp(0).vector_value ());
 
-          if (retval.numel () == 0)
+          if (error_state || retval.numel () == 0)
             gripe_user_supplied_eval ("lsode");
         }
       else
         gripe_user_supplied_eval ("lsode");
     }
 
   return retval;
 }
@@ -399,26 +399,35 @@ parameters for @code{lsode}.\n\
                   ("first arg should be a string or 2-element string array");
                 }
             }
         }
 
       if (error_state || ! lsode_fcn)
         LSODE_ABORT ();
 
-      ColumnVector state = args(1).vector_value ("lsode: expecting state vector as second argument");
+      ColumnVector state (args(1).vector_value ());
+
+      if (error_state)
+        LSODE_ABORT1 ("expecting state vector as second argument");
 
-      ColumnVector out_times = args(2).vector_value ("lsode: expecting output time vector as third argument");
+      ColumnVector out_times (args(2).vector_value ());
+
+      if (error_state)
+        LSODE_ABORT1 ("expecting output time vector as third argument");
 
       ColumnVector crit_times;
 
       int crit_times_set = 0;
       if (nargin > 3)
         {
-          crit_times = args(3).vector_value ("lsode: expecting critical time vector as fourth argument");
+          crit_times = ColumnVector (args(3).vector_value ());
+
+          if (error_state)
+            LSODE_ABORT1 ("expecting critical time vector as fourth argument");
 
           crit_times_set = 1;
         }
 
       double tzero = out_times (0);
 
       ODEFunc func (lsode_user_function);
       if (lsode_jac)
diff --git a/libinterp/corefcn/matrix_type.cc b/libinterp/corefcn/matrix_type.cc
--- a/libinterp/corefcn/matrix_type.cc
+++ b/libinterp/corefcn/matrix_type.cc
@@ -271,31 +271,37 @@ LU@tie{}factorization.  Once the matrix 
               else if (str_typ == "unknown")
                 mattyp.invalidate_type ();
               else
                 error ("matrix_type: Unknown matrix type %s", str_typ.c_str ());
 
               if (nargin == 3
                   && (str_typ == "upper" || str_typ == "lower"))
                 {
-                  const ColumnVector perm (args(2).vector_value ("matrix_type: invalid permutation vector PERM"));
+                  const ColumnVector perm =
+                    ColumnVector (args(2).vector_value ());
 
-                  octave_idx_type len = perm.numel ();
-                  dim_vector dv = args(0).dims ();
-
-                  if (len != dv(0))
+                  if (error_state)
                     error ("matrix_type: Invalid permutation vector PERM");
                   else
                     {
-                      OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
+                      octave_idx_type len = perm.numel ();
+                      dim_vector dv = args(0).dims ();
 
-                      for (octave_idx_type i = 0; i < len; i++)
-                        p[i] = static_cast<octave_idx_type> (perm (i)) - 1;
+                      if (len != dv(0))
+                        error ("matrix_type: Invalid permutation vector PERM");
+                      else
+                        {
+                          OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
 
-                      mattyp.mark_as_permuted (len, p);
+                          for (octave_idx_type i = 0; i < len; i++)
+                            p[i] = static_cast<octave_idx_type> (perm (i)) - 1;
+
+                          mattyp.mark_as_permuted (len, p);
+                        }
                     }
                 }
               else if (nargin != 2
                        && str_typ != "banded positive definite"
                        && str_typ != "banded")
                 error ("matrix_type: Invalid number of arguments");
 
               // Set the matrix type
@@ -411,31 +417,37 @@ LU@tie{}factorization.  Once the matrix 
                 mattyp.mark_as_full ();
               else if (str_typ == "unknown")
                 mattyp.invalidate_type ();
               else
                 error ("matrix_type: Unknown matrix type %s", str_typ.c_str ());
 
               if (nargin == 3 && (str_typ == "upper" || str_typ == "lower"))
                 {
-                  const ColumnVector perm (args(2).vector_value ("matrix_type: invalid permutation vector PERM"));
+                  const ColumnVector perm =
+                    ColumnVector (args(2).vector_value ());
 
-                  octave_idx_type len = perm.numel ();
-                  dim_vector dv = args(0).dims ();
-
-                  if (len != dv(0))
+                  if (error_state)
                     error ("matrix_type: Invalid permutation vector PERM");
                   else
                     {
-                      OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
+                      octave_idx_type len = perm.numel ();
+                      dim_vector dv = args(0).dims ();
 
-                      for (octave_idx_type i = 0; i < len; i++)
-                        p[i] = static_cast<octave_idx_type> (perm (i)) - 1;
+                      if (len != dv(0))
+                        error ("matrix_type: Invalid permutation vector PERM");
+                      else
+                        {
+                          OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
 
-                      mattyp.mark_as_permuted (len, p);
+                          for (octave_idx_type i = 0; i < len; i++)
+                            p[i] = static_cast<octave_idx_type> (perm (i)) - 1;
+
+                          mattyp.mark_as_permuted (len, p);
+                        }
                     }
                 }
               else if (nargin != 2)
                 error ("matrix_type: Invalid number of arguments");
 
               // Set the matrix type
               if (args(0).is_single_type ())
                 {
diff --git a/libinterp/corefcn/quad.cc b/libinterp/corefcn/quad.cc
--- a/libinterp/corefcn/quad.cc
+++ b/libinterp/corefcn/quad.cc
@@ -146,17 +146,17 @@ quad_float_user_function (float x)
 
   return retval;
 }
 
 #define QUAD_ABORT() \
   do \
     { \
       if (fcn_name.length ()) \
-       clear_function (fcn_name); \
+        clear_function (fcn_name); \
       return retval; \
     } \
   while (0)
 
 #define QUAD_ABORT1(msg) \
   do \
     { \
       error ("quad: " msg); \
@@ -296,20 +296,26 @@ variable by routines @code{dblquad} and 
           switch (nargin)
             {
             case 5:
               if (indefinite)
                 QUAD_ABORT1 ("singularities not allowed on infinite intervals");
 
               have_sing = true;
 
-              sing = args(4).float_vector_value ("quad: expecting vector of singularities as fourth argument");
+              sing = FloatColumnVector (args(4).float_vector_value ());
+
+              if (error_state)
+                QUAD_ABORT1 ("expecting vector of singularities as fourth argument");
 
             case 4:
-              tol = args(3).float_vector_value ("quad: expecting vector of tolerances as fifth argument");
+              tol = FloatColumnVector (args(3).float_vector_value ());
+
+              if (error_state)
+                QUAD_ABORT1 ("expecting vector of tolerances as fifth argument");
 
               switch (tol.numel ())
                 {
                 case 2:
                   quad_opts.set_single_precision_relative_tolerance (tol (1));
 
                 case 1:
                   quad_opts.set_single_precision_absolute_tolerance (tol (0));
@@ -399,20 +405,26 @@ variable by routines @code{dblquad} and 
           switch (nargin)
             {
             case 5:
               if (indefinite)
                 QUAD_ABORT1 ("singularities not allowed on infinite intervals");
 
               have_sing = true;
 
-              sing = args(4).vector_value ("quad: expecting vector of singularities as fourth argument");
+              sing = ColumnVector (args(4).vector_value ());
+
+              if (error_state)
+                QUAD_ABORT1 ("expecting vector of singularities as fourth argument");
 
             case 4:
-              tol = args(3).vector_value ("quad: expecting vector of tolerances as fifth argument");
+              tol = ColumnVector (args(3).vector_value ());
+
+              if (error_state)
+                QUAD_ABORT1 ("expecting vector of tolerances as fifth argument");
 
               switch (tol.numel ())
                 {
                 case 2:
                   quad_opts.set_relative_tolerance (tol (1));
 
                 case 1:
                   quad_opts.set_absolute_tolerance (tol (0));
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -266,19 +266,18 @@ do_rand (const octave_value_list& args, 
               }
             else if (ts == "state" || ts == "twister")
               {
                 if (args(idx+1).is_string ()
                     && args(idx+1).string_value () == "reset")
                   octave_rand::reset (fcn);
                 else
                   {
-                    Array<double> tmp = args(idx+1).array_value ();
-
-                    ColumnVector s = tmp.reshape (tmp.numel (), 1);
+                    ColumnVector s =
+                      ColumnVector (args(idx+1).vector_value(false, true));
 
                     octave_rand::state (s, fcn);
                   }
               }
             else
               error ("%s: unrecognized string argument", fcn);
           }
         else
diff --git a/libinterp/dldfcn/__eigs__.cc b/libinterp/dldfcn/__eigs__.cc
--- a/libinterp/dldfcn/__eigs__.cc
+++ b/libinterp/dldfcn/__eigs__.cc
@@ -68,17 +68,23 @@ eigs_func (const ColumnVector &x, int &e
       if (tmp.length () && tmp(0).is_defined ())
         {
           if (! warned_imaginary && tmp(0).is_complex_type ())
             {
               warning ("eigs: ignoring imaginary part returned from user-supplied function");
               warned_imaginary = true;
             }
 
-          retval = tmp(0).vector_value ("eigs: evaluation of user-supplied function failed");
+          retval = ColumnVector (tmp(0).vector_value ());
+
+          if (error_state)
+            {
+              eigs_error = 1;
+              gripe_user_supplied_eval ("eigs");
+            }
         }
       else
         {
           eigs_error = 1;
           gripe_user_supplied_eval ("eigs");
         }
     }
 
@@ -100,17 +106,23 @@ eigs_complex_func (const ComplexColumnVe
         {
           eigs_error = 1;
           gripe_user_supplied_eval ("eigs");
           return retval;
         }
 
       if (tmp.length () && tmp(0).is_defined ())
         {
-          retval = tmp(0).complex_vector_value ("eigs: evaluation of user-supplied function failed");
+          retval = ComplexColumnVector (tmp(0).complex_vector_value ());
+
+          if (error_state)
+            {
+              eigs_error = 1;
+              gripe_user_supplied_eval ("eigs");
+            }
         }
       else
         {
           eigs_error = 1;
           gripe_user_supplied_eval ("eigs");
         }
     }
 
diff --git a/libinterp/dldfcn/__magick_read__.cc b/libinterp/dldfcn/__magick_read__.cc
--- a/libinterp/dldfcn/__magick_read__.cc
+++ b/libinterp/dldfcn/__magick_read__.cc
@@ -765,18 +765,22 @@ Use @code{imread} instead.\n\
   if (indexes.is_string () && indexes.string_value () == "all")
     {
       frameidx.resize (dim_vector (1, nFrames));
       for (octave_idx_type i = 0; i < nFrames; i++)
         frameidx(i) = i;
     }
   else
     {
-      frameidx = indexes.int_vector_value ("__magick_read__: invalid value for Index/Frame");
-
+      frameidx = indexes.int_vector_value ();
+      if (error_state)
+        {
+          error ("__magick_read__: invalid value for Index/Frame");
+          return output;
+        }
       // Fix indexes from base 1 to base 0, and at the same time, make
       // sure none of the indexes is outside the range of image number.
       const octave_idx_type n = frameidx.numel ();
       for (octave_idx_type i = 0; i < n; i++)
         {
           frameidx(i)--;
           if (frameidx(i) < 0 || frameidx(i) > nFrames - 1)
             {
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -1550,17 +1550,17 @@ octave_value::cell_value (void) const
   return rep->cell_value ();
 }
 
 Cell
 octave_value::cell_value (const char *fmt, ...) const
 {
   Cell retval;
   va_list args;
-  va_start (args, fmt);
+  va_start (args,fmt);
   retval = rep->cell_value (fmt, args);
   va_end (args);
   return retval;
 }
 
 // Define the idx_type_value function here instead of in ov.h to avoid
 // needing definitions for the SIZEOF_X macros in ov.h.
 
@@ -1685,41 +1685,16 @@ octave_value::vector_value (bool force_s
 {
   Array<double> retval = array_value (force_string_conv);
 
   return retval.reshape (make_vector_dims (retval.dims (),
                                            force_vector_conversion,
                                            type_name (), "real vector"));
 }
 
-Array<double>
-octave_value::vector_value (const char *fmt, ...) const
-{
-  Array<double> retval;
-
-  try
-    {
-      retval = vector_value ();
-    }
-  catch (const octave_execution_exception&)
-    {
-      if (fmt)
-        {
-          va_list args;
-          va_start (args, fmt);
-          verror (fmt, args);
-          va_end (args);
-        }
-
-      throw;
-    }
-
-  return retval;
-}
-
 template <class T>
 static Array<int>
 convert_to_int_array (const Array<octave_int<T> >& A)
 {
   Array<int> retval (A.dims ());
   octave_idx_type n = A.numel ();
 
   for (octave_idx_type i = 0; i < n; i++)
@@ -1779,41 +1754,16 @@ octave_value::int_vector_value (bool for
         retval = Array<int> (a);
     }
 
   return retval.reshape (make_vector_dims (retval.dims (),
                                            force_vector_conversion,
                                            type_name (), "integer vector"));
 }
 
-Array<int>
-octave_value::int_vector_value (const char *fmt, ...) const
-{
-  Array<int> retval;
-
-  try
-    {
-      retval = int_vector_value ();
-    }
-  catch (const octave_execution_exception&)
-    {
-      if (fmt)
-        {
-          va_list args;
-          va_start (args, fmt);
-          verror (fmt, args);
-          va_end (args);
-        }
-
-      throw;
-    }
-
-  return retval;
-}
-
 template <class T>
 static Array<octave_idx_type>
 convert_to_octave_idx_type_array (const Array<octave_int<T> >& A)
 {
   Array<octave_idx_type> retval (A.dims ());
   octave_idx_type n = A.numel ();
 
   for (octave_idx_type i = 0; i < n; i++)
@@ -1885,41 +1835,16 @@ octave_value::complex_vector_value (bool
 {
   Array<Complex> retval = complex_array_value (force_string_conv);
 
   return retval.reshape (make_vector_dims (retval.dims (),
                                            force_vector_conversion,
                                            type_name (), "complex vector"));
 }
 
-Array<Complex>
-octave_value::complex_vector_value (const char *fmt, ...) const
-{
-  Array<Complex> retval;
-
-  try
-    {
-      retval = complex_vector_value ();
-    }
-  catch (const octave_execution_exception&)
-    {
-      if (fmt)
-        {
-          va_list args;
-          va_start (args, fmt);
-          verror (fmt, args);
-          va_end (args);
-        }
-
-      throw;
-    }
-
-  return retval;
-}
-
 FloatColumnVector
 octave_value::float_column_vector_value (bool force_string_conv,
                                          bool frc_vec_conv) const
 {
   return FloatColumnVector (float_vector_value (force_string_conv,
                                                 frc_vec_conv));
 }
 
@@ -1954,77 +1879,27 @@ octave_value::float_vector_value (bool f
 {
   Array<float> retval = float_array_value (force_string_conv);
 
   return retval.reshape (make_vector_dims (retval.dims (),
                                            force_vector_conversion,
                                            type_name (), "real vector"));
 }
 
-Array<float>
-octave_value::float_vector_value (const char *fmt, ...) const
-{
-  Array<float> retval;
-
-  try
-    {
-      retval = float_vector_value ();
-    }
-  catch (const octave_execution_exception&)
-    {
-      if (fmt)
-        {
-          va_list args;
-          va_start (args, fmt);
-          verror (fmt, args);
-          va_end (args);
-        }
-
-      throw;
-    }
-
-  return retval;
-}
-
 Array<FloatComplex>
 octave_value::float_complex_vector_value (bool force_string_conv,
                                           bool force_vector_conversion) const
 {
   Array<FloatComplex> retval = float_complex_array_value (force_string_conv);
 
   return retval.reshape (make_vector_dims (retval.dims (),
                                            force_vector_conversion,
                                            type_name (), "complex vector"));
 }
 
-Array<FloatComplex>
-octave_value::float_complex_vector_value (const char *fmt, ...) const
-{
-  Array<FloatComplex> retval;
-
-  try
-    {
-      retval = float_complex_vector_value ();
-    }
-  catch (const octave_execution_exception&)
-    {
-      if (fmt)
-        {
-          va_list args;
-          va_start (args, fmt);
-          verror (fmt, args);
-          va_end (args);
-        }
-
-      throw;
-    }
-
-  return retval;
-}
-
 octave_value
 octave_value::storable_value (void) const
 {
   octave_value retval = *this;
   if (is_null_value ())
     retval = octave_value (rep->empty_clone ());
   else
     retval.maybe_economize ();
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -898,30 +898,30 @@ public:
 
   std::string string_value (bool force = false) const
   { return rep->string_value (force); }
 
   std::string string_value (const char *fmt, ...) const
   {
     std::string retval;
     va_list args;
-    va_start (args, fmt);
+    va_start (args,fmt);
     retval = rep->string_value (fmt, args);
     va_end (args);
     return retval;
   }
 
   Array<std::string> cellstr_value (void) const
   { return rep->cellstr_value (); }
 
   Array<std::string> cellstr_value (const char *fmt, ...) const
   {
     Array<std::string> retval;
     va_list args;
-    va_start (args, fmt);
+    va_start (args,fmt);
     retval = rep->cellstr_value (fmt, args);
     va_end (args);
     return retval;
   }
 
   Range range_value (void) const
   { return rep->range_value (); }
 
@@ -993,44 +993,34 @@ public:
 
 
 
 
   Array<int> int_vector_value (bool req_int = false,
                                bool frc_str_conv = false,
                                bool frc_vec_conv = false) const;
 
-  Array<int> int_vector_value (const char *fmt, ...) const;
-
   Array<octave_idx_type>
   octave_idx_type_vector_value (bool req_int = false,
                                 bool frc_str_conv = false,
                                 bool frc_vec_conv = false) const;
 
   Array<double> vector_value (bool frc_str_conv = false,
                               bool frc_vec_conv = false) const;
 
-  Array<double> vector_value (const char *fmt, ...) const;
-
   Array<Complex> complex_vector_value (bool frc_str_conv = false,
                                        bool frc_vec_conv = false) const;
 
-  Array<Complex> complex_vector_value (const char *fmt, ...) const;
-
   Array<float> float_vector_value (bool frc_str_conv = false,
                                    bool frc_vec_conv = false) const;
 
-  Array<float> float_vector_value (const char *fmt, ...) const;
-
   Array<FloatComplex>
   float_complex_vector_value (bool frc_str_conv = false,
                               bool frc_vec_conv = false) const;
 
-  Array<FloatComplex> float_complex_vector_value (const char *fmt, ...) const;
-
   // Possibly economize a lazy-indexed value.
 
   void maybe_economize (void)
   { rep->maybe_economize (); }
 
   // The following two hook conversions are called on any octave_value prior to
   // storing it to a "permanent" location, like a named variable, a cell or a
   // struct component, or a return value of a function.
