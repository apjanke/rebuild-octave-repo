# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1542392210 18000
#      Fri Nov 16 13:16:50 2018 -0500
# Node ID 8a15f3bace491ecbfdc7c90caf8d89ea8918ad1d
# Parent  36e0e5b428e7cc63c2f81174eed0f6e513d24a89
move eval_string inside interpreter/evaluator class

* tree_evaluator.h, tree_evaluator.cc (tree_evaluator::eval_string):
New functions.

* interpreter.h, interpreter.cc (interpreter::eval_string): New
functions.  Forward to evaluator eval_string functions.

* parse.h, oct-parse.yy (eval_string): Deprecate and forward to
interpreter eval_string functions.  Change all uses.

* pt.h, pt.cc (tree::meets_bp_condition): Accept reference to
tree_evaluator as argument.  Change all uses.
(tree::is_breakpoint): Split into separate is_breakpoint and
is_active_breakpoint functions.  Change all uses.

diff --git a/libgui/src/variable-editor-model.cc b/libgui/src/variable-editor-model.cc
--- a/libgui/src/variable-editor-model.cc
+++ b/libgui/src/variable-editor-model.cc
@@ -33,16 +33,18 @@ along with Octave; see the file COPYING.
 #include <QMap>
 #include <QMessageBox>
 #include <QString>
 #include <QTableView>
 
 #include "octave-qt-link.h"
 #include "variable-editor-model.h"
 
+#include "interpreter.h"
+#include "interpreter-private.h"
 #include "ov.h"
 #include "parse.h"
 #include "pr-flt-fmt.h"
 #include "utils.h"
 #include "variables.h"
 
 static bool
 cell_is_editable (const octave_value& val)
@@ -1119,19 +1121,21 @@ namespace octave
   variable_editor_model::set_data_oct (const std::string& name,
                                        const std::string& expr,
                                        const QModelIndex& idx)
   {
     // INTERPRETER THREAD
 
     try
       {
-        int parse_status = 0;
+        interpreter& interp
+          = __get_interpreter__ ("variable_editor_model::set_data_oct");
 
-        eval_string (expr, true, parse_status);
+        int parse_status = 0;
+        interp.eval_string (expr, true, parse_status);
 
         octave_value val = retrieve_variable (name);
 
         emit update_data_signal (val);
       }
     catch (execution_exception&)
       {
         clear_update_pending ();
@@ -1168,19 +1172,21 @@ namespace octave
   void
   variable_editor_model::eval_oct (const std::string& name,
                                    const std::string& expr)
   {
     // INTERPRETER THREAD
 
     try
       {
-        int parse_status = 0;
+        interpreter& interp
+          = __get_interpreter__ ("variable_editor_model::eval_oct");
 
-        eval_string (expr, true, parse_status);
+        int parse_status = 0;
+        interp.eval_string (expr, true, parse_status);
 
         init_from_oct (name);
       }
     catch  (execution_exception&)
       {
         evaluation_error (expr);
       }
   }
@@ -1202,19 +1208,21 @@ namespace octave
 
     name = name.substr (0, name.find ("."));
 
     if (name.back () == ')' || name.back () == '}')
       name = name.substr (0, name.find (name.back () == ')' ? "(" : "{"));
 
     if (symbol_exist (name, "var") > 0)
       {
-        int parse_status = 0;
+        interpreter& interp
+          = __get_interpreter__ ("variable_editor_model::retrieve_variable");
 
-        return eval_string (x, true, parse_status);
+        int parse_status = 0;
+        return interp.eval_string (x, true, parse_status);
       }
 
     return octave_value ();
   }
 
   void
   variable_editor_model::evaluation_error (const std::string& expr) const
   {
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -11489,17 +11489,20 @@ gh_manager::do_execute_callback (const g
         fcn = cb.function_value ();
       else if (cb.is_string ())
         {
           int status;
           std::string s = cb.string_value ();
 
           try
             {
-              octave::eval_string (s, false, status, 0);
+              octave::interpreter& interp
+                = octave::__get_interpreter__ ("gh_manager::do_execute_callback");
+
+              interp.eval_string (s, false, status, 0);
             }
           catch (octave::execution_exception&)
             {
               std::cerr << "execution error in graphics callback function"
                         << std::endl;
               Flasterr (ovl ("execution error in graphics callback function"));
               octave::interpreter::recover_from_exception ();
             }
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -193,34 +193,37 @@ generate_struct_completions (const std::
 
       std::string base_name = prefix;
 
       pos = base_name.find_first_of ("{(. ");
 
       if (pos != std::string::npos)
         base_name = base_name.substr (0, pos);
 
-      octave::symbol_table& symtab
-        = octave::__get_symbol_table__ ("generate_struct_completions");
+      octave::interpreter& interp
+        = octave::__get_interpreter__ ("generate_struct_completions");
+
+      octave::symbol_table& symtab = interp.get_symbol_table ();
 
       if (is_variable (symtab, base_name))
         {
           int parse_status;
 
           octave::unwind_protect frame;
 
           frame.protect_var (discard_error_messages);
           frame.protect_var (discard_warning_messages);
 
           discard_error_messages = true;
           discard_warning_messages = true;
 
           try
             {
-              octave_value tmp = octave::eval_string (prefix, true, parse_status);
+              octave_value tmp
+                = interp.eval_string (prefix, true, parse_status);
 
               frame.run ();
 
               if (tmp.is_defined ()
                   && (tmp.isstruct () || tmp.isjava () || tmp.is_classdef_object ()))
                 names = tmp.map_keys ();
             }
           catch (const octave::execution_exception&)
@@ -256,17 +259,20 @@ looks_like_struct (const std::string& te
       int parse_status;
 
       octave::unwind_protect frame;
 
       frame.protect_var (discard_error_messages);
 
       discard_error_messages = true;
 
-      octave_value tmp = eval_string (text, true, parse_status);
+      octave::interpreter& interp
+        = octave::__get_interpreter__ ("looks_like_struct");
+
+      octave_value tmp = interp.eval_string (text, true, parse_status);
 
       frame.run ();
 
       retval = (tmp.is_defined () && tmp.isstruct ());
     }
 #endif
 
   return retval;
@@ -664,17 +670,18 @@ namespace octave
           retval(0) = "";
         else
           retval(0) = input_buf;
       }
     else
       {
         int parse_status = 0;
 
-        retval = octave::eval_string (input_buf, true, parse_status, nargout);
+        retval
+          = m_interpreter.eval_string (input_buf, true, parse_status, nargout);
 
         if (! Vdebugging && retval.empty ())
           retval(0) = Matrix ();
       }
 
     return retval;
   }
 
diff --git a/libinterp/corefcn/interpreter.cc b/libinterp/corefcn/interpreter.cc
--- a/libinterp/corefcn/interpreter.cc
+++ b/libinterp/corefcn/interpreter.cc
@@ -1125,16 +1125,36 @@ namespace octave
 
         if (fcn)
           retval = fcn->islocked ();
       }
 
     return retval;
   }
 
+  octave_value_list interpreter::eval_string (const std::string& eval_str,
+                                              bool silent, int& parse_status,
+                                              int nargout)
+  {
+    return m_evaluator.eval_string (eval_str, silent, parse_status, nargout);
+  }
+
+  octave_value interpreter::eval_string (const std::string& eval_str,
+                                         bool silent, int& parse_status)
+  {
+    return m_evaluator.eval_string (eval_str, silent, parse_status);
+  }
+
+  octave_value_list interpreter::eval_string (const octave_value& arg,
+                                              bool silent, int& parse_status,
+                                              int nargout)
+  {
+    return m_evaluator.eval_string (arg, silent, parse_status, nargout);
+  }
+
   void interpreter::recover_from_exception (void)
   {
     can_interrupt = true;
     octave_interrupt_state = 0;
     octave_signal_caught = 0;
     octave_exception_state = octave_no_exception;
     octave_restore_signal_mask ();
     catch_interrupts ();
diff --git a/libinterp/corefcn/interpreter.h b/libinterp/corefcn/interpreter.h
--- a/libinterp/corefcn/interpreter.h
+++ b/libinterp/corefcn/interpreter.h
@@ -233,16 +233,25 @@ namespace octave
     }
 
     void mlock (void);
 
     void munlock (const std::string& nm);
 
     bool mislocked (const std::string& nm);
 
+    octave_value_list eval_string (const std::string& eval_str, bool silent,
+                                   int& parse_status, int nargout);
+
+    octave_value eval_string (const std::string& eval_str, bool silent,
+                              int& parse_status);
+
+    octave_value_list eval_string (const octave_value& arg, bool silent,
+                                   int& parse_status, int nargout);
+
     static void recover_from_exception (void);
 
     static void add_atexit_function (const std::string& fname);
 
     static bool remove_atexit_function (const std::string& fname);
 
     static interpreter * the_interpreter (void) { return instance; }
 
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -505,16 +505,19 @@ read_mat5_binary_element (std::istream& 
 
   // element type, length and small data element flag
   int32_t type = 0;
   int32_t element_length;
   bool is_small_data_element;
   if (read_mat5_tag (is, swap, type, element_length, is_small_data_element))
     return retval;                      // EOF
 
+  octave::interpreter& interp
+    = octave::__get_interpreter__ ("read_mat5_binary_element");
+
   if (type == miCOMPRESSED)
     {
 #if defined (HAVE_ZLIB)
       // If C++ allowed us direct access to the file descriptor of an
       // ifstream in a uniform way, the code below could be vastly
       // simplified, and additional copies of the data in memory
       // wouldn't be needed.
 
@@ -898,17 +901,17 @@ read_mat5_binary_element (std::istream& 
                     else
                       {
                         // Next just search for it anywhere in the system path
                         std::list<std::string> names;
                         names.push_back (fname + ".oct");
                         names.push_back (fname + ".mex");
                         names.push_back (fname + ".m");
 
-                        octave::load_path& lp = octave::__get_load_path__ ("read_mat5_binary_element");
+                        octave::load_path& lp = interp.get_load_path ();
 
                         octave::directory_path p (lp.system_path ());
 
                         str =
                           octave::sys::env::make_absolute (p.find_first_of (names));
 
                         size_t xpos
                           = str.find_last_of (octave::sys::file_ops::dir_sep_chars ());
@@ -968,25 +971,23 @@ read_mat5_binary_element (std::istream& 
             tc2 = m2.contents ("MCOS").cell_value ()(1 + off).cell_value ()(1);
             m2 = tc2.scalar_map_value ();
 
             octave::unwind_protect_safe frame;
 
             // Set up temporary scope to use for evaluating the text
             // that defines the anonymous function.
 
-            octave::symbol_table& symtab
-              = octave::__get_symbol_table__ ("read_mat5_binary_element");
+            octave::symbol_table& symtab = interp.get_symbol_table ();
 
             octave::symbol_scope local_scope;
 
             symtab.set_scope (local_scope);
 
-            octave::call_stack& cs
-              = octave::__get_call_stack__ ("read_mat5_binary_element");
+            octave::call_stack& cs = interp.get_call_stack ();
             cs.push (local_scope, 0);
             frame.add_method (cs, &octave::call_stack::pop);
 
             if (m2.nfields () > 0)
               {
                 octave_value tmp;
 
                 for (auto p0 = m2.begin (); p0 != m2.end (); p0++)
@@ -994,18 +995,18 @@ read_mat5_binary_element (std::istream& 
                     std::string key = m2.key (p0);
                     octave_value val = m2.contents (p0);
 
                     local_scope.assign (key, val, 0);
                   }
               }
 
             int parse_status;
-            octave_value anon_fcn_handle =
-              octave::eval_string (fname.substr (4), true, parse_status);
+            octave_value anon_fcn_handle
+              = interp.eval_string (fname.substr (4), true, parse_status);
 
             if (parse_status != 0)
               error ("load: failed to load anonymous function handle");
 
             octave_fcn_handle *fh =
               anon_fcn_handle.fcn_handle_value ();
 
             if (! fh)
@@ -1185,18 +1186,17 @@ read_mat5_binary_element (std::istream& 
                 // inline is not an object in Octave but rather an
                 // overload of a function handle.  Special case.
                 tc =
                   new octave_fcn_inline (m.contents ("expr")(0).string_value (),
                                          m.contents ("args")(0).string_value ());
               }
             else
               {
-                cdef_manager& cdm
-                  = octave::__get_cdef_manager__ ("read_mat5_binary_element");
+                cdef_manager& cdm = interp.get_cdef_manager ();
 
                 if (cdm.find_class (classname, false, true).ok ())
                   {
                     tc = m;
                     warning ("load: classdef element has been converted to a struct");
                   }
                 else
                   {
@@ -1207,17 +1207,17 @@ read_mat5_binary_element (std::istream& 
                     if (cls->reconstruct_exemplar ())
                       {
 
                         if (! cls->reconstruct_parents ())
                           warning ("load: unable to reconstruct object inheritance");
 
                         tc = cls;
 
-                        octave::load_path& lp = octave::__get_load_path__ ("read_mat5_binary_element");
+                        octave::load_path& lp = interp.get_load_path ();
 
                         if (lp.find_method (classname, "loadobj") != "")
                           {
                             try
                               {
                                 octave_value_list tmp = octave::feval ("loadobj", tc, 1);
 
                                 tc = tmp(0);
@@ -2605,17 +2605,18 @@ save_mat5_binary_element (std::ostream& 
           OCTAVE_LOCAL_BUFFER (char, paddedname, paddedlength);
           memset (paddedname, 0, paddedlength);
           strncpy (paddedname, classname.c_str (), namelen);
           os.write (paddedname, paddedlength);
         }
 
       octave_map m;
 
-      octave::load_path& lp = octave::__get_load_path__ ("read_mat5_binary_element");
+      octave::load_path& lp
+        = octave::__get_load_path__ ("save_mat5_binary_element");
 
       if (tc.isobject ()
           && lp.find_method (tc.class_name (), "saveobj") != "")
         {
           try
             {
               octave_value_list tmp = octave::feval ("saveobj", tc, 1);
 
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -3315,17 +3315,20 @@ mexEvalString (const char *s)
 
   int parse_status;
   bool execution_error = false;
 
   octave_value_list ret;
 
   try
     {
-      ret = octave::eval_string (s, false, parse_status, 0);
+      octave::interpreter& interp
+        = octave::__get_interpreter__ ("mexEvalString");
+
+      ret = interp.eval_string (std::string (s), false, parse_status, 0);
     }
   catch (const octave::execution_exception&)
     {
       octave::interpreter::recover_from_exception ();
 
       execution_error = true;
     }
 
@@ -3342,17 +3345,20 @@ mexEvalStringWithTrap (const char *s)
 
   int parse_status;
   bool execution_error = false;
 
   octave_value_list ret;
 
   try
     {
-      ret = octave::eval_string (s, false, parse_status, 0);
+      octave::interpreter& interp
+        = octave::__get_interpreter__ ("mexEvalString");
+
+      ret = interp.eval_string (std::string (s), false, parse_status, 0);
     }
   catch (const octave::execution_exception&)
     {
       octave::interpreter::recover_from_exception ();
 
       execution_error = true;
     }
 
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -132,17 +132,20 @@ extract_function (const octave_value& ar
                                          warn_for.c_str ());
 
       std::string cmd = header;
       cmd.append (s);
       cmd.append (trailer);
 
       int parse_status;
 
-      octave::eval_string (cmd, true, parse_status, 0);
+      octave::interpreter& interp
+        = octave::__get_interpreter__ ("extract_function");
+
+      interp.eval_string (cmd, true, parse_status, 0);
 
       if (parse_status != 0)
         error ("%s: '%s' is not valid as a function",
                warn_for.c_str (), fname.c_str ());
 
       retval = is_valid_function (fname, warn_for, 0);
 
       if (! retval)
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -400,20 +400,22 @@ octave_fcn_handle::save_ascii (std::ostr
   return true;
 }
 
 bool
 octave_fcn_handle::parse_anon_fcn_handle (const std::string& fcn_text)
 {
   bool success = true;
 
-  int parse_status;
+  octave::interpreter& interp
+    = octave::__get_interpreter__ ("octave_fcn_handle::parse_anon_fcn_handle");
 
-  octave_value anon_fcn_handle =
-    octave::eval_string (fcn_text, true, parse_status);
+  int parse_status;
+  octave_value anon_fcn_handle
+    = interp.eval_string (fcn_text, true, parse_status);
 
   if (parse_status == 0)
     {
       octave_fcn_handle *fh = anon_fcn_handle.fcn_handle_value ();
 
       if (fh)
         {
           fcn = fh->fcn;
@@ -1843,18 +1845,18 @@ function handle @var{fcn_handle}.
       retval = buf.str ();
     }
   else
     retval = fh_nm;
 
   return retval;
 }
 
-DEFUN (str2func, args, ,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (str2func, interp, args, ,
+           doc: /* -*- texinfo -*-
 @deftypefn  {} {} str2func (@var{fcn_name})
 @deftypefnx {} {} str2func (@var{fcn_name}, "global")
 Return a function handle constructed from the string @var{fcn_name}.
 
 If the optional @qcode{"global"} argument is passed, locally visible
 functions are ignored in the lookup.
 @seealso{func2str, inline, functions}
 @end deftypefn */)
@@ -1867,17 +1869,17 @@ functions are ignored in the lookup.
   std::string nm = args(0).xstring_value ("str2func: FCN_NAME must be a string");
 
   octave_value retval;
 
   if (nm[0] == '@')
     {
       int parse_status;
       octave_value anon_fcn_handle
-        = octave::eval_string (nm, true, parse_status);
+        = interp.eval_string (nm, true, parse_status);
 
       if (parse_status == 0)
         retval = anon_fcn_handle;
     }
   else
     retval = make_fcn_handle (nm, nargin != 2);
 
   return retval;
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -77,33 +77,36 @@ octave_fcn_inline::octave_fcn_inline (co
       if (i > 0)
         buf << ", ";
 
       buf << ifargs(i);
     }
 
   buf << ") " << iftext;
 
+  octave::interpreter& interp
+    = octave::__get_interpreter__ ("octave_fcn_inline::octave_fcn_inline");
+
   int parse_status;
-  octave_value anon_fcn_handle = octave::eval_string (buf.str (), true, parse_status);
+  octave_value anon_fcn_handle
+    = interp.eval_string (buf.str (), true, parse_status);
 
   if (parse_status == 0)
     {
       octave_fcn_handle *fh = anon_fcn_handle.fcn_handle_value ();
 
       if (fh)
         {
           fcn = fh->fcn_val ();
 
           octave_user_function *uf = fcn.user_function_value ();
 
           if (uf)
             {
-              octave::call_stack& cs
-                = octave::__get_call_stack__ ("octave_fcn_inline");
+              octave::call_stack& cs = interp.get_call_stack ();
 
               octave_function *curr_fcn = cs.current ();
 
               if (curr_fcn)
                 {
                   octave::symbol_scope parent_scope
                     = curr_fcn->parent_fcn_scope ();
 
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -46,16 +46,18 @@ along with Octave; see the file COPYING.
 #include "cmd-edit.h"
 #include "defaults.h"
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
 #include "file-ops.h"
 #include "file-stat.h"
 #include "fpucw-wrappers.h"
+#include "interpreter.h"
+#include "interpreter-private.h"
 #include "load-path.h"
 #include "lo-sysdep.h"
 #include "oct-env.h"
 #include "oct-shlib.h"
 #include "ov-java.h"
 #include "parse.h"
 #include "variables.h"
 
@@ -2012,19 +2014,22 @@ Java_org_octave_Octave_doInvoke (JNIEnv 
 
       END_INTERRUPT_WITH_EXCEPTIONS;
     }
 }
 
 JNIEXPORT void JNICALL
 Java_org_octave_Octave_doEvalString (JNIEnv *env, jclass, jstring cmd)
 {
+  octave::interpreter& interp
+    = octave::__get_interpreter__ ("Java_org_octave_Octave_doEvalString");
+
   std::string s = jstring_to_string (env, cmd);
   int pstatus;
-  octave::eval_string (s, false, pstatus, 0);
+  interp.eval_string (s, false, pstatus, 0);
 }
 
 JNIEXPORT jboolean JNICALL
 Java_org_octave_Octave_needThreadedInvokation (JNIEnv *env, jclass)
 {
   return (get_current_thread_ID (env) != octave_thread_ID);
 }
 
diff --git a/libinterp/parse-tree/oct-parse.yy b/libinterp/parse-tree/oct-parse.yy
--- a/libinterp/parse-tree/oct-parse.yy
+++ b/libinterp/parse-tree/oct-parse.yy
@@ -5375,120 +5375,42 @@ builtin ("sin", 0)
 }
 
 namespace octave
 {
   octave_value_list
   eval_string (const std::string& eval_str, bool silent,
                int& parse_status, int nargout)
   {
-    octave_value_list retval;
-
-    parser parser (eval_str, __get_interpreter__ ("eval_string"));
-
-    do
-      {
-        parser.reset ();
-
-        parse_status = parser.run ();
-
-        if (parse_status == 0)
-          {
-            if (parser.m_stmt_list)
-              {
-                tree_statement *stmt = nullptr;
-
-                tree_evaluator& tw = __get_evaluator__ ("eval_string");
-
-                if (parser.m_stmt_list->length () == 1
-                    && (stmt = parser.m_stmt_list->front ())
-                    && stmt->is_expression ())
-                  {
-                    tree_expression *expr = stmt->expression ();
-
-                    if (silent)
-                      expr->set_print_flag (false);
-
-                    bool do_bind_ans = false;
-
-                    if (expr->is_identifier ())
-                      {
-                        symbol_scope scope = tw.get_current_scope ();
-
-                        symbol_record::context_id context
-                          = scope.current_context ();
-
-                        tree_identifier *id
-                          = dynamic_cast<tree_identifier *> (expr);
-
-                        do_bind_ans = (! id->is_variable (context));
-                      }
-                    else
-                      do_bind_ans = (! expr->is_assignment_expression ());
-
-                    retval = tw.evaluate_n (expr, nargout);
-
-                    if (do_bind_ans && ! retval.empty ())
-                      tw.bind_ans (retval(0), expr->print_result ());
-
-                    if (nargout == 0)
-                      retval = octave_value_list ();
-                  }
-                else if (nargout == 0)
-                  parser.m_stmt_list->accept (tw);
-                else
-                  error ("eval: invalid use of statement list");
-
-                if (tw.returning () || tw.breaking () || tw.continuing ())
-                  break;
-              }
-            else if (parser.m_lexer.m_end_of_input)
-              break;
-          }
-      }
-    while (parse_status == 0);
-
-    return retval;
+    interpreter& interp = __get_interpreter__ ("eval_string");
+
+    return interp.eval_string (eval_str, silent, parse_status, nargout);
   }
 
   octave_value
   eval_string (const std::string& eval_str, bool silent, int& parse_status)
   {
-    octave_value retval;
-
-    octave_value_list tmp = eval_string (eval_str, silent, parse_status, 1);
-
-    if (! tmp.empty ())
-      retval = tmp(0);
-
-    return retval;
-  }
-
-  static octave_value_list
-  eval_string (const octave_value& arg, bool silent, int& parse_status,
-               int nargout)
-  {
-    std::string s = arg.xstring_value ("eval: expecting std::string argument");
-
-    return eval_string (s, silent, parse_status, nargout);
+    interpreter& interp = __get_interpreter__ ("eval_string");
+
+    return interp.eval_string (eval_str, silent, parse_status);
   }
 
   void
   cleanup_statement_list (tree_statement_list **lst)
   {
     if (*lst)
       {
         delete *lst;
         *lst = nullptr;
       }
   }
 }
 
-DEFUN (eval, args, nargout,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (eval, interp, args, nargout,
+           doc: /* -*- texinfo -*-
 @deftypefn  {} {} eval (@var{try})
 @deftypefnx {} {} eval (@var{try}, @var{catch})
 Parse the string @var{try} and evaluate it as if it were an Octave
 program.
 
 If execution fails, evaluate the optional string @var{catch}.
 
 The string @var{try} is evaluated in the current context, so any results
@@ -5540,33 +5462,33 @@ does.
   int parse_status = 0;
 
   bool execution_error = false;
 
   octave_value_list tmp;
 
   try
     {
-      tmp = octave::eval_string (args(0), nargout > 0, parse_status, nargout);
+      tmp = interp.eval_string (args(0), nargout > 0, parse_status, nargout);
     }
   catch (const octave::execution_exception&)
     {
       octave::interpreter::recover_from_exception ();
 
       execution_error = true;
     }
 
   if (nargin > 1 && (parse_status != 0 || execution_error))
     {
       // Set up for letting the user print any messages from
       // errors that occurred in the first part of this eval().
 
       buffer_error_messages--;
 
-      tmp = octave::eval_string (args(1), nargout > 0, parse_status, nargout);
+      tmp = interp.eval_string (args(1), nargout > 0, parse_status, nargout);
 
       if (nargout > 0)
         retval = tmp;
     }
   else
     {
       if (nargout > 0)
         retval = tmp;
@@ -5716,35 +5638,33 @@ Like @code{eval}, except that the expres
   int parse_status = 0;
 
   bool execution_error = false;
 
   octave_value_list tmp;
 
   try
     {
-      tmp = octave::eval_string (args(1), nargout > 0,
-                                 parse_status, nargout);
+      tmp = interp.eval_string (args(1), nargout > 0, parse_status, nargout);
     }
   catch (const octave::execution_exception&)
     {
       octave::interpreter::recover_from_exception ();
 
       execution_error = true;
     }
 
   if (nargin > 2 && (parse_status != 0 || execution_error))
     {
       // Set up for letting the user print any messages from
       // errors that occurred in the first part of this eval().
 
       buffer_error_messages--;
 
-      tmp = octave::eval_string (args(2), nargout > 0,
-                                 parse_status, nargout);
+      tmp = interp.eval_string (args(2), nargout > 0, parse_status, nargout);
 
       retval = (nargout > 0) ? tmp : octave_value_list ();
     }
   else
     {
       if (nargout > 0)
         retval = tmp;
 
@@ -5777,18 +5697,18 @@ restore_octave_stdout (std::streambuf *b
 
 static void
 restore_octave_stderr (std::streambuf *buf)
 {
   std::cerr.flush ();
   std::cerr.rdbuf (buf);
 }
 
-DEFUN (evalc, args, nargout,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (evalc, interp, args, nargout,
+           doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{s} =} evalc (@var{try})
 @deftypefnx {} {@var{s} =} evalc (@var{try}, @var{catch})
 Parse and evaluate the string @var{try} as if it were an Octave program,
 while capturing the output into the return variable @var{s}.
 
 If execution fails, evaluate the optional string @var{catch}.
 
 This function behaves like @code{eval}, but any output or warning messages
@@ -5835,17 +5755,17 @@ s = evalc ("t = 42"), t
   frame.add_fcn (maybe_print_last_error_message, &eval_error_occurred);
   frame.add_fcn (restore_octave_stdout, old_out_buf);
   frame.add_fcn (restore_octave_stderr, old_err_buf);
 
   // call standard eval function
   octave_value_list retval;
   int eval_nargout = std::max (0, nargout - 1);
 
-  retval = Feval (args, eval_nargout);
+  retval = Feval (interp, args, eval_nargout);
   eval_error_occurred = false;
 
   retval.prepend (buffer.str ());
   return retval;
 }
 
 /*
 
diff --git a/libinterp/parse-tree/parse.h b/libinterp/parse-tree/parse.h
--- a/libinterp/parse-tree/parse.h
+++ b/libinterp/parse-tree/parse.h
@@ -575,19 +575,21 @@ namespace octave
   extern OCTINTERP_API octave_value_list
   feval (octave_value& val,
          const octave_value_list& args = octave_value_list (),
          int nargout = 0);
 
   extern OCTINTERP_API octave_value_list
   feval (const octave_value_list& args, int nargout = 0);
 
+  OCTAVE_DEPRECATED (5, "use 'octave::interpreter::eval_string' instead")
   extern OCTINTERP_API octave_value_list
   eval_string (const std::string&, bool silent, int& parse_status, int nargout);
 
+  OCTAVE_DEPRECATED (5, "use 'octave::interpreter::eval_string' instead")
   extern OCTINTERP_API octave_value
   eval_string (const std::string&, bool silent, int& parse_status);
 
   extern OCTINTERP_API void
   cleanup_statement_list (tree_statement_list **lst);
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -188,16 +188,109 @@ namespace octave
           octave_stdout << "\n";
 
         retval = 0;
       }
 
     return retval;
   }
 
+  octave_value_list
+  tree_evaluator::eval_string (const std::string& eval_str, bool silent,
+                               int& parse_status, int nargout)
+  {
+    octave_value_list retval;
+
+    parser parser (eval_str, m_interpreter);
+
+    do
+      {
+        parser.reset ();
+
+        parse_status = parser.run ();
+
+        if (parse_status == 0)
+          {
+            if (parser.m_stmt_list)
+              {
+                tree_statement *stmt = nullptr;
+
+                if (parser.m_stmt_list->length () == 1
+                    && (stmt = parser.m_stmt_list->front ())
+                    && stmt->is_expression ())
+                  {
+                    tree_expression *expr = stmt->expression ();
+
+                    if (silent)
+                      expr->set_print_flag (false);
+
+                    bool do_bind_ans = false;
+
+                    if (expr->is_identifier ())
+                      {
+                        symbol_scope scope = get_current_scope ();
+
+                        symbol_record::context_id context
+                          = scope.current_context ();
+
+                        tree_identifier *id
+                          = dynamic_cast<tree_identifier *> (expr);
+
+                        do_bind_ans = (! id->is_variable (context));
+                      }
+                    else
+                      do_bind_ans = (! expr->is_assignment_expression ());
+
+                    retval = evaluate_n (expr, nargout);
+
+                    if (do_bind_ans && ! retval.empty ())
+                      bind_ans (retval(0), expr->print_result ());
+
+                    if (nargout == 0)
+                      retval = octave_value_list ();
+                  }
+                else if (nargout == 0)
+                  parser.m_stmt_list->accept (*this);
+                else
+                  error ("eval: invalid use of statement list");
+
+                if (returning () || breaking () || continuing ())
+                  break;
+              }
+            else if (parser.m_lexer.m_end_of_input)
+              break;
+          }
+      }
+    while (parse_status == 0);
+
+    return retval;
+  }
+
+  octave_value tree_evaluator::eval_string (const std::string& eval_str,
+                                            bool silent, int& parse_status)
+  {
+    octave_value retval;
+
+    octave_value_list tmp = eval_string (eval_str, silent, parse_status, 1);
+
+    if (! tmp.empty ())
+      retval = tmp(0);
+
+    return retval;
+  }
+
+  octave_value_list tree_evaluator::eval_string (const octave_value& arg,
+                                                 bool silent, int& parse_status,
+                                                 int nargout)
+  {
+    std::string s = arg.xstring_value ("eval: expecting string argument");
+
+    return eval_string (s, silent, parse_status, nargout);
+  }
+
   void
   tree_evaluator::visit_anon_fcn_handle (tree_anon_fcn_handle& anon_fh)
   {
     // FIXME: should CMD_LIST be limited to a single expression?
     // I think that is what Matlab does.
 
     tree_parameter_list *param_list = anon_fh.parameter_list ();
     tree_expression *expr = anon_fh.expression ();
@@ -443,17 +536,17 @@ namespace octave
     if (m_echo_state)
       {
         size_t line = cmd.line ();
         echo_code (line);
         m_echo_file_pos = line + 1;
       }
 
     if (m_debug_mode)
-      do_breakpoint (cmd.is_breakpoint (true));
+      do_breakpoint (cmd.is_active_breakpoint (*this));
 
     if (m_in_loop_command)
       m_breaking = 1;
     else
       error ("break must appear in a loop in the same file as loop command");
   }
 
   void
@@ -525,17 +618,17 @@ namespace octave
     if (m_echo_state)
       {
         size_t line = cmd.line ();
         echo_code (line);
         m_echo_file_pos = line + 1;
       }
 
     if (m_debug_mode)
-      do_breakpoint (cmd.is_breakpoint (true));
+      do_breakpoint (cmd.is_active_breakpoint (*this));
 
     if (m_in_loop_command)
       m_continuing = 1;
   }
 
   bool
   tree_evaluator::statement_printing_enabled (void)
   {
@@ -1038,17 +1131,17 @@ namespace octave
     if (m_echo_state)
       {
         size_t line = cmd.line ();
         echo_code (line);
         m_echo_file_pos = line + 1;
       }
 
     if (m_debug_mode)
-      do_breakpoint (cmd.is_breakpoint (true));
+      do_breakpoint (cmd.is_active_breakpoint (*this));
 
     tree_decl_init_list *init_list = cmd.initializer_list ();
 
     if (init_list)
       init_list->accept (*this);
   }
 
   void
@@ -1148,17 +1241,17 @@ namespace octave
 
     if (m_echo_state)
       {
         echo_code (line);
         line++;
       }
 
     if (m_debug_mode)
-      do_breakpoint (cmd.is_breakpoint (true));
+      do_breakpoint (cmd.is_active_breakpoint (*this));
 
     // FIXME: need to handle PARFOR loops here using cmd.in_parallel ()
     // and cmd.maxproc_expr ();
 
     unwind_protect frame;
 
     frame.protect_var (m_in_loop_command);
 
@@ -1286,17 +1379,17 @@ namespace octave
 
     if (m_echo_state)
       {
         echo_code (line);
         line++;
       }
 
     if (m_debug_mode)
-      do_breakpoint (cmd.is_breakpoint (true));
+      do_breakpoint (cmd.is_active_breakpoint (*this));
 
     unwind_protect frame;
 
     frame.protect_var (m_in_loop_command);
 
     m_in_loop_command = true;
 
     tree_expression *expr = cmd.control_expr ();
@@ -1753,17 +1846,17 @@ namespace octave
       {
         tree_expression *expr = tic->condition ();
 
         if (m_statement_context == SC_FUNCTION
             || m_statement_context == SC_SCRIPT)
           m_call_stack.set_location (tic->line (), tic->column ());
 
         if (m_debug_mode && ! tic->is_else_clause ())
-          do_breakpoint (tic->is_breakpoint (true));
+          do_breakpoint (tic->is_active_breakpoint (*this));
 
         if (tic->is_else_clause () || is_logically_true (expr, "if"))
           {
             tree_statement_list *stmt_lst = tic->commands ();
 
             if (stmt_lst)
               stmt_lst->accept (*this);
 
@@ -2367,17 +2460,17 @@ namespace octave
     if (m_echo_state)
       {
         size_t line = cmd.line ();
         echo_code (line);
         m_echo_file_pos = line + 1;
       }
 
     if (m_debug_mode && cmd.is_end_of_fcn_or_script ())
-      do_breakpoint (cmd.is_breakpoint (true), true);
+      do_breakpoint (cmd.is_active_breakpoint (*this), true);
   }
 
   void
   tree_evaluator::visit_constant (tree_constant& expr)
   {
     int nargout = m_nargout_stack.top ();
 
     if (nargout > 1)
@@ -2527,17 +2620,17 @@ namespace octave
     if (m_echo_state)
       {
         size_t line = cmd.line ();
         echo_code (line);
         m_echo_file_pos = line + 1;
       }
 
     if (m_debug_mode)
-      do_breakpoint (cmd.is_breakpoint (true));
+      do_breakpoint (cmd.is_active_breakpoint (*this));
 
     // Act like dbcont.
 
     if (Vdebugging && m_call_stack.current_frame () == m_current_frame)
       {
         Vdebugging = false;
 
         reset_debug_state ();
@@ -2661,17 +2754,17 @@ namespace octave
                 if (m_echo_state)
                   {
                     size_t line = stmt.line ();
                     echo_code (line);
                     m_echo_file_pos = line + 1;
                   }
 
                 if (m_debug_mode)
-                  do_breakpoint (expr->is_breakpoint (true));
+                  do_breakpoint (expr->is_active_breakpoint (*this));
 
                 // FIXME: maybe all of this should be packaged in
                 // one virtual function that returns a flag saying whether
                 // or not the expression will take care of binding ans and
                 // printing the result.
 
                 // FIXME: it seems that we should just have to
                 // evaluate the expression and that should take care of
@@ -2795,17 +2888,17 @@ namespace octave
     if (m_echo_state)
       {
         size_t line = cmd.line ();
         echo_code (line);
         m_echo_file_pos = line + 1;
       }
 
     if (m_debug_mode)
-      do_breakpoint (cmd.is_breakpoint (true));
+      do_breakpoint (cmd.is_active_breakpoint (*this));
 
     tree_expression *expr = cmd.switch_value ();
 
     if (! expr)
       error ("missing value in switch command near line %d, column %d",
              cmd.line (), cmd.column ());
 
     octave_value val = evaluate (expr);
@@ -3063,17 +3156,17 @@ namespace octave
       panic_impossible ();
 
     for (;;)
       {
         if (m_echo_state)
           m_echo_file_pos = line;
 
         if (m_debug_mode)
-          do_breakpoint (cmd.is_breakpoint (true));
+          do_breakpoint (cmd.is_active_breakpoint (*this));
 
         if (is_logically_true (expr, "while"))
           {
             tree_statement_list *loop_body = cmd.body ();
 
             if (loop_body)
               loop_body->accept (*this);
 
@@ -3123,17 +3216,17 @@ namespace octave
 
         if (loop_body)
           loop_body->accept (*this);
 
         if (quit_loop_now ())
           break;
 
         if (m_debug_mode)
-          do_breakpoint (cmd.is_breakpoint (true));
+          do_breakpoint (cmd.is_active_breakpoint (*this));
 
         m_call_stack.set_location (until_line, until_column);
 
         if (is_logically_true (expr, "do-until"))
           break;
       }
   }
 
@@ -3164,17 +3257,18 @@ namespace octave
               }
           }
       }
   }
 
   void
   tree_evaluator::do_breakpoint (tree_statement& stmt)
   {
-    do_breakpoint (stmt.is_breakpoint (true), stmt.is_end_of_fcn_or_script ());
+    do_breakpoint (stmt.is_active_breakpoint (*this),
+                   stmt.is_end_of_fcn_or_script ());
   }
 
   void
   tree_evaluator::do_breakpoint (bool is_breakpoint,
                                  bool is_end_of_fcn_or_script)
   {
     bool break_on_this_statement = false;
 
diff --git a/libinterp/parse-tree/pt-eval.h b/libinterp/parse-tree/pt-eval.h
--- a/libinterp/parse-tree/pt-eval.h
+++ b/libinterp/parse-tree/pt-eval.h
@@ -148,16 +148,25 @@ namespace octave
     tree_evaluator& operator = (const tree_evaluator&) = delete;
 
     ~tree_evaluator (void) = default;
 
     void reset (void);
 
     int repl (bool interactive);
 
+    octave_value_list eval_string (const std::string& eval_str, bool silent,
+                                   int& parse_status, int nargout);
+
+    octave_value eval_string (const std::string& eval_str, bool silent,
+                              int& parse_status);
+
+    octave_value_list eval_string (const octave_value& arg, bool silent,
+                                   int& parse_status, int nargout);
+
     void visit_anon_fcn_handle (tree_anon_fcn_handle&);
 
     void visit_argument_list (tree_argument_list&);
 
     void visit_binary_expression (tree_binary_expression&);
 
     void visit_boolean_expression (tree_boolean_expression&);
 
diff --git a/libinterp/parse-tree/pt-stmt.cc b/libinterp/parse-tree/pt-stmt.cc
--- a/libinterp/parse-tree/pt-stmt.cc
+++ b/libinterp/parse-tree/pt-stmt.cc
@@ -32,16 +32,17 @@ along with Octave; see the file COPYING.
 #include "comment-list.h"
 #include "input.h"
 #include "oct-lvalue.h"
 #include "octave-link.h"
 #include "ov.h"
 #include "pager.h"
 #include "pt-bp.h"
 #include "pt-cmd.h"
+#include "pt-eval.h"
 #include "pt-id.h"
 #include "pt-idx.h"
 #include "pt-jump.h"
 #include "pt-pr-code.h"
 #include "pt-stmt.h"
 #include "pt-walk.h"
 #include "utils.h"
 #include "variables.h"
@@ -84,20 +85,27 @@ namespace octave
   {
     if (m_command)
       m_command->delete_breakpoint ();
     else if (m_expression)
       m_expression->delete_breakpoint ();
   }
 
   bool
-  tree_statement::is_breakpoint (bool check_active) const
+  tree_statement::is_breakpoint (void) const
   {
-    return m_command ? m_command->is_breakpoint (check_active)
-      : (m_expression ? m_expression->is_breakpoint (check_active) : false);
+    return m_command ? m_command->is_breakpoint ()
+      : (m_expression ? m_expression->is_breakpoint () : false);
+  }
+
+  bool
+  tree_statement::is_active_breakpoint (tree_evaluator& tw) const
+  {
+    return m_command ? m_command->is_active_breakpoint (tw)
+      : (m_expression ? m_expression->is_active_breakpoint (tw) : false);
   }
 
   std::string
   tree_statement::bp_cond () const
   {
     return (m_command
             ? m_command->bp_cond ()
             : (m_expression ? m_expression->bp_cond () : "0"));
diff --git a/libinterp/parse-tree/pt-stmt.h b/libinterp/parse-tree/pt-stmt.h
--- a/libinterp/parse-tree/pt-stmt.h
+++ b/libinterp/parse-tree/pt-stmt.h
@@ -33,16 +33,17 @@ class octave_value_list;
 #include "bp-table.h"
 #include "pt.h"
 #include "pt-walk.h"
 
 namespace octave
 {
   class comment_list;
   class tree_command;
+  class tree_evaluator;
   class tree_expression;
 
   // A statement is either a command to execute or an expression to
   // evaluate.
 
   class tree_statement : public tree
   {
   public:
@@ -72,17 +73,20 @@ namespace octave
     bool is_command (void) const { return m_command != nullptr; }
 
     bool is_expression (void) const { return m_expression != nullptr; }
 
     void set_breakpoint (const std::string& condition);
 
     void delete_breakpoint (void);
 
-    bool is_breakpoint (bool check_valid = false) const;
+    bool is_breakpoint (void) const;
+
+    bool is_active_breakpoint (tree_evaluator& tw) const;
+
     std::string bp_cond () const;
 
     int line (void) const;
     int column (void) const;
 
     void set_location (int l, int c);
 
     void echo_code (const std::string& prefix);
diff --git a/libinterp/parse-tree/pt.cc b/libinterp/parse-tree/pt.cc
--- a/libinterp/parse-tree/pt.cc
+++ b/libinterp/parse-tree/pt.cc
@@ -24,16 +24,17 @@ along with Octave; see the file COPYING.
 #  include "config.h"
 #endif
 
 #include <sstream>
 #include <string>
 
 #include "ov-fcn.h"
 #include "pt.h"
+#include "pt-eval.h"
 #include "pt-pr-code.h"
 #include "unwind-prot.h"
 
 namespace octave
 {
   // Hide the details of the string buffer so that we are less likely to
   // create a memory leak.
 
@@ -46,21 +47,20 @@ namespace octave
 
     accept (tpc);
 
     std::string retval = buf.str ();
 
     return retval;
   }
 
-  // function from libinterp/parse-tree/oct-parse.cc, not listed in oct-parse.h
-  octave_value_list eval_string (const std::string&, bool, int&, int);
   // Is the current breakpoint condition met?
+
   bool
-  tree::meets_bp_condition () const
+  tree::meets_bp_condition (tree_evaluator& tw) const
   {
     bool retval;
     if (m_bp_cond == nullptr)
       retval = false;
     else if (m_bp_cond->empty ())     // empty condition always met
       retval = true;
     else
       {
@@ -74,17 +74,17 @@ namespace octave
         buffer_error_messages++;
         Vdebug_on_error = false;
         Vdebug_on_warning = false;
 
         retval = true;                // default to stopping if any error
         try
           {
             octave_value_list val
-              = eval_string (*m_bp_cond, 1, parse_status, 1);
+              = tw.eval_string (*m_bp_cond, 1, parse_status, 1);
 
             if (parse_status == 0)
               {
                 if (! val(0).is_scalar_type ())
                   warning ("Breakpoint condition must be a scalar, not size %s",
                            val(0).dims ().str ('x').c_str ());
                 else
                   retval = val(0).bool_value ();
diff --git a/libinterp/parse-tree/pt.h b/libinterp/parse-tree/pt.h
--- a/libinterp/parse-tree/pt.h
+++ b/libinterp/parse-tree/pt.h
@@ -28,16 +28,17 @@ along with Octave; see the file COPYING.
 #include <string>
 
 #include <iosfwd>
 
 class octave_function;
 
 namespace octave
 {
+  class tree_evaluator;
   class tree_walker;
 
   // Base class for the parse tree.
 
   class tree
   {
   public:
 
@@ -80,21 +81,26 @@ namespace octave
       if (m_bp_cond)
         {
           delete m_bp_cond;
 
           m_bp_cond = nullptr;
         }
     }
 
-    bool meets_bp_condition (void) const;
+    bool meets_bp_condition (tree_evaluator& tw) const;
 
-    bool is_breakpoint (bool check_active = false) const
+    bool is_breakpoint (void) const
     {
-      return m_bp_cond && (! check_active || meets_bp_condition ());
+      return m_bp_cond;
+    }
+
+    bool is_active_breakpoint (tree_evaluator& tw) const
+    {
+      return m_bp_cond && meets_bp_condition (tw);
     }
 
     // breakpoint condition, or "0" (i.e., "false") if no breakpoint.
     // To distinguish "0" from a disabled breakpoint, test "is_breakpoint" too.
     const std::string bp_cond (void) const
     {
       return m_bp_cond ? *m_bp_cond : "0";
     }
