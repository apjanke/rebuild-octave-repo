# HG changeset patch
# User Ben Abbott  <bpabbott@mac.com>
# Date 1364771944 14400
#      Sun Mar 31 19:19:04 2013 -0400
# Node ID 1de4ec2a856d299540bde214bc4d939c464b97db
# Parent  7fa90eb412402cfb40dae8adc508c4cdf9107945
Matlab compatibility for strsplit()

* scripts/strings/strsplit.m: Matlab compatible version.
* NEWS: Mention break in backward compatibility.
* scripts/deprecated/javafields.m: Modify call to strsplit().
* scripts/deprecated/javamethods.m: ditto
* scripts/general/fieldnames.m: ditto
* scripts/general/int2str.m: ditto
* scripts/general/methods.m: ditto
* scripts/general/num2str.m: ditto
* scripts/help/gen_doc_cache.m: ditto
* scripts/help/help.m: ditto
* scripts/help/lookfor.m: ditto
* scripts/io/strread.m: ditto
* scripts/java/javaclasspath.m: ditto
* scripts/miscellaneous/compare_versions.m: ditto
* scripts/miscellaneous/computer.m: ditto
* scripts/miscellaneous/fact.m: ditto
* scripts/miscellaneous/tar.m: ditto
* scripts/miscellaneous/unpack.m: ditto
* scripts/miscellaneous/what.m: ditto
* scripts/miscellaneous/zip.m: ditto
* scripts/pkg/private/configure_make.m: ditto
* scripts/pkg/private/fix_depends.m: ditto
* scripts/pkg/private/generate_lookfor_cache.m: ditto
* scripts/pkg/private/list_forge_packages.m: ditto
* scripts/pkg/private/unload_packages.m: ditto
* scripts/pkg/private/write_index.m: ditto
* scripts/plot/private/__file_filter__.m: ditto
* scripts/plot/private/__fltk_file_filter__.m: ditto
* scripts/plot/private/__go_draw_axes__.m: ditto
* scripts/plot/private/__next_line_style__.m: ditto
* scripts/strings/untabify.m: ditto
* scripts/testfun/rundemos.m: ditto
* scripts/testfun/runtests.m: ditto

diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -12,16 +12,55 @@ Summary of important user-visible change
     states that are set locally affect the current function and all
     functions called from the current scope.  The previous warning state
     is restored on return from the current function.  The "local"
     option is ignored if used in the top-level workspace.
 
 Summary of important user-visible changes for version 3.8:
 ---------------------------------------------------------
 
+ ** strsplit has been modified to be compatible with Matlab.  There
+    are three instances where backward compatibility is broken.
+
+    (1) Delimiters are now string vectors, not scalars.
+
+    Octave's conventioal behavior
+
+      strsplit ("1 2, 3", ", ")
+      ans = 
+      {
+       [1,1] = 1
+       [1,2] = 2
+       [1,3] = 
+       [1,4] = 3
+      }
+
+    Matlab compatible behavior
+
+      strsplit ("1 2, 3", ", ")
+      ans = 
+      {
+       [1,1] = 1 2
+       [1,2] = 3
+      }
+
+    (2) By default, Matlab treats consecutive delimiters are as a single
+    delimiter.  By default, Octave's conventional behavior was to return
+    an empty string.
+
+    (3) Octave's conventional implementation supported splitting 2D
+    character arrays.  The Matlab compatible version requires the input
+    string be a row vector.
+
+    Where the conventional behavior is desired, the in-line function below
+    may be substituted.
+
+    cstrsplit = @(str,del, collapsedelimiters = false) strsplit (strjoin ...
+      (cellstr (str), del(1)), num2cell (del(:)), collapsedelimiters);
+
  ** Octave now supports nested functions with scoping rules that are
     compatible with Matlab.  A nested function is one declared and defined
     within the body of another function.  The nested function is only
     accessible from within the enclosing function which makes it one
     method for making private functions whose names do not conflict with those
     in the global namespace (See also subfunctions and private functions).
     In addition, variables in the enclosing function are visible within the
     nested function.  This makes it possible to have a pseudo-global variable
diff --git a/scripts/deprecated/javafields.m b/scripts/deprecated/javafields.m
--- a/scripts/deprecated/javafields.m
+++ b/scripts/deprecated/javafields.m
@@ -35,17 +35,17 @@ function fld_names = javafields (javaobj
              "javafields is obsolete and will be removed from a future version of Octave, please use fieldnames instead");
   endif
   
   if (nargin != 1)
     print_usage ();
   endif
   
   c_methods = javaMethod ("getFields", "org.octave.ClassHelper", javaobj);
-  method_list = strsplit (c_methods, ';');
+  method_list = strsplit (c_methods, ';', false);
 
   if (nargout == 0)
     if (! isempty (method_list))
       disp (method_list);
     endif
   else
     fld_names = cellstr (method_list);
   endif
diff --git a/scripts/deprecated/javamethods.m b/scripts/deprecated/javamethods.m
--- a/scripts/deprecated/javamethods.m
+++ b/scripts/deprecated/javamethods.m
@@ -35,17 +35,17 @@ function mtd_names = javamethods (classn
              "javamethods is obsolete and will be removed from a future version of Octave, please use methods instead");
   endif
   
   if (nargin != 1)
     print_usage ();
   endif
 
   cls_methods = javaMethod ("getMethods", "org.octave.ClassHelper", classname);
-  method_list = strsplit (cls_methods, ';');
+  method_list = strsplit (cls_methods, ';', false);
 
   if (nargout == 0)
     if (! isempty (method_list))
       disp (method_list);
     endif
   else
     mtd_names = cellstr (method_list);
   endif
diff --git a/scripts/general/fieldnames.m b/scripts/general/fieldnames.m
--- a/scripts/general/fieldnames.m
+++ b/scripts/general/fieldnames.m
@@ -47,17 +47,17 @@ function names = fieldnames (obj)
     names = __fieldnames__ (obj);
   elseif (isjava (obj) || ischar (obj))
     ## FIXME: Function prototype that excepts java obj exists, but doesn't
     ##        work if obj is java.lang.String.  Convert obj to classname.
     if (! ischar (obj))
       obj = class (obj);
     endif
     names_str = javaMethod ("getFields", "org.octave.ClassHelper", obj);
-    names = strsplit (names_str, ';');
+    names = strsplit (names_str, ';', false);
   else
     error ("fieldnames: Invalid input argument"); 
   endif
 
 endfunction
 
 
 ## test preservation of fieldname order
diff --git a/scripts/general/int2str.m b/scripts/general/int2str.m
--- a/scripts/general/int2str.m
+++ b/scripts/general/int2str.m
@@ -68,17 +68,17 @@ function retval = int2str (n)
     idx(2) = 2:sz(2);
     rfmt = get_fmt (n(idx{:}), 2);
     fmt = cstrcat (ifmt, repmat (rfmt, 1, nc-1), "\n");
   else
     fmt = cstrcat (get_fmt (n, 0), "\n");
   endif
   tmp = sprintf (fmt, permute (n, [2, 1, 3 : nd]));
   tmp(end) = "";
-  retval = char (strsplit (tmp, "\n"));
+  retval = char (strsplit (tmp, "\n", false));
 
 endfunction
 
 function fmt = get_fmt (x, sep)
 
   t = x(:);
   t = t(t != 0);
   if (isempty (t))
diff --git a/scripts/general/methods.m b/scripts/general/methods.m
--- a/scripts/general/methods.m
+++ b/scripts/general/methods.m
@@ -38,24 +38,24 @@ function mtds = methods (obj)
     ## Call internal C++ function for Octave objects
     mtds_list = __methods__ (obj);
   elseif (ischar (obj))
     ## Could be a classname for an Octave class or Java class.
     ## Try Octave class first.
     mtds_list = __methods__ (obj);
     if (isempty (mtds_list))
       mtds_str = javaMethod ("getMethods", "org.octave.ClassHelper", obj);
-      mtds_list = strsplit (mtds_str, ';');
+      mtds_list = strsplit (mtds_str, ';', false);
     endif
   elseif (isjava (obj))
     ## FIXME: Function prototype that excepts java obj exists, but doesn't
     ##        work if obj is java.lang.String.  Convert obj to classname.
     obj = class (obj);
     mtds_str = javaMethod ("getMethods", "org.octave.ClassHelper", obj);
-    mtds_list = strsplit (mtds_str, ';');
+    mtds_list = strsplit (mtds_str, ';', false);
   else
     error ("methods: Invalid input argument");
   endif
 
   if (nargout == 0)
     classname = ifelse (ischar (obj), obj, class (obj));
     printf ("Methods for class %s:\n", classname);
     disp (list_in_columns (mtds_list));
diff --git a/scripts/general/num2str.m b/scripts/general/num2str.m
--- a/scripts/general/num2str.m
+++ b/scripts/general/num2str.m
@@ -113,17 +113,17 @@ function retval = num2str (x, arg)
       else
         ## Logical input
         fmt = "%3d";
       endif
     endif
     fmt = cstrcat (deblank (repmat (fmt, 1, columns (x))), "\n");
     nd = ndims (x);
     tmp = sprintf (fmt, permute (x, [2, 1, 3:nd]));
-    retval = strtrim (char (strsplit (tmp(1:end-1), "\n")));
+    retval = strtrim (char (strsplit (tmp(1:end-1), "\n", false)));
   else   # Complex matrix input
     if (nargin == 2)
       if (ischar (arg))
         fmt = cstrcat (arg, "%-+", arg(2:end), "i");
       elseif (isnumeric (arg) && isscalar (arg) && arg >= 0)
         fmt = sprintf ("%%%d.%dg%%-+%d.%dgi", arg+7, arg, arg+7, arg);
       else
         error ("num2str: PRECISION must be a scalar integer >= 0");
@@ -159,17 +159,17 @@ function retval = num2str (x, arg)
 
     fmt = cstrcat (deblank (repmat (fmt, 1, nc)), "\n");
     tmp = sprintf (fmt, permute (x, [2, 1, 3:nd]));
 
     ## Put the "i"'s where they are supposed to be.
     tmp = regexprep (tmp, " +i\n", "i\n");
     tmp = regexprep (tmp, "( +)i", "i$1");
 
-    retval = strtrim (char (strsplit (tmp(1:end-1), "\n")));
+    retval = strtrim (char (strsplit (tmp(1:end-1), "\n", false)));
   endif
 
 endfunction
 
 
 %!assert (num2str (123), "123")
 %!assert (num2str (1.23), "1.23")
 %!assert (num2str (123.456, 4), "123.5")
diff --git a/scripts/help/gen_doc_cache.m b/scripts/help/gen_doc_cache.m
--- a/scripts/help/gen_doc_cache.m
+++ b/scripts/help/gen_doc_cache.m
@@ -112,17 +112,17 @@ function cache = create_cache (list)
     cache (2, end) = text;
     cache (3, end) = first_sentence;
   endfor
 endfunction
 
 function cache = gen_doc_cache_in_dir (directory)
 
   ## If 'directory' is not in the current path, add it so we search it
-  dir_in_path = ismember (directory, strsplit (path (), pathsep ()));
+  dir_in_path = ismember (directory, strsplit (path (), pathsep (), false));
 
   # dirs not in path
   if (! iscell (directory))
     directory = {directory};
   endif
   dirs_notpath = {directory{!dir_in_path}};
 
   # add them
diff --git a/scripts/help/help.m b/scripts/help/help.m
--- a/scripts/help/help.m
+++ b/scripts/help/help.m
@@ -137,17 +137,17 @@ function retval = do_list_functions ()
   operators = do_list_operators ();
 
   keywords = sprintf ("*** keywords:\n\n%s\n\n",
                       list_in_columns (__keywords__ ()));
 
   builtins = sprintf ("*** builtins:\n\n%s\n\n",
                       list_in_columns (__builtins__ ()));
 
-  dirs = strsplit (path, pathsep);
+  dirs = strsplit (path, pathsep, false);
   flist = "";
   for i = 2:numel (dirs)
     files = sort ({dir(fullfile (dirs{i}, "*.m")).name, ...
                    dir(fullfile (dirs{i}, "*.oct")).name, ...
                    dir(fullfile (dirs{i}, "*.mex")).name});
 
     if (! isempty (files))
       flist = sprintf ("%s*** functions in %s:\n\n%s\n\n",
diff --git a/scripts/help/lookfor.m b/scripts/help/lookfor.m
--- a/scripts/help/lookfor.m
+++ b/scripts/help/lookfor.m
@@ -61,20 +61,20 @@ function [out_fun, out_help_text] = look
     [fun, help_text] = search_cache (str, cache_file, search_type);
     had_core_cache = true;
   else
     fun = help_text = {};
     had_core_cache = false;
   endif
 
   ## Search functions in new path dirs.
-  orig_path = strsplit (__pathorig__ (), pathsep ());
+  orig_path = strsplit (__pathorig__ (), pathsep (), false);
 
   ## ditto for path.
-  new_path = strsplit (path (), pathsep ());
+  new_path = strsplit (path (), pathsep (), false);
 
   ## scratch out directories already covered by orig_path.
   if (had_core_cache)
     new_path = setdiff (new_path, orig_path);
   endif
 
   for n = 1:numel (new_path)
     elt = new_path{n};
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -616,23 +616,23 @@ function varargout = strread (str, forma
                 endif
               else
                 ## FIXME: this assumes char(254)/char(255) won't occur in input!
                 clear wrds;
                 wrds(1:2:2*numel (words(icol, jptr))) = ...
                      strrep (words(icol, jptr), fmt_words{ii}, ...
                      [char(255) char(254)]);
                 wrds(2:2:2*numel (words(icol, jptr))-1) = char (255);
-                wrds = strsplit ([wrds{:}], char (255));
+                wrds = strsplit ([wrds{:}], char (255), false);
                 words(icol, jptr) = ...
                   wrds(find (cellfun ("isempty", strfind (wrds, char (254)))));
                 wrds(find (cellfun ("isempty", strfind (wrds, char (254))))) ...
                    = char (255);
                 words(icol+1, jptr) = strsplit (strrep ([wrds{2:end}], ...
-                   char (254), fmt_words{ii}), char (255));
+                   char (254), fmt_words{ii}), char (255), false);
                 ## Former trailing literal may now be leading for next specifier
                 --ii;
                 fwptr = [fwptr(1:ii) (++fwptr(ii+1:end))];
               endif
             endif
           endif
 
         else
@@ -694,17 +694,17 @@ function varargout = strread (str, forma
           if (pad_out)
             data(end+1:num_lines) = numeric_fill_value;
           endif
           varargout{k} = data.';
           k++;
         case {"%0", "%1", "%2", "%3", "%4", "%5", "%6", "%7", "%8", "%9"}
           sw = regexp (fmt_words{m}, '\d', "once");
           ew = regexp (fmt_words{m}, '[nfudsq]') - 1;
-          nfmt = strsplit (fmt_words{m}(2:ew), ".");
+          nfmt = strsplit (fmt_words{m}(2:ew), ".", false);
           swidth = str2double (nfmt{1});
           switch fmt_words{m}(ew+1)
             case {"d", "u", "f", "n"}
               n = cellfun ("isempty", data);
               ### FIXME - erroneously formatted data lead to NaN, not an error
               ###         => ReturnOnError can't be implemented for numeric data
               data = str2double (strtrunc (data, swidth));
               data(n) = numeric_fill_value;
@@ -767,17 +767,17 @@ function out = split_by (text, sep, mult
     ## However watch out if eol_char is also in delimiters
     if (index (sep, eol_char)); enchr = char (255); endif
     text = strrep (text, eol_char, [enchr eol_char enchr]);
   else
     mult_dlms_s1 = false;
   endif
 
   ## Split text string along delimiters
-  out = strsplit (text, sep, mult_dlms_s1);
+  out = strsplit (text, num2cell (sep(:)), mult_dlms_s1);
   if (index (sep, eol_char)); out = strrep (out, char (255), ''); endif
   ## In case of trailing delimiter, strip stray last empty word
   if (!isempty (out) && any (sep == text(end)))
     out(end) = [];
   endif
 
   ## Empty cells converted to empty cellstrings.
   out(cellfun ("isempty", out)) = {""};
diff --git a/scripts/java/javaclasspath.m b/scripts/java/javaclasspath.m
--- a/scripts/java/javaclasspath.m
+++ b/scripts/java/javaclasspath.m
@@ -53,21 +53,21 @@
 ## @end table
 ## @seealso{javaaddpath, javarmpath}
 ## @end deftypefn
 
 function varargout = javaclasspath (which)
 
   ## dynamic classpath
   dynamic_path = javaMethod ("getClassPath", "org.octave.ClassHelper");
-  dynamic_path_list = strsplit (dynamic_path, pathsep ());
+  dynamic_path_list = strsplit (dynamic_path, pathsep (), false);
 
   ## static classpath
   static_path = javaMethod ("getProperty", "java.lang.System", "java.class.path");
-  static_path_list = strsplit (static_path, pathsep ());
+  static_path_list = strsplit (static_path, pathsep (), false);
   if (numel (static_path_list) > 1)
     ## remove first element (which is .../octave.jar)
     static_path_list(1) = [];
   else
     static_path_list = {};
   endif
 
   switch (nargin)
diff --git a/scripts/miscellaneous/compare_versions.m b/scripts/miscellaneous/compare_versions.m
--- a/scripts/miscellaneous/compare_versions.m
+++ b/scripts/miscellaneous/compare_versions.m
@@ -108,18 +108,18 @@ function out = compare_versions (v1, v2,
   if (! isempty (v2firstchar))
     v2c = v2(v2firstchar:length (v2));
     v2nochar = v2(1:v2firstchar-1);
   else
     v2c = "";
     v2nochar = v2;
   endif
 
-  v1n = str2num (char (strsplit (v1nochar, ".")));
-  v2n = str2num (char (strsplit (v2nochar, ".")));
+  v1n = str2num (char (strsplit (v1nochar, ".", false)));
+  v2n = str2num (char (strsplit (v2nochar, ".", false)));
   if ((isempty (v1n) && isempty (v1c)) || (isempty (v2n) && isempty (v2c)))
     error ("compare_versions: given version strings are not valid: %s %s",
            v1, v2);
   endif
 
   ## Assume that any additional elements would be 0 if one is longer
   ## than the other.
   maxnumlen = max ([length(v1n) length(v2n)]);
diff --git a/scripts/miscellaneous/computer.m b/scripts/miscellaneous/computer.m
--- a/scripts/miscellaneous/computer.m
+++ b/scripts/miscellaneous/computer.m
@@ -44,17 +44,17 @@
 ## If the argument @code{"arch"} is specified, return a string
 ## indicating the architecture of the computer on which Octave is
 ## running.
 ## @end deftypefn
 
 function [c, maxsize, endian] = computer (a)
 
   if (nargin == 1 && ischar (a) && strcmpi (a, "arch"))
-    tmp = strsplit (octave_config_info ("canonical_host_type"), "-");
+    tmp = strsplit (octave_config_info ("canonical_host_type"), "-", false);
     if (numel (tmp) == 4)
       c = sprintf ("%s-%s-%s", tmp{4}, tmp{3}, tmp{1});
     else
       c = sprintf ("%s-%s", tmp{3}, tmp{1});
     endif
   elseif (nargin == 0)
     msg = octave_config_info ("canonical_host_type");
 
diff --git a/scripts/miscellaneous/fact.m b/scripts/miscellaneous/fact.m
--- a/scripts/miscellaneous/fact.m
+++ b/scripts/miscellaneous/fact.m
@@ -245,24 +245,24 @@ function f = fact ()
   else
     w = wordwrap (w);
     printf ("%s", w);
   endif
 endfunction
 
 function out = wordwrap (w)
   cols = terminal_size ()(2);
-  wc = strsplit (w, " ");
+  wc = strsplit (w, " ", false);
   out = "\n";
   i = 1;
   numwords = numel (wc);
   while (i <= numwords);
     line = wc{i};
     while (i < numwords
            && length (newline = cstrcat (line, " ", wc{i+1})) < cols)
       line = newline;
       i++;
     endwhile
     out = cstrcat (out, line, "\n");
     i++;
   endwhile
   out = cstrcat (out, "\n");
-endfunction
\ No newline at end of file
+endfunction
diff --git a/scripts/miscellaneous/tar.m b/scripts/miscellaneous/tar.m
--- a/scripts/miscellaneous/tar.m
+++ b/scripts/miscellaneous/tar.m
@@ -54,13 +54,13 @@ function entries = tar (tarfile, files, 
   if (status)
     error ("tar: tar exited with status = %d", status);
   endif
 
   if (nargout > 0)
     if (output(end) == "\n")
       output(end) = [];
     endif
-    entries = strsplit (output, "\n");
+    entries = strsplit (output, "\n", false);
     entries = entries';
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/unpack.m b/scripts/miscellaneous/unpack.m
--- a/scripts/miscellaneous/unpack.m
+++ b/scripts/miscellaneous/unpack.m
@@ -189,17 +189,17 @@ function filelist = unpack (file, dir = 
   endif
 
   if (nargout > 0 || needmove)
     ## Trim the last cr if needed.
     ## FIXME -- will this need to change to a check for "\r\n" for windows?
     if (output(length (output)) == "\n")
       output(length (output)) = [];
     endif
-    files = parser (strsplit (output, "\n"))';
+    files = parser (strsplit (output, "\n", false))';
 
     ## Move files if necessary
     if (needmove)
       [st, msg, msgid] = movefile (files, dir);
       if (! st)
         error ("unpack: unable to move files to \"%s\": %s",
                dir, msg);
       endif
diff --git a/scripts/miscellaneous/what.m b/scripts/miscellaneous/what.m
--- a/scripts/miscellaneous/what.m
+++ b/scripts/miscellaneous/what.m
@@ -27,17 +27,17 @@
 ## @end deftypefn
 
 function ret = what (d)
 
   if (nargin == 0)
     d = pwd ();
   elseif (isempty (strfind (d, filesep ())))
     ## Find the appropriate directory on the path.
-    p = strtrim (strsplit (path (), pathsep ()));
+    p = strtrim (strsplit (path (), pathsep (), false));
     d = p{find (cellfun (@(x) ! isempty (strfind (x, d)), p))(end)};
   else
     [status, msg, msgid] = fileattrib (d);
     if (status != 1)
       error ("what: could not find the file or path %s", d);
     else
       d = msg.Name;
     endif
diff --git a/scripts/miscellaneous/zip.m b/scripts/miscellaneous/zip.m
--- a/scripts/miscellaneous/zip.m
+++ b/scripts/miscellaneous/zip.m
@@ -57,12 +57,12 @@ function entries = zip (zipfile, files, 
     cmd = sprintf ("unzip -Z -1 %s", zipfile);
     [status, entries] = system (cmd);
     if (status)
       error ("zip: zipinfo failed with exit status = %d", status);
     endif
     if (entries(end) == "\n")
       entries(end) = [];
     endif
-    entries = strsplit (entries, "\n");
+    entries = strsplit (entries, "\n", false);
   endif
 
 endfunction
diff --git a/scripts/pkg/private/configure_make.m b/scripts/pkg/private/configure_make.m
--- a/scripts/pkg/private/configure_make.m
+++ b/scripts/pkg/private/configure_make.m
@@ -86,17 +86,17 @@ function configure_make (desc, packdir, 
       if (fid < 0)
         error ("couldn't open %s: %s", files, msg);
       endif
       filenames = char (fread (fid))';
       fclose (fid);
       if (filenames(end) == "\n")
         filenames(end) = [];
       endif
-      filenames = strtrim (strsplit (filenames, "\n"));
+      filenames = strtrim (strsplit (filenames, "\n", false));
       delete_idx =  [];
       for i = 1:length (filenames)
         if (! all (isspace (filenames{i})))
           filenames{i} = fullfile (src, filenames{i});
         else
           delete_idx(end+1) = i;
         endif
       endfor
diff --git a/scripts/pkg/private/fix_depends.m b/scripts/pkg/private/fix_depends.m
--- a/scripts/pkg/private/fix_depends.m
+++ b/scripts/pkg/private/fix_depends.m
@@ -21,17 +21,17 @@
 ## @deftypefn {Function File} {@var{deps_cell} =} fix_depends (@var{depends})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Make sure the depends field is of the right format.
 ## This function returns a cell of structures with the following fields:
 ##   package, version, operator
 function deps_cell = fix_depends (depends)
-  deps = strtrim (strsplit (tolower (depends), ","));
+  deps = strtrim (strsplit (tolower (depends), ",", false));
   deps_cell = cell (1, length (deps));
 
   ## For each dependency.
   for i = 1:length (deps)
     dep = deps{i};
     lpar = find (dep == "(");
     rpar = find (dep == ")");
     ## Does the dependency specify a version
diff --git a/scripts/pkg/private/generate_lookfor_cache.m b/scripts/pkg/private/generate_lookfor_cache.m
--- a/scripts/pkg/private/generate_lookfor_cache.m
+++ b/scripts/pkg/private/generate_lookfor_cache.m
@@ -18,14 +18,14 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} generate_lookfor_cache (@var{desc})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function generate_lookfor_cache (desc)
-  dirs = strtrim (strsplit (genpath (desc.dir), pathsep ()));
+  dirs = strtrim (strsplit (genpath (desc.dir), pathsep (), false));
   for i = 1 : length (dirs)
     gen_doc_cache (fullfile (dirs{i}, "doc-cache"), dirs{i});
   endfor
 endfunction
 
diff --git a/scripts/pkg/private/unload_packages.m b/scripts/pkg/private/unload_packages.m
--- a/scripts/pkg/private/unload_packages.m
+++ b/scripts/pkg/private/unload_packages.m
@@ -30,17 +30,17 @@ function unload_packages (files, handle_
   pnames = pdirs = cell (1, num_packages);
   for i = 1:num_packages
     pnames{i} = installed_pkgs_lst{i}.name;
     pdirs{i} = installed_pkgs_lst{i}.dir;
     pdeps{i} = installed_pkgs_lst{i}.depends;
   endfor
 
   ## Get the current octave path.
-  p = strtrim (strsplit (path (), pathsep ()));
+  p = strtrim (strsplit (path (), pathsep (), false));
 
   if (length (files) == 1 && strcmp (files{1}, "all"))
     ## Unload all.
     dirs = pdirs;
     desc = installed_pkgs_lst;
   else
     ## Unload package_name1 ...
     dirs = {};
diff --git a/scripts/pkg/private/write_index.m b/scripts/pkg/private/write_index.m
--- a/scripts/pkg/private/write_index.m
+++ b/scripts/pkg/private/write_index.m
@@ -69,17 +69,17 @@ function write_index (desc, dir, index_f
       functions{end+1} = file(1:end-4);
     endif
   endfor
 
   ## Does desc have a categories field?
   if (! isfield (desc, "categories"))
     error ("the DESCRIPTION file must have a Categories field, when no INDEX file is given");
   endif
-  categories = strtrim (strsplit (desc.categories, ","));
+  categories = strtrim (strsplit (desc.categories, ",", false));
   if (length (categories) < 1)
       error ("the Category field is empty");
   endif
 
   ## Write INDEX.
   fid = fopen (index_file, "w");
   if (fid == -1)
     error ("couldn't open %s for writing", index_file);
diff --git a/scripts/plot/private/__file_filter__.m b/scripts/plot/private/__file_filter__.m
--- a/scripts/plot/private/__file_filter__.m
+++ b/scripts/plot/private/__file_filter__.m
@@ -76,17 +76,17 @@ function name = __default_filtername__ (
       name = "C Source Files";
     case {"*.cc" "*.c++" "*.cpp"}
       name = "C++ Source Files";
     case "*.oct"
       name = "Octave Compiled Files";
   endswitch
 
   if (isempty (name))
-    extlist = strsplit (filterext, ";");
+    extlist = strsplit (filterext, ";", false);
     extlist = strrep (extlist, "*.", "");
     extlist = toupper (extlist);
     extlist(end+1, :) = repmat ({","}, 1, length (extlist));
     extlist = strcat (extlist{:});
     extlist = extlist(1:end-1);
     name = strcat (extlist, "-Files");
   endif
 
diff --git a/scripts/plot/private/__fltk_file_filter__.m b/scripts/plot/private/__fltk_file_filter__.m
--- a/scripts/plot/private/__fltk_file_filter__.m
+++ b/scripts/plot/private/__fltk_file_filter__.m
@@ -29,17 +29,17 @@ function retval = __fltk_file_filter__ (
   [r, c] = size (file_filter);
   if ((c == 0) || (c > 2))
     error ("expecting 1 or to 2 columns for file filter cell");
   endif
   fltk_str = "";
   for idx = 1 : r
 
     curr_ext = file_filter{idx, 1};
-    curr_ext = strsplit (curr_ext, ";");
+    curr_ext = strsplit (curr_ext, ";", false);
 
     if (length (curr_ext) > 1)
       curr_ext = regexprep (curr_ext, '\*\.', ',');
       curr_ext = strcat (curr_ext{:})(2 : end);
       curr_ext = strcat ("*.{", curr_ext, "}");
     else
       curr_ext = curr_ext{:};
     endif
diff --git a/scripts/plot/private/__go_draw_axes__.m b/scripts/plot/private/__go_draw_axes__.m
--- a/scripts/plot/private/__go_draw_axes__.m
+++ b/scripts/plot/private/__go_draw_axes__.m
@@ -2224,17 +2224,17 @@ endfunction
 
 function ticklabel = ticklabel_to_cell (ticklabel)
   if (isnumeric (ticklabel))
     ## Use upto 5 significant digits
     ticklabel = num2str (ticklabel(:), 5);
   endif
   if (ischar (ticklabel))
     if (rows (ticklabel) == 1 && any (ticklabel == "|"))
-      ticklabel = strsplit (ticklabel, "|");
+      ticklabel = strsplit (ticklabel, "|", false);
     else
       ticklabel = cellstr (ticklabel);
     endif
   elseif (isempty (ticklabel))
     ticklabel = {""};
   else
     ticklabel = ticklabel;
   endif
diff --git a/scripts/plot/private/__next_line_style__.m b/scripts/plot/private/__next_line_style__.m
--- a/scripts/plot/private/__next_line_style__.m
+++ b/scripts/plot/private/__next_line_style__.m
@@ -36,17 +36,17 @@ function [linestyle, marker] = __next_li
         if (isempty (style_rotation))
           error ("__next_line_style__: style_rotation not initialized");
         elseif (++style_index > num_styles)
           style_index = 1;
         endif
       elseif (reset || isempty (style_rotation))
         style_rotation = get (gca (), "linestyleorder");
         if (ischar (style_rotation))
-          style_rotation = strsplit (style_rotation, "|");
+          style_rotation = strsplit (style_rotation, "|", false);
         endif
         num_styles = length (style_rotation);
         style_index = 1;
       endif
     elseif (! isempty (style_rotation))
       options = __pltopt__ ("__next_line_style__",
                             style_rotation (style_index));
       linestyle = options.linestyle;
diff --git a/scripts/strings/strsplit.m b/scripts/strings/strsplit.m
--- a/scripts/strings/strsplit.m
+++ b/scripts/strings/strsplit.m
@@ -12,107 +12,261 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {[@var{cstr}] =} strsplit (@var{s}, @var{sep})
-## @deftypefnx {Function File} {[@var{cstr}] =} strsplit (@var{s}, @var{sep}, @var{strip_empty})
-## Split the string @var{s} using one or more separators @var{sep} and return
-## a cell array of strings.  Consecutive separators and separators at
-## boundaries result in empty strings, unless @var{strip_empty} is true.
-## The default value of @var{strip_empty} is false.
+## @deftypefn  {Function File} {[@var{cstr}] =} strsplit (@var{s})
+## @deftypefnx {Function File} {[@var{cstr}] =} strsplit (@var{s}, @var{del})
+## @deftypefnx {Function File} {[@var{cstr}] =} strsplit (@var{s}, @var{del}, @var{collapsedelimiters})
+## @deftypefnx {Function File} {[@var{cstr}] =} strsplit (@dots{}, @var{name}, @var{value})
+## @deftypefnx {Function File} {[@var{cstr}, @var{matches}] =} strsplit (@dots{})
+## Split the string @var{s} using the delimiters specified by @var{del} and return
+## a cell array of strings.  For a single delimiter, @var{del} may be a string,
+## or a scalar cell-string.  For multible delimiters, @var{del} must be a cell-string
+## array.  Unless @var{collapsedelimiters} is specified to be @var{false}, consecutive
+## delimiters are collapsed into one.
 ##
-## 2-D character arrays are split at separators and at the original column
-## boundaries.
+## The second output, @var{matches}, returns the delmiters which were matched
+## in the original string.  The matched delimiters are uneffected by the
+## @var{collapsedelimiters}.
 ##
 ## Example:
 ##
 ## @example
 ## @group
+## strsplit ("a b c")
+##       @result{}
+##           @{
+##             [1,1] = a
+##             [1,2] = b
+##             [1,3] = c
+##           @}
+##
 ## strsplit ("a,b,c", ",")
 ##       @result{}
 ##           @{
 ##             [1,1] = a
 ##             [1,2] = b
 ##             [1,3] = c
 ##           @}
 ##
-## strsplit (["a,b" ; "cde"], ",")
+## strsplit ("a foo b,bar c", @{"\s", "foo", "bar"@})
+##       @result{}
+##           @{
+##             [1,1] = a
+##             [1,2] = b
+##             [1,3] = c
+##           @}
+##
+## strsplit ("a,,b, c", @{",", " "@}, false)
+##       @result{}
+##           @{
+##             [1,1] = a
+##             [1,2] = 
+##             [1,3] = b
+##             [1,4] = 
+##             [1,5] = c
+##           @}
+##
+## @end group
+## @end example
+##
+## Supported @var{name}/@var{value} pair arguments are;
+##
+## @itemize
+## @item @code{collapsedelimiters} may take the value of @var{true} or @var{false}
+## with the default being @var{false}.
+## @item @code{delimitertype} may take the value of @code{simple} or @code{regularexpression},
+## with the default being @code{simple}.
+## @end itemize
+## 
+## Example:
+##
+## @example
+## @group
+## strsplit ("a foo b,bar c", ",|\\s|foo|bar", "delimitertype", "regularexpression")
+##       @result{}
+##           @{
+##             [1,1] = a
+##             [1,2] = b
+##             [1,3] = c
+##           @}
+## 
+## strsplit ("a,,b, c", "[, ]", false, "delimitertype", "regularexpression")
+##       @result{}
+##           @{
+##             [1,1] = a
+##             [1,2] = 
+##             [1,3] = b
+##             [1,4] = 
+##             [1,5] = c
+##           @}
+## 
+## strsplit ("a,\t,b, c", @{',', '\s'@}, "delimitertype", "regularexpression")
 ##       @result{}
 ##           @{
 ##             [1,1] = a
 ##             [1,2] = b
-##             [1,3] = cde
+##             [1,3] = c
 ##           @}
 ## @end group
 ## @end example
-## @seealso{strtok}
+## 
+## @seealso{strtok, regexp}
 ## @end deftypefn
 
-function cstr = strsplit (s, sep, strip_empty = false)
+function [result, matches] = strsplit (str, del, varargin)
 
-  if (nargin < 2 || nargin > 3)
+  args.collapsedelimiters = true;
+  args.delimitertype = "simple";
+
+  [reg, params] = parseparams (varargin);
+
+  if (numel (reg) > 1)
     print_usage ();
-  elseif (! ischar (s) || ! ischar (sep))
-    error ("strsplit: S and SEP must be string values");
-  elseif (! isscalar (strip_empty))
-    error ("strsplit: STRIP_EMPTY must be a scalar value");
+  elseif (numel (reg) == 1)
+    if (islogical (reg{1}) || isnumeric (reg{1}))
+      args.collapsedelimiters = reg{1};
+    else
+      print_usage ();
+    endif
+  endif
+  fields = fieldnames (args);
+  for n = 1:2:numel(params)
+    if (any (strcmpi (params{n}, fields)))
+      args.(lower(params{n})) = params{n+1};
+    elseif (ischar (varargin{n}))
+      error ("strsplit:invalid_parameter_name",
+        sprintf ("strsplit: Invalid parameter name, `%s'", varargin{n}))
+    else
+      print_usage ();
+    endif
+  endfor
+
+  # Save the length of the "delimitertype" parameter
+  length_deltype = numel (args.delimitertype);
+
+  if (nargin == 1 || (nargin > 1 && (islogical (del) || isnumeric (del))))
+    if (nargin > 1)
+      ## Second input is the "collapsedelimiters" parameter
+      args.collapsedelimiters = del;
+    endif
+    ## Set proper default for the delimiter type
+    if (strncmpi (args.delimitertype, "simple", numel (args.delimitertype)))
+      del = {" ","\f","\n","\r","\t","\v"};
+    else
+      del = "\\s";
+    endif
+  endif
+
+  if (nargin < 1)
+    print_usage ();
+  elseif (! ischar (str) || (! ischar (del) && ! iscellstr (del)))
+    error ("strsplit: S and DEL must be string values");
+  elseif (rows (str) > 1)
+    error ("strsplit: S must be a string value");
+  elseif (! isscalar (args.collapsedelimiters))
+    error ("strsplit: COLLAPSEDELIMITERS must be a scalar value");
+  endif
+
+  if (strncmpi (args.delimitertype, "simple", length_deltype))
+    if (iscellstr (del))
+      del = cellfun (@(x) regexp2simple (x, false), del, "uniformoutput",
+        false);
+    else
+      del = regexp2simple (del, false);
+    endif
   endif
 
-  if (isempty (s))
-    cstr = cell (size (s));
-  else
-    if (rows (s) > 1)
-      ## For 2-D arrays, add separator character at line boundaries
-      ## and transform to single string
-      s(:, end+1) = sep(1);
-      s = reshape (s.', 1, numel (s));
-      s(end) = []; 
+  if (isempty (str))
+    result = {str};
+  elseif (strncmpi (args.delimitertype, "regularexpression", length_deltype)
+          || strncmpi (args.delimitertype, "simple", length_deltype))
+    if (iscellstr (del))
+      del = sprintf ('%s|', del{:});
+      del(end) = [];
     endif
-
-    ## Split s according to delimiter
-    if (isscalar (sep))
-      ## Single separator
-      idx = find (s == sep);
-    else
-      ## Multiple separators
-      idx = strchr (s, sep);
+    [result, ~, ~, ~, matches] = regexp (str, del, "split");
+    if (args.collapsedelimiters)
+      result(cellfun (@isempty, result)) = [];
+    endif
+    if (strncmpi (args.delimitertype, "simple", length_deltype))
+      matches = cellfun (@(x) regexp2simple (x, true), matches,
+        "uniformoutput", false);
     endif
+  else
+    error ("strsplit:invalid_delimitertype", 
+      sprintf ("strsplit: Invalid DELIMITERTYPE"))
+  endif
+endfunction
 
-    ## Get substring lengths.
-    if (isempty (idx))
-      strlens = length (s);
-    else
-      strlens = [idx(1)-1, diff(idx)-1, numel(s)-idx(end)];
-    endif
-    ## Remove separators.
-    s(idx) = [];
-    if (strip_empty)
-      ## Omit zero lengths.
-      strlens = strlens(strlens != 0);
-    endif
-
-    ## Convert!
-    cstr = mat2cell (s, 1, strlens);
+function str = regexp2simple (str, reverse = false)
+  rep = {'\', '[', ']', '{', '}', '$', '^', '(', ')', '*', '+', '.', '?', '|'};
+  if (reverse)
+    ## backslash must go last
+    for r = numel(rep):-1:1
+      str = strrep (str, [char(92), rep{r}], rep{r});
+    endfor
+  else
+    ## backslash must go first
+    for r = 1:numel(rep)
+      str = strrep (str, rep{r}, [char(92), rep{r}]);
+    endfor
   endif
-
 endfunction
 
+%!shared str
+%! str = "The rain in Spain stays mainly in the plain.";
+% Split on all whitespace.
+%!assert (strsplit (str), {"The", "rain", "in", "Spain", "stays", ...
+%! "mainly", "in", "the", "plain."})
+% Split on "ain".
+%!assert (strsplit (str, "ain"), {"The r", " in Sp", " stays m", ...
+%!  "ly in the pl", "."})
+% Split on " " and "ain" (treating multiple delimiters as one).
+%!test
+%! s = strsplit (str, '\s|ain', true, "delimitertype", "r");
+%! assert (s, {"The", "r", "in", "Sp", "stays", "m", "ly", "in", "the", "pl", "."})
+%!test
+%! s = strsplit (str, "\\s|ain", true, "delimitertype", "r");
+%! assert (s, {"The", "r", "in", "Sp", "stays", "m", "ly", "in", "the", "pl", "."})
+%!test
+%! [s, m] = strsplit (str, {"\\s", "ain"}, true, "delimitertype", "r");
+%! assert (s, {"The", "r", "in", "Sp", "stays", "m", "ly", "in", "the", "pl", "."})
+%! assert (m, {" ", "ain", " ", " ", "ain", " ", " ", "ain", " ", " ", " ", "ain"})
+% Split on " " and "ain", and treat multiple delimiters separately.
+%!test
+%! [s, m] = strsplit (str, {" ", "ain"}, "collapsedelimiters", false);
+%! assert (s, {"The", "r", "", "in", "Sp", "", "stays", "m", "ly", "in", "the", "pl", "."})
+%! assert (m, {" ", "ain", " ", " ", "ain", " ", " ", "ain", " ", " ", " ", "ain"})
 
+%!assert (strsplit ("road to hell"), {"road", "to", "hell"})
 %!assert (strsplit ("road to hell", " "), {"road", "to", "hell"})
-%!assert (strsplit ("road to^hell", " ^"), {"road", "to", "hell"})
-%!assert (strsplit ("road   to--hell", " -", true), {"road", "to", "hell"})
-%!assert (strsplit (["a,bc";",de"], ","), {"a", "bc", char(ones(1,0)), "de "})
-%!assert (strsplit (["a,bc";",de"], ",", true), {"a", "bc", "de "})
-%!assert (strsplit (["a,bc";",de"], ", ", true), {"a", "bc", "de"})
+%!assert (strsplit ("road to^hell", {" ","^"}), {"road", "to", "hell"})
+%!assert (strsplit ("road   to--hell", {" ","-"}, true), {"road", "to", "hell"})
+%!assert (strsplit (["a,bc,,de"], ",", false), {"a", "bc", "", "de"})
+%!assert (strsplit (["a,bc,de"], ",", true), {"a", "bc", "de"})
+%!assert (strsplit (["a,bc,de"], {","," "}, true), {"a", "bc", "de"})
+%!test
+%! [s, m] = strsplit ("hello \t world", 1);
+%! assert (s, {"hello", "world"});
+%! assert (m, {" ", "\t", " "});
+
+%!assert (strsplit ("road to hell", " ", "delimitertype", "r"), {"road", "to", "hell"})
+%!assert (strsplit ("road to^hell", '\^| ', "delimitertype", "r"), {"road", "to", "hell"})
+%!assert (strsplit ("road to^hell", "[ ^]", "delimitertype", "r"), {"road", "to", "hell"})
+%!assert (strsplit ("road   to--hell", "[ -]", false, "delimitertype", "r"), {"road", "", "", "to", "", "hell"})
+%!assert (strsplit (["a,bc,de"], ",", "delimitertype", "r"), {"a", "bc", "de"})
+%!assert (strsplit (["a,bc,,de"], ",", false, "delimitertype", "r"), {"a", "bc", "", "de"})
+%!assert (strsplit (["a,bc,de"], ",", true, "delimitertype", "r"), {"a", "bc", "de"})
+%!assert (strsplit (["a,bc,de"], "[, ]", true, "delimitertype", "r"), {"a", "bc", "de"})
+%!assert (strsplit ("hello \t world", 1, "delimitertype", "r"), {"hello", "world"});
 
 %% Test input validation
 %!error strsplit ()
-%!error strsplit ("abc")
 %!error strsplit ("abc", "b", true, 4)
-%!error <S and SEP must be string values> strsplit (123, "b")
-%!error <S and SEP must be string values> strsplit ("abc", 1)
-%!error <STRIP_EMPTY must be a scalar value> strsplit ("abc", "def", ones (3,3))
+%!error <S and DEL must be string values> strsplit (123, "b")
+%!error <COLLAPSEDELIMITERS must be a scalar value> strsplit ("abc", "def", ones (3,3))
 
diff --git a/scripts/testfun/rundemos.m b/scripts/testfun/rundemos.m
--- a/scripts/testfun/rundemos.m
+++ b/scripts/testfun/rundemos.m
@@ -25,17 +25,17 @@
 ## @seealso{runtests, path}
 ## @end deftypefn
 
 ## Author: jwe
 
 function rundemos (directory)
 
   if (nargin == 0)
-    dirs = strsplit (path (), pathsep ());
+    dirs = strsplit (path (), pathsep (), false);
   elseif (nargin == 1)
     if (is_absolute_filename (directory))
       dirs = {directory};
     else
       directory = regexprep (directory, ['\',filesep(),'$'], "");
       fullname = find_dir_in_path (directory);
       if (! isempty (fullname))
         dirs = {fullname};
diff --git a/scripts/testfun/runtests.m b/scripts/testfun/runtests.m
--- a/scripts/testfun/runtests.m
+++ b/scripts/testfun/runtests.m
@@ -25,17 +25,17 @@
 ## @seealso{rundemos, path}
 ## @end deftypefn
 
 ## Author: jwe
 
 function runtests (directory)
 
   if (nargin == 0)
-    dirs = strsplit (path (), pathsep ());
+    dirs = strsplit (path (), pathsep (), false);
   elseif (nargin == 1)
     if (is_absolute_filename (directory))
       dirs = {directory};
     else
       directory = regexprep (directory, ['\',filesep(),'$'], "");
       fullname = find_dir_in_path (directory);
       if (! isempty (fullname))
         dirs = {fullname};
