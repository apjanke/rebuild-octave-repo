# HG changeset patch
# User Kai T. Ohlhus <k.ohlhus@gmail.com>
# Date 1417781316 -3600
#      Fri Dec 05 13:08:36 2014 +0100
# Node ID af41e41ad28ea05ca0426de04f49e3f1de32c48c
# Parent  5db5619fe54e0e6a59cf2daf4bc2e523b7301f0a
replace oct-mem.h inline indirections by standard function calls.

* Array.h: replaced copy_or_memcpy, fill_or_memset, and no_ctor_new
* Array.cc: replaced copy_or_memcpy, and fill_or_memset
* idx-vector.h: replaced copy_or_memcpy, and fill_or_memset
* idx-vector.cc: replaced copy_or_memcpy
* boolSparse.cc: replaced copy_or_memcpy, and fill_or_memset
* Sparse.h: replaced copy_or_memcpy
* Sparse.cc: replaced copy_or_memcpy, and fill_or_memset
* oct-binmap.h: replaced copy_or_memcpy
* mx-inlines.cc: new standard header dependency
* module.mk: removed header entry
* oct-mem.h: removed unused header

diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -71,17 +71,17 @@ Array<T>::fill (const T& val)
 {
   if (rep->count > 1)
     {
       --rep->count;
       rep = new ArrayRep (length (), val);
       slice_data = rep->data;
     }
   else
-    fill_or_memset (slice_len, val, slice_data);
+    std::fill_n (slice_data, slice_len, val);
 }
 
 template <class T>
 void
 Array<T>::clear (void)
 {
   if (--rep->count == 0)
     delete rep;
@@ -394,17 +394,17 @@ private:
   T *do_permute (const T *src, T *dest, int lev) const
   {
     if (lev == 0)
       {
         octave_idx_type step = stride[0];
         octave_idx_type len = dim[0];
         if (step == 1)
           {
-            copy_or_memcpy (len, src, dest);
+            std::copy (src, src + len, dest);
             dest += len;
           }
         else
           {
             for (octave_idx_type i = 0, j = 0; i < len; i++, j += step)
               dest[i] = src[j];
 
             dest += len;
@@ -678,28 +678,28 @@ public:
 private:
 
   // recursive resizing
   template <class T>
   void do_resize_fill (const T* src, T *dest, const T& rfv, int lev) const
   {
     if (lev == 0)
       {
-        copy_or_memcpy (cext[0], src, dest);
-        fill_or_memset (dext[0] - cext[0], rfv, dest + cext[0]);
+        std::copy (src, src+cext[0], dest);
+        std::fill_n (dest + cext[0], dext[0] - cext[0], rfv);
       }
     else
       {
         octave_idx_type sd, dd, k;
         sd = sext[lev-1];
         dd = dext[lev-1];
         for (k = 0; k < cext[lev]; k++)
           do_resize_fill (src + k * sd, dest + k * dd, rfv, lev - 1);
 
-        fill_or_memset (dext[lev] - k * dd, rfv, dest + k * dd);
+        std::fill_n (dest + k * dd, dext[lev] - k * dd, rfv);
       }
   }
 
   // No copying!
 
   rec_resize_helper (const rec_resize_helper&);
 
   rec_resize_helper& operator = (const rec_resize_helper&);
@@ -954,31 +954,31 @@ Array<T>::resize1 (octave_idx_type n, co
                 }
               else
                 {
                   static const octave_idx_type max_stack_chunk = 1024;
                   octave_idx_type nn = n + std::min (nx, max_stack_chunk);
                   Array<T> tmp (Array<T> (dim_vector (nn, 1)), dv, 0, n);
                   T *dest = tmp.fortran_vec ();
 
-                  copy_or_memcpy (nx, data (), dest);
+                  std::copy (data (), data () + nx, dest);
                   dest[nx] = rfv;
 
                   *this = tmp;
                 }
             }
           else if (n != nx)
             {
               Array<T> tmp = Array<T> (dv);
               T *dest = tmp.fortran_vec ();
 
               octave_idx_type n0 = std::min (n, nx);
               octave_idx_type n1 = n - n0;
-              copy_or_memcpy (n0, data (), dest);
-              fill_or_memset (n1, rfv, dest + n0);
+              std::copy (data (), data () + n0, dest);
+              std::fill_n (dest + n0, n1, rfv);
 
               *this = tmp;
             }
         }
     }
   else
     gripe_invalid_resize ();
 }
@@ -998,32 +998,32 @@ Array<T>::resize2 (octave_idx_type r, oc
 
           octave_idx_type r0 = std::min (r, rx);
           octave_idx_type r1 = r - r0;
           octave_idx_type c0 = std::min (c, cx);
           octave_idx_type c1 = c - c0;
           const T *src = data ();
           if (r == rx)
             {
-              copy_or_memcpy (r * c0, src, dest);
+              std::copy (src, src + r * c0, dest);
               dest += r * c0;
             }
           else
             {
               for (octave_idx_type k = 0; k < c0; k++)
                 {
-                  copy_or_memcpy (r0, src, dest);
+                  std::copy (src, src + r0, dest);
                   src += rx;
                   dest += r0;
-                  fill_or_memset (r1, rfv, dest);
+                  std::fill_n (dest, r1, rfv);
                   dest += r1;
                 }
             }
 
-          fill_or_memset (r * c1, rfv, dest);
+          std::fill_n (dest, r * c1, rfv);
 
           *this = tmp;
         }
     }
   else
     gripe_invalid_resize ();
 
 }
@@ -1411,18 +1411,18 @@ Array<T>::delete_elements (const idx_vec
         }
       else if (i.is_cont_range (n, l, u))
         {
           // Special case deleting a contiguous range.
           octave_idx_type m = n + l - u;
           Array<T> tmp (dim_vector (col_vec ? m : 1, !col_vec ? m : 1));
           const T *src = data ();
           T *dest = tmp.fortran_vec ();
-          copy_or_memcpy (l, src, dest);
-          copy_or_memcpy (n - u, src + u, dest + l);
+          std::copy (src, src + l, dest);
+          std::copy (src + u, src + n, dest + l);
           *this = tmp;
         }
       else
         {
           // Use index.
           *this = index (i.complement (n));
         }
     }
@@ -1464,19 +1464,19 @@ Array<T>::delete_elements (int dim, cons
 
           // Special case deleting a contiguous range.
           Array<T> tmp = Array<T> (rdv);
           const T *src = data ();
           T *dest = tmp.fortran_vec ();
           l *= dl; u *= dl; n *= dl;
           for (octave_idx_type k = 0; k < du; k++)
             {
-              copy_or_memcpy (l, src, dest);
+              std::copy (src, src + l, dest);
               dest += l;
-              copy_or_memcpy (n - u, src + u, dest);
+              std::copy (src + u, src + n, dest);
               dest += n - u;
               src += n;
             }
 
           *this = tmp;
         }
       else
         {
diff --git a/liboctave/array/Array.h b/liboctave/array/Array.h
--- a/liboctave/array/Array.h
+++ b/liboctave/array/Array.h
@@ -33,17 +33,16 @@ along with Octave; see the file COPYING.
 #include <iosfwd>
 
 #include "dim-vector.h"
 #include "idx-vector.h"
 #include "lo-traits.h"
 #include "lo-utils.h"
 #include "oct-sort.h"
 #include "quit.h"
-#include "oct-mem.h"
 #include "oct-refcount.h"
 
 //!Handles the reference counting for all the derived classes.
 template <class T>
 class
 Array
 {
 protected:
@@ -53,46 +52,46 @@ protected:
   {
   public:
 
     T *data;
     octave_idx_type len;
     octave_refcount<int> count;
 
     ArrayRep (T *d, octave_idx_type l)
-      : data (no_ctor_new<T> (l)), len (l), count (1)
+      : data (new T [l]), len (l), count (1)
     {
-      copy_or_memcpy (l, d, data);
+      std::copy (d, d+l, data);
     }
 
     template <class U>
     ArrayRep (U *d, octave_idx_type l)
-      : data (no_ctor_new<T> (l)), len (l), count (1)
+      : data (new T [l]), len (l), count (1)
     {
       std::copy (d, d+l, data);
     }
 
     ArrayRep (void) : data (0), len (0), count (1) { }
 
     explicit ArrayRep (octave_idx_type n)
-      : data (no_ctor_new<T> (n)), len (n), count (1) { }
+      : data (new T [n]), len (n), count (1) { }
 
     explicit ArrayRep (octave_idx_type n, const T& val)
-      : data (no_ctor_new<T> (n)), len (n), count (1)
+      : data (new T [n]), len (n), count (1)
     {
-      fill_or_memset (n, val, data);
+      std::fill_n (data, n, val);
     }
 
     ArrayRep (const ArrayRep& a)
-      : data (no_ctor_new<T> (a.len)), len (a.len), count (1)
+      : data (new T [a.len]), len (a.len), count (1)
     {
-      copy_or_memcpy (a.len, a.data, data);
+      std::copy (a.data, a.data + a.len, data);
     }
 
-    ~ArrayRep (void) { no_ctor_delete<T> (data); }
+    ~ArrayRep (void) { delete [] data; }
 
     octave_idx_type length (void) const { return len; }
 
   private:
 
     // No assignment!
 
     ArrayRep& operator = (const ArrayRep& a);
diff --git a/liboctave/array/Sparse.cc b/liboctave/array/Sparse.cc
--- a/liboctave/array/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -165,23 +165,23 @@ Sparse<T>::SparseRep::change_length (oct
   // discard.
   static const int frac = 5;
   if (nz > nzmx || nz < nzmx - nzmx/frac)
     {
       // Reallocate.
       octave_idx_type min_nzmx = std::min (nz, nzmx);
 
       octave_idx_type * new_ridx = new octave_idx_type [nz];
-      copy_or_memcpy (min_nzmx, r, new_ridx);
+      std::copy (r, r + min_nzmx, new_ridx);
 
       delete [] r;
       r = new_ridx;
 
       T * new_data = new T [nz];
-      copy_or_memcpy (min_nzmx, d, new_data);
+      std::copy (d, d + min_nzmx, new_data);
 
       delete [] d;
       d = new_data;
 
       nzmx = nz;
     }
 }
 
@@ -973,23 +973,23 @@ Sparse<T>::resize (octave_idx_type r, oc
         }
     }
 
   rep->nrows = dimensions(0) = r;
 
   if (c != rep->ncols)
     {
       octave_idx_type *new_cidx = new octave_idx_type [c+1];
-      copy_or_memcpy (std::min (c, rep->ncols)+1, rep->c, new_cidx);
+      std::copy (rep->c, rep->c + std::min (c, rep->ncols) + 1, new_cidx);
       delete [] rep->c;
       rep->c = new_cidx;
 
       if (c > rep->ncols)
-        fill_or_memset (c - rep->ncols, rep->c[rep->ncols],
-                        rep->c + rep->ncols + 1);
+        std::fill_n (rep->c + rep->ncols + 1, c - rep->ncols,
+          rep->c[rep->ncols]);
     }
 
   rep->ncols = dimensions(1) = c;
 
   rep->change_length (rep->nnz ());
 }
 
 template <class T>
@@ -1175,19 +1175,19 @@ Sparse<T>::delete_elements (const idx_ve
         {
           // Special-case a contiguous range.
           // Look-up indices first.
           octave_idx_type li = lblookup (tmp.ridx (), nz, lb);
           octave_idx_type ui = lblookup (tmp.ridx (), nz, ub);
           // Copy data and adjust indices.
           octave_idx_type nz_new = nz - (ui - li);
           *this = Sparse<T> (nr - (ub - lb), 1, nz_new);
-          copy_or_memcpy (li, tmp.data (), data ());
-          copy_or_memcpy (li, tmp.ridx (), xridx ());
-          copy_or_memcpy (nz - ui, tmp.data () + ui, xdata () + li);
+          std::copy (tmp.data (), tmp.data () + li, data ());
+          std::copy (tmp.ridx (), tmp.ridx () + li, xridx ());
+          std::copy (tmp.data () + ui, tmp.data () + nz, xdata () + li);
           mx_inline_sub (nz - ui, xridx () + li, tmp.ridx () + ui, ub - lb);
           xcidx (1) = nz_new;
         }
       else
         {
           OCTAVE_LOCAL_BUFFER (octave_idx_type, ridx_new, nz);
           OCTAVE_LOCAL_BUFFER (T, data_new, nz);
           idx_vector sidx = idx.sorted (true);
@@ -1202,36 +1202,36 @@ Sparse<T>::delete_elements (const idx_ve
               if (j == sl || sj[j] > r)
                 {
                   data_new[nz_new] = tmp.data (i);
                   ridx_new[nz_new++] = r - j;
                 }
             }
 
           *this = Sparse<T> (nr - sl, 1, nz_new);
-          copy_or_memcpy (nz_new, ridx_new, ridx ());
-          copy_or_memcpy (nz_new, data_new, xdata ());
+          std::copy (ridx_new, ridx_new + nz_new, ridx ());
+          std::copy (data_new, data_new + nz_new, xdata ());
           xcidx (1) = nz_new;
         }
     }
   else if (nr == 1)
     {
       // Sparse row vector.
       octave_idx_type lb, ub;
       if (idx.is_cont_range (nc, lb, ub))
         {
           const Sparse<T> tmp = *this;
           octave_idx_type lbi = tmp.cidx (lb);
           octave_idx_type ubi = tmp.cidx (ub);
           octave_idx_type new_nz = nz - (ubi - lbi);
           *this = Sparse<T> (1, nc - (ub - lb), new_nz);
-          copy_or_memcpy (lbi, tmp.data (), data ());
-          copy_or_memcpy (nz - ubi, tmp.data () + ubi, xdata () + lbi);
-          fill_or_memset (new_nz, static_cast<octave_idx_type> (0), ridx ());
-          copy_or_memcpy (lb, tmp.cidx () + 1, cidx () + 1);
+          std::copy (tmp.data (), tmp.data () + lbi, data ());
+          std::copy (tmp.data () + ubi, tmp.data () + nz , xdata () + lbi);
+          std::fill_n (ridx (), new_nz, static_cast<octave_idx_type> (0));
+          std::copy (tmp.cidx () + 1, tmp.cidx () + 1 + lb, cidx () + 1);
           mx_inline_sub (nc - ub, xcidx () + 1, tmp.cidx () + ub + 1,
                          ubi - lbi);
         }
       else
         *this = index (idx.complement (nc));
     }
   else if (idx.length (nel) != 0)
     {
@@ -1277,21 +1277,21 @@ Sparse<T>::delete_elements (const idx_ve
           else
             {
               const Sparse<T> tmp = *this;
               octave_idx_type lbi = tmp.cidx (lb);
               octave_idx_type ubi = tmp.cidx (ub);
               octave_idx_type new_nz = nz - (ubi - lbi);
 
               *this = Sparse<T> (nr, nc - (ub - lb), new_nz);
-              copy_or_memcpy (lbi, tmp.data (), data ());
-              copy_or_memcpy (lbi, tmp.ridx (), ridx ());
-              copy_or_memcpy (nz - ubi, tmp.data () + ubi, xdata () + lbi);
-              copy_or_memcpy (nz - ubi, tmp.ridx () + ubi, xridx () + lbi);
-              copy_or_memcpy (lb, tmp.cidx () + 1, cidx () + 1);
+              std::copy (tmp.data (), tmp.data () + lbi, data ());
+              std::copy (tmp.ridx (), tmp.ridx () + lbi, ridx ());
+              std::copy (tmp.data () + ubi, tmp.data () + nz, xdata () + lbi);
+              std::copy (tmp.ridx () + ubi, tmp.ridx () + nz, xridx () + lbi);
+              std::copy (tmp.cidx () + 1, tmp.cidx () + 1 + lb, cidx () + 1);
               mx_inline_sub (nc - ub, xcidx () + lb + 1,
                              tmp.cidx () + ub + 1, ubi - lbi);
             }
         }
       else
         *this = index (idx_i, idx_j.complement (nc));
     }
   else if (idx_j.is_colon ())
@@ -1462,30 +1462,30 @@ Sparse<T>::index (const idx_vector& idx,
         {
           // Special-case a contiguous range.
           // Look-up indices first.
           octave_idx_type li = lblookup (ridx (), nz, lb);
           octave_idx_type ui = lblookup (ridx (), nz, ub);
           // Copy data and adjust indices.
           octave_idx_type nz_new = ui - li;
           retval = Sparse<T> (ub - lb, 1, nz_new);
-          copy_or_memcpy (nz_new, data () + li, retval.data ());
+          std::copy (data () + li, data () + li + nz_new, retval.data ());
           mx_inline_sub (nz_new, retval.xridx (), ridx () + li, lb);
           retval.xcidx (1) = nz_new;
         }
       else if (idx.is_permutation (nel) && idx.is_vector ())
         {
           if (idx.is_range () && idx.increment () == -1)
             {
               retval = Sparse<T> (nr, 1, nz);
 
               for (octave_idx_type j = 0; j < nz; j++)
                 retval.ridx (j) = nr - ridx (nz - j - 1) - 1;
 
-              copy_or_memcpy (2, cidx (), retval.cidx ());
+              std::copy (cidx (), cidx () + 2, retval.cidx ());
               std::reverse_copy (data (), data () + nz, retval.data ());
             }
           else
             {
               Array<T> tmp = array_value ();
               tmp = tmp.index (idx);
               retval = Sparse<T> (tmp);
             }
@@ -1547,19 +1547,18 @@ Sparse<T>::index (const idx_vector& idx,
         retval = Sparse<T> (1, 1, elem (0, idx(0)));
       else if (idx.is_cont_range (nel, lb, ub))
         {
           // Special-case a contiguous range.
           octave_idx_type lbi = cidx (lb);
           octave_idx_type ubi = cidx (ub);
           octave_idx_type new_nz = ubi - lbi;
           retval = Sparse<T> (1, ub - lb, new_nz);
-          copy_or_memcpy (new_nz, data () + lbi, retval.data ());
-          fill_or_memset (new_nz, static_cast<octave_idx_type> (0),
-                          retval.ridx ());
+          std::copy (data () + lbi, data () + lbi + new_nz, retval.data ());
+          std::fill_n (retval.ridx (), new_nz, static_cast<octave_idx_type> (0));
           mx_inline_sub (ub - lb + 1, retval.cidx (), cidx () + lb, lbi);
         }
       else
         {
           // Sparse row vectors occupy O(nr) storage anyway, so let's just
           // convert the matrix to full, index, and sparsify the result.
           retval = Sparse<T> (array_value ().index (idx));
         }
@@ -1634,18 +1633,18 @@ Sparse<T>::index (const idx_vector& idx_
         retval = *this; // Shallow copy.
       else if (idx_j.is_cont_range (nc, lb, ub))
         {
           // Special-case a contiguous range.
           octave_idx_type lbi = cidx (lb);
           octave_idx_type ubi = cidx (ub);
           octave_idx_type new_nz = ubi - lbi;
           retval = Sparse<T> (nr, ub - lb, new_nz);
-          copy_or_memcpy (new_nz, data () + lbi, retval.data ());
-          copy_or_memcpy (new_nz, ridx () + lbi, retval.ridx ());
+          std::copy (data () + lbi, data () + lbi + new_nz, retval.data ());
+          std::copy (ridx () + lbi, ridx () + lbi + new_nz, retval.ridx ());
           mx_inline_sub (ub - lb + 1, retval.cidx (), cidx () + lb, lbi);
         }
       else
         {
           // Count new nonzero elements.
           retval = Sparse<T> (nr, m);
           for (octave_idx_type j = 0; j < m; j++)
             {
@@ -1657,18 +1656,18 @@ Sparse<T>::index (const idx_vector& idx_
 
           // Copy data & indices.
           for (octave_idx_type j = 0; j < m; j++)
             {
               octave_idx_type ljj = cidx (idx_j(j));
               octave_idx_type lj = retval.xcidx (j);
               octave_idx_type nzj = retval.xcidx (j+1) - lj;
 
-              copy_or_memcpy (nzj, data () + ljj, retval.data () + lj);
-              copy_or_memcpy (nzj, ridx () + ljj, retval.ridx () + lj);
+              std::copy (data () + ljj, data () + ljj + nzj, retval.data () + lj);
+              std::copy (ridx () + ljj, ridx () + ljj + nzj, retval.ridx () + lj);
             }
         }
     }
   else if (nc == 1 && idx_j.is_colon_equiv (nc) && idx_i.is_vector ())
     {
       // It's actually vector indexing. The 1D index is specialized for that.
       retval = index (idx_i);
 
@@ -1888,38 +1887,38 @@ Sparse<T>::assign (const idx_vector& idx
                       // Make room first.
                       std::copy_backward (data () + ui, data () + nz,
                                           data () + nz + rnz);
                       std::copy_backward (ridx () + ui, ridx () + nz,
                                           ridx () + nz + rnz);
                     }
 
                   // Copy data and adjust indices from rhs.
-                  copy_or_memcpy (rnz, rhs.data (), data () + li);
+                  std::copy (rhs.data (), rhs.data () + rnz, data () + li);
                   mx_inline_add (rnz, ridx () + li, rhs.ridx (), lb);
                 }
               else
                 {
                   // Clearing elements or exceeding capacity, allocate afresh
                   // and paste pieces.
                   const Sparse<T> tmp = *this;
                   *this = Sparse<T> (nr, 1, new_nz);
 
                   // Head ...
-                  copy_or_memcpy (li, tmp.data (), data ());
-                  copy_or_memcpy (li, tmp.ridx (), ridx ());
+                  std::copy (tmp.data (), tmp.data () + li, data ());
+                  std::copy (tmp.ridx (), tmp.ridx () + li, ridx ());
 
                   // new stuff ...
-                  copy_or_memcpy (rnz, rhs.data (), data () + li);
+                  std::copy (rhs.data (), rhs.data () + rnz, data () + li);
                   mx_inline_add (rnz, ridx () + li, rhs.ridx (), lb);
 
                   // ...tail
-                  copy_or_memcpy (nz - ui, tmp.data () + ui,
+                  std::copy (tmp.data () + ui, tmp.data () + nz,
                                   data () + li + rnz);
-                  copy_or_memcpy (nz - ui, tmp.ridx () + ui,
+                  std::copy (tmp.ridx () + ui, tmp.ridx () + nz,
                                   ridx () + li + rnz);
                 }
 
               cidx (1) = new_nz;
             }
           else if (idx.is_range () && idx.increment () == -1)
             {
               // It's s(u:-1:l) = r. Reverse the assignment.
@@ -1945,18 +1944,18 @@ Sparse<T>::assign (const idx_vector& idx
             }
           else
             {
               const Sparse<T> tmp = *this;
               octave_idx_type new_nz = nz + rhl;
               // Disassembly our matrix...
               Array<octave_idx_type> new_ri (dim_vector (new_nz, 1));
               Array<T> new_data (dim_vector (new_nz, 1));
-              copy_or_memcpy (nz, tmp.ridx (), new_ri.fortran_vec ());
-              copy_or_memcpy (nz, tmp.data (), new_data.fortran_vec ());
+              std::copy (tmp.ridx (), tmp.ridx () + nz, new_ri.fortran_vec ());
+              std::copy (tmp.data (), tmp.data () + nz, new_data.fortran_vec ());
               // ... insert new data (densified) ...
               idx.copy_data (new_ri.fortran_vec () + nz);
               new_data.assign (idx_vector (nz, new_nz), rhs.array_value ());
               // ... reassembly.
               *this = Sparse<T> (new_data, new_ri,
                                  static_cast<octave_idx_type> (0),
                                  nr, nc, false);
             }
@@ -2072,45 +2071,45 @@ Sparse<T>::assign (const idx_vector& idx
                       std::copy (data () + ui, data () + nz,
                                  data () + li + rnz);
                       std::copy (ridx () + ui, ridx () + nz,
                                  ridx () + li + rnz);
                       mx_inline_add2 (nc - ub, cidx () + ub + 1, new_nz - nz);
                     }
 
                   // Copy data and indices from rhs.
-                  copy_or_memcpy (rnz, rhs.data (), data () + li);
-                  copy_or_memcpy (rnz, rhs.ridx (), ridx () + li);
+                  std::copy (rhs.data (), rhs.data () + rnz, data () + li);
+                  std::copy (rhs.ridx (), rhs.ridx () + rnz, ridx () + li);
                   mx_inline_add (ub - lb, cidx () + lb + 1, rhs.cidx () + 1,
                                  li);
 
                   assert (nnz () == new_nz);
                 }
               else
                 {
                   // Clearing elements or exceeding capacity, allocate afresh
                   // and paste pieces.
                   const Sparse<T> tmp = *this;
                   *this = Sparse<T> (nr, nc, new_nz);
 
                   // Head...
-                  copy_or_memcpy (li, tmp.data (), data ());
-                  copy_or_memcpy (li, tmp.ridx (), ridx ());
-                  copy_or_memcpy (lb, tmp.cidx () + 1, cidx () + 1);
+                  std::copy (tmp.data (), tmp.data () + li, data ());
+                  std::copy (tmp.ridx (), tmp.ridx () + li, ridx ());
+                  std::copy (tmp.cidx () + 1, tmp.cidx () + 1 + lb, cidx () + 1);
 
                   // new stuff...
-                  copy_or_memcpy (rnz, rhs.data (), data () + li);
-                  copy_or_memcpy (rnz, rhs.ridx (), ridx () + li);
+                  std::copy (rhs.data (), rhs.data () + rnz, data () + li);
+                  std::copy (rhs.ridx (), rhs.ridx () + rnz, ridx () + li);
                   mx_inline_add (ub - lb, cidx () + lb + 1, rhs.cidx () + 1,
                                  li);
 
                   // ...tail.
-                  copy_or_memcpy (nz - ui, tmp.data () + ui,
+                  std::copy (tmp.data () + ui, tmp.data () + nz,
                                   data () + li + rnz);
-                  copy_or_memcpy (nz - ui, tmp.ridx () + ui,
+                  std::copy (tmp.ridx () + ui, tmp.ridx () + nz,
                                   ridx () + li + rnz);
                   mx_inline_add (nc - ub, cidx () + ub + 1,
                                  tmp.cidx () + ub + 1, new_nz - nz);
 
                   assert (nnz () == new_nz);
                 }
             }
           else if (idx_j.is_range () && idx_j.increment () == -1)
@@ -2151,25 +2150,29 @@ Sparse<T>::assign (const idx_vector& idx
                 {
                   octave_idx_type l = xcidx (i);
                   octave_idx_type u = xcidx (i+1);
                   octave_idx_type j = jsav[i];
                   if (j >= 0)
                     {
                       // from rhs
                       octave_idx_type k = rhs.cidx (j);
-                      copy_or_memcpy (u - l, rhs.data () + k, xdata () + l);
-                      copy_or_memcpy (u - l, rhs.ridx () + k, xridx () + l);
+                      std::copy (rhs.data () + k, rhs.data () + k + u - l,
+                        xdata () + l);
+                      std::copy (rhs.ridx () + k, rhs.ridx () + k + u - l,
+                        xridx () + l);
                     }
                   else
                     {
                       // original
                       octave_idx_type k = tmp.cidx (i);
-                      copy_or_memcpy (u - l, tmp.data () + k, xdata () + l);
-                      copy_or_memcpy (u - l, tmp.ridx () + k, xridx () + l);
+                      std::copy (tmp.data () + k, tmp.data () + k + u - l,
+                        xdata () + l);
+                      std::copy (tmp.ridx () + k, tmp.ridx () + k + u - l,
+                        xridx () + l);
                     }
                 }
 
             }
         }
       else if (nc == 1 && idx_j.is_colon_equiv (nc) && idx_i.is_vector ())
         {
           // It's just vector indexing.  The 1D assign is specialized for that.
diff --git a/liboctave/array/Sparse.h b/liboctave/array/Sparse.h
--- a/liboctave/array/Sparse.h
+++ b/liboctave/array/Sparse.h
@@ -33,17 +33,16 @@ along with Octave; see the file COPYING.
 #include <algorithm>
 
 #include "Array.h"
 #include "dim-vector.h"
 #include "lo-error.h"
 #include "lo-utils.h"
 
 #include "oct-sort.h"
-#include "oct-mem.h"
 
 class idx_vector;
 class PermMatrix;
 
 // Two dimensional sparse class.  Handles the reference counting for
 // all the derived classes.
 
 template <class T>
@@ -97,19 +96,19 @@ protected:
     }
 
     SparseRep (const SparseRep& a)
       : d (new T [a.nzmx]), r (new octave_idx_type [a.nzmx]),
         c (new octave_idx_type [a.ncols + 1]),
         nzmx (a.nzmx), nrows (a.nrows), ncols (a.ncols), count (1)
     {
       octave_idx_type nz = a.nnz ();
-      copy_or_memcpy (nz, a.d, d);
-      copy_or_memcpy (nz, a.r, r);
-      copy_or_memcpy (ncols + 1, a.c, c);
+      std::copy (a.d, a.d + nz, d);
+      std::copy (a.r, a.r + nz, r);
+      std::copy (a.c, a.c + ncols + 1, c);
     }
 
     ~SparseRep (void) { delete [] d; delete [] r; delete [] c; }
 
     octave_idx_type length (void) const { return nzmx; }
 
     octave_idx_type nnz (void) const { return c[ncols]; }
 
@@ -208,18 +207,18 @@ public:
   template <class U>
   Sparse (const Sparse<U>& a)
     : rep (new typename Sparse<T>::SparseRep (a.rep->nrows, a.rep->ncols,
            a.rep->nzmx)),
     dimensions (a.dimensions)
   {
     octave_idx_type nz = a.nnz ();
     std::copy (a.rep->d, a.rep->d + nz, rep->d);
-    copy_or_memcpy (nz, a.rep->r, rep->r);
-    copy_or_memcpy (rep->ncols + 1, a.rep->c, rep->c);
+    std::copy (a.rep->r, a.rep->r + nz, rep->r);
+    std::copy (a.rep->c, a.rep->c + rep->ncols + 1, rep->c);
   }
 
   // No type conversion case.
   Sparse (const Sparse<T>& a)
     : rep (a.rep), dimensions (a.dimensions)
   {
     rep->count++;
   }
diff --git a/liboctave/array/boolSparse.cc b/liboctave/array/boolSparse.cc
--- a/liboctave/array/boolSparse.cc
+++ b/liboctave/array/boolSparse.cc
@@ -30,17 +30,16 @@ along with Octave; see the file COPYING.
 #include <vector>
 
 #include "quit.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 
 #include "boolSparse.h"
 #include "dSparse.h"
-#include "oct-mem.h"
 #include "oct-locbuf.h"
 
 #include "Sparse-op-defs.h"
 
 // SparseBoolMatrix class.
 
 bool
 SparseBoolMatrix::operator == (const SparseBoolMatrix& a) const
@@ -155,34 +154,34 @@ SparseBoolMatrix::any (int dim) const
     {
       // Result is a row vector.
       retval = Sparse<bool> (1, nc);
       retval.xcidx (0) = 0;
       for (octave_idx_type i = 0; i < nc; i++)
         retval.xcidx (i+1) = retval.xcidx (i) + (cidx (i+1) > cidx (i));
       octave_idx_type new_nz = retval.xcidx (nc);
       retval.change_capacity (new_nz);
-      fill_or_memset (new_nz, static_cast<octave_idx_type> (0), retval.ridx ());
-      fill_or_memset (new_nz, true, retval.data ());
+      std::fill_n (retval.ridx (), new_nz, static_cast<octave_idx_type> (0));
+      std::fill_n (retval.data (), new_nz, true);
     }
   else if (dim == 1)
     {
       // Result is a column vector.
       if (nz > nr/4)
         {
           // We can use O(nr) memory.
           Array<bool> tmp (dim_vector (nr, 1), false);
           for (octave_idx_type i = 0; i < nz; i++)
             tmp.xelem (ridx (i)) = true;
           retval = tmp;
         }
       else
         {
           Array<octave_idx_type> tmp (dim_vector (nz, 1));
-          copy_or_memcpy (nz, ridx (), tmp.fortran_vec ());
+          std::copy (ridx (), ridx () + nz, tmp.fortran_vec ());
           retval = Sparse<bool> (Array<bool> (dim_vector (1, 1), true),
                                  idx_vector (tmp),
                                  idx_vector (static_cast<octave_idx_type> (0)),
                                  nr, 1, false);
         }
     }
 
   return retval;
@@ -201,17 +200,17 @@ SparseBoolMatrix::sum (int dim) const
   if (dim == 0)
     {
       // Result is a row vector.
       retval = Sparse<double> (1, nc);
       for (octave_idx_type i = 0; i < nc; i++)
         retval.xcidx (i+1) = retval.xcidx (i) + (cidx (i+1) > cidx (i));
       octave_idx_type new_nz = retval.xcidx (nc);
       retval.change_capacity (new_nz);
-      fill_or_memset (new_nz, static_cast<octave_idx_type> (0), retval.ridx ());
+      std::fill_n (retval.ridx (), new_nz, static_cast<octave_idx_type> (0));
       for (octave_idx_type i = 0, k = 0; i < nc; i++)
         {
           octave_idx_type c = cidx (i+1) - cidx (i);
           if (c > 0)
             retval.xdata (k++) = c;
         }
     }
   else if (dim == 1)
@@ -223,17 +222,17 @@ SparseBoolMatrix::sum (int dim) const
           Array<double> tmp (dim_vector (nr, 1), 0);
           for (octave_idx_type i = 0; i < nz; i++)
             tmp.xelem (ridx (i)) += 1.0;
           retval = tmp;
         }
       else
         {
           Array<octave_idx_type> tmp (dim_vector (nz, 1));
-          copy_or_memcpy (nz, ridx (), tmp.fortran_vec ());
+          std::copy (ridx (), ridx () + nz, tmp.fortran_vec ());
           retval = Sparse<double> (Array<double> (dim_vector (1, 1), 1.0),
                                    idx_vector (tmp),
                                    idx_vector (static_cast<octave_idx_type> (0)),
                                    nr, 1);
         }
     }
 
   return retval;
diff --git a/liboctave/array/idx-vector.cc b/liboctave/array/idx-vector.cc
--- a/liboctave/array/idx-vector.cc
+++ b/liboctave/array/idx-vector.cc
@@ -1088,17 +1088,17 @@ idx_vector::copy_data (octave_idx_type *
         *data = r->get_data ();
       }
       break;
 
     case class_vector:
       {
         idx_vector_rep * r = dynamic_cast<idx_vector_rep *> (rep);
         const octave_idx_type *rdata = r->get_data ();
-        copy_or_memcpy (len, rdata, data);
+        std::copy (rdata, rdata + len, data);
       }
       break;
 
     case class_mask:
       {
         idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
         const bool *mask = r->get_data ();
         octave_idx_type ext = r->extent (0);
diff --git a/liboctave/array/idx-vector.h b/liboctave/array/idx-vector.h
--- a/liboctave/array/idx-vector.h
+++ b/liboctave/array/idx-vector.h
@@ -21,25 +21,25 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_idx_vector_h)
 #define octave_idx_vector_h 1
 
 #include <cassert>
+#include <cstring>
 
 #include <algorithm>
 #include <iosfwd>
 #include <memory>
 
 #include "dim-vector.h"
 #include "oct-inttypes.h"
 #include "oct-alloc.h"
-#include "oct-mem.h"
 #include "oct-refcount.h"
 
 template<class T> class Array;
 template<class T> class Sparse;
 class Range;
 
 // Design rationale:
 // idx_vector is a reference-counting, polymorphic pointer, that can contain
@@ -626,27 +626,27 @@ public:
   octave_idx_type
   index (const T *src, octave_idx_type n, T *dest) const
   {
     octave_idx_type len = rep->length (n);
 
     switch (rep->idx_class ())
       {
       case class_colon:
-        copy_or_memcpy (len, src, dest);
+        std::copy (src, src + len, dest);
         break;
 
       case class_range:
         {
           idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
           octave_idx_type start = r->get_start ();
           octave_idx_type step = r->get_step ();
           const T *ssrc = src + start;
           if (step == 1)
-            copy_or_memcpy (len, ssrc, dest);
+            std::copy (ssrc, ssrc + len, dest);
           else if (step == -1)
             std::reverse_copy (ssrc - len + 1, ssrc + 1, dest);
           else if (step == 0)
             std::fill_n (dest, len, *ssrc);
           else
             {
               for (octave_idx_type i = 0, j = 0; i < len; i++, j += step)
                 dest[i] = ssrc[j];
@@ -700,27 +700,27 @@ public:
   octave_idx_type
   assign (const T *src, octave_idx_type n, T *dest) const
   {
     octave_idx_type len = rep->length (n);
 
     switch (rep->idx_class ())
       {
       case class_colon:
-        copy_or_memcpy (len, src, dest);
+        std::copy (src, src + len, dest);
         break;
 
       case class_range:
         {
           idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
           octave_idx_type start = r->get_start ();
           octave_idx_type step = r->get_step ();
           T *sdest = dest + start;
           if (step == 1)
-            copy_or_memcpy (len, src, sdest);
+            std::copy (src, src + len, sdest);
           else if (step == -1)
             std::reverse_copy (src, src + len, sdest - len + 1);
           else
             {
               for (octave_idx_type i = 0, j = 0; i < len; i++, j += step)
                 sdest[j] = src[i];
             }
         }
diff --git a/liboctave/operators/mx-inlines.cc b/liboctave/operators/mx-inlines.cc
--- a/liboctave/operators/mx-inlines.cc
+++ b/liboctave/operators/mx-inlines.cc
@@ -22,16 +22,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #if !defined (octave_mx_inlines_h)
 #define octave_mx_inlines_h 1
 
 #include <cstddef>
 #include <cmath>
+#include <cstring>
 #include <memory>
 
 #include "quit.h"
 
 #include "oct-cmplx.h"
 #include "oct-locbuf.h"
 #include "oct-inttypes.h"
 #include "Array.h"
diff --git a/liboctave/util/module.mk b/liboctave/util/module.mk
--- a/liboctave/util/module.mk
+++ b/liboctave/util/module.mk
@@ -21,17 +21,16 @@ UTIL_INC = \
   util/oct-alloc.h \
   util/oct-base64.h \
   util/oct-binmap.h \
   util/oct-cmplx.h \
   util/oct-glob.h \
   util/oct-inttypes.h \
   util/oct-locbuf.h \
   util/oct-md5.h \
-  util/oct-mem.h \
   util/oct-mutex.h \
   util/oct-refcount.h \
   util/oct-rl-edit.h \
   util/oct-rl-hist.h \
   util/oct-shlib.h \
   util/oct-sort.h \
   util/oct-sparse.h \
   util/pathsearch.h \
diff --git a/liboctave/util/oct-binmap.h b/liboctave/util/oct-binmap.h
--- a/liboctave/util/oct-binmap.h
+++ b/liboctave/util/oct-binmap.h
@@ -221,18 +221,18 @@ binmap (const T& x, const Sparse<R>& ys,
 {
   R yzero = R ();
   U fz = fcn (x, yzero);
 
   if (fz == U ())  // Sparsity preserving fcn
     {
       octave_idx_type nz = ys.nnz ();
       Sparse<U> retval (ys.rows (), ys.cols (), nz);
-      copy_or_memcpy (nz, ys.ridx (), retval.ridx ());
-      copy_or_memcpy (ys.cols () + 1, ys.cidx (), retval.cidx ());
+      std::copy (ys.ridx (), ys.ridx () + nz, retval.ridx ());
+      std::copy (ys.cidx (), ys.cidx () + ys.cols () + 1, retval.cidx ());
 
       for (octave_idx_type i = 0; i < nz; i++)
         {
           octave_quit ();
           // FIXME: Could keep track of whether fcn call results in a 0.
           //        If no zeroes are created could skip maybe_compress()
           retval.xdata (i) = fcn (x, ys.data (i));
         }
@@ -252,18 +252,18 @@ binmap (const Sparse<T>& xs, const R& y,
 {
   T xzero = T ();
   U fz = fcn (xzero, y);
 
   if (fz == U ())  // Sparsity preserving fcn
     {
       octave_idx_type nz = xs.nnz ();
       Sparse<U> retval (xs.rows (), xs.cols (), nz);
-      copy_or_memcpy (nz, xs.ridx (), retval.ridx ());
-      copy_or_memcpy (xs.cols () + 1, xs.cidx (), retval.cidx ());
+      std::copy (xs.ridx (), xs.ridx () + nz, retval.ridx ());
+      std::copy (xs.cidx (), xs.cidx () + xs.cols () + 1, retval.cidx ());
 
       for (octave_idx_type i = 0; i < nz; i++)
         {
           octave_quit ();
           // FIXME: Could keep track of whether fcn call results in a 0.
           //        If no zeroes are created could skip maybe_compress()
           retval.xdata (i) = fcn (xs.data (i), y);
         }
diff --git a/liboctave/util/oct-mem.h b/liboctave/util/oct-mem.h
deleted file mode 100644
--- a/liboctave/util/oct-mem.h
+++ /dev/null
@@ -1,160 +0,0 @@
-/*
-
-Copyright (C) 2009-2013 VZLU Prague
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#if !defined (octave_oct_mem_h)
-#define octave_oct_mem_h 1
-
-#include <cstddef>
-#include <cstring>
-#include <algorithm>
-
-#include "oct-cmplx.h"
-#include "oct-inttypes.h"
-
-// NOTE: These functions are used to optimize stuff where performance is a
-// priority. They assume that the std::complex and octave_int can be
-// manipulated as plain memory, an assumption that is always true in practice
-// but not theoretically guaranteed by the C++ standard. In the future, C++ may
-// provide a better way to accomplish these tasks.
-
-inline size_t safe_size_comp (size_t n, size_t size)
-{
-  if (n > static_cast<size_t> (-1) / size)
-    throw std::bad_alloc ();
-  return n * size;
-}
-
-// Unaliased copy. This boils down to memcpy, even for octave_int and
-// complex types.
-
-template <class T>
-inline void copy_or_memcpy (size_t n, const T *src, T *dest)
-{ std::copy (src, src + n, dest); }
-
-#define DEFINE_POD_UCOPY(T) \
-inline void copy_or_memcpy (size_t n, const T *src, T *dest) \
-{ std::memcpy (dest, src, n * sizeof (T)); }
-
-DEFINE_POD_UCOPY (double)
-DEFINE_POD_UCOPY (float)
-DEFINE_POD_UCOPY (char)
-DEFINE_POD_UCOPY (short)
-DEFINE_POD_UCOPY (int)
-DEFINE_POD_UCOPY (long)
-DEFINE_POD_UCOPY (unsigned char)
-DEFINE_POD_UCOPY (unsigned short)
-DEFINE_POD_UCOPY (unsigned int)
-DEFINE_POD_UCOPY (unsigned long)
-
-DEFINE_POD_UCOPY (Complex)
-DEFINE_POD_UCOPY (FloatComplex)
-
-template <class T>
-DEFINE_POD_UCOPY (octave_int<T>)
-
-// Fill by value, with a check for zero. This boils down to memset if value is
-// a POD zero.
-template <class T>
-inline void fill_or_memset (size_t n, const T& value, T *dest)
-{ std::fill_n (dest, n, value); }
-
-template <class T>
-inline bool helper_is_zero_mem (const T& value)
-{
-  // get integer type of the same size.
-  typedef typename query_integer_type<sizeof (T), false>::type IT;
-  return *(reinterpret_cast<const IT *>(&value)) == 0;
-}
-
-template <class T>
-inline bool helper_is_zero_mem (const std::complex<T>& value)
-{
-  return (helper_is_zero_mem (value.real ())
-          && helper_is_zero_mem (value.imag ()));
-}
-
-template <class T>
-inline bool helper_is_zero_mem (const octave_int<T>& value)
-{ return value.value () == T (); }
-
-#define DEFINE_POD_FILL(T) \
-inline void fill_or_memset (size_t n, const T& value, T *dest) \
-{ \
-  if (helper_is_zero_mem (value)) \
-    std::memset (dest, 0, n * sizeof (T)); \
-  else \
-    std::fill_n (dest, n, value); \
-}
-
-DEFINE_POD_FILL (double)
-DEFINE_POD_FILL (float)
-DEFINE_POD_FILL (char)
-DEFINE_POD_FILL (short)
-DEFINE_POD_FILL (int)
-DEFINE_POD_FILL (long)
-DEFINE_POD_FILL (unsigned char)
-DEFINE_POD_FILL (unsigned short)
-DEFINE_POD_FILL (unsigned int)
-DEFINE_POD_FILL (unsigned long)
-
-DEFINE_POD_FILL (Complex)
-DEFINE_POD_FILL (FloatComplex)
-
-template <class T>
-DEFINE_POD_FILL (octave_int<T>)
-
-// Uninitialized allocation.
-// Will not initialize memory for complex and octave_int.
-// Memory allocated by octave_new should be freed by octave_delete.
-template <class T>
-inline T *no_ctor_new (size_t n)
-{
-  // Some systems let us allocate > 2GB memory even though size_t, which is
-  // either buggy or completely cuckoo, so let's check here to stay safe.
-  safe_size_comp (n, sizeof (T));
-  return new T [n];
-}
-template <class T>
-inline void no_ctor_delete (T *ptr)
-{ delete [] ptr; }
-
-#define DEFINE_POD_NEW_DELETE(T) \
-template <> \
-inline T *no_ctor_new<T > (size_t n) \
-{ return reinterpret_cast<T *> (new char [safe_size_comp (n, sizeof (T))]); } \
-template <> \
-inline void no_ctor_delete<T > (T *ptr) \
-{ delete [] reinterpret_cast<char *> (ptr); }
-
-DEFINE_POD_NEW_DELETE (Complex)
-DEFINE_POD_NEW_DELETE (FloatComplex)
-
-DEFINE_POD_NEW_DELETE (octave_int8)
-DEFINE_POD_NEW_DELETE (octave_int16)
-DEFINE_POD_NEW_DELETE (octave_int32)
-DEFINE_POD_NEW_DELETE (octave_int64)
-DEFINE_POD_NEW_DELETE (octave_uint8)
-DEFINE_POD_NEW_DELETE (octave_uint16)
-DEFINE_POD_NEW_DELETE (octave_uint32)
-DEFINE_POD_NEW_DELETE (octave_uint64)
-
-#endif /* octave_oct_mem_h */
