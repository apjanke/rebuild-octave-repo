# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1421766342 18000
#      Tue Jan 20 10:05:42 2015 -0500
# Branch gui-release
# Node ID fe689210525c318816ffadfd8e8adf202667788c
# Parent  6d75f1683ce822a2fae79be0d3086bb801ec1bcf
# Parent  446c46af4b429aeb9b894699c6344c8abee10182
maint: Periodic merge of stable to gui-release.

diff --git a/Makefile.am b/Makefile.am
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,31 +1,31 @@
 # Makefile for Octave
 #
 # Copyright (C) 1993-2013 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include build-aux/common.mk
 
-## Avoid making multiple subdirs in parallel which can lead 
+## Avoid making multiple subdirs in parallel which can lead
 ## to a confusing error message stream
 .NOTPARALLEL:
 
 ACLOCAL_AMFLAGS = -I m4
 
 BUILT_DISTFILES = AUTHORS BUGS ChangeLog INSTALL.OCTAVE
 
 EXTRA_DIST = \
diff --git a/build-aux/common.mk b/build-aux/common.mk
--- a/build-aux/common.mk
+++ b/build-aux/common.mk
@@ -47,17 +47,17 @@ LEXLIB = @LEXLIB@
 YACC = @YACC@
 AM_YFLAGS = -dv
 BISON_API_PREFIX_DECL_STYLE = @BISON_API_PREFIX_DECL_STYLE@
 BISON_PUSH_PULL_DECL_STYLE = @BISON_PUSH_PULL_DECL_STYLE@
 
 GPERF = @GPERF@
 
 AR = @AR@
-ARFLAGS = @ARFLAGS@ 
+ARFLAGS = @ARFLAGS@
 
 TEMPLATE_AR = @TEMPLATE_AR@
 TEMPLATE_ARFLAGS = @TEMPLATE_ARFLAGS@
 
 RANLIB = @RANLIB@
 
 LN_S = @LN_S@
 MKDIR_P = @MKDIR_P@
@@ -432,17 +432,17 @@ archlibdir = @archlibdir@
 # user that are specific to this site.
 localarchlibdir = @localarchlibdir@
 localapiarchlibdir = @localapiarchlibdir@
 localverarchlibdir = @localverarchlibdir@
 
 # Where to put object files that will by dynamically loaded.
 # This path usually includes the Octave version and configuration
 # name, so that multiple configurations for multiple versions of
-# Octave may be installed at once. 
+# Octave may be installed at once.
 octfiledir = @octfiledir@
 
 # Directories Octave should search for object files that will be
 # dynamically loaded and that are specific to this site
 # (i.e. customizations), before consulting ${octfiledir}.  This should
 # be a colon-separated list of directories.
 localoctfiledir = @localoctfiledir@
 localapioctfiledir = @localapioctfiledir@
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -1,11 +1,11 @@
 dnl Process this file with autoconf to produce a configure script.
 dnl
-dnl Copyright (C) 1993-2013 John W. Eaton
+dnl Copyright (C) 1993-2014 John W. Eaton
 ###
 ### This file is part of Octave.
 ###
 ### Octave is free software; you can redistribute it and/or modify it
 ### under the terms of the GNU General Public License as published by the
 ### Free Software Foundation; either version 3 of the License, or (at
 ### your option) any later version.
 ###
diff --git a/doc/Makefile.am b/doc/Makefile.am
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -1,24 +1,24 @@
 # Makefile for Octave's doc directory
 #
 # Copyright (C) 1993-2013 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
 ## Avoid making multiple subdirs in parallel
 ## which can lead to a confusing error message stream.
diff --git a/doc/doxyhtml/Makefile.am b/doc/doxyhtml/Makefile.am
--- a/doc/doxyhtml/Makefile.am
+++ b/doc/doxyhtml/Makefile.am
@@ -1,24 +1,24 @@
 # Makefile for Octave's doc/doxyhtml directory
 #
 # Copyright (C) 1993-2013 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
 doxyhtml:
 	doxygen Doxyfile
diff --git a/doc/interpreter/Makefile.am b/doc/interpreter/Makefile.am
--- a/doc/interpreter/Makefile.am
+++ b/doc/interpreter/Makefile.am
@@ -1,37 +1,37 @@
 # Makefile for Octave's doc/interpreter directory
 #
 # Copyright (C) 1993-2013 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
 TEXINFO_TEX = ../texinfo.tex
 
 ## Leading PATH_SEPARATOR required due to weak parsing by dvips (12/04/09)
 TEXINPUTS := "$(PATH_SEPARATOR)$(srcdir)$(PATH_SEPARATOR)$(TEXINPUTS)$(PATH_SEPARATOR)"
 export TEXINPUTS
 
-## Include custom texmf.cnf necessary to run @seealso macro 
+## Include custom texmf.cnf necessary to run @seealso macro
 TEXMFCNF := "..$(PATH_SEPARATOR)$(srcdir)/..$(PATH_SEPARATOR)$(TEXMFCNF)$(PATH_SEPARATOR)"
 export TEXMFCNF
 
 dist_man_MANS = \
   mkoctfile.1 \
   octave-cli.1 \
   octave-config.1 \
   octave.1
@@ -101,17 +101,17 @@ BUILT_IMAGES = \
   $(IMAGES_PNG) \
   $(IMAGES_TXT)
 
 IMAGES = \
   $(BUILT_IMAGES) \
   $(JAVA_IMAGES)
 
 ## FIXME: JAVA_IMAGES will eventually need to be added to the HTML build.
-##        It will require a different Makefile rule later because 
+##        It will require a different Makefile rule later because
 ##        JAVA_IMAGES live in a subdir rather than in the current directory.
 HTMLDIR_IMAGES = $(addprefix octave.html/, $(IMAGES_PNG))
 
 LOGOS = \
   octave_logo.eps \
   octave_logo.pdf
 
 MUNGED_TEXI_SRC = \
@@ -190,17 +190,17 @@ html: $(HTMLDIR_IMAGES)
 $(HTMLDIR_IMAGES): $(IMAGES_PNG) | octave.html
 	cp $(@F) octave.html
 
 ## The texi2dvi script (used to create both PDF and DVI output formats)
 ## uses some fixed temporary file names.  In order to avoid a race condition
 ## the DVI and PDF builds are forced to run serially through a Makefile rule.
 octave.pdf: octave.dvi
 
-# Prevent packaging of distribution unless all libraries 
+# Prevent packaging of distribution unless all libraries
 # necessary to create documentation are present
 dist-hook:
 	@$(GREP) '#define HAVE_COLAMD 1' $(top_builddir)/config.h > /dev/null || { echo "Documentation creation requires missing COLAMD library.  Cannot package distribution!" ; exit 1; }
 	@$(GREP) '#define HAVE_CHOLMOD 1' $(top_builddir)/config.h > /dev/null || { echo "Documentation creation requires missing CHOLMOD library.  Cannot package distribution!" ; exit 1; }
 	@$(GREP) '#define HAVE_UMFPACK 1' $(top_builddir)/config.h > /dev/null || { echo "Documentation creation requires missing UMFPACK library.  Cannot package distribution!" ; exit 1; }
 	@$(GREP) '#define HAVE_QHULL 1' $(top_builddir)/config.h > /dev/null || { echo "Documentation creation requires missing QHULL library.  Cannot package distribution!" ; exit 1; }
 
 octetc_DATA = doc-cache macros.texi
@@ -250,17 +250,17 @@ undocumented_list:
 
 SPELLCHECK_FILES = $(MUNGED_TEXI_SRC:.texi=.scheck)
 
 %.scheck: %.texi
 	$(srcdir)/doccheck/spellcheck $< > $@-t
 	mv $@-t $@
 	[ -s $@ ] || rm -f $@
 
-spellcheck: $(SPELLCHECK_FILES) 
+spellcheck: $(SPELLCHECK_FILES)
 	@if ls *.scheck >/dev/null 2>&1 ; then \
 		echo "Spellcheck failed"; \
 		echo "Review the following files:"; \
 		ls *.scheck ; \
 		exit 1 ; \
 	else \
 		echo "Spellcheck passed"; \
 	fi
diff --git a/doc/interpreter/arith.txi b/doc/interpreter/arith.txi
--- a/doc/interpreter/arith.txi
+++ b/doc/interpreter/arith.txi
@@ -1,32 +1,32 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Arithmetic
 @chapter Arithmetic
 
 Unless otherwise noted, all of the functions described in this chapter
 will work for real and complex scalar, vector, or matrix arguments.  Functions
-described as @dfn{mapping functions} apply the given operation individually to 
+described as @dfn{mapping functions} apply the given operation individually to
 each element when given a matrix argument.  For example:
 
 @example
 @group
 sin ([1, 2; 3, 4])
      @result{}  0.84147   0.90930
          0.14112  -0.75680
 @end group
diff --git a/doc/interpreter/audio.txi b/doc/interpreter/audio.txi
--- a/doc/interpreter/audio.txi
+++ b/doc/interpreter/audio.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 Kurt Hornik
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @c Written by Kurt Hornik <Kurt.Hornik@wu-wien.ac.at> on 1996/05/14
 
 @node Audio Processing
 @chapter Audio Processing
diff --git a/doc/interpreter/basics.txi b/doc/interpreter/basics.txi
--- a/doc/interpreter/basics.txi
+++ b/doc/interpreter/basics.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Getting Started
 @chapter Getting Started
 
 This chapter explains some of Octave's basic features, including how to
@@ -121,20 +121,20 @@ Force the graphical user interface (GUI)
 @itemx -?
 @cindex @code{--help}
 @cindex @code{-h}
 @cindex @code{-?}
 Print short help message and exit.
 
 @item --image-path @var{path}
 @cindex @code{--image-path @var{path}}
-Add path to the head of the search path for images.  The value of 
-@var{path} specified on the command line will override any value of 
-@w{@env{OCTAVE_IMAGE_PATH}} found in the environment, but not any commands 
-in the system or user startup files that set the built-in variable 
+Add path to the head of the search path for images.  The value of
+@var{path} specified on the command line will override any value of
+@w{@env{OCTAVE_IMAGE_PATH}} found in the environment, but not any commands
+in the system or user startup files that set the built-in variable
 @w{@env{IMAGE_PATH}}.
 
 @item --info-file @var{filename}
 @cindex @code{--info-file @var{filename}}
 Specify the name of the info file to use.  The value of @var{filename}
 specified on the command line will override any value of
 @w{@env{OCTAVE_INFO_FILE}} found in the environment, but not any commands
 in the system or user startup files that use the @code{info_file}
@@ -176,17 +176,17 @@ interface (CLI) instead.
 Disable recording of command-line history.
 
 @item --no-init-file
 @cindex @code{--no-init-file}
 Don't read the initialization files @file{~/.octaverc} and @file{.octaverc}.
 
 @item --no-init-path
 @cindex @code{--no-init-path}
-Don't initialize the search path for function files to include default 
+Don't initialize the search path for function files to include default
 locations.
 
 @item --no-line-editing
 @cindex @code{--no-line-editing}
 Disable command-line editing.
 
 @item --no-site-file
 @cindex @code{--no-site-file}
@@ -205,17 +205,17 @@ strictly terminal-only environment.
 Don't read any of the system or user initialization files at startup.
 This is equivalent to using both of the options @option{--no-init-file}
 and @option{--no-site-file}.
 
 @item  --path @var{path}
 @itemx -p @var{path}
 @cindex @code{--path @var{path}}
 @cindex @code{-p @var{path}}
-Add path to the head of the search path for function files.  The 
+Add path to the head of the search path for function files.  The
 value of @var{path} specified on the command line will override any value
 of @w{@env{OCTAVE_PATH}} found in the environment, but not any commands in the
 system or user startup files that set the internal load path through one
 of the path functions.
 
 @item --persist
 @cindex @code{--persist}
 Go to interactive mode after @option{--eval} or reading from a file
@@ -287,43 +287,43 @@ Turn on verbose output.
 @cindex @code{-v}
 Print the program version number and exit.
 
 @item @var{file}
 Execute commands from @var{file}.  Exit when done unless
 @option{--persist} is also specified.
 @end table
 
-Octave also includes several functions which return information 
+Octave also includes several functions which return information
 about the command line, including the number of arguments and all of the
 options.
 
 @DOCSTRING(argv)
 
 @DOCSTRING(program_name)
 
 @DOCSTRING(program_invocation_name)
 
-Here is an example of using these functions to reproduce the command 
+Here is an example of using these functions to reproduce the command
 line which invoked Octave.
 
 @example
 @group
 printf ("%s", program_name ());
 arg_list = argv ();
 for i = 1:nargin
   printf (" %s", arg_list@{i@});
 endfor
 printf ("\n");
 @end group
 @end example
 
 @noindent
 @xref{Indexing Cell Arrays}, for an explanation of how to retrieve objects
-from cell arrays, and @ref{Defining Functions}, for information about the 
+from cell arrays, and @ref{Defining Functions}, for information about the
 variable @code{nargin}.
 
 @node Startup Files
 @subsection Startup Files
 @cindex initialization
 @cindex startup
 
 When Octave starts, it looks for commands to execute from the files in
@@ -332,37 +332,37 @@ including function definitions.
 
 @cindex startup files
 
 @table @code
 @item @var{octave-home}/share/octave/site/m/startup/octaverc
 @cindex site startup file
 where @var{octave-home} is the directory in which Octave is installed
 (the default is @file{/usr/local}).
-This file is provided so that changes to the default Octave environment 
+This file is provided so that changes to the default Octave environment
 can be made globally for all users at your site for all versions of Octave
-you have installed.  Care should be taken when making changes to this file 
-since all users of Octave at your site will be affected.  The default file 
+you have installed.  Care should be taken when making changes to this file
+since all users of Octave at your site will be affected.  The default file
 may be overridden by the environment variable @w{@env{OCTAVE_SITE_INITFILE}}.
 
 @item @var{octave-home}/share/octave/@var{version}/m/startup/octaverc
 @cindex version startup file
 where @var{octave-home} is the directory in which Octave is
 installed (the default is @file{/usr/local}), and @var{version}
 is the version number of Octave.  This file is provided so that changes
 to the default Octave environment can be made globally for all users of
 a particular version of Octave.  Care should be taken when making
 changes to this file since all users of Octave at your site will be
 affected.  The default file may be overridden by the environment variable
 @w{@env{OCTAVE_VERSION_INITFILE}}.
 
 @item ~/.octaverc
 @cindex personal startup file
 @cindex @code{~/.octaverc}
-This file is used to make personal changes to the default 
+This file is used to make personal changes to the default
 Octave environment.
 
 @item .octaverc
 @cindex project startup file
 @cindex @code{.octaverc}
 This file can be used to make changes to the default Octave environment
 for a particular project.  Octave searches for this file in the current
 directory after it reads @file{~/.octaverc}.  Any use of the @code{cd}
@@ -452,32 +452,32 @@ and because they may occasionally be use
 @node Command Line Editing
 @section Command Line Editing
 @cindex command-line editing
 @cindex editing the command line
 
 Octave uses the GNU Readline library to provide an extensive set of
 command-line editing and history features.  Only the most common
 features are described in this manual.  In addition, all of the editing
-functions can be bound to different key strokes at the user's discretion.  
-This manual assumes no changes from the default Emacs bindings.  See the GNU 
-Readline Library manual for more information on customizing Readline and 
+functions can be bound to different key strokes at the user's discretion.
+This manual assumes no changes from the default Emacs bindings.  See the GNU
+Readline Library manual for more information on customizing Readline and
 for a complete feature list.
 
 To insert printing characters (letters, digits, symbols, etc.), simply
 type the character.  Octave will insert the character at the cursor and
 advance the cursor forward.
 
 Many of the command-line editing functions operate using control
 characters.  For example, the character @kbd{Control-a} moves the cursor
 to the beginning of the line.  To type @kbd{C-a}, hold down @key{CTRL}
 and then press @key{a}.  In the following sections, control characters
 such as @kbd{Control-a} are written as @kbd{C-a}.
 
-Another set of command-line editing functions use Meta characters.  To 
+Another set of command-line editing functions use Meta characters.  To
 type @kbd{M-u}, hold down the @key{META} key and press @key{u}.  Depending
 on the keyboard, the @key{META} key may be labeled @key{ALT} or
 even @key{WINDOWS}.  If your terminal does not have a @key{META} key, you
 can still type Meta characters using two-character sequences starting
 with @kbd{ESC}.  Thus, to enter @kbd{M-u}, you would type
 @key{ESC} @key{u}.  The @kbd{ESC} character sequences are also allowed on
 terminals with real Meta keys.  In the following sections, Meta
 characters such as @kbd{Meta-u} are written as @kbd{M-u}.
@@ -571,17 +571,17 @@ Here is the list of commands for killing
 Kill the text from the current cursor position to the end of the line.
 
 @item M-d
 Kill from the cursor to the end of the current word, or if between
 words, to the end of the next word.
 
 @item M-@key{DEL}
 Kill from the cursor to the start of the previous word, or if between
-words, to the start of the previous word. 
+words, to the start of the previous word.
 
 @item C-w
 Kill from the cursor to the previous whitespace.  This is different than
 @kbd{M-@key{DEL}} because the word boundaries differ.
 @end table
 
 And, here is how to @dfn{yank} the text back into the line.  Yanking
 means to copy the most-recently-killed text from the kill buffer.
@@ -700,17 +700,17 @@ Move to the end of the input history, i.
 Search backward starting at the current line and moving `up' through
 the history as necessary.  This is an incremental search.
 
 @item C-s
 Search forward starting at the current line and moving `down' through
 the history as necessary.
 @end table
 
-On most terminals, you can also use the up and down arrow keys in place 
+On most terminals, you can also use the up and down arrow keys in place
 of @kbd{C-p} and @kbd{C-n} to move through the history list.
 
 In addition to the keyboard commands for moving through the history
 list, Octave provides three functions for viewing, editing, and
 re-running chunks of commands from the history list.
 
 @DOCSTRING(history)
 
@@ -899,23 +899,23 @@ This error message has several parts, an
 information to help you locate the source of the error.  The messages
 are generated from the point of the innermost error, and provide a
 traceback of enclosing expressions and function calls.
 
 In the example above, the first line indicates that a variable named
 @samp{x} was found to be undefined near line 1 and column 24 of some
 function or expression.  For errors occurring within functions, lines
 are counted from the beginning of the file containing the function
-definition.  For errors occurring outside of an enclosing function, 
-the line number indicates the input line number, which is usually displayed 
+definition.  For errors occurring outside of an enclosing function,
+the line number indicates the input line number, which is usually displayed
 in the primary prompt string.
 
-The second and third lines of the error message indicate that the error 
-occurred within the function @code{f}.  If the function @code{f} had been 
-called from within another function, for example, @code{g}, the list of 
+The second and third lines of the error message indicate that the error
+occurred within the function @code{f}.  If the function @code{f} had been
+called from within another function, for example, @code{g}, the list of
 errors would have ended with one more line:
 
 @example
 error:   g at line 1, column 17
 @end example
 
 These lists of function calls make it fairly easy to trace the
 path your program took before the error occurred, and to correct the
@@ -981,19 +981,19 @@ executed program.  The first argument in
 of the Octave executable.  The rest of the argument list will either be
 options to Octave, or data files, or both.  The @samp{-qf} options are
 usually specified in stand-alone Octave programs to prevent them from
 printing the normal startup message, and to keep them from behaving
 differently depending on the contents of a particular user's
 @file{~/.octaverc} file.  @xref{Invoking Octave from the Command Line}.
 
 Note that some operating systems may place a limit on the number of
-characters that are recognized after @samp{#!}.  Also, the arguments 
-appearing in a @samp{#!} line are parsed differently by various 
-shells/systems.  The majority of them group all the arguments together in one 
+characters that are recognized after @samp{#!}.  Also, the arguments
+appearing in a @samp{#!} line are parsed differently by various
+shells/systems.  The majority of them group all the arguments together in one
 string and pass it to the interpreter as a single argument.  In this case, the
 following script:
 
 @example
 @group
 #! @var{octave-interpreter-name} -q -f # comment
 @end group
 @end example
@@ -1004,17 +1004,17 @@ is equivalent to typing at the command l
 @example
 @group
 octave "-q -f # comment"
 @end group
 @end example
 
 @noindent
 which will produce an error message.  Unfortunately, it is
-not possible for Octave to determine whether it has been called from the 
+not possible for Octave to determine whether it has been called from the
 command line or from a @samp{#!} script, so some care is needed when using the
 @samp{#!} mechanism.
 
 Note that when Octave is started from an executable script, the built-in
 function @code{argv} returns a cell array containing the command line
 arguments passed to the executable Octave script, not the arguments
 passed to the Octave interpreter on the @samp{#!} line of the script.
 For example, the following program will reproduce the command line that
@@ -1034,17 +1034,17 @@ printf ("\n");
 
 @node Comments
 @section Comments in Octave Programs
 @cindex comments
 @cindex use of comments
 @cindex documenting Octave programs
 
 A @dfn{comment} is some text that is included in a program for the sake
-of human readers, and which is NOT an executable part of the program.  
+of human readers, and which is NOT an executable part of the program.
 Comments can explain what the program does, and how it works.  Nearly all
 programming languages have provisions for comments, because programs are
 typically hard to understand without them.
 
 @menu
 * Single Line Comments::
 * Block Comments::
 * Comments and the Help System::
@@ -1059,40 +1059,40 @@ In the Octave language, a comment starts
 character, @samp{#}, or the percent symbol @samp{%} and continues to the
 end of the line.  Any text following the sharp sign or percent symbol is
 ignored by the Octave interpreter and not executed.  The following example
 shows whole line and partial line comments.
 
 @example
 @group
 function countdown
-  # Count down for main rocket engines 
+  # Count down for main rocket engines
   disp (3);
   disp (2);
   disp (1);
   disp ("Blast Off!");  # Rocket leaves pad
 endfunction
 @end group
 @end example
 
 @node Block Comments
 @subsection Block Comments
 @cindex block comments
 @cindex multi-line comments
 @cindex @samp{#@{}
 @cindex @samp{%@{}
 
-Entire blocks of code can be commented by enclosing the code between 
-matching @samp{#@{} and @samp{#@}} or @samp{%@{} and @samp{%@}} markers.  
+Entire blocks of code can be commented by enclosing the code between
+matching @samp{#@{} and @samp{#@}} or @samp{%@{} and @samp{%@}} markers.
 For example,
 
 @example
 @group
 function quick_countdown
-  # Count down for main rocket engines 
+  # Count down for main rocket engines
   disp (3);
  #@{
   disp (2);
   disp (1);
  #@}
   disp ("Blast Off!");  # Rocket leaves pad
 endfunction
 @end group
@@ -1147,10 +1147,10 @@ the command @kbd{help f} produces the ou
 @end example
 
 Although it is possible to put comment lines into keyboard-composed,
 throw-away Octave programs, it usually isn't very useful because the
 purpose of a comment is to help you or another person understand the
 program at a later time.
 
 The @code{help} parser currently only recognizes single line comments
-(@pxref{Single Line Comments}) and not block comments for the initial 
-help text. 
+(@pxref{Single Line Comments}) and not block comments for the initial
+help text.
diff --git a/doc/interpreter/bugs.txi b/doc/interpreter/bugs.txi
--- a/doc/interpreter/bugs.txi
+++ b/doc/interpreter/bugs.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @c The text of this file appears in the file BUGS in the Octave
 @c distribution, as well as in the Octave manual.
 
 @ifclear BUGSONLY
@@ -221,17 +221,17 @@ A complete input file that will reproduc
 
 A single statement may not be enough of an example---the bug might
 depend on other details that are missing from the single statement where
 the error finally occurs.
 
 @item
 The command arguments you gave Octave to execute that example
 and observe the bug.  To guarantee you won't omit something important,
-list all the options. 
+list all the options.
 
 If we were to try to guess the arguments, we would probably guess wrong
 and then we would not encounter the bug.
 
 @item
 The type of machine you are using, and the operating system name and
 version number.
 
diff --git a/doc/interpreter/container.txi b/doc/interpreter/container.txi
--- a/doc/interpreter/container.txi
+++ b/doc/interpreter/container.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Data Containers
 @chapter Data Containers
 @cindex containers
 
@@ -255,33 +255,33 @@ x(1).b = 1;
 x(2).b = 2;
 @end group
 @end example
 
 @noindent
 which creates a 2-by-1 structure array with two fields.  Another way
 to create a structure array is with the @code{struct} function
 (@pxref{Creating Structures}).  As previously, to print the value of
-the structure array, you can type its name: 
+the structure array, you can type its name:
 
 @example
 @group
 x
      @result{} x =
         @{
           1x2 struct array containing the fields:
 
             a
             b
-        @}  
+        @}
 @end group
 @end example
 
 Individual elements of the structure array can be returned by indexing
-the variable like @code{@var{x}(1)}, which returns a structure with 
+the variable like @code{@var{x}(1)}, which returns a structure with
 two fields:
 
 @example
 @group
 x(1)
      @result{} ans =
         @{
           a = string1
@@ -345,17 +345,17 @@ size (x)
 @end example
 
 Elements can be deleted from a structure array in a similar manner to a
 numerical array, by assigning the elements to an empty matrix.  For
 example
 
 @example
 @group
-in = struct ("call1", @{x, Inf, "last"@}, 
+in = struct ("call1", @{x, Inf, "last"@},
              "call2", @{x, Inf, "first"@})
      @result{} in =
         @{
           1x3 struct array containing the fields:
 
             call1
             call2
         @}
@@ -445,25 +445,25 @@ struct ("field1", 1, "field2", 2)
       @{
         field1 =  1
         field2 =  2
       @}
 @end group
 @end example
 
 If the values passed to @code{struct} are a mix of scalar and cell
-arrays, then the scalar arguments are expanded to create a 
+arrays, then the scalar arguments are expanded to create a
 structure array with a consistent dimension.  For example:
 
 @example
 @group
 s = struct ("field1", @{1, "one"@}, "field2", @{2, "two"@},
         "field3", 3);
 s.field1
-     @result{} 
+     @result{}
         ans =  1
         ans = one
 
 s.field2
      @result{}
         ans =  2
         ans = two
 
@@ -640,17 +640,17 @@ iscell (3)
 @DOCSTRING(iscell)
 
 @node Creating Cell Arrays
 @subsection Creating Cell Arrays
 
 The introductory example (@pxref{Basic Usage of Cell Arrays}) showed
 how to create a cell array containing currently available variables.
 In many situations, however, it is useful to create a cell array and
-then fill it with data. 
+then fill it with data.
 
 The @code{cell} function returns a cell array of a given size, containing
 empty matrices.  This function is similar to the @code{zeros}
 function for creating new numerical arrays.  The following example creates
 a 2-by-2 cell array containing empty matrices
 
 @example
 @group
@@ -701,28 +701,28 @@ is possible to convert numerical arrays 
 
 @DOCSTRING(cellslices)
 
 @node Indexing Cell Arrays
 @subsection Indexing Cell Arrays
 
 As shown in @pxref{Basic Usage of Cell Arrays} elements can be
 extracted from cell arrays using the @samp{@{} and @samp{@}}
-operators.  If you want to extract or access subarrays which are still 
+operators.  If you want to extract or access subarrays which are still
 cell arrays, you need to use the @samp{(} and @samp{)} operators.  The
 following example illustrates the difference:
 
 @example
 @group
 c = @{"1", "2", "3"; "x", "y", "z"; "4", "5", "6"@};
 c@{2,3@}
      @result{} ans = z
 
 c(2,3)
-     @result{} ans = 
+     @result{} ans =
         @{
           [1,1] = z
         @}
 @end group
 @end example
 
 @noindent So with @samp{@{@}} you access elements of a cell
 array, while with @samp{()} you access a sub array of a cell
@@ -752,28 +752,28 @@ c(:, [1, 3]) = @{0@}
 @end example
 
 Note, that the above can also be achieved like this:
 
 @example
 c(:, [1, 3]) = 0;
 @end example
 
-@noindent Here, the scalar @samp{0} is automatically promoted to 
+@noindent Here, the scalar @samp{0} is automatically promoted to
 cell array @samp{@{0@}} and then assigned to the subarray of @code{c}.
 
 To give another example for indexing cell arrays with @samp{()}, you
 can exchange the first and the second row of a cell array as in the
-following command: 
+following command:
 
 @example
 @group
 c = @{1, 2, 3; 4, 5, 6@};
 c([1, 2], :) = c([2, 1], :)
-     @result{} = 
+     @result{} =
         @{
           [1,1] =  4
           [2,1] =  1
           [1,2] =  5
           [2,2] =  2
           [1,3] =  6
           [2,3] =  3
         @}
@@ -784,17 +784,17 @@ Accessing multiple elements of a cell ar
 @samp{@}} operators will result in a comma-separated list of all the
 requested elements (@pxref{Comma Separated Lists}).  Using the
 @samp{@{} and @samp{@}} operators the first two rows in the above
 example can be swapped back like this:
 
 @example
 @group
 [c@{[1,2], :@}] = deal (c@{[2, 1], :@})
-     @result{} = 
+     @result{} =
         @{
           [1,1] =  1
           [2,1] =  4
           [1,2] =  2
           [2,2] =  5
           [1,3] =  3
           [2,3] =  6
         @}
@@ -847,17 +847,17 @@ variable.  It is also possible to store 
 character matrix by letting each row be a string.  This, however,
 introduces the problem that all strings must be of equal length.
 Therefore, it is recommended to use cell arrays to store multiple
 strings.  For cases, where the character matrix representation is required
 for an operation, there are several functions that convert a cell
 array of strings to a character array and back.  @code{char} and
 @code{strvcat} convert cell arrays to a character array
 (@pxref{Concatenating Strings}), while the function @code{cellstr}
-converts a character array to a cell array of strings: 
+converts a character array to a cell array of strings:
 
 @example
 @group
 a = ["hello"; "world"];
 c = cellstr (a)
      @result{} c =
          @{
            [1,1] = hello
@@ -886,17 +886,17 @@ strcmp ("hello", c)
 @end example
 
 @noindent
 The following string functions support cell arrays of strings:
 @code{char}, @code{strvcat}, @code{strcat} (@pxref{Concatenating
 Strings}), @code{strcmp}, @code{strncmp}, @code{strcmpi},
 @code{strncmpi} (@pxref{Comparing Strings}), @code{str2double},
 @code{deblank}, @code{strtrim}, @code{strtrunc}, @code{strfind},
-@code{strmatch}, , @code{regexp}, @code{regexpi} (@pxref{Manipulating 
+@code{strmatch}, , @code{regexp}, @code{regexpi} (@pxref{Manipulating
 Strings}) and @code{str2double} (@pxref{String Conversions}).
 
 The function @code{iscellstr} can be used to test if an object is a
 cell array of strings.
 
 @DOCSTRING(iscellstr)
 
 @node Processing Data in Cell Arrays
@@ -947,17 +947,17 @@ x = [1 0 1 0 0 1 1; 0 0 0 0 0 0 7];
 Here, @samp{@var{x}, 2, "last"} is a comma separated list constituting
 the input arguments of @code{find}.  @code{find} returns a comma
 separated list of output arguments which is assigned element by
 element to the comma separated list @samp{@var{i}, @var{j}}.
 
 Another example of where comma separated lists are used is in the
 creation of a new array with @code{[]} (@pxref{Matrices}) or the
 creation of a cell array with @code{@{@}} (@pxref{Basic Usage of Cell
-Arrays}).  In the expressions 
+Arrays}).  In the expressions
 
 @example
 @group
 a = [1, 2, 3, 4];
 c = @{4, 5, 6, 7@};
 @end group
 @end example
 
@@ -988,17 +988,17 @@ of a cell array can be extracted into a 
 a = @{1, [2, 3], 4, 5, 6@};
 b = [a@{1:4@}]
      @result{} b =
          1   2   3   4   5
 @end group
 @end example
 
 Similarly, it is possible to create a new cell array containing cell
-elements selected with @code{@{@}}.  By surrounding the list with  
+elements selected with @code{@{@}}.  By surrounding the list with
 @samp{@{} and @samp{@}} a new cell array will be created, as the
 following example illustrates:
 
 @example
 @group
 a = @{1, rand(2, 2), "three"@};
 b = @{ a@{ [1, 3] @} @}
      @result{} b =
@@ -1015,24 +1015,24 @@ be passed as an argument list to a given
 with the elements as individual arguments.  The two calls to
 @code{printf} in the following example are identical but the latter is
 simpler and can handle cell arrays of an arbitrary size:
 
 @example
 @group
 c = @{"GNU", "Octave", "is", "Free", "Software"@};
 printf ("%s ", c@{1@}, c@{2@}, c@{3@}, c@{4@}, c@{5@});
-     @print{} GNU Octave is Free Software 
+     @print{} GNU Octave is Free Software
 printf ("%s ", c@{:@});
-     @print{} GNU Octave is Free Software 
+     @print{} GNU Octave is Free Software
 @end group
 @end example
 
 If used on the left-hand side of an assignment, a comma separated list
-generated with @code{@{@}} can be assigned to.  An example is 
+generated with @code{@{@}} can be assigned to.  An example is
 
 @example
 @group
 in@{1@} = [10, 20, 30, 40, 50, 60, 70, 80, 90];
 in@{2@} = inf;
 in@{3@} = "last";
 in@{4@} = "first";
 out = cell (4, 1);
@@ -1054,16 +1054,16 @@ out = cell (4, 1);
 @node Comma Separated Lists Generated from Structure Arrays
 @subsection Comma Separated Lists Generated from Structure Arrays
 Structure arrays can equally be used to create comma separated
 lists.  This is done by addressing one of the fields of a structure
 array.  For example:
 
 @example
 @group
-x = ceil (randn (10, 1)); 
-in = struct ("call1", @{x, 3, "last"@}, 
+x = ceil (randn (10, 1));
+in = struct ("call1", @{x, 3, "last"@},
              "call2", @{x, inf, "first"@});
 out = struct ("call1", cell (2, 1), "call2", cell (2, 1));
 [out.call1] = find (in.call1);
 [out.call2] = find (in.call2);
 @end group
 @end example
diff --git a/doc/interpreter/cp-idx.txi b/doc/interpreter/cp-idx.txi
--- a/doc/interpreter/cp-idx.txi
+++ b/doc/interpreter/cp-idx.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Concept Index
 @unnumbered Concept Index
 
 @printindex cp
diff --git a/doc/interpreter/data.txi b/doc/interpreter/data.txi
--- a/doc/interpreter/data.txi
+++ b/doc/interpreter/data.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Data Types
 @chapter Data Types
 @cindex data types
 
diff --git a/doc/interpreter/debug.txi b/doc/interpreter/debug.txi
--- a/doc/interpreter/debug.txi
+++ b/doc/interpreter/debug.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Debugging
 @chapter Debugging
 
 Octave includes a built-in debugger to aid in the development of
diff --git a/doc/interpreter/diagperm.txi b/doc/interpreter/diagperm.txi
--- a/doc/interpreter/diagperm.txi
+++ b/doc/interpreter/diagperm.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 2009-2013 Jaroslav Hajek
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Diagonal and Permutation Matrices
 @chapter Diagonal and Permutation Matrices
 @cindex diagonal and permutation matrices
 @cindex matrices, diagonal and permutation
@@ -28,37 +28,37 @@
 * Example Code::         Examples of Usage
 * Zeros Treatment::      Differences in Treatment of Zero Elements
 @end menu
 
 @node Basic Usage
 @section Creating and Manipulating Diagonal/Permutation Matrices
 
 A diagonal matrix is defined as a matrix that has zero entries outside the main
-diagonal; that is, 
+diagonal; that is,
 @tex
 $D_{ij} = 0$ if $i \neq j$
 @end tex
 @ifnottex
 @code{D(i,j) == 0} if @code{i != j}.
 @end ifnottex
 Most often, square diagonal matrices are considered; however, the definition can
 equally be applied to non-square matrices, in which case we usually speak of a
 rectangular diagonal matrix.
 
 A permutation matrix is defined as a square matrix that has a single element
 equal to unity in each row and each column; all other elements are zero.  That
-is, there exists a permutation (vector) 
+is, there exists a permutation (vector)
 @tex
 $p$ such that $P_{ij}=1$ if $j = p_i$ and
-$P_{ij}=0$ otherwise.  
+$P_{ij}=0$ otherwise.
 @end tex
 @ifnottex
-@code{p} such that @code{P(i,j) == 1} if @code{j == p(i)} and 
-@code{P(i,j) == 0} otherwise.  
+@code{p} such that @code{P(i,j) == 1} if @code{j == p(i)} and
+@code{P(i,j) == 0} otherwise.
 @end ifnottex
 
 Octave provides special treatment of real and complex rectangular diagonal
 matrices, as well as permutation matrices.  They are stored as special objects,
 using efficient storage and algorithms, facilitating writing both readable and
 efficient matrix algebra expressions in the Octave language.
 
 @menu
@@ -100,17 +100,17 @@ Diagonal Matrix
 @result{}
 Diagonal Matrix
 
    1   0   0
    0   2   0
    0   0   3
    0   0   0
    0   0   0
-@end example  
+@end example
 
 @node Creating Permutation Matrices
 @subsection Creating Permutation Matrices
 
 For creating permutation matrices, Octave does not introduce a new function, but
 rather overrides an existing syntax: permutation matrices can be conveniently
 created by indexing an identity matrix by permutation vectors.
 That is, if @var{q} is a permutation vector of length @var{n}, the expression
@@ -118,21 +118,21 @@ That is, if @var{q} is a permutation vec
 @example
   P = eye (n) (:, q);
 @end example
 
 @noindent
 will create a permutation matrix - a special matrix object.
 
 @example
-eye (n) (q, :) 
+eye (n) (q, :)
 @end example
 
 @noindent
-will also work (and create a row permutation matrix), as well as 
+will also work (and create a row permutation matrix), as well as
 
 @example
 eye (n) (q1, q2).
 @end example
 
 For example:
 
 @example
@@ -226,17 +226,17 @@ are treated specially when performed on 
 
 @node Expressions Involving Diagonal Matrices
 @subsection Expressions Involving Diagonal Matrices
 @cindex diagonal matrix expressions
 
 Assume @var{D} is a diagonal matrix.  If @var{M} is a full matrix,
 then @code{D*M} will scale the rows of @var{M}.  That means,
 if @code{S = D*M}, then for each pair of indices
-i,j it holds 
+i,j it holds
 @tex
 $$S_{ij} = D_{ii} M_{ij}$$
 @end tex
 @ifnottex
 
 @example
 S(i,j) = D(i,i) * M(i,j).
 @end example
@@ -247,18 +247,18 @@ Similarly, @code{M*D} will do a column s
 The matrix @var{D} may also be rectangular, m-by-n where @code{m != n}.
 If @code{m < n}, then the expression @code{D*M} is equivalent to
 
 @example
 D(:,1:m) * M(1:m,:),
 @end example
 
 @noindent
-i.e., trailing @code{n-m} rows of @var{M} are ignored.  If @code{m > n}, 
-then @code{D*M} is equivalent to 
+i.e., trailing @code{n-m} rows of @var{M} are ignored.  If @code{m > n},
+then @code{D*M} is equivalent to
 
 @example
 [D(1:n,n) * M; zeros(m-n, columns (M))],
 @end example
 
 @noindent
 i.e., null rows are appended to the result.
 The situation for right-multiplication @code{M*D} is analogous.
@@ -266,17 +266,17 @@ The situation for right-multiplication @
 @cindex pseudoinverse
 The expressions @code{D \ M} and @code{M / D} perform inverse scaling.
 They are equivalent to solving a diagonal (or rectangular diagonal)
 in a least-squares minimum-norm sense.  In exact arithmetic, this is
 equivalent to multiplying by a pseudoinverse.  The pseudoinverse of
 a rectangular diagonal matrix is again a rectangular diagonal matrix
 with swapped dimensions, where each nonzero diagonal element is replaced
 by its reciprocal.
-The matrix division algorithms do, in fact, use division rather than 
+The matrix division algorithms do, in fact, use division rather than
 multiplication by reciprocals for better numerical accuracy; otherwise, they
 honor the above definition.  Note that a diagonal matrix is never truncated due
 to ill-conditioning; otherwise, it would not be of much use for scaling.  This
 is typically consistent with linear algebra needs.  A full matrix that only
 happens to be diagonal (and is thus not a special object) is of course treated
 normally.
 
 Multiplication and division by diagonal matrices work efficiently also when
@@ -285,31 +285,31 @@ matrix and @var{S} is a sparse matrix sc
 returns a sparse matrix.  The expressions @code{S*D}, @code{D\S}, @code{S/D}
 work analogically.
 
 If @var{D1} and @var{D2} are both diagonal matrices, then the expressions
 
 @example
 @group
 D1 + D2
-D1 - D2 
-D1 * D2 
-D1 / D2 
+D1 - D2
+D1 * D2
+D1 / D2
 D1 \ D2
 @end group
 @end example
 
 @noindent
 again produce diagonal matrices, provided that normal
 dimension matching rules are obeyed.  The relations used are same as described
 above.
 
 Also, a diagonal matrix @var{D} can be multiplied or divided by a scalar, or
 raised to a scalar power if it is square, producing diagonal matrix result in
-all cases. 
+all cases.
 
 A diagonal matrix can also be transposed or conjugate-transposed, giving the
 expected result.  Extracting a leading submatrix of a diagonal matrix, i.e.,
 @code{D(1:m,1:n)}, will produce a diagonal matrix, other indexing expressions
 will implicitly convert to full matrix.
 
 Adding a diagonal matrix to a full matrix only operates on the diagonal
 elements.  Thus,
@@ -327,17 +327,17 @@ When involved in expressions with other 
 take place.  This is not always strictly necessary but chosen to facilitate
 better consistency with @sc{matlab}.
 
 @node Expressions Involving Permutation Matrices
 @subsection Expressions Involving Permutation Matrices
 
 If @var{P} is a permutation matrix and @var{M} a matrix, the expression
 @code{P*M} will permute the rows of @var{M}.  Similarly, @code{M*P} will
-yield a column permutation. 
+yield a column permutation.
 Matrix division @code{P\M} and @code{M/P} can be used to do inverse permutation.
 
 The previously described syntax for creating permutation matrices can actually
 help an user to understand the connection between a permutation matrix and
 a permuting vector.  Namely, the following holds, where @code{I = eye (n)}
 is an identity matrix:
 
 @example
@@ -390,17 +390,17 @@ diagonal or permutation matrices).
 @node Diagonal Matrix Functions
 @subsection Diagonal Matrix Functions
 
 @dfn{inv} and @dfn{pinv} can be applied to a diagonal matrix, yielding again
 a diagonal matrix.  @dfn{det} will use an efficient straightforward calculation
 when given a diagonal matrix, as well as @dfn{cond}.
 The following mapper functions can be applied to a diagonal matrix
 without converting it to a full one:
-@dfn{abs}, @dfn{real}, @dfn{imag}, @dfn{conj}, @dfn{sqrt}. 
+@dfn{abs}, @dfn{real}, @dfn{imag}, @dfn{conj}, @dfn{sqrt}.
 A diagonal matrix can also be returned from the @dfn{balance}
 and @dfn{svd} functions.
 The @dfn{sparse} function will convert a diagonal matrix efficiently to a
 sparse matrix.
 
 @node Permutation Matrix Functions
 @subsection Permutation Matrix Functions
 @cindex matrix, permutation functions
@@ -486,31 +486,31 @@ with Tikhonov regularization (ridge regr
 @cindex matrix, zero elements
 
 Making diagonal and permutation matrices special matrix objects in their own
 right and the consequent usage of smarter algorithms for certain operations
 implies, as a side effect, small differences in treating zeros.
 The contents of this section apply also to sparse matrices, discussed in
 the following chapter. (@pxref{Sparse Matrices})
 
-The IEEE floating point standard defines the result of the expressions @code{0*Inf} and 
+The IEEE floating point standard defines the result of the expressions @code{0*Inf} and
 @code{0*NaN} as @code{NaN}. This is widely agreed to be a good
 compromise.
 Numerical software dealing with structured and sparse matrices (including
 Octave) however, almost always makes a distinction between a "numerical zero"
-and an "assumed zero". 
+and an "assumed zero".
 A "numerical zero" is a zero value occurring in a place where any floating-point
 value could occur.  It is normally stored somewhere in memory as an explicit
-value. 
+value.
 An "assumed zero", on the contrary, is a zero matrix element implied by the
 matrix structure (diagonal, triangular) or a sparsity pattern; its value is
 usually not stored explicitly anywhere, but is implied by the underlying
 data structure.
 
-The primary distinction is that an assumed zero, when multiplied 
+The primary distinction is that an assumed zero, when multiplied
 by any number, or divided by any nonzero number,
 yields *always* a zero, even when, e.g., multiplied by @code{Inf}
 or divided by @code{NaN}.
 The reason for this behavior is that the numerical multiplication is not
 actually performed anywhere by the underlying algorithm; the result is
 just assumed to be zero.  Equivalently, one can say that the part of the
 computation involving assumed zeros is performed symbolically, not numerically.
 
diff --git a/doc/interpreter/diffeq.txi b/doc/interpreter/diffeq.txi
--- a/doc/interpreter/diffeq.txi
+++ b/doc/interpreter/diffeq.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Differential Equations
 @chapter Differential Equations
 
 Octave has built-in functions for solving ordinary differential equations,
diff --git a/doc/interpreter/doccheck/README b/doc/interpreter/doccheck/README
--- a/doc/interpreter/doccheck/README
+++ b/doc/interpreter/doccheck/README
@@ -1,23 +1,23 @@
 ################################################################################
                                    README
                              doccheck directory
 ################################################################################
 This directory contains scripts and data for validating Octave's Texinfo
-documentation.  These scripts are internal developer tools for ensuring 
+documentation.  These scripts are internal developer tools for ensuring
 consistent documentation formats and avoiding misspellings.
 
 The scripts provide 3 services:
 
 1) A spellchecker, built atop GNU Aspell with a private dictionary of keywords
    specific to Octave.
 
 2) A grammarchecker designed from scratch in Perl to ensure a common format
-   for Octave documentation and to make use of as many features of Texinfo as 
+   for Octave documentation and to make use of as many features of Texinfo as
    possible.
 
 3) A list of undocumented functions, i.e, those missing an @DOCSTRING reference
    in the .txi files.
 
 ################################################################################
                                    FILES
 ################################################################################
@@ -43,17 +43,17 @@ This will produce a list of misspelled w
 +Sample Flow
 
 cd doc/interpreter
 doccheck/spellcheck arith.texi > misspellings
 vi arith.texi
 vi misspellings
 ....
   Review misspellings and identify where to correct the source (.m, .cc, .txi)
-  The original source file is marked with a comment: 
+  The original source file is marked with a comment:
 
   @c FUNCTION_NAME SRC_DIR/SRC_FILE
 
   When there is no source file comment, the source file is the .txi source.
   Make corrections to source files, *not* arith.texi which is derived.
 ....
 cd ../../  # top-level of Octave development tree
 make       # propagate changes to arith.texi
@@ -80,15 +80,15 @@ Now Aspell no longer reports any misspel
 
 GRAMMAR:
 
 To be added
 
 UNDOCUMENTED FUNCTIONS:
 
 From the doc/interpreter/ directory, type 'make undocumented_list'.
-This will produce the undocumented_list file with the undocumented functions.  
+This will produce the undocumented_list file with the undocumented functions.
 
 Functions which don't require an @DOCSTRING reference can be added to the list
 of exceptions at the bottom of the mk_undocumented_list script.  This is often
 necessary where a single DOCSTRING, such as besselj, is used to document
 multiple functions.
 
diff --git a/doc/interpreter/doccheck/spellcheck b/doc/interpreter/doccheck/spellcheck
--- a/doc/interpreter/doccheck/spellcheck
+++ b/doc/interpreter/doccheck/spellcheck
@@ -1,14 +1,14 @@
 #!/usr/bin/perl -w
 
 ################################################################################
 # File   : spellcheck
 # Purpose: Spellcheck a single Texinfo file
-#          written in Perl, rather than the shell, to be more portable to OS 
+#          written in Perl, rather than the shell, to be more portable to OS
 #          without good command lines such as Windows.
 # Usage  : spellcheck FILENAME.texi
 ################################################################################
 use File::Temp ":POSIX";
 
 # Initialize variables
 # Octave specific configuration file for Aspell
 $aspell_conf = './doccheck/aspell.conf';
diff --git a/doc/interpreter/emacs.txi b/doc/interpreter/emacs.txi
--- a/doc/interpreter/emacs.txi
+++ b/doc/interpreter/emacs.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 Kurt Hornik
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @c Written by Kurt Hornik <Kurt.Hornik@wu-wien.ac.at> on 1996/05/17.
 @c Last updated by KH on 1997/07/31.
 
 @node Emacs Octave Support
@@ -112,17 +112,17 @@ Describe the features of Octave mode.
 
 @item LFD
 Reindent the current Octave line, insert a newline and indent the new
 line (@code{octave-reindent-then-newline-and-indent}).  An abbrev before
 point is expanded if @code{abbrev-mode} is non-@code{nil}.
 
 @item TAB
 Indents current Octave line based on its contents and on previous
-lines (@code{indent-according-to-mode}). 
+lines (@code{indent-according-to-mode}).
 
 @item ;
 Insert an ``electric'' semicolon (@code{octave-electric-semi}).  If
 @code{octave-auto-indent} is non-@code{nil}, reindent the current line.
 If @code{octave-auto-newline} is non-@code{nil}, automagically insert a
 newline and indent the new line.
 
 @item `
@@ -133,17 +133,17 @@ abbrevs start with a grave accent.
 
 @item M-LFD
 Break line at point and insert continuation marker and alignment
 (@code{octave-split-line}).
 
 @item M-TAB
 Perform completion on Octave symbol preceding point, comparing that
 symbol against Octave's reserved words and built-in variables
-(@code{octave-complete-symbol}). 
+(@code{octave-complete-symbol}).
 
 @item M-C-a
 Move backward to the beginning of a function
 (@code{octave-beginning-of-defun}).
 With prefix argument @var{N}, do it that many times if @var{N} is
 positive; otherwise, move forward to the @var{N}-th following beginning
 of a function.
 
@@ -248,33 +248,33 @@ Search the function, operator and variab
 with documentation for Octave for entries (@code{octave-help}).  If used
 interactively, the entry is prompted for with completion.  If multiple
 matches are found, one can cycle through them using the standard
 @samp{,} (@code{Info-index-next}) command of the Info reader.
 
 The variable @code{octave-help-files} is a list of files to search
 through and defaults to @qcode{'("octave")}.  If there is also an Octave
 Local Guide with corresponding info file, say, @file{octave-LG}, you can
-have @code{octave-help} search both files by 
+have @code{octave-help} search both files by
 @lisp
 (setq octave-help-files '("octave" "octave-LG"))
 @end lisp
 @noindent
 in one of your Emacs startup files.
 
 @end table
 
 A common problem is that the @key{RET} key does @emph{not} indent the
 line to where the new text should go after inserting the newline.  This
 is because the standard Emacs convention is that @key{RET} (aka
 @kbd{C-m}) just adds a newline, whereas @key{LFD} (aka @kbd{C-j}) adds a
 newline and indents it.  This is particularly inconvenient for users with
 keyboards which do not have a special @key{LFD} key at all; in such
 cases, it is typically more convenient to use @key{RET} as the @key{LFD}
-key (rather than typing @kbd{C-j}).  
+key (rather than typing @kbd{C-j}).
 
 You can make @key{RET} do this by adding
 @lisp
 (define-key octave-mode-map "\C-m"
   'octave-reindent-then-newline-and-indent)
 @end lisp
 @noindent
 to one of your Emacs startup files.  Another, more generally applicable
@@ -311,17 +311,17 @@ This is an extremely useful feature for 
 keywords match---if they don't, an error message is displayed.
 
 @item octave-block-offset
 Extra indentation applied to statements in block structures.
 Default is 2.
 
 @item octave-continuation-offset
 Extra indentation applied to Octave continuation lines.
-Default is 4. 
+Default is 4.
 
 @item octave-continuation-string
 String used for Octave continuation lines.
 Normally @samp{\}.
 
 @item octave-mode-startup-message
 If @code{t} (default), a startup message is displayed when Octave mode
 is called.
@@ -370,17 +370,17 @@ bug report using @kbd{C-c C-b} (@code{oc
 automatically sets up a mail buffer with version information already
 added.  You just need to add a description of the problem, including a
 reproducible test case and send the message.
 
 @node Running Octave from Within Emacs
 @appendixsec Running Octave from Within Emacs
 
 The package @file{octave} provides commands for running an inferior
-Octave process in a special Emacs buffer.  Use 
+Octave process in a special Emacs buffer.  Use
 @lisp
 M-x run-octave
 @end lisp
 @noindent
 to directly start an inferior Octave process.  If Emacs does not know
 about this command, add the line
 @lisp
 (autoload 'run-octave "octave-inf" nil t)
diff --git a/doc/interpreter/errors.txi b/doc/interpreter/errors.txi
--- a/doc/interpreter/errors.txi
+++ b/doc/interpreter/errors.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Errors and Warnings
 @chapter Errors and Warnings
 
 Octave includes several functions for printing error and warning
@@ -105,24 +105,24 @@ endfunction
 When it is called with no input arguments it produces the following
 error.
 
 @example
 @group
 f ()
 
 @print{}  error: Invalid call to f.  Correct usage is:
-@print{}  
+@print{}
 @print{}   -- Function File: f (ARG1)
-@print{}  
-@print{}  
+@print{}
+@print{}
 @print{}  Additional help for built-in functions and operators is
 @print{}  available in the online version of the manual.  Use the command
 @print{}  `doc <topic>' to search the manual index.
-@print{}  
+@print{}
 @print{}  Help and information about Octave is also available on the WWW
 @print{}  at http://www.octave.org and via the help@@octave.org
 @print{}  mailing list.
 @end group
 @end example
 
 @DOCSTRING(print_usage)
 
@@ -261,18 +261,18 @@ endfor
 @DOCSTRING(errno)
 
 @DOCSTRING(errno_list)
 
 @node Recovering From Errors
 @subsection Recovering From Errors
 
 Octave provides several ways of recovering from errors.  There are
-@code{try}/@code{catch} blocks, 
-@code{unwind_protect}/@code{unwind_protect_cleanup} blocks, 
+@code{try}/@code{catch} blocks,
+@code{unwind_protect}/@code{unwind_protect_cleanup} blocks,
 and finally the @code{onCleanup} command.
 
 The @code{onCleanup} command associates an ordinary Octave variable (the
 trigger) with an arbitrary function (the action).  Whenever the Octave variable
 ceases to exist---whether due to a function return, an error, or simply because
 the variable has been removed with @code{clear}---then the assigned function
 is executed.
 
@@ -367,25 +367,25 @@ are actually printed to the screen.  If 
 is called with a string argument that is either @qcode{"on"} or @qcode{"off"}
 all warnings will be enabled or disabled.
 
 It is also possible to enable and disable individual warnings through
 their string identifications.  The following code will issue a warning
 
 @example
 @group
-warning ("example:non-negative-variable", 
+warning ("example:non-negative-variable",
          "'a' must be non-negative.  Setting 'a' to zero.");
 @end group
 @end example
 
 @noindent
 while the following won't issue a warning
 
 @example
 @group
 warning ("off", "example:non-negative-variable");
-warning ("example:non-negative-variable", 
+warning ("example:non-negative-variable",
          "'a' must be non-negative.  Setting 'a' to zero.");
 @end group
 @end example
 
 
diff --git a/doc/interpreter/eval.txi b/doc/interpreter/eval.txi
--- a/doc/interpreter/eval.txi
+++ b/doc/interpreter/eval.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Evaluation
 @chapter Evaluation
 
 Normally, you evaluate expressions simply by typing them at the Octave
@@ -35,17 +35,17 @@ been computed and stored in a string, wh
 @end menu
 
 @node Calling a Function by its Name
 @section Calling a Function by its Name
 
 The @code{feval} function allows you to call a function from a string
 containing its name.  This is useful when writing a function that needs to
 call user-supplied functions.  The @code{feval} function takes the name
-of the function to call as its first argument, and the remaining 
+of the function to call as its first argument, and the remaining
 arguments are given to the function.
 
 The following example is a simple-minded function using @code{feval}
 that finds the root of a user-supplied function of one variable using
 Newton's method.
 
 @example
 function result = newtroot (fname, x)
diff --git a/doc/interpreter/expr.txi b/doc/interpreter/expr.txi
--- a/doc/interpreter/expr.txi
+++ b/doc/interpreter/expr.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Expressions
 @chapter Expressions
 @cindex expressions
 
@@ -114,18 +114,18 @@ be used in ranges and typically eliminat
 @code{size} or @code{length} to gather array bounds before indexing.
 For example:
 
 @example
 @group
 a = [1, 2, 3, 4];
 
 a(1:end/2)        # first half of a => [1, 2]
-a(end + 1) = 5;   # append element 
-a(end) = [];      # delete element 
+a(end + 1) = 5;   # append element
+a(end) = [];      # delete element
 a(1:2:end)        # odd elements of a => [1, 3]
 a(2:2:end)        # even elements of a => [2, 4]
 a(end:-1:1)       # reversal of a => [4, 3, 2 , 1]
 @end group
 @end example
 
 @menu
 * Advanced Indexing::
@@ -767,17 +767,17 @@ True if @var{x} is not equal to @var{y}.
 @end table
 
 For complex numbers, the following ordering is defined:
 @var{z1} < @var{z2}
 if and only if
 
 @example
 @group
-  abs (@var{z1}) < abs (@var{z2}) 
+  abs (@var{z1}) < abs (@var{z2})
   || (abs (@var{z1}) == abs (@var{z2}) && arg (@var{z1}) < arg (@var{z2}))
 @end group
 @end example
 
 This is consistent with the ordering used by @dfn{max}, @dfn{min} and
 @dfn{sort}, but is not consistent with @sc{matlab}, which only compares the real
 parts.
 
@@ -1003,17 +1003,17 @@ function f (a, b, c)
 @end example
 
 @noindent
 would result in an error if @code{f} were called with one or two
 arguments because Octave would be forced to try to evaluate both of the
 operands for the operator @samp{&}.
 
 @sc{matlab} has special behavior that allows the operators @samp{&} and
-@samp{|} to short-circuit when used in the truth expression for @code{if} and 
+@samp{|} to short-circuit when used in the truth expression for @code{if} and
 @code{while} statements.  The Octave parser may be instructed to behave in the
 same manner, but its use is strongly discouraged.
 
 @DOCSTRING(do_braindead_shortcircuit_evaluation)
 
 Finally, the ternary operator (?:) is not supported in Octave.  If
 short-circuiting is not important, it can be replaced by the @code{ifelse}
 function.
@@ -1159,17 +1159,17 @@ c = v
 In expressions like this, the number of values in each part of the
 expression need not match.  For example, the expression
 
 @example
 [a, b] = [u, s, v] = svd (a)
 @end example
 
 @noindent
-is equivalent to 
+is equivalent to
 
 @example
 @group
 [u, s, v] = svd (a)
 a = u
 b = s
 @end group
 @end example
diff --git a/doc/interpreter/external.txi b/doc/interpreter/external.txi
--- a/doc/interpreter/external.txi
+++ b/doc/interpreter/external.txi
@@ -2,22 +2,22 @@
 @c Copyright (C) 2007 Paul Thomas and Christoph Spiel
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node External Code Interface
 @appendix External Code Interface
 @cindex dynamic-linking
 @cindex Dynamically Linked Functions
@@ -124,17 +124,17 @@ bridge to hardware resources which often
 * Sparse Matrices in Oct-Files::
 * Accessing Global Variables in Oct-Files::
 * Calling Octave Functions from Oct-Files::
 * Calling External Code from Oct-Files::
 * Allocating Local Memory in Oct-Files::
 * Input Parameter Checking in Oct-Files::
 * Exception and Error Handling in Oct-Files::
 * Documentation and Test of Oct-Files::
-@c * Application Programming Interface for Oct-Files::  
+@c * Application Programming Interface for Oct-Files::
 @end menu
 
 @node Getting Started with Oct-Files
 @subsection Getting Started with Oct-Files
 
 Oct-files are pieces of C++ code that have been compiled with the Octave
 API into a dynamically loadable object.  They take their name from the file
 which contains the object which has the extension @file{.oct}.
@@ -150,17 +150,17 @@ Consider the following short example whi
 writing a C++ function that can be linked to Octave.
 
 @example
 @group
 @EXAMPLEFILE(helloworld.cc)
 @end group
 @end example
 
-The first critical line is @code{#include <octave/oct.h>} which 
+The first critical line is @code{#include <octave/oct.h>} which
 makes available most of the definitions necessary for a C++ oct-file.
 Note that @file{octave/oct.h} is a C++ header and cannot be directly
 @code{#include}'ed in a C source file, nor any other language.
 
 Included by @file{oct.h} is a definition for the macro
 @w{@code{DEFUN_DLD}} which creates a dynamically loaded function.  This
 macro takes four arguments:
 
@@ -734,27 +734,27 @@ with fewer elements than are actually in
 @group
 int nr, nc;
 nr = 3, nc = 4;
 SparseMatrix sm (nr, nc, 0);
 sm(0,0) = 1; sm(0,1) = 2; sm(1,3) = 3; sm(2,3) = 4;
 @end group
 @end example
 
-@noindent 
+@noindent
 is perfectly valid.  However, it is a very bad idea because as each new
 element is added to the sparse matrix the matrix needs to request more
 space and reallocate memory.  This is an expensive operation, that will
 significantly slow this means of creating a sparse matrix.  Furthermore,
 it is possible to create a sparse matrix with too much storage, so having
 @var{nz} greater than 4 is also valid.  The disadvantage is that the matrix
 occupies more memory than strictly needed.
 
 It is not always possible to know the number of non-zero elements prior
-to filling a matrix.  For this reason the additional unused storage of 
+to filling a matrix.  For this reason the additional unused storage of
 a sparse matrix can be removed after its creation with the
 @code{maybe_compress} function.  In addition, @code{maybe_compress} can
 deallocate the unused storage, but it can also remove zero elements
 from the matrix.  The removal of zero elements from the matrix is
 controlled by setting the argument of the @code{maybe_compress} function
 to be @code{true}.  However, the cost of removing the zeros is high because it
 implies re-sorting the elements.  If possible, it is better
 if the user does not add the unnecessary zeros in the first place.
@@ -865,17 +865,17 @@ The basic means of extracting a sparse m
 and returning it as an @code{octave_value}, can be seen in the
 following example.
 
 @example
 @group
 octave_value_list retval;
 
 SparseMatrix sm = args(0).sparse_matrix_value ();
-SparseComplexMatrix scm = 
+SparseComplexMatrix scm =
     args(1).sparse_complex_matrix_value ();
 SparseBoolMatrix sbm = args(2).sparse_bool_matrix_value ();
 @dots{}
 retval(2) = sbm;
 retval(1) = scm;
 retval(0) = sm;
 @end group
 @end example
@@ -1209,17 +1209,17 @@ help strings within oct-files.
 
 The major issue is that the help string will typically be longer than a
 single line of text, and so the formatting of long help strings needs to
 be taken into account.  There are several possible solutions, but the most
 common is illustrated in the following example,
 
 @example
 @group
-DEFUN_DLD (do_what_i_want, args, nargout, 
+DEFUN_DLD (do_what_i_want, args, nargout,
   "-*- texinfo -*-\n\
 @@deftypefn @{Function File@} @{@} do_what_i_say (@@var@{n@})\n\
 A function that does what the user actually wants rather\n\
 than what they requested.\n\
 @@end deftypefn")
 @{
 @dots{}
 @}
@@ -1251,17 +1251,17 @@ from the compiled code.  An example in a
 %!error (sin ())
 %!error (sin (1,1))
 */
 @end group
 @end example
 
 @c @node Application Programming Interface for Oct-Files
 @c @subsection Application Programming Interface for Oct-Files
-@c 
+@c
 @c WRITE ME, using Coda section 1.3 as a starting point.
 
 @node Mex-Files
 @section Mex-Files
 @cindex mex-files
 @cindex mex
 
 Octave includes an interface to allow legacy mex-files to be compiled
@@ -1278,17 +1278,17 @@ be written with the oct-file interface p
 @menu
 * Getting Started with Mex-Files::
 * Working with Matrices and Arrays in Mex-Files::
 * Character Strings in Mex-Files::
 * Cell Arrays with Mex-Files::
 * Structures with Mex-Files::
 * Sparse Matrices with Mex-Files::
 * Calling Other Functions in Mex-Files::
-@c * Application Programming Interface for Mex-Files::  
+@c * Application Programming Interface for Mex-Files::
 @end menu
 
 @node Getting Started with Mex-Files
 @subsection Getting Started with Mex-Files
 
 The basic command to build a mex-file is either @code{mkoctfile --mex}
 or @code{mex}.  The first command can be used either from within Octave or from
 the command line.  However, to avoid issues with @sc{matlab}'s own @code{mex}
@@ -1560,38 +1560,38 @@ mxArray *mxCreateCellMatrix (int m, int 
 @subsection Structures with Mex-Files
 
 The basic function to create a structure in a mex-file is
 @code{mxCreateStructMatrix} which creates a structure array with a two
 dimensional matrix, or @code{mxCreateStructArray}.
 
 @example
 @group
-mxArray *mxCreateStructArray (int ndims, int *dims, 
-                              int num_keys, 
+mxArray *mxCreateStructArray (int ndims, int *dims,
+                              int num_keys,
                               const char **keys);
-mxArray *mxCreateStructMatrix (int rows, int cols, 
-                               int num_keys, 
+mxArray *mxCreateStructMatrix (int rows, int cols,
+                               int num_keys,
                                const char **keys);
 @end group
 @end example
 
 Accessing the fields of the structure can then be performed with
 @code{mxGetField} and @code{mxSetField} or alternatively with the
 @code{mxGetFieldByNumber} and @code{mxSetFieldByNumber} functions.
 
 @example
 @group
 mxArray *mxGetField (const mxArray *ptr, mwIndex index,
                      const char *key);
-mxArray *mxGetFieldByNumber (const mxArray *ptr, 
+mxArray *mxGetFieldByNumber (const mxArray *ptr,
                              mwIndex index, int key_num);
-void mxSetField (mxArray *ptr, mwIndex index, 
+void mxSetField (mxArray *ptr, mwIndex index,
                  const char *key, mxArray *val);
-void mxSetFieldByNumber (mxArray *ptr, mwIndex index, 
+void mxSetFieldByNumber (mxArray *ptr, mwIndex index,
                          int key_num, mxArray *val);
 @end group
 @end example
 
 A difference between the oct-file interface to structures and the
 mex-file version is that the functions to operate on structures in
 mex-files directly include an @code{index} over the elements of the
 arrays of elements per @code{field}; Whereas, the oct-file structure
@@ -1602,17 +1602,17 @@ found in the file @file{mystruct.c} show
 
 @example
 @EXAMPLEFILE(mystruct.c)
 @end example
 
 An example of the behavior of this function within Octave is then
 
 @example
-a(1).f1 = "f11"; a(1).f2 = "f12"; 
+a(1).f1 = "f11"; a(1).f2 = "f12";
 a(2).f1 = "f21"; a(2).f2 = "f22";
 b = mystruct (a);
 @result{}  field f1(0) = f11
     field f1(1) = f21
     field f2(0) = f12
     field f2(1) = f22
 b
 @result{} 2x2 struct array containing the fields:
@@ -1720,17 +1720,17 @@ a = myfeval ("sin", 1)
 @end group
 @end example
 
 Note that it is not possible to use function handles or inline functions
 within a mex-file.
 
 @c @node Application Programming Interface for Mex-Files
 @c @subsection Application Programming Interface for Mex-Files
-@c 
+@c
 @c WRITE ME, refer to mex.h and mexproto.h
 
 @node Standalone Programs
 @section Standalone Programs
 
 The libraries Octave itself uses can be utilized in standalone
 applications.  These applications then have access, for example, to the
 array and matrix classes, as well as to all of the Octave algorithms.  The
@@ -1775,22 +1775,22 @@ which, as before, is compiled and run as
 @group
 $ mkoctfile --link-stand-alone embedded.cc -o embedded
 $ ./embedded
 GCD of [10, 15] is 5
 $
 @end group
 @end example
 
-It is worth noting that, if only built-in functions are to be called from 
-a C++ standalone program, then it does not need to initialize the 
-interpreter to do so.  The general rule is that, for a built-in 
+It is worth noting that, if only built-in functions are to be called from
+a C++ standalone program, then it does not need to initialize the
+interpreter to do so.  The general rule is that, for a built-in
 function named @code{function_name} in the interpreter, there will be
-a C++ function named @code{Ffunction_name} (note the prepended capital 
-@code{F}) accessible in the C++ API@.  The declarations for all built-in 
+a C++ function named @code{Ffunction_name} (note the prepended capital
+@code{F}) accessible in the C++ API@.  The declarations for all built-in
 functions are collected in the header file @code{builtin-defun-decls.h}.
 This feature should be used with care as the list of built-in functions can
 change.  No guarantees can be made that a function that is currently built in
 won't be implemented as a .m file or as a dynamically linked function in the
 future.  An example of how to call built-in functions from C++ can be seen in the
 code
 
 @example
@@ -1798,17 +1798,17 @@ code
 @end example
 
 @noindent
 which, again, is compiled and run as a standalone application with
 
 @example
 @group
 $ mkoctfile --link-stand-alone standalonebuiltin.cc -o standalonebuiltin
-$ ./standalonebuiltin 
+$ ./standalonebuiltin
 This is a matrix:
  11 12
  21 22
 
 This is the norm of the matrix:
 34.4952
 $
 @end group
diff --git a/doc/interpreter/fn-idx.txi b/doc/interpreter/fn-idx.txi
--- a/doc/interpreter/fn-idx.txi
+++ b/doc/interpreter/fn-idx.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Function Index
 @unnumbered Function Index
 
 @printindex fn
diff --git a/doc/interpreter/func.txi b/doc/interpreter/func.txi
--- a/doc/interpreter/func.txi
+++ b/doc/interpreter/func.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Functions and Scripts
 @chapter Functions and Scripts
 @cindex defining functions
 @cindex user-defined functions
@@ -465,17 +465,17 @@ function val = smallest (varargin)
 endfunction
 @end group
 @end example
 
 @noindent
 This implementation handles any number of input arguments, but it's also
 a very simple solution to the problem.
 
-A slightly more complex example of @code{varargin} is a function 
+A slightly more complex example of @code{varargin} is a function
 @code{print_arguments} that prints all input arguments.  Such a function
 can be defined like this
 
 @example
 @group
 function print_arguments (varargin)
   for i = 1:length (varargin)
     printf ("Input argument %d: ", i);
@@ -774,17 +774,17 @@ using @code{addpath} and @code{rmpath}. 
 code adds @samp{~/Octave} to the load path.
 
 @example
 addpath ("~/Octave")
 @end example
 
 @noindent
 After this the directory @samp{~/Octave} will be searched for functions.
- 
+
 @DOCSTRING(addpath)
 
 @DOCSTRING(genpath)
 
 @DOCSTRING(rmpath)
 
 @DOCSTRING(savepath)
 
@@ -853,18 +853,18 @@ function @code{func2} to do much of the 
 function y = func1 (x)
   y = func2 (x);
 endfunction
 @end group
 @end example
 
 @noindent
 Then if the path to @code{func1} is @code{<directory>/func1.m}, and if
-@code{func2} is found in the directory @code{<directory>/private/func2.m}, 
-then @code{func2} is only available for use of the functions, like 
+@code{func2} is found in the directory @code{<directory>/private/func2.m},
+then @code{func2} is only available for use of the functions, like
 @code{func1}, that are found in @code{<directory>}.
 
 @node Nested Functions
 @subsection Nested Functions
 
 Nested functions are similar to subfunctions in that only the main function is
 visible outside the file.  However, they also allow for child functions to
 access the local variables in their parent function.  This shared access mimics
@@ -1014,17 +1014,17 @@ endfunction
 @end example
 
 @node Overloading and Autoloading
 @subsection Overloading and Autoloading
 
 Functions can be overloaded to work with different input arguments.  For
 example, the operator '+' has been overloaded in Octave to work with single,
 double, uint8, int32, and many other arguments.  The preferred way to overload
-functions is through classes and object oriented programming 
+functions is through classes and object oriented programming
 (@pxref{Function Overloading}).  Occasionally, however, one needs to undo
 user overloading and call the default function associated with a specific
 type.  The @code{builtin} function exists for this purpose.
 
 @DOCSTRING(builtin)
 
 A single dynamically linked file might define several
 functions.  However, as Octave searches for functions based on the
@@ -1117,21 +1117,21 @@ is possible and even likely that multipl
 defined within a particular scope.  The precedence of which function will be
 used within a particular scope is given by
 
 @enumerate 1
 @item Subfunction
 A subfunction with the required function name in the given scope.
 
 @item Private function
-A function defined within a private directory of the directory 
+A function defined within a private directory of the directory
 which contains the current function.
 
 @item Class constructor
-A function that constuctors a user class as defined in chapter 
+A function that constuctors a user class as defined in chapter
 @ref{Object Oriented Programming}.
 
 @item Class method
 An overloaded function of a class as in chapter
 @ref{Object Oriented Programming}.
 
 @item Command-line Function
 A function that has been defined on the command-line.
@@ -1163,17 +1163,17 @@ function file, and that it defines a sin
 evaluated as soon as it is defined.
 
 A script file also differs from a function file in that the variables
 named in a script file are not local variables, but are in the same
 scope as the other variables that are visible on the command line.
 
 Even though a script file may not begin with the @code{function}
 keyword, it is possible to define more than one function in a single
-script file and load (but not execute) all of them at once.  To do 
+script file and load (but not execute) all of them at once.  To do
 this, the first token in the file (ignoring comments and other white
 space) must be something other than @code{function}.  If you have no
 other statements to evaluate, you can use a statement that has no
 effect, like this:
 
 @example
 @group
 # Prevent Octave from thinking that this
@@ -1256,17 +1256,17 @@ execute commands from any file.
 @node Function Handles Anonymous Functions Inline Functions
 @section Function Handles, Anonymous Functions, Inline Functions
 @cindex handle, function handles
 @cindex anonymous functions
 @cindex inline, inline functions
 
 It can be very convenient store a function in a variable so that it
 can be passed to a different function.  For example, a function that
-performs numerical minimization needs access to the function that 
+performs numerical minimization needs access to the function that
 should be minimized.
 
 @menu
 * Function Handles::
 * Anonymous Functions::
 * Inline Functions::
 @end menu
 
@@ -1409,17 +1409,17 @@ Commands are a special class of function
 input arguments.  A command can be called as an ordinary function, but
 it can also be called without the parentheses.  For example,
 
 @example
 my_command hello world
 @end example
 
 @noindent
-is equivalent to 
+is equivalent to
 
 @example
 my_command ("hello", "world")
 @end example
 
 @noindent
 The general form of a command call is
 
diff --git a/doc/interpreter/geometry.txi b/doc/interpreter/geometry.txi
--- a/doc/interpreter/geometry.txi
+++ b/doc/interpreter/geometry.txi
@@ -1,35 +1,35 @@
 @c Copyright (C) 2007-2013 John W. Eaton and David Bateman
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Geometry
 @chapter Geometry
 
-Much of the geometry code in Octave is based on the Qhull 
-library@footnote{Barber, C.B., Dobkin, D.P., and Huhdanpaa, H.T., 
-@cite{The Quickhull Algorithm for Convex Hulls}, ACM Trans. on Mathematical 
-Software, 22(4):469--483, Dec 1996, @url{http://www.qhull.org}}.  
-Some of the documentation for Qhull, particularly for the options that 
-can be passed to @code{delaunay}, @code{voronoi} and @code{convhull}, 
+Much of the geometry code in Octave is based on the Qhull
+library@footnote{Barber, C.B., Dobkin, D.P., and Huhdanpaa, H.T.,
+@cite{The Quickhull Algorithm for Convex Hulls}, ACM Trans. on Mathematical
+Software, 22(4):469--483, Dec 1996, @url{http://www.qhull.org}}.
+Some of the documentation for Qhull, particularly for the options that
+can be passed to @code{delaunay}, @code{voronoi} and @code{convhull},
 etc., is relevant to Octave users.
 
 @menu
 * Delaunay Triangulation::
 * Voronoi Diagrams::
 * Convex Hull::
 * Interpolation on Scattered Data::
 @end menu
@@ -41,25 +41,25 @@ The Delaunay triangulation is constructe
 circum-circles.  These circum-circles are chosen so that there are at
 least three of the points in the set to triangulation on the
 circumference of the circum-circle.  None of the points in the set of
 points falls within any of the circum-circles.
 
 In general there are only three points on the circumference of any
 circum-circle.  However, in some cases, and in particular for the
 case of a regular grid, 4 or more points can be on a single
-circum-circle.  In this case the Delaunay triangulation is not unique. 
+circum-circle.  In this case the Delaunay triangulation is not unique.
 
 @DOCSTRING(delaunay)
 
 The 3- and N-dimensional extension of the Delaunay triangulation are
-given by @code{delaunay3} and @code{delaunayn} respectively.  
+given by @code{delaunay3} and @code{delaunayn} respectively.
 @code{delaunay3} returns a set of tetrahedra that satisfy the
 Delaunay circum-circle criteria.  Similarly, @code{delaunayn} returns the
-N-dimensional simplex satisfying the Delaunay circum-circle criteria.  
+N-dimensional simplex satisfying the Delaunay circum-circle criteria.
 The N-dimensional extension of a triangulation is called a tessellation.
 
 @DOCSTRING(delaunay3)
 
 @DOCSTRING(delaunayn)
 
 An example of a Delaunay triangulation of a set of points is
 
@@ -283,17 +283,17 @@ where the point outside the tessellation
 
 A Voronoi diagram or Voronoi tessellation of a set of points @var{s} in
 an N-dimensional space, is the tessellation of the N-dimensional space
 such that all points in @code{@var{v}(@var{p})}, a partitions of the
 tessellation where @var{p} is a member of @var{s}, are closer to @var{p}
 than any other point in @var{s}.  The Voronoi diagram is related to the
 Delaunay triangulation of a set of points, in that the vertexes of the
 Voronoi tessellation are the centers of the circum-circles of the
-simplices of the Delaunay tessellation. 
+simplices of the Delaunay tessellation.
 
 @DOCSTRING(voronoi)
 
 @DOCSTRING(voronoin)
 
 An example of the use of @code{voronoi} is
 
 @example
@@ -323,17 +323,17 @@ diagram clearer.
 @end ifnotinfo
 
 Additional information about the size of the facets of a Voronoi
 diagram, and which points of a set of points is in a polygon can be had
 with the @code{polyarea} and @code{inpolygon} functions respectively.
 
 @DOCSTRING(polyarea)
 
-An example of the use of @code{polyarea} might be 
+An example of the use of @code{polyarea} might be
 
 @example
 @group
 rand ("state", 2);
 x = rand (10, 1);
 y = rand (10, 1);
 [c, f] = voronoin ([x, y]);
 af = zeros (size (f));
@@ -440,17 +440,17 @@ y = 2*rand (size (x)) - 1;
 z = sin (2*(x.^2+y.^2));
 [xx,yy] = meshgrid (linspace (-1,1,32));
 griddata (x,y,z,xx,yy);
 @end group
 @end example
 
 @noindent
 that interpolates from a random scattering of points, to a uniform
-grid. 
+grid.
 @ifnotinfo
 The output of the above can be seen in @ref{fig:griddata}.
 
 @float Figure,fig:griddata
 @center @image{griddata,4in}
 @caption{Interpolation from a scattered data to a regular grid}
 @end float
 @end ifnotinfo
diff --git a/doc/interpreter/geometryimages.m b/doc/interpreter/geometryimages.m
--- a/doc/interpreter/geometryimages.m
+++ b/doc/interpreter/geometryimages.m
@@ -100,17 +100,17 @@ function geometryimages (nm, typ)
   hide_output ();
 endfunction
 
 function [r, c] = tri2circ (tri, xx, yy)
   x = xx(tri);
   y = yy(tri);
   m = (y(1:end-1) - y(2:end)) ./ (x(1:end-1) - x(2:end));
   xc = (prod(m) .* (y(1) - y(end)) + m(end)*(x(1)+x(2)) - m(1)*(x(2)+x(3))) ...
-        ./ (2 * (m(end) - m(1))); 
+        ./ (2 * (m(end) - m(1)));
   yc = - (xc - (x(2) + x(3))./2) ./ m(end) + (y(2) + y(3)) / 2;
   c = [xc, yc];
   r = sqrt ((xc - x(1)).^2 + (yc - y(1)).^2);
 endfunction
 
 function set_print_size ()
   image_size = [5.0, 3.5]; # in inches, 16:9 format
   border = 0;              # For postscript use 50/72
diff --git a/doc/interpreter/gpl.txi b/doc/interpreter/gpl.txi
--- a/doc/interpreter/gpl.txi
+++ b/doc/interpreter/gpl.txi
@@ -218,17 +218,17 @@ and you may offer support or warranty pr
 @item Conveying Modified Source Versions.
 
 You may convey a work based on the Program, or the modifications to
 produce it from the Program, in the form of source code under the
 terms of section 4, provided that you also meet all of these
 conditions:
 
 @enumerate a
-@item 
+@item
 The work must carry prominent notices stating that you modified it,
 and giving a relevant date.
 
 @item
 The work must carry prominent notices stating that it is released
 under this License and any conditions added under section 7.  This
 requirement modifies the requirement in section 4 to ``keep intact all
 notices''.
@@ -666,17 +666,17 @@ free software which everyone can redistr
 terms.
 
 To do so, attach the following notices to the program.  It is safest
 to attach them to the start of each source file to most effectively
 state the exclusion of warranty; and each file should have at least
 the ``copyright'' line and a pointer to where the full notice is found.
 
 @smallexample
-@var{one line to give the program's name and a brief idea of what it does.}  
+@var{one line to give the program's name and a brief idea of what it does.}
 Copyright (C) @var{year} @var{name of author}
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or (at
 your option) any later version.
 
 This program is distributed in the hope that it will be useful, but
@@ -689,17 +689,17 @@ along with this program.  If not, see @u
 @end smallexample
 
 Also add information on how to contact you by electronic and paper mail.
 
 If the program does terminal interaction, make it output a short
 notice like this when it starts in an interactive mode:
 
 @smallexample
-@var{program} Copyright (C) @var{year} @var{name of author} 
+@var{program} Copyright (C) @var{year} @var{name of author}
 This program comes with ABSOLUTELY NO WARRANTY; for details type @samp{show w}.
 This is free software, and you are welcome to redistribute it
 under certain conditions; type @samp{show c} for details.
 @end smallexample
 
 The hypothetical commands @samp{show w} and @samp{show c} should show
 the appropriate parts of the General Public License.  Of course, your
 program's commands might be different; for a GUI interface, you would
diff --git a/doc/interpreter/grammar.txi b/doc/interpreter/grammar.txi
--- a/doc/interpreter/grammar.txi
+++ b/doc/interpreter/grammar.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Grammar and Parser
 @appendix Grammar and Parser
 @cindex grammar rules
 @cindex language definition
diff --git a/doc/interpreter/gui.txi b/doc/interpreter/gui.txi
--- a/doc/interpreter/gui.txi
+++ b/doc/interpreter/gui.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 2012-2013 Rik Wehbring
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node GUI Development
 @chapter GUI Development
 
 Octave is principally a batch or command-line language.  However, it does
diff --git a/doc/interpreter/image.txi b/doc/interpreter/image.txi
--- a/doc/interpreter/image.txi
+++ b/doc/interpreter/image.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Image Processing
 @chapter Image Processing
 
 Since an image is basically a matrix, Octave is a very powerful
@@ -218,25 +218,25 @@ The following functions can be used to m
 
 @DOCSTRING(cmpermute)
 
 @node Plotting on top of Images
 @section Plotting on top of Images
 
 If gnuplot is being used to display images it is possible to plot on
 top of images.  Since an image is a matrix it is indexed by row and
-column values.  The plotting system is, however, based on the 
+column values.  The plotting system is, however, based on the
 traditional @math{(x, y)} system.  To minimize the difference between
 the two systems Octave places the origin of the coordinate system in
 the point corresponding to the pixel at @math{(1, 1)}.  So, to plot
 points given by row and column values on top of an image, one should
 simply call @code{plot} with the column values as the first argument
 and the row values as the second.  As an example the following code
 generates an image with random intensities between 0 and 1, and shows
-the image with red circles over pixels with an intensity above 
+the image with red circles over pixels with an intensity above
 @math{0.99}.
 
 @example
 @group
 I = rand (100, 100);
 [row, col] = find (I > 0.99);
 hold ("on");
 imshow (I);
@@ -244,17 +244,17 @@ plot (col, row, "ro");
 hold ("off");
 @end group
 @end example
 
 @node Color Conversion
 @section Color Conversion
 
 Octave supports conversion from the RGB color system to NTSC and HSV
-and vice versa. 
+and vice versa.
 
 @DOCSTRING(rgb2hsv)
 
 @DOCSTRING(hsv2rgb)
 
 @DOCSTRING(rgb2ntsc)
 
 @DOCSTRING(ntsc2rgb)
diff --git a/doc/interpreter/install.txi b/doc/interpreter/install.txi
--- a/doc/interpreter/install.txi
+++ b/doc/interpreter/install.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @c The text of this file appears in the file INSTALL in the Octave
 @c distribution, as well as in the Octave manual.
 
 @ifclear INSTALLONLY
@@ -282,17 +282,17 @@ API for portable 2-D and 3-D graphics (@
 OpenGL implementation is required to provide Octave's OpenGL-based
 graphics functions.  Octave's OpenGL-based graphics functions usually
 outperform the gnuplot-based graphics functions because plot data can be
 rendered directly instead of sending data and commands to gnuplot for
 interpretation and rendering.
 
 @item Qhull
 Computational geometry library (@url{http://www.qhull.org}).  Qhull is
-required to provide the functions @code{convhull}, @code{convhulln}, 
+required to provide the functions @code{convhull}, @code{convhulln},
 @code{delaunay}, @code{delaunay3}, @code{delaunayn}, @code{voronoi}, and
 @code{voronoin}.
 
 @item QRUPDATE
 QR factorization updating library
 (@url{http://sourceforge.net/projects/qrupdate}).  QRUPDATE is used to
 provide improved performance for the functions @code{qrdelete},
 @code{qrinsert}, @code{qrshift}, and @code{qrupdate}.
@@ -477,18 +477,18 @@ for Mac systems.
 Don't use framework OpenGL headers, libraries, or specific source code
 even if the configure test succeeds.  If this option is given then
 OpenGL headers and libraries in standard system locations are tested
 (the default value is @option{--with-framework-opengl}).  This is a
 platform specific configure option for Mac systems.
 
 @end table
 
-See the file @file{INSTALL} for more general information about the 
-command line options used by configure.  That file also contains 
+See the file @file{INSTALL} for more general information about the
+command line options used by configure.  That file also contains
 instructions for compiling in a directory other than the one where
 the source is located.
 
 @item
 Run make.
 
 You will need a recent version of GNU Make as Octave relies on certain
 features not generally available in all versions of make.  Modifying
@@ -600,17 +600,17 @@ Configuring Octave with @option{--enable
 32-bit system have a 64-bit address space.
 
 On 64-bit systems, Octave is limited to (approximately) the following
 array sizes when using the default 32-bit indexing mode:
 
 @example
 @group
 double:         16GB
-single:          8GB 
+single:          8GB
 uint64, int64:  16GB
 uint32, int32:   8GB
 uint16, int16:   4GB
 uint8, int8:     2GB
 @end group
 @end example
 
 In each case, the limit is really (approximately) @math{2^{31}} elements
@@ -761,17 +761,17 @@ Octave's 64-bit index support is activat
   CPPFLAGS="-I$prefix64/include" LDFLAGS="-L$prefix64/lib" \
   --enable-64
 @end group
 @end example
 
 You must ensure that all Fortran sources except those in the
 @file{liboctave/cruft/ranlib} directory are compiled such that INTEGERS are
 8-bytes wide.  If you are using gfortran, the configure script should
-automatically set the Makefile variable @w{@env{F77_INTEGER_8_FLAG}} to 
+automatically set the Makefile variable @w{@env{F77_INTEGER_8_FLAG}} to
 @option{-fdefault-integer-8}.  If you are using another compiler, you
 must set this variable yourself.  You should NOT set this flag in
 @env{FFLAGS}, otherwise the files in @file{liboctave/cruft/ranlib} will be
 miscompiled.
 
 @item Other dependencies
 
 Probably nothing special needs to be done for the following
@@ -843,20 +843,20 @@ problems, then you should modify the con
 On FreeBSD systems Octave may hang while initializing some internal
 constants.  The fix appears to be to use
 
 @example
 options      GPL_MATH_EMULATE
 @end example
 
 @noindent
-rather than 
+rather than
 
 @example
-options      MATH_EMULATE 
+options      MATH_EMULATE
 @end example
 
 @noindent
 in the kernel configuration files (typically found in the directory
 @file{/sys/i386/conf}.  After making this change, you'll need to rebuild
 the kernel, install it, and reboot.
 
 @item
@@ -869,17 +869,17 @@ passing `void (*)()' as argument 2 of
 @end group
 @end example
 
 @noindent
 or
 
 @example
 @group
-warning: ANSI C++ prohibits conversion from `(int)' 
+warning: ANSI C++ prohibits conversion from `(int)'
          to `(@dots{})'
 @end group
 @end example
 
 @noindent
 while compiling @file{sighandlers.cc}, you may need to edit some files
 in the @code{gcc} include subdirectory to add proper prototypes for
 functions there.  For example, Ultrix 4.2 needs proper declarations for
@@ -948,17 +948,17 @@ when compiling the Fortran subroutines i
 subdirectory, you should either upgrade your compiler or try compiling
 with optimization turned off.
 
 @item
 On NeXT systems, if you get errors like this:
 
 @example
 @group
-/usr/tmp/cc007458.s:unknown:Undefined local 
+/usr/tmp/cc007458.s:unknown:Undefined local
       symbol LBB7656
 /usr/tmp/cc007458.s:unknown:Undefined local
       symbol LBE7656
 @end group
 @end example
 
 @noindent
 when compiling @file{Array.cc} and @file{Matrix.cc}, try recompiling
diff --git a/doc/interpreter/interp.txi b/doc/interpreter/interp.txi
--- a/doc/interpreter/interp.txi
+++ b/doc/interpreter/interp.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 2007-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Interpolation
 @chapter Interpolation
 
 @menu
@@ -66,23 +66,23 @@ legend ("spline", "pchip");
 
 @ifnotinfo
 @noindent
 The result of which can be seen in @ref{fig:interpderiv1} and
 @ref{fig:interpderiv2}.
 
 @float Figure,fig:interpderiv1
 @center @image{interpderiv1,4in}
-@caption{Comparison of @qcode{"pchip"} and @qcode{"spline"} interpolation methods for a 
+@caption{Comparison of @qcode{"pchip"} and @qcode{"spline"} interpolation methods for a
 step function}
 @end float
 
 @float Figure,fig:interpderiv2
 @center @image{interpderiv2,4in}
-@caption{Comparison of the second derivative of the @qcode{"pchip"} and @qcode{"spline"} 
+@caption{Comparison of the second derivative of the @qcode{"pchip"} and @qcode{"spline"}
 interpolation methods for a step function}
 @end float
 @end ifnotinfo
 
 Fourier interpolation, is a resampling technique where a signal is
 converted to the frequency domain, padded with zeros and then
 reconverted to the time domain.
 
diff --git a/doc/interpreter/interpimages.m b/doc/interpreter/interpimages.m
--- a/doc/interpreter/interpimages.m
+++ b/doc/interpreter/interpimages.m
@@ -69,17 +69,17 @@ function interpimages (nm, typ)
     dti = 0.025;
     y = sign (t);
     ddys = diff (diff (interp1 (t,y,ti,"spline"))./dti)./dti;
     ddyp = diff (diff (interp1 (t,y,ti,"pchip"))./dti)./dti;
     plot (ti(2:end-1),ddys,"r*", ti(2:end-1),ddyp,"g+");
     legend ("spline", "pchip");
     print ([nm "." typ], d_typ);
   endif
-  hide_output ();  
+  hide_output ();
 endfunction
 
 function set_print_size ()
   image_size = [5.0, 3.5]; # in inches, 16:9 format
   border = 0;              # For postscript use 50/72
   set (0, "defaultfigurepapertype", "<custom>");
   set (0, "defaultfigurepaperorientation", "landscape");
   set (0, "defaultfigurepapersize", image_size + 2*border);
diff --git a/doc/interpreter/intro.txi b/doc/interpreter/intro.txi
--- a/doc/interpreter/intro.txi
+++ b/doc/interpreter/intro.txi
@@ -1,48 +1,48 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Introduction
 @chapter A Brief Introduction to Octave
 @cindex introduction
 
 GNU Octave is a high-level language, primarily intended for numerical
-computations.  It is typically used for such problems as solving 
+computations.  It is typically used for such problems as solving
 linear and nonlinear equations, numerical linear algebra, statistical
 analysis, and for performing other numerical experiments.  It may also
 be used as a batch-oriented language for automated data processing.
 
 Until recently GNU Octave provided a command-line interface with
 graphical results displayed in separate windows.  The current version
 (version 3.8, released in late 2013) also provides, by default, a
 graphical user interface.
 
-GNU Octave is freely redistributable software.  You may redistribute 
+GNU Octave is freely redistributable software.  You may redistribute
 it and/or modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation.  The GPL is included in 
+as published by the Free Software Foundation.  The GPL is included in
 this manual, @pxref{Copying}.
 
-This manual provides comprehensive documentation on how to install, 
-run, use, and extend GNU Octave.  Additional chapters describe how 
+This manual provides comprehensive documentation on how to install,
+run, use, and extend GNU Octave.  Additional chapters describe how
 to report bugs and help contribute code.
 
 This document corresponds to Octave version @value{VERSION}.
 
 @menu
 * Running Octave::
 * Simple Examples::
 * Conventions::
@@ -52,17 +52,17 @@ This document corresponds to Octave vers
 @section Running Octave
 
 On most systems, Octave is started with the shell command @samp{octave}.
 This, by default, starts the graphical user interface (GUI).  The central
 window in the GUI is the Octave command-line interface.  Octave displays
 an initial message and then a prompt indicating it is ready to accept
 input.  If you have chosen the traditional command-line interface only
 the command prompt appears.  In any case, you can immediately begin
-typing Octave commands. 
+typing Octave commands.
 
 If you get into trouble, you can usually interrupt Octave by typing
 @kbd{Control-C} (written @kbd{C-c} for short).  @kbd{C-c} gets
 its name from the fact that you type it by holding down @key{CTRL} and
 then pressing @key{c}.  Doing this will normally return you to Octave's
 prompt.
 
 @cindex exiting octave
@@ -81,22 +81,22 @@ capabilities.
 
 If you are new to Octave, I recommend that you try these examples to
 begin learning Octave by using it.  Lines marked like so, @samp{octave:13>},
 are lines you type, ending each with a carriage return.  Octave will
 respond with an answer, or by displaying a graph.
 
 @subsection Elementary Calculations
 
-Octave can easily be used for basic numerical calculations.  Octave 
-knows about arithmetic operations (+,-,*,/), exponentiation (^), 
-natural logarithms/exponents (log, exp), and the trigonometric 
-functions (sin, cos, @dots{}).  Moreover, Octave calculations work 
-on real or imaginary numbers (i,j).  In addition, some mathematical 
-constants such as the base of the natural logarithm (e) and the ratio 
+Octave can easily be used for basic numerical calculations.  Octave
+knows about arithmetic operations (+,-,*,/), exponentiation (^),
+natural logarithms/exponents (log, exp), and the trigonometric
+functions (sin, cos, @dots{}).  Moreover, Octave calculations work
+on real or imaginary numbers (i,j).  In addition, some mathematical
+constants such as the base of the natural logarithm (e) and the ratio
 of a circle's circumference to its diameter (pi) are pre-defined.
 
 @noindent
 For example, to verify Euler's Identity,
 @tex
 $$e^{\imath\pi} = -1$$
 @end tex
 @ifnottex
@@ -104,49 +104,49 @@ For example, to verify Euler's Identity,
 
  i*pi
 e     = -1
 @end display
 @end ifnottex
 
 @noindent
 type the following which will evaluate to @code{-1} within the
-tolerance of the calculation. 
+tolerance of the calculation.
 
 @example
 octave:1> exp (i*pi)
 @end example
 
 @subsection Creating a Matrix
 
-Vectors and matrices are the basic building blocks for numerical analysis.  
+Vectors and matrices are the basic building blocks for numerical analysis.
 To create a new matrix and store it in a variable so that you can
 refer to it later, type the command
 
 @example
 octave:1> A = [ 1, 1, 2; 3, 5, 8; 13, 21, 34 ]
 @end example
 
 @noindent
-Octave will respond by printing the matrix in neatly aligned columns.  
-Octave uses a comma or space to separate entries in a row, and a 
-semicolon or carriage return to separate one row from the next.  
+Octave will respond by printing the matrix in neatly aligned columns.
+Octave uses a comma or space to separate entries in a row, and a
+semicolon or carriage return to separate one row from the next.
 Ending a command with a semicolon tells Octave not to print the result
 of the command.  For example,
 
 @example
 octave:2> B = rand (3, 2);
 @end example
 
 @noindent
 will create a 3 row, 2 column matrix with each element set to a random
 value between zero and one.
 
 To display the value of a variable, simply type the name of the
-variable at the prompt.  For example, to display the value stored in the 
+variable at the prompt.  For example, to display the value stored in the
 matrix @code{B}, type the command
 
 @example
 octave:3> B
 @end example
 
 @subsection Matrix Arithmetic
 
@@ -197,33 +197,33 @@ This is conceptually equivalent to
 @ifnottex
 @code{inv (a) * b},
 @end ifnottex
 but avoids computing the inverse of a matrix directly.
 
 If the coefficient matrix is singular, Octave will print a warning
 message and compute a minimum norm solution.
 
-A simple example comes from chemistry and the need to obtain balanced 
-chemical equations.  Consider the burning of hydrogen and oxygen to 
+A simple example comes from chemistry and the need to obtain balanced
+chemical equations.  Consider the burning of hydrogen and oxygen to
 produce water.
 @tex
 $$ {\rm H_{2}} + {\rm O_{2}} \rightarrow {\rm H_{2}O} $$
 @end tex
 @ifnottex
 
 @example
 H2 + O2 --> H2O
 @end example
 
 @end ifnottex
 @noindent
-The equation above is not accurate.  The Law of Conservation of Mass requires 
-that the number of molecules of each type balance on the left- and right-hand 
-sides of the equation.  Writing the variable overall reaction with 
+The equation above is not accurate.  The Law of Conservation of Mass requires
+that the number of molecules of each type balance on the left- and right-hand
+sides of the equation.  Writing the variable overall reaction with
 individual equations for hydrogen and oxygen one finds:
 @tex
 \vbox{
 $$ x_{1}{\rm H_{2}} + x_{2}{\rm O_{2}} \rightarrow {\rm H_{2}O} $$
 $$ {\rm H:}\quad 2x_{1} + 0x_{2} \rightarrow 2 $$
 $$ {\rm O:}\quad 0x_{1} + 2x_{2} \rightarrow 1 $$
 }
 @end tex
@@ -289,17 +289,17 @@ This is straightforward, and may be acco
 function body directly on the command line.  For example, the following
 commands define the right-hand side function for an interesting pair of
 nonlinear differential equations.  Note that while you are entering a
 function, Octave responds with a different prompt, to indicate that it
 is waiting for you to complete your input.
 
 @example
 @group
-octave:1> function xdot = f (x, t) 
+octave:1> function xdot = f (x, t)
 >
 >  r = 0.25;
 >  k = 1.4;
 >  a = 1.5;
 >  b = 0.16;
 >  c = 0.9;
 >  d = 0.8;
 >
@@ -436,19 +436,19 @@ manual.  You may want to skip this secti
 
 @node Fonts
 @subsection Fonts
 @cindex documentation fonts
 
 Examples of Octave code appear in this font or form: @code{svd (a)}.
 Names that represent variables or function arguments appear
 in this font or form: @var{first-number}.  Commands that you type at the
-shell prompt appear in this font or form: @samp{octave --no-init-file}.  
-Commands that you type at the Octave prompt sometimes appear in this font 
-or form: @kbd{foo --bar --baz}.  Specific keys on your keyboard appear 
+shell prompt appear in this font or form: @samp{octave --no-init-file}.
+Commands that you type at the Octave prompt sometimes appear in this font
+or form: @kbd{foo --bar --baz}.  Specific keys on your keyboard appear
 in this font or form: @key{ANY}.
 
 @node Evaluation Notation
 @subsection Evaluation Notation
 @cindex evaluation notation
 @cindex documentation notation
 
 In the examples in this manual, results from expressions that you
@@ -503,19 +503,19 @@ rot90 ([1, 2; 3, 4], 7)
 @end group
 @end example
 
 @node Printing Notation
 @subsection Printing Notation
 @cindex printing notation
 
 Many of the examples in this manual print text when they are
-evaluated.  In this manual the printed text resulting from an example 
-is indicated by @samp{@print{}}.  The value that is returned by 
-evaluating the expression is displayed with @samp{@result{}} 
+evaluated.  In this manual the printed text resulting from an example
+is indicated by @samp{@print{}}.  The value that is returned by
+evaluating the expression is displayed with @samp{@result{}}
 (@code{1} in the next example) and follows on a separate line.
 
 @example
 @group
 printf ("foo %s\n", "bar")
      @print{} foo bar
      @result{} 1
 @end group
@@ -535,17 +535,17 @@ fieldnames ([1, 2; 3, 4])
 error: fieldnames: Invalid input argument
 @end group
 @end example
 
 @node Format of Descriptions
 @subsection Format of Descriptions
 @cindex description format
 
-Functions and commands are described in this manual in a 
+Functions and commands are described in this manual in a
 uniform format.  The first line of a description contains the name of
 the item followed by its arguments, if any.
 @ifnottex
 The category---function, command, or whatever---appears at the
 beginning of the line.
 @end ifnottex
 @iftex
 The category---function, command, or whatever---is printed next to the
diff --git a/doc/interpreter/io.txi b/doc/interpreter/io.txi
--- a/doc/interpreter/io.txi
+++ b/doc/interpreter/io.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Input and Output
 @chapter Input and Output
 
 Octave supports several ways of reading and writing data to or from the
@@ -164,17 +164,17 @@ save myfile.mat A
 Once one or more variables have been saved to a file, they can be
 read into memory using the @code{load} command.
 
 @example
 @group
 load myfile.mat
 A
      @print{} A =
-     @print{} 
+     @print{}
      @print{}    1   2   3
      @print{}    4   5   6
      @print{}    7   8   9
 @end group
 @end example
 
 @DOCSTRING(save)
 
@@ -512,38 +512,38 @@ is a flag, @samp{10} specifies the field
 the conversion style.  (This particular type specifier says to print a
 numeric argument in decimal notation, with a minimum of 8 digits
 left-justified in a field at least 10 characters wide.)
 
 In more detail, output conversion specifications consist of an
 initial @samp{%} character followed in sequence by:
 
 @itemize @bullet
-@item 
+@item
 Zero or more @dfn{flag characters} that modify the normal behavior of
 the conversion specification.
 @cindex flag character (@code{printf})
 
-@item 
+@item
 An optional decimal integer specifying the @dfn{minimum field width}.
 If the normal conversion produces fewer characters than this, the field
 is padded with spaces to the specified width.  This is a @emph{minimum}
 value; if the normal conversion produces more characters than this, the
 field is @emph{not} truncated.  Normally, the output is right-justified
 within the field.
 @cindex minimum field width (@code{printf})
 
 You can also specify a field width of @samp{*}.  This means that the
 next argument in the argument list (before the actual value to be
 printed) is used as the field width.  The value is rounded to the
 nearest integer.  If the value is negative, this means to set the
 @samp{-} flag (see below) and to use the absolute value as the field
 width.
 
-@item 
+@item
 An optional @dfn{precision} to specify the number of digits to be
 written for the numeric conversions.  If the precision is specified, it
 consists of a period (@samp{.}) followed optionally by a decimal integer
 (which defaults to zero if omitted).
 @cindex precision (@code{printf})
 
 You can also specify a precision of @samp{*}.  This means that the next
 argument in the argument list (before the actual value to be printed) is
@@ -554,17 +554,17 @@ if it is negative.
 An optional @dfn{type modifier character}.  This character is ignored by
 Octave's @code{printf} function, but is recognized to provide
 compatibility with the C language @code{printf}.
 
 @item
 A character that specifies the conversion to be applied.
 @end itemize
 
-The exact options that are permitted and how they are interpreted vary 
+The exact options that are permitted and how they are interpreted vary
 between the different conversion specifiers.  See the descriptions of the
 individual conversions for information about the particular options that
 they use.
 
 @node Table of Output Conversions
 @subsection Table of Output Conversions
 @cindex output conversions, for @code{printf}
 
@@ -741,17 +741,17 @@ If the precision is @code{0} or not spec
 printed cannot be expressed precisely in the specified number of digits,
 the value is rounded to the nearest number that fits.
 
 @node Other Output Conversions
 @subsection Other Output Conversions
 
 This section describes miscellaneous conversions for @code{printf}.
 
-The @samp{%c} conversion prints a single character.  The @samp{-} 
+The @samp{%c} conversion prints a single character.  The @samp{-}
 flag can be used to specify left-justification in the field, but no
 other flags are defined, and no precision or type modifier can be given.
 For example:
 
 @example
 printf ("%c%c%c%c%c", "h", "e", "l", "l", "o");
 @end example
 
@@ -864,17 +864,17 @@ are explicitly documented.
 An optional type modifier character.  This character is ignored by
 Octave's @code{scanf} function, but is recognized to provide
 compatibility with the C language @code{scanf}.
 
 @item
 A character that specifies the conversion to be applied.
 @end itemize
 
-The exact options that are permitted and how they are interpreted vary 
+The exact options that are permitted and how they are interpreted vary
 between the different conversion specifiers.  See the descriptions of the
 individual conversions for information about the particular options that
 they allow.
 
 @node Table of Input Conversions
 @subsection Table of Input Conversions
 @cindex input conversions, for @code{scanf}
 
@@ -952,17 +952,17 @@ both permit either uppercase or lowercas
 
 Unlike the C language @code{scanf}, Octave ignores the @samp{h},
 @samp{l}, and @samp{L} modifiers.
 
 @node String Input Conversions
 @subsection String Input Conversions
 
 This section describes the @code{scanf} input conversions for reading
-string and character values: @samp{%s} and @samp{%c}.  
+string and character values: @samp{%s} and @samp{%c}.
 
 The @samp{%c} conversion is the simplest: it matches a fixed number of
 characters, always.  The maximum field with says how many characters to
 read; if you don't specify the maximum, the default is 1.  This
 conversion does not skip over initial whitespace characters.  It reads
 precisely the next @var{n} characters, and fails if it cannot get that
 many.
 
diff --git a/doc/interpreter/java.txi b/doc/interpreter/java.txi
--- a/doc/interpreter/java.txi
+++ b/doc/interpreter/java.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 2010-2013 Martin Hepperle
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Java Interface
 @chapter Java Interface
 
 @cindex using Octave with Java
@@ -229,19 +229,19 @@ Therefore it may be necessary to detect 
 functions.  The following function can be used to detect the environment.  Due
 to the persistent variable it can be called repeatedly without a heavy
 performance hit.
 
 Example:
 
 @example
 @group
-%% 
+%%
 %% Return: true if the environment is Octave.
-%% 
+%%
 function retval = isOctave
   persistent cacheval;  % speeds up repeated calls
 
   if isempty (cacheval)
     cacheval = (exist ("OCTAVE_VERSION", "builtin") > 0);
   end
 
   retval = cacheval;
@@ -295,17 +295,17 @@ was started from).  If such a file is fo
 'per Octave invocation' basis.
 
 @item Next, Octave searches in the user's home directory.  If a file
 @file{javaclasspath.txt} exists here, its contents are appended to the static
 classpath (if any).  Thus, it is possible to build an initial static classpath
 on a 'per user' basis.
 
 @item Finally, Octave looks for a next occurrence of file
-@file{javaclasspath.txt} in the m-files directory where Octave Java functions 
+@file{javaclasspath.txt} in the m-files directory where Octave Java functions
 live.  This is where @file{javaclasspath.m} resides, usually something like
 @file{@w{@env{OCTAVE_HOME}}/share/octave/@w{@env{OCTAVE_VERSION}}/m/java/}.  You can
 find this directory by executing the command
 
 @example
 which javaclasspath
 @end example
 
diff --git a/doc/interpreter/linalg.txi b/doc/interpreter/linalg.txi
--- a/doc/interpreter/linalg.txi
+++ b/doc/interpreter/linalg.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Linear Algebra
 @chapter Linear Algebra
 @cindex linear algebra
 
@@ -65,17 +65,17 @@ backward substitution using the @sc{lapa
 @c @item If the matrix is a upper triangular matrix with column permutations
 @c or lower triangular matrix with row permutations, perform a forward or
 @c backward substitution, and goto 5.
 
 @item If the matrix is square, Hermitian with a real positive diagonal,
 attempt Cholesky@tie{}factorization using the @sc{lapack} xPOTRF function.
 
 @item If the Cholesky@tie{}factorization failed or the matrix is not
-Hermitian with a real positive diagonal, and the matrix is square, factorize 
+Hermitian with a real positive diagonal, and the matrix is square, factorize
 using the @sc{lapack} xGETRF function.
 
 @item If the matrix is not square, or any of the previous solvers flags
 a singular or near singular matrix, find a least squares solution using
 the @sc{lapack} xGELSD function.
 @end enumerate
 
 The user can force the type of the matrix with the @code{matrix_type}
diff --git a/doc/interpreter/macros.texi b/doc/interpreter/macros.texi
--- a/doc/interpreter/macros.texi
+++ b/doc/interpreter/macros.texi
@@ -1,36 +1,36 @@
 @c Copyright (C) 2012-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @c The following macro marks words that aspell should ignore during
 @c spellchecking.  Within Texinfo it has no effect as it merely replaces
 @c the macro call with the argument itself.
 
 @macro nospell {arg}
 \arg\
 @end macro
 
 @c The following macro works around the Info/plain text expansion of @code{XXX}
-@c which is `XXX'.  This looks particularly bad when the macro body is 
+@c which is `XXX'.  This looks particularly bad when the macro body is
 @c single or double-quoted text, such as a property value `"position"'
 @ifinfo
 @rmacro qcode{arg}
 \arg\
 @end rmacro
 @end ifinfo
 @ifnotinfo
 @rmacro qcode{arg}
@@ -41,17 +41,17 @@
 @c The following macro is used for the on-line help system, but we don't
 @c want lots of `See also: foo, bar, and baz' strings cluttering the
 @c printed manual (that information should be in the supporting text for
 @c each group of functions and variables).
 @c
 @c Implementation Note:
 @c For TeX, @vskip produces a nice separation.
 @c For Texinfo, '@sp 1' should work, but in practice produces ugly results
-@c for HTML.  We use a simple blank line to produce the correct behavior. 
+@c for HTML.  We use a simple blank line to produce the correct behavior.
 
 @macro seealso {args}
 @iftex
 @vskip 2pt
 @end iftex
 @ifnottex
 
 @end ifnottex
diff --git a/doc/interpreter/matrix.txi b/doc/interpreter/matrix.txi
--- a/doc/interpreter/matrix.txi
+++ b/doc/interpreter/matrix.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Matrix Manipulation
 @chapter Matrix Manipulation
 
 There are a number of functions available for checking to see if the
diff --git a/doc/interpreter/munge-texi.pl b/doc/interpreter/munge-texi.pl
--- a/doc/interpreter/munge-texi.pl
+++ b/doc/interpreter/munge-texi.pl
@@ -18,18 +18,18 @@ foreach $DOCSTRING_file (@ARGV)
 {
   open (DOCFH, $DOCSTRING_file) or die "Unable to open $DOCSTRING_file\n";
 
   # Skip comments
   while (defined ($_ = <DOCFH>) and /$comment_line/o) {;}
 
   # Validate DOCSTRING file format
   die "invalid doc file format\n" if (! /$doc_delim/o);
-  
-  do 
+
+  do
   {
     s/\s*$//;   # strip EOL character(s)
     $symbol = substr ($_,1);
     $docstring = extract_docstring ();
     if ($help_text{$symbol})
     {
       warn "ignoring duplicate entry for $symbol\n";
     }
@@ -66,58 +66,58 @@ TXI_LINE: while (<STDIN>)
 
     next TXI_LINE;
   }
   if (/^\s*\@EXAMPLEFILE\((\S+)\)/)
   {
     $fname = "$top_srcdir/examples/$1";
     print '@verbatim',"\n";
     open (EXAMPFH, $fname) or die "unable to open example file $fname\n";
-    while (<EXAMPFH>) 
-    { 
+    while (<EXAMPFH>)
+    {
       print $_;
       print "\n" if (eof and substr ($_, -1) ne "\n");
     }
     close (EXAMPFH);
     print '@end verbatim',"\n\n";
 
     next TXI_LINE;
   }
 
   # pass ordinary lines straight through to output
   print $_;
 }
 
 
 ################################################################################
-# Subroutines 
+# Subroutines
 ################################################################################
 sub extract_docstring
 {
   my ($docstring, $arg_list, $func_list, $repl, $rest_of_line);
-  
+
   while (defined ($_ = <DOCFH>) and ! /$doc_delim/o)
   {
     # expand any @seealso references
     if (m'^@seealso{')
     {
       # Join multiple lines until full macro body found
       while (! /}/m) { $_ .= <DOCFH>; }
 
       ($arg_list, $rest_of_line) = m'^@seealso{(.*)}(.*)?'s;
-     
+
       $func_list = $arg_list;
       $func_list =~ s/\s+//gs;
       $repl = "";
       foreach $func (split (/,/, $func_list))
       {
         $func =~ s/^@/@@/;   # Texinfo uses @@ to produce '@'
         $repl .= "\@ref{XREF$func,,$func}, ";
       }
-      substr($repl,-2) = "";   # Remove last ', ' 
+      substr($repl,-2) = "";   # Remove last ', '
       $_ = "\@seealso{$repl}$rest_of_line";
     }
 
     $docstring .= $_;
   }
 
   return $docstring;
 }
diff --git a/doc/interpreter/nonlin.txi b/doc/interpreter/nonlin.txi
--- a/doc/interpreter/nonlin.txi
+++ b/doc/interpreter/nonlin.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Nonlinear Equations
 @chapter Nonlinear Equations
 @cindex nonlinear equations
 @cindex equations, nonlinear
@@ -110,17 +110,17 @@ info = 1
 @end group
 @end example
 
 @noindent
 A value of @code{info = 1} indicates that the solution has converged.
 
 When no Jacobian is supplied (as in the example above) it is approximated
 numerically.  This requires more function evaluations, and hence is
-less efficient.  In the example above we could compute the Jacobian 
+less efficient.  In the example above we could compute the Jacobian
 analytically as
 
 @iftex
 @tex
 $$
 \left[\matrix{ {\partial f_1 \over \partial x_1} &
                {\partial f_1 \over \partial x_2} \cr
                {\partial f_2 \over \partial x_1} &
diff --git a/doc/interpreter/numbers.txi b/doc/interpreter/numbers.txi
--- a/doc/interpreter/numbers.txi
+++ b/doc/interpreter/numbers.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Numeric Data Types
 @chapter Numeric Data Types
 @cindex numeric constant
 @cindex numeric value
@@ -463,17 +463,17 @@ precision answers.  A single precision v
 
 @DOCSTRING(single)
 
 for example:
 
 @example
 @group
 sngl = single (rand (2, 2))
-     @result{} sngl = 
+     @result{} sngl =
         0.37569   0.92982
         0.11962   0.50876
 class (sngl)
     @result{} single
 @end group
 @end example
 
 Many functions can also return single precision values directly.  For
@@ -742,17 +742,17 @@ single (1) + 1
 @end group
 @end example
 
 @noindent
 returns a single precision value.  The mixed operations that are valid
 and their returned data types are
 
 @multitable @columnfractions .2 .3 .3 .2
-@headitem @tab Mixed Operation @tab Result @tab 
+@headitem @tab Mixed Operation @tab Result @tab
 @item @tab double OP single @tab single @tab
 @item @tab double OP integer @tab integer @tab
 @item @tab double OP char @tab double @tab
 @item @tab double OP logical @tab double @tab
 @item @tab single OP integer @tab integer @tab
 @item @tab single OP char @tab single @tab
 @item @tab single OP logical @tab single @tab
 @end multitable
@@ -777,17 +777,17 @@ changed.  For example,
 x = ones (2, 2);
 x(1, 1) = single (2)
    @result{} x = 2   1
           1   1
 @end group
 @end example
 
 @noindent
-where @code{x} remains of the double precision type. 
+where @code{x} remains of the double precision type.
 
 @node Predicates for Numeric Objects
 @section Predicates for Numeric Objects
 
 Since the type of a variable may change during the execution of a
 program, it can be necessary to do type checking at run-time.  Doing this
 also allows you to change the behavior of a function depending on the
 type of the input.  As an example, this naive implementation of @code{abs}
diff --git a/doc/interpreter/obsolete.txi b/doc/interpreter/obsolete.txi
--- a/doc/interpreter/obsolete.txi
+++ b/doc/interpreter/obsolete.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 2010-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @c The text of this file appears in the file BUGS in the Octave
 @c distribution, as well as in the Octave manual.
 
 @node Obsolete Functions
diff --git a/doc/interpreter/octave-config.1 b/doc/interpreter/octave-config.1
--- a/doc/interpreter/octave-config.1
+++ b/doc/interpreter/octave-config.1
@@ -66,20 +66,20 @@ Recognized variables are:
    LIBDIR                  OCTLIBDIR
    LIBEXECDIR              PREFIX
    LOCALAPIARCHLIBDIR      STARTUPFILEDIR
    LOCALAPIFCNFILEDIR      VERSION
 .Ve
 .RE
 .TP
 .B \-v\fR,\fB \-\-version
-Display the version number of 
+Display the version number of
 .BR octave (1).
 .TP
 \fB\-h\fP, \fB\-?\fP, \fB\-\-help\fP
 Print help message.
 .SH AUTHOR
 John W. Eaton <jwe@octave.org>
 
-This manual page was contributed by Dirk Eddelbuettel <edd@debian.org> 
+This manual page was contributed by Dirk Eddelbuettel <edd@debian.org>
 for the Debian GNU/Linux distribution but may be used by others.
 .SH "SEE ALSO"
 octave (1).
diff --git a/doc/interpreter/octave.texi b/doc/interpreter/octave.texi
--- a/doc/interpreter/octave.texi
+++ b/doc/interpreter/octave.texi
@@ -1,22 +1,22 @@
 % Copyright (C) 1996-2013 John W. Eaton
 %
 % This file is part of Octave.
 %
 % Octave is free software; you can redistribute it and/or modify it
 % under the terms of the GNU General Public License as published by the
 % Free Software Foundation; either version 3 of the License, or (at
 % your option) any later version.
-% 
+%
 % Octave is distributed in the hope that it will be useful, but WITHOUT
 % ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 % FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 % for more details.
-% 
+%
 % You should have received a copy of the GNU General Public License
 % along with Octave; see the file COPYING.  If not, see
 % <http://www.gnu.org/licenses/>.
 
 \input texinfo
 
 @setfilename octave.info
 
@@ -95,18 +95,18 @@ modified versions.
 @multitable @columnfractions 0.4 0.025 0.65
 @item
 @flushright @image{octave_logo,2.1in}
 @end flushright
 @tab
 @c this is a spacer column
 @tab
 @sp 8
-@titlefont{Free Your Numbers} 
-@end multitable 
+@titlefont{Free Your Numbers}
+@end multitable
 @author John W. Eaton
 @author David Bateman
 @author S@o{}ren Hauberg
 @author Rik Wehbring
 @page
 @vskip 0pt plus 1filll
 Copyright @copyright{} 1996, 1997, 1999, 2000, 2001, 2002, 2005, 2006,
 2007, 2011, 2013 John W. Eaton.
@@ -178,18 +178,18 @@ It corresponds to GNU Octave version @va
 * Interpolation::
 * Geometry::
 * Signal Processing::
 * Image Processing::
 * Audio Processing::
 * Object Oriented Programming::
 * GUI Development::
 * System Utilities::
-* Java Interface:: 
-* Packages:: 
+* Java Interface::
+* Packages::
 * External Code Interface::
 * Test and Demo Functions::
 * Tips and Standards::
 * Contributing Guidelines::
 * Obsolete Functions::
 * Trouble::                     If you have trouble installing Octave.
 * Installation::                How to configure, compile and install Octave.
 * Emacs Octave Support::
@@ -941,30 +941,30 @@ Grammar and Parser
 @include package.texi
 
 @c maybe add again later, if anyone every writes any really interesting
 @c fun stuff for Octave.
 @c
 @c @include amuse.texi
 
 @c ------------------------------------------------------------------------
-@c Appendices start here. 
+@c Appendices start here.
 
 @include external.texi
 @include testfun.texi
 @include tips.texi
 @include contrib.texi
 @include obsolete.texi
 @include bugs.texi
 @include install.texi
 @include emacs.texi
 @include grammar.texi
 @include gpl.texi
 
 @c ------------------------------------------------------------------------
-@c Indices start here. 
+@c Indices start here.
 
 @include cp-idx.texi
 @c @include vr-idx.texi
 @include fn-idx.texi
 @include op-idx.texi
 
 @bye
diff --git a/doc/interpreter/oop.txi b/doc/interpreter/oop.txi
--- a/doc/interpreter/oop.txi
+++ b/doc/interpreter/oop.txi
@@ -2,22 +2,22 @@
 @c Copyright (C) 2009 VZLU Prague
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @c FIXME
 @c For now can't include "@" character in the path name, and so name
 @c the example directory without the "@"!!
 
@@ -177,31 +177,31 @@ An example of a display method for the p
 @example
 @EXAMPLEFILE(@polynomial/display.m)
 @end example
 
 @noindent
 Note that in the display method, it makes sense to start the method
 with the line @code{fprintf ("%s =", inputname (1))} to be consistent
 with the rest of Octave and print the variable name to be displayed
-when displaying the class. 
+when displaying the class.
 
 To be consistent with the Octave graphic handle classes, a class
 should also define the @code{get} and @code{set} methods.  The
 @code{get} method should accept one or two arguments, and given one
 argument of the appropriate class it should return a structure with
 all of the properties of the class.  For example:
 
 @example
 @EXAMPLEFILE(@polynomial/get.m)
 @end example
 
 @noindent
 Similarly, the @code{set} method should taken as its first argument an
-object to modify, and then take property/value pairs to be modified. 
+object to modify, and then take property/value pairs to be modified.
 
 @example
 @EXAMPLEFILE(@polynomial/set.m)
 @end example
 
 @noindent
 Note that as Octave does not implement pass by reference, than the
 modified object is the return value of the @code{set} method and it
@@ -252,62 +252,62 @@ fields are reinserted into the user obje
 @menu
 * Defining Indexing And Indexed Assignment::
 * Indexed Assignment Optimization::
 @end menu
 
 @node Defining Indexing And Indexed Assignment
 @subsection Defining Indexing And Indexed Assignment
 
-Objects can be indexed with parentheses, either like 
+Objects can be indexed with parentheses, either like
 @code{@var{a} (@var{idx})} or like @code{@var{a} @{@var{idx}@}}, or even
 like @code{@var{a} (@var{idx}).@var{field}}.  However, it is up to the user
 to decide what this indexing actually means.  In the case of our polynomial
-class @code{@var{p} (@var{n})} might mean either the coefficient of the 
-@var{n}-th power of the polynomial, or it might be the evaluation of the 
-polynomial at @var{n}.  The meaning of this subscripted referencing is 
+class @code{@var{p} (@var{n})} might mean either the coefficient of the
+@var{n}-th power of the polynomial, or it might be the evaluation of the
+polynomial at @var{n}.  The meaning of this subscripted referencing is
 determined by the @code{subsref} method.
 
 @DOCSTRING(subsref)
 
 For example we might decide that indexing with @qcode{"()"} evaluates the
 polynomial and indexing with @qcode{"@{@}"} returns the @var{n}-th coefficient
 (of @var{n}-th power).  In this case the @code{subsref} method of our
 polynomial class might look like
 
 @example
 @EXAMPLEFILE(@polynomial/subsref.m)
 @end example
 
-The equivalent functionality for subscripted assignments uses the 
+The equivalent functionality for subscripted assignments uses the
 @code{subsasgn} method.
 
 @DOCSTRING(subsasgn)
 
 @DOCSTRING(optimize_subsasgn_calls)
 
 Note that the @code{subsref} and @code{subsasgn} methods always receive the
 whole index chain, while they usually handle only the first element.  It is the
 responsibility of these methods to handle the rest of the chain (if needed),
 usually by forwarding it again to @code{subsref} or @code{subsasgn}.
 
 If you wish to use the @code{end} keyword in subscripted expressions
-of an object, then the user needs to define the @code{end} method for 
+of an object, then the user needs to define the @code{end} method for
 the class.  For example, the @code{end} method for our polynomial class might
 look like
 
 @example
 @group
 @EXAMPLEFILE(@polynomial/end.m)
 @end group
 @end example
 
 @noindent
 which is a fairly generic @code{end} method that has a behavior similar to
-the @code{end} keyword for Octave Array classes.  It can then be used as 
+the @code{end} keyword for Octave Array classes.  It can then be used as
 follows:
 
 @example
 @group
 p = polynomial ([1,2,3,4]);
 p(end-1)
   @result{} 3
 @end group
@@ -321,17 +321,17 @@ and this is controlled with the @code{su
 Finally, objects can equally be used like ranges, using the @code{colon}
 method
 
 @DOCSTRING(colon)
 
 @node Indexed Assignment Optimization
 @subsection Indexed Assignment Optimization
 
-Octave's ubiquitous lazily-copied pass-by-value semantics implies 
+Octave's ubiquitous lazily-copied pass-by-value semantics implies
 a problem for performance of user-defined subsasgn methods.  Imagine
 a call to subsasgn:
 
 @example
 @group
   ss = substruct ("()",@{1@});
   x = subsasgn (x, ss, 1);
 @end group
@@ -345,17 +345,17 @@ and the corresponding method looking lik
   function x = subsasgn (x, ss, val)
     @dots{}
     x.myfield (ss.subs@{1@}) = val;
   endfunction
 @end group
 @end example
 
 The problem is that on entry to the subsasgn method, @code{x} is still
-referenced from the caller's scope, which means that the method will 
+referenced from the caller's scope, which means that the method will
 first need to unshare (copy) @code{x} and @code{x.myfield} before performing
 the assignment.  Upon completing the call, unless an error occurs,
 the result is immediately assigned to @code{x} in the caller's scope,
 so that the previous value of @code{x.myfield} is forgotten.  Hence, the
 Octave language implies a copy of N elements (N being the size of
 @code{x.myfield}), where modifying just a single element would actually
 suffice, i.e., degrades a constant-time operation to linear-time one.
 This may be a real problem for user classes that intrinsically store large
@@ -431,18 +431,18 @@ polynomial class is the @code{plot} func
 @end group
 @end example
 
 @noindent
 which allows polynomials to be plotted in the domain near the region
 of the roots of the polynomial.
 
 Functions that are of particular interest to be overloaded are the class
-conversion functions such as @code{double}.  Overloading these functions 
-allows the @code{cast} function to work with the user class and can aid 
+conversion functions such as @code{double}.  Overloading these functions
+allows the @code{cast} function to work with the user class and can aid
 in the use of methods of other classes with the user class.  An example
 @code{double} function for our polynomial class might look like.
 
 @example
 @group
 @EXAMPLEFILE(@polynomial/double.m)
 @end group
 @end example
@@ -481,17 +481,17 @@ in the use of methods of other classes w
 @cindex relational operators
 @cindex subtraction
 @cindex tests for equality
 @cindex transpose
 @cindex transpose, complex-conjugate
 @cindex unary minus
 
 @c Need at least one plaintext sentence here between the @node and @float
-@c table below or the two will overlap due to a bug in Texinfo. 
+@c table below or the two will overlap due to a bug in Texinfo.
 @c This is not our fault; this *is* a ridiculous kluge.
 The following table shows, for each built-in numerical operation, the
 corresponding function name to use when providing an overloaded method for a
 user class.
 
 @float Table,tab:overload_ops
 @opindex +
 @opindex -
@@ -515,20 +515,20 @@ user class.
 @opindex !
 @opindex '
 @opindex .'
 @opindex :
 @opindex <
 
 @tex
 \vskip 6pt
-{\hbox to \hsize {\hfill\vbox{\offinterlineskip \tabskip=0pt 
+{\hbox to \hsize {\hfill\vbox{\offinterlineskip \tabskip=0pt
 \halign{
 \vrule height2.0ex depth1.ex width 0.6pt #\tabskip=0.3em &
-# \hfil & \vrule # & # \hfil & \vrule # & # \hfil & # \vrule 
+# \hfil & \vrule # & # \hfil & \vrule # & # \hfil & # \vrule
 width 0.6pt \tabskip=0pt\cr
 \noalign{\hrule height 0.6pt}
 & Operation && Method && Description &\cr
 \noalign{\hrule}
 & $a + b$ && plus (a, b) && Binary addition operator&\cr
 & $a - b$ && minus (a, b) && Binary subtraction operator&\cr
 & $+ a$ && uplus (a) && Unary addition operator&\cr
 & $- a$ && uminus (a) && Unary subtraction operator&\cr
@@ -636,17 +636,17 @@ the above is of the type @qcode{"polynom
 @code{superiorto} function in the class constructor.  In particular our
 polynomial class constructor would be modified to be
 
 @example
 @EXAMPLEFILE(@polynomial/polynomial_superiorto.m)
 @end example
 
 Note that user classes always have higher precedence than built-in
-Octave types.  So in fact marking our polynomial class higher than the 
+Octave types.  So in fact marking our polynomial class higher than the
 @qcode{"double"} class is in fact not necessary.
 
 When faced with two objects that have the same precedence, Octave will use the
 method of the object that appears first on the list of arguments.
 
 @node Inheritance and Aggregation
 @section Inheritance and Aggregation
 
@@ -725,17 +725,17 @@ octave:1> f = FIRfilter (polynomial ([1 
 f.polynomial = 0.333333 + 0.333333 * X + 0.333333 * X ^ 2
 octave:2> class (f)
 ans = FIRfilter
 octave:3> isa (f,"FIRfilter")
 ans =  1
 octave:4> isa (f,"polynomial")
 ans =  1
 octave:5> struct (f)
-ans = 
+ans =
 @{
 polynomial = 0.333333 + 0.333333 * X + 0.333333 * X ^ 2
 @}
 @end group
 @end example
 
 We only need to define a method to actually process data with our
 filter and our class is usable.  It is also useful to provide a means
diff --git a/doc/interpreter/op-idx.txi b/doc/interpreter/op-idx.txi
--- a/doc/interpreter/op-idx.txi
+++ b/doc/interpreter/op-idx.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Operator Index
 @unnumbered Operator Index
 
 @printindex op
diff --git a/doc/interpreter/optim.txi b/doc/interpreter/optim.txi
--- a/doc/interpreter/optim.txi
+++ b/doc/interpreter/optim.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Optimization
 @chapter Optimization
 
 Octave comes with support for solving various kinds of optimization
diff --git a/doc/interpreter/package.txi b/doc/interpreter/package.txi
--- a/doc/interpreter/package.txi
+++ b/doc/interpreter/package.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 2007-2013 Sren Hauberg
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Packages
 @chapter Packages
 
 Since Octave is Free Software users are encouraged to share their
@@ -108,18 +108,18 @@ it may not function correctly.  Because 
 to disable dependency checking.
 
 @DOCSTRING(pkg)
 
 @node Using Packages
 @section Using Packages
 
 By default installed packages are not available from the Octave prompt,
-but it is possible to control this using the @code{pkg load} and 
-@code{pkg unload} commands.  The functions from a package can be 
+but it is possible to control this using the @code{pkg load} and
+@code{pkg unload} commands.  The functions from a package can be
 added to the Octave path by typing
 
 @example
 pkg load package_name
 @end example
 
 @noindent
 where @code{package_name} is the name of the package to be added
@@ -133,18 +133,18 @@ pkg unload package_name
 @end example
 
 @node Administrating Packages
 @section Administrating Packages
 
 On UNIX-like systems it is possible to make both per-user and
 system-wide installations of a package.  If the user performing the
 installation is @code{root} the packages will be installed in a
-system-wide directory that defaults to 
-@file{OCTAVE_HOME/share/octave/packages/}.  If the user is not 
+system-wide directory that defaults to
+@file{OCTAVE_HOME/share/octave/packages/}.  If the user is not
 @code{root} the default installation directory is
 @file{~/octave/}.  Packages will be installed in a subdirectory of the
 installation directory that will be named after the package.  It is
 possible to change the installation directory by using the
 @code{pkg prefix} command
 
 @example
 pkg prefix new_installation_directory
@@ -242,17 +242,17 @@ autoload ('bar', which ('foo'));
 directives.
 
 @cindex PKG_DEL
 @anchor{XREFPKG_DEL}
 @item package/PKG_DEL
 An optional file that includes commands that are run when the package
 is removed from the users path.  Note that @w{@code{PKG_DEL}} directives in
 the source code of the package will also be added to this file by the
-Octave package manager. 
+Octave package manager.
 @xref{PKG_ADD and PKG_DEL Directives}, for details on @w{@code{PKG_DEL}}
 directives.
 
 @item package/pre_install.m
 This is an optional function that is run prior to the installation of a
 package.  This function is called with a single argument, a struct with
 fields names after the data in the @file{DESCRIPTION}, and the paths where
 the package functions will be installed.
@@ -319,17 +319,17 @@ The @file{DESCRIPTION} file contains var
 package, such as its name, author, and version.  This file has a very
 simple format
 
 @itemize
 @item
 Lines starting with @samp{#} are comments.
 
 @item
-Lines starting with a blank character are continuations from the 
+Lines starting with a blank character are continuations from the
 previous line.
 
 @item
 Everything else is of the form @code{NameOfOption: ValueOfOption}.
 @end itemize
 
 @noindent
 The following is a simple example of a @file{DESCRIPTION} file
@@ -416,41 +416,41 @@ or newer).  This is optional since the f
 These are the external install dependencies of the package and are not
 checked by the package manager.  This is here as a hint to the
 distribution packager.  They follow the same conventions as the
 @code{Depends} keyword.
 
 @item BuildRequires
 These are the external build dependencies of the package and are not
 checked by the package manager.  This is here as a hint to the
-distribution packager.  They follow the same conventions as the 
+distribution packager.  They follow the same conventions as the
 @code{Depends} keyword.  Note that in general, packaging systems such
 as @code{rpm} or @code{deb} and autoprobe the install dependencies
 from the build dependencies, and therefore the often a
 @code{BuildRequires} dependency removes the need for a
 @code{SystemRequirements} dependency.
 
 @end table
 
 @noindent
-The developer is free to add additional arguments to the 
+The developer is free to add additional arguments to the
 @file{DESCRIPTION} file for their own purposes.  One further detail to
 aid the packager is that the @code{SystemRequirements} and
 @code{BuildRequires} keywords can have a distribution dependent section,
 and the automatic build process will use these.  An example of the
 format of this is
 
 @example
 BuildRequires: libtermcap-devel [Mandriva] libtermcap2-devel
 @end example
 
 @noindent
 where the first package name will be used as a default and if the
 RPMs are built on a Mandriva distribution, then the second package
-name will be used instead. 
+name will be used instead.
 
 @node The INDEX File
 @subsection The INDEX File
 
 The optional @file{INDEX} file provides a categorical view of the
 functions in the package.  This file has a very simple format
 
 @itemize
@@ -480,25 +480,25 @@ Category Name 1
  function1 function2 function3
  function4
 Category Name 2
  function2 function5
 @end group
 @end example
 
 If you wish to refer to a function that users might expect
-to find in your package but is not there, providing a work around or 
+to find in your package but is not there, providing a work around or
 pointing out that the function is available elsewhere, you can use:
 
 @example
 fn = workaround description
 @end example
 
 @noindent
-This workaround description will not appear when listing functions in the 
+This workaround description will not appear when listing functions in the
 package with @code{pkg describe} but they will be published
 in the HTML documentation online.
 Workaround descriptions can use any HTML markup, but
 keep in mind that it will be enclosed in a bold-italic environment.
 For the special case of:
 
 @example
 fn = use <code>alternate expression</code>
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -855,38 +855,38 @@ width 0.6pt \tabskip=0pt\cr
 \symtable{Arrows} {#}
 {& \hbox to \cola{$\backslash$leftarrow}      && $\leftarrow$
 && \hbox to \colb{$\backslash$Leftarrow}      && $\Leftarrow$
 && \hbox to \colc{$\backslash$rightarrow}     && $\rightarrow$      &\cr
 & $\backslash$Rightarrow      && $\Rightarrow$
 && $\backslash$leftrightarrow && $\leftrightarrow$
 && $\backslash$uparrow        && $\uparrow$         &\cr
 & $\backslash$downarrow       && $\downarrow$
-&&   && 
+&&   &&
 &&   &&       &\cr}
 \vskip12pt
 \symtable{Openings and Closings} {#}
 {& \hbox to \cola{$\backslash$lfloor   }    && $\lfloor$
 && \hbox to \colb{$\backslash$langle   }    && $\langle$
 && \hbox to \colc{$\backslash$lceil    }    && $\lceil$      &\cr
 & $\backslash$rfloor    && $\rfloor$
 && $\backslash$rangle   && $\rangle$
 && $\backslash$rceil    && $\rceil$      &\cr}
 \vskip12pt
 \symtable{Alternate Names} {#}
 {& \hbox to \cola{$\backslash$neq}   && $\neq$
-&& \hbox to \colb{}   && 
+&& \hbox to \colb{}   &&
 && \hbox to \colc{}   &&   &\cr}
 \vskip12pt
 \symtable{Other (not in Appendix F Tables)} {#}
 {& \hbox to \cola{$\backslash$ldots}     && $\ldots$
 && \hbox to \colb{$\backslash$0}         && $\oslash$
 && \hbox to \colc{$\backslash$copyright} && $\copyright$      &\cr
 & $\backslash$deg        && $^\circ$
-&&    &&  
+&&    &&
 &&    &&       &\cr}
 \vskip12pt
 \hskip36pt Table 15.1: Available special characters in \TeX\ mode (cont.)
 @end tex
 @end float
 
 A complete example showing the capabilities of the extended text is
 
diff --git a/doc/interpreter/poly.txi b/doc/interpreter/poly.txi
--- a/doc/interpreter/poly.txi
+++ b/doc/interpreter/poly.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Polynomial Manipulations
 @chapter Polynomial Manipulations
 
 In Octave, a polynomial is represented by its coefficients (arranged
diff --git a/doc/interpreter/preface.txi b/doc/interpreter/preface.txi
--- a/doc/interpreter/preface.txi
+++ b/doc/interpreter/preface.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @ifclear AUTHORSONLY
 @node Preface
 @unnumbered Preface
 @cindex contributors
@@ -52,18 +52,18 @@ Virtually everyone thinks that the name 
 music, but it is actually the name of one of John W. Eaton's former
 professors who wrote a famous textbook on chemical reaction engineering,
 and who was also well known for his ability to do quick `back of the
 envelope' calculations.  We hope that this software will make it
 possible for many people to do more ambitious computations just as
 easily.
 
 Everyone is encouraged to share this software with others under the
-terms of the GNU General Public License (@pxref{Copying}).  You are 
-also encouraged to help make Octave more useful by writing and 
+terms of the GNU General Public License (@pxref{Copying}).  You are
+also encouraged to help make Octave more useful by writing and
 contributing additional functions for it, and by reporting any problems
 you may have.
 
 @menu
 * Acknowledgements::
 * Citing Octave in Publications::
 * How You Can Contribute to Octave::
 * Distribution::
@@ -148,33 +148,33 @@ This project would not have been possibl
 in and to produce Octave.
 
 @node Citing Octave in Publications
 @unnumberedsec Citing Octave in Publications
 @cindex Citing Octave
 @cindex Citations
 
 In view of the many contributions made by numerous developers over many years
-it is common courtesy to cite Octave in publications when it has been used 
+it is common courtesy to cite Octave in publications when it has been used
 during the course of research or the preparation of figures.  The
 @code{citation} function can automatically generate a recommended citation
 text for Octave or any of its packages.  See the help text below on how to
 use @code{citation}.
 
 @DOCSTRING(citation)
 
 @node How You Can Contribute to Octave
 @unnumberedsec How You Can Contribute to Octave
 @cindex contributing to Octave
 @cindex funding Octave development
 
 There are a number of ways that you can contribute to help make Octave a
 better system.  Perhaps the most important way to contribute is to write
 high-quality code for solving new problems, and to make your code freely
-available for others to use.  @xref{Contributing Guidelines}, for detailed 
+available for others to use.  @xref{Contributing Guidelines}, for detailed
 information on contributing new code.
 
 If you find Octave useful, consider providing additional funding to
 continue its development.  Even a modest amount of additional funding
 could make a significant difference in the amount of time that is
 available for development and support.
 
 Donations supporting Octave development may be made on the web at
@@ -200,20 +200,20 @@ make Octave better and more reliable by 
 by offering suggestions for ways to improve Octave.  @xref{Trouble}, for
 tips on how to write useful bug reports.
 
 @node Distribution
 @unnumberedsec Distribution
 @cindex distribution of Octave
 
 Octave is @dfn{free} software.  This means that everyone is free to
-use it and free to redistribute it on certain conditions.  Octave 
+use it and free to redistribute it on certain conditions.  Octave
 is not, however, in the public domain.  It is copyrighted and there are
-restrictions on its distribution, but the restrictions are designed to 
-ensure that others will have the same freedom to use and redistribute 
-Octave that you have.  The precise conditions can be found in the 
-GNU General Public License that comes with Octave and that also appears 
+restrictions on its distribution, but the restrictions are designed to
+ensure that others will have the same freedom to use and redistribute
+Octave that you have.  The precise conditions can be found in the
+GNU General Public License that comes with Octave and that also appears
 in @ref{Copying}.
 
 To download a copy of Octave, please visit
 @url{http://www.octave.org/download.html}.
 
 @end ifclear
diff --git a/doc/interpreter/quad.txi b/doc/interpreter/quad.txi
--- a/doc/interpreter/quad.txi
+++ b/doc/interpreter/quad.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Numerical Integration
 @chapter Numerical Integration
 
 Octave comes with several built-in functions for computing the integral
@@ -164,29 +164,29 @@ quadcc (f, 0, Inf)
 @DOCSTRING(quadgk)
 
 @DOCSTRING(quadcc)
 
 Sometimes one does not have the function, but only the raw (x, y) points from
 which to perform an integration.  This can occur when collecting data in an
 experiment.  The @code{trapz} function can integrate these values as shown in
 the following example where "data" has been collected on the cosine function
-over the range [0, pi/2). 
+over the range [0, pi/2).
 
 @example
 @group
 x = 0:0.1:pi/2;  # Uniformly spaced points
 y = cos (x);
 trapz (x, y)
      @result{} 0.99666
 @end group
 @end example
 
 The answer is reasonably close to the exact value of 1.  Ordinary quadrature
-is sensitive to the characteristics of the integrand.  Empirical integration 
+is sensitive to the characteristics of the integrand.  Empirical integration
 depends not just on the integrand, but also on the particular points chosen to
 represent the function.  Repeating the example above with the sine function
 over the range [0, pi/2) produces far inferior results.
 
 @example
 @group
 x = 0:0.1:pi/2;  # Uniformly spaced points
 y = sin (x);
diff --git a/doc/interpreter/set.txi b/doc/interpreter/set.txi
--- a/doc/interpreter/set.txi
+++ b/doc/interpreter/set.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Sets
 @chapter Sets
 
 Octave has a limited number of functions for managing sets of data, where a
diff --git a/doc/interpreter/signal.txi b/doc/interpreter/signal.txi
--- a/doc/interpreter/signal.txi
+++ b/doc/interpreter/signal.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Signal Processing
 @chapter Signal Processing
 
 This chapter describes the signal processing and fast Fourier
diff --git a/doc/interpreter/sparse.txi b/doc/interpreter/sparse.txi
--- a/doc/interpreter/sparse.txi
+++ b/doc/interpreter/sparse.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 2004-2013 David Bateman
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @ifhtml
 @set htmltex
 @end ifhtml
 @iftex
@@ -34,17 +34,17 @@
 @end menu
 
 @node Basics
 @section Creation and Manipulation of Sparse Matrices
 
 The size of mathematical problems that can be treated at any particular
 time is generally limited by the available computing resources.  Both,
 the speed of the computer and its available memory place limitation on
-the problem size. 
+the problem size.
 
 There are many classes of mathematical problems which give rise to
 matrices, where a large number of the elements are zero.  In this case
 it makes sense to have a special matrix type to handle this class of
 problems where only the non-zero elements of the matrix are
 stored.  Not only does this reduce the amount of memory to store the
 matrix, but it also means that operations on this type of matrix can
 take advantage of the a priori knowledge of the positions of the
@@ -63,33 +63,33 @@ on them.
 @end menu
 
 @node Storage of Sparse Matrices
 @subsection Storage of Sparse Matrices
 
 It is not strictly speaking necessary for the user to understand how
 sparse matrices are stored.  However, such an understanding will help
 to get an understanding of the size of sparse matrices.  Understanding
-the storage technique is also necessary for those users wishing to 
-create their own oct-files. 
+the storage technique is also necessary for those users wishing to
+create their own oct-files.
 
 There are many different means of storing sparse matrix data.  What all
 of the methods have in common is that they attempt to reduce the complexity
 and storage given a priori knowledge of the particular class of problems
 that will be solved.  A good summary of the available techniques for storing
 sparse matrix is given by Saad @footnote{Y. Saad "SPARSKIT: A basic toolkit
 for sparse matrix computation", 1994,
 @url{http://www-users.cs.umn.edu/~saad/software/SPARSKIT/paper.ps}}.
 With full matrices, knowledge of the point of an element of the matrix
-within the matrix is implied by its position in the computers memory. 
+within the matrix is implied by its position in the computers memory.
 However, this is not the case for sparse matrices, and so the positions
-of the non-zero elements of the matrix must equally be stored. 
+of the non-zero elements of the matrix must equally be stored.
 
 An obvious way to do this is by storing the elements of the matrix as
-triplets, with two elements being their position in the array 
+triplets, with two elements being their position in the array
 (rows and column) and the third being the data itself.  This is conceptually
 easy to grasp, but requires more storage than is strictly needed.
 
 The storage technique used within Octave is the compressed column
 format.  It is similar to the Yale format.
 @footnote{@url{http://en.wikipedia.org/wiki/Sparse_matrix#Yale_format}}
 In this format the position of each element in a row and the data are
 stored as previously.  However, if we assume that all elements in the
@@ -104,17 +104,17 @@ columns, with the first element always b
 this is a simplification in the code, in that there is no special case
 for the first or last columns.  A short example, demonstrating this in
 C is.
 
 @example
 @group
   for (j = 0; j < nc; j++)
     for (i = cidx(j); i < cidx(j+1); i++)
-       printf ("non-zero element (%i,%i) is %d\n", 
+       printf ("non-zero element (%i,%i) is %d\n",
            ridx(i), j, data(i));
 @end group
 @end example
 
 A clear understanding might be had by considering an example of how the
 above applies to an example matrix.  Consider the matrix
 
 @example
@@ -144,30 +144,30 @@ contents of these three vectors for the 
 @group
   @var{cidx} = [0, 1, 2, 2, 4]
   @var{ridx} = [0, 0, 1, 2]
   @var{data} = [1, 2, 3, 4]
 @end group
 @end example
 
 Note that this is the representation of these elements with the first row
-and column assumed to start at zero, while in Octave itself the row and 
-column indexing starts at one.  Thus the number of elements in the 
-@var{i}-th column is given by @code{@var{cidx} (@var{i} + 1) - 
+and column assumed to start at zero, while in Octave itself the row and
+column indexing starts at one.  Thus the number of elements in the
+@var{i}-th column is given by @code{@var{cidx} (@var{i} + 1) -
 @var{cidx} (@var{i})}.
 
 Although Octave uses a compressed column format, it should be noted
 that compressed row formats are equally possible.  However, in the
 context of mixed operations between mixed sparse and dense matrices,
 it makes sense that the elements of the sparse matrices are in the
 same order as the dense matrices.  Octave stores dense matrices in
 column major ordering, and so sparse matrices are equally stored in
 this manner.
 
-A further constraint on the sparse matrix storage used by Octave is that 
+A further constraint on the sparse matrix storage used by Octave is that
 all elements in the rows are stored in increasing order of their row
 index, which makes certain operations faster.  However, it imposes
 the need to sort the elements on the creation of sparse matrices.  Having
 disordered elements is potentially an advantage in that it makes operations
 such as concatenating two sparse matrices together easier and faster, however
 it adds complexity and speed problems elsewhere.
 
 @node Creating Sparse Matrices
@@ -176,17 +176,17 @@ it adds complexity and speed problems el
 There are several means to create sparse matrix.
 
 @table @asis
 @item Returned from a function
 There are many functions that directly return sparse matrices.  These include
 @dfn{speye}, @dfn{sprand}, @dfn{diag}, etc.
 
 @item Constructed from matrices or vectors
-The function @dfn{sparse} allows a sparse matrix to be constructed from 
+The function @dfn{sparse} allows a sparse matrix to be constructed from
 three vectors representing the row, column and data.  Alternatively, the
 function @dfn{spconvert} uses a three column matrix format to allow easy
 importation of data from elsewhere.
 
 @item Created and then filled
 The function @dfn{sparse} or @dfn{spalloc} can be used to create an empty
 matrix that is then filled by the user
 
@@ -205,17 +205,17 @@ Another typical sparse matrix that is of
 of random elements.  The functions @dfn{sprand} and @dfn{sprandn} perform
 this for uniform and normal random distributions of elements.  They have exactly
 the same calling convention, where @code{sprand (@var{r}, @var{c}, @var{d})},
 creates an @var{r}-by-@var{c} sparse matrix with a density of filled
 elements of @var{d}.
 
 Other functions of interest that directly create sparse matrices, are
 @dfn{diag} or its generalization @dfn{spdiags}, that can take the
-definition of the diagonals of the matrix and create the sparse matrix 
+definition of the diagonals of the matrix and create the sparse matrix
 that corresponds to this.  For example,
 
 @example
 s = diag (sparse (randn (1,n)), -1);
 @end example
 
 @noindent
 creates a sparse (@var{n}+1)-by-(@var{n}+1) sparse matrix with a single
@@ -228,17 +228,17 @@ diagonal defined.
 @DOCSTRING(spones)
 
 @DOCSTRING(sprand)
 
 @DOCSTRING(sprandn)
 
 @DOCSTRING(sprandsym)
 
-The recommended way for the user to create a sparse matrix, is to create 
+The recommended way for the user to create a sparse matrix, is to create
 two vectors containing the row and column index of the data and a third
 vector of the same size containing the data to be stored.  For example,
 
 @example
 @group
   ri = ci = d = [];
   for j = 1:c
     ri = [ri; randperm(r,n)'];
@@ -254,17 +254,17 @@ creates an @var{r}-by-@var{c} sparse mat
 of @var{n} (<@var{r}) elements per column.  The elements of the vectors
 do not need to be sorted in any particular order as Octave will sort
 them prior to storing the data.  However, pre-sorting the data will
 make the creation of the sparse matrix faster.
 
 The function @dfn{spconvert} takes a three or four column real matrix.
 The first two columns represent the row and column index respectively and
 the third and four columns, the real and imaginary parts of the sparse
-matrix.  The matrix can contain zero elements and the elements can be 
+matrix.  The matrix can contain zero elements and the elements can be
 sorted in any order.  Adding zero elements is a convenient way to define
 the size of the sparse matrix.  For example:
 
 @example
 @group
 s = spconvert ([1 2 3 4; 1 3 4 4; 1 2 3 0]')
 @result{} Compressed Column Sparse (rows=4, cols=4, nnz=3)
       (1 , 1) -> 1
@@ -285,18 +285,18 @@ for j = 1:c
   s (:, j) = [zeros(r - k, 1); ...
         rand(k, 1)] (idx);
 endfor
 @end group
 @end example
 
 It should be noted, that due to the way that the Octave
 assignment functions are written that the assignment will reallocate
-the memory used by the sparse matrix at each iteration of the above loop. 
-Therefore the @dfn{spalloc} function ignores the @var{nz} argument and 
+the memory used by the sparse matrix at each iteration of the above loop.
+Therefore the @dfn{spalloc} function ignores the @var{nz} argument and
 does not pre-assign the memory for the matrix.  Therefore, it is vitally
 important that code using to above structure should be vectorized
 as much as possible to minimize the number of assignments and reduce the
 number of memory allocations.
 
 @DOCSTRING(full)
 
 @DOCSTRING(spalloc)
@@ -345,17 +345,17 @@ matrix (@pxref{Sparse Linear Algebra}). 
 matrix type when the div (/) or ldiv (\) operator is first used with
 the matrix and then caches the type.  However the @dfn{matrix_type}
 function can be used to determine the type of the sparse matrix prior
 to use of the div or ldiv operators.  For example,
 
 @example
 @group
 a = tril (sprandn (1024, 1024, 0.02), -1) ...
-    + speye (1024); 
+    + speye (1024);
 matrix_type (a);
 ans = Lower
 @end group
 @end example
 
 @noindent
 shows that Octave correctly determines the matrix type for lower
 triangular matrices.  @dfn{matrix_type} can also be used to force
@@ -405,17 +405,17 @@ xy = [0,4,8,6,4,2;5,0,5,7,5,7]';
 gplot (A,xy)
 @end group
 @end example
 
 @noindent
 which creates an adjacency matrix @code{A} where node 1 is connected
 to nodes 2 and 6, node 2 with nodes 1 and 3, etc.  The coordinates of
 the nodes are given in the n-by-2 matrix @code{xy}.
-@ifset htmltex 
+@ifset htmltex
 @xref{fig:gplot}.
 
 @float Figure,fig:gplot
 @center @image{gplot,4in}
 @caption{Simple use of the @dfn{gplot} command.}
 @end float
 @end ifset
 
@@ -449,136 +449,136 @@ symmetric or @code{treeplot (etree (A+A'
 
 @node Sparse Functions
 @subsubsection Sparse Functions
 
 Many Octave functions have been overloaded to work with either sparse or full
 matrices.  There is no difference in calling convention when using an
 overloaded function with a sparse matrix, however, there is also no access to
 potentially sparse-specific features.  At any time the sparse matrix specific
-version of a function can be used by explicitly calling its function name. 
+version of a function can be used by explicitly calling its function name.
 
 The table below lists all of the sparse functions of Octave.  Note that the
 names of the specific sparse forms of the functions are typically the same as
 the general versions with a @dfn{sp} prefix.  In the table below, and in the
 rest of this article, the specific sparse versions of functions are used.
 
 @c Table includes in comments the missing sparse functions
 
 @table @asis
 @item Generate sparse matrices:
-  @dfn{spalloc}, @dfn{spdiags}, @dfn{speye}, @dfn{sprand}, 
+  @dfn{spalloc}, @dfn{spdiags}, @dfn{speye}, @dfn{sprand},
   @dfn{sprandn}, @dfn{sprandsym}
 
 @item Sparse matrix conversion:
   @dfn{full}, @dfn{sparse}, @dfn{spconvert}
 
 @item Manipulate sparse matrices
   @dfn{issparse}, @dfn{nnz}, @dfn{nonzeros}, @dfn{nzmax},
   @dfn{spfun}, @dfn{spones}, @dfn{spy}
 
 @item Graph Theory:
-  @dfn{etree}, @dfn{etreeplot}, @dfn{gplot}, 
+  @dfn{etree}, @dfn{etreeplot}, @dfn{gplot},
   @dfn{treeplot}
 @c @dfn{treelayout}
 
 @item Sparse matrix reordering:
   @dfn{amd}, @dfn{ccolamd}, @dfn{colamd}, @dfn{colperm}, @dfn{csymamd},
   @dfn{dmperm}, @dfn{symamd}, @dfn{randperm}, @dfn{symrcm}
 
 @item Linear algebra:
   @dfn{condest}, @dfn{eigs}, @dfn{matrix_type}, @dfn{normest}, @dfn{sprank},
   @dfn{spaugment}, @dfn{svds}
 
 @item Iterative techniques:
   @dfn{luinc}, @dfn{pcg}, @dfn{pcr}
-@c @dfn{bicg}, @dfn{bicgstab}, @dfn{cholinc}, @dfn{cgs}, @dfn{gmres}, 
+@c @dfn{bicg}, @dfn{bicgstab}, @dfn{cholinc}, @dfn{cgs}, @dfn{gmres},
 @c @dfn{lsqr}, @dfn{minres}, @dfn{qmr}, @dfn{symmlq}
 
 @item Miscellaneous:
   @dfn{spparms}, @dfn{symbfact}, @dfn{spstats}
 @end table
 
 In addition all of the standard Octave mapper functions (i.e., basic
 math functions that take a single argument) such as @dfn{abs}, etc.
 can accept sparse matrices.  The reader is referred to the documentation
 supplied with these functions within Octave itself for further
 details.
 
 @node Return Types of Operators and Functions
 @subsubsection Return Types of Operators and Functions
 
-The two basic reasons to use sparse matrices are to reduce the memory 
+The two basic reasons to use sparse matrices are to reduce the memory
 usage and to not have to do calculations on zero elements.  The two are
 closely related in that the computation time on a sparse matrix operator
 or function is roughly linear with the number of non-zero elements.
 
-Therefore, there is a certain density of non-zero elements of a matrix 
+Therefore, there is a certain density of non-zero elements of a matrix
 where it no longer makes sense to store it as a sparse matrix, but rather
-as a full matrix.  For this reason operators and functions that have a 
+as a full matrix.  For this reason operators and functions that have a
 high probability of returning a full matrix will always return one.  For
 example adding a scalar constant to a sparse matrix will almost always
 make it a full matrix, and so the example,
 
 @example
 @group
 speye (3) + 0
 @result{}   1  0  0
   0  1  0
   0  0  1
 @end group
 @end example
 
 @noindent
-returns a full matrix as can be seen. 
+returns a full matrix as can be seen.
 
 
 Additionally, if @code{sparse_auto_mutate} is true, all sparse functions
 test the amount of memory occupied by the sparse matrix to see if the
 amount of storage used is larger than the amount used by the full
 equivalent.  Therefore @code{speye (2) * 1} will return a full matrix as
 the memory used is smaller for the full version than the sparse version.
 
-As all of the mixed operators and functions between full and sparse 
+As all of the mixed operators and functions between full and sparse
 matrices exist, in general this does not cause any problems.  However,
 one area where it does cause a problem is where a sparse matrix is
 promoted to a full matrix, where subsequent operations would resparsify
 the matrix.  Such cases are rare, but can be artificially created, for
 example @code{(fliplr (speye (3)) + speye (3)) - speye (3)} gives a full
-matrix when it should give a sparse one.  In general, where such cases 
+matrix when it should give a sparse one.  In general, where such cases
 occur, they impose only a small memory penalty.
 
 There is however one known case where this behavior of Octave's
 sparse matrices will cause a problem.  That is in the handling of the
 @dfn{diag} function.  Whether @dfn{diag} returns a sparse or full matrix
-depending on the type of its input arguments.  So 
+depending on the type of its input arguments.  So
 
 @example
  a = diag (sparse ([1,2,3]), -1);
 @end example
 
 @noindent
 should return a sparse matrix.  To ensure this actually happens, the
-@dfn{sparse} function, and other functions based on it like @dfn{speye}, 
-always returns a sparse matrix, even if the memory used will be larger 
+@dfn{sparse} function, and other functions based on it like @dfn{speye},
+always returns a sparse matrix, even if the memory used will be larger
 than its full representation.
 
 @DOCSTRING(sparse_auto_mutate)
 
 Note that the @code{sparse_auto_mutate} option is incompatible with
 @sc{matlab}, and so it is off by default.
 
 @node Mathematical Considerations
 @subsubsection Mathematical Considerations
 
 The attempt has been made to make sparse matrices behave in exactly the
 same manner as there full counterparts.  However, there are certain differences
 and especially differences with other products sparse implementations.
 
-First, the @qcode{"./"} and @qcode{".^"} operators must be used with care. 
+First, the @qcode{"./"} and @qcode{".^"} operators must be used with care.
 Consider what the examples
 
 @example
 @group
   s = speye (4);
   a1 = s .^ 2;
   a2 = s .^ s;
   a3 = s .^ -2;
@@ -587,29 +587,29 @@ Consider what the examples
   a6 = s ./ s;
 @end group
 @end example
 
 @noindent
 will give.  The first example of @var{s} raised to the power of 2 causes
 no problems.  However @var{s} raised element-wise to itself involves a
 large number of terms @code{0 .^ 0} which is 1. There @code{@var{s} .^
-@var{s}} is a full matrix. 
+@var{s}} is a full matrix.
 
 Likewise @code{@var{s} .^ -2} involves terms like @code{0 .^ -2} which
 is infinity, and so @code{@var{s} .^ -2} is equally a full matrix.
 
-For the "./" operator @code{@var{s} ./ 2} has no problems, but 
+For the "./" operator @code{@var{s} ./ 2} has no problems, but
 @code{2 ./ @var{s}} involves a large number of infinity terms as well
 and is equally a full matrix.  The case of @code{@var{s} ./ @var{s}}
 involves terms like @code{0 ./ 0} which is a @code{NaN} and so this
 is equally a full matrix with the zero elements of @var{s} filled with
 @code{NaN} values.
 
-The above behavior is consistent with full matrices, but is not 
+The above behavior is consistent with full matrices, but is not
 consistent with sparse implementations in other products.
 
 A particular problem of sparse matrices comes about due to the fact that
 as the zeros are not stored, the sign-bit of these zeros is equally not
 stored.  In certain cases the sign-bit of zero is important.  For example:
 
 @example
 @group
@@ -617,19 +617,19 @@ stored.  In certain cases the sign-bit o
  b = 1 ./ a
  @result{} -Inf            Inf
      Inf           -Inf
  c = 1 ./ sparse (a)
  @result{}  Inf            Inf
      Inf            Inf
 @end group
 @end example
- 
+
 To correct this behavior would mean that zero elements with a negative
-sign-bit would need to be stored in the matrix to ensure that their 
+sign-bit would need to be stored in the matrix to ensure that their
 sign-bit was respected.  This is not done at this time, for reasons of
 efficiency, and so the user is warned that calculations where the sign-bit
 of zero is important must not be done using sparse matrices.
 
 In general any function or operator used on a sparse matrix will
 result in a sparse matrix with the same or a larger number of non-zero
 elements than the original matrix.  This is particularly true for the
 important case of sparse matrix factorizations.  The usual way to
@@ -640,30 +640,30 @@ and @code{U} than the equivalent factori
 
 Several functions are available to reorder depending on the type of the
 matrix to be factorized.  If the matrix is symmetric positive-definite,
 then @dfn{symamd} or @dfn{csymamd} should be used.  Otherwise
 @dfn{amd}, @dfn{colamd} or @dfn{ccolamd} should be used.  For completeness
 the reordering functions @dfn{colperm} and @dfn{randperm} are
 also available.
 
-@xref{fig:simplematrix}, for an example of the structure of a simple 
+@xref{fig:simplematrix}, for an example of the structure of a simple
 positive definite matrix.
 
 @float Figure,fig:simplematrix
 @center @image{spmatrix,4in}
 @caption{Structure of simple sparse matrix.}
 @end float
 
 The standard Cholesky@tie{}factorization of this matrix can be
 obtained by the same command that would be used for a full
-matrix.  This can be visualized with the command 
+matrix.  This can be visualized with the command
 @code{r = chol (A); spy (r);}.
 @xref{fig:simplechol}.
-The original matrix had 
+The original matrix had
 @ifinfo
 @ifnothtml
 43
 @end ifnothtml
 @end ifinfo
 @ifset htmltex
 598
 @end ifset
@@ -673,23 +673,23 @@ non-zero terms, while this Cholesky@tie{
 71,
 @end ifnothtml
 @end ifinfo
 @ifset htmltex
 10200,
 @end ifset
 with only half of the symmetric matrix being stored.  This
 is a significant level of fill in, and although not an issue
-for such a small test case, can represents a large overhead 
+for such a small test case, can represents a large overhead
 in working with other sparse matrices.
 
 The appropriate sparsity preserving permutation of the original
 matrix is given by @dfn{symamd} and the factorization using this
 reordering can be visualized using the command @code{q = symamd (A);
-r = chol (A(q,q)); spy (r)}.  This gives 
+r = chol (A(q,q)); spy (r)}.  This gives
 @ifinfo
 @ifnothtml
 29
 @end ifnothtml
 @end ifinfo
 @ifset htmltex
 399
 @end ifset
@@ -733,17 +733,17 @@ reorder the matrix to maximize performan
 
 @DOCSTRING(symamd)
 
 @DOCSTRING(symrcm)
 
 @node Sparse Linear Algebra
 @section Linear Algebra on Sparse Matrices
 
-Octave includes a polymorphic solver for sparse matrices, where 
+Octave includes a polymorphic solver for sparse matrices, where
 the exact solver used to factorize the matrix, depends on the properties
 of the sparse matrix itself.  Generally, the cost of determining the matrix type
 is small relative to the cost of factorizing the matrix itself, but in any
 case the matrix type is cached once it is calculated, so that it is not
 re-determined each time it is used in a linear equation.
 
 The selection tree for how the linear equation is solve is
 
@@ -752,48 +752,48 @@ The selection tree for how the linear eq
 
 @item If the matrix is a permuted diagonal, solve directly taking into
 account the permutations.  Goto 8
 
 @item If the matrix is square, banded and if the band density is less
 than that given by @code{spparms ("bandden")} continue, else goto 4.
 
 @enumerate a
-@item If the matrix is tridiagonal and the right-hand side is not sparse 
+@item If the matrix is tridiagonal and the right-hand side is not sparse
 continue, else goto 3b.
 
 @enumerate
 @item If the matrix is Hermitian, with a positive real diagonal, attempt
       Cholesky@tie{}factorization using @sc{lapack} xPTSV.
 
 @item If the above failed or the matrix is not Hermitian with a positive
-      real diagonal use Gaussian elimination with pivoting using 
+      real diagonal use Gaussian elimination with pivoting using
       @sc{lapack} xGTSV, and goto 8.
 @end enumerate
 
 @item If the matrix is Hermitian with a positive real diagonal, attempt
       Cholesky@tie{}factorization using @sc{lapack} xPBTRF.
 
 @item if the above failed or the matrix is not Hermitian with a positive
-      real diagonal use Gaussian elimination with pivoting using 
+      real diagonal use Gaussian elimination with pivoting using
       @sc{lapack} xGBTRF, and goto 8.
 @end enumerate
 
 @item If the matrix is upper or lower triangular perform a sparse forward
 or backward substitution, and goto 8
 
 @item If the matrix is an upper triangular matrix with column permutations
-or lower triangular matrix with row permutations, perform a sparse forward 
+or lower triangular matrix with row permutations, perform a sparse forward
 or backward substitution, and goto 8
 
 @item If the matrix is square, Hermitian with a real positive diagonal, attempt
 sparse Cholesky@tie{}factorization using @sc{cholmod}.
 
 @item If the sparse Cholesky@tie{}factorization failed or the matrix is not
-Hermitian with a real positive diagonal, and the matrix is square, factorize 
+Hermitian with a real positive diagonal, and the matrix is square, factorize
 using @sc{umfpack}.
 
 @item If the matrix is not square, or any of the previous solvers flags
 a singular or near singular matrix, find a minimum norm solution using
 @sc{cxsparse}@footnote{The @sc{cholmod}, @sc{umfpack} and @sc{cxsparse} packages were
 written by Tim Davis and are available at
 @url{http://www.cise.ufl.edu/research/sparse/}}.
 @end enumerate
@@ -880,17 +880,17 @@ are partial factorizations of the origin
 
 A common application for sparse matrices is in the solution of Finite
 Element Models.  Finite element models allow numerical solution of
 partial differential equations that do not have closed form solutions,
 typically because of the complex shape of the domain.
 
 In order to motivate this application, we consider the boundary value
 Laplace equation.  This system can model scalar potential fields, such
-as heat or electrical potential.  Given a medium 
+as heat or electrical potential.  Given a medium
 @tex
 $\Omega$ with boundary $\partial\Omega$.  At all points on the $\partial\Omega$
 the boundary conditions are known, and we wish to calculate the potential in
 $\Omega$.
 @end tex
 @ifnottex
 Omega with boundary dOmega.  At all points on the dOmega
 the boundary conditions are known, and we wish to calculate the potential in
@@ -898,75 +898,75 @@ Omega.
 @end ifnottex
 Boundary conditions may specify the potential (Dirichlet
 boundary condition), its normal derivative across the boundary
 (Neumann boundary condition), or a weighted sum of the potential and
 its derivative (Cauchy boundary condition).
 
 In a thermal model, we want to calculate the temperature in
 @tex
-$\Omega$ 
+$\Omega$
 @end tex
 @ifnottex
 Omega
 @end ifnottex
 and know the boundary temperature (Dirichlet condition)
 or heat flux (from which we can calculate the Neumann condition
-by dividing by the thermal conductivity at the boundary).  Similarly, 
+by dividing by the thermal conductivity at the boundary).  Similarly,
 in an electrical model, we want to calculate the voltage in
 @tex
-$\Omega$ 
+$\Omega$
 @end tex
 @ifnottex
 Omega
 @end ifnottex
 and know the boundary voltage (Dirichlet) or current
 (Neumann condition after diving by the electrical conductivity).
 In an electrical model, it is common for much of the boundary
 to be electrically isolated; this is a Neumann boundary condition
 with the current equal to zero.
 
-The simplest finite element models will divide 
+The simplest finite element models will divide
 @tex
-$\Omega$ 
+$\Omega$
 @end tex
 @ifnottex
 Omega
 @end ifnottex
 into simplexes (triangles in 2D, pyramids in 3D).
 @ifset htmltex
-We take as a 3-D example a cylindrical liquid filled tank with a small 
-non-conductive ball from the EIDORS project@footnote{EIDORS - Electrical 
-Impedance Tomography and Diffuse optical Tomography Reconstruction Software 
+We take as a 3-D example a cylindrical liquid filled tank with a small
+non-conductive ball from the EIDORS project@footnote{EIDORS - Electrical
+Impedance Tomography and Diffuse optical Tomography Reconstruction Software
 @url{http://eidors3d.sourceforge.net}}.  This is model is designed to reflect
 an application of electrical impedance tomography, where current patterns
 are applied to such a tank in order to image the internal conductivity
-distribution.  In order to describe the FEM geometry, we have a matrix of 
+distribution.  In order to describe the FEM geometry, we have a matrix of
 vertices @code{nodes} and simplices @code{elems}.
 @end ifset
 
 The following example creates a simple rectangular 2-D electrically
-conductive medium with 10 V and 20 V imposed on opposite sides 
+conductive medium with 10 V and 20 V imposed on opposite sides
 (Dirichlet boundary conditions).  All other edges are electrically
 isolated.
 
 @example
 @group
    node_y = [1;1.2;1.5;1.8;2]*ones(1,11);
    node_x = ones(5,1)*[1,1.05,1.1,1.2, ...
              1.3,1.5,1.7,1.8,1.9,1.95,2];
    nodes = [node_x(:), node_y(:)];
 
    [h,w] = size (node_x);
    elems = [];
    for idx = 1:w-1
      widx = (idx-1)*h;
      elems = [elems; ...
        widx+[(1:h-1);(2:h);h+(1:h-1)]'; ...
-       widx+[(2:h);h+(2:h);h+(1:h-1)]' ]; 
+       widx+[(2:h);h+(2:h);h+(1:h-1)]' ];
    endfor
 
    E = size (elems,1); # No. of simplices
    N = size (nodes,1); # No. of vertices
    D = size (elems,2); # dimensions+1
 @end group
 @end example
 
@@ -981,29 +981,29 @@ This creates a N-by-2 matrix @code{nodes
 
   elems(1:7,:)'
     1    2    3    4    2    3    4 @dots{}
     2    3    4    5    7    8    9 @dots{}
     6    7    8    9    6    7    8 @dots{}
 @end group
 @end example
 
-Using a first order FEM, we approximate the electrical conductivity 
-distribution in 
+Using a first order FEM, we approximate the electrical conductivity
+distribution in
 @tex
-$\Omega$ 
+$\Omega$
 @end tex
 @ifnottex
 Omega
 @end ifnottex
 as constant on each simplex (represented by the vector @code{conductivity}).
 Based on the finite element geometry, we first calculate a system (or
 stiffness) matrix for each simplex (represented as 3-by-3 elements on the
-diagonal of the element-wise system matrix @code{SE}.  Based on @code{SE} 
-and a N-by-DE connectivity matrix @code{C}, representing the connections 
+diagonal of the element-wise system matrix @code{SE}.  Based on @code{SE}
+and a N-by-DE connectivity matrix @code{C}, representing the connections
 between simplices and vertices, the global connectivity matrix @code{S} is
 calculated.
 
 @example
   ## Element conductivity
   conductivity = [1*ones(1,16), ...
          2*ones(1,48), 1*ones(1,16)];
 
@@ -1013,87 +1013,87 @@ calculated.
 
   ## Calculate system matrix
   Siidx = floor ([0:D*E-1]'/D) * D * ...
          ones(1,D) + ones(D*E,1)*(1:D) ;
   Sjidx = [1:D*E]'*ones (1,D);
   Sdata = zeros (D*E,D);
   dfact = factorial (D-1);
   for j = 1:E
-     a = inv ([ones(D,1), ... 
+     a = inv ([ones(D,1), ...
          nodes(elems(j,:), :)]);
      const = conductivity(j) * 2 / ...
          dfact / abs (det (a));
      Sdata(D*(j-1)+(1:D),:) = const * ...
          a(2:D,:)' * a(2:D,:);
   endfor
   ## Element-wise system matrix
   SE = sparse(Siidx,Sjidx,Sdata);
   ## Global system matrix
   S = C'* SE *C;
 @end example
 
-The system matrix acts like the conductivity 
+The system matrix acts like the conductivity
 @tex
-$S$ 
+$S$
 @end tex
 @ifnottex
 @code{S}
 @end ifnottex
-in Ohm's law 
+in Ohm's law
 @tex
-$SV = I$. 
+$SV = I$.
 @end tex
 @ifnottex
 @code{S * V = I}.
 @end ifnottex
-Based on the Dirichlet and Neumann boundary conditions, we are able to 
-solve for the voltages at each vertex @code{V}. 
+Based on the Dirichlet and Neumann boundary conditions, we are able to
+solve for the voltages at each vertex @code{V}.
 
 @example
   ## Dirichlet boundary conditions
-  D_nodes = [1:5, 51:55]; 
-  D_value = [10*ones(1,5), 20*ones(1,5)]; 
+  D_nodes = [1:5, 51:55];
+  D_value = [10*ones(1,5), 20*ones(1,5)];
 
   V = zeros (N,1);
   V(D_nodes) = D_value;
-  idx = 1:N; # vertices without Dirichlet 
+  idx = 1:N; # vertices without Dirichlet
              # boundary condns
   idx(D_nodes) = [];
 
   ## Neumann boundary conditions.  Note that
   ## N_value must be normalized by the
   ## boundary length and element conductivity
   N_nodes = [];
   N_value = [];
 
   Q = zeros (N,1);
   Q(N_nodes) = N_value;
 
   V(idx) = S(idx,idx) \ ( Q(idx) - ...
             S(idx,D_nodes) * V(D_nodes));
 @end example
 
-Finally, in order to display the solution, we show each solved voltage 
+Finally, in order to display the solution, we show each solved voltage
 value in the z-axis for each simplex vertex.
 @ifset htmltex
 @xref{fig:femmodel}.
 @end ifset
 
 @example
 @group
   elemx = elems(:,[1,2,3,1])';
   xelems = reshape (nodes(elemx, 1), 4, E);
   yelems = reshape (nodes(elemx, 2), 4, E);
   velems = reshape (V(elemx), 4, E);
-  plot3 (xelems,yelems,velems,"k"); 
+  plot3 (xelems,yelems,velems,"k");
   print "grid.eps";
 @end group
 @end example
 
 
 @ifset htmltex
 @float Figure,fig:femmodel
 @center @image{grid,4in}
-@caption{Example finite element model the showing triangular elements. 
+@caption{Example finite element model the showing triangular elements.
 The height of each vertex corresponds to the solution value.}
 @end float
 @end ifset
diff --git a/doc/interpreter/sparseimages.m b/doc/interpreter/sparseimages.m
--- a/doc/interpreter/sparseimages.m
+++ b/doc/interpreter/sparseimages.m
@@ -187,36 +187,36 @@ function femimages (nm, typ)
     node_y = [1;1.2;1.5;1.8;2] * ones (1,11);
     node_x = ones (5,1) * [1,1.05,1.1,1.2,1.3,1.5,1.7,1.8,1.9,1.95,2];
     nodes = [node_x(:), node_y(:)];
 
     [h,w] = size (node_x);
     elems = [];
     for idx = 1 : w-1
       widx = (idx-1)*h;
-      elems = [elems; widx+[(1:h-1);(2:h);h+(1:h-1)]']; 
-      elems = [elems; widx+[(2:h);h+(2:h);h+(1:h-1)]']; 
+      elems = [elems; widx+[(1:h-1);(2:h);h+(1:h-1)]'];
+      elems = [elems; widx+[(2:h);h+(2:h);h+(1:h-1)]'];
     endfor
 
     E = size (elems,1);  # No. of elements
     N = size (nodes,1);  # No. of elements
     D = size (elems,2);  # dimensions+1
 
     ## Plot FEM Geometry
     elemx = elems(:,[1,2,3,1])';
     xelems = reshape (nodes(elemx, 1), 4, E);
     yelems = reshape (nodes(elemx, 2), 4, E);
 
     ## Set element conductivity
     conductivity = [1*ones(1,16), 2*ones(1,48), 1*ones(1,16)];
 
     ## Dirichlet boundary conditions
-    D_nodes = [1:5, 51:55]; 
-    D_value = [10*ones(1,5), 20*ones(1,5)]; 
-  
+    D_nodes = [1:5, 51:55];
+    D_value = [10*ones(1,5), 20*ones(1,5)];
+
     ## Neumann boundary conditions
     ## Note that N_value must be normalized by the boundary
     ##   length and element conductivity
     N_nodes = [];
     N_value = [];
 
     ## Calculate connectivity matrix
     C = sparse ((1:D*E), reshape (elems',D*E,1),1, D*E, N);
diff --git a/doc/interpreter/splineimages.m b/doc/interpreter/splineimages.m
--- a/doc/interpreter/splineimages.m
+++ b/doc/interpreter/splineimages.m
@@ -150,17 +150,17 @@ function splineimages (nm, typ)
     y3 = ppval (pp3, xx);
     plot (x, y, ".", xx, [y1; y2; y3]);
     legend ({"data with outliers","robust, beta = 0.25", ...
              "robust, beta = 0.75", "no robust fitting"});
     axis tight;
     ylim ([-2 2]);
     print ([nm "." typ], d_typ);
   endif
-  hide_output ();  
+  hide_output ();
 endfunction
 
 function set_print_size ()
   image_size = [5.0, 3.5]; # in inches, 16:9 format
   border = 0;              # For postscript use 50/72
   set (0, "defaultfigurepapertype", "<custom>");
   set (0, "defaultfigurepaperorientation", "landscape");
   set (0, "defaultfigurepapersize", image_size + 2*border);
diff --git a/doc/interpreter/stats.txi b/doc/interpreter/stats.txi
--- a/doc/interpreter/stats.txi
+++ b/doc/interpreter/stats.txi
@@ -1,31 +1,31 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Statistics
 @chapter Statistics
 
 Octave has support for various statistical methods.  This includes
-basic descriptive statistics, probability distributions, statistical tests, 
+basic descriptive statistics, probability distributions, statistical tests,
 random number generation, and much more.
 
 The functions that analyze data all assume that multi-dimensional data
 is arranged in a matrix where each row is an observation, and each
 column is a variable.  Thus, the matrix defined by
 
 @example
 @group
@@ -37,35 +37,35 @@ a = [ 0.9, 0.7;
 
 @noindent
 contains three observations from a two-dimensional distribution.
 While this is the default data arrangement, most functions support
 different arrangements.
 
 It should be noted that the statistics functions don't test for data
 containing NaN, NA, or Inf.  These values need to be detected and dealt
-with explicitly.  See @ref{XREFisnan,,isnan}, @ref{XREFisna,,isna}, 
-@ref{XREFisinf,,isinf}, @ref{XREFisfinite,,isfinite}. 
+with explicitly.  See @ref{XREFisnan,,isnan}, @ref{XREFisna,,isna},
+@ref{XREFisinf,,isinf}, @ref{XREFisfinite,,isfinite}.
 
 @menu
 * Descriptive Statistics::
 * Basic Statistical Functions::
 * Statistical Plots::
 * Correlation and Regression Analysis::
 * Distributions::
 * Tests::
 * Random Number Generation::
 @end menu
 
 @node Descriptive Statistics
 @section Descriptive Statistics
 
-One principal goal of descriptive statistics is to represent the essence of a 
+One principal goal of descriptive statistics is to represent the essence of a
 large data set concisely.  Octave provides the mean, median, and mode functions
-which all summarize a data set with just a single number corresponding to 
+which all summarize a data set with just a single number corresponding to
 the central tendency of the data.
 
 @DOCSTRING(mean)
 
 @DOCSTRING(median)
 
 @DOCSTRING(mode)
 
@@ -104,17 +104,17 @@ A summary view of a data set can be gene
 @code{statistics} function.
 
 @DOCSTRING(statistics)
 
 @node Basic Statistical Functions
 @section Basic Statistical Functions
 
 Octave supports various helpful statistical functions.  Many are useful as
-initial steps to prepare a data set for further analysis.  Others provide 
+initial steps to prepare a data set for further analysis.  Others provide
 different measures from those of the basic descriptive statistics.
 
 @DOCSTRING(center)
 
 @DOCSTRING(zscore)
 
 @DOCSTRING(histc)
 
@@ -179,22 +179,22 @@ using the @code{hist} function as descri
 
 @node Distributions
 @section Distributions
 
 Octave has functions for computing the Probability Density Function
 (PDF), the Cumulative Distribution function (CDF), and the quantile
 (the inverse of the CDF) for a large number of distributions.
 
-The following table summarizes the supported distributions (in 
+The following table summarizes the supported distributions (in
 alphabetical order).
 
 @tex
 \vskip 6pt
-{\hbox to \hsize {\hfill\vbox{\offinterlineskip \tabskip=0pt 
+{\hbox to \hsize {\hfill\vbox{\offinterlineskip \tabskip=0pt
 \halign{
 \vrule height2.0ex depth1.ex width 0.6pt #\tabskip=0.3em &
 # \hfil & \vrule # & # \hfil & \vrule # & # \hfil & \vrule # & # \hfil &
 # \vrule width 0.6pt \tabskip=0pt\cr
 \noalign{\hrule height 0.6pt}
 & {\bf Distribution} && {\bf PDF}      && {\bf CDF}     && {\bf Quantile}&\cr
 \noalign{\hrule}
 &Beta         && betapdf        && betacdf       && betainv&\cr
@@ -462,17 +462,17 @@ alphabetical order).
 @node Tests
 @section Tests
 
 Octave can perform many different statistical tests.  The following
 table summarizes the available tests.
 
 @tex
 \vskip 6pt
-{\hbox to \hsize {\hfill\vbox{\offinterlineskip \tabskip=0pt 
+{\hbox to \hsize {\hfill\vbox{\offinterlineskip \tabskip=0pt
 \halign{
 \vrule height2.0ex depth1.ex width 0.6pt #\tabskip=0.3em &
 # \hfil & \vrule # & # \hfil & # \vrule width 0.6pt \tabskip=0pt\cr
 \noalign{\hrule height 0.6pt}
 & @strong{Hypothesis} && {\bf Test Functions} &\cr
 \noalign{\hrule}
 & Equal mean values && anova, hotelling\_test2, t\_test\_2, &\cr
 &                   && welch\_test, wilcoxon\_test, z\_test\_2 &\cr
@@ -586,17 +586,17 @@ The random number generators are based o
 described in @ref{Special Utility Matrices}.
 @c Should rand, randn, rande, randp, and randg be moved to here?
 
 The following table summarizes the available random number generators
 (in alphabetical order).
 
 @tex
 \vskip 6pt
-{\hbox to \hsize {\hfill\vbox{\offinterlineskip \tabskip=0pt 
+{\hbox to \hsize {\hfill\vbox{\offinterlineskip \tabskip=0pt
 \halign{
 \vrule height2.0ex depth1.ex width 0.6pt #\tabskip=0.3em &
 # \hfil & \vrule # & # \hfil & # \vrule width 0.6pt \tabskip=0pt\cr
 \noalign{\hrule height 0.6pt}
 & {\bf Distribution}                && {\bf Function} &\cr
 \noalign{\hrule}
 & Beta Distribution                 && betarnd &\cr
 & Binomial Distribution             && binornd &\cr
diff --git a/doc/interpreter/stmt.txi b/doc/interpreter/stmt.txi
--- a/doc/interpreter/stmt.txi
+++ b/doc/interpreter/stmt.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Statements
 @chapter Statements
 @cindex statements
 
@@ -460,17 +460,17 @@ simple.
 
 The @code{do-until} statement is similar to the @code{while} statement,
 except that it repeatedly executes a statement until a condition becomes
 true, and the test of the condition is at the end of the loop, so the
 body of the loop is always executed at least once.  As with the
 condition in an @code{if} statement, the condition in a @code{do-until}
 statement is considered true if its value is non-zero, and false if its
 value is zero.  If the value of the conditional expression in a
-@code{do-until} statement is a vector or a matrix, it is considered 
+@code{do-until} statement is a vector or a matrix, it is considered
 true only if it is non-empty and @emph{all} of the elements are non-zero.
 
 Octave's @code{do-until} statement looks like this:
 
 @example
 @group
 do
   @var{body}
@@ -563,33 +563,33 @@ using the @code{for} statement.  For exa
 disp ("Loop over a matrix")
 for i = [1,3;2,4]
   i
 endfor
 disp ("Loop over a cell array")
 for i = @{1,"two";"three",4@}
   i
 endfor
-@end group 
+@end group
 @end example
 
 @noindent
 In this case the variable @code{i} takes on the value of the columns of
 the matrix or cell matrix.  So the first loop iterates twice, producing
 two column vectors @code{[1;2]}, followed by @code{[3;4]}, and likewise
 for the loop over the cell array.  This can be extended to loops over
 multi-dimensional arrays.  For example:
 
 @example
 @group
 a = [1,3;2,4]; c = cat (3, a, 2*a);
 for i = c
   i
 endfor
-@end group 
+@end group
 @end example
 
 @noindent
 In the above case, the multi-dimensional matrix @var{c} is reshaped to a
 two-dimensional matrix as @code{reshape (c, rows (c),
 prod (size (c)(2:end)))} and then the same behavior as a loop over a two
 dimensional matrix is produced.
 
@@ -635,20 +635,20 @@ for [val, key] = x
   key
   val
 endfor
 
      @print{} key = a
      @print{} val = 1
      @print{} key = b
      @print{} val =
-     @print{} 
+     @print{}
      @print{}   1  2
      @print{}   3  4
-     @print{} 
+     @print{}
      @print{} key = c
      @print{} val = string
 @end group
 @end example
 
 The elements are not accessed in any particular order.  If you need to
 cycle through the list in a particular way, you will have to use the
 function @code{fieldnames} and sort the list yourself.
@@ -766,33 +766,33 @@ endfor
 
 @node The unwind_protect Statement
 @section The unwind_protect Statement
 @cindex @code{unwind_protect} statement
 @cindex @code{unwind_protect_cleanup}
 @cindex @code{end_unwind_protect}
 
 Octave supports a limited form of exception handling modeled after the
-unwind-protect form of Lisp.  
+unwind-protect form of Lisp.
 
 The general form of an @code{unwind_protect} block looks like this:
 
 @example
 @group
 unwind_protect
   @var{body}
 unwind_protect_cleanup
   @var{cleanup}
 end_unwind_protect
 @end group
 @end example
 
 @noindent
 where @var{body} and @var{cleanup} are both optional and may contain any
-Octave expressions or commands.  The statements in @var{cleanup} are 
+Octave expressions or commands.  The statements in @var{cleanup} are
 guaranteed to be executed regardless of how control exits @var{body}.
 
 This is useful to protect temporary changes to global variables from
 possible errors.  For example, the following code will always restore
 the original value of the global variable @code{frobnosticate}
 even if an error occurs in the first part of the @code{unwind_protect}
 block.
 
diff --git a/doc/interpreter/strings.txi b/doc/interpreter/strings.txi
--- a/doc/interpreter/strings.txi
+++ b/doc/interpreter/strings.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Strings
 @chapter Strings
 @cindex strings
 @cindex character strings
@@ -38,18 +38,18 @@ following expressions
 represent the string whose contents are @samp{parrot}.  Strings in
 Octave can be of any length.
 
 Since the single-quote mark is also used for the transpose operator
 (@pxref{Arithmetic Ops}) but double-quote marks have no other purpose in Octave,
 it is best to use double-quote marks to denote strings.
 
 Strings can be concatenated using the notation for defining matrices.  For
-example, the expression 
- 
+example, the expression
+
 @example
 [ "foo" , "bar" , "baz" ]
 @end example
 
 @noindent
 produces the string whose contents are @samp{foobarbaz}.  @xref{Numeric Data
 Types}, for more information about creating matrices.
 
@@ -77,17 +77,17 @@ is not a special character.  Here is an 
 toascii ("\n")
     @result{} 10
 toascii ('\n')
     @result{} [ 92 110 ]
 @end group
 @end example
 
 Here is a table of all the escape sequences used in Octave (within
-double quoted strings).  They are the same as those used in the C 
+double quoted strings).  They are the same as those used in the C
 programming language.
 
 @table @code
 @item \\
 Represents a literal backslash, @samp{\}.
 
 @item \"
 Represents a literal double-quote character, @samp{"}.
@@ -282,41 +282,41 @@ strcat ("oc", "tave", " is", " good", " 
 @item @code{char} generates an empty row in the output
 for each empty string in the input.  @code{strvcat}, on the other hand,
 eliminates empty strings.
 
 @example
 @group
 char ("orange", "green", "", "red")
     @result{} orange
-       green 
+       green
 
        red
 @end group
 
 @group
 strvcat ("orange", "green", "", "red")
     @result{} orange
-       green 
-       red  
+       green
+       red
 @end group
 @end example
 
 @item All string concatenation functions except @code{cstrcat} also accept cell
 array data (@pxref{Cell Arrays}).  @code{char} and
 @code{strvcat} convert cell arrays into character arrays, while @code{strcat}
 concatenates within the cells of the cell arrays:
 
 @example
 @group
 char (@{"red", "green", "", "blue"@})
-     @result{} red  
+     @result{} red
         green
 
-        blue 
+        blue
 @end group
 
 @group
 strcat (@{"abc"; "ghi"@}, @{"def"; "jkl"@})
      @result{}
         @{
           [1,1] = abcdef
           [2,1] = ghijkl
@@ -411,17 +411,17 @@ Since a string is just a matrix, simple 
 using standard operators.  The following example shows how to replace
 all blank characters with underscores.
 
 @example
 @group
 quote = ...
   "First things first, but not necessarily in that order";
 quote( quote == " " ) = "_"
-@result{} quote = 
+@result{} quote =
     First_things_first,_but_not_necessarily_in_that_order
 @end group
 @end example
 
 For more complex manipulations, such as searching, replacing, and
 general regular expressions, the following functions come with Octave.
 
 @DOCSTRING(deblank)
diff --git a/doc/interpreter/system.txi b/doc/interpreter/system.txi
--- a/doc/interpreter/system.txi
+++ b/doc/interpreter/system.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node System Utilities
 @chapter System Utilities
 
 This chapter describes the functions that are available to allow you to
@@ -360,27 +360,27 @@ they can be used, look at the definition
 
 @DOCSTRING(WCONTINUE)
 
 @DOCSTRING(WCOREDUMP)
 
 @DOCSTRING(WEXITSTATUS)
 
 @DOCSTRING(WIFCONTINUED)
- 
+
 @DOCSTRING(WIFSIGNALED)
 
 @DOCSTRING(WIFSTOPPED)
 
 @DOCSTRING(WIFEXITED)
 
 @DOCSTRING(WNOHANG)
 
 @DOCSTRING(WSTOPSIG)
- 
+
 @DOCSTRING(WTERMSIG)
 
 @DOCSTRING(WUNTRACED)
 
 @DOCSTRING(fcntl)
 
 @DOCSTRING(kill)
 
diff --git a/doc/interpreter/testfun.txi b/doc/interpreter/testfun.txi
--- a/doc/interpreter/testfun.txi
+++ b/doc/interpreter/testfun.txi
@@ -2,22 +2,22 @@
 @c Copyright (C) 2002-2005 Paul Kienzle
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Test and Demo Functions
 @appendix Test and Demo Functions
 @cindex test functions
 
@@ -40,17 +40,17 @@ of the line is processed through the Oct
 generates an error, then the test is said to fail.
 
 Since @code{eval()} will stop at the first error it encounters, you must
 divide your tests up into blocks, with anything in a separate
 block evaluated separately.  Blocks are introduced by valid keywords like
 @code{test}, @code{function}, or @code{assert} immediately following @samp{%!}.
 A block is defined by indentation as in Python.  Lines beginning with
 @samp{%!<whitespace>} are part of the preceeding block.
- 
+
 For example:
 
 @example
 @group
 %!test error ("this test fails!");
 %!test "test doesn't fail. it doesn't generate an error";
 @end group
 @end example
@@ -193,20 +193,20 @@ You can also share test functions:
 @group
 %!function @var{a} = fn (@var{b})
 %!  @var{a} = 2*@var{b};
 %!endfunction
 %!assert (fn(2), 4);
 @end group
 @end example
 
-Note that all previous variables and values are lost when a new 
+Note that all previous variables and values are lost when a new
 shared block is declared.
 
-Remember that @code{%!function} begins a new block and that 
+Remember that @code{%!function} begins a new block and that
 @code{%!endfunction} ends this block.  Be aware that until a new block
 is started, lines starting with @samp{%!<space>} will be discarded as comments.
 The following is nearly identical to the example above, but does nothing.
 
 @example
 @group
 %!function @var{a} = fn (@var{b})
 %!  @var{a} = 2*@var{b};
@@ -214,19 +214,19 @@ The following is nearly identical to the
 %! assert (fn(2), 4);
 @end group
 @end example
 
 @noindent
 Because there is a space after @samp{%!} the @code{assert} statement does
 not begin a new block and this line is treated as a comment.
 
-Error and warning blocks are like test blocks, but they only succeed 
+Error and warning blocks are like test blocks, but they only succeed
 if the code generates an error.  You can check the text of the error
-is correct using an optional regular expression @code{<pattern>}.  
+is correct using an optional regular expression @code{<pattern>}.
 For example:
 
 @example
 %!error <passes!> error ("this test passes!");
 @end example
 
 If the code doesn't generate an error, the test fails.  For example:
 
@@ -241,17 +241,17 @@ produces
 @group
   ***** error "this is an error because it succeeds.";
 !!!!! test failed: no error
 @end group
 @end example
 
 It is important to automate the tests as much as possible, however
 some tests require user interaction.  These can be isolated into
-demo blocks, which if you are in batch mode, are only run when 
+demo blocks, which if you are in batch mode, are only run when
 called with @code{demo} or the @code{verbose} option to @code{test}.
 The code is displayed before it is executed.  For example,
 
 @example
 @group
 %!demo
 %! @var{t} = [0:0.01:2*pi]; @var{x} = sin (@var{t});
 %! plot (@var{t}, @var{x});
@@ -264,17 +264,17 @@ produces
 
 @example
 @group
 funcname example 1:
  @var{t} = [0:0.01:2*pi]; @var{x} = sin (@var{t});
  plot (@var{t}, @var{x});
  # you should now see a sine wave in your figure window
 
-Press <enter> to continue: 
+Press <enter> to continue:
 @end group
 @end example
 
 Note that demo blocks cannot use any shared variables.  This is so
 that they can be executed by themselves, ignoring all other tests.
 
 If you want to temporarily disable a test block, put @code{#} in place
 of the block type.  This creates a comment block which is echoed
diff --git a/doc/interpreter/tips.txi b/doc/interpreter/tips.txi
--- a/doc/interpreter/tips.txi
+++ b/doc/interpreter/tips.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Tips and Standards
 @appendix Tips and Standards
 @cindex tips
 @cindex standards of coding style
@@ -118,17 +118,17 @@ Here is an example:
 @example
 ## Copyright (C) 1996, 1997, 2007 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or
 ## modify it under the terms of the GNU General Public
 ## License as published by the Free Software Foundation;
-## either version 3 of the License, or (at your option) any 
+## either version 3 of the License, or (at your option) any
 ## later version.
 ##
 ## Octave is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied
 ## warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 ## PURPOSE.  See the GNU General Public License for more
 ## details.
 ##
@@ -279,17 +279,17 @@ Do not start or end a documentation stri
 
 @item
 Format the documentation string so that it fits within an 80-column screen.
 It is a good idea for most lines to be no wider than 60 characters.
 
 However, rather than simply filling the entire documentation string, you
 can make it much more readable by choosing line breaks with care.
 Use blank lines between topics if the documentation string is long.
- 
+
 @item
 @strong{Do not} indent subsequent lines of a documentation string so
 that the text is lined up in the source code with the text of the first
 line.  This looks nice in the source code, but looks bizarre when users
 view the documentation.  Remember that the indentation before the
 starting double-quote is not part of the string!
 
 @item
@@ -344,17 +344,17 @@ for standard Octave functions, and @code
 dynamically linked functions.  A skeletal Texinfo documentation string
 therefore looks like this
 
 @example
 @group
 -*- texinfo -*-
 @@deftypefn @{Function File@} @{@@var@{ret@} =@} fn (@dots{})
 @@cindex index term
-Help text in Texinfo format.  Code samples should be marked 
+Help text in Texinfo format.  Code samples should be marked
 like @@code@{sample of code@} and variables should be marked
 as @@var@{variable@}.
 @@seealso@{fn2, fn3@}
 @@end deftypefn
 @end group
 @end example
 
 This help string must be commented in user functions, or in the help
@@ -369,17 +369,17 @@ and should be the first part of any help
 @item @@deftypefn @{class@} @dots{} @@end deftypefn
 The entire help string should be enclosed within the block defined by
 deftypefn.
 
 @item @@cindex index term
 This generates an index entry, and can be useful when the function is
 included as part of a larger piece of documentation.  It is ignored
 within Octave's help viewer.  Only one index term may appear per line
-but multiple @@cindex lines are valid if the function should be 
+but multiple @@cindex lines are valid if the function should be
 filed under different terms.
 
 @item @@var@{variable@}
 All variables should be marked with this macro.  The markup of variables
 is then changed appropriately for display.
 
 @item @@code@{sample of code@}
 All samples of code should be marked with this macro for the same
@@ -562,17 +562,17 @@ for @@var@{n@} or @@var@{k@}.
 @@seealso@{bincoeff, perms@}
 @@end deftypefn
 @end example
 
 @noindent
 which demonstrates most of the concepts discussed above.
 @iftex
 This documentation string renders as
-@c Note: use the actual output of info below, rather than try and 
+@c Note: use the actual output of info below, rather than try and
 @c reproduce it here to prevent it looking different from how it would
 @c appear with info.
 
 @example
  -- Function File: C = nchoosek (N, K)
  -- Function File: C = nchoosek (SET, K)
      Compute the binomial coefficient or all combinations of a set of
      items.
diff --git a/doc/interpreter/var.txi b/doc/interpreter/var.txi
--- a/doc/interpreter/var.txi
+++ b/doc/interpreter/var.txi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Variables
 @chapter Variables
 @cindex variables, user-defined
 @cindex user-defined variables
@@ -310,17 +310,17 @@ see which variables are available at the
 and its siblings @code{whos} and @code{whos_line_format} will show
 different information about what is in memory, as the following shows.
 
 @example
 @group
 str = "A random string";
 who -variables
      @print{} *** local user variables:
-     @print{} 
+     @print{}
      @print{} __nargin__  str
 @end group
 @end example
 
 @DOCSTRING(who)
 
 @DOCSTRING(whos)
 
diff --git a/doc/interpreter/vectorize.txi b/doc/interpreter/vectorize.txi
--- a/doc/interpreter/vectorize.txi
+++ b/doc/interpreter/vectorize.txi
@@ -552,17 +552,17 @@ programs.
 @itemize @bullet
 
 @item Avoid computing costly intermediate results multiple times.
 Octave currently does not eliminate common subexpressions.  Also, certain
 internal computation results are cached for variables.  For instance, if
 a matrix variable is used multiple times as an index, checking the
 indices (and internal conversion to integers) is only done once.
 
-@item Be aware of lazy copies (copy-on-write).  
+@item Be aware of lazy copies (copy-on-write).
 @cindex copy-on-write
 @cindex COW
 @cindex memory management
 When a copy of an object is created, the data is not immediately copied, but
 rather shared.  The actual copying is postponed until the copied data needs to
 be modified.  For example:
 
 @example
diff --git a/doc/liboctave/Makefile.am b/doc/liboctave/Makefile.am
--- a/doc/liboctave/Makefile.am
+++ b/doc/liboctave/Makefile.am
@@ -1,24 +1,24 @@
 # Makefile for Octave's doc/liboctave directory
 #
 # Copyright (C) 1996-2013 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
 TEXINFO_TEX = ../texinfo.tex
 
diff --git a/doc/liboctave/array.texi b/doc/liboctave/array.texi
--- a/doc/liboctave/array.texi
+++ b/doc/liboctave/array.texi
@@ -1,32 +1,32 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Arrays, Matrix and Vector Operations, Introduction, Top
 @chapter Arrays
 @cindex arrays
 
 @menu
-* Constructors and Assignment::  
+* Constructors and Assignment::
 @end menu
 
 @node Constructors and Assignment,  , Arrays, Arrays
 @section Constructors and Assignment
 
 @deftypefn Constructor {} Array<T> (void)
 Create an array with no elements.
 @end deftypefn
diff --git a/doc/liboctave/bugs.texi b/doc/liboctave/bugs.texi
--- a/doc/liboctave/bugs.texi
+++ b/doc/liboctave/bugs.texi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Bugs, Concept Index, Installation, Top
 @chapter Bugs
 @cindex bugs, known
 @cindex installation trouble
diff --git a/doc/liboctave/cp-idx.texi b/doc/liboctave/cp-idx.texi
--- a/doc/liboctave/cp-idx.texi
+++ b/doc/liboctave/cp-idx.texi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Concept Index, Function Index, Bugs, Top
 @unnumbered Concept Index
 
 @printindex cp
diff --git a/doc/liboctave/dae.texi b/doc/liboctave/dae.texi
--- a/doc/liboctave/dae.texi
+++ b/doc/liboctave/dae.texi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Differential Algebraic Equations, Error Handling, Ordinary Differential Equations, Top
 @chapter Differential Algebraic Equations
 @cindex DAE
 
diff --git a/doc/liboctave/diffeq.texi b/doc/liboctave/diffeq.texi
--- a/doc/liboctave/diffeq.texi
+++ b/doc/liboctave/diffeq.texi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Ordinary Differential Equations, Differential Algebraic Equations, Quadrature, Top
 @chapter Ordinary Differential Equations
 @cindex ODE
 
diff --git a/doc/liboctave/error.texi b/doc/liboctave/error.texi
--- a/doc/liboctave/error.texi
+++ b/doc/liboctave/error.texi
@@ -1,21 +1,21 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Error Handling, Installation, Differential Algebraic Equations, Top
 @chapter Error Handling
 
diff --git a/doc/liboctave/factor.texi b/doc/liboctave/factor.texi
--- a/doc/liboctave/factor.texi
+++ b/doc/liboctave/factor.texi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Matrix Factorizations, Ranges, Matrix and Vector Operations, Top
 @chapter Matrix Factorizations
 @cindex matrix factorizations
 @cindex factorizations
diff --git a/doc/liboctave/fn-idx.texi b/doc/liboctave/fn-idx.texi
--- a/doc/liboctave/fn-idx.texi
+++ b/doc/liboctave/fn-idx.texi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Function Index, , Concept Index, Top
 @unnumbered Function Index
 
 @printindex fn
diff --git a/doc/liboctave/gpl.texi b/doc/liboctave/gpl.texi
--- a/doc/liboctave/gpl.texi
+++ b/doc/liboctave/gpl.texi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @cindex warranty
 @cindex copyright
 @node Copying, Introduction, Acknowledgements, Top
 @unnumbered GNU GENERAL PUBLIC LICENSE
@@ -235,17 +235,17 @@ and you may offer support or warranty pr
 @item Conveying Modified Source Versions.
 
 You may convey a work based on the Program, or the modifications to
 produce it from the Program, in the form of source code under the
 terms of section 4, provided that you also meet all of these
 conditions:
 
 @enumerate a
-@item 
+@item
 The work must carry prominent notices stating that you modified it,
 and giving a relevant date.
 
 @item
 The work must carry prominent notices stating that it is released
 under this License and any conditions added under section 7.  This
 requirement modifies the requirement in section 4 to ``keep intact all
 notices''.
@@ -683,17 +683,17 @@ free software which everyone can redistr
 terms.
 
 To do so, attach the following notices to the program.  It is safest
 to attach them to the start of each source file to most effectively
 state the exclusion of warranty; and each file should have at least
 the ``copyright'' line and a pointer to where the full notice is found.
 
 @smallexample
-@var{one line to give the program's name and a brief idea of what it does.}  
+@var{one line to give the program's name and a brief idea of what it does.}
 Copyright (C) @var{year} @var{name of author}
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or (at
 your option) any later version.
 
 This program is distributed in the hope that it will be useful, but
@@ -706,17 +706,17 @@ along with this program.  If not, see @u
 @end smallexample
 
 Also add information on how to contact you by electronic and paper mail.
 
 If the program does terminal interaction, make it output a short
 notice like this when it starts in an interactive mode:
 
 @smallexample
-@var{program} Copyright (C) @var{year} @var{name of author} 
+@var{program} Copyright (C) @var{year} @var{name of author}
 This program comes with ABSOLUTELY NO WARRANTY; for details type @samp{show w}.
 This is free software, and you are welcome to redistribute it
 under certain conditions; type @samp{show c} for details.
 @end smallexample
 
 The hypothetical commands @samp{show w} and @samp{show c} should show
 the appropriate parts of the General Public License.  Of course, your
 program's commands might be different; for a GUI interface, you would
diff --git a/doc/liboctave/install.texi b/doc/liboctave/install.texi
--- a/doc/liboctave/install.texi
+++ b/doc/liboctave/install.texi
@@ -1,21 +1,21 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Installation, Bugs, Error Handling, Top
 @chapter Installation
 @cindex installation
diff --git a/doc/liboctave/intro.texi b/doc/liboctave/intro.texi
--- a/doc/liboctave/intro.texi
+++ b/doc/liboctave/intro.texi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Introduction, Arrays, Copying, Top
 @chapter A Brief Introduction to Octave
 @cindex introduction
 
diff --git a/doc/liboctave/liboctave.texi b/doc/liboctave/liboctave.texi
--- a/doc/liboctave/liboctave.texi
+++ b/doc/liboctave/liboctave.texi
@@ -1,22 +1,22 @@
 % Copyright (C) 1996-2013 John W. Eaton
 %
 % This file is part of Octave.
 %
 % Octave is free software; you can redistribute it and/or modify it
 % under the terms of the GNU General Public License as published by the
 % Free Software Foundation; either version 3 of the License, or (at
 % your option) any later version.
-% 
+%
 % Octave is distributed in the hope that it will be useful, but WITHOUT
 % ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 % FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 % for more details.
-% 
+%
 % You should have received a copy of the GNU General Public License
 % along with Octave; see the file COPYING.  If not, see
 % <http://www.gnu.org/licenses/>.
 
 
 \input texinfo
 @setfilename liboctave.info
 
@@ -113,57 +113,57 @@ into another language, under the same co
 This manual documents how to use, install and port Octave's C++ class
 library, and how to report bugs.  It corresponds to Octave version
 @value{VERSION}.
 @end ifnottex
 
 @c ------------------------------------------------------------------------
 
 @menu
-* Acknowledgements::            
-* Copying::                     
-* Introduction::                
-* Arrays::                      
-* Matrix and Vector Operations::  
-* Matrix Factorizations::       
-* Ranges::                      
-* Nonlinear Functions::         
-* Nonlinear Equations::         
-* Optimization::                
-* Quadrature::                  
-* Ordinary Differential Equations::  
-* Differential Algebraic Equations::  
-* Error Handling::              
-* Installation::                
-* Bugs::                        
-* Concept Index::               
-* Function Index::              
+* Acknowledgements::
+* Copying::
+* Introduction::
+* Arrays::
+* Matrix and Vector Operations::
+* Matrix Factorizations::
+* Ranges::
+* Nonlinear Functions::
+* Nonlinear Equations::
+* Optimization::
+* Quadrature::
+* Ordinary Differential Equations::
+* Differential Algebraic Equations::
+* Error Handling::
+* Installation::
+* Bugs::
+* Concept Index::
+* Function Index::
 
  --- The Detailed Node Listing ---
 
 Acknowledgements
 
 * Contributors::                People who contributed to developing of Octave.
 
 Arrays
 
-* Constructors and Assignment::  
+* Constructors and Assignment::
 
 Optimization
 
-* Objective Functions::         
-* Bounds::                      
-* Linear Constraints::          
-* Nonlinear Constraints::       
-* Quadratic Programming::       
-* Nonlinear Programming::       
+* Objective Functions::
+* Bounds::
+* Linear Constraints::
+* Nonlinear Constraints::
+* Quadratic Programming::
+* Nonlinear Programming::
 
 Quadrature
 
-* Collocation Weights::         
+* Collocation Weights::
 @end menu
 
 @c ------------------------------------------------------------------------
 
 @include preface.texi
 @include gpl.texi
 @include intro.texi
 @include array.texi
diff --git a/doc/liboctave/matvec.texi b/doc/liboctave/matvec.texi
--- a/doc/liboctave/matvec.texi
+++ b/doc/liboctave/matvec.texi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 The real and complex @code{ColumnVector} and @code{RowVector} classes
 all have the following functions.  These will eventually be part of an
 @code{MArray<T>} class, derived from the @code{Array<T>} class.  Then
 the @code{ColumnVector} and @code{RowVector} classes will be derived
diff --git a/doc/liboctave/nleqn.texi b/doc/liboctave/nleqn.texi
--- a/doc/liboctave/nleqn.texi
+++ b/doc/liboctave/nleqn.texi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Nonlinear Equations, Optimization, Nonlinear Functions, Top
 @chapter Nonlinear Equations
 @cindex nonlinear equations
 
diff --git a/doc/liboctave/nlfunc.texi b/doc/liboctave/nlfunc.texi
--- a/doc/liboctave/nlfunc.texi
+++ b/doc/liboctave/nlfunc.texi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1997-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Nonlinear Functions, Nonlinear Equations, Ranges, Top
 @chapter Nonlinear Functions
 @cindex nonlinear functions
 
diff --git a/doc/liboctave/ode.texi b/doc/liboctave/ode.texi
--- a/doc/liboctave/ode.texi
+++ b/doc/liboctave/ode.texi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Ordinary Differential Equations, Differential Algebraic Equations, Nonlinear Equations, Top
 @chapter Ordinary Differential Equations
 @cindex ODE
 
diff --git a/doc/liboctave/optim.texi b/doc/liboctave/optim.texi
--- a/doc/liboctave/optim.texi
+++ b/doc/liboctave/optim.texi
@@ -1,37 +1,37 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Optimization, Quadrature, Nonlinear Equations, Top
 @chapter Optimization
 @cindex optimization
 
 @menu
-* Objective Functions::         
-* Bounds::                      
-* Linear Constraints::          
-* Nonlinear Constraints::       
-* Quadratic Programming::       
-* Nonlinear Programming::       
+* Objective Functions::
+* Bounds::
+* Linear Constraints::
+* Nonlinear Constraints::
+* Quadratic Programming::
+* Nonlinear Programming::
 @end menu
 
 @node Objective Functions, Bounds, Optimization, Optimization
 @section Objective Functions
 @cindex objective functions
 
 @deftypefn  {} {} Objective (void)
 @deftypefnx  {} {} Objective (const @var{objective_fcn})
diff --git a/doc/liboctave/preface.texi b/doc/liboctave/preface.texi
--- a/doc/liboctave/preface.texi
+++ b/doc/liboctave/preface.texi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Acknowledgements, Copying, Top, Top
 @chapter Acknowledgements
 @cindex acknowledgements
 
diff --git a/doc/liboctave/quad.texi b/doc/liboctave/quad.texi
--- a/doc/liboctave/quad.texi
+++ b/doc/liboctave/quad.texi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Quadrature, Ordinary Differential Equations, Optimization, Top
 @chapter Quadrature
 @cindex quadrature
 @cindex numerical integration
@@ -69,17 +69,17 @@
 
 @deftypefn  {} {} IndefQuad (integrand_fcn @var{fcn})
 @deftypefnx  {} {} IndefQuad (integrand_fcn @var{fcn}, double @var{b}, IntegralType @var{t})
 @deftypefnx  {} {} IndefQuad (integrand_fcn @var{fcn}, double @var{b}, IntegralType @var{t}, double @var{abs}, double @var{rel})
 @deftypefnx  {} {} IndefQuad (integrand_fcn @var{fcn}, double @var{abs}, double @var{rel})
 @end deftypefn
 
 @menu
-* Collocation Weights::         
+* Collocation Weights::
 @end menu
 
 @node Collocation Weights,  , Quadrature, Quadrature
 @section Collocation Weights
 @cindex orthogonal collocation
 @cindex collocation weights
 
 @deftypefn  {} {} CollocWt (void)
diff --git a/doc/liboctave/range.texi b/doc/liboctave/range.texi
--- a/doc/liboctave/range.texi
+++ b/doc/liboctave/range.texi
@@ -1,22 +1,22 @@
 @c Copyright (C) 1996-2013 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
-@c 
+@c
 @c Octave is distributed in the hope that it will be useful, but WITHOUT
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
-@c 
+@c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Ranges, Nonlinear Functions, Matrix Factorizations, Top
 @chapter Ranges
 @cindex ranges
 
diff --git a/doc/refcard/Makefile.am b/doc/refcard/Makefile.am
--- a/doc/refcard/Makefile.am
+++ b/doc/refcard/Makefile.am
@@ -1,35 +1,35 @@
 # Makefile for Octave's doc/refcard directory
 #
 # Copyright (C) 1996-2013 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
 TEX = \
   refcard.tex \
   refcard-a4.tex \
   refcard-legal.tex \
-  refcard-letter.tex 
+  refcard-letter.tex
 
 FORMATTED = \
   refcard-a4.dvi \
   refcard-a4.ps \
   refcard-a4.pdf \
   refcard-legal.dvi \
   refcard-legal.ps \
   refcard-legal.pdf \
diff --git a/doc/refcard/refcard.tex b/doc/refcard/refcard.tex
--- a/doc/refcard/refcard.tex
+++ b/doc/refcard/refcard.tex
@@ -572,17 +572,17 @@ nnz ({\it s})&No. non-zero elements in s
   of {\it range}\cr
 \quad :&select all rows (columns)\cr
 \endsec
 
 \sec Global and Persistent Variables;
 global {\it var1} ...&Declare variables global.\cr
 global {\it var1} = {\it val}&Declare variable global. Set initial value.\cr
 persistent {\it var1}&Declare a variable as static to a function.\cr
-persistent {\it var1} = {\it val}&Declare a variable as static to a 
+persistent {\it var1} = {\it val}&Declare a variable as static to a
   function and set its initial value.\cr
 \omit\hfill\vbox{\rm\vskip0.25ex
   Global variables may be accessed inside the body of a function
   without having to be passed in the function parameter list provided
   they are declared global when used.}\span\cr
 \endsec
 
 \sec Selected Built-in Functions;
@@ -638,26 +638,26 @@ realmin&minimum representable value\cr
   are always evaluated.\vskip0.75ex}\span\cr
 {\it x} < {\it y}&true if {\it x\/} is less than {\it y}\cr
 {\it x} <= {\it y}&true if {\it x\/} is less than or equal to {\it y}\cr
 {\it x} == {\it y}&true if {\it x\/} is equal to {\it y}\cr
 {\it x} >= {\it y}&true if {\it x\/} is greater than or equal to {\it y}\cr
 {\it x} > {\it y}&true if {\it x\/} is greater than {\it y}\cr
 {\it x} != {\it y}&true if {\it x\/} is not equal to {\it y}\cr
 {\it x} \& {\it y}&true if both {\it x\/} and {\it y\/} are true\cr
-{\it x} | {\it y}&true if at least one of {\it x\/} or {\it y\/} is true\cr 
+{\it x} | {\it y}&true if at least one of {\it x\/} or {\it y\/} is true\cr
 ! {\it bool}&true if {\it bool\/} is false\cr
 \endsec
 
 \sec Short-circuit Boolean Operators;
 \omit \vbox{\rm\vskip0.75ex
-  Operators evaluate left-to-right. Operands are only evaluated if 
-  necessary, stopping once overall truth value can be determined.  
-  Operands are converted to scalars using the {\tt all} 
-  function.\vskip0.75ex}\span\cr   
+  Operators evaluate left-to-right. Operands are only evaluated if
+  necessary, stopping once overall truth value can be determined.
+  Operands are converted to scalars using the {\tt all}
+  function.\vskip0.75ex}\span\cr
 {\it x} \&\& {\it y}&true if both {\it x\/} and {\it y\/} are true\cr
 {\it x} || {\it y}&true if at least one of {\it x\/} or {\it y\/} is true\cr
 \endsec
 
 \sec Operator Precedence;
 \omit \vbox{\rm\vskip0.5ex
   Table of Octave operators, in order of increasing
   precedence.\vskip0.75ex}\span\cr
@@ -795,24 +795,24 @@ diag ({\it v}, {\it k})&create diagonal 
 linspace ({\it b}, {\it l}, {\it n})&create vector of linearly-spaced
   elements\cr
 logspace ({\it b}, {\it l}, {\it n})&create vector of log-spaced
   elements\cr
 eye ({\it n}, {\it m})&create {\it n\/} by {\it m\/} identity matrix\cr
 ones ({\it n}, {\it m})&create {\it n\/} by {\it m\/} matrix of ones\cr
 zeros ({\it n}, {\it m})&create {\it n\/} by {\it m\/} matrix of zeros\cr
 rand ({\it n}, {\it m})&create {\it n\/} by {\it m\/} matrix of random
-  values\cr 
+  values\cr
 \endsec
 
 % sin ({\it a}) cos({\it a}) tan({\it a})&trigonometric functions\cr
 % asin ({\it a}) acos({\it a}) atan({\it a})&inverse trigonometric functions\cr
 % sinh ({\it a}) cosh({\it a}) tanh({\it a})&hyperbolic trig functions\cr
 % asinh ({\it a}) acosh({\it a}) atanh({\it a})&inverse hyperbolic trig
-% functions\cr\cr 
+% functions\cr\cr
 
 \sec Linear Algebra;
 chol ({\it a})&Cholesky factorization\cr
 det ({\it a})&compute the determinant of a matrix\cr
 eig ({\it a})&eigenvalues and eigenvectors\cr
 expm ({\it a})&compute the exponential of a matrix\cr
 hess ({\it a})&compute Hessenberg decomposition\cr
 inverse ({\it a})&invert a square matrix\cr
@@ -974,12 +974,12 @@ Octave itself is free software; you are 
 it under the terms of the GNU General Public License.  There is
 absolutely no warranty for Octave.
 }
 
 \end
 
 % For AUCTeX:
 %
-% Local Variables: 
+% Local Variables:
 % mode: tex
 % TeX-master: t
-% End: 
+% End:
diff --git a/etc/HACKING b/etc/HACKING
--- a/etc/HACKING
+++ b/etc/HACKING
@@ -77,22 +77,22 @@ After cloning Octave, you will need to r
 This script will examine the source tree and generate some Makefile
 fragments, then run autotools scripts to generate Makefile.in files from
 Makefile.am files and create the configure script.  The bootstrap script
 comes from gnulib, but is kept in the Octave source archive.  It should
 be updated from the gnulib sources as necessary.
 
 If you have a copy of gnulib in some directory apart from the Octave
 source tree, then pass the name of the directory containing gnulib-tool
-to the bootstrap script using the option: 
+to the bootstrap script using the option:
 
   --gnulib-srcdir=DIRNAME
 
 If you have downloaded gnulib directly, DIRNAME will be the directory where
-gnulib was unpacked.  If you have installed gnulib using a package 
+gnulib was unpacked.  If you have installed gnulib using a package
 manager, DIRNAME is likely to be /usr/bin or /usr/local/bin(where the
 gnulib-tool script resides).
 
 By using an external gnulib directory, you can share a single gnulib source
 tree among several projects.  Since 2011, the gnulib sources are a Mercurial
 subrepository, so they will be automatically updated to the
 corresponding Mercurial revision if you update the working directory to
 a past revision not too far in the past.
@@ -201,17 +201,17 @@ An overview of the directory layout of O
       slatec-fn        various special function subroutines
 
     numeric     C++ numerical algorithms and interfaces to the Fortran
                 algorithms
 
     operators   code for operators that act on base classes (such as Array)
 
     system      OS-related functions
- 
+
     util        utility and miscellaneous functions
 
   libinterp     -- the interpreter itself plus lots of infrastructure
                    around it.  Octave's extensive octave_value class
                    hierarchy for polymorphically handling all Octave
                    types is defined here.  The built-in functions are
                    also defined here.
 
@@ -332,17 +332,17 @@ An overview of the directory layout of O
 
     fntests.m        script to run function tests embedded in C++ and
                      .m files
 
 ----
 John W. Eaton
 jwe@octave.org
 
-Last updated: Tue, 29 Oct 2013 11:42:47 PDT 
+Last updated: Tue, 29 Oct 2013 11:42:47 PDT
 
 
 
 ################################################################################
 
 Copyright (C) 2009-2013 John W. Eaton
 
 This file is part of Octave.
diff --git a/etc/NEWS.1 b/etc/NEWS.1
--- a/etc/NEWS.1
+++ b/etc/NEWS.1
@@ -242,17 +242,17 @@ Summary of changes for version 1.1.0:
 
   * The commands `gplot clear' and `gsplot clear' are equivalent to
     `clearplot'.  (Previously, `gplot clear' would evaluate `clear' as
     an ordinary expression and clear all the visible variables.)
 
   * The Matlab-style plotting commands have been improved.  They now
     accept line-style arguments, multiple x-y pairs, and other plot
     option flags.  For example,
- 
+
       plot (x, y, "@12", x, y2, x, y3, "4", x, y4, "+")
 
     results in a plot with
 
       y  plotted with points of type 2 ("+") and color 1 (red).
       y2 plotted with lines.
       y3 plotted with lines of color 4.
       y4 plotted with points which are "+"s.
@@ -293,17 +293,17 @@ Summary of changes for version 1.1.0:
     -- The load command now accepts the option -float-binary, for
        saving floating point data in binary files in single precision.
 
   * who and whos now accept a list of globbing patterns so you can
     limit the lists of variables and functions to those that match a
     given set of patterns.
 
   * New functions for manipulating polynomials
-      
+
       compan     -- companion matrix corresponding to polynomial coefficients
       conv       -- convolve two vectors
       deconv     -- deconvolve two vectors
       roots      -- find the roots of a polynomial
       poly       -- characteristic polynomial of a matrix
       polyderiv  -- differentiate a polynomial
       polyinteg  -- integrate a polynomial
       polyreduce -- reduce a polynomial to minimum number of terms
@@ -626,17 +626,17 @@ Summary of changes for version 0.82:
 
   * For empty matrices with one nonzero dimension, the +, -, .*, and
     ./ operators now correctly preserve the dimension.
 
   * Octave no longer crashes if you type ^D at the beginning of a line
     in the middle of defining a loop or if statement.
 
   * On AIX systems, Back off on indexing DiagArray via Proxy class to
-    avoid gcc (or possibly AIX assembler?) bug. 
+    avoid gcc (or possibly AIX assembler?) bug.
 
   * Various other bug and portability fixes.
 
 Summary of changes for version 0.81:
 -----------------------------------
 
   * Octave no longer dumps core if you try to define a function in
     your .octaverc file.
@@ -910,17 +910,17 @@ Summary of changes for version 0.78:
     provided that OCTAVE_HOME is set correctly, even if Octave is
     installed in a directory different from that specified at compile
     time.
 
   * There is a new command line option, --info-file FILE, that may be
     used to set Octave's idea of the location of the info file.  It
     will override any value of OCTAVE_INFO_FILE found in the
     environment, but not any INFO_FILE="filename" commands found in
-    the system or user startup files. 
+    the system or user startup files.
 
   * Octave's Info reader will now recognize gzipped files that have
     names ending in `.gz'.
 
   * The save command now accepts regular expressions as arguments.
     Note that these patterns are regular expressions, and do not work
     like filename globbing.  For example, given the variables `a',
     `aa', and `a1', the command `save a*' saves `a' and `aa' but not
@@ -1038,22 +1038,22 @@ Summary of changes for version 0.73:
 
   * Matrices may now have one or both dimensions zero, so that
     operations on empty matrices are now handled more consistently.
 
     By default, dimensions of the empty matrix are now printed along
     with the empty matrix symbol, `[]'.  For example:
 
       octave:13> zeros (3, 0)
-      ans = 
+      ans =
 
       [](3x0)
 
     The new variable `print_empty_dimensions' controls this behavior.
-    
+
     See also Carl de Boor, An Empty Exercise, SIGNUM, Volume 25,
     pages 2--6, 1990, or C. N. Nett and W. M. Haddad, A
     System-Theoretic Appropriate Realization of the Empty Matrix
     Concept, IEEE Transactions on Automatic Control, Volume 38,
     Number 5, May 1993.
 
   * The right and left division operators `/' and `\' will now find a
     minimum norm solution if the system is not square, or if the
@@ -1096,17 +1096,17 @@ Summary of changes for version 0.72:
 
       [ linspace (1, 2) ]
 
     will work.  However, some possible sources of confusion remain
     because Octave tries (possibly too hard) to determine exactly what
     operation is intended from the context surrounding an operator.
     For example:
 
-    -- In the command 
+    -- In the command
 
          [ 1 - 1 ]
 
        the `-' is treated as a binary operator and the result is the
        scalar 0, but in the command
 
          [ 1 -1 ]
 
@@ -1169,17 +1169,17 @@ Summary of changes for version 0.72:
 
   * New built-in variables for file and I/O functions:
 
       stdin    -- file number corresponding to the standard input stream.
       stdout   -- file number corresponding to the standard output stream.
       stderr   -- file number corresponding to the standard error stream.
 
     The following may be used as the final (optional) argument for
-    fseek: 
+    fseek:
 
       SEEK_SET -- set position relative to the beginning of the file.
       SEEK_CUR -- set position relative to the current position.
       SEEK_END -- set position relative to the end of the file.
 
   * New function: setstr -- convert vectors or scalars to strings
     (doesn't work for matrices yet).
 
@@ -1360,17 +1360,17 @@ Summary of changes for version 0.69:
   * Replacements for acosh, asinh, atanh, and gamma from the BSD math
     library for those systems that don't have them.
 
 Summary of changes for version 0.68:
 -----------------------------------
 
   * New functions:
 
-      eval  -- evaluate a string as a sequence of Octave commands. 
+      eval  -- evaluate a string as a sequence of Octave commands.
       input -- print a prompt and get user input.
 
 Summary of changes for version 0.67:
 -----------------------------------
 
   * New functions:
 
       find -- return the indices of nonzero elements.
@@ -1404,17 +1404,17 @@ Summary of changes for version 0.67:
     possible to have unary and binary operations on empty matrices
     return an empty matrix.  The default value of this variable is
     'warn', so that empty matrices are propagated but you get a
     warning.  Some functions, like eig and svd have also been changed
     to handle this.
 
   * Empty matrices can be used in conditionals, but they always
     evaluate to `false'.  With propagate_empty_matrices = 'true', both
-    of the following expressions print 0: 
+    of the following expressions print 0:
 
       if  [], 1, else 0, end
       if ~[], 1, else 0, end
 
   * Octave no longer converts input like `3.2 i' or `3 I' to complex
     constants directly because that causes problems inside square
     brackets, where spaces are important.  This abbreviated notation
     *does* work if there isn't a space between the number and the i,
@@ -1442,17 +1442,17 @@ Summary of changes for version 0.66:
     numbers, and octave is a link to that file.  This makes it
     possible to have more than one version of the interpreter installed.
 
 Summary of changes for version 0.63:
 -----------------------------------
 
   * The reshape function works again.
 
-  * Octave now converts input like `3.2i' or `3 I' or `2.3e5 j' to be 
+  * Octave now converts input like `3.2i' or `3 I' or `2.3e5 j' to be
     complex constants directly, rather than requiring an expression
     like `3.3 * i' to be evaluated.
 
 Summary of changes for version 0.61:
 -----------------------------------
 
   * Octave has been successfully compiled using gcc 2.3.3 and libg++ 2.3.
     on a 486 system running Linux.
@@ -1460,17 +1460,17 @@ Summary of changes for version 0.61:
   * The win_texas_lotto function is now called texas_lotto (it's a
     script file, and win_texas_lotto.m is too long for some Linux and
     System V systems).
 
 Summary of changes for version 0.57:
 ------------------------------------
 
   * The C-like formatted print functions printf, fprintf, and sprintf
-    finally work. 
+    finally work.
 
 Summary of changes for version 0.56:
 ------------------------------------
 
   * By default, octave prints a short disclaimer when it starts.
     (You can suppress it by invoking octave with -q).
 
   * You can keep octave from reading your ~/.octaverc and .octaverc
@@ -1521,32 +1521,32 @@ Summary of changes for version 0.55:
     if a return value has not been explicitly declared.  The default
     value for this variable is 'false'.
 
 Summary of changes for version 0.52:
 ------------------------------------
 
   * Name completion works for function and variable names currently in
     the symbol tables.  Coming soon: completion for names of functions
-    defined in script files but not yet compiled. 
+    defined in script files but not yet compiled.
 
   * The initial value of do_fortran_indexing is now false, and the
     initial value of prefer_column_vectors is now true.  Swap the
     values of these variables if you want behavior that is more like
     Matlab.
 
   * All script files check the number of input arguments before doing
     much real work.
 
   * The identifiers `i' and `j' are now also names for sqrt(-1).
     These symbols may be used for other purposes, but their original
     definition will reappear if they are cleared.
 
   * The symbol tables are now implemented with hash tables for faster
-    searching. 
+    searching.
 
   * A small amount of help is now available for most built-in
     operators, keywords and functions.  Coming soon: help for script
     files.
 
   * Without any arguments, the help command now lists all known
     built-in operators, keywords and functions.
 
diff --git a/etc/NEWS.2 b/etc/NEWS.2
--- a/etc/NEWS.2
+++ b/etc/NEWS.2
@@ -15,17 +15,17 @@ Summary of changes for version 2.1.x:
 	(condition-case ()
 	    (require 'custom)
 	  (error nil))
 	(if (and (featurep 'custom) (fboundp 'custom-declare-variable))
 	    nil ;; We've got what we needed
 	  ;; We have the old custom-library, hack around it!
 	  (defmacro defgroup (&rest args)
 	    nil)
-	  (defmacro defcustom (var value doc &rest args) 
+	  (defmacro defcustom (var value doc &rest args)
 	    (` (defvar (, var) (, value) (, doc))))))
 
   * When `format +' is in effect, Octave uses the following symbols to
     provide more information about the values in a matrix:
 
       +      postive real
       -      negative real
       i      pure imaginary
@@ -44,17 +44,17 @@ Summary of changes for version 2.1.x:
     string vector.
 
   * The value of LOADPATH set by the environment variable
     OCTAVE_PATH, the -p or --path command line options, or on the
     command line is no longer modified to include the default path.
     Instead it is left as specified.  Its default value is now ":",
     which tells Octave to search the default path, and the new
     built-in variable DEFAULT_LOADPATH contains the default list of
-    directories to search.  
+    directories to search.
 
   * The function file_in_path no longer does any special processing of
     its PATH argument.  To search LOADPATH for files, it is now
     generally better to use the new function file_in_loadpath.
 
   * If fread is given a skip parameter, the skip is performed after
     the read instead of before (for compatibility with Matlab).
 
@@ -286,17 +286,17 @@ Summary of changes for version 2.1.x:
       kolmogorov_smirnov_test     -- one-sample Kolmogorov-Smirnov test
       kolmogorov_smirnov_test_2   -- two-sample Kolmogorov-Smirnov test
       kruskal_wallis_test         -- kruskal-Wallis test
       manova                      -- one-way multivariate analysis of variance
       mcnemar_test                -- mcnemar's test for symmetry
       prop_test_2                 -- compare two proportions
       run_test                    -- run test for independence
       sign_test                   -- sign test
-      t_test                      -- student's one-sample t test 
+      t_test                      -- student's one-sample t test
       t_test_2                    -- student's two-sample t test
       t_test_regression           -- test one linear hypothesis in linear
                                      regression model
       u_test                      -- mann-Whitney U-test
       var_test                    -- f test to compare two variances
       welch_test                  -- welch two-sample t test
       wilcoxon_test               -- wilcoxon signed-rank test
       z_test                      -- test for mean of a normal sample with
@@ -308,17 +308,17 @@ Summary of changes for version 2.1.x:
     variables at the end of the file, leaving the existing contents.
 
   * New command-line option --no-history (also available using the
     single character option -H) inhibits saving command history.
 
   * The mkoctfile script now accepts -DDEF options and passes them on
     to the C and C++ compilers.
 
-  * Running `make check' should work now before you run `make install', 
+  * Running `make check' should work now before you run `make install',
     even if you build a copy of Octave that depends on shared versions
     of the Octave libraries.
 
   * For matrices, x(:) now works and returns a column vector no matter
     what the value of do_fortran_indexing is.
 
   * New keywords __FILE__ and __LINE__ expand to the name of the file
     that is being read and the current input line number, respectively.
@@ -341,17 +341,17 @@ Summary of changes for version 2.1.x:
     assignment) is printed.  If it is nonzero, the value of the right
     hand side (i.e., the result of the expression) is printed.  The
     default value of is zero, so the behavior is the same as in
     previous versions of Octave.
 
   * tmpnam now takes two optional arguments, DIR, and PREFIX.  For
     example, tmpnam ("/foo", "bar-") returns a file name like
     "/foo/bar-10773baa".  If DIR is omitted or empty, the value of the
-    environment variable TMPDIR, or /tmp is used.  If PREFIX is 
+    environment variable TMPDIR, or /tmp is used.  If PREFIX is
     omitted, "oct-" is used.
 
   * The built-in variable `PWD' has been removed.  If you need to get
     the value of the current working directory, use the pwd() function
     instead.
 
   * New operators.  Octave's parser now recognizes the following
     operators:  << >> += -= *= /= .+= .-= .*= ./= &= |= <<= >>=.  So
@@ -397,20 +397,20 @@ Summary of changes for version 2.1.x:
       the normal indexing operator.  For example,
 
         x = list ([1,2;3,4], 1, "foo");
         stdout << x(2) << "\n"
         1
         stdout << x;
         (
          [1] =
-        
+
            1  2
            3  4
-        
+
           [2] = 1
           [3] = foo
         )
 
       There is currently no special syntax for creating lists; you
       must use the list function.
 
   * Commas in global statements are no longer special.  They are now
@@ -747,17 +747,17 @@ Summary of changes for version 2.0:
   * It is now possible to get the values of individual option settings
     for the dassl, fsolve, lsode, npsol, qpsol, and quad functions
     using commands like
 
       dassl_reltol = dassl_options ("relative tolerance");
 
   * The svd() function no longer computes the left and right singular
     matrices unnecessarily.  This can significantly improve
-    performance for large matrices if you are just looking for the  
+    performance for large matrices if you are just looking for the
     singular values.
 
   * The filter() function is now a built-in function.
 
   * New function randn() returns a pseudo-random number from a normal
     distribution.  The rand() and randn() functions have separate
     seeds and generators.
 
@@ -902,17 +902,17 @@ Summary of changes for version 2.0:
        value is 2.
 
     -- New functions:
 
        struct_contains (S, NAME) -- returns 1 if S is a structure with
                                     element NAME; otherwise returns 0.
 
        struct_elements (S)       -- returns the names of all elements
-                                    of structure S in an array of strings. 
+                                    of structure S in an array of strings.
 
   * New io/subprocess functions:
 
       fputs    -- write a string to a file with no formatting
       popen2   -- start a subprocess with 2-way communication
       mkfifo   -- create a FIFO special file
       popen    -- open a pipe to a subprocess
       pclose   -- close a pipe from a subprocess
diff --git a/etc/NEWS.3 b/etc/NEWS.3
--- a/etc/NEWS.3
+++ b/etc/NEWS.3
@@ -1707,15 +1707,15 @@ Summary of important user-visible change
 
 
  ** For compatibility with Matlab, normcdf, norminv, normpdf, and
     normrnd have been modified to compute distributions using the
     standard deviation instead of the variance.
 
 
  ** For compatibility with Matlab, gamcdf, gaminv, gampdf, gamrnd,
-    expcdf, expinv, exppdf and exprnd have been modified to compute 
+    expcdf, expinv, exppdf and exprnd have been modified to compute
     the distributions using the standard scale factor rather than
     one over the scale factor.
 
 ---------------------------------------------------------
 
 See NEWS.2 for old news.
diff --git a/etc/OLD-ChangeLogs/ChangeLog b/etc/OLD-ChangeLogs/ChangeLog
--- a/etc/OLD-ChangeLogs/ChangeLog
+++ b/etc/OLD-ChangeLogs/ChangeLog
@@ -406,17 +406,17 @@ 2010-11-14  Michael Goffioul  <michael.g
 	%OCTAVE_CONF_F77_INTEGER_8_FLAG%.
 
 2010-11-10  John W. Eaton  <jwe@octave.org>
 
 	* configure.ac: Don't check for nan.h.
 
 2010-11-10  John W. Eaton  <jwe@octave.org>
 
-	* configure.ac (AH_BOTTOM): Eliminate special case for __DECCXX: 
+	* configure.ac (AH_BOTTOM): Eliminate special case for __DECCXX:
 
 2010-11-10  John W. Eaton  <jwe@octave.org>
 
 	* configure.ac: Eliminate special cases for nextstep.
 
 2010-11-10  John W. Eaton  <jwe@octave.org>
 
 	* configure.ac: Eliminate special checks for SCO systems.
diff --git a/etc/OLD-ChangeLogs/doc-ChangeLog b/etc/OLD-ChangeLogs/doc-ChangeLog
--- a/etc/OLD-ChangeLogs/doc-ChangeLog
+++ b/etc/OLD-ChangeLogs/doc-ChangeLog
@@ -128,17 +128,17 @@ 2011-03-26  Rik  <octave@nomad.inbox5.co
 	of functions not requiring a docstring.
 
 2011-03-19  Rik  <octave@nomad.inbox5.com>
 
 	* interpreter/container.txi: Add cellindexmat function to documentation.
 
 2011-03-19  Rik  <octave@nomad.inbox5.com>
 
-	* interpreter/oop.txi: Add optimize_subsasgn_calls function to 
+	* interpreter/oop.txi: Add optimize_subsasgn_calls function to
 	documentation.
 
 2011-03-19  Rik  <octave@nomad.inbox5.com>
 
 	* interpreter/stats.txi: Add runlength function to documentation.
 
 2011-03-19  Rik  <octave@nomad.inbox5.com>
 
@@ -177,17 +177,17 @@ 2011-03-18  Rik  <octave@nomad.inbox5.co
 2011-03-18  Rik  <octave@nomad.inbox5.com>
 
 	* interpreter/arith.txi, interpreter/linalg.txi: Add function chop
 	to documentation.  Re-order Utility Functions and move function dot
 	from linear algebra section to be with other utility functions.
 
 2011-03-18  Rik  <octave@nomad.inbox5.com>
 
-	* interpreter/basics.txi: Add gen_doc_cache, get_help_text, 
+	* interpreter/basics.txi: Add gen_doc_cache, get_help_text,
 	get_help_text_from_file, get_first_help_sentence to documentation.
 
 2011-03-17  Rik  <octave@nomad.inbox5.com>
 
 	* interpreter/io.txi: Add fileread to documentation.
 
 2011-03-17  Rik  <octave@nomad.inbox5.com>
 
@@ -210,18 +210,18 @@ 2011-03-16  Rik  <octave@nomad.inbox5.co
 	documentation.
 
 2011-03-03  Rik  <octave@nomad.inbox5.com>
 
 	* interpreter/matrix.txi: Deprecate is_duplicate_entry.
 
 2011-03-02  Rik  <octave@nomad.inbox5.com>
 
-	* interpreter/stats.txi: Correctly refer to discrete uniform 
-	distribution in documentation. 
+	* interpreter/stats.txi: Correctly refer to discrete uniform
+	distribution in documentation.
 
 2011-03-01  Jordi Gutirrez Hermoso  <jordigh@gmail.com>
 
 	* interpreter/dynamic.txi: Make it clear that <octave/oct.h> is
 	a C++ source file and refer to the section where other languages
 	are discussed.
 
 	* faq/OctaveFAQ.texi: Major update to FAQ. Whitespace changes.
diff --git a/etc/OLD-ChangeLogs/scripts-ChangeLog b/etc/OLD-ChangeLogs/scripts-ChangeLog
--- a/etc/OLD-ChangeLogs/scripts-ChangeLog
+++ b/etc/OLD-ChangeLogs/scripts-ChangeLog
@@ -45,17 +45,17 @@ 2011-04-13  Rik  <octave@nomad.inbox5.co
 2011-04-12  Ben Abbott  <bpabbott@mac.com>
 
 	* miscellaneous/getappdata.m: If no property name is provided, return
 	a structure representing the appdata.
 
 2011-04-12  Marco Caliari  <marco.caliari@univr.it>
 
 	* general/quadgk.m: Fix problem with -Inf bound on integral (bug
-	#33055). 
+	#33055).
 
 2011-04-11  Ben Abbott  <bpabbott@mac.com>
 
 	* miscellaneous/getappdata.m: If appdata propery does not exist, return
 	an empty matrix.
 
 2011-04-08  Rik  <octave@nomad.inbox5.com>
 
@@ -121,17 +121,17 @@ 2011-04-04  Rik  <octave@nomad.inbox5.co
 
 2011-04-04  Rik  <octave@nomad.inbox5.com>
 
 	* deprecated/module.mk, general/module.mk: Deprecate perror, strerror
 	functions.
 
 2011-04-02  Rik  <octave@nomad.inbox5.com>
 
-	* statistics/base/prctile.m, statistics/base/quantile.m: Improve 
+	* statistics/base/prctile.m, statistics/base/quantile.m: Improve
 	docstrings.
 
 2011-03-31  Rik  <octave@nomad.inbox5.com>
 
 	* pkg/module.mk, pkg/pkg.m, pkg/private/get_forge_pkg.m: Add
 	documentation for '-forge' option (bug #32464).  Make get_forge_pkg
 	a private function.
 
@@ -331,17 +331,17 @@ 2011-02-25  Jordi Gutirrez Hermoso  <jordigh@gmail.com>
 
 	* miscellaneous/warnings_ids.m: Add a warning description for
 	Matlab-style short-circuiting
 
 2011-02-24  Ben Abbott  <bpabbott@mac.com>
 
 	* plot/subplot.m: Document using INDEX as a vector.
 
-2011-02-24  Robert T. Short  <rtshort@ieee.org> 
+2011-02-24  Robert T. Short  <rtshort@ieee.org>
 
 	* polynomial/polyval.m: Properly evaluate constant polynomials.
 
 2011-02-24  John W. Eaton  <jwe@octave.org>
 
 	* strings/strchr.m: Avoid implicit string to number conversion.
 	Bug #32546.  From Kim Hansen <kim@i9.dk>.
 
diff --git a/etc/OLD-ChangeLogs/src-ChangeLog b/etc/OLD-ChangeLogs/src-ChangeLog
--- a/etc/OLD-ChangeLogs/src-ChangeLog
+++ b/etc/OLD-ChangeLogs/src-ChangeLog
@@ -281,17 +281,17 @@ 2011-02-13  Konstantinos Poulios  <logar
 
 2011-02-13  Konstantinos Poulios  <logari81@googlemail.com>
 
 	* graphics.h.in (axes::properties::update_boundingbox,
 	axes::properties::update_dataaspectratio,
 	axes::properties::update_dataaspectratiomode,
 	axes::properties::update_plotboxaspectratio,
 	axes::properties::update_plotboxaspectratiomode):
-	Replace update_transform hooks with sync_positions. 
+	Replace update_transform hooks with sync_positions.
 
 2011-02-13  Konstantinos Poulios  <logari81@googlemail.com>
 
 	* graphics.h.in (axes::properties::get_extent,
 	axes::properties::calc_tightbox): New functions prototypes.
 	(axes::properties::update_view): Hook sync_positions.
 	(axes::properties::update_outerposition,
 	axes::properties::update_position): Set activepositionproperty
@@ -606,17 +606,17 @@ 2011-01-28  John W. Eaton  <jwe@octave.o
 
 2011-01-27  Rik  <octave@nomad.inbox5.com>
 
 	* graphics.cc: Improve reset docstring.
 
 2011-01-27  Kai Habel  <kai.habel@gmx.de>
 
 	* DLD-FUNCTIONS/__init_fltk__.cc (__fltk_uigetfile__): Remove here.
-	* DLD-FUNCTIONS/__fltk_uigetfile__.cc: New file. 
+	* DLD-FUNCTIONS/__fltk_uigetfile__.cc: New file.
 	* DLD-FUNCTIONS/module-files: Add __fltk_uigetfile__.cc.
 	Bug #32190.
 
 2011-01-27  John W. Eaton  <jwe@octave.org>
 
 	* DLD-FUNCTIONS/dlmread.cc (Fdlmread): Skip leading whitespace
 	on each line.
 
@@ -674,17 +674,17 @@ 2011-01-26  Pascal Dupuis  <Pascal.Dupui
 	(class callback_event, class set_event): Likewise.
 
 	* graphics.h.in (class base_graphics_property): Disallow copying.
 	* graphics.cc (class function_event): Likewise.
 	(function_event::function_event (void)): Delete implementation.
 
 2011-01-25  Rik  <octave@nomad.inbox5.com>
 
-	* DLD-FUNCTIONS/config-module.awk: Use automake variable for 
+	* DLD-FUNCTIONS/config-module.awk: Use automake variable for
 	portability.
 	* Makefile.am (uninstall-oct): Use GNU Make features for portability
 
 2011-01-25  Rik  <octave@nomad.inbox5.com>
 
 	* DLD-FUNCTIONS/fft.cc, DLD-FUNCTIONS/fft2.cc, DLD-FUNCTIONS/fftn.cc,
 	load-save.cc: Make docstrings static by removing documentation
 	depending on #ifdef configuration variables.
@@ -1388,17 +1388,17 @@ 2010-12-27  Rik  <octave@nomad.inbox5.co
 
 2010-12-26  Michael Godfrey <godfrey@isl.stanford.edu>
 
 	* gammainc.cc: Add @tex blocks to docstring.
 
 2010-12-25  Rik  <octave@nomad.inbox5.com>
 
 	* DLD-FUNCTIONS/str2double.cc: Fix bug in converting "numberi" strings
-	such as "2i".  Add ability to process special value "NA".  Rewrite 
+	such as "2i".  Add ability to process special value "NA".  Rewrite
 	docstring.
 
 2010-12-25  Rik  <octave@nomad.inbox5.com>
 
 	* input.cc (PS1): Correct use of xref macro to remove Tex warning.
 
 2010-12-22  Jordi Gutirrez Hermoso  <jordigh@gmail.com>
 
@@ -1421,17 +1421,17 @@ 2010-12-18  Konstantinos Poulios  <logar
 
 2010-12-18  John W. Eaton  <jwe@octave.org>
 
 	* DLD-FUNCTIONS/dlmread.cc (Fdlmread): Simplify file name/id logic.
 	Bug #31910.
 
 2010-12-17  Rik  <octave@nomad.inbox5.com>
 
-	* oct-parse.yy (builtin): Remove seealso reference to deprecated 
+	* oct-parse.yy (builtin): Remove seealso reference to deprecated
 	function dispatch.
 
 2010-12-17  Konstantinos Poulios  <logari81@googlemail.com>
 
 	* graphics.h.in (class text::properties): New properties positionmode,
 	rotationmode, horizontalalignmentmode, verticalalignmentmode.
 	* graphics.cc (axes::properties::init, axes::properties::set_defaults):
 	Set mode to auto for all initialized positioning properties.
diff --git a/etc/OLD-ChangeLogs/test-ChangeLog b/etc/OLD-ChangeLogs/test-ChangeLog
--- a/etc/OLD-ChangeLogs/test-ChangeLog
+++ b/etc/OLD-ChangeLogs/test-ChangeLog
@@ -1,11 +1,11 @@
 2011-04-11  Rik  <octave@nomad.inbox5.com>
 
-	* fntests.m: Remove deprecated and private functions from list of 
+	* fntests.m: Remove deprecated and private functions from list of
 	functions requiring tests.  Count functions with %!demo blocks as
 	having tests.
 
 2011-04-03  Rik  <octave@nomad.inbox5.com>
 
 	* test_diag_perm.m: Reverse previous changeset.  Return 3-input form
 	of diag().
 
diff --git a/etc/PROJECTS b/etc/PROJECTS
--- a/etc/PROJECTS
+++ b/etc/PROJECTS
@@ -1,11 +1,11 @@
 Octave PROJECTS
 ===============
 
-A list of proposed projects is maintained at: 
-             
+A list of proposed projects is maintained at:
+
              http://wiki.octave.org/Projects
 
 If you start working steadily on a project, please let
 maintainers@octave.org know.  We might have information that could help
 you.  You should also read the Contributing Guidelines chapter in the
 Octave manual.
diff --git a/etc/README.Cygwin b/etc/README.Cygwin
--- a/etc/README.Cygwin
+++ b/etc/README.Cygwin
@@ -1,75 +1,75 @@
 Starting with version 3.0.1, Octave is once again part of the normal
-net distribution of Cygwin, available from http://www.cygwin.com.  
+net distribution of Cygwin, available from http://www.cygwin.com.
 
 It is possible to build Octave from source on Windows systems with Cygwin,
 but with the old gcc-3.4.4-3 compiler there are some performance
 problems related to the way C++ exception handling is implemented.
-This is a known problem with a long history and it is STRONGLY 
+This is a known problem with a long history and it is STRONGLY
 encouraged to use gcc-4.3.2-1 or later.
 
-Current binary versions are built with gcc-4.5.3-3.  
+Current binary versions are built with gcc-4.5.3-3.
 
 
 ------- SUGGESTED CONFIGURATION  ---------------------------
 
 The latest development Octave development sources (octave-3.5.91+)
 are built with:
 
 configure --enable-shared \
           --enable-float-truncate \
-          CC=gcc-4 F77=gfortran-4 CXX=g++-4 CPP=cpp-4 
+          CC=gcc-4 F77=gfortran-4 CXX=g++-4 CPP=cpp-4
           lt_cv_deplibs_check_method=pass_all \
-          LDFLAGS=-Wl,-no-undefined 
+          LDFLAGS=-Wl,-no-undefined
 
 "--enable-float-truncate" is needed for the following bug:
 http://thread.gmane.org/gmane.comp.gnu.octave.bugs/12361/focus=12404
 Without it, one of the quadgk test will fail as
-"a=a" could be false due to truncation problems with 
-complex numbers. 
+"a=a" could be false due to truncation problems with
+complex numbers.
 
 "lt_cv_deplibs_check_method=pass_all"  is needed to bypass
 incorrect libtool detection of system capabilities and
 to allow shared libs building.
 
-"LDFLAGS=-Wl,-no-undefined" is better than previous 
+"LDFLAGS=-Wl,-no-undefined" is better than previous
 "LDFLAGS=-no-undefined" as gcc-4 is now complaining about
 unknown command and the "undefined" is for the linker.
 
-The additional patch used for 3.4.3-3 package can also be 
+The additional patch used for 3.4.3-3 package can also be
 needed for 3.6.x (see below).
 
 ------- SUGGESTION FOR FORK ISSUE --------------------------
 
-The build process can fails in building images for documentation 
-due to fork issue of the octave dll just built. In such case 
+The build process can fails in building images for documentation
+due to fork issue of the octave dll just built. In such case
 I suggest to rebase the built dll's with:
 
 $ find build_tree -name "*.dll"  > rebase_list
 
 and after closing all cygwin process, from a dash shell
 
 $ rebaseall -s 'dll|so|oct' -T /full_path/rebase_list
 
 After rebasing the "make" should be able to complete the
-creation of the images and the documentation. 
+creation of the images and the documentation.
 
------------------------------------------------------- 
+------------------------------------------------------
 
 Octave-3.4.3-3 package was built using:
 
 configure --libexecdir=/usr/lib \
           --enable-shared \
           --enable-float-truncate \
           F77=gfortran-4 \
           lt_cv_deplibs_check_method=pass_all \
-          LDFLAGS=-no-undefined    
+          LDFLAGS=-no-undefined
 
-plus and additional patch to solve a specific cygwin 
+plus and additional patch to solve a specific cygwin
 fltk print issue, see:
 https://savannah.gnu.org/bugs/?31641
 
 Octave-3.2.4 was built using:
 
 configure --enable-shared \
           --without-fltk \
           --without-framework-opengl \
diff --git a/etc/README.MacOS b/etc/README.MacOS
--- a/etc/README.MacOS
+++ b/etc/README.MacOS
@@ -23,17 +23,17 @@ the links below.
   http://ftp.gnu.org/pub/gnu/octave/
 
 Development snapshots, intended for testing, are available from the link
 below.
 
   ftp://alpha.gnu.org/gnu/octave
 
 Links to the stable releases, snap shots, and instructions for obtaining
-the current development sources using mercurial can be found on Octave's 
+the current development sources using mercurial can be found on Octave's
 web-site below.
 
   http://www.octave.org/download.html
 
 Building on MacOS can vary significantly between versions.  These
 instructions document the procedure for MacOS 10.6.X.
 
 
@@ -58,17 +58,17 @@ as well.  However, care must be taken.
     libstdc++.  For a successful build the first file in LDFLAGS must refer to
     this library.  For example, if building with gcc-4.5 obtained from MacPorts
     LDFLAGS would begin as,
 
       export LDFLAGS="/opt/local/lib/gcc45/libstdc++.6.dylib [...]"
 
   * As of MacOS 10.6.6, the 64-bit BLAS routines that are part of Apple's vecLib
     (framework accelerate) are not functioning correctly.  As a work around, an
-    alternative BLAS/LAPACK library, such as ATLAS, must be used.  A bug report 
+    alternative BLAS/LAPACK library, such as ATLAS, must be used.  A bug report
     has been filed with Apple.
 
       http://bugreport.apple.com
       Title: "64 bit ABI issue with libBLAS.dylib"
       Problem ID: 7850167
       Date: April 11, 2010 at 12:04 AM
 
 
@@ -198,52 +198,52 @@ 2.3 Building With Dependencies Satisfied
 To install and setup the Fink package manager see the on line documentation.
 
   http://www.finkproject.org/
 
 Currently, Fink does not have a package available for Octave versions above
 3.0.x.  These instructions will allow the developers sources to be build and
 run, but will not permit Octave to be installed in the usual Fink way.
 
-TODO - When a Fink package is developed for Octave 3.4.x, modify these 
+TODO - When a Fink package is developed for Octave 3.4.x, modify these
        instructions to model the MacPorts section.
 
 
 2.3.1 Dependencies
 ------------------
 
 To build Octave's sources the list of Fink packages below need to be installed.
 
   aquaterm
   arpack
   autoconf (>= 2.6.0)
   automake (>= 1.11)
   fftw3 (>= 3.1.1)
   fftw3-shlibs (>= 3.1.1)
   flex >= 2.5.30
-  fltk-aqua-shlibs 
+  fltk-aqua-shlibs
   glpk-dev
   glpk-shlibs
   gnuplot (>= 4.2.6)
   graphicsmagick (<= 1.3.7)
   graphicsmagick-shlibs (<= 1.3.7)
   hdf5 (>= 1.6.5)
   hdf5-shlibs (>= 1.6.5)
   libcurl4
   libcurl4-shlibs
   libncurses5
   libncurses5-shlibs
-  libtool >= 2.2.2 
+  libtool >= 2.2.2
   ncurses
   pcre
   pcre-shlibs
   qhull
   qrupdate [1]
   readline5
-  readline5-shlibs 
+  readline5-shlibs
   sed
   suitesparse (= 3.1.0-1 )
 
 Some of Octave's dependencies are among the default packages for Fink.  These
 include the list below, and possibly others as well.
 
   tetex
   texinfo
@@ -401,17 +401,17 @@ below (these assume gcc-4.4 is installed
   export LAPACK_LIBS=-llapack
   ./configure --prefix="/opt/local" --without-framework-carbon --with-x
   make
 
 Octave's integrated tests may be run.
 
   make check
 
-"make install" should not be run as it will bypass the macports package 
+"make install" should not be run as it will bypass the macports package
 management.  To run Octave, type the command below from the root of the
 mercurial archive.
 
   ./run-octave
 
 
 John W. Eaton
 jwe@octave.org
diff --git a/etc/README.MinGW b/etc/README.MinGW
--- a/etc/README.MinGW
+++ b/etc/README.MinGW
@@ -13,45 +13,45 @@ The process for building Octave from sou
  * Install development tools and compiler
  * Install or compile dependencies of Octave
  * Download Octave source
  * Configure and compile source
 
 We strongly encourage experienced users to build Octave from the
 testing and development snapshots to try the latest features of Octave.
 
-A good tutorial on building Octave for version 3.2 is available from 
-http://octave.svn.sourceforge.net/viewvc/octave/trunk/octave-forge/admin/Windows/mingw32/HOWTO.txt 
+A good tutorial on building Octave for version 3.2 is available from
+http://octave.svn.sourceforge.net/viewvc/octave/trunk/octave-forge/admin/Windows/mingw32/HOWTO.txt
 
 Additional information beyond the tutorial is summarized below.
 
  2.1 Development tools and compiler
  ----------------------
  Msys + MinGW development Tools
 
  The Msys + MinGW development Tools are required to build Octave from source.
 
  The latest version of the Msys system is 1.0.16.  For MinGW, search and use
  the most recent version available.  Note: The Howto.txt file describing
  the development tools is rather old.
 
  The latest GCC (GNU Complier Collection) for MinGW is gcc-4.5.0.  Earlier
  versions are not recommended for building Octave 3.4.xx.
 
- The latest Msys, MinGW, and GCC tools can be downloaded from 
- http://sourceforge.net/projects/mingw/files/ 
+ The latest Msys, MinGW, and GCC tools can be downloaded from
+ http://sourceforge.net/projects/mingw/files/
 
  (Compiling for 64-bit binaries requires mingw-64 toolkits.  This has not been
   tested.)
 
  2.2 Dependencies
  ----------------------
 
  External program dependencies
- 
+
   * gnuplot (you can build this with the shell script mentioned in Howto.txt)
   * MikTeX
   * ghostscript
   * pstoedit (required for printing using FLTK (OpenGL) graphics)
   * fig2dev (Optional; better quality for FLTK printing in some file formats)
   * sed
   * less
 
@@ -68,41 +68,41 @@ Additional information beyond the tutori
 
   Please read Howto.txt carefully on how to build them.  The Howto.txt is old
   so some revisions will be required when using GCC-4.5.0
 
  2.3 Download Octave source
  ----------------------
 
   The source for testing snapshots can be downloaded from the official Octave
-  web site.  http://www.octave.org/download.html 
+  web site.  http://www.octave.org/download.html
 
   The very latest development code is also available via anonymous access to a
   read-only Mercurial archive.  The method of download is described on the web
   site.  You will also need to install gnulib as another dependency.  Please
   visit http://www.gnu.org/software/gnulib/ and download sources using git.
 
  2.4 Configure and compile source
  ----------------------
 
   Building from source can be carried out using the script described in
-  Howto.txt.  
-  
+  Howto.txt.
+
   When using GCC-4.5.0, remove flags for shared libstdc++ because a shared
   build is already the default.
 
-  When running './configure', you must add '--enable-float-truncate' option. 
-  Please see the following thread for more information: 
+  When running './configure', you must add '--enable-float-truncate' option.
+  Please see the following thread for more information:
   http://thread.gmane.org/gmane.comp.gnu.octave.bugs/12361/focus=12404
 
   To build development sources from the Mercurial repository you must run
   bootstrap before running configure and make.  This requires
   that automake and autoconf tools be installed.
 
 
 Tatsuro MATSUOKA
 tmacchant@yahoo.co.jp
 
 Benjamin Lindner
-bjmldn@gmail.com 
+bjmldn@gmail.com
 
 
 Last updated: Sat Jan 22 17:29:12 PST 2011
diff --git a/etc/README.gnuplot b/etc/README.gnuplot
--- a/etc/README.gnuplot
+++ b/etc/README.gnuplot
@@ -1,12 +1,12 @@
 Octave works best with gnuplot 4.4 or higher, which is available from
 http://www.gnuplot.info.
 
 In versions prior to 4.2.6 it is not possible to use the mouse to zoom in
 on plots.  This is a limitation of earlier versions of gnuplot, which are
-unable to zoom when the data it plots is not stored in a file. 
+unable to zoom when the data it plots is not stored in a file.
 
 
 John W. Eaton
 jwe@octave.org
 
 Last updated: Tue Jan  4 18:55:56 PST 2011
diff --git a/etc/gdbinit b/etc/gdbinit
--- a/etc/gdbinit
+++ b/etc/gdbinit
@@ -4,40 +4,40 @@
 set print thread-events off
 
 ## Helpful macros for debugging Octave.
 
 ############################################################
 ## Display a dim-vector object.
 
 define display-dims
-  echo ndims: \ 
+  echo ndims: \
   output $arg0.rep[-1]
-  echo \ndims: \ 
+  echo \ndims: \
   output *$arg0.rep@$arg0.rep[-1]
   echo \n
   dont-repeat
 end
 
 document display-dims
 Usage: display-dims DIM_VECTOR
 Display the contents of an Octave dimension vector.
 end
 
 ############################################################
 ## Display a dense array object.
 
 define display-dense-array
-  echo array object: \ 
+  echo array object: \
   output $arg0
   echo \ndimensions:\n
   display-dims $arg0.dimensions
-  echo \nrep = \ 
+  echo \nrep = \
   output *$arg0.rep
-  echo \nrep.data = \ 
+  echo \nrep.data = \
   output *$arg0.rep.data@$arg0.rep.len
   echo \n
   dont-repeat
 end
 
 document display-dense-array
 Usage: display-dense-array ARRAY
 Display the contents of an ordinary, i.e., dense Octave array.
@@ -45,45 +45,45 @@ Display the contents of an ordinary, i.e
 See also [display-sparse-array] for showing the contents
 of sparse Octave arrays.
 end
 
 ############################################################
 ## Display a sparse array object.
 
 define display-sparse-array
-  echo sparse object: \ 
+  echo sparse object: \
   output $arg0
-  echo \ndimensions.rep[0] = \ 
+  echo \ndimensions.rep[0] = \
   display-dims $arg0.dimensions
-  echo \ndimensions.rep[1] = \ 
+  echo \ndimensions.rep[1] = \
   output $arg0.dimensions.rep[1]
-  echo \nrep = \ 
+  echo \nrep = \
   output *$arg0.rep
-  echo \nrep.d = \ 
+  echo \nrep.d = \
   output *$arg0.rep.d@$arg0.rep.nzmx
-  echo \nrep.r = \ 
+  echo \nrep.r = \
   output *$arg0.rep.r@$arg0.rep.nzmx
-  echo \nrep.c = \ 
+  echo \nrep.c = \
   output *$arg0.rep.c@($arg0.rep.ncols+1)
   echo \n
   dont-repeat
 end
 
 document display-sparse-array
 Usage: display-sparse-array SPARSE_ARRAY
 Display the contents of a sparse Octave array.
 
 See also [display-dense-array] for showing the contents
 of ordinary Octave arrays.
 end
 
 ############################################################
 
-## Display Octave debugging stack 
+## Display Octave debugging stack
 
 define show-octave-dbstack
   call show_octave_dbstack ()
 end
 
 document show-octave-dbstack
 Usage: show-octave-dbstack
 Display the contents of the current Octave debugging stack.
diff --git a/etc/icons/Makefile.am b/etc/icons/Makefile.am
--- a/etc/icons/Makefile.am
+++ b/etc/icons/Makefile.am
@@ -1,24 +1,24 @@
 # Makefile for Octave's doc/icons directory
 #
 # Copyright (C) 2012-2013 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
 IMAGE_FILES = \
   octave-logo.ico \
diff --git a/examples/@polynomial/end.m b/examples/@polynomial/end.m
--- a/examples/@polynomial/end.m
+++ b/examples/@polynomial/end.m
@@ -1,9 +1,9 @@
 function r = end (obj, index_pos, num_indices)
 
   if (num_indices != 1)
     error ("polynomial object may only have one index")
   endif
-  
+
   r = length (obj.poly) - 1;
 
 endfunction
diff --git a/examples/@polynomial/subsasgn.m b/examples/@polynomial/subsasgn.m
--- a/examples/@polynomial/subsasgn.m
+++ b/examples/@polynomial/subsasgn.m
@@ -5,17 +5,17 @@ function p = subsasgn (p, s, val)
   switch (s(1).type)
     case "{}"
       ind = s(1).subs;
       if (numel (ind) != 1)
         error ("polynomial: need exactly one index");
       else
         if (length (s) == 1)
           if (isnumeric (ind{1}))
-            p.poly(ind{1}+1) = val; 
+            p.poly(ind{1}+1) = val;
           else
             p.poly(ind{1}) = val;
           endif
         else
           error ("polynomial: chained subscripts not allowed for {}");
         endif
       endif
     case "."
diff --git a/examples/Makefile.am b/examples/Makefile.am
--- a/examples/Makefile.am
+++ b/examples/Makefile.am
@@ -1,31 +1,31 @@
 # Makefile for Octave's examples directory
 #
 # Copyright (C) 1996-2013 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
-EXTRA_DIST = 
+EXTRA_DIST =
 
 FCN_FILE_DIRS =
 
 FCN_FILES =
 
 include @polynomial/module.mk
 include @FIRfilter/module.mk
 
diff --git a/examples/standalonebuiltin.cc b/examples/standalonebuiltin.cc
--- a/examples/standalonebuiltin.cc
+++ b/examples/standalonebuiltin.cc
@@ -7,22 +7,22 @@ main (void)
 {
   int n = 2;
   Matrix a_matrix = Matrix (n, n);
 
   for (octave_idx_type i = 0; i < n; i++)
     for (octave_idx_type j = 0; j < n; j++)
       a_matrix(i,j) = (i + 1) * 10 + (j + 1);
 
-  std::cout << "This is a matrix:" << std::endl 
+  std::cout << "This is a matrix:" << std::endl
             << a_matrix            << std::endl;
 
   octave_value_list in;
   in(0) = a_matrix;
 
   octave_value_list out = Fnorm (in, 1);
   double norm_of_the_matrix = out(0).double_value ();
 
-  std::cout << "This is the norm of the matrix:" << std::endl 
+  std::cout << "This is the norm of the matrix:" << std::endl
             << norm_of_the_matrix                << std::endl;
-  
+
   return 0;
 }
diff --git a/libgui/Makefile.am b/libgui/Makefile.am
--- a/libgui/Makefile.am
+++ b/libgui/Makefile.am
@@ -54,17 +54,17 @@ noinst_HEADERS =
 noinst_LTLIBRARIES =
 
 include src/module.mk
 include graphics/module.mk
 include qterminal-module.mk
 
 ## liboctgui merely collects a bunch of compiled convenience libraries.
 ## It has no source code itself.
-liboctgui_la_SOURCES = 
+liboctgui_la_SOURCES =
 
 include link-deps.mk
 
 # Dummy C++ source to force C++ linking.
 nodist_EXTRA_liboctgui_la_SOURCES = dummy.cc
 
 liboctgui_la_LIBADD = \
   qterminal/libqterminal.la \
diff --git a/libgui/qterminal/libqterminal/README b/libgui/qterminal/libqterminal/README
--- a/libgui/qterminal/libqterminal/README
+++ b/libgui/qterminal/libqterminal/README
@@ -1,7 +1,7 @@
 lib.pro is a *.pro-file for qmake
 
-It produces static lib (libqtermwidget.a) only. 
+It produces static lib (libqtermwidget.a) only.
 For creating shared lib (*.so) uncomment "dll" in "CONFIG" line in *.pro-file
 
-Library was tested both with HAVE_POSIX_OPENPT and HAVE_GETPT precompiler directives, 
-defined in "DEFINES" line. You should select variant which would be correct for your system.
\ No newline at end of file
+Library was tested both with HAVE_POSIX_OPENPT and HAVE_GETPT precompiler directives,
+defined in "DEFINES" line. You should select variant which would be correct for your system.
diff --git a/libgui/qterminal/libqterminal/unix/BlockArray.cpp b/libgui/qterminal/libqterminal/unix/BlockArray.cpp
--- a/libgui/qterminal/libqterminal/unix/BlockArray.cpp
+++ b/libgui/qterminal/libqterminal/unix/BlockArray.cpp
@@ -112,17 +112,17 @@ const Block* BlockArray::at(size_t i)
 
     if (i == lastmap_index)
         return lastmap;
 
     if (i > index) {
         qDebug() << "BlockArray::at() i > index\n";
         return 0;
     }
-    
+
 //     if (index - i >= length) {
 //         kDebug(1211) << "BlockArray::at() index - i >= length\n";
 //         return 0;
 //     }
 
     size_t j = i; // (current - (index - i) + (index/size+1)*size) % size ;
 
     assert(j < size);
diff --git a/libgui/qterminal/libqterminal/unix/BlockArray.h b/libgui/qterminal/libqterminal/unix/BlockArray.h
--- a/libgui/qterminal/libqterminal/unix/BlockArray.h
+++ b/libgui/qterminal/libqterminal/unix/BlockArray.h
@@ -1,12 +1,12 @@
 /*
     This file is part of Konsole, an X terminal.
     Copyright (C) 2000, 2013 by Stephan Kulow <coolo@kde.org>
-   
+
     Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
diff --git a/libgui/qterminal/libqterminal/unix/Character.h b/libgui/qterminal/libqterminal/unix/Character.h
--- a/libgui/qterminal/libqterminal/unix/Character.h
+++ b/libgui/qterminal/libqterminal/unix/Character.h
@@ -1,11 +1,11 @@
 /*
     This file is part of Konsole, KDE's terminal.
-    
+
     Copyright (C) 2007, 2013 by Robert Knight <robertknight@gmail.com>
     Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
 
     Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
@@ -50,17 +50,17 @@ static const int LINE_DOUBLEHEIGHT	= (1 
 /**
  * A single character in the terminal which consists of a unicode character
  * value, foreground and background colors and a set of rendition attributes
  * which specify how it should be drawn.
  */
 class Character
 {
 public:
-  /** 
+  /**
    * Constructs a new character.
    *
    * @param _c The unicode character value of this character.
    * @param _f The foreground color used to draw the character.
    * @param _b The color used to draw the character's background.
    * @param _r A set of rendition flags which specify how this character is to be drawn.
    */
   inline Character(quint16 _c = ' ',
@@ -68,79 +68,79 @@ public:
             CharacterColor  _b = CharacterColor(COLOR_SPACE_DEFAULT,DEFAULT_BACK_COLOR),
             quint8  _r = DEFAULT_RENDITION)
        : character(_c), rendition(_r), foregroundColor(_f), backgroundColor(_b) {}
 
   union
   {
     /** The unicode character value for this character. */
     quint16 character;
-    /** 
+    /**
      * Experimental addition which allows a single Character instance to contain more than
      * one unicode character.
      *
      * charSequence is a hash code which can be used to look up the unicode
      * character sequence in the ExtendedCharTable used to create the sequence.
      */
-    quint16 charSequence; 
+    quint16 charSequence;
   };
 
   /** A combination of RENDITION flags which specify options for drawing the character. */
   quint8  rendition;
 
   /** The foreground color used to draw this character. */
-  CharacterColor  foregroundColor; 
+  CharacterColor  foregroundColor;
   /** The color used to draw this character's background. */
   CharacterColor  backgroundColor;
 
-  /** 
+  /**
    * Returns true if this character has a transparent background when
    * it is drawn with the specified @p palette.
    */
   bool   isTransparent(const ColorEntry* palette) const;
   /**
    * Returns true if this character should always be drawn in bold when
    * it is drawn with the specified @p palette, independent of whether
-   * or not the character has the RE_BOLD rendition flag. 
+   * or not the character has the RE_BOLD rendition flag.
    */
   bool   isBold(const ColorEntry* base) const;
-  
-  /** 
+
+  /**
    * Compares two characters and returns true if they have the same unicode character value,
    * rendition and colors.
    */
   friend bool operator == (const Character& a, const Character& b);
   /**
    * Compares two characters and returns true if they have different unicode character values,
    * renditions or colors.
    */
   friend bool operator != (const Character& a, const Character& b);
 };
 
 inline bool operator == (const Character& a, const Character& b)
-{ 
-  return a.character == b.character && 
-         a.rendition == b.rendition && 
-         a.foregroundColor == b.foregroundColor && 
+{
+  return a.character == b.character &&
+         a.rendition == b.rendition &&
+         a.foregroundColor == b.foregroundColor &&
          a.backgroundColor == b.backgroundColor;
 }
 
 inline bool operator != (const Character& a, const Character& b)
 {
-  return    a.character != b.character || 
-            a.rendition != b.rendition || 
-            a.foregroundColor != b.foregroundColor || 
+  return    a.character != b.character ||
+            a.rendition != b.rendition ||
+            a.foregroundColor != b.foregroundColor ||
             a.backgroundColor != b.backgroundColor;
 }
 
 inline bool Character::isTransparent(const ColorEntry* base) const
 {
-  return ((backgroundColor._colorSpace == COLOR_SPACE_DEFAULT) && 
+  return ((backgroundColor._colorSpace == COLOR_SPACE_DEFAULT) &&
           base[backgroundColor._u+0+(backgroundColor._v?BASE_COLORS:0)].transparent)
-      || ((backgroundColor._colorSpace == COLOR_SPACE_SYSTEM) && 
+      || ((backgroundColor._colorSpace == COLOR_SPACE_SYSTEM) &&
           base[backgroundColor._u+2+(backgroundColor._v?BASE_COLORS:0)].transparent);
 }
 
 inline bool Character::isBold(const ColorEntry* base) const
 {
   return ((backgroundColor._colorSpace == COLOR_SPACE_DEFAULT) &&
             base[backgroundColor._u+0+(backgroundColor._v?BASE_COLORS:0)].bold)
       || ((backgroundColor._colorSpace == COLOR_SPACE_SYSTEM) &&
@@ -175,29 +175,29 @@ public:
      * @param length Length of @p unicodePoints
      */
     ushort createExtendedChar(ushort* unicodePoints , ushort length);
     /**
      * Looks up and returns a pointer to a sequence of unicode characters
      * which was added to the table using createExtendedChar().
      *
      * @param hash The hash key returned by createExtendedChar()
-     * @param length This variable is set to the length of the 
+     * @param length This variable is set to the length of the
      * character sequence.
      *
      * @return A unicode character sequence of size @p length.
      */
     ushort* lookupExtendedChar(ushort hash , ushort& length) const;
 
     /** The global ExtendedCharTable instance. */
     static ExtendedCharTable instance;
 private:
     // calculates the hash key of a sequence of unicode points of size 'length'
     ushort extendedCharHash(ushort* unicodePoints , ushort length) const;
-    // tests whether the entry in the table specified by 'hash' matches the 
+    // tests whether the entry in the table specified by 'hash' matches the
     // character sequence 'unicodePoints' of size 'length'
     bool extendedCharMatch(ushort hash , ushort* unicodePoints , ushort length) const;
     // internal, maps hash keys to character sequence buffers.  The first ushort
     // in each value is the length of the buffer, followed by the ushorts in the buffer
     // themselves.
     QHash<ushort,ushort*> extendedCharTable;
 };
 
diff --git a/libgui/qterminal/libqterminal/unix/CharacterColor.h b/libgui/qterminal/libqterminal/unix/CharacterColor.h
--- a/libgui/qterminal/libqterminal/unix/CharacterColor.h
+++ b/libgui/qterminal/libqterminal/unix/CharacterColor.h
@@ -1,11 +1,11 @@
 /*
     This file is part of Konsole, KDE's terminal.
-    
+
     Copyright (C) 2007, 2013 by Robert Knight <robertknight@gmail.com>
     Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
 
     Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
@@ -23,70 +23,70 @@
 */
 
 #ifndef CHARACTERCOLOR_H
 #define CHARACTERCOLOR_H
 
 // Qt
 #include <QColor>
 
-/** 
- * An entry in a terminal display's color palette. 
+/**
+ * An entry in a terminal display's color palette.
  *
  * A color palette is an array of 16 ColorEntry instances which map
  * system color indexes (from 0 to 15) into actual colors.
  *
  * Each entry can be set as bold, in which case any text
- * drawn using the color should be drawn in bold.  
+ * drawn using the color should be drawn in bold.
  *
  * Each entry can also be transparent, in which case the terminal
  * display should avoid drawing the background for any characters
  * using the entry as a background.
  */
 class ColorEntry
 {
 public:
-  /** 
+  /**
    * Constructs a new color palette entry.
    *
    * @param c The color value for this entry.
    * @param tr Specifies that the color should be transparent when used as a background color.
    * @param b Specifies that text drawn with this color should be bold.
    */
   ColorEntry(QColor c, bool tr, bool b) : color(c), transparent(tr), bold(b) {}
 
   /**
    * Constructs a new color palette entry with an undefined color, and
    * with the transparent and bold flags set to false.
-   */ 
-  ColorEntry() : transparent(false), bold(false) {} 
- 
+   */
+  ColorEntry() : transparent(false), bold(false) {}
+
   /**
    * Sets the color, transparency and boldness of this color to those of @p rhs.
-   */ 
-  void operator=(const ColorEntry& rhs) 
-  { 
-       color = rhs.color; 
-       transparent = rhs.transparent; 
-       bold = rhs.bold; 
+   */
+  void operator=(const ColorEntry& rhs)
+  {
+       color = rhs.color;
+       transparent = rhs.transparent;
+       bold = rhs.bold;
   }
 
   /** The color value of this entry for display. */
   QColor color;
 
-  /** 
-   * If true character backgrounds using this color should be transparent. 
+  /**
+   * If true character backgrounds using this color should be transparent.
    * This is not applicable when the color is used to render text.
    */
   bool   transparent;
   /**
    * If true characters drawn using this color should be bold.
    * This is not applicable when the color is used to draw a character's background.
    */
-  bool   bold;        
+  bool   bold;
 };
 
 
 // Attributed Character Representations ///////////////////////////////
 
 // Colors
 
 #define BASE_COLORS   (2+8)
@@ -141,108 +141,108 @@ static const ColorEntry base_color_table
  * Describes the color of a single character in the terminal.
  */
 class CharacterColor
 {
     friend class Character;
 
 public:
   /** Constructs a new CharacterColor whoose color and color space are undefined. */
-  CharacterColor() 
-      : _colorSpace(COLOR_SPACE_UNDEFINED), 
-        _u(0), 
-        _v(0), 
-        _w(0) 
+  CharacterColor()
+      : _colorSpace(COLOR_SPACE_UNDEFINED),
+        _u(0),
+        _v(0),
+        _w(0)
   {}
 
-  /** 
-   * Constructs a new CharacterColor using the specified @p colorSpace and with 
+  /**
+   * Constructs a new CharacterColor using the specified @p colorSpace and with
    * color value @p co
    *
    * The meaning of @p co depends on the @p colorSpace used.
    *
    * TODO : Document how @p co relates to @p colorSpace
    *
    * TODO : Add documentation about available color spaces.
    */
-  CharacterColor(quint8 colorSpace, int co) 
-      : _colorSpace(colorSpace), 
-        _u(0), 
-        _v(0), 
+  CharacterColor(quint8 colorSpace, int co)
+      : _colorSpace(colorSpace),
+        _u(0),
+        _v(0),
         _w(0)
   {
     switch (colorSpace)
     {
         case COLOR_SPACE_DEFAULT:
             _u = co & 1;
             break;
         case COLOR_SPACE_SYSTEM:
             _u = co & 7;
             _v = (co >> 3) & 1;
             break;
-        case COLOR_SPACE_256:  
+        case COLOR_SPACE_256:
             _u = co & 255;
             break;
         case COLOR_SPACE_RGB:
             _u = co >> 16;
             _v = co >> 8;
             _w = co;
             break;
         default:
             _colorSpace = COLOR_SPACE_UNDEFINED;
     }
   }
 
-  /** 
+  /**
    * Returns true if this character color entry is valid.
    */
-  bool isValid() 
+  bool isValid()
   {
         return _colorSpace != COLOR_SPACE_UNDEFINED;
   }
-    
-  /** 
+
+  /**
    * Toggles the value of this color between a normal system color and the corresponding intensive
    * system color.
-   * 
+   *
    * This is only applicable if the color is using the COLOR_SPACE_DEFAULT or COLOR_SPACE_SYSTEM
    * color spaces.
    */
   void toggleIntensive();
 
-  /** 
+  /**
    * Returns the color within the specified color @palette
    *
    * The @p palette is only used if this color is one of the 16 system colors, otherwise
    * it is ignored.
    */
   QColor color(const ColorEntry* palette) const;
- 
-  /** 
+
+  /**
    * Compares two colors and returns true if they represent the same color value and
    * use the same color space.
    */
   friend bool operator == (const CharacterColor& a, const CharacterColor& b);
   /**
    * Compares two colors and returns true if they represent different color values
    * or use different color spaces.
    */
   friend bool operator != (const CharacterColor& a, const CharacterColor& b);
 
 private:
   quint8 _colorSpace;
 
-  // bytes storing the character color 
-  quint8 _u; 
-  quint8 _v; 
-  quint8 _w; 
+  // bytes storing the character color
+  quint8 _u;
+  quint8 _v;
+  quint8 _w;
 };
 
 inline bool operator == (const CharacterColor& a, const CharacterColor& b)
-{ 
+{
     return a._colorSpace == b._colorSpace &&
 	       a._u == b._u &&
 	       a._v == b._v &&
            a._w == b._w;
 }
 
 inline bool operator != (const CharacterColor& a, const CharacterColor& b)
 {
@@ -254,17 +254,17 @@ inline const QColor color256(quint8 u, c
   //   0.. 16: system colors
   if (u <   8) return base[u+2            ].color; u -= 8;
   if (u <   8) return base[u+2+BASE_COLORS].color; u -= 8;
 
   //  16..231: 6x6x6 rgb color cube
   if (u < 216) return QColor(255*((u/36)%6)/5,
                              255*((u/ 6)%6)/5,
                              255*((u/ 1)%6)/5); u -= 216;
-  
+
   // 232..255: gray, leaving out black and white
   int gray = u*10+8; return QColor(gray,gray,gray);
 }
 
 inline QColor CharacterColor::color(const ColorEntry* base) const
 {
   switch (_colorSpace)
   {
diff --git a/libgui/qterminal/libqterminal/unix/Emulation.cpp b/libgui/qterminal/libqterminal/unix/Emulation.cpp
--- a/libgui/qterminal/libqterminal/unix/Emulation.cpp
+++ b/libgui/qterminal/libqterminal/unix/Emulation.cpp
@@ -1,12 +1,12 @@
 /*
     This file is part of Konsole, an X terminal.
 
-    Copyright (C) 2007, 2013 Robert Knight <robertknight@gmail.com> 
+    Copyright (C) 2007, 2013 Robert Knight <robertknight@gmail.com>
     Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
     Copyright (C) 1996, 2013 by Matthias Ettrich <ettrich@kde.org>
 
     Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
@@ -59,19 +59,19 @@ Emulation::Emulation() :
 
   // create screens with a default size
   _screen[0] = new Screen(40,80);
   _screen[1] = new Screen(40,80);
   _currentScreen = _screen[0];
 
   QObject::connect(&_bulkTimer1, SIGNAL(timeout()), this, SLOT(showBulk()) );
   QObject::connect(&_bulkTimer2, SIGNAL(timeout()), this, SLOT(showBulk()) );
-   
+
   // listen for mouse status changes
-  connect( this , SIGNAL(programUsesMouseChanged(bool)) , 
+  connect( this , SIGNAL(programUsesMouseChanged(bool)) ,
            SLOT(usesMouseChanged(bool)) );
 }
 
 bool Emulation::programUsesMouse() const
 {
     return _usesMouse;
 }
 
@@ -113,17 +113,17 @@ Emulation::~Emulation()
 
 /*! change between primary and alternate _screen
 */
 
 void Emulation::setScreen(int n)
 {
   Screen *old = _currentScreen;
   _currentScreen = _screen[n&1];
-  if (_currentScreen != old) 
+  if (_currentScreen != old)
   {
      old->setBusySelecting(false);
 
      // tell all windows onto this emulation to switch to the newly active _screen
      QListIterator<ScreenWindow*> windowIter(_windows);
      while ( windowIter.hasNext() )
      {
          windowIter.next()->setScreen(_currentScreen);
@@ -213,17 +213,17 @@ void Emulation::receiveChar(int c)
 /* ------------------------------------------------------------------------- */
 
 /*!
 */
 
 void Emulation::sendKeyEvent( QKeyEvent* ev )
 {
   emit stateSet(NOTIFYNORMAL);
-  
+
   if (!ev->text().isEmpty())
   { // A block of text
     // Note that the text is proper unicode.
     // We should do a conversion here, but since this
     // routine will never be used, we simply emit plain ascii.
     //emit sendBlock(ev->text().toAscii(),ev->text().length());
     emit sendData(ev->text().toUtf8(),ev->text().length());
   }
@@ -258,19 +258,19 @@ void Emulation::receiveData(const char* 
         for (int i=0;i<unicodeText.length();i++)
 	{
                 receiveChar(unicodeText[i].unicode());
 	}
 }
 
 // Selection --------------------------------------------------------------- --
 
-void Emulation::writeToStream( TerminalCharacterDecoder* _decoder , 
+void Emulation::writeToStream( TerminalCharacterDecoder* _decoder ,
                                int startLine ,
-                               int endLine) 
+                               int endLine)
 {
   _currentScreen->writeToStream(_decoder,startLine,endLine);
 }
 
 int Emulation::lineCount()
 {
     // sum number of lines currently on _screen plus number of lines in history
     return _currentScreen->getLines() + _currentScreen->getHistLines();
@@ -337,59 +337,59 @@ ushort ExtendedCharTable::extendedCharHa
         hash = 31*hash + unicodePoints[i];
     }
     return hash;
 }
 bool ExtendedCharTable::extendedCharMatch(ushort hash , ushort* unicodePoints , ushort length) const
 {
     ushort* entry = extendedCharTable[hash];
 
-    // compare given length with stored sequence length ( given as the first ushort in the 
-    // stored buffer ) 
-    if ( entry == 0 || entry[0] != length ) 
+    // compare given length with stored sequence length ( given as the first ushort in the
+    // stored buffer )
+    if ( entry == 0 || entry[0] != length )
        return false;
     // if the lengths match, each character must be checked.  the stored buffer starts at
     // entry[1]
     for ( int i = 0 ; i < length ; i++ )
     {
         if ( entry[i+1] != unicodePoints[i] )
-           return false; 
-    } 
+           return false;
+    }
     return true;
 }
 ushort ExtendedCharTable::createExtendedChar(ushort* unicodePoints , ushort length)
 {
     // look for this sequence of points in the table
     ushort hash = extendedCharHash(unicodePoints,length);
 
     // check existing entry for match
     while ( extendedCharTable.contains(hash) )
     {
         if ( extendedCharMatch(hash,unicodePoints,length) )
         {
-            // this sequence already has an entry in the table, 
+            // this sequence already has an entry in the table,
             // return its hash
             return hash;
         }
         else
         {
             // if hash is already used by another, different sequence of unicode character
             // points then try next hash
             hash++;
         }
-    }    
+    }
 
-    
+
      // add the new sequence to the table and
      // return that index
     ushort* buffer = new ushort[length+1];
     buffer[0] = length;
     for ( int i = 0 ; i < length ; i++ )
-       buffer[i+1] = unicodePoints[i]; 
-    
+       buffer[i+1] = unicodePoints[i];
+
     extendedCharTable.insert(hash,buffer);
 
     return hash;
 }
 
 ushort* ExtendedCharTable::lookupExtendedChar(ushort hash , ushort& length) const
 {
     // lookup index in table and if found, set the length
diff --git a/libgui/qterminal/libqterminal/unix/Emulation.h b/libgui/qterminal/libqterminal/unix/Emulation.h
--- a/libgui/qterminal/libqterminal/unix/Emulation.h
+++ b/libgui/qterminal/libqterminal/unix/Emulation.h
@@ -1,11 +1,11 @@
 /*
     This file is part of Konsole, an X terminal.
-    
+
     Copyright (C) 2007, 2013 by Robert Knight <robertknight@gmail.com>
     Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
 
     Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
@@ -23,272 +23,272 @@
 */
 
 #ifndef EMULATION_H
 #define EMULATION_H
 
 // System
 #include <stdio.h>
 
-// Qt 
+// Qt
 #include <QKeyEvent>
 
 #include <QtCore/QTextCodec>
 #include <QtCore/QTextStream>
 #include <QtCore/QTimer>
 
 class KeyboardTranslator;
 class HistoryType;
 class Screen;
 class ScreenWindow;
 class TerminalCharacterDecoder;
 
-/** 
- * This enum describes the available states which 
+/**
+ * This enum describes the available states which
  * the terminal emulation may be set to.
  *
- * These are the values used by Emulation::stateChanged() 
+ * These are the values used by Emulation::stateChanged()
  */
-enum 
-{ 
+enum
+{
     /** The emulation is currently receiving user input. */
-    NOTIFYNORMAL=0, 
-    /** 
+    NOTIFYNORMAL=0,
+    /**
      * The terminal program has triggered a bell event
      * to get the user's attention.
      */
-    NOTIFYBELL=1, 
-    /** 
-     * The emulation is currently receiving data from its 
+    NOTIFYBELL=1,
+    /**
+     * The emulation is currently receiving data from its
      * terminal input.
      */
     NOTIFYACTIVITY=2,
 
-    // unused here? 
-    NOTIFYSILENCE=3 
+    // unused here?
+    NOTIFYSILENCE=3
 };
 
 /**
  * Base class for terminal emulation back-ends.
  *
- * The back-end is responsible for decoding an incoming character stream and 
+ * The back-end is responsible for decoding an incoming character stream and
  * producing an output image of characters.
  *
  * When input from the terminal is received, the receiveData() slot should be called with
- * the data which has arrived.  The emulation will process the data and update the 
+ * the data which has arrived.  The emulation will process the data and update the
  * screen image accordingly.  The codec used to decode the incoming character stream
- * into the unicode characters used internally can be specified using setCodec() 
+ * into the unicode characters used internally can be specified using setCodec()
  *
- * The size of the screen image can be specified by calling setImageSize() with the 
+ * The size of the screen image can be specified by calling setImageSize() with the
  * desired number of lines and columns.  When new lines are added, old content
- * is moved into a history store, which can be set by calling setHistory(). 
+ * is moved into a history store, which can be set by calling setHistory().
  *
- * The screen image can be accessed by creating a ScreenWindow onto this emulation 
- * by calling createWindow().  Screen windows provide access to a section of the 
- * output.  Each screen window covers the same number of lines and columns as the 
+ * The screen image can be accessed by creating a ScreenWindow onto this emulation
+ * by calling createWindow().  Screen windows provide access to a section of the
+ * output.  Each screen window covers the same number of lines and columns as the
  * image size returned by imageSize().  The screen window can be moved up and down
- * and provides transparent access to both the current on-screen image and the 
+ * and provides transparent access to both the current on-screen image and the
  * previous output.  The screen windows emit an outputChanged signal
  * when the section of the image they are looking at changes.
  * Graphical views can then render the contents of a screen window, listening for notifications
- * of output changes from the screen window which they are associated with and updating 
- * accordingly. 
+ * of output changes from the screen window which they are associated with and updating
+ * accordingly.
  *
  * The emulation also is also responsible for converting input from the connected views such
  * as keypresses and mouse activity into a character string which can be sent
  * to the terminal program.  Key presses can be processed by calling the sendKeyEvent() slot,
  * while mouse events can be processed using the sendMouseEvent() slot.  When the character
  * stream has been produced, the emulation will emit a sendData() signal with a pointer
  * to the character buffer.  This data should be fed to the standard input of the terminal
  * process.  The translation of key presses into an output character stream is performed
  * using a lookup in a set of key bindings which map key sequences to output
  * character sequences.  The name of the key bindings set used can be specified using
  * setKeyBindings()
  *
- * The emulation maintains certain state information which changes depending on the 
- * input received.  The emulation can be reset back to its starting state by calling 
- * reset().  
+ * The emulation maintains certain state information which changes depending on the
+ * input received.  The emulation can be reset back to its starting state by calling
+ * reset().
  *
  * The emulation also maintains an activity state, which specifies whether
  * terminal is currently active ( when data is received ), normal
  * ( when the terminal is idle or receiving user input ) or trying
  * to alert the user ( also known as a "Bell" event ).  The stateSet() signal
  * is emitted whenever the activity state is set.  This can be used to determine
  * how long the emulation has been active/idle for and also respond to
  * a 'bell' event in different ways.
  */
 class Emulation : public QObject
-{ 
+{
 Q_OBJECT
 
 public:
- 
-   /** Constructs a new terminal emulation */ 
+
+   /** Constructs a new terminal emulation */
    Emulation();
   ~Emulation();
 
   /**
    * Creates a new window onto the output from this emulation.  The contents
    * of the window are then rendered by views which are set to use this window using the
    * TerminalDisplay::setScreenWindow() method.
    */
   ScreenWindow* createWindow();
 
   /** Returns the size of the screen image which the emulation produces */
   QSize imageSize();
 
   /**
    * Returns the total number of lines, including those stored in the history.
-   */ 
+   */
   int lineCount();
 
-  
-  /** 
+
+  /**
    * Sets the history store used by this emulation.  When new lines
    * are added to the output, older lines at the top of the screen are transferred to a history
-   * store.   
+   * store.
    *
-   * The number of lines which are kept and the storage location depend on the 
+   * The number of lines which are kept and the storage location depend on the
    * type of store.
    */
   void setHistory(const HistoryType&);
   /** Returns the history store used by this emulation.  See setHistory() */
   const HistoryType& history();
   /** Clears the history scroll. */
   void clearHistory();
 
-  /** 
-   * Copies the output history from @p startLine to @p endLine 
+  /**
+   * Copies the output history from @p startLine to @p endLine
    * into @p stream, using @p decoder to convert the terminal
-   * characters into text. 
+   * characters into text.
    *
-   * @param decoder A decoder which converts lines of terminal characters with 
+   * @param decoder A decoder which converts lines of terminal characters with
    * appearance attributes into output text.  PlainTextDecoder is the most commonly
    * used decoder.
    * @param startLine The first
    */
   virtual void writeToStream(TerminalCharacterDecoder* decoder,int startLine,int endLine);
-  
-  
+
+
   /** Returns the codec used to decode incoming characters.  See setCodec() */
   const QTextCodec* codec() { return _codec; }
   /** Sets the codec used to decode incoming characters.  */
   void setCodec(const QTextCodec*);
 
-  /** 
-   * Convenience method.  
+  /**
+   * Convenience method.
    * Returns true if the current codec used to decode incoming
    * characters is UTF-8
    */
   bool utf8() { Q_ASSERT(_codec); return _codec->mibEnum() == 106; }
-  
+
 
   /** TODO Document me */
   virtual char getErase() const;
 
-  /** 
+  /**
    * Sets the key bindings used to key events
    * ( received through sendKeyEvent() ) into character
    * streams to send to the terminal.
    */
   void setKeyBindings(const QString& name);
-  /** 
+  /**
    * Returns the name of the emulation's current key bindings.
    * See setKeyBindings()
    */
   QString keyBindings();
 
-  /** 
+  /**
    * Copies the current image into the history and clears the screen.
    */
   virtual void clearEntireScreen() =0;
 
   /** Resets the state of the terminal. */
   virtual void reset() =0;
 
-  /** 
+  /**
    * Returns true if the active terminal program wants
    * mouse input events.
    *
    * The programUsesMouseChanged() signal is emitted when this
    * changes.
    */
   bool programUsesMouse() const;
 
-public slots: 
+public slots:
 
   /** Change the size of the emulation's image */
   virtual void setImageSize(int lines, int columns);
-  
-  /** 
+
+  /**
    * Interprets a sequence of characters and sends the result to the terminal.
    * This is equivalent to calling sendKeyEvent() for each character in @p text in succession.
    */
   virtual void sendText(const QString& text) = 0;
 
-  /** 
+  /**
    * Interprets a key press event and emits the sendData() signal with
-   * the resulting character stream. 
+   * the resulting character stream.
    */
   virtual void sendKeyEvent(QKeyEvent*);
- 
-  /** 
+
+  /**
    * Converts information about a mouse event into an xterm-compatible escape
    * sequence and emits the character sequence via sendData()
    */
   virtual void sendMouseEvent(int buttons, int column, int line, int eventType);
-  
+
   /**
-   * Sends a string of characters to the foreground terminal process. 
+   * Sends a string of characters to the foreground terminal process.
    *
-   * @param string The characters to send.  
+   * @param string The characters to send.
    * @param length Length of @p string or if set to a negative value, @p string will
    * be treated as a null-terminated string and its length will be determined automatically.
    */
   virtual void sendString(const char* string, int length = -1) = 0;
 
-  /** 
+  /**
    * Processes an incoming stream of characters.  receiveData() decodes the incoming
    * character buffer using the current codec(), and then calls receiveChar() for
-   * each unicode character in the resulting buffer.  
+   * each unicode character in the resulting buffer.
    *
    * receiveData() also starts a timer which causes the outputChanged() signal
    * to be emitted when it expires.  The timer allows multiple updates in quick
    * succession to be buffered into a single outputChanged() signal emission.
    *
    * @param buffer A string of characters received from the terminal program.
    * @param len The length of @p buffer
    */
   void receiveData(const char* buffer,int len);
 
 signals:
 
-  /** 
-   * Emitted when a buffer of data is ready to send to the 
+  /**
+   * Emitted when a buffer of data is ready to send to the
    * standard input of the terminal.
    *
    * @param data The buffer of data ready to be sent
    * @paran len The length of @p data in bytes
    */
   void sendData(const char* data,int len);
 
-  /** 
+  /**
    * Requests that sending of input to the emulation
    * from the terminal process be suspended or resumed.
    *
-   * @param suspend If true, requests that sending of 
-   * input from the terminal process' stdout be 
+   * @param suspend If true, requests that sending of
+   * input from the terminal process' stdout be
    * suspended.  Otherwise requests that sending of
-   * input be resumed. 
+   * input be resumed.
    */
   void lockPtyRequest(bool suspend);
 
   /**
    * Requests that the pty used by the terminal process
-   * be set to UTF 8 mode.  
+   * be set to UTF 8 mode.
    *
    * TODO: More documentation
    */
   void useUtf8Request(bool);
 
   /**
    * Emitted when the activity state of the emulation is set.
    *
@@ -303,154 +303,154 @@ signals:
    * to represent the tabs associated with this
    * emulation be changed.  This is a Konsole-specific
    * extension from pre-KDE 4 times.
    *
    * TODO: Document how the parameter works.
    */
   void changeTabTextColorRequest(int color);
 
-  /** 
+  /**
    * This is emitted when the program running in the shell indicates whether or
    * not it is interested in mouse events.
    *
    * @param usesMouse This will be true if the program wants to be informed about
    * mouse events or false otherwise.
    */
   void programUsesMouseChanged(bool usesMouse);
 
-  /** 
+  /**
    * Emitted when the contents of the screen image change.
    * The emulation buffers the updates from successive image changes,
    * and only emits outputChanged() at sensible intervals when
    * there is a lot of terminal activity.
    *
    * Normally there is no need for objects other than the screen windows
    * created with createWindow() to listen for this signal.
    *
    * ScreenWindow objects created using createWindow() will emit their
-   * own outputChanged() signal in response to this signal. 
+   * own outputChanged() signal in response to this signal.
    */
   void outputChanged();
 
   /**
-   * Emitted when the program running in the terminal wishes to update the 
+   * Emitted when the program running in the terminal wishes to update the
    * session's title.  This also allows terminal programs to customize other
-   * aspects of the terminal emulation display. 
+   * aspects of the terminal emulation display.
    *
    * This signal is emitted when the escape sequence "\033]ARG;VALUE\007"
    * is received in the input string, where ARG is a number specifying what
    * should change and VALUE is a string specifying the new value.
    *
    * TODO:  The name of this method is not very accurate since this method
    * is used to perform a whole range of tasks besides just setting
-   * the user-title of the session.    
+   * the user-title of the session.
    *
    * @param title Specifies what to change.
    * <ul>
    * <li>0 - Set window icon text and session title to @p newTitle</li>
    * <li>1 - Set window icon text to @p newTitle</li>
    * <li>2 - Set session title to @p newTitle</li>
    * <li>11 - Set the session's default background color to @p newTitle,
    *         where @p newTitle can be an HTML-style string (#RRGGBB) or a named
-   *         color (eg 'red', 'blue').  
+   *         color (eg 'red', 'blue').
    *         See http://doc.trolltech.com/4.2/qcolor.html#setNamedColor for more
    *         details.
    * </li>
    * <li>31 - Supposedly treats @p newTitle as a URL and opens it (NOT IMPLEMENTED)</li>
-   * <li>32 - Sets the icon associated with the session.  @p newTitle is the name 
+   * <li>32 - Sets the icon associated with the session.  @p newTitle is the name
    *    of the icon to use, which can be the name of any icon in the current KDE icon
    *    theme (eg: 'konsole', 'kate', 'folder_home')</li>
    * </ul>
-   * @param newTitle Specifies the new title 
+   * @param newTitle Specifies the new title
    */
 
   void titleChanged(int title,const QString& newTitle);
 
   /**
    * Emitted when the program running in the terminal changes the
    * screen size.
    */
   void imageSizeChanged(int lineCount , int columnCount);
 
-  /** 
+  /**
    * Emitted when the terminal program requests to change various properties
-   * of the terminal display.  
+   * of the terminal display.
    *
    * A profile change command occurs when a special escape sequence, followed
    * by a string containing a series of name and value pairs is received.
    * This string can be parsed using a ProfileCommandParser instance.
    *
    * @param text A string expected to contain a series of key and value pairs in
    * the form:  name=value;name2=value2 ...
    */
   void profileChangeCommandReceived(const QString& text);
 
 protected:
   virtual void setMode  (int mode) = 0;
   virtual void resetMode(int mode) = 0;
-   
- /** 
+
+ /**
    * Processes an incoming character.  See receiveData()
-   * @p ch A unicode character code. 
+   * @p ch A unicode character code.
    */
   virtual void receiveChar(int ch);
 
-  /** 
+  /**
    * Sets the active screen.  The terminal has two screens, primary and alternate.
    * The primary screen is used by default.  When certain interactive programs such
    * as Vim are run, they trigger a switch to the alternate screen.
    *
    * @param index 0 to switch to the primary screen, or 1 to switch to the alternate screen
    */
-  void setScreen(int index); 
+  void setScreen(int index);
 
   enum EmulationCodec
   {
       LocaleCodec = 0,
       Utf8Codec   = 1
   };
   void setCodec(EmulationCodec codec); // codec number, 0 = locale, 1=utf8
 
 
   QList<ScreenWindow*> _windows;
-  
-  Screen* _currentScreen;  // pointer to the screen which is currently active, 
+
+  Screen* _currentScreen;  // pointer to the screen which is currently active,
                             // this is one of the elements in the screen[] array
 
   Screen* _screen[2];      // 0 = primary screen ( used by most programs, including the shell
                             //                      scrollbars are enabled in this mode )
                             // 1 = alternate      ( used by vi , emacs etc.
                             //                      scrollbars are not enabled in this mode )
-                            
-  
-  //decodes an incoming C-style character stream into a unicode QString using 
+
+
+  //decodes an incoming C-style character stream into a unicode QString using
   //the current text codec.  (this allows for rendering of non-ASCII characters in text files etc.)
   const QTextCodec* _codec;
   QTextDecoder* _decoder;
 
   const KeyboardTranslator* _keyTranslator; // the keyboard layout
 
 protected slots:
-  /** 
+  /**
    * Schedules an update of attached views.
    * Repeated calls to bufferedUpdate() in close succession will result in only a single update,
-   * much like the Qt buffered update of widgets. 
+   * much like the Qt buffered update of widgets.
    */
   void bufferedUpdate();
 
-private slots: 
+private slots:
 
   // triggered by timer, causes the emulation to send an updated screen image to each
   // view
-  void showBulk(); 
+  void showBulk();
 
   void usesMouseChanged(bool usesMouse);
 
 private:
 
   bool _usesMouse;
   QTimer _bulkTimer1;
   QTimer _bulkTimer2;
-  
+
 };
 
 #endif // ifndef EMULATION_H
diff --git a/libgui/qterminal/libqterminal/unix/Filter.cpp b/libgui/qterminal/libqterminal/unix/Filter.cpp
--- a/libgui/qterminal/libqterminal/unix/Filter.cpp
+++ b/libgui/qterminal/libqterminal/unix/Filter.cpp
@@ -35,17 +35,17 @@
 #include <QtCore>
 
 // Konsole
 #include "unix/TerminalCharacterDecoder.h"
 
 FilterChain::~FilterChain()
 {
     QMutableListIterator<Filter*> iter(*this);
-    
+
     while ( iter.hasNext() )
     {
         Filter* filter = iter.next();
         iter.remove();
         delete filter;
     }
 }
 
@@ -131,17 +131,17 @@ void TerminalImageFilterChain::setImage(
 //qDebug("%s %d", __FILE__, __LINE__);
 
     // reset all filters and hotspots
     reset();
 //qDebug("%s %d", __FILE__, __LINE__);
 
     PlainTextDecoder decoder;
     decoder.setTrailingWhitespace(false);
-    
+
 //qDebug("%s %d", __FILE__, __LINE__);
     // setup new shared buffers for the filters to process on
     QString* newBuffer = new QString();
     QList<int>* newLinePositions = new QList<int>();
     setBuffer( newBuffer , newLinePositions );
 
     // free the old buffers
     delete _buffer;
@@ -158,17 +158,17 @@ void TerminalImageFilterChain::setImage(
         _linePositions->append(_buffer->length());
         decoder.decodeLine(image + i*columns,columns,LINE_DEFAULT);
 
         // pretend that each line ends with a newline character.
         // this prevents a link that occurs at the end of one line
         // being treated as part of a link that occurs at the start of the next line
         //
         // the downside is that links which are spread over more than one line are not
-        // highlighted.  
+        // highlighted.
         //
         // TODO - Use the "line wrapped" attribute associated with lines in a
         // terminal image to avoid adding this imaginary character for wrapped
         // lines
         if ( !(lineProperties.value(i,LINE_DEFAULT) & LINE_WRAPPED) )
         	lineStream << QChar('\n');
     }
     decoder.end();
@@ -216,28 +216,28 @@ void Filter::getLineColumn(int position 
         {
             nextLine = _buffer->length() + 1;
         }
         else
         {
             nextLine = _linePositions->value(i+1);
         }
 
-       // kDebug() << "pos - " << position << " line pos(" << i<< ") " << _linePositions->value(i) << 
+       // kDebug() << "pos - " << position << " line pos(" << i<< ") " << _linePositions->value(i) <<
        //     " next = " << nextLine << " buffer len = " << _buffer->length();
 
-        if ( _linePositions->value(i) <= position && position < nextLine ) 
+        if ( _linePositions->value(i) <= position && position < nextLine )
         {
             startLine = i;
             startColumn = position - _linePositions->value(i);
             return;
         }
     }
 }
-    
+
 
 /*void Filter::addLine(const QString& text)
 {
     _linePositions << _buffer.length();
     _buffer.append(text);
 }*/
 
 const QString* Filter::buffer()
@@ -249,17 +249,17 @@ Filter::HotSpot::~HotSpot()
 }
 void Filter::addHotSpot(HotSpot* spot)
 {
     _hotspotList << spot;
 
     for (int line = spot->startLine() ; line <= spot->endLine() ; line++)
     {
         _hotspots.insert(line,spot);
-    }    
+    }
 }
 QList<Filter::HotSpot*> Filter::hotSpots() const
 {
     return _hotspotList;
 }
 QList<Filter::HotSpot*> Filter::hotSpotsAtLine(int line) const
 {
     return _hotspots.values(line);
@@ -267,22 +267,22 @@ QList<Filter::HotSpot*> Filter::hotSpots
 
 Filter::HotSpot* Filter::hotSpotAt(int line , int column) const
 {
     QListIterator<HotSpot*> spotIter(_hotspots.values(line));
 
     while (spotIter.hasNext())
     {
         HotSpot* spot = spotIter.next();
-        
+
         if ( spot->startLine() == line && spot->startColumn() > column )
             continue;
         if ( spot->endLine() == line && spot->endColumn() < column )
             continue;
-       
+
         return spot;
     }
 
     return 0;
 }
 
 Filter::HotSpot::HotSpot(int startLine , int startColumn , int endLine , int endColumn)
     : _startLine(startLine)
@@ -343,17 +343,17 @@ void RegExpFilter::HotSpot::setCapturedT
 {
     _capturedTexts = texts;
 }
 QStringList RegExpFilter::HotSpot::capturedTexts() const
 {
     return _capturedTexts;
 }
 
-void RegExpFilter::setRegExp(const QRegExp& regExp) 
+void RegExpFilter::setRegExp(const QRegExp& regExp)
 {
     _searchText = regExp;
 }
 QRegExp RegExpFilter::regExp() const
 {
     return _searchText;
 }
 /*void RegExpFilter::reset(int)
@@ -380,36 +380,36 @@ void RegExpFilter::process()
         if ( pos >= 0 )
         {
 
             int startLine = 0;
             int endLine = 0;
             int startColumn = 0;
             int endColumn = 0;
 
-            
+
             //kDebug() << "pos from " << pos << " to " << pos + _searchText.matchedLength();
-            
+
             getLineColumn(pos,startLine,startColumn);
             getLineColumn(pos + _searchText.matchedLength(),endLine,endColumn);
 
             //kDebug() << "start " << startLine << " / " << startColumn;
             //kDebug() << "end " << endLine << " / " << endColumn;
 
             RegExpFilter::HotSpot* spot = newHotSpot(startLine,startColumn,
                                            endLine,endColumn);
             spot->setCapturedTexts(_searchText.capturedTexts());
 
-            addHotSpot( spot );  
+            addHotSpot( spot );
             pos += _searchText.matchedLength();
 
             // if matchedLength == 0, the program will get stuck in an infinite loop
             Q_ASSERT( _searchText.matchedLength() > 0 );
         }
-    }    
+    }
 }
 
 RegExpFilter::HotSpot* RegExpFilter::newHotSpot(int startLine,int startColumn,
                                                 int endLine,int endColumn)
 {
     return new RegExpFilter::HotSpot(startLine,startColumn,
                                                   endLine,endColumn);
 }
@@ -427,26 +427,26 @@ UrlFilter::HotSpot::HotSpot(int startLin
 }
 QString UrlFilter::HotSpot::tooltip() const
 {
     QString url = capturedTexts().first();
 
     const UrlType kind = urlType();
 
     if ( kind == StandardUrl )
-        return QString(); 
+        return QString();
     else if ( kind == Email )
-        return QString(); 
+        return QString();
     else
         return QString();
 }
 UrlFilter::HotSpot::UrlType UrlFilter::HotSpot::urlType() const
 {
     QString url = capturedTexts().first();
-    
+
     if ( FullUrlRegExp.exactMatch(url) )
         return StandardUrl;
     else if ( EmailAddressRegExp.exactMatch(url) )
         return Email;
     else
         return Unknown;
 }
 
@@ -471,33 +471,33 @@ void UrlFilter::HotSpot::activate(QObjec
         if ( kind == StandardUrl )
         {
             // if the URL path does not include the protocol ( eg. "www.kde.org" ) then
             // prepend http:// ( eg. "www.kde.org" --> "http://www.kde.org" )
             if (!url.contains("://"))
             {
                 url.prepend("http://");
             }
-        } 
+        }
         else if ( kind == Email )
         {
             url.prepend("mailto:");
         }
-    
+
 //        new KRun(url,QApplication::activeWindow());
     }
 }
 
-// Note:  Altering these regular expressions can have a major effect on the performance of the filters 
+// Note:  Altering these regular expressions can have a major effect on the performance of the filters
 // used for finding URLs in the text, especially if they are very general and could match very long
 // pieces of text.
 // Please be careful when altering them.
 
 //regexp matches:
-// full url:  
+// full url:
 // protocolname:// or www. followed by anything other than whitespaces, <, >, ' or ", and ends before whitespaces, <, >, ', ", ], !, comma and dot
 const QRegExp UrlFilter::FullUrlRegExp("(www\\.(?!\\.)|[a-z][a-z0-9+.-]*://)[^\\s<>'\"]+[^!,\\.\\s<>'\"\\]]");
 // email address:
 // [word chars, dots or dashes]@[word chars, dots or dashes].[word chars]
 const QRegExp UrlFilter::EmailAddressRegExp("\\b(\\w|\\.|-)+@(\\w|\\.|-)+\\.\\w+\\b");
 
 // matches full url or email address
 const QRegExp UrlFilter::CompleteUrlRegExp('('+FullUrlRegExp.pattern()+'|'+
@@ -544,12 +544,12 @@ QList<QAction*> UrlFilter::HotSpot::acti
     copyAction->setObjectName("copy-action");
 
     QObject::connect( openAction , SIGNAL(triggered()) , _urlObject , SLOT(activated()) );
     QObject::connect( copyAction , SIGNAL(triggered()) , _urlObject , SLOT(activated()) );
 
     list << openAction;
     list << copyAction;
 
-    return list; 
+    return list;
 }
 
 //#include "moc_Filter.cpp"
diff --git a/libgui/qterminal/libqterminal/unix/Filter.h b/libgui/qterminal/libqterminal/unix/Filter.h
--- a/libgui/qterminal/libqterminal/unix/Filter.h
+++ b/libgui/qterminal/libqterminal/unix/Filter.h
@@ -38,17 +38,17 @@
  * and marks the areas which match the filter's patterns as 'hotspots'.
  *
  * Each hotspot has a type identifier associated with it ( such as a link or a highlighted section ),
  * and an action.  When the user performs some activity such as a mouse-click in a hotspot area ( the exact
  * action will depend on what is displaying the block of text which the filter is processing ), the hotspot's
  * activate() method should be called.  Depending on the type of hotspot this will trigger a suitable response.
  *
  * For example, if a hotspot represents a URL then a suitable action would be opening that URL in a web browser.
- * Hotspots may have more than one action, in which case the list of actions can be obtained using the 
+ * Hotspots may have more than one action, in which case the list of actions can be obtained using the
  * actions() method.
  *
  * Different subclasses of filter will return different types of hotspot.
  * Subclasses must reimplement the process() method to examine a block of text and identify sections of interest.
  * When processing the text they should create instances of Filter::HotSpot subclasses for sections of interest
  * and add them to the filter's list of hotspots using addHotSpot()
  */
 class Filter
@@ -58,145 +58,145 @@ public:
     * Represents an area of text which matched the pattern a particular filter has been looking for.
     *
     * Each hotspot has a type identifier associated with it ( such as a link or a highlighted section ),
     * and an action.  When the user performs some activity such as a mouse-click in a hotspot area ( the exact
     * action will depend on what is displaying the block of text which the filter is processing ), the hotspot's
     * activate() method should be called.  Depending on the type of hotspot this will trigger a suitable response.
     *
     * For example, if a hotspot represents a URL then a suitable action would be opening that URL in a web browser.
-    * Hotspots may have more than one action, in which case the list of actions can be obtained using the 
-    * actions() method.  These actions may then be displayed in a popup menu or toolbar for example. 
+    * Hotspots may have more than one action, in which case the list of actions can be obtained using the
+    * actions() method.  These actions may then be displayed in a popup menu or toolbar for example.
     */
     class HotSpot
     {
     public:
-       /** 
+       /**
         * Constructs a new hotspot which covers the area from (@p startLine,@p startColumn) to (@p endLine,@p endColumn)
         * in a block of text.
         */
        HotSpot(int startLine , int startColumn , int endLine , int endColumn);
        virtual ~HotSpot();
 
        enum Type
        {
             // the type of the hotspot is not specified
             NotSpecified,
             // this hotspot represents a clickable link
             Link,
             // this hotspot represents a marker
             Marker
-       }; 
+       };
 
        /** Returns the line when the hotspot area starts */
        int startLine() const;
        /** Returns the line where the hotspot area ends */
        int endLine() const;
        /** Returns the column on startLine() where the hotspot area starts */
        int startColumn() const;
        /** Returns the column on endLine() where the hotspot area ends */
        int endColumn() const;
-       /** 
+       /**
         * Returns the type of the hotspot.  This is usually used as a hint for views on how to represent
         * the hotspot graphically.  eg.  Link hotspots are typically underlined when the user mouses over them
         */
        Type type() const;
-       /** 
-        * Causes the an action associated with a hotspot to be triggered. 
+       /**
+        * Causes the an action associated with a hotspot to be triggered.
         *
         * @param object The object which caused the hotspot to be triggered.  This is
         * typically null ( in which case the default action should be performed ) or
         * one of the objects from the actions() list.  In which case the associated
-        * action should be performed. 
+        * action should be performed.
         */
-       virtual void activate(QObject* object = 0) = 0; 
-       /** 
-        * Returns a list of actions associated with the hotspot which can be used in a 
-        * menu or toolbar 
+       virtual void activate(QObject* object = 0) = 0;
+       /**
+        * Returns a list of actions associated with the hotspot which can be used in a
+        * menu or toolbar
         */
        virtual QList<QAction*> actions();
 
-       /** 
+       /**
         * Returns the text of a tooltip to be shown when the mouse moves over the hotspot, or
         * an empty string if there is no tooltip associated with this hotspot.
         *
-        * The default implementation returns an empty string. 
+        * The default implementation returns an empty string.
         */
        virtual QString tooltip() const;
 
     protected:
        /** Sets the type of a hotspot.  This should only be set once */
        void setType(Type type);
 
     private:
        int    _startLine;
        int    _startColumn;
        int    _endLine;
        int    _endColumn;
        Type _type;
-    
+
     };
 
     /** Constructs a new filter. */
     Filter();
     virtual ~Filter();
 
     /** Causes the filter to process the block of text currently in its internal buffer */
     virtual void process() = 0;
 
-    /** 
+    /**
      * Empties the filters internal buffer and resets the line count back to 0.
-     * All hotspots are deleted. 
+     * All hotspots are deleted.
      */
     void reset();
 
     /** Adds a new line of text to the filter and increments the line count */
     //void addLine(const QString& string);
 
     /** Returns the hotspot which covers the given @p line and @p column, or 0 if no hotspot covers that area */
     HotSpot* hotSpotAt(int line , int column) const;
 
     /** Returns the list of hotspots identified by the filter */
     QList<HotSpot*> hotSpots() const;
 
     /** Returns the list of hotspots identified by the filter which occur on a given line */
     QList<HotSpot*> hotSpotsAtLine(int line) const;
 
-    /** 
+    /**
      * TODO: Document me
      */
     void setBuffer(const QString* buffer , const QList<int>* linePositions);
 
 protected:
     /** Adds a new hotspot to the list */
     void addHotSpot(HotSpot*);
     /** Returns the internal buffer */
     const QString* buffer();
     /** Converts a character position within buffer() to a line and column */
     void getLineColumn(int position , int& startLine , int& startColumn);
 
 private:
     QMultiHash<int,HotSpot*> _hotspots;
     QList<HotSpot*> _hotspotList;
-    
+
     const QList<int>* _linePositions;
     const QString* _buffer;
 };
 
-/** 
- * A filter which searches for sections of text matching a regular expression and creates a new RegExpFilter::HotSpot 
+/**
+ * A filter which searches for sections of text matching a regular expression and creates a new RegExpFilter::HotSpot
  * instance for them.
  *
  * Subclasses can reimplement newHotSpot() to return custom hotspot types when matches for the regular expression
- * are found. 
+ * are found.
  */
 class RegExpFilter : public Filter
 {
 public:
-    /** 
+    /**
      * Type of hotspot created by RegExpFilter.  The capturedTexts() method can be used to find the text
      * matched by the filter's regular expression.
      */
     class HotSpot : public Filter::HotSpot
     {
     public:
         HotSpot(int startLine, int startColumn, int endLine , int endColumn);
         virtual void activate(QObject* object = 0);
@@ -207,65 +207,65 @@ public:
         QStringList capturedTexts() const;
     private:
         QStringList _capturedTexts;
     };
 
     /** Constructs a new regular expression filter */
     RegExpFilter();
 
-    /** 
-     * Sets the regular expression which the filter searches for in blocks of text. 
+    /**
+     * Sets the regular expression which the filter searches for in blocks of text.
      *
      * Regular expressions which match the empty string are treated as not matching
-     * anything. 
+     * anything.
      */
     void setRegExp(const QRegExp& text);
     /** Returns the regular expression which the filter searches for in blocks of text */
     QRegExp regExp() const;
 
-    /** 
-     * Reimplemented to search the filter's text buffer for text matching regExp() 
+    /**
+     * Reimplemented to search the filter's text buffer for text matching regExp()
      *
      * If regexp matches the empty string, then process() will return immediately
-     * without finding results. 
+     * without finding results.
      */
     virtual void process();
 
 protected:
-    /** 
+    /**
      * Called when a match for the regular expression is encountered.  Subclasses should reimplement this
      * to return custom hotspot types
      */
     virtual RegExpFilter::HotSpot* newHotSpot(int startLine,int startColumn,
                                     int endLine,int endColumn);
 
 private:
     QRegExp _searchText;
 };
 
 class FilterObject;
 
 /** A filter which matches URLs in blocks of text */
-class UrlFilter : public RegExpFilter 
+class UrlFilter : public RegExpFilter
 {
 public:
-    /** 
-     * Hotspot type created by UrlFilter instances.  The activate() method opens a web browser 
+    /**
+     * Hotspot type created by UrlFilter instances.  The activate() method opens a web browser
      * at the given URL when called.
      */
-    class HotSpot : public RegExpFilter::HotSpot 
+    class HotSpot : public RegExpFilter::HotSpot
     {
     public:
         HotSpot(int startLine,int startColumn,int endLine,int endColumn);
         virtual ~HotSpot();
 
         virtual QList<QAction*> actions();
 
-        /** 
+        /**
          * Open a web browser at the current URL.  The url itself can be determined using
          * the capturedTexts() method.
          */
         virtual void activate(QObject* object = 0);
 
         virtual QString tooltip() const;
     private:
         enum UrlType
@@ -280,40 +280,40 @@ public:
     };
 
     UrlFilter();
 
 protected:
     virtual RegExpFilter::HotSpot* newHotSpot(int,int,int,int);
 
 private:
-    
+
     static const QRegExp FullUrlRegExp;
     static const QRegExp EmailAddressRegExp;
 
     // combined OR of FullUrlRegExp and EmailAddressRegExp
-    static const QRegExp CompleteUrlRegExp; 
+    static const QRegExp CompleteUrlRegExp;
 };
 
 class FilterObject : public QObject
 {
 Q_OBJECT
 public:
     FilterObject(Filter::HotSpot* filter) : _filter(filter) {}
 private slots:
     void activated();
 private:
     Filter::HotSpot* _filter;
 };
 
-/** 
- * A chain which allows a group of filters to be processed as one. 
+/**
+ * A chain which allows a group of filters to be processed as one.
  * The chain owns the filters added to it and deletes them when the chain itself is destroyed.
  *
- * Use addFilter() to add a new filter to the chain.  
+ * Use addFilter() to add a new filter to the chain.
  * When new text to be filtered arrives, use addLine() to add each additional
  * line of text which needs to be processed and then after adding the last line, use
  * process() to cause each filter in the chain to process the text.
  *
  * After processing a block of text, the reset() method can be used to set the filter chain's
  * internal cursor back to the first line.
  *
  * The hotSpotAt() method will return the first hotspot which covers a given position.
@@ -333,22 +333,22 @@ public:
     /** Returns true if the chain contains @p filter */
     bool containsFilter(Filter* filter);
     /** Removes all filters from the chain */
     void clear();
 
     /** Resets each filter in the chain */
     void reset();
     /**
-     * Processes each filter in the chain 
+     * Processes each filter in the chain
      */
     void process();
 
     /** Sets the buffer for each filter in the chain to process. */
-    void setBuffer(const QString* buffer , const QList<int>* linePositions); 
+    void setBuffer(const QString* buffer , const QList<int>* linePositions);
 
     /** Returns the first hotspot which occurs at @p line, @p column or 0 if no hotspot was found */
     Filter::HotSpot* hotSpotAt(int line , int column) const;
     /** Returns a list of all the hotspots in all the chain's filters */
     QList<Filter::HotSpot*> hotSpots() const;
     /** Returns a list of all hotspots at the given line in all the chain's filters */
     QList<Filter::HotSpot> hotSpotsAtLine(int line) const;
 
@@ -364,16 +364,16 @@ public:
     /**
      * Set the current terminal image to @p image.
      *
      * @param image The terminal image
      * @param lines The number of lines in the terminal image
      * @param columns The number of columns in the terminal image
      */
     void setImage(const Character* const image , int lines , int columns,
-				  const QVector<LineProperty>& lineProperties);  
+				  const QVector<LineProperty>& lineProperties);
 
 private:
     QString* _buffer;
     QList<int>* _linePositions;
 };
 
 #endif //FILTER_H
diff --git a/libgui/qterminal/libqterminal/unix/History.cpp b/libgui/qterminal/libqterminal/unix/History.cpp
--- a/libgui/qterminal/libqterminal/unix/History.cpp
+++ b/libgui/qterminal/libqterminal/unix/History.cpp
@@ -82,17 +82,17 @@ FIXME: There is noticeable decrease in s
 */
 
 HistoryFile::HistoryFile()
   : ion(-1),
     length(0),
 	fileMap(0)
 {
   if (tmpFile.open())
-  { 
+  {
     tmpFile.setAutoRemove(true);
     ion = tmpFile.handle();
   }
 }
 
 HistoryFile::~HistoryFile()
 {
 	if (fileMap)
@@ -106,17 +106,17 @@ void HistoryFile::map()
 {
 	assert( fileMap == 0 );
 
 	fileMap = (char*)mmap( 0 , length , PROT_READ , MAP_PRIVATE , ion , 0 );
 
     //if mmap'ing fails, fall back to the read-lseek combination
     if ( fileMap == MAP_FAILED )
     {
-            readWriteBalance = 0; 
+            readWriteBalance = 0;
             fileMap = 0;
             qDebug() << ": mmap'ing history failed.  errno = " << errno;
     }
 }
 
 void HistoryFile::unmap()
 {
 	int result = munmap( fileMap , length );
@@ -141,18 +141,18 @@ void HistoryFile::add(const unsigned cha
 
   rc = lseek(ion,length,SEEK_SET); if (rc < 0) { perror("HistoryFile::add.seek"); return; }
   rc = write(ion,bytes,len);       if (rc < 0) { perror("HistoryFile::add.write"); return; }
   length += rc;
 }
 
 void HistoryFile::get(unsigned char* bytes, int len, int loc)
 {
-  //count number of get() calls vs. number of add() calls.  
-  //If there are many more get() calls compared with add() 
+  //count number of get() calls vs. number of add() calls.
+  //If there are many more get() calls compared with add()
   //calls (decided by using MAP_THRESHOLD) then mmap the log
   //file to improve performance.
   readWriteBalance--;
   if ( !fileMap && readWriteBalance < MAP_THRESHOLD )
 		  map();
 
   if ( fileMap )
   {
@@ -191,17 +191,17 @@ HistoryScroll::~HistoryScroll()
 
 bool HistoryScroll::hasScroll()
 {
   return true;
 }
 
 // History Scroll File //////////////////////////////////////
 
-/* 
+/*
    The history scroll makes a Row(Row(Cell)) from
    two history buffers. The index buffer contains
    start of line positions which refere to the cells
    buffer.
 
    Note that index[0] addresses the second line
    (line #1), while the first line (line #0) starts
    at 0 in cells.
@@ -211,17 +211,17 @@ HistoryScrollFile::HistoryScrollFile(con
   : HistoryScroll(new HistoryTypeFile(logFileName)),
   m_logFileName(logFileName)
 {
 }
 
 HistoryScrollFile::~HistoryScrollFile()
 {
 }
- 
+
 int HistoryScrollFile::getLines()
 {
   return index.len() / sizeof(int);
 }
 
 int HistoryScrollFile::getLineLen(int lineno)
 {
   return (startOfLine(lineno+1) - startOfLine(lineno)) / sizeof(Character);
@@ -236,17 +236,17 @@ bool HistoryScrollFile::isWrappedLine(in
   }
   return false;
 }
 
 int HistoryScrollFile::startOfLine(int lineno)
 {
   if (lineno <= 0) return 0;
   if (lineno <= getLines())
-    { 
+    {
 	
 	if (!index.isMapped())
 			index.map();
 	
 	int res;
     index.get((unsigned char*)&res,sizeof(int),(lineno-1)*sizeof(int));
     return res;
     }
@@ -335,59 +335,59 @@ int HistoryScrollBuffer::getLineLen(int 
   {
     return 0;
   }
 }
 
 bool HistoryScrollBuffer::isWrappedLine(int lineNumber)
 {
   Q_ASSERT( lineNumber >= 0 && lineNumber < _maxLineCount );
-    
+
   if (lineNumber < _usedLines)
   {
     //kDebug() << "Line" << lineNumber << "wrapped is" << _wrappedLine[bufferIndex(lineNumber)];
     return _wrappedLine[bufferIndex(lineNumber)];
   }
   else
     return false;
 }
 
 void HistoryScrollBuffer::getCells(int lineNumber, int startColumn, int count, Character* buffer)
 {
   if ( count == 0 ) return;
 
   Q_ASSERT( lineNumber < _maxLineCount );
 
-  if (lineNumber >= _usedLines) 
+  if (lineNumber >= _usedLines)
   {
     memset(buffer, 0, count * sizeof(Character));
     return;
   }
-  
+
   const HistoryLine& line = _historyBuffer[bufferIndex(lineNumber)];
 
   //kDebug() << "startCol " << startColumn;
   //kDebug() << "line.size() " << line.size();
   //kDebug() << "count " << count;
 
   Q_ASSERT( startColumn <= line.size() - count );
-    
+
   memcpy(buffer, line.constData() + startColumn , count * sizeof(Character));
 }
 
 void HistoryScrollBuffer::setMaxNbLines(unsigned int lineCount)
 {
     HistoryLine* oldBuffer = _historyBuffer;
     HistoryLine* newBuffer = new HistoryLine[lineCount];
-    
+
     for ( int i = 0 ; i < qMin(_usedLines,(int)lineCount) ; i++ )
     {
         newBuffer[i] = oldBuffer[bufferIndex(i)];
     }
-    
+
     _usedLines = qMin(_usedLines,(int)lineCount);
     _maxLineCount = lineCount;
     _head = ( _usedLines == _maxLineCount ) ? 0 : _usedLines-1;
 
     _historyBuffer = newBuffer;
     delete[] oldBuffer;
 
     _wrappedLine.resize(lineCount);
@@ -399,17 +399,17 @@ int HistoryScrollBuffer::bufferIndex(int
     Q_ASSERT( lineNumber < _maxLineCount );
     Q_ASSERT( (_usedLines == _maxLineCount) || lineNumber <= _head );
 
     if ( _usedLines == _maxLineCount )
     {
         return (_head+lineNumber+1) % _maxLineCount;
     }
     else
-    {   
+    {
         return lineNumber;
     }
 }
 
 
 // History Scroll None //////////////////////////////////////
 
 HistoryScrollNone::HistoryScrollNone()
@@ -497,17 +497,17 @@ void HistoryScrollBlockArray::getCells(i
 
   assert(((colno + count) * sizeof(Character)) < ENTRIES);
   memcpy(res, b->data + (colno * sizeof(Character)), count * sizeof(Character));
 }
 
 void HistoryScrollBlockArray::addCells(const Character a[], int count)
 {
   Block *b = m_blockArray.lastBlock();
-  
+
   if (!b) return;
 
   // put cells in block's data
   assert((count * sizeof(Character)) < ENTRIES);
 
   memset(b->data, 0, ENTRIES);
 
   memcpy(b->data, a, count * sizeof(Character));
@@ -655,17 +655,17 @@ bool HistoryTypeFile::isEnabled() const
 
 const QString& HistoryTypeFile::getFileName() const
 {
   return m_fileName;
 }
 
 HistoryScroll* HistoryTypeFile::scroll(HistoryScroll *old) const
 {
-  if (dynamic_cast<HistoryFile *>(old)) 
+  if (dynamic_cast<HistoryFile *>(old))
      return old; // Unchanged.
 
   HistoryScroll *newScroll = new HistoryScrollFile(m_fileName);
 
   Character line[LINE_SIZE];
   int lines = (old != 0) ? old->getLines() : 0;
   for(int i = 0; i < lines; i++)
   {
@@ -682,15 +682,15 @@ HistoryScroll* HistoryTypeFile::scroll(H
      {
         old->getCells(i, 0, size, line);
         newScroll->addCells(line, size);
         newScroll->addLine(old->isWrappedLine(i));
      }
   }
 
   delete old;
-  return newScroll; 
+  return newScroll;
 }
 
 int HistoryTypeFile::maximumLineCount() const
 {
   return 0;
 }
diff --git a/libgui/qterminal/libqterminal/unix/History.h b/libgui/qterminal/libqterminal/unix/History.h
--- a/libgui/qterminal/libqterminal/unix/History.h
+++ b/libgui/qterminal/libqterminal/unix/History.h
@@ -53,17 +53,17 @@ public:
 
 private:
   int  ion;
   int  length;
   QTemporaryFile tmpFile;
 
   //pointer to start of mmap'ed file data, or 0 if the file is not mmap'ed
   char* fileMap;
- 
+
   //incremented whenver 'add' is called and decremented whenever
   //'get' is called.
   //this is used to detect when a large number of lines are being read and processed from the history
   //and automatically mmap the file for better performance (saves the overhead of many lseek-read calls).
   int readWriteBalance;
 
   //when readWriteBalance goes below this threshold, the file will be mmap'ed automatically
   static const int MAP_THRESHOLD = -1000;
@@ -162,27 +162,27 @@ public:
   virtual bool isWrappedLine(int lineno);
 
   virtual void addCells(const Character a[], int count);
   virtual void addCellsVector(const QVector<Character>& cells);
   virtual void addLine(bool previousWrapped=false);
 
   void setMaxNbLines(unsigned int nbLines);
   unsigned int maxNbLines() { return _maxLineCount; }
-  
+
 
 private:
   int bufferIndex(int lineNumber);
 
   HistoryLine* _historyBuffer;
   QBitArray _wrappedLine;
   int _maxLineCount;
-  int _usedLines;  
+  int _usedLines;
   int _head;
-  
+
   //QVector<histline*> m_histBuffer;
   //QBitArray m_wrappedLine;
   //unsigned int m_maxNbLines;
   //unsigned int m_nbLines;
   //unsigned int m_arrayIndex;
   //bool         m_buffFilled;
 };
 
@@ -250,17 +250,17 @@ protected:
 class HistoryType
 {
 public:
   HistoryType();
   virtual ~HistoryType();
 
   /**
    * Returns true if the history is enabled ( can store lines of output )
-   * or false otherwise. 
+   * or false otherwise.
    */
   virtual bool isEnabled()           const = 0;
   /**
    * Returns true if the history size is unlimited.
    */
   bool isUnlimited() const { return maximumLineCount() == 0; }
   /**
    * Returns the maximum number of lines which this history type
@@ -281,17 +281,17 @@ public:
 
   virtual HistoryScroll* scroll(HistoryScroll *) const;
 };
 
 class HistoryTypeBlockArray : public HistoryType
 {
 public:
   HistoryTypeBlockArray(size_t size);
-  
+
   virtual bool isEnabled() const;
   virtual int maximumLineCount() const;
 
   virtual HistoryScroll* scroll(HistoryScroll *) const;
 
 protected:
   size_t m_size;
 };
@@ -312,17 +312,17 @@ protected:
   QString m_fileName;
 };
 
 
 class HistoryTypeBuffer : public HistoryType
 {
 public:
   HistoryTypeBuffer(unsigned int nbLines);
-  
+
   virtual bool isEnabled() const;
   virtual int maximumLineCount() const;
 
   virtual HistoryScroll* scroll(HistoryScroll *) const;
 
 protected:
   unsigned int m_nbLines;
 };
diff --git a/libgui/qterminal/libqterminal/unix/KeyboardTranslator.cpp b/libgui/qterminal/libqterminal/unix/KeyboardTranslator.cpp
--- a/libgui/qterminal/libqterminal/unix/KeyboardTranslator.cpp
+++ b/libgui/qterminal/libqterminal/unix/KeyboardTranslator.cpp
@@ -35,17 +35,17 @@
 #include <QtCore>
 #include <QtGui>
 
 // FIXME: We should not have a special case for Mac here.  Instead, we
 // should be loading .keytab files at run time, and ideally, allowing
 // individual keys to be redefined from some preferences menu.
 
 //and this is default now translator - default.keytab from original Konsole
-const char* KeyboardTranslatorManager::defaultTranslatorText = 
+const char* KeyboardTranslatorManager::defaultTranslatorText =
 #if defined (Q_OS_MAC)
 #include "ExtendedDefaultTranslatorMac.h"
 #else
 #include "ExtendedDefaultTranslator.h"
 #endif
 ;
 
 KeyboardTranslatorManager::KeyboardTranslatorManager()
@@ -112,20 +112,20 @@ const KeyboardTranslator* KeyboardTransl
 bool KeyboardTranslatorManager::saveTranslator(const KeyboardTranslator* translator)
 {
     const QString path = ".keytab";// = KGlobal::dirs()->saveLocation("data","konsole/")+translator->name()
     //           +".keytab";
 
     qDebug() << "Saving translator to" << path;
 
     QFile destination(path);
-    
+
     if (!destination.open(QIODevice::WriteOnly | QIODevice::Text))
     {
-        qWarning() << "Unable to save keyboard translation:" 
+        qWarning() << "Unable to save keyboard translation:"
                    << destination.errorString();
 
         return false;
     }
 
     {
         KeyboardTranslatorWriter writer(&destination);
         writer.writeHeader(translator->description());
@@ -139,18 +139,18 @@ bool KeyboardTranslatorManager::saveTran
 
     return true;
 }
 
 KeyboardTranslator* KeyboardTranslatorManager::loadTranslator(const QString& name)
 {
     const QString& path = findTranslatorPath(name);
 
-    QFile source(path); 
-    
+    QFile source(path);
+
     if (name.isEmpty() || !source.open(QIODevice::ReadOnly | QIODevice::Text))
         return 0;
 
     return loadTranslator(&source,name);
 }
 
 const KeyboardTranslator* KeyboardTranslatorManager::defaultTranslator()
 {
@@ -163,17 +163,17 @@ const KeyboardTranslator* KeyboardTransl
     return loadTranslator(&textBuffer,"fallback");
 }
 
 KeyboardTranslator* KeyboardTranslatorManager::loadTranslator(QIODevice* source,const QString& name)
 {
     KeyboardTranslator* translator = new KeyboardTranslator(name);
     KeyboardTranslatorReader reader(source);
     translator->setDescription( reader.description() );
-    
+
     while ( reader.hasNextEntry() ) {
         translator->addEntry(reader.nextEntry());
     }	
 
     source->close();
 
     if ( !reader.parseError() )
     {
@@ -218,17 +218,17 @@ void KeyboardTranslatorWriter::writeEntr
 //
 // - keyboard "name"
 // - key KeySequence : "characters"
 // - key KeySequence : CommandName
 //
 // KeySequence begins with the name of the key ( taken from the Qt::Key enum )
 // and is followed by the keyboard modifiers and state flags ( with + or - in front
 // of each modifier or flag to indicate whether it is required ).  All keyboard modifiers
-// and flags are optional, if a particular modifier or state is not specified it is 
+// and flags are optional, if a particular modifier or state is not specified it is
 // assumed not to be a part of the sequence.  The key sequence may contain whitespace
 //
 // eg:  "key Up+Shift : scrollLineUp"
 //      "key Next-Shift : "\E[6~"
 //
 // (lines containing only whitespace are ignored, parseLine assumes that comments have
 // already been removed)
 //
@@ -245,17 +245,17 @@ KeyboardTranslatorReader::KeyboardTransl
         if ( !tokens.isEmpty() && tokens.first().type == Token::TitleKeyword )
         {
             _description = (tokens[1].text.toUtf8());
         }
     }
 
     readNext();
 }
-void KeyboardTranslatorReader::readNext() 
+void KeyboardTranslatorReader::readNext()
 {
     // find next entry
     while ( !_source->atEnd() )
     {
         const QList<Token>& tokens = tokenize( QString(_source->readLine()) );
         if ( !tokens.isEmpty() && tokens.first().type == Token::KeyKeyword )
         {
             KeyboardTranslator::States flags = KeyboardTranslator::NoState;
@@ -265,17 +265,17 @@ void KeyboardTranslatorReader::readNext(
 
             int keyCode = Qt::Key_unknown;
 
             decodeSequence(tokens[1].text.toLower(),
                            keyCode,
                            modifiers,
                            modifierMask,
                            flags,
-                           flagMask); 
+                           flagMask);
 
             KeyboardTranslator::Command command = KeyboardTranslator::NoCommand;
             QByteArray text;
 
             // get text or command
             if ( tokens[2].type == Token::OutputText )
             {
                 text = tokens[2].text.toLocal8Bit();
@@ -297,22 +297,22 @@ void KeyboardTranslatorReader::readNext(
             newEntry.setCommand( command );
 
             _nextEntry = newEntry;
 
             _hasNext = true;
 
             return;
         }
-    } 
+    }
 
     _hasNext = false;
 }
 
-bool KeyboardTranslatorReader::parseAsCommand(const QString& text,KeyboardTranslator::Command& command) 
+bool KeyboardTranslatorReader::parseAsCommand(const QString& text,KeyboardTranslator::Command& command)
 {
     if ( text.compare("erase",Qt::CaseInsensitive) == 0 )
         command = KeyboardTranslator::EraseCommand;
     else if ( text.compare("scrollpageup",Qt::CaseInsensitive) == 0 )
         command = KeyboardTranslator::ScrollPageUpCommand;
     else if ( text.compare("scrollpagedown",Qt::CaseInsensitive) == 0 )
         command = KeyboardTranslator::ScrollPageDownCommand;
     else if ( text.compare("scrolllineup",Qt::CaseInsensitive) == 0 )
@@ -329,17 +329,17 @@ bool KeyboardTranslatorReader::parseAsCo
 
 bool KeyboardTranslatorReader::decodeSequence(const QString& text,
                                               int& keyCode,
                                               Qt::KeyboardModifiers& modifiers,
                                               Qt::KeyboardModifiers& modifierMask,
                                               KeyboardTranslator::States& flags,
                                               KeyboardTranslator::States& flagMask)
 {
-    bool isWanted = true; 
+    bool isWanted = true;
     bool endOfItem = false;
     QString buffer;
 
     Qt::KeyboardModifiers tempModifiers = modifiers;
     Qt::KeyboardModifiers tempModifierMask = modifierMask;
     KeyboardTranslator::States tempFlags = flags;
     KeyboardTranslator::States tempFlagMask = flagMask;
 
@@ -378,23 +378,23 @@ bool KeyboardTranslatorReader::decodeSeq
             else if ( parseAsKeyCode(buffer,itemKeyCode) )
                 keyCode = itemKeyCode;
             else
                 qDebug() << "Unable to parse key binding item:" << buffer;
 
             buffer.clear();
         }
 
-        // check if this is a wanted / not-wanted flag and update the 
+        // check if this is a wanted / not-wanted flag and update the
         // state ready for the next item
         if ( ch == '+' )
             isWanted = true;
         else if ( ch == '-' )
             isWanted = false;
-    } 
+    }
 
     modifiers = tempModifiers;
     modifierMask = tempModifierMask;
     flags = tempFlags;
     flagMask = tempFlagMask;
 
     return true;
 }
@@ -459,17 +459,17 @@ bool KeyboardTranslatorReader::parseAsKe
 QString KeyboardTranslatorReader::description() const
 {
     return _description;
 }
 bool KeyboardTranslatorReader::hasNextEntry()
 {
     return _hasNext;
 }
-KeyboardTranslator::Entry KeyboardTranslatorReader::createEntry( const QString& condition , 
+KeyboardTranslator::Entry KeyboardTranslatorReader::createEntry( const QString& condition ,
                                                                  const QString& result )
 {
     QString entryString("keyboard \"temporary\"\nkey ");
     entryString.append(condition);
     entryString.append(" : ");
 
     // if 'result' is the name of a command then the entry result will be that command,
     // otherwise the result will be treated as a string to echo when the key sequence
@@ -489,17 +489,17 @@ KeyboardTranslator::Entry KeyboardTransl
     KeyboardTranslatorReader reader(&buffer);
 
     if ( reader.hasNextEntry() )
         entry = reader.nextEntry();
 
     return entry;
 }
 
-KeyboardTranslator::Entry KeyboardTranslatorReader::nextEntry() 
+KeyboardTranslator::Entry KeyboardTranslatorReader::nextEntry()
 {
     Q_ASSERT( _hasNext );
 
 
     KeyboardTranslator::Entry entry = _nextEntry;
 
     readNext();
 
@@ -541,34 +541,34 @@ QList<KeyboardTranslatorReader::Token> K
         Token sequenceToken = { Token::KeySequence , key.capturedTexts()[1].remove(' ') };
 
         list << keyToken << sequenceToken;
 
         if ( key.capturedTexts()[3].isEmpty() )
         {
             // capturedTexts()[2] is a command
             Token commandToken = { Token::Command , key.capturedTexts()[2] };
-            list << commandToken;    
-        }   
+            list << commandToken;
+        }
         else
         {
             // capturedTexts()[3] is the output string
             Token outputToken = { Token::OutputText , key.capturedTexts()[3] };
             list << outputToken;
-        }     
+        }
     }
     else
     {
         qWarning() << "Line in keyboard translator file could not be understood:" << text;
     }
 
     return list;
 }
 
-QList<QString> KeyboardTranslatorManager::allTranslators() 
+QList<QString> KeyboardTranslatorManager::allTranslators()
 {
     if ( !_haveLoadedAll )
     {
         findTranslators();
     }
 
     return _translators.keys();
 }
@@ -589,34 +589,34 @@ bool KeyboardTranslator::Entry::operator
             _modifiers == rhs._modifiers &&
             _modifierMask == rhs._modifierMask &&
             _state == rhs._state &&
             _stateMask == rhs._stateMask &&
             _command == rhs._command &&
             _text == rhs._text;
 }
 
-bool KeyboardTranslator::Entry::matches(int keyCode , 
+bool KeyboardTranslator::Entry::matches(int keyCode ,
                                         Qt::KeyboardModifiers modifiers,
                                         States state) const
 {
     if ( _keyCode != keyCode )
         return false;
 
-    if ( (modifiers & _modifierMask) != (_modifiers & _modifierMask) ) 
+    if ( (modifiers & _modifierMask) != (_modifiers & _modifierMask) )
         return false;
 
     // if modifiers is non-zero, the 'any modifier' state is implicit
     if ( modifiers != 0 )
         state |= AnyModifierState;
 
     if ( (state & _stateMask) != (_state & _stateMask) )
         return false;
 
-    // special handling for the 'Any Modifier' state, which checks for the presence of 
+    // special handling for the 'Any Modifier' state, which checks for the presence of
     // any or no modifiers.  In this context, the 'keypad' modifier does not count.
     bool anyModifiersSet = modifiers != 0 && modifiers != Qt::KeypadModifier;
     if ( _stateMask & KeyboardTranslator::AnyModifierState )
     {
         // test fails if any modifier is required but none are set
         if ( (_state & KeyboardTranslator::AnyModifierState) && !anyModifiersSet )
             return false;
 
@@ -648,17 +648,17 @@ QByteArray KeyboardTranslator::Entry::es
             // any character which is not printable is replaced by an equivalent
             // \xhh escape sequence (where 'hh' are the corresponding hex digits)
             if ( !QChar(ch).isPrint() )
                 replacement = 'x';
         }
 
         if ( replacement == 'x' )
         {
-            result.replace(i,1,"\\x"+QByteArray(1,ch).toInt(0, 16)); 
+            result.replace(i,1,"\\x"+QByteArray(1,ch).toInt(0, 16));
         } else if ( replacement != 0 )
         {
             result.remove(i,1);
             result.insert(i,'\\');
             result.insert(i+1,replacement);
         }
     }
 
@@ -709,17 +709,17 @@ QByteArray KeyboardTranslator::Entry::un
             default:
                 escapedChar = false;
             }
 
             if ( escapedChar )
                 result.replace(i,charsToRemove,replacement);
         }
     }
-    
+
     return result;
 }
 
 void KeyboardTranslator::Entry::insertModifier( QString& item , int modifier ) const
 {
     if ( !(modifier & _modifierMask) )
         return;
 
@@ -782,34 +782,34 @@ QString KeyboardTranslator::Entry::resul
 QString KeyboardTranslator::Entry::conditionToString() const
 {
     QString result = QKeySequence(_keyCode).toString();
 
     // add modifiers
     insertModifier( result , Qt::ShiftModifier );
     insertModifier( result , Qt::ControlModifier );
     insertModifier( result , Qt::AltModifier );
-    insertModifier( result , Qt::MetaModifier ); 
+    insertModifier( result , Qt::MetaModifier );
 
     // add states
     insertState( result , KeyboardTranslator::AlternateScreenState );
     insertState( result , KeyboardTranslator::NewLineState );
     insertState( result , KeyboardTranslator::AnsiState );
     insertState( result , KeyboardTranslator::CursorKeysState );
     insertState( result , KeyboardTranslator::AnyModifierState );
 
     return result;
 }
 
 KeyboardTranslator::KeyboardTranslator(const QString& name)
     : _name(name)
 {
 }
 
-void KeyboardTranslator::setDescription(const QString& description) 
+void KeyboardTranslator::setDescription(const QString& description)
 {
     _description = description;
 }
 QString KeyboardTranslator::description() const
 {
     return _description;
 }
 void KeyboardTranslator::setName(const QString& name)
@@ -841,33 +841,33 @@ void KeyboardTranslator::removeEntry(con
 {
     _entries.remove(entry.keyCode());
 }
 KeyboardTranslator::Entry KeyboardTranslator::findEntry(int keyCode, Qt::KeyboardModifiers modifiers, States state) const
 {
     if ( _entries.contains(keyCode) )
     {
         QList<Entry> entriesForKey = _entries.values(keyCode);
-        
+
         QListIterator<Entry> iter(entriesForKey);
 
         while (iter.hasNext())
         {
             const Entry& next = iter.next();
             if ( next.matches(keyCode,modifiers,state) )
                 return next;
         }
 
         return Entry(); // entry not found
     }
     else
     {
         return Entry();
     }
-    
+
 }
 void KeyboardTranslatorManager::addTranslator(KeyboardTranslator* translator)
 {
     _translators.insert(translator->name(),translator);
 
     if ( !saveTranslator(translator) )
         qWarning() << "Unable to save translator" << translator->name()
                    << "to disk.";
@@ -876,17 +876,17 @@ bool KeyboardTranslatorManager::deleteTr
 {
     Q_ASSERT( _translators.contains(name) );
 
     // locate and delete
     QString path = findTranslatorPath(name);
     if ( QFile::remove(path) )
     {
         _translators.remove(name);
-        return true; 
+        return true;
     }
     else
     {
         qWarning() << "Failed to remove translator - " << path;
         return false;
     }
 }
 K_GLOBAL_STATIC( KeyboardTranslatorManager , theKeyboardTranslatorManager )
diff --git a/libgui/qterminal/libqterminal/unix/KeyboardTranslator.h b/libgui/qterminal/libqterminal/unix/KeyboardTranslator.h
--- a/libgui/qterminal/libqterminal/unix/KeyboardTranslator.h
+++ b/libgui/qterminal/libqterminal/unix/KeyboardTranslator.h
@@ -105,63 +105,63 @@ static struct K_GLOBAL_STATIC_STRUCT_NAM
 								
 								
 
 
 
 class QIODevice;
 class QTextStream;
 
-/** 
+/**
  * A convertor which maps between key sequences pressed by the user and the
  * character strings which should be sent to the terminal and commands
  * which should be invoked when those character sequences are pressed.
  *
  * Konsole supports multiple keyboard translators, allowing the user to
  * specify the character sequences which are sent to the terminal
  * when particular key sequences are pressed.
  *
  * A key sequence is defined as a key code, associated keyboard modifiers
  * (Shift,Ctrl,Alt,Meta etc.) and state flags which indicate the state
  * which the terminal must be in for the key sequence to apply.
  */
 class KeyboardTranslator
 {
 public:
-    /** 
+    /**
      * The meaning of a particular key sequence may depend upon the state which
      * the terminal emulation is in.  Therefore findEntry() may return a different
      * Entry depending upon the state flags supplied.
      *
      * This enum describes the states which may be associated with with a particular
      * entry in the keyboard translation entry.
      */
     enum State
     {
         /** Indicates that no special state is active */
         NoState = 0,
         /**
          * TODO More documentation
          */
         NewLineState = 1,
-        /** 
+        /**
          * Indicates that the terminal is in 'Ansi' mode.
          * TODO: More documentation
          */
         AnsiState = 2,
         /**
          * TODO More documentation
          */
         CursorKeysState = 4,
         /**
          * Indicates that the alternate screen ( typically used by interactive programs
-         * such as screen or vim ) is active 
+         * such as screen or vim ) is active
          */
         AlternateScreenState = 8,
-        /** Indicates that any of the modifier keys is active. */ 
+        /** Indicates that any of the modifier keys is active. */
         AnyModifierState = 16
     };
     Q_DECLARE_FLAGS(States,State)
 
     /**
      * This enum describes commands which are associated with particular key sequences.
      */
     enum Command
@@ -188,135 +188,135 @@ public:
     /**
      * Represents an association between a key sequence pressed by the user
      * and the character sequence and commands associated with it for a particular
      * KeyboardTranslator.
      */
     class Entry
     {
     public:
-        /** 
+        /**
          * Constructs a new entry for a keyboard translator.
          */
         Entry();
 
-        /** 
+        /**
          * Returns true if this entry is null.
-         * This is true for newly constructed entries which have no properties set. 
+         * This is true for newly constructed entries which have no properties set.
          */
         bool isNull() const;
 
         /** Returns the commands associated with this entry */
         Command command() const;
         /** Sets the command associated with this entry. */
         void setCommand(Command command);
 
-        /** 
-         * Returns the character sequence associated with this entry, optionally replacing 
+        /**
+         * Returns the character sequence associated with this entry, optionally replacing
          * wildcard '*' characters with numbers to indicate the keyboard modifiers being pressed.
          *
          * TODO: The numbers used to replace '*' characters are taken from the Konsole/KDE 3 code.
-         * Document them. 
+         * Document them.
          *
          * @param expandWildCards Specifies whether wild cards (occurrences of the '*' character) in
-         * the entry should be replaced with a number to indicate the modifier keys being pressed. 
+         * the entry should be replaced with a number to indicate the modifier keys being pressed.
          *
          * @param modifiers The keyboard modifiers being pressed.
          */
         QByteArray text(bool expandWildCards = false,
                         Qt::KeyboardModifiers modifiers = Qt::NoModifier) const;
 
         /** Sets the character sequence associated with this entry */
         void setText(const QByteArray& text);
 
-        /** 
+        /**
          * Returns the character sequence associated with this entry,
          * with any non-printable characters replaced with escape sequences.
          *
          * eg. \\E for Escape, \\t for tab, \\n for new line.
          *
          * @param expandWildCards See text()
          * @param modifiers See text()
          */
         QByteArray escapedText(bool expandWildCards = false,
                                Qt::KeyboardModifiers modifiers = Qt::NoModifier) const;
 
         /** Returns the character code ( from the Qt::Key enum ) associated with this entry */
         int keyCode() const;
         /** Sets the character code associated with this entry */
         void setKeyCode(int keyCode);
 
-        /** 
-         * Returns a bitwise-OR of the enabled keyboard modifiers associated with this entry. 
+        /**
+         * Returns a bitwise-OR of the enabled keyboard modifiers associated with this entry.
          * If a modifier is set in modifierMask() but not in modifiers(), this means that the entry
          * only matches when that modifier is NOT pressed.
          *
          * If a modifier is not set in modifierMask() then the entry matches whether the modifier
-         * is pressed or not. 
+         * is pressed or not.
          */
         Qt::KeyboardModifiers modifiers() const;
 
         /** Returns the keyboard modifiers which are valid in this entry.  See modifiers() */
         Qt::KeyboardModifiers modifierMask() const;
 
         /** See modifiers() */
         void setModifiers( Qt::KeyboardModifiers modifiers );
         /** See modifierMask() and modifiers() */
         void setModifierMask( Qt::KeyboardModifiers modifiers );
 
-        /** 
-         * Returns a bitwise-OR of the enabled state flags associated with this entry. 
-         * If flag is set in stateMask() but not in state(), this means that the entry only 
+        /**
+         * Returns a bitwise-OR of the enabled state flags associated with this entry.
+         * If flag is set in stateMask() but not in state(), this means that the entry only
          * matches when the terminal is NOT in that state.
          *
          * If a state is not set in stateMask() then the entry matches whether the terminal
-         * is in that state or not. 
+         * is in that state or not.
          */
         States state() const;
 
         /** Returns the state flags which are valid in this entry.  See state() */
         States stateMask() const;
 
         /** See state() */
         void setState( States state );
         /** See stateMask() */
         void setStateMask( States mask );
 
-        /** 
-         * Returns the key code and modifiers associated with this entry 
+        /**
+         * Returns the key code and modifiers associated with this entry
          * as a QKeySequence
          */
         //QKeySequence keySequence() const;
 
-        /** 
+        /**
          * Returns this entry's conditions ( ie. its key code, modifier and state criteria )
          * as a string.
          */
         QString conditionToString() const;
 
         /**
          * Returns this entry's result ( ie. its command or character sequence )
          * as a string.
          *
          * @param expandWildCards See text()
          * @param modifiers See text()
          */
         QString resultToString(bool expandWildCards = false,
                                Qt::KeyboardModifiers modifiers = Qt::NoModifier) const;
 
-        /** 
+        /**
          * Returns true if this entry matches the given key sequence, specified
          * as a combination of @p keyCode , @p modifiers and @p state.
          */
-        bool matches( int keyCode , 
-                      Qt::KeyboardModifiers modifiers , 
+        bool matches( int keyCode ,
+                      Qt::KeyboardModifiers modifiers ,
                       States flags ) const;
 
         bool operator==(const Entry& rhs) const;
-       
+
     private:
         void insertModifier( QString& item , int modifier ) const;
         void insertState( QString& item , int state ) const;
         QByteArray unescape(const QByteArray& text) const;
 
         int _keyCode;
         Qt::KeyboardModifiers _modifiers;
         Qt::KeyboardModifiers _modifierMask;
@@ -324,17 +324,17 @@ public:
         States _stateMask;
 
         Command _command;
         QByteArray _text;
     };
 
     /** Constructs a new keyboard translator with the given @p name */
     KeyboardTranslator(const QString& name);
-   
+
     //KeyboardTranslator(const KeyboardTranslator& other);
 
     /** Returns the name of this keyboard translator */
     QString name() const;
 
     /** Sets the name of this keyboard translator */
     void setName(const QString& name);
 
@@ -342,29 +342,29 @@ public:
     QString description() const;
 
     /** Sets the descriptive name of this keyboard translator */
     void setDescription(const QString& description);
 
     /**
      * Looks for an entry in this keyboard translator which matches the given
      * key code, keyboard modifiers and state flags.
-     * 
+     *
      * Returns the matching entry if found or a null Entry otherwise ( ie.
      * entry.isNull() will return true )
      *
      * @param keyCode A key code from the Qt::Key enum
      * @param modifiers A combination of modifiers
      * @param state Optional flags which specify the current state of the terminal
      */
-    Entry findEntry(int keyCode , 
-                    Qt::KeyboardModifiers modifiers , 
+    Entry findEntry(int keyCode ,
+                    Qt::KeyboardModifiers modifiers ,
                     States state = NoState) const;
 
-    /** 
+    /**
      * Adds an entry to this keyboard translator's table.  Entries can be looked up according
      * to their key sequence using findEntry()
      */
     void addEntry(const Entry& entry);
 
     /**
      * Replaces an entry in the translator.  If the @p existing entry is null,
      * then this is equivalent to calling addEntry(@p replacement)
@@ -385,18 +385,18 @@ private:
                                                  // entries are indexed according to
                                                  // their keycode
     QString _name;
     QString _description;
 };
 Q_DECLARE_OPERATORS_FOR_FLAGS(KeyboardTranslator::States)
 Q_DECLARE_OPERATORS_FOR_FLAGS(KeyboardTranslator::Commands)
 
-/** 
- * Parses the contents of a Keyboard Translator (.keytab) file and 
+/**
+ * Parses the contents of a Keyboard Translator (.keytab) file and
  * returns the entries found in it.
  *
  * Usage example:
  *
  * @code
  *  QFile source( "/path/to/keytab" );
  *  source.open( QIODevice::ReadOnly );
  *
@@ -406,51 +406,51 @@ Q_DECLARE_OPERATORS_FOR_FLAGS(KeyboardTr
  *  while ( reader.hasNextEntry() )
  *      translator->addEntry(reader.nextEntry());
  *
  *  source.close();
  *
  *  if ( !reader.parseError() )
  *  {
  *      // parsing succeeded, do something with the translator
- *  } 
+ *  }
  *  else
  *  {
  *      // parsing failed
  *  }
  * @endcode
  */
 class KeyboardTranslatorReader
 {
 public:
     /** Constructs a new reader which parses the given @p source */
     KeyboardTranslatorReader( QIODevice* source );
 
-    /** 
-     * Returns the description text. 
-     * TODO: More documentation 
+    /**
+     * Returns the description text.
+     * TODO: More documentation
      */
     QString description() const;
 
     /** Returns true if there is another entry in the source stream */
     bool hasNextEntry();
     /** Returns the next entry found in the source stream */
-    KeyboardTranslator::Entry nextEntry(); 
+    KeyboardTranslator::Entry nextEntry();
 
-    /** 
+    /**
      * Returns true if an error occurred whilst parsing the input or
      * false if no error occurred.
      */
     bool parseError();
 
     /**
      * Parses a condition and result string for a translator entry
      * and produces a keyboard translator entry.
      *
-     * The condition and result strings are in the same format as in  
+     * The condition and result strings are in the same format as in
      */
     static KeyboardTranslator::Entry createEntry( const QString& condition ,
                                                   const QString& result );
 private:
     struct Token
     {
         enum Type
         {
@@ -461,17 +461,17 @@ private:
             Command,
             OutputText
         };
         Type type;
         QString text;
     };
     QList<Token> tokenize(const QString&);
     void readNext();
-    bool decodeSequence(const QString& , 
+    bool decodeSequence(const QString& ,
                                 int& keyCode,
                                 Qt::KeyboardModifiers& modifiers,
                                 Qt::KeyboardModifiers& modifierMask,
                                 KeyboardTranslator::States& state,
                                 KeyboardTranslator::States& stateFlags);
 
     static bool parseAsModifier(const QString& item , Qt::KeyboardModifier& modifier);
     static bool parseAsStateFlag(const QString& item , KeyboardTranslator::State& state);
@@ -483,168 +483,168 @@ private:
     KeyboardTranslator::Entry _nextEntry;
     bool _hasNext;
 };
 
 /** Writes a keyboard translation to disk. */
 class KeyboardTranslatorWriter
 {
 public:
-    /** 
+    /**
      * Constructs a new writer which saves data into @p destination.
      * The caller is responsible for closing the device when writing is complete.
      */
     KeyboardTranslatorWriter(QIODevice* destination);
     ~KeyboardTranslatorWriter();
 
-    /** 
-     * Writes the header for the keyboard translator. 
-     * @param description Description of the keyboard translator. 
+    /**
+     * Writes the header for the keyboard translator.
+     * @param description Description of the keyboard translator.
      */
     void writeHeader( const QString& description );
     /** Writes a translator entry. */
-    void writeEntry( const KeyboardTranslator::Entry& entry ); 
+    void writeEntry( const KeyboardTranslator::Entry& entry );
 
 private:
-    QIODevice* _destination;  
+    QIODevice* _destination;
     QTextStream* _writer;
 };
 
 /**
  * Manages the keyboard translations available for use by terminal sessions,
  * see KeyboardTranslator.
  */
 class KeyboardTranslatorManager
 {
 public:
-    /** 
+    /**
      * Constructs a new KeyboardTranslatorManager and loads the list of
      * available keyboard translations.
      *
      * The keyboard translations themselves are not loaded until they are
      * first requested via a call to findTranslator()
      */
     KeyboardTranslatorManager();
     ~KeyboardTranslatorManager();
 
     /**
-     * Adds a new translator.  If a translator with the same name 
+     * Adds a new translator.  If a translator with the same name
      * already exists, it will be replaced by the new translator.
      *
      * TODO: More documentation.
      */
     void addTranslator(KeyboardTranslator* translator);
 
     /**
      * Deletes a translator.  Returns true on successful deletion or false otherwise.
      *
      * TODO: More documentation
      */
     bool deleteTranslator(const QString& name);
 
     /** Returns the default translator for Konsole. */
     const KeyboardTranslator* defaultTranslator();
 
-    /** 
+    /**
      * Returns the keyboard translator with the given name or 0 if no translator
      * with that name exists.
      *
      * The first time that a translator with a particular name is requested,
-     * the on-disk .keyboard file is loaded and parsed.  
+     * the on-disk .keyboard file is loaded and parsed.
      */
     const KeyboardTranslator* findTranslator(const QString& name);
     /**
      * Returns a list of the names of available keyboard translators.
      *
-     * The first time this is called, a search for available 
+     * The first time this is called, a search for available
      * translators is started.
      */
     QList<QString> allTranslators();
 
     /** Returns the global KeyboardTranslatorManager instance. */
    static KeyboardTranslatorManager* instance();
 
 private:
     static const char* defaultTranslatorText;
-    
+
     void findTranslators(); // locate the available translators
-    KeyboardTranslator* loadTranslator(const QString& name); // loads the translator 
+    KeyboardTranslator* loadTranslator(const QString& name); // loads the translator
                                                              // with the given name
     KeyboardTranslator* loadTranslator(QIODevice* device,const QString& name);
 
     bool saveTranslator(const KeyboardTranslator* translator);
     QString findTranslatorPath(const QString& name);
-    
+
     QHash<QString,KeyboardTranslator*> _translators; // maps translator-name -> KeyboardTranslator
                                                      // instance
     bool _haveLoadedAll;
 };
 
 inline int KeyboardTranslator::Entry::keyCode() const { return _keyCode; }
 inline void KeyboardTranslator::Entry::setKeyCode(int keyCode) { _keyCode = keyCode; }
 
-inline void KeyboardTranslator::Entry::setModifiers( Qt::KeyboardModifiers modifier ) 
-{ 
+inline void KeyboardTranslator::Entry::setModifiers( Qt::KeyboardModifiers modifier )
+{
     _modifiers = modifier;
 }
 inline Qt::KeyboardModifiers KeyboardTranslator::Entry::modifiers() const { return _modifiers; }
 
-inline void  KeyboardTranslator::Entry::setModifierMask( Qt::KeyboardModifiers mask ) 
-{ 
-   _modifierMask = mask; 
+inline void  KeyboardTranslator::Entry::setModifierMask( Qt::KeyboardModifiers mask )
+{
+   _modifierMask = mask;
 }
 inline Qt::KeyboardModifiers KeyboardTranslator::Entry::modifierMask() const { return _modifierMask; }
 
 inline bool KeyboardTranslator::Entry::isNull() const
 {
     return ( *this == Entry() );
 }
 
 inline void KeyboardTranslator::Entry::setCommand( Command command )
-{ 
-    _command = command; 
+{
+    _command = command;
 }
 inline KeyboardTranslator::Command KeyboardTranslator::Entry::command() const { return _command; }
 
 inline void KeyboardTranslator::Entry::setText( const QByteArray& text )
-{ 
+{
     _text = unescape(text);
 }
 inline int oneOrZero(int value)
 {
     return value ? 1 : 0;
 }
-inline QByteArray KeyboardTranslator::Entry::text(bool expandWildCards,Qt::KeyboardModifiers modifiers) const 
+inline QByteArray KeyboardTranslator::Entry::text(bool expandWildCards,Qt::KeyboardModifiers modifiers) const
 {
     QByteArray expandedText = _text;
-    
+
     if (expandWildCards)
     {
         int modifierValue = 1;
         modifierValue += oneOrZero(modifiers & Qt::ShiftModifier);
         modifierValue += oneOrZero(modifiers & Qt::AltModifier)     << 1;
         modifierValue += oneOrZero(modifiers & Qt::ControlModifier) << 2;
 
-        for (int i=0;i<_text.length();i++) 
+        for (int i=0;i<_text.length();i++)
         {
             if (expandedText[i] == '*')
                 expandedText[i] = '0' + modifierValue;
         }
     }
 
-    return expandedText; 
+    return expandedText;
 }
 
 inline void KeyboardTranslator::Entry::setState( States state )
-{ 
-    _state = state; 
+{
+    _state = state;
 }
 inline KeyboardTranslator::States KeyboardTranslator::Entry::state() const { return _state; }
 
 inline void KeyboardTranslator::Entry::setStateMask( States stateMask )
-{ 
-    _stateMask = stateMask; 
+{
+    _stateMask = stateMask;
 }
 inline KeyboardTranslator::States KeyboardTranslator::Entry::stateMask() const { return _stateMask; }
 
 
 #endif // KEYBOARDTRANSLATOR_H
 
diff --git a/libgui/qterminal/libqterminal/unix/LineFont.h b/libgui/qterminal/libqterminal/unix/LineFont.h
--- a/libgui/qterminal/libqterminal/unix/LineFont.h
+++ b/libgui/qterminal/libqterminal/unix/LineFont.h
@@ -1,21 +1,21 @@
 // WARNING: Autogenerated by "fontembedder ./linefont.src".
 // You probably do not want to hand-edit this!
 
 static const quint32 LineChars[] = {
-	0x00007c00, 0x000fffe0, 0x00421084, 0x00e739ce, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00427000, 0x004e7380, 0x00e77800, 0x00ef7bc0, 
-	0x00421c00, 0x00439ce0, 0x00e73c00, 0x00e7bde0, 0x00007084, 0x000e7384, 0x000079ce, 0x000f7bce, 
-	0x00001c84, 0x00039ce4, 0x00003dce, 0x0007bdee, 0x00427084, 0x004e7384, 0x004279ce, 0x00e77884, 
-	0x00e779ce, 0x004f7bce, 0x00ef7bc4, 0x00ef7bce, 0x00421c84, 0x00439ce4, 0x00423dce, 0x00e73c84, 
-	0x00e73dce, 0x0047bdee, 0x00e7bde4, 0x00e7bdee, 0x00427c00, 0x0043fce0, 0x004e7f80, 0x004fffe0, 
-	0x004fffe0, 0x00e7fde0, 0x006f7fc0, 0x00efffe0, 0x00007c84, 0x0003fce4, 0x000e7f84, 0x000fffe4, 
-	0x00007dce, 0x0007fdee, 0x000f7fce, 0x000fffee, 0x00427c84, 0x0043fce4, 0x004e7f84, 0x004fffe4, 
-	0x00427dce, 0x00e77c84, 0x00e77dce, 0x0047fdee, 0x004e7fce, 0x00e7fde4, 0x00ef7f84, 0x004fffee, 
-	0x00efffe4, 0x00e7fdee, 0x00ef7fce, 0x00efffee, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
-	0x000f83e0, 0x00a5294a, 0x004e1380, 0x00a57800, 0x00ad0bc0, 0x004390e0, 0x00a53c00, 0x00a5a1e0, 
-	0x000e1384, 0x0000794a, 0x000f0b4a, 0x000390e4, 0x00003d4a, 0x0007a16a, 0x004e1384, 0x00a5694a, 
-	0x00ad2b4a, 0x004390e4, 0x00a52d4a, 0x00a5a16a, 0x004f83e0, 0x00a57c00, 0x00ad83e0, 0x000f83e4, 
-	0x00007d4a, 0x000f836a, 0x004f93e4, 0x00a57d4a, 0x00ad836a, 0x00000000, 0x00000000, 0x00000000, 
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00001c00, 0x00001084, 0x00007000, 0x00421000, 
+	0x00007c00, 0x000fffe0, 0x00421084, 0x00e739ce, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00427000, 0x004e7380, 0x00e77800, 0x00ef7bc0,
+	0x00421c00, 0x00439ce0, 0x00e73c00, 0x00e7bde0, 0x00007084, 0x000e7384, 0x000079ce, 0x000f7bce,
+	0x00001c84, 0x00039ce4, 0x00003dce, 0x0007bdee, 0x00427084, 0x004e7384, 0x004279ce, 0x00e77884,
+	0x00e779ce, 0x004f7bce, 0x00ef7bc4, 0x00ef7bce, 0x00421c84, 0x00439ce4, 0x00423dce, 0x00e73c84,
+	0x00e73dce, 0x0047bdee, 0x00e7bde4, 0x00e7bdee, 0x00427c00, 0x0043fce0, 0x004e7f80, 0x004fffe0,
+	0x004fffe0, 0x00e7fde0, 0x006f7fc0, 0x00efffe0, 0x00007c84, 0x0003fce4, 0x000e7f84, 0x000fffe4,
+	0x00007dce, 0x0007fdee, 0x000f7fce, 0x000fffee, 0x00427c84, 0x0043fce4, 0x004e7f84, 0x004fffe4,
+	0x00427dce, 0x00e77c84, 0x00e77dce, 0x0047fdee, 0x004e7fce, 0x00e7fde4, 0x00ef7f84, 0x004fffee,
+	0x00efffe4, 0x00e7fdee, 0x00ef7fce, 0x00efffee, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x000f83e0, 0x00a5294a, 0x004e1380, 0x00a57800, 0x00ad0bc0, 0x004390e0, 0x00a53c00, 0x00a5a1e0,
+	0x000e1384, 0x0000794a, 0x000f0b4a, 0x000390e4, 0x00003d4a, 0x0007a16a, 0x004e1384, 0x00a5694a,
+	0x00ad2b4a, 0x004390e4, 0x00a52d4a, 0x00a5a16a, 0x004f83e0, 0x00a57c00, 0x00ad83e0, 0x000f83e4,
+	0x00007d4a, 0x000f836a, 0x004f93e4, 0x00a57d4a, 0x00ad836a, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00001c00, 0x00001084, 0x00007000, 0x00421000,
 	0x00039ce0, 0x000039ce, 0x000e7380, 0x00e73800, 0x000e7f80, 0x00e73884, 0x0003fce0, 0x004239ce
 };
diff --git a/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.cpp b/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.cpp
--- a/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.cpp
+++ b/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.cpp
@@ -146,18 +146,18 @@ void QUnixTerminalImpl::setCursorType(Cu
         case BlockCursor: m_terminalView->setKeyboardCursorShape(TerminalView::BlockCursor); break;
         case IBeamCursor: m_terminalView->setKeyboardCursorShape(TerminalView::IBeamCursor); break;
     }
     m_terminalView->setBlinkingCursor(blinking);
 }
 
 // FIXME -- not sure how to make these work properly given the way the
 // Unix terminal handles colors.
-void QUnixTerminalImpl::setBackgroundColor (const QColor& color) 
-  { 
+void QUnixTerminalImpl::setBackgroundColor (const QColor& color)
+  {
     ColorEntry cols[TABLE_COLORS];
 
     const ColorEntry * curr_cols = m_terminalView->colorTable();
     for(int i=0;i<TABLE_COLORS;i++)
     {
      cols[i] = curr_cols[i];
     }
 
diff --git a/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.h b/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.h
--- a/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.h
+++ b/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.h
@@ -1,27 +1,27 @@
 /*  Copyright (C) 2008 e_k (e_k@users.sourceforge.net)
     Copyright (C) 2012-2013 Jacob Dawid <jacob.dawid@googlemail.com>
 
     This library is free software; you can redistribute it and/or
     modify it under the terms of the GNU Library General Public
     License as published by the Free Software Foundation; either
     version 2 of the License, or (at your option) any later version.
-		    
+		
     This library is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     Library General Public License for more details.
-			    
+			
     You should have received a copy of the GNU Library General Public License
     along with this library; see the file COPYING.LIB.  If not, write to
     the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
     Boston, MA 02110-1301, USA.
 */
-						    
+						
 
 #ifndef Q_UNIXTERMINALIMPL
 #define Q_UNIXTERMINALIMPL
 
 #include <QtGui>
 #include "unix/kpty.h"
 #include "unix/TerminalModel.h"
 #include "unix/TerminalView.h"
@@ -32,17 +32,17 @@ class QUnixTerminalImpl : public QTermin
     Q_OBJECT
 
     int fdstderr;
 
 public:
     QUnixTerminalImpl(QWidget *parent = 0);
     virtual ~QUnixTerminalImpl();
 
-    void setTerminalFont(const QFont &font); 
+    void setTerminalFont(const QFont &font);
     void setSize(int h, int v);
     void sendText(const QString& text);
 
     void setCursorType(CursorType type, bool blinking);
 
     void setBackgroundColor (const QColor& color);
     void setForegroundColor (const QColor& color);
     void setSelectionColor (const QColor& color);
@@ -52,17 +52,17 @@ public:
 
 public slots:
     void copyClipboard();
     void pasteClipboard();
     void selectAll();
 
 protected:
     void showEvent(QShowEvent *);
-    virtual void resizeEvent(QResizeEvent *);   
+    virtual void resizeEvent(QResizeEvent *);
 
 private:
     void initialize();
     void connectToPty();
 
     TerminalView *m_terminalView;
     TerminalModel *m_terminalModel;
     KPty *m_kpty;
diff --git a/libgui/qterminal/libqterminal/unix/Screen.cpp b/libgui/qterminal/libqterminal/unix/Screen.cpp
--- a/libgui/qterminal/libqterminal/unix/Screen.cpp
+++ b/libgui/qterminal/libqterminal/unix/Screen.cpp
@@ -40,20 +40,20 @@
 #include "unix/TerminalCharacterDecoder.h"
 
 //FIXME: this is emulation specific. Use false for xterm, true for ANSI.
 //FIXME: see if we can get this from terminfo.
 #define BS_CLEARS false
 
 //Macro to convert x,y position on screen to position within an image.
 //
-//Originally the image was stored as one large contiguous block of 
+//Originally the image was stored as one large contiguous block of
 //memory, so a position within the image could be represented as an
 //offset from the beginning of the block.  For efficiency reasons this
-//is no longer the case.  
+//is no longer the case.
 //Many internal parts of this class still use this representation for parameters and so on,
 //notably moveImage() and clearImage().
 //This macro converts from an X,Y position into an image offset.
 #ifndef loc
 #define loc(X,Y) ((Y)*columns+(X))
 #endif
 
 
@@ -244,24 +244,24 @@ void Screen::eraseChars(int n)
   clearImage(loc(cuX,cuY),loc(p,cuY),' ');
 }
 
 void Screen::deleteChars(int n)
 {
   Q_ASSERT( n >= 0 );
 
   // always delete at least one char
-  if (n == 0) 
-      n = 1; 
+  if (n == 0)
+      n = 1;
 
   // if cursor is beyond the end of the line there is nothing to do
   if ( cuX >= screenLines[cuY].count() )
       return;
 
-  if ( cuX+n >= screenLines[cuY].count() ) 
+  if ( cuX+n >= screenLines[cuY].count() )
        n = screenLines[cuY].count() - 1 - cuX;
 
   Q_ASSERT( n >= 0 );
   Q_ASSERT( cuX+n < screenLines[cuY].count() );
 
   screenLines[cuY].remove(cuX,n);
 }
 
@@ -386,30 +386,30 @@ void Screen::resizeImage(int new_lines, 
     bmargin = lines-1; //FIXME: margin lost
     for (int i = 0; i < cuY-(new_lines-1); i++)
     {
       addHistLine(); scrollUp(0,1);
     }
   }
 
   // create new screen lines and copy from old to new
-  
+
    ImageLine* newScreenLines = new ImageLine[new_lines+1];
    for (int i=0; i < qMin(lines-1,new_lines+1) ;i++)
            newScreenLines[i]=screenLines[i];
    for (int i=lines;(i > 0) && (i<new_lines+1);i++)
            newScreenLines[i].resize( new_columns );
-   
+
   lineProperties.resize(new_lines+1);
   for (int i=lines;(i > 0) && (i<new_lines+1);i++)
           lineProperties[i] = LINE_DEFAULT;
 
   clearSelection();
- 
-  delete[] screenLines; 
+
+  delete[] screenLines;
   screenLines = newScreenLines;
 
   lines = new_lines;
   columns = new_columns;
   cuX = qMin(cuX,columns-1);
   cuY = qMin(cuY,lines-1);
 
   // FIXME: try to keep values, evtl.
@@ -456,50 +456,50 @@ void Screen::setDefaultMargins()
    is to poor to distinguish between bold
    (which is a font attribute) and intensive
    (which is a color attribute), we translate
    this and RE_BOLD in falls eventually appart
    into RE_BOLD and RE_INTENSIVE.
 */
 
 void Screen::reverseRendition(Character& p) const
-{ 
-	CharacterColor f = p.foregroundColor; 
+{
+	CharacterColor f = p.foregroundColor;
 	CharacterColor b = p.backgroundColor;
   	
-	p.foregroundColor = b; 
+	p.foregroundColor = b;
 	p.backgroundColor = f; //p->r &= ~RE_TRANSPARENT;
 }
 
 void Screen::effectiveRendition()
 // calculate rendition
 {
   //copy "current rendition" straight into "effective rendition", which is then later copied directly
   //into the image[] array which holds the characters and their appearance properties.
   //- The old version below filtered out all attributes other than underline and blink at this stage,
   //so that they would not be copied into the image[] array and hence would not be visible by TerminalDisplay
-  //which actually paints the screen using the information from the image[] array.  
+  //which actually paints the screen using the information from the image[] array.
   //I don't know why it did this, but I'm fairly sure it was the wrong thing to do.  The net result
   //was that bold text wasn't printed in bold by Konsole.
   ef_re = cu_re;
-  
+
   //OLD VERSION:
   //ef_re = cu_re & (RE_UNDERLINE | RE_BLINK);
-  
+
   if (cu_re & RE_REVERSE)
   {
     ef_fg = cu_bg;
     ef_bg = cu_fg;
   }
   else
   {
     ef_fg = cu_fg;
     ef_bg = cu_bg;
   }
- 
+
   if (cu_re & RE_BOLD)
     ef_fg.toggleIntensive();
 }
 
 /*!
     returns the image.
 
     Get the size of the image by \sa getLines and \sa getColumns.
@@ -508,125 +508,125 @@ void Screen::effectiveRendition()
     freed.
 
 */
 
 void Screen::copyFromHistory(Character* dest, int startLine, int count) const
 {
   Q_ASSERT( startLine >= 0 && count > 0 && startLine + count <= hist->getLines() );
 
-  for (int line = startLine; line < startLine + count; line++) 
+  for (int line = startLine; line < startLine + count; line++)
   {
     const int length = qMin(columns,hist->getLineLen(line));
     const int destLineOffset  = (line-startLine)*columns;
 
     hist->getCells(line,0,length,dest + destLineOffset);
 
-    for (int column = length; column < columns; column++) 
+    for (int column = length; column < columns; column++)
 		dest[destLineOffset+column] = defaultChar;
-    
+
 	// invert selected text
 	if (sel_begin !=-1)
 	{
     	for (int column = 0; column < columns; column++)
     	{
-        	if (isSelected(column,line)) 
+        	if (isSelected(column,line))
 			{
-          		reverseRendition(dest[destLineOffset + column]); 
+          		reverseRendition(dest[destLineOffset + column]);
     		}
   		}
 	}
   }
 }
 
 void Screen::copyFromScreen(Character* dest , int startLine , int count) const
 {
 	Q_ASSERT( startLine >= 0 && count > 0 && startLine + count <= lines );
 
     for (int line = startLine; line < (startLine+count) ; line++)
     {
        int srcLineStartIndex  = line*columns;
 	   int destLineStartIndex = (line-startLine)*columns;
 
        for (int column = 0; column < columns; column++)
-       { 
-		 int srcIndex = srcLineStartIndex + column; 
+       {
+		 int srcIndex = srcLineStartIndex + column;
 		 int destIndex = destLineStartIndex + column;
 
          dest[destIndex] = screenLines[srcIndex/columns].value(srcIndex%columns,defaultChar);
 
 	     // invert selected text
          if (sel_begin != -1 && isSelected(column,line + hist->getLines()))
-           reverseRendition(dest[destIndex]); 
+           reverseRendition(dest[destIndex]);
        }
 
     }
 }
 
 void Screen::getImage( Character* dest, int size, int startLine, int endLine ) const
 {
-  Q_ASSERT( startLine >= 0 ); 
+  Q_ASSERT( startLine >= 0 );
   Q_ASSERT( endLine >= startLine && endLine < hist->getLines() + lines );
 
   const int mergedLines = endLine - startLine + 1;
 
-  Q_ASSERT( size >= mergedLines * columns ); 
+  Q_ASSERT( size >= mergedLines * columns );
   Q_UNUSED( size );
 
   const int linesInHistoryBuffer = qBound(0,hist->getLines()-startLine,mergedLines);
   const int linesInScreenBuffer = mergedLines - linesInHistoryBuffer;
 
   // copy lines from history buffer
   if (linesInHistoryBuffer > 0) {
-  	copyFromHistory(dest,startLine,linesInHistoryBuffer); 
+  	copyFromHistory(dest,startLine,linesInHistoryBuffer);
     }
 
   // copy lines from screen buffer
   if (linesInScreenBuffer > 0) {
   	copyFromScreen(dest + linesInHistoryBuffer*columns,
 				   startLine + linesInHistoryBuffer - hist->getLines(),
 				   linesInScreenBuffer);
     }				
- 
+
   // invert display when in screen mode
   if (getMode(MODE_Screen))
-  {  
+  {
     for (int i = 0; i < mergedLines*columns; i++)
       reverseRendition(dest[i]); // for reverse display
   }
 
   // mark the character at the current cursor position
   int cursorIndex = loc(cuX, cuY + linesInHistoryBuffer);
   if(getMode(MODE_Cursor) && cursorIndex < columns*mergedLines)
     dest[cursorIndex].rendition |= RE_CURSOR;
 }
 
 QVector<LineProperty> Screen::getLineProperties( int startLine , int endLine ) const
 {
-  Q_ASSERT( startLine >= 0 ); 
+  Q_ASSERT( startLine >= 0 );
   Q_ASSERT( endLine >= startLine && endLine < hist->getLines() + lines );
 
 	const int mergedLines = endLine-startLine+1;
 	const int linesInHistory = qBound(0,hist->getLines()-startLine,mergedLines);
   const int linesInScreen = mergedLines - linesInHistory;
 
   QVector<LineProperty> result(mergedLines);
   int index = 0;
 
   // copy properties for lines in history
-  for (int line = startLine; line < startLine + linesInHistory; line++) 
+  for (int line = startLine; line < startLine + linesInHistory; line++)
   {
 		//TODO Support for line properties other than wrapped lines
 	  if (hist->isWrappedLine(line))
 	  {
 	  	result[index] = (LineProperty)(result[index] | LINE_WRAPPED);
 	  }
     index++;
   }
-  
+
   // copy properties for lines in screen buffer
   const int firstScreenLine = startLine + linesInHistory - hist->getLines();
   for (int line = firstScreenLine; line < firstScreenLine+linesInScreen; line++)
 	{
     result[index]=lineProperties[line];
   	index++;
 	}
 
@@ -798,20 +798,20 @@ void Screen::ShowCharacter(unsigned shor
   currentChar.backgroundColor = ef_bg;
   currentChar.rendition = ef_re;
 
   int i = 0;
   int newCursorX = cuX + w--;
   while(w)
   {
      i++;
-   
+
      if ( screenLines[cuY].size() < cuX + i + 1 )
          screenLines[cuY].resize(cuX+i+1);
-     
+
      Character& ch = screenLines[cuY][cuX + i];
      ch.character = 0;
      ch.foregroundColor = ef_fg;
      ch.backgroundColor = ef_bg;
      ch.rendition = ef_re;
 
      w--;
   }
@@ -819,17 +819,17 @@ void Screen::ShowCharacter(unsigned shor
 }
 
 void Screen::compose(const QString& /*compose*/)
 {
    Q_ASSERT( 0 /*Not implemented yet*/ );
 
 /*  if (lastPos == -1)
      return;
-     
+
   QChar c(image[lastPos].character);
   compose.prepend(c);
   //compose.compose(); ### FIXME!
   image[lastPos].character = compose[0].unicode();*/
 }
 
 int Screen::scrolledLines() const
 {
@@ -891,17 +891,17 @@ void Screen::scrollDown(int n)
     The `n' new lines are cleared.
     \sa setRegion \sa scrollUp
 */
 
 void Screen::scrollDown(int from, int n)
 {
 
   //kDebug() << "Screen::scrollDown( from: " << from << " , n: " << n << ")";
-  
+
   _scrolledLines += n;
 
 //FIXME: make sure `tmargin', `bmargin', `from', `n' is in bounds.
   if (n <= 0) return;
   if (from > bmargin) return;
   if (from + n > bmargin) n = bmargin - from;
   moveImage(loc(0,from+n),loc(0,from),loc(columns-1,bmargin-n));
   clearImage(loc(0,from),loc(columns-1,from+n-1),' ');
@@ -961,31 +961,31 @@ int Screen::getCursorY() const
 /*! fill screen between (including) `loca' (start) and `loce' (end) with spaces.
 
     This is an internal helper functions. The parameter types are internal
     addresses of within the screen image and make use of the way how the
     screen matrix is mapped to the image vector.
 */
 
 void Screen::clearImage(int loca, int loce, char c)
-{ 
+{
   int scr_TL=loc(0,hist->getLines());
   //FIXME: check positions
 
   //Clear entire selection if it overlaps region to be moved...
   if ( (sel_BR > (loca+scr_TL) )&&(sel_TL < (loce+scr_TL)) )
   {
     clearSelection();
   }
 
   int topLine = loca/columns;
   int bottomLine = loce/columns;
 
   Character clearCh(c,cu_fg,cu_bg,DEFAULT_RENDITION);
-  
+
   //if the character being used to clear the area is the same as the
   //default character, the affected lines can simply be shrunk.
   bool isDefaultCh = (clearCh == Character());
 
   for (int y=topLine;y<=bottomLine;y++)
   {
         lineProperties[y] = 0;
 
@@ -1006,40 +1006,40 @@ void Screen::clearImage(int loca, int lo
             Character* data = line.data();
             for (int i=startCol;i<=endCol;i++)
                 data[i]=clearCh;
         }
   }
 }
 
 /*! move image between (including) `sourceBegin' and `sourceEnd' to 'dest'.
-    
+
     The 'dest', 'sourceBegin' and 'sourceEnd' parameters can be generated using
     the loc(column,line) macro.
 
 NOTE:  moveImage() can only move whole lines.
 
     This is an internal helper functions. The parameter types are internal
     addresses of within the screen image and make use of the way how the
     screen matrix is mapped to the image vector.
 */
 
 void Screen::moveImage(int dest, int sourceBegin, int sourceEnd)
 {
-  //kDebug() << "moving image from (" << (sourceBegin/columns) 
+  //kDebug() << "moving image from (" << (sourceBegin/columns)
   //    << "," << (sourceEnd/columns) << ") to " <<
   //    (dest/columns);
 
   Q_ASSERT( sourceBegin <= sourceEnd );
- 
+
   int lines=(sourceEnd-sourceBegin)/columns;
 
   //move screen image and line properties:
-  //the source and destination areas of the image may overlap, 
-  //so it matters that we do the copy in the right order - 
+  //the source and destination areas of the image may overlap,
+  //so it matters that we do the copy in the right order -
   //forwards if dest < sourceBegin or backwards otherwise.
   //(search the web for 'memmove implementation' for details)
   if (dest < sourceBegin)
   {
     for (int i=0;i<=lines;i++)
     {
         screenLines[ (dest/columns)+i ] = screenLines[ (sourceBegin/columns)+i ];
         lineProperties[(dest/columns)+i]=lineProperties[(sourceBegin/columns)+i];
@@ -1056,17 +1056,17 @@ void Screen::moveImage(int dest, int sou
 
   if (lastPos != -1)
   {
      int diff = dest - sourceBegin; // Scroll by this amount
      lastPos += diff;
      if ((lastPos < 0) || (lastPos >= (lines*columns)))
         lastPos = -1;
   }
-     
+
   // Adjust selection to follow scroll.
   if (sel_begin != -1)
   {
      bool beginIsTL = (sel_begin == sel_TL);
      int diff = dest - sourceBegin; // Scroll by this amount
      int scr_TL=loc(0,hist->getLines());
      int srca = sourceBegin+scr_TL; // Translate index from screen to global
      int srce = sourceEnd+scr_TL; // Translate index from screen to global
@@ -1164,27 +1164,27 @@ void Screen::setDefaultRendition()
   cu_re   = DEFAULT_RENDITION;
   effectiveRendition();
 }
 
 void Screen::setForeColor(int space, int color)
 {
   cu_fg = CharacterColor(space, color);
 
-  if ( cu_fg.isValid() ) 
+  if ( cu_fg.isValid() )
     effectiveRendition();
-  else 
+  else
     setForeColor(COLOR_SPACE_DEFAULT,DEFAULT_FORE_COLOR);
 }
 
 void Screen::setBackColor(int space, int color)
 {
   cu_bg = CharacterColor(space, color);
 
-  if ( cu_bg.isValid() ) 
+  if ( cu_bg.isValid() )
     effectiveRendition();
   else
     setBackColor(COLOR_SPACE_DEFAULT,DEFAULT_BACK_COLOR);
 }
 
 /* ------------------------------------------------------------------------- */
 /*                                                                           */
 /*                            Marking & Selection                            */
@@ -1198,17 +1198,17 @@ void Screen::clearSelection()
   sel_begin = -1;
 }
 
 void Screen::getSelectionStart(int& column , int& line)
 {
     if ( sel_TL != -1 )
     {
         column = sel_TL % columns;
-        line = sel_TL / columns; 
+        line = sel_TL / columns;
     }
     else
     {
         column = cuX + getHistLines();
         line = cuY + getHistLines();
     }
 }
 void Screen::getSelectionEnd(int& column , int& line)
@@ -1217,17 +1217,17 @@ void Screen::getSelectionEnd(int& column
     {
         column = sel_BR % columns;
         line = sel_BR / columns;
     }
     else
     {
         column = cuX + getHistLines();
         line = cuY + getHistLines();
-    } 
+    }
 }
 void Screen::setSelectionStart(/*const ScreenCursor& viewCursor ,*/ const int x, const int y, const bool mode)
 {
 //  kDebug(1211) << "setSelBeginXY(" << x << "," << y << ")";
   sel_begin = loc(x,y); //+histCursor) ;
 
   /* FIXME, HACK to correct for x too far to the right... */
   if (x == columns) sel_begin--;
@@ -1277,31 +1277,31 @@ bool Screen::isSelected( const int x,con
   return ( pos >= sel_TL && pos <= sel_BR );
   }
 }
 
 QString Screen::selectedText(bool preserveLineBreaks)
 {
   QString result;
   QTextStream stream(&result, QIODevice::ReadWrite);
-  
+
   PlainTextDecoder decoder;
   decoder.begin(&stream);
   writeSelectionToStream(&decoder , preserveLineBreaks);
   decoder.end();
-  
+
   return result;
 }
 
 bool Screen::isSelectionValid() const
 {
     return ( sel_TL >= 0 && sel_BR >= 0 );
 }
 
-void Screen::writeSelectionToStream(TerminalCharacterDecoder* decoder , 
+void Screen::writeSelectionToStream(TerminalCharacterDecoder* decoder ,
                                     bool preserveLineBreaks)
 {
     // do nothing if selection is invalid
     if ( !isSelectionValid() )
         return;
 
 	int top = sel_TL / columns;	
 	int left = sel_TL % columns;
@@ -1321,32 +1321,32 @@ void Screen::writeSelectionToStream(Term
 		
 			int count = -1;
 			if ( y == bottom || columnmode ) count = right - start + 1;
 
             const bool appendNewLine = ( y != bottom );
 			copyLineToStream( y,
                               start,
                               count,
-                              decoder, 
+                              decoder,
                               appendNewLine,
                               preserveLineBreaks );
 	}	
 }
 
 
-void Screen::copyLineToStream(int line , 
-                              int start, 
+void Screen::copyLineToStream(int line ,
+                              int start,
                               int count,
                               TerminalCharacterDecoder* decoder,
                               bool appendNewLine,
                               bool preserveLineBreaks)
 {
 		//buffer to hold characters for decoding
-		//the buffer is static to avoid initialising every 
+		//the buffer is static to avoid initialising every
         //element on each call to copyLineToStream
 		//(which is unnecessary since all elements will be overwritten anyway)
 		static const int MAX_CHARS = 1024;
 		static Character characterBuffer[MAX_CHARS];
 		
 		assert( count < MAX_CHARS );
 
         LineProperty currentLineProperties = 0;
@@ -1366,17 +1366,17 @@ void Screen::copyLineToStream(int line ,
             }
 			else
             {
 					count = qMin(start+count,lineLength)-start;
             }
 
             // safety checks
             assert( start >= 0 );
-            assert( count >= 0 );    
+            assert( count >= 0 );
             assert( (start+count) <= hist->getLineLen(line) );
 
 			hist->getCells(line,start,count,characterBuffer);
 
             if ( hist->isWrappedLine(line) )
                 currentLineProperties |= LINE_WRAPPED;
 		}
 		else
@@ -1396,17 +1396,17 @@ void Screen::copyLineToStream(int line ,
 			{
 			    characterBuffer[i-start] = data[i];
             }
 
             // count cannot be any greater than length
 			count = qBound(0,count,length-start);
 
             Q_ASSERT( screenLine < lineProperties.count() );
-            currentLineProperties |= lineProperties[screenLine]; 
+            currentLineProperties |= lineProperties[screenLine];
 		}
 
 		//do not decode trailing whitespace characters
 		for (int i=count-1 ; i >= 0; i--)
 				if (QChar(characterBuffer[i].character).isSpace())
 						count--;
 				else
 						break;
@@ -1417,32 +1417,32 @@ void Screen::copyLineToStream(int line ,
 
         if ( !omitLineBreak && appendNewLine && (count+1 < MAX_CHARS) )
         {
             characterBuffer[count] = '\n';
             count++;
         }
 
 		//decode line and write to text stream	
-		decoder->decodeLine( (Character*) characterBuffer , 
+		decoder->decodeLine( (Character*) characterBuffer ,
                              count, currentLineProperties );
 }
 
 // Method below has been removed because of its reliance on 'histCursor'
 // and I want to restrict the methods which have knowledge of the scroll position
 // to just those which deal with selection and supplying final screen images.
 //
 /*void Screen::writeToStream(QTextStream* stream , TerminalCharacterDecoder* decoder) {
   sel_begin = 0;
   sel_BR = sel_begin;
   sel_TL = sel_begin;
   setSelectionEnd(columns-1,lines-1+hist->getLines()-histCursor);
-  
+
   writeSelectionToStream(stream,decoder);
-  
+
   clearSelection();
 }*/
 
 void Screen::writeToStream(TerminalCharacterDecoder* decoder, int from, int to)
 {
 	sel_begin = loc(0,from);
 	sel_TL = sel_begin;
 	sel_BR = loc(columns-1,to);
diff --git a/libgui/qterminal/libqterminal/unix/Screen.h b/libgui/qterminal/libqterminal/unix/Screen.h
--- a/libgui/qterminal/libqterminal/unix/Screen.h
+++ b/libgui/qterminal/libqterminal/unix/Screen.h
@@ -51,42 +51,42 @@ class TerminalCharacterDecoder;
 
 /**
     \brief An image of characters with associated attributes.
 
     The terminal emulation ( Emulation ) receives a serial stream of
     characters from the program currently running in the terminal.
     From this stream it creates an image of characters which is ultimately
     rendered by the display widget ( TerminalDisplay ).  Some types of emulation
-    may have more than one screen image. 
+    may have more than one screen image.
 
     getImage() is used to retrieve the currently visible image
     which is then used by the display widget to draw the output from the
-    terminal. 
+    terminal.
 
     The number of lines of output history which are kept in addition to the current
-    screen image depends on the history scroll being used to store the output.  
+    screen image depends on the history scroll being used to store the output.
     The scroll is specified using setScroll()
     The output history can be retrieved using writeToStream()
 
-    The screen image has a selection associated with it, specified using 
+    The screen image has a selection associated with it, specified using
     setSelectionStart() and setSelectionEnd().  The selected text can be retrieved
     using selectedText().  When getImage() is used to retrieve the the visible image,
-    characters which are part of the selection have their colours inverted.   
+    characters which are part of the selection have their colours inverted.
 */
 class Screen
 {
 public:
     /** Construct a new screen image of size @p lines by @p columns. */
     Screen(int lines, int columns);
     ~Screen();
 
-    // VT100/2 Operations 
+    // VT100/2 Operations
     // Cursor Movement
-    
+
     /** Move the cursor up by @p n lines. */
     void cursorUp    (int n);
     /** Move the cursor down by @p n lines. */
     void cursorDown  (int n);
     /** Move the cursor to the left by @p n columns. */
     void cursorLeft  (int n);
     /** Move the cursor to the right by @p n columns. */
     void cursorRight (int n);
@@ -94,188 +94,188 @@ public:
     void setCursorY  (int y);
     /** Position the cursor at column @p x. */
     void setCursorX  (int x);
     /** Position the cursor at line @p y, column @p x. */
     void setCursorYX (int y, int x);
     /**
      * Sets the margins for scrolling the screen.
      *
-     * @param topLine The top line of the new scrolling margin. 
-     * @param bottomLine The bottom line of the new scrolling margin. 
+     * @param topLine The top line of the new scrolling margin.
+     * @param bottomLine The bottom line of the new scrolling margin.
      */
     void setMargins  (int topLine , int bottomLine);
-    /** Returns the top line of the scrolling region. */ 
+    /** Returns the top line of the scrolling region. */
     int topMargin() const;
     /** Returns the bottom line of the scrolling region. */
     int bottomMargin() const;
 
-    /** 
+    /**
      * Resets the scrolling margins back to the top and bottom lines
      * of the screen.
      */
     void setDefaultMargins();
-    
-    /** 
-     * Moves the cursor down one line, if the MODE_NewLine mode 
+
+    /**
+     * Moves the cursor down one line, if the MODE_NewLine mode
      * flag is enabled then the cursor is returned to the leftmost
      * column first.
      *
      * Equivalent to NextLine() if the MODE_NewLine flag is set
-     * or index() otherwise. 
+     * or index() otherwise.
      */
     void NewLine     ();
     /**
      * Moves the cursor down one line and positions it at the beginning
      * of the line.
      */
     void NextLine    ();
 
-    /** 
+    /**
      * Move the cursor down one line.  If the cursor is on the bottom
      * line of the scrolling region (as returned by bottomMargin()) the
      * scrolling region is scrolled up by one line instead.
      */
     void index       ();
     /**
      * Move the cursor up one line.  If the cursor is on the top line
      * of the scrolling region (as returned by topMargin()) the scrolling
      * region is scrolled down by one line instead.
      */
     void reverseIndex();
-    
-    /** 
-     * Scroll the scrolling region of the screen up by @p n lines. 
-     * The scrolling region is initially the whole screen, but can be changed 
+
+    /**
+     * Scroll the scrolling region of the screen up by @p n lines.
+     * The scrolling region is initially the whole screen, but can be changed
      * using setMargins()
-     */ 
+     */
     void scrollUp(int n);
     /**
      * Scroll the scrolling region of the screen down by @p n lines.
      * The scrolling region is initially the whole screen, but can be changed
      * using setMargins()
      */
     void scrollDown(int n);
-    
-    /** 
-     * Moves the cursor to the beginning of the current line. 
+
+    /**
+     * Moves the cursor to the beginning of the current line.
      * Equivalent to setCursorX(0)
      */
     void Return      ();
-    /** 
+    /**
      * Moves the cursor one column to the left and erases the character
      * at the new cursor position.
      */
     void BackSpace   ();
-    /** 
+    /**
      * Moves the cursor @p n tab-stops to the right.
      */
     void Tabulate    (int n = 1);
-    /** 
-     * Moves the cursor @p n tab-stops to the left. 
+    /**
+     * Moves the cursor @p n tab-stops to the left.
      */
     void backTabulate(int n);
-    
+
     // Editing
-    
-    /** 
-     * Erase @p n characters beginning from the current cursor position. 
+
+    /**
+     * Erase @p n characters beginning from the current cursor position.
      * This is equivalent to over-writing @p n characters starting with the current
      * cursor position with spaces.
-     * If @p n is 0 then one character is erased. 
+     * If @p n is 0 then one character is erased.
      */
     void eraseChars  (int n);
-    /** 
-     * Delete @p n characters beginning from the current cursor position. 
-     * If @p n is 0 then one character is deleted. 
+    /**
+     * Delete @p n characters beginning from the current cursor position.
+     * If @p n is 0 then one character is deleted.
      */
     void deleteChars (int n);
     /**
      * Insert @p n blank characters beginning from the current cursor position.
-     * The position of the cursor is not altered.  
+     * The position of the cursor is not altered.
      * If @p n is 0 then one character is inserted.
      */
     void insertChars (int n);
-    /** 
+    /**
      * Removes @p n lines beginning from the current cursor position.
      * The position of the cursor is not altered.
      * If @p n is 0 then one line is removed.
      */
     void deleteLines (int n);
     /**
      * Inserts @p lines beginning from the current cursor position.
      * The position of the cursor is not altered.
      * If @p n is 0 then one line is inserted.
      */
     void insertLines (int n);
     /** Clears all the tab stops. */
     void clearTabStops();
-    /**  Sets or removes a tab stop at the cursor's current column. */ 
+    /**  Sets or removes a tab stop at the cursor's current column. */
     void changeTabStop(bool set);
-   
+
     /** Resets (clears) the specified screen @p mode. */
     void resetMode   (int mode);
     /** Sets (enables) the specified screen @p mode. */
     void setMode     (int mode);
-    /** 
+    /**
      * Saves the state of the specified screen @p mode.  It can be restored
      * using restoreMode()
      */
     void saveMode    (int mode);
     /** Restores the state of a screen @p mode saved by calling saveMode() */
     void restoreMode (int mode);
     /** Returns whether the specified screen @p mode is enabled or not .*/
     bool getMode     (int mode) const;
-   
-    /** 
-     * Saves the current position and appearence (text color and style) of the cursor. 
-     * It can be restored by calling restoreCursor() 
-     */ 
+
+    /**
+     * Saves the current position and appearence (text color and style) of the cursor.
+     * It can be restored by calling restoreCursor()
+     */
     void saveCursor  ();
     /** Restores the position and appearence of the cursor.  See saveCursor() */
     void restoreCursor();
-   
-    /** Clear the whole screen, moving the current screen contents into the history first. */ 
+
+    /** Clear the whole screen, moving the current screen contents into the history first. */
     void clearEntireScreen();
-    /** 
-     * Clear the area of the screen from the current cursor position to the end of 
+    /**
+     * Clear the area of the screen from the current cursor position to the end of
      * the screen.
      */
     void clearToEndOfScreen();
     /**
      * Clear the area of the screen from the current cursor position to the start
      * of the screen.
      */
     void clearToBeginOfScreen();
     /** Clears the whole of the line on which the cursor is currently positioned. */
     void clearEntireLine();
     /** Clears from the current cursor position to the end of the line. */
     void clearToEndOfLine();
     /** Clears from the current cursor position to the beginning of the line. */
     void clearToBeginOfLine();
-    
+
     /** Fills the entire screen with the letter 'E' */
     void helpAlign   ();
-       
-    /** 
-     * Enables the given @p rendition flag.  Rendition flags control the appearence 
+
+    /**
+     * Enables the given @p rendition flag.  Rendition flags control the appearence
      * of characters on the screen.
      *
      * @see Character::rendition
-     */  
+     */
     void setRendition  (int rendition);
     /**
      * Disables the given @p rendition flag.  Rendition flags control the appearence
      * of characters on the screen.
      *
      * @see Character::rendition
      */
     void resetRendition(int rendition);
-    
-    /** 
+
+    /**
      * Sets the cursor's foreground color.
      * @param space The color space used by the @p color argument
      * @param color The new foreground color.  The meaning of this depends on
      * the color @p space used.
      *
      * @see CharacterColor
      */
     void setForeColor  (int space, int color);
@@ -283,289 +283,289 @@ public:
      * Sets the cursor's background color.
      * @param space The color space used by the @p color argumnet.
      * @param color The new background color.  The meaning of this depends on
      * the color @p space used.
      *
      * @see CharacterColor
      */
     void setBackColor  (int space, int color);
-    /** 
-     * Resets the cursor's color back to the default and sets the 
+    /**
+     * Resets the cursor's color back to the default and sets the
      * character's rendition flags back to the default settings.
      */
     void setDefaultRendition();
-    
+
     /** Returns the column which the cursor is positioned at. */
     int  getCursorX() const;
     /** Returns the line which the cursor is positioned on. */
     int  getCursorY() const;
-   
-	/** TODO Document me */ 
+
+	/** TODO Document me */
 	void clear();
-    /** 
+    /**
      * Sets the position of the cursor to the 'home' position at the top-left
-     * corner of the screen (0,0) 
+     * corner of the screen (0,0)
      */
     void home();
     /**
      * Resets the state of the screen.  This resets the various screen modes
      * back to their default states.  The cursor style and colors are reset
      * (as if setDefaultRendition() had been called)
      *
      * <ul>
      * <li>Line wrapping is enabled.</li>
      * <li>Origin mode is disabled.</li>
      * <li>Insert mode is disabled.</li>
      * <li>Cursor mode is enabled.  TODO Document me</li>
      * <li>Screen mode is disabled. TODO Document me</li>
      * <li>New line mode is disabled.  TODO Document me</li>
      * </ul>
      *
-     * If @p clearScreen is true then the screen contents are erased entirely, 
+     * If @p clearScreen is true then the screen contents are erased entirely,
      * otherwise they are unaltered.
      */
     void reset(bool clearScreen = true);
-   
-    /** 
-     * Displays a new character at the current cursor position. 
-     * 
+
+    /**
+     * Displays a new character at the current cursor position.
+     *
      * If the cursor is currently positioned at the right-edge of the screen and
-     * line wrapping is enabled then the character is added at the start of a new 
+     * line wrapping is enabled then the character is added at the start of a new
      * line below the current one.
      *
-     * If the MODE_Insert screen mode is currently enabled then the character 
-     * is inserted at the current cursor position, otherwise it will replace the 
-     * character already at the current cursor position.  
-     */ 
+     * If the MODE_Insert screen mode is currently enabled then the character
+     * is inserted at the current cursor position, otherwise it will replace the
+     * character already at the current cursor position.
+     */
     void ShowCharacter(unsigned short c);
-    
+
     // Do composition with last shown character FIXME: Not implemented yet for KDE 4
     void compose(const QString& compose);
-    
-    /** 
-     * Resizes the image to a new fixed size of @p new_lines by @p new_columns.  
+
+    /**
+     * Resizes the image to a new fixed size of @p new_lines by @p new_columns.
      * In the case that @p new_columns is smaller than the current number of columns,
      * existing lines are not truncated.  This prevents characters from being lost
      * if the terminal display is resized smaller and then larger again.
      *
      * (note that in versions of Konsole prior to KDE 4, existing lines were
      *  truncated when making the screen image smaller)
      */
     void resizeImage(int new_lines, int new_columns);
-    
+
     /**
-     * Returns the current screen image.  
+     * Returns the current screen image.
      * The result is an array of Characters of size [getLines()][getColumns()] which
      * must be freed by the caller after use.
      *
      * @param dest Buffer to copy the characters into
      * @param size Size of @p dest in Characters
      * @param startLine Index of first line to copy
      * @param endLine Index of last line to copy
      */
     void getImage( Character* dest , int size , int startLine , int endLine ) const;
 
-    /** 
+    /**
      * Returns the additional attributes associated with lines in the image.
-     * The most important attribute is LINE_WRAPPED which specifies that the 
+     * The most important attribute is LINE_WRAPPED which specifies that the
      * line is wrapped,
      * other attributes control the size of characters in the line.
      */
     QVector<LineProperty> getLineProperties( int startLine , int endLine ) const;
 	
 
     /** Return the number of lines. */
     int  getLines()   { return lines; }
     /** Return the number of columns. */
     int  getColumns() { return columns; }
     /** Return the number of lines in the history buffer. */
     int  getHistLines ();
-    /** 
-     * Sets the type of storage used to keep lines in the history. 
-     * If @p copyPreviousScroll is true then the contents of the previous 
+    /**
+     * Sets the type of storage used to keep lines in the history.
+     * If @p copyPreviousScroll is true then the contents of the previous
      * history buffer are copied into the new scroll.
      */
     void setScroll(const HistoryType& , bool copyPreviousScroll = true);
     /** Returns the type of storage used to keep lines in the history. */
     const HistoryType& getScroll();
-    /** 
+    /**
      * Returns true if this screen keeps lines that are scrolled off the screen
      * in a history buffer.
      */
     bool hasScroll();
 
-    /** 
+    /**
      * Sets the start of the selection.
      *
      * @param column The column index of the first character in the selection.
      * @param line The line index of the first character in the selection.
      * @param columnmode True if the selection is in column mode.
      */
     void setSelectionStart(const int column, const int line, const bool columnmode);
-    
+
     /**
      * Sets the end of the current selection.
      *
      * @param column The column index of the last character in the selection.
-     * @param line The line index of the last character in the selection. 
-     */ 
+     * @param line The line index of the last character in the selection.
+     */
     void setSelectionEnd(const int column, const int line);
-   
+
     /**
      * Retrieves the start of the selection or the cursor position if there
      * is no selection.
      */
     void getSelectionStart(int& column , int& line);
-    
+
     /**
      * Retrieves the end of the selection or the cursor position if there
      * is no selection.
      */
     void getSelectionEnd(int& column , int& line);
 
     /** Clears the current selection */
     void clearSelection();
 
     void setBusySelecting(bool busy) { sel_busy = busy; }
 
-    /** 
+    /**
  	 * 	Returns true if the character at (@p column, @p line) is part of the
- 	 *  current selection. 
- 	 */ 
+ 	 *  current selection.
+ 	 */
     bool isSelected(const int column,const int line) const;
 
-    /** 
-     * Convenience method.  Returns the currently selected text. 
-     * @param preserveLineBreaks Specifies whether new line characters should 
+    /**
+     * Convenience method.  Returns the currently selected text.
+     * @param preserveLineBreaks Specifies whether new line characters should
      * be inserted into the returned text at the end of each terminal line.
      */
     QString selectedText(bool preserveLineBreaks);
-	    
+	
 	/**
 	 * Copies part of the output to a stream.
 	 *
 	 * @param decoder A decoder which coverts terminal characters into text
 	 * @param from The first line in the history to retrieve
 	 * @param to The last line in the history to retrieve
 	 */
 	void writeToStream(TerminalCharacterDecoder* decoder, int from, int to);
 
-    /** 
+    /**
      * Sets the selection to line @p no in the history and returns
      * the text of that line from the history buffer.
      */
     QString getHistoryLine(int no);
 
 	/**
 	 * Copies the selected characters, set using @see setSelBeginXY and @see setSelExtentXY
 	 * into a stream.
 	 *
-	 * @param decoder A decoder which converts terminal characters into text.  
-	 * PlainTextDecoder is the most commonly used decoder which coverts characters 
+	 * @param decoder A decoder which converts terminal characters into text.
+	 * PlainTextDecoder is the most commonly used decoder which coverts characters
 	 * into plain text with no formatting.
-     * @param preserveLineBreaks Specifies whether new line characters should 
-     * be inserted into the returned text at the end of each terminal line. 
+     * @param preserveLineBreaks Specifies whether new line characters should
+     * be inserted into the returned text at the end of each terminal line.
 	 */
 	void writeSelectionToStream(TerminalCharacterDecoder* decoder , bool
                                 preserveLineBreaks = true);
 
     /** TODO Document me */
     void checkSelection(int from, int to);
 
-	/** 
+	/**
 	 * Sets or clears an attribute of the current line.
-	 * 
+	 *
 	 * @param property The attribute to set or clear
 	 * Possible properties are:
 	 * LINE_WRAPPED:	 Specifies that the line is wrapped.
 	 * LINE_DOUBLEWIDTH: Specifies that the characters in the current line should be double the normal width.
 	 * LINE_DOUBLEHEIGHT:Specifies that the characters in the current line should be double the normal height.
      *                   Double-height lines are formed of two lines containing the same characters,
-     *                   with both having the LINE_DOUBLEHEIGHT attribute.  This allows other parts of the 
+     *                   with both having the LINE_DOUBLEHEIGHT attribute.  This allows other parts of the
      *                   code to work on the assumption that all lines are the same height.
 	 *
 	 * @param enable true to apply the attribute to the current line or false to remove it
 	 */
 	void setLineProperty(LineProperty property , bool enable);
 
 
-    /** 
+    /**
      * Returns the number of lines that the image has been scrolled up or down by,
      * since the last call to resetScrolledLines().
      *
      * a positive return value indicates that the image has been scrolled up,
-     * a negative return value indicates that the image has been scrolled down. 
+     * a negative return value indicates that the image has been scrolled down.
      */
     int scrolledLines() const;
 
     /**
      * Returns the region of the image which was last scrolled.
      *
-     * This is the area of the image from the top margin to the 
+     * This is the area of the image from the top margin to the
      * bottom margin when the last scroll occurred.
      */
     QRect lastScrolledRegion() const;
 
-    /** 
+    /**
      * Resets the count of the number of lines that the image has been scrolled up or down by,
      * see scrolledLines()
      */
     void resetScrolledLines();
 
     /**
      * Returns the number of lines of output which have been
      * dropped from the history since the last call
      * to resetDroppedLines()
      *
      * If the history is not unlimited then it will drop
      * the oldest lines of output if new lines are added when
-     * it is full.  
+     * it is full.
      */
     int droppedLines() const;
 
     /**
      * Resets the count of the number of lines dropped from
      * the history.
      */
     void resetDroppedLines();
 
-	/** 
+	/**
  	 * Fills the buffer @p dest with @p count instances of the default (ie. blank)
  	 * Character style.
  	 */
 	static void fillWithDefaultChar(Character* dest, int count);
 
-private: 
+private:
 
-	//copies a line of text from the screen or history into a stream using a 
+	//copies a line of text from the screen or history into a stream using a
 	//specified character decoder
-	//line - the line number to copy, from 0 (the earliest line in the history) up to 
+	//line - the line number to copy, from 0 (the earliest line in the history) up to
 	//		 hist->getLines() + lines - 1
 	//start - the first column on the line to copy
 	//count - the number of characters on the line to copy
 	//decoder - a decoder which coverts terminal characters (an Character array) into text
     //appendNewLine - if true a new line character (\n) is appended to the end of the line
-	void copyLineToStream(int line, 
-                          int start, 
-                          int count, 
+	void copyLineToStream(int line,
+                          int start,
+                          int count,
                           TerminalCharacterDecoder* decoder,
                           bool appendNewLine,
                           bool preserveLineBreaks);
 	
     //fills a section of the screen image with the character 'c'
     //the parameters are specified as offsets from the start of the screen image.
     //the loc(x,y) macro can be used to generate these values from a column,line pair.
     void clearImage(int loca, int loce, char c);
 
     //move screen image between 'sourceBegin' and 'sourceEnd' to 'dest'.
     //the parameters are specified as offsets from the start of the screen image.
     //the loc(x,y) macro can be used to generate these values from a column,line pair.
     void moveImage(int dest, int sourceBegin, int sourceEnd);
-    
+
     void scrollUp(int from, int i);
     void scrollDown(int from, int i);
 
     void addHistLine();
 
     void initTabStops();
 
     void effectiveRendition();
@@ -588,21 +588,21 @@ private:
     typedef QVector<Character> ImageLine;      // [0..columns]
     ImageLine*          screenLines;    // [lines]
 
     int _scrolledLines;
     QRect _lastScrolledRegion;
 
     int _droppedLines;
 
-    QVarLengthArray<LineProperty,64> lineProperties;    
+    QVarLengthArray<LineProperty,64> lineProperties;
 	
     // history buffer ---------------
     HistoryScroll *hist;
-    
+
     // cursor location
     int cuX;
     int cuY;
 
     // cursor color and rendition info
     CharacterColor cu_fg;      // foreground
     CharacterColor cu_bg;      // background
     quint8 cu_re;      // rendition
@@ -627,27 +627,27 @@ private:
 
     // effective colors and rendition ------------
     CharacterColor ef_fg;      // These are derived from
     CharacterColor ef_bg;      // the cu_* variables above
     quint8 ef_re;      // to speed up operation
 
     //
     // save cursor, rendition & states ------------
-    // 
+    //
 
     // cursor location
     int sa_cuX;
     int sa_cuY;
 
     // rendition info
     quint8 sa_cu_re;
     CharacterColor sa_cu_fg;
     CharacterColor sa_cu_bg;
-    
+
     // last position where we added a character
     int lastPos;
 
     // modes
     ScreenParm saveParm;
 
     static Character defaultChar;
 };
diff --git a/libgui/qterminal/libqterminal/unix/ScreenWindow.cpp b/libgui/qterminal/libqterminal/unix/ScreenWindow.cpp
--- a/libgui/qterminal/libqterminal/unix/ScreenWindow.cpp
+++ b/libgui/qterminal/libqterminal/unix/ScreenWindow.cpp
@@ -55,51 +55,51 @@ Screen* ScreenWindow::screen() const
 {
     return _screen;
 }
 
 Character* ScreenWindow::getImage()
 {
 	// reallocate internal buffer if the window size has changed
 	int size = windowLines() * windowColumns();
-	if (_windowBuffer == 0 || _windowBufferSize != size) 
+	if (_windowBuffer == 0 || _windowBufferSize != size)
 	{
 		delete[] _windowBuffer;
 		_windowBufferSize = size;
 		_windowBuffer = new Character[size];
 		_bufferNeedsUpdate = true;
 	}
 
 	 if (!_bufferNeedsUpdate)
 		return _windowBuffer;
- 
+
 	_screen->getImage(_windowBuffer,size,
 					  currentLine(),endWindowLine());
 
-	// this window may look beyond the end of the screen, in which 
+	// this window may look beyond the end of the screen, in which
 	// case there will be an unused area which needs to be filled
 	// with blank characters
 	fillUnusedArea();
 
 	_bufferNeedsUpdate = false;
 	return _windowBuffer;
 }
 
 void ScreenWindow::fillUnusedArea()
 {
 	int screenEndLine = _screen->getHistLines() + _screen->getLines() - 1;
 	int windowEndLine = currentLine() + windowLines() - 1;
 
 	int unusedLines = windowEndLine - screenEndLine;
 	int charsToFill = unusedLines * windowColumns();
 
-	Screen::fillWithDefaultChar(_windowBuffer + _windowBufferSize - charsToFill,charsToFill); 
+	Screen::fillWithDefaultChar(_windowBuffer + _windowBufferSize - charsToFill,charsToFill);
 }
 
-// return the index of the line at the end of this window, or if this window 
+// return the index of the line at the end of this window, or if this window
 // goes beyond the end of the screen, the index of the line at the end
 // of the screen.
 //
 // when passing a line number to a Screen method, the line number should
 // never be more than endWindowLine()
 //
 int ScreenWindow::endWindowLine() const
 {
@@ -182,37 +182,37 @@ int ScreenWindow::lineCount() const
 int ScreenWindow::columnCount() const
 {
     return _screen->getColumns();
 }
 
 QPoint ScreenWindow::cursorPosition() const
 {
     QPoint position;
-    
+
     position.setX( _screen->getCursorX() );
     position.setY( _screen->getCursorY() );
 
-    return position; 
+    return position;
 }
 
 int ScreenWindow::currentLine() const
 {
     return qBound(0,_currentLine,lineCount()-windowLines());
 }
 
 void ScreenWindow::scrollBy( RelativeScrollMode mode , int amount )
 {
     if ( mode == ScrollLines )
     {
         scrollTo( currentLine() + amount );
     }
     else if ( mode == ScrollPages )
     {
-        scrollTo( currentLine() + amount * ( windowLines() / 2 ) ); 
+        scrollTo( currentLine() + amount * ( windowLines() / 2 ) );
     }
 }
 
 bool ScreenWindow::atEndOfOutput() const
 {
     return currentLine() == (lineCount()-windowLines());
 }
 
@@ -243,17 +243,17 @@ bool ScreenWindow::trackOutput() const
     return _trackOutput;
 }
 
 int ScreenWindow::scrollCount() const
 {
     return _scrollCount;
 }
 
-void ScreenWindow::resetScrollCount() 
+void ScreenWindow::resetScrollCount()
 {
     _scrollCount = 0;
 }
 
 QRect ScreenWindow::scrollRegion() const
 {
 	bool equalToScreenSize = windowLines() == _screen->getLines();
 
@@ -263,32 +263,32 @@ QRect ScreenWindow::scrollRegion() const
 		return QRect(0,0,windowColumns(),windowLines());
 }
 
 void ScreenWindow::notifyOutputChanged()
 {
     // move window to the bottom of the screen and update scroll count
     // if this window is currently tracking the bottom of the screen
     if ( _trackOutput )
-    { 
+    {
         _scrollCount -= _screen->scrolledLines();
         _currentLine = qMax(0,_screen->getHistLines() - (windowLines()-_screen->getLines()));
     }
     else
     {
-        // if the history is not unlimited then it may 
+        // if the history is not unlimited then it may
         // have run out of space and dropped the oldest
         // lines of output - in this case the screen
-        // window's current line number will need to 
+        // window's current line number will need to
         // be adjusted - otherwise the output will scroll
-        _currentLine = qMax(0,_currentLine - 
+        _currentLine = qMax(0,_currentLine -
                               _screen->droppedLines());
 
         // ensure that the screen window's current position does
         // not go beyond the bottom of the screen
         _currentLine = qMin( _currentLine , _screen->getHistLines() );
     }
 
 	_bufferNeedsUpdate = true;
 
-    emit outputChanged(); 
+    emit outputChanged();
 }
 
diff --git a/libgui/qterminal/libqterminal/unix/ScreenWindow.h b/libgui/qterminal/libqterminal/unix/ScreenWindow.h
--- a/libgui/qterminal/libqterminal/unix/ScreenWindow.h
+++ b/libgui/qterminal/libqterminal/unix/ScreenWindow.h
@@ -31,204 +31,204 @@
 #include "unix/Character.h"
 
 class Screen;
 
 /**
  * Provides a window onto a section of a terminal screen.
  * This window can then be rendered by a terminal display widget ( TerminalDisplay ).
  *
- * To use the screen window, create a new ScreenWindow() instance and associated it with 
+ * To use the screen window, create a new ScreenWindow() instance and associated it with
  * a terminal screen using setScreen().
  * Use the scrollTo() method to scroll the window up and down on the screen.
  * Call the getImage() method to retrieve the character image which is currently visible in the window.
  *
  * setTrackOutput() controls whether the window moves to the bottom of the associated screen when new
  * lines are added to it.
  *
  * Whenever the output from the underlying screen is changed, the notifyOutputChanged() slot should
  * be called.  This in turn will update the window's position and emit the outputChanged() signal
  * if necessary.
  */
 class ScreenWindow : public QObject
 {
 Q_OBJECT
 
 public:
-    /** 
+    /**
      * Constructs a new screen window with the given parent.
      * A screen must be specified by calling setScreen() before calling getImage() or getLineProperties().
      *
      * You should not call this constructor directly, instead use the Emulation::createWindow() method
      * to create a window on the emulation which you wish to view.  This allows the emulation
      * to notify the window when the associated screen has changed and synchronize selection updates
      * between all views on a session.
      */
     ScreenWindow(QObject* parent = 0);
 	virtual ~ScreenWindow();
 
     /** Sets the screen which this window looks onto */
     void setScreen(Screen* screen);
     /** Returns the screen which this window looks onto */
     Screen* screen() const;
 
-    /** 
+    /**
      * Returns the image of characters which are currently visible through this window
      * onto the screen.
      *
      * The buffer is managed by the ScreenWindow instance and does not need to be
      * deleted by the caller.
      */
     Character* getImage();
 
     /**
      * Returns the line attributes associated with the lines of characters which
      * are currently visible through this window
      */
     QVector<LineProperty> getLineProperties();
 
     /**
      * Returns the number of lines which the region of the window
-     * specified by scrollRegion() has been scrolled by since the last call 
-     * to resetScrollCount().  scrollRegion() is in most cases the 
+     * specified by scrollRegion() has been scrolled by since the last call
+     * to resetScrollCount().  scrollRegion() is in most cases the
      * whole window, but will be a smaller area in, for example, applications
      * which provide split-screen facilities.
      *
      * This is not guaranteed to be accurate, but allows views to optimise
      * rendering by reducing the amount of costly text rendering that
-     * needs to be done when the output is scrolled. 
+     * needs to be done when the output is scrolled.
      */
     int scrollCount() const;
 
     /**
      * Resets the count of scrolled lines returned by scrollCount()
      */
     void resetScrollCount();
 
     /**
-     * Returns the area of the window which was last scrolled, this is 
+     * Returns the area of the window which was last scrolled, this is
      * usually the whole window area.
      *
      * Like scrollCount(), this is not guaranteed to be accurate,
      * but allows views to optimise rendering.
      */
     QRect scrollRegion() const;
 
-    /** 
-     * Sets the start of the selection to the given @p line and @p column within 
+    /**
+     * Sets the start of the selection to the given @p line and @p column within
      * the window.
      */
     void setSelectionStart( int column , int line , bool columnMode );
     /**
      * Sets the end of the selection to the given @p line and @p column within
      * the window.
      */
-    void setSelectionEnd( int column , int line ); 
+    void setSelectionEnd( int column , int line );
     /**
      * Retrieves the start of the selection within the window.
      */
     void getSelectionStart( int& column , int& line );
     /**
      * Retrieves the end of the selection within the window.
      */
     void getSelectionEnd( int& column , int& line );
     /**
      * Returns true if the character at @p line , @p column is part of the selection.
      */
     bool isSelected( int column , int line );
-    /** 
+    /**
      * Clears the current selection
      */
     void clearSelection();
 
 	/** Sets the number of lines in the window */
 	void setWindowLines(int lines);
     /** Returns the number of lines in the window */
     int windowLines() const;
     /** Returns the number of columns in the window */
     int windowColumns() const;
-    
+
     /** Returns the total number of lines in the screen */
     int lineCount() const;
     /** Returns the total number of columns in the screen */
     int columnCount() const;
 
     /** Returns the index of the line which is currently at the top of this window */
     int currentLine() const;
 
-    /** 
-     * Returns the position of the cursor 
+    /**
+     * Returns the position of the cursor
      * within the window.
      */
     QPoint cursorPosition() const;
 
-    /** 
+    /**
      * Convenience method. Returns true if the window is currently at the bottom
      * of the screen.
      */
     bool atEndOfOutput() const;
 
     /** Scrolls the window so that @p line is at the top of the window */
     void scrollTo( int line );
 
     enum RelativeScrollMode
     {
         ScrollLines,
         ScrollPages
     };
 
-    /** 
+    /**
      * Scrolls the window relative to its current position on the screen.
      *
      * @param mode Specifies whether @p amount refers to the number of lines or the number
-     * of pages to scroll.    
+     * of pages to scroll.
      * @param amount The number of lines or pages ( depending on @p mode ) to scroll by.  If
      * this number is positive, the view is scrolled down.  If this number is negative, the view
      * is scrolled up.
      */
     void scrollBy( RelativeScrollMode mode , int amount );
 
-    /** 
+    /**
      * Specifies whether the window should automatically move to the bottom
      * of the screen when new output is added.
      *
-     * If this is set to true, the window will be moved to the bottom of the associated screen ( see 
+     * If this is set to true, the window will be moved to the bottom of the associated screen ( see
      * screen() ) when the notifyOutputChanged() method is called.
      */
     void setTrackOutput(bool trackOutput);
-    /** 
+    /**
      * Returns whether the window automatically moves to the bottom of the screen as
      * new output is added.  See setTrackOutput()
      */
     bool trackOutput() const;
 
     /**
      * Returns the text which is currently selected.
      *
      * @param preserveLineBreaks See Screen::selectedText()
      */
     QString selectedText( bool preserveLineBreaks ) const;
 
 public slots:
-    /** 
+    /**
      * Notifies the window that the contents of the associated terminal screen have changed.
      * This moves the window to the bottom of the screen if trackOutput() is true and causes
      * the outputChanged() signal to be emitted.
      */
     void notifyOutputChanged();
 
 signals:
     /**
-     * Emitted when the contents of the associated terminal screen ( see screen() ) changes. 
+     * Emitted when the contents of the associated terminal screen ( see screen() ) changes.
      */
     void outputChanged();
 
     /**
      * Emitted when the screen window is scrolled to a different position.
-     * 
+     *
      * @param line The line which is now at the top of the window.
      */
     void scrolled(int line);
 
     /**
      * Emitted when the selection is changed.
      */
     void selectionChanged();
@@ -239,14 +239,14 @@ private:
 
     Screen* _screen; // see setScreen() , screen()
 	Character* _windowBuffer;
 	int _windowBufferSize;
 	bool _bufferNeedsUpdate;
 
 	int  _windowLines;
     int  _currentLine; // see scrollTo() , currentLine()
-    bool _trackOutput; // see setTrackOutput() , trackOutput() 
+    bool _trackOutput; // see setTrackOutput() , trackOutput()
     int  _scrollCount; // count of lines which the window has been scrolled by since
                        // the last call to resetScrollCount()
 };
 
 #endif // SCREENWINDOW_H
diff --git a/libgui/qterminal/libqterminal/unix/TerminalCharacterDecoder.cpp b/libgui/qterminal/libqterminal/unix/TerminalCharacterDecoder.cpp
--- a/libgui/qterminal/libqterminal/unix/TerminalCharacterDecoder.cpp
+++ b/libgui/qterminal/libqterminal/unix/TerminalCharacterDecoder.cpp
@@ -1,13 +1,13 @@
 /*
     This file is part of Konsole, an X terminal.
-    
+
     Copyright (C) 2006, 2013 by Robert Knight <robertknight@gmail.com>
-    
+
     Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU Lesser General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
@@ -38,17 +38,17 @@ void PlainTextDecoder::setTrailingWhites
     _includeTrailingWhitespace = enable;
 }
 bool PlainTextDecoder::trailingWhitespace() const
 {
     return _includeTrailingWhitespace;
 }
 void PlainTextDecoder::begin(QTextStream* output)
 {
-   _output = output; 
+   _output = output;
 }
 void PlainTextDecoder::end()
 {
     _output = 0;
 }
 void PlainTextDecoder::decodeLine(const Character* const characters, int count, LineProperty /*properties*/
 							 )
 {
@@ -56,17 +56,17 @@ void PlainTextDecoder::decodeLine(const 
 
 	//TODO should we ignore or respect the LINE_WRAPPED line property?
 
 	//note:  we build up a QString and send it to the text stream rather writing into the text
 	//stream a character at a time because it is more efficient.
 	//(since QTextStream always deals with QStrings internally anyway)
 	QString plainText;
 	plainText.reserve(count);
-   
+
     int outputCount = count;
 
     // if inclusion of trailing whitespace is disabled then find the end of the
     // line
     if ( !_includeTrailingWhitespace )
     {
         for (int i = count-1 ; i >= 0 ; i--)
         {
diff --git a/libgui/qterminal/libqterminal/unix/TerminalCharacterDecoder.h b/libgui/qterminal/libqterminal/unix/TerminalCharacterDecoder.h
--- a/libgui/qterminal/libqterminal/unix/TerminalCharacterDecoder.h
+++ b/libgui/qterminal/libqterminal/unix/TerminalCharacterDecoder.h
@@ -1,13 +1,13 @@
 /*
     This file is part of Konsole, an X terminal.
-    
+
     Copyright (C) 2006-2007, 2013 by Robert Knight <robertknight@gmail.com>
-    
+
     Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU Lesser General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
@@ -30,17 +30,17 @@ class QTextStream;
 
 /**
  * Base class for terminal character decoders
  *
  * The decoder converts lines of terminal characters which consist of a unicode character, foreground
  * and background colours and other appearance-related properties into text strings.
  *
  * Derived classes may produce either plain text with no other colour or appearance information, or
- * they may produce text which incorporates these additional properties. 
+ * they may produce text which incorporates these additional properties.
  */
 class TerminalCharacterDecoder
 {
 public:
 	virtual ~TerminalCharacterDecoder() {}
 
     /** Begin decoding characters.  The resulting text is appended to @p output. */
     virtual void begin(QTextStream* output) = 0;
@@ -50,32 +50,32 @@ public:
 	/**
 	 * Converts a line of terminal characters with associated properties into a text string
 	 * and writes the string into an output QTextStream.
 	 *
 	 * @param characters An array of characters of length @p count.
 	 * @param properties Additional properties which affect all characters in the line
 	 * @param output The output stream which receives the decoded text
 	 */
-	virtual void decodeLine(const Character* const characters, 
+	virtual void decodeLine(const Character* const characters,
 							int count,
-							LineProperty properties) = 0; 
+							LineProperty properties) = 0;
 };
 
 /**
  * A terminal character decoder which produces plain text, ignoring colours and other appearance-related
  * properties of the original characters.
  */
 class PlainTextDecoder : public TerminalCharacterDecoder
 {
 public:
-	PlainTextDecoder(); 
+	PlainTextDecoder();
 
-    /** 
-     * Set whether trailing whitespace at the end of lines should be included 
+    /**
+     * Set whether trailing whitespace at the end of lines should be included
      * in the output.
      * Defaults to true.
      */
     void setTrailingWhitespace(bool enable);
     /**
      * Returns whether trailing whitespace at the end of lines is included
      * in the output.
      */
@@ -83,29 +83,29 @@ public:
 
     virtual void begin(QTextStream* output);
     virtual void end();
 
 	virtual void decodeLine(const Character* const characters,
 							int count,
 							LineProperty properties);	
 
-    
+
 private:
     QTextStream* _output;
     bool _includeTrailingWhitespace;
 };
 
 /**
  * A terminal character decoder which produces pretty HTML markup
  */
 class HTMLDecoder : public TerminalCharacterDecoder
 {
 public:
-	/** 
+	/**
 	 * Constructs an HTML decoder using a default black-on-white color scheme.
 	 */
 	HTMLDecoder();
 
 	/**
 	 * Sets the colour table which the decoder uses to produce the HTML colour codes in its
 	 * output
 	 */
@@ -119,16 +119,16 @@ public:
     virtual void end();
 
 private:
 	void openSpan(QString& text , const QString& style);
 	void closeSpan(QString& text);
 
     QTextStream* _output;
 	const ColorEntry* _colorTable;
-    bool _innerSpanOpen; 
+    bool _innerSpanOpen;
 	quint8 _lastRendition;
 	CharacterColor _lastForeColor;
 	CharacterColor _lastBackColor;
 
 };
 
 #endif
diff --git a/libgui/qterminal/libqterminal/unix/Vt102Emulation.h b/libgui/qterminal/libqterminal/unix/Vt102Emulation.h
--- a/libgui/qterminal/libqterminal/unix/Vt102Emulation.h
+++ b/libgui/qterminal/libqterminal/unix/Vt102Emulation.h
@@ -1,11 +1,11 @@
 /*
     This file is part of Konsole, an X terminal.
-    
+
     Copyright (C) 2007, 2013 by Robert Knight <robertknight@gmail.com>
     Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
 
     Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
@@ -23,17 +23,17 @@
 */
 
 #ifndef VT102EMULATION_H
 #define VT102EMULATION_H
 
 // Standard Library
 #include <stdio.h>
 
-// Qt 
+// Qt
 #include <QKeyEvent>
 #include <QtCore/QHash>
 #include <QtCore/QTimer>
 
 // Konsole
 #include "unix/Emulation.h"
 #include "unix/Screen.h"
 
@@ -61,56 +61,56 @@ struct CharCodes
   bool pound  ;    // Some VT100 tricks
   bool sa_graphic; // saved graphic
   bool sa_pound;   // saved pound
 };
 
 /**
  * Provides an xterm compatible terminal emulation based on the DEC VT102 terminal.
  * A full description of this terminal can be found at http://vt100.net/docs/vt102-ug/
- * 
- * In addition, various additional xterm escape sequences are supported to provide 
+ *
+ * In addition, various additional xterm escape sequences are supported to provide
  * features such as mouse input handling.
  * See http://rtfm.etla.org/xterm/ctlseq.html for a description of xterm's escape
- * sequences. 
+ * sequences.
  *
  */
 class Vt102Emulation : public Emulation
-{ 
+{
 Q_OBJECT
 
 public:
 
   /** Constructs a new emulation */
   Vt102Emulation();
   ~Vt102Emulation();
-  
+
   // reimplemented
   virtual void clearEntireScreen();
   virtual void reset();
-  
+
   // reimplemented
   virtual char getErase() const;
-  
-public slots: 
 
-  // reimplemented 
+public slots:
+
+  // reimplemented
   virtual void sendString(const char*,int length = -1);
   virtual void sendText(const QString& text);
   virtual void sendKeyEvent(QKeyEvent*);
   virtual void sendMouseEvent( int buttons, int column, int line , int eventType );
-  
+
 protected:
   // reimplemented
   virtual void setMode    (int mode);
   virtual void resetMode  (int mode);
 
-  // reimplemented 
+  // reimplemented
   virtual void receiveChar(int cc);
-  
+
 
 private slots:
 		
   //causes changeTitle() to be emitted for each (int,QString) pair in pendingTitleUpdates
   //used to buffer multiple title updates
   void updateTitle();
 
 
@@ -126,17 +126,17 @@ private:
   void setMargins(int top, int bottom);
   //set margins for all screens back to their defaults
   void setDefaultMargins();
 
   // returns true if 'mode' is set or false otherwise
   bool getMode    (int mode);
   // saves the current boolean value of 'mode'
   void saveMode   (int mode);
-  // restores the boolean value of 'mode' 
+  // restores the boolean value of 'mode'
   void restoreMode(int mode);
   // resets all modes
   void resetModes();
 
   void resetToken();
 #define MAXPBUF 80
   void pushToToken(int cc);
   int pbuf[MAXPBUF]; //FIXME: overflow?
@@ -169,19 +169,19 @@ private:
   // number of columns
   void clearScreenAndSetColumns(int columnCount);
 
   CharCodes _charset[2];
 
   DECpar _currParm;
   DECpar _saveParm;
 
-  //hash table and timer for buffering calls to the session instance 
+  //hash table and timer for buffering calls to the session instance
   //to update the name of the session
   //or window title.
-  //these calls occur when certain escape sequences are seen in the 
+  //these calls occur when certain escape sequences are seen in the
   //output from the terminal
   QHash<int,QString> _pendingTitleUpdates;
   QTimer* _titleUpdateTimer;
-  
+
 };
 
 #endif // VT102EMULATION_H
diff --git a/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.cpp b/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.cpp
--- a/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.cpp
+++ b/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.cpp
@@ -274,17 +274,17 @@ static void maybeSwapPoints (QPoint& beg
       || (end.y () == begin.y () && end.x () < begin.x ()))
     qSwap (begin, end);
 }
 
 //////////////////////////////////////////////////////////////////////////////
 
 QConsolePrivate::QConsolePrivate (QWinTerminalImpl* parent, const QString& cmd)
   : q (parent), m_command (cmd), m_cursorBlinking (false),
-    m_hasBlinkingCursor (true), m_cursorType (BlockCursor), 
+    m_hasBlinkingCursor (true), m_cursorType (BlockCursor),
     m_beginSelection (0, 0), m_endSelection (0, 0), m_settingSelection (false),
     m_process (NULL), m_inWheelEvent (false)
 {
   log (NULL);
 
   // Possibly detach from any existing console
   log ("Detaching from existing console (if any)...\n");
   FreeConsole ();
@@ -411,17 +411,17 @@ QConsolePrivate::QConsolePrivate (QWinTe
   updateVerticalScrollBar ();
 
   m_consoleWatcher = new QTimer (parent);
   m_consoleWatcher->setInterval (10);
   m_consoleWatcher->setSingleShot (false);
 
   m_blinkCursorTimer = new QTimer (parent);
   QObject::connect (m_blinkCursorTimer, SIGNAL (timeout()),
-                    q, SLOT (blinkCursorEvent ()));  
+                    q, SLOT (blinkCursorEvent ()));
 
   QObject::connect (m_horizontalScrollBar, SIGNAL (valueChanged (int)),
                     q, SLOT (horizontalScrollValueChanged (int)));
 
   QObject::connect (m_verticalScrollBar, SIGNAL (valueChanged (int)),
                     q, SLOT (verticalScrollValueChanged (int)));
 
   QObject::connect (m_consoleWatcher, SIGNAL (timeout (void)),
@@ -852,19 +852,19 @@ void QConsolePrivate::drawCursor (QPaint
       if (m_cursorType == QConsolePrivate::BlockCursor)
         {
           if (q->hasFocus ())
             p.fillRect (rect, color);
           else
             {
               // draw the cursor outline, adjusting the area so that
               // it is draw entirely inside 'rect'
- 
+
               int penWidth = qMax (1, p.pen().width());
- 
+
               p.drawRect (rect.adjusted (penWidth/2, penWidth/2,
                                          - penWidth/2 - penWidth%2,
                                          - penWidth/2 - penWidth%2));
             }
         }
       else if (m_cursorType == QConsolePrivate::UnderlineCursor)
         {
           p.drawLine (rect.left (), rect.bottom (),
@@ -1371,21 +1371,21 @@ void QConsolePrivate::sendConsoleText (c
           events[nEvents].Event.KeyEvent.bKeyDown          = TRUE;
           events[nEvents].Event.KeyEvent.wRepeatCount      = 1;
           events[nEvents].Event.KeyEvent.wVirtualKeyCode   =
             VK_RETURN;
           events[nEvents].Event.KeyEvent.wVirtualScanCode  = 0;
           events[nEvents].Event.KeyEvent.uChar.UnicodeChar = c.unicode ();
           events[nEvents].Event.KeyEvent.dwControlKeyState = 0;
           nEvents++;
- 
+
           WriteConsoleInput (hStdIn, events, nEvents, &written);
           nEvents = 0;
           ZeroMemory (events, sizeof (events));
- 
+
         }
       else
         {
           events[nEvents].EventType                        = KEY_EVENT;
           events[nEvents].Event.KeyEvent.bKeyDown          = TRUE;
           events[nEvents].Event.KeyEvent.wRepeatCount      = 1;
           events[nEvents].Event.KeyEvent.wVirtualKeyCode   =
             LOBYTE (VkKeyScan (c.unicode ()));
diff --git a/libgui/qterminal/qterminal/main.cpp b/libgui/qterminal/qterminal/main.cpp
--- a/libgui/qterminal/qterminal/main.cpp
+++ b/libgui/qterminal/qterminal/main.cpp
@@ -28,13 +28,13 @@ int main(int argc, char *argv[])
     QApplication app(argc, argv);
     QMainWindow *mainWindow = new QMainWindow();
 
     QTerminal *terminal = new QTerminal();
 
     mainWindow->setCentralWidget(terminal);
     mainWindow->resize(600, 400);
 
-    mainWindow->show();    
+    mainWindow->show();
     return app.exec();
-} 
+}
 
-  
+
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -2072,17 +2072,17 @@ file_editor_tab::center_current_line ()
 
       int first_line = _edit_area->firstVisibleLine ();
       first_line = first_line + (line - first_line - (visible_lines-1)/2);
 
       _edit_area->SendScintilla (2613,first_line); // SCI_SETFIRSTVISIBLELINE
     }
 }
 
-void 
+void
 file_editor_tab::handle_cursor_moved (int line, int col)
 {
   if (_edit_area->SendScintilla (QsciScintillaBase::SCI_AUTOCACTIVE))
     show_auto_completion (this);
 
   _row_indicator->setNum (line+1);
   _col_indicator->setNum (col+1);
 }
diff --git a/libgui/src/octave-gui.cc b/libgui/src/octave-gui.cc
--- a/libgui/src/octave-gui.cc
+++ b/libgui/src/octave-gui.cc
@@ -179,16 +179,16 @@ octave_start_gui (int argc, char *argv[]
 
       return application.exec ();
     }
   else
     {
       QApplication application (argc, argv);
 
       octave_cli_thread main_thread (argc, argv);
-      
+
       application.setQuitOnLastWindowClosed (false);
 
       main_thread.start ();
 
       return application.exec ();
     }
 }
diff --git a/libgui/src/octave-qt-link.cc b/libgui/src/octave-qt-link.cc
--- a/libgui/src/octave-qt-link.cc
+++ b/libgui/src/octave-qt-link.cc
@@ -549,10 +549,10 @@ void
 octave_qt_link::do_show_doc (const std::string& file)
 {
   emit show_doc_signal (QString::fromStdString (file));
 }
 
 void
 octave_qt_link::terminal_interrupt (void)
 {
-  command_interpreter->interrupt ();  
+  command_interpreter->interrupt ();
 }
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -6723,17 +6723,17 @@ Undocumented internal function.\n\
               Range r = vals.range_value ();
               if (r.inc () == 0)
                 vals = r.base ();
             }
 
           if (vals.is_single_type ())
             {
               if (vals.is_complex_type ())
-                retval = do_accumarray_sum (idx, 
+                retval = do_accumarray_sum (idx,
                                             vals.float_complex_array_value (),
                                             n);
               else
                 retval = do_accumarray_sum (idx, vals.float_array_value (), n);
             }
           else if (vals.is_numeric_type () || vals.is_bool_type ())
             {
               if (vals.is_complex_type ())
diff --git a/libinterp/corefcn/defun-int.h b/libinterp/corefcn/defun-int.h
--- a/libinterp/corefcn/defun-int.h
+++ b/libinterp/corefcn/defun-int.h
@@ -86,17 +86,17 @@ defun_isargout (int, int, bool *);
   DECLARE_FUNX (F ## name, args_name, nargout_name)
 
 // Define the code that will be used to insert the new function into
 // the symbol table.  We look for this name instead of the actual
 // function so that we can easily install the doc std::string too.
 
 typedef bool (*octave_dld_fcn_installer) (const octave_shlib&, bool relative);
 
-typedef octave_function * 
+typedef octave_function *
   (*octave_dld_fcn_getter) (const octave_shlib&, bool relative);
 
 #define DEFINE_FUN_INSTALLER_FUN(name, doc) \
   DEFINE_FUNX_INSTALLER_FUN(#name, F ## name, G ## name, doc)
 
 #define DEFINE_FUNX_INSTALLER_FUN(name, fname, gname, doc) \
   extern "C" \
   OCTAVE_EXPORT \
diff --git a/libinterp/corefcn/det.cc b/libinterp/corefcn/det.cc
--- a/libinterp/corefcn/det.cc
+++ b/libinterp/corefcn/det.cc
@@ -229,17 +229,17 @@ For that, use any of the condition numbe
                 }
             }
           else
             {
               ComplexMatrix m = arg.complex_matrix_value ();
               if (! error_state)
                 {
                   MAYBE_CAST (rep, octave_complex_matrix);
-                  MatrixType mtype = rep ? rep -> matrix_type () 
+                  MatrixType mtype = rep ? rep -> matrix_type ()
                                          : MatrixType ();
                   ComplexDET det = m.determinant (mtype, info, rcond);
                   retval(1) = rcond;
                   retval(0) = info == -1 ? Complex (0.0) : det.value ();
                   if (rep) rep->matrix_type (mtype);
                 }
             }
         }
diff --git a/libinterp/corefcn/gl2ps-renderer.cc b/libinterp/corefcn/gl2ps-renderer.cc
--- a/libinterp/corefcn/gl2ps-renderer.cc
+++ b/libinterp/corefcn/gl2ps-renderer.cc
@@ -192,17 +192,17 @@ template <typename T>
 static void
 draw_pixels (GLsizei w, GLsizei h, GLenum format, const T *data, float maxval)
 {
   OCTAVE_LOCAL_BUFFER (GLfloat, a, 3*w*h);
 
   // Convert to GL_FLOAT as it is the only type gl2ps accepts.
   for (unsigned int i = 0; i < 3*w*h; i++)
     a[i] = data[i] / maxval;
-  
+
   gl2psDrawPixels (w, h, 0, 0, format, GL_FLOAT, a);
 }
 
 void
 glps_renderer::draw_pixels (GLsizei w, GLsizei h, GLenum format,
                             GLenum type, const GLvoid *data)
 {
   // gl2psDrawPixels only supports the GL_FLOAT type.
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -3774,32 +3774,32 @@ figure::properties::update_papersize (vo
                + std::abs (sz(1) - 514.0 * mm2in) < tol)
         typ = "b3";
       else if (std::abs (sz(0) - 257.0 * mm2in)
                + std::abs (sz(1) - 364.0 * mm2in) < tol)
         typ = "b4";
       else if (std::abs (sz(0) - 182.0 * mm2in)
                + std::abs (sz(1) - 257.0 * mm2in) < tol)
         typ = "b5";
-      else if (std::abs (sz(0) - 9.0) 
+      else if (std::abs (sz(0) - 9.0)
                + std::abs (sz(1) - 12.0) < tol)
         typ = "arch-a";
       else if (std::abs (sz(0) - 12.0)
                + std::abs (sz(1) - 18.0) < tol)
         typ = "arch-b";
       else if (std::abs (sz(0) - 18.0)
                + std::abs (sz(1) - 24.0) < tol)
         typ = "arch-c";
       else if (std::abs (sz(0) - 24.0)
                + std::abs (sz(1) - 36.0) < tol)
         typ = "arch-d";
       else if (std::abs (sz(0) - 36.0)
                + std::abs (sz(1) - 48.0) < tol)
         typ = "arch-e";
-      else if (std::abs (sz(0) - 8.5) 
+      else if (std::abs (sz(0) - 8.5)
                + std::abs (sz(1) - 11.0) < tol)
         typ = "a";
       else if (std::abs (sz(0) - 11.0)
                + std::abs (sz(1) - 17.0) < tol)
         typ = "b";
       else if (std::abs (sz(0) - 17.0)
                + std::abs (sz(1) - 22.0) < tol)
         typ = "c";
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -5158,17 +5158,17 @@ public:
       radio_property units S , "{normalized}|inches|centimeters|points|pixels|characters"
     END_PROPERTIES
 
   protected:
     void init (void)
       {
         position.add_constraint (dim_vector (1, 4));
       }
-    
+
     void update_units (const caseless_str& old_units);
     void update_fontunits (const caseless_str& old_units);
 
   };
 
 private:
   properties xproperties;
 
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -545,17 +545,17 @@ read_mat5_binary_element (std::istream& 
           if (swap)
             swap_bytes<4> (tmp, 2);
 
           destLen = tmp[1] + 8;
           std::string outbuf (destLen, ' ');
 
           // FIXME: find a way to avoid casting away const here!
 
-          int err = uncompress (reinterpret_cast<Bytef *> 
+          int err = uncompress (reinterpret_cast<Bytef *>
                                  (const_cast<char *> (outbuf.c_str ())),
                                 &destLen, reinterpret_cast<Bytef *> (inbuf),
                                 element_length);
 
           if (err != Z_OK)
             {
               std::string msg;
               switch (err)
diff --git a/libinterp/corefcn/lu.cc b/libinterp/corefcn/lu.cc
--- a/libinterp/corefcn/lu.cc
+++ b/libinterp/corefcn/lu.cc
@@ -222,17 +222,17 @@ information.\n\
 
               if ( nargout < 2 )
                   retval(0) = fact.Y ();
               else
                 {
 
                   retval(1)
                     = octave_value (
-                        fact.U () * fact.Pc_mat ().transpose (),                    
+                        fact.U () * fact.Pc_mat ().transpose (),
                         MatrixType (MatrixType::Permuted_Upper,
                                     nc, fact.col_perm ()));
 
                   PermMatrix P = fact.Pr_mat ();
                   SparseMatrix L = fact.L ();
                   if ( nargout < 3 )
                       retval(0)
                         = octave_value ( P.transpose () * L,
@@ -292,17 +292,17 @@ information.\n\
 
                   retval(0) = fact.Y ();
 
               else
                 {
 
                   retval(1)
                     = octave_value (
-                        fact.U () * fact.Pc_mat ().transpose (),                    
+                        fact.U () * fact.Pc_mat ().transpose (),
                         MatrixType (MatrixType::Permuted_Upper,
                                     nc, fact.col_perm ()));
 
                   PermMatrix P = fact.Pr_mat ();
                   SparseComplexMatrix L = fact.L ();
                   if ( nargout < 3 )
                       retval(0)
                         = octave_value ( P.transpose () * L,
diff --git a/libinterp/corefcn/oct-tex-parser.yy b/libinterp/corefcn/oct-tex-parser.yy
--- a/libinterp/corefcn/oct-tex-parser.yy
+++ b/libinterp/corefcn/oct-tex-parser.yy
@@ -42,17 +42,17 @@ static void yyerror (text_parser_tex& pa
 #define malloc GNULIB_NAMESPACE::malloc
 #endif
 
 #define scanner parser.get_scanner ()
 %}
 
 %name-prefix="octave_tex_"
 %define api.pure
-%parse-param { text_parser_tex& parser } 
+%parse-param { text_parser_tex& parser }
 %lex-param { void *scanner }
 
 %code requires {#include <string>}
 
 %union {
   /* Leaf symbols produced by the scanner */
   char                       ch;
   double                     num;
diff --git a/libinterp/corefcn/oct-tex-symbols.in b/libinterp/corefcn/oct-tex-symbols.in
--- a/libinterp/corefcn/oct-tex-symbols.in
+++ b/libinterp/corefcn/oct-tex-symbols.in
@@ -1,14 +1,14 @@
 # List of supported symbols for the TeX interpreter
 # (http://www.mathworks.com/help/matlab/ref/text_props.html):
 # - symbol name
 # - Unicode code
 # - MS symbol code (http://www.kostis.net/charsets/symbol.htm)
-# - Arranged by listings in The TeXbook, Appendix F 
+# - Arranged by listings in The TeXbook, Appendix F
 # - Lowercase Greek letters: Greek Upper case: Misc Symbols type Ord: "Large" operators:
 # - Binary operators: Relations: Negated relations: Arrows: Openings: Closings: Alternate names:
 # - Other (not in Appendix F Tables):
 
 alpha           0x03B1  0xF061
 beta            0x03B2  0xF062
 gamma           0x03B3  0xF067
 delta           0x03B4  0xF064
diff --git a/libinterp/corefcn/quadcc.cc b/libinterp/corefcn/quadcc.cc
--- a/libinterp/corefcn/quadcc.cc
+++ b/libinterp/corefcn/quadcc.cc
@@ -1638,17 +1638,17 @@ Mathematical Software, Vol. 37, Issue 3,
       error ("quadcc: list of singularities (SING) must be a vector of real values");
       return retval;
     }
   else
     {
       nivals = 1 + args(4).numel ();
     }
 
-  int cquad_heapsize = (nivals >= min_cquad_heapsize ? nivals + 1 
+  int cquad_heapsize = (nivals >= min_cquad_heapsize ? nivals + 1
                                                      : min_cquad_heapsize);
   /* The interval heap. */
   OCTAVE_LOCAL_BUFFER (cquad_ival, ivals, cquad_heapsize);
   OCTAVE_LOCAL_BUFFER (double, iivals, cquad_heapsize);
   OCTAVE_LOCAL_BUFFER (int, heap, cquad_heapsize);
 
   if (nivals == 1)
     {
diff --git a/libinterp/corefcn/zfstream.cc b/libinterp/corefcn/zfstream.cc
--- a/libinterp/corefcn/zfstream.cc
+++ b/libinterp/corefcn/zfstream.cc
@@ -400,17 +400,17 @@ gzfilebuf::enable_buffer ()
       if (buffer_size > 0)
         {
           // Allocate internal buffer
           buffer = new char_type [buffer_size];
           // Get area starts empty and will be expanded by underflow as needed
           this->setg (buffer, buffer, buffer);
           // Setup entire internal buffer as put area.
           // The one-past-end pointer actually points to the last element of
-          // the buffer, so that overflow(c) can safely add the extra character 
+          // the buffer, so that overflow(c) can safely add the extra character
           // c to the sequence.  These pointers remain in place for the
           // duration of the buffer
           this->setp (buffer, buffer + buffer_size - 1);
         }
       else
         {
           // Even in "unbuffered" case, (small?) get buffer is still required
           buffer_size = SMALLBUFSIZE;
diff --git a/libinterp/dldfcn/__eigs__.cc b/libinterp/dldfcn/__eigs__.cc
--- a/libinterp/dldfcn/__eigs__.cc
+++ b/libinterp/dldfcn/__eigs__.cc
@@ -568,17 +568,17 @@ Undocumented internal function.\n\
                         (eigs_func, n, typ, sigmar, k, p, info, eig_vec,
                          eig_val, resid, octave_stdout, tol, (nargout > 1),
                          cholB, disp, maxit);
               else if (have_sigma)
                 {
                   if (a_is_sparse)
                     nconv = EigsRealNonSymmetricMatrixShift
                             (asmm, sigmar, k, p, info, eig_vec, eig_val, bsmm,
-                             permB, resid, octave_stdout, tol, (nargout > 1), 
+                             permB, resid, octave_stdout, tol, (nargout > 1),
                              cholB, disp, maxit);
                   else
                     nconv = EigsRealNonSymmetricMatrixShift
                             (amm, sigmar, k, p, info, eig_vec, eig_val, bmm,
                              permB, resid, octave_stdout, tol, (nargout > 1),
                              cholB, disp, maxit);
                 }
               else
diff --git a/libinterp/dldfcn/__voronoi__.cc b/libinterp/dldfcn/__voronoi__.cc
--- a/libinterp/dldfcn/__voronoi__.cc
+++ b/libinterp/dldfcn/__voronoi__.cc
@@ -193,28 +193,28 @@ Undocumented internal function.\n\
       // Find the number of Voronoi vertices for each Voronoi cell and
       // store them in NI so we can use them later to set the dimensions
       // of the RowVector objects used to collect them.
 
       FORALLfacets
         {
           facet->seen = false;
         }
-      
+
       OCTAVE_LOCAL_BUFFER (octave_idx_type, ni, num_voronoi_regions);
       for (octave_idx_type i = 0; i < num_voronoi_regions; i++)
         ni[i] = 0;
 
       k = 0;
 
       FORALLvertices
         {
           if (qh hull_dim == 3)
             qh_order_vertexneighbors (vertex);
-          
+
           bool infinity_seen = false;
 
           facetT *neighbor, **neighborp;
 
           FOREACHneighbor_ (vertex)
             {
               if (neighbor->upperdelaunay)
                 {
diff --git a/libinterp/gendoc.pl b/libinterp/gendoc.pl
--- a/libinterp/gendoc.pl
+++ b/libinterp/gendoc.pl
@@ -38,17 +38,17 @@ DFFILE: foreach $df_fname (@ARGV)
 
   LINE: while (<DF_FH>)
   {
     if (/XDEFUN_FILE_NAME \("([^"]+)"/)
     {
       $src_fname = $1;
       next LINE;
     }
-    if (/XDEF/ and ! /XDEFALIAS/) 
+    if (/XDEF/ and ! /XDEFALIAS/)
     {
       ## Decode 4 or 5 part macro definition.
       ($func, $str) = /\("?(\w+)"?,[^,]+,[^,]+,(?:[^,]+,)?\s*"(.*)"\)\s*$/ ;
 
       unless ($func) { die "Unable to parse $df_fname at line $.\n" }
 
       push (@func_list, $func);
       ## Do escape sequence expansion
diff --git a/libinterp/genprops.awk b/libinterp/genprops.awk
--- a/libinterp/genprops.awk
+++ b/libinterp/genprops.awk
@@ -1,22 +1,22 @@
 ## Copyright (C) 2007-2013 John W. Eaton
 ##
 ## This file is part of Octave.
-## 
+##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
-## 
+##
 ## Octave is distributed in the hope that it will be useful, but WITHOUT
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 ##
 ## Generate the graphics.h file from graphics.h.in and write the
 ## output to stdout.
 ##
 ## If the variable emit_graphics_props is set on the command line,
@@ -68,17 +68,17 @@
 ##       function, so we don't emit one.
 ##
 ##   S:  There is a custom extern definition for the type-specific set
 ##       function, so we emit only the declaration.
 ##
 ################################################################################
 ##   'o','O','a' are currently not processed.  They are commented out in code.
 ################################################################################
-##    
+##
 ##   o:  There is a custom inline definition for the octave_value version
 ##       of the set function, so we don't emit one.
 ##
 ##   O:  There is a custom extern definition for the octave_value version
 ##       of the set function, so we emit only the declaration.
 ##
 ##   a:  The octave_value version of the set function will use assignment:
 ##
@@ -139,103 +139,103 @@
 ## The 'o' and 'O' qualifiers are only useful when the the property type
 ## is something other than octave_value.
 
 ## simple accessor
 
 function emit_get_accessor (i, rtype, faccess)
 {
   printf ("  %s get_%s (void) const", rtype, name[i]);
-  
+
   if (emit_get[i] == "definition")
     printf (" { return %s.%s (); }\n", name[i], faccess);
   else
     printf (";\n");
 }
 
 ## bool_property
 
 function emit_get_bool (i)
 {
   printf ("  bool is_%s (void) const", name[i]);
-  
+
   if (emit_get[i] == "definition")
     printf (" { return %s.is_on (); }\n", name[i]);
   else
     printf (";\n");
 
   emit_get_accessor(i, "std::string", "current_value");
 }
 
 ## radio_property
 
 function emit_get_radio (i)
 {
   printf ("  bool %s_is (const std::string& v) const", name[i]);
-  
+
   if (emit_get[i] == "definition")
     printf (" { return %s.is (v); }\n", name[i]);
   else
     printf (";\n");
 
   emit_get_accessor(i, "std::string", "current_value");
 }
 
 ## color_property
 
 function emit_get_color (i)
 {
   printf ("  bool %s_is_rgb (void) const { return %s.is_rgb (); }\n", name[i], name[i]);
 
   printf ("  bool %s_is (const std::string& v) const", name[i]);
-  
+
   if (emit_get[i] == "definition")
     printf (" { return %s.is (v); }\n", name[i]);
   else
     printf (";\n");
-  
+
   printf ("  Matrix get_%s_rgb (void) const", name[i]);
-  
+
   if (emit_get[i] == "definition")
     printf (" { return (%s.is_rgb () ? %s.rgb () : Matrix ()); }\n", name[i], name[i]);
   else
     printf (";\n");
 
   emit_get_accessor(i, "octave_value", "get");
 }
 
 ## double_radio_property
 
 function emit_get_double_radio (i)
 {
   printf ("  bool %s_is_double (void) const { return %s.is_double (); }\n", name[i], name[i]);
 
   printf ("  bool %s_is (const std::string& v) const", name[i]);
-  
+
   if (emit_get[i] == "definition")
     printf (" { return %s.is (v); }\n", name[i]);
   else
     printf (";\n");
-  
+
   printf ("  double get_%s_double (void) const", name[i]);
-  
+
   if (emit_get[i] == "definition")
     printf (" { return (%s.is_double () ? %s.double_value () : 0); }\n", name[i], name[i]);
   else
     printf (";\n");
 
   emit_get_accessor(i, "octave_value", "get");
 }
 
 ## callback_property
 
 function emit_get_callback (i)
 {
   printf ("  void execute_%s (const octave_value& data = octave_value ()) const", name[i]);
-  
+
   if (emit_get[i] == "definition")
     printf (" { %s.execute (data); }\n", name[i]);
   else
     printf (";\n");
 
   emit_get_accessor(i, "octave_value", "get");
 }
 
@@ -298,17 +298,17 @@ function emit_declarations ()
   if (idx > 0)
     print (base ? "protected:\n" : "private:\n");
 
   for (i = 1; i <= idx; i++)
     printf ("  %s%s %s;\n", mutable[i] ? "mutable " : "", type[i], name[i]);
 
   if (idx > 0)
     print "\npublic:\n";
-  
+
   if (idx > 0)
   {
     printf ("  enum\n  {");
     for (i = 1; i <= idx; i++)
     {
       printf ("%s\n    ID_%s = %d", (i == 1 ? "" : ","), toupper(name[i]), pcount);
       pcount++;
     }
@@ -758,30 +758,30 @@ BEGIN {
         ## so we don't emit anything.
         if (index (quals, "s"))
           emit_set[idx] = "";
 
         ## There is a custom extern definition for the set function,
         ## but we still emit the declaration.
         if (index (quals, "S"))
           emit_set[idx] = "declaration";
-        
+
         ## The property is hidden
         if (index (quals, "h"))
           hidden[idx] = 1;
 
         ## The property is read-only
         if (index (quals, "r"))
           readonly[idx] = 1;
 
         ## There is an inline updater method that should be called
         ## from the set method
         if (index (quals, "u"))
           updater[idx] = "inline";
-        
+
         ## There is an extern updater method that should be called
         ## from the set method
         if (index (quals, "U"))
           updater[idx] = "extern";
 
         ## There is not factory default value
         if (index (quals, "f"))
           factory[idx] = 0;
diff --git a/libinterp/mk-errno-list b/libinterp/mk-errno-list
--- a/libinterp/mk-errno-list
+++ b/libinterp/mk-errno-list
@@ -1,24 +1,24 @@
 #! /bin/sh
 #
 # Copyright (C) 2005-2013 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 if [ $# -ne 2 ]; then
   echo "usage: get-errno-list [--perl PERL|--python PYTHON]" 1>&2
   exit 1
 fi
diff --git a/libinterp/mk-pkg-add b/libinterp/mk-pkg-add
--- a/libinterp/mk-pkg-add
+++ b/libinterp/mk-pkg-add
@@ -1,37 +1,37 @@
 #! /bin/sh
 #
 # Copyright (C) 2005-2013 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 set -e
 
 SED=${SED:-'sed'}
 
 for f in "$@"; do
   if [ -f $f ]; then
 
     ## Compute and print the autoloads.
-  
+
     base=`basename $f | $SED 's/\.df$//'`
     fcns=`$SED -n -e 's/^ *XDEFUN_DLD_INTERNAL *( *\([^, ]*\)[, ].*$/\1/p' \
                   -e 's/^ *XDEFUNX_DLD_INTERNAL *( *"\([^"]*\)".*$/\1/p' $f | \
           sort -u`
     if [ -n "$fcns" ]; then
       for n in $fcns; do
         if [ "$n" = "$base" ]; then
           true
diff --git a/libinterp/mkbuiltins b/libinterp/mkbuiltins
--- a/libinterp/mkbuiltins
+++ b/libinterp/mkbuiltins
@@ -1,24 +1,24 @@
 #! /bin/sh
 #
 # Copyright (C) 1996-2013 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 if test $# -lt 2; then
   echo "usage: mkbuiltins --header|--source f1 f2 ..." 1>&2
   exit 1
 fi
diff --git a/libinterp/mkdefs b/libinterp/mkdefs
--- a/libinterp/mkdefs
+++ b/libinterp/mkdefs
@@ -1,24 +1,24 @@
 #! /bin/sh
 #
 # Copyright (C) 1996-2013 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 SED=${SED:-'sed'}
 
 if [ $# -ne 2 ]; then
   echo "usage: mkdefs srcdir file < preprocessed-file-contents" 1>&2
diff --git a/libinterp/mkdocs b/libinterp/mkdocs
--- a/libinterp/mkdocs
+++ b/libinterp/mkdocs
@@ -1,24 +1,24 @@
 #! /bin/sh
 #
 # Copyright (C) 1999-2013 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 SED=${SED:-'sed'}
 
 $SED -n -e '/^BEGIN_DOC_STRING/{
   : loop
diff --git a/libinterp/mkops b/libinterp/mkops
--- a/libinterp/mkops
+++ b/libinterp/mkops
@@ -1,24 +1,24 @@
 #! /bin/sh
 #
 # Copyright (C) 1997-2013 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 SED=${SED:-'sed'}
 
 cat << \EOF
 // DO NOT EDIT!  Generated automatically by mkops.
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -1007,17 +1007,17 @@ box (JNIEnv* jni_env, jobject jobj, jcla
           break;
         }
 
       cls = jni_env->FindClass ("java/lang/Character");
       if (jni_env->IsInstanceOf (jobj, cls))
         {
           jmethodID m = jni_env->GetMethodID (cls, "charValue", "()C");
           retval = jni_env->CallCharMethod (jobj, m);
-          retval = retval.convert_to_str (false, true); 
+          retval = retval.convert_to_str (false, true);
           break;
         }
 
       if (Vjava_matrix_autoconversion)
         {
           cls = find_octave_class (jni_env, "org/octave/Matrix");
 
           if (jni_env->IsInstanceOf (jobj, cls))
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -174,17 +174,17 @@ object) relevant global values before an
           curr_lexer->push_start_state (COMMAND_START); \
         } \
       else \
         { \
           return curr_lexer->handle_incompatible_op (PATTERN, TOK, false); \
         } \
     } \
   while (0)
-    
+
 #define CMD_OR_UNARY_OP(PATTERN, TOK, COMPAT) \
  \
   do \
     { \
       curr_lexer->lexer_debug (PATTERN); \
  \
       if (curr_lexer->previous_token_may_be_command ()) \
         { \
@@ -724,17 +724,17 @@ ANY_INCLUDING_NL (.|{NL})
             while (i < len)
               {
                 char c = yytext[i++];
                 if (! (c == ' ' || c == '\t' || c == '\n' || c == '\r'))
                   {
                     looks_like_block_comment = false;
                     break;
                   }
-              }      
+              }
 
             if (looks_like_block_comment)
               {
                 yyless (0);
 
                 curr_lexer->finish_comment (octave_comment_elt::full_line);
 
                 curr_lexer->pop_start_state ();
@@ -759,17 +759,17 @@ ANY_INCLUDING_NL (.|{NL})
 // End of a block of full-line comments.
 %}
 
 <LINE_COMMENT_START>{ANY_INCLUDING_NL} {
     curr_lexer->lexer_debug ("<LINE_COMMENT_START>{ANY_INCLUDING_NL}");
 
     curr_lexer->xunput (yytext[0]);
 
-    curr_lexer->finish_comment (octave_comment_elt::full_line);  
+    curr_lexer->finish_comment (octave_comment_elt::full_line);
 
     curr_lexer->pop_start_state ();
   }
 
 %{
 // End of a block of full-line comments.
 %}
 
@@ -1959,17 +1959,17 @@ lexical_feedback::reset (void)
   end_of_input = false;
   at_beginning_of_statement = true;
   looking_at_anon_fcn_args = false;
   looking_at_return_list = false;
   looking_at_parameter_list = false;
   looking_at_decl_list = false;
   looking_at_initializer_expression = false;
   looking_at_matrix_or_assign_lhs = false;
-  looking_for_object_index = false; 
+  looking_for_object_index = false;
   looking_at_indirect_ref = false;
   parsing_class_method = false;
   maybe_classdef_get_set_method = false;
   parsing_classdef = false;
   force_script = false;
   reading_fcn_file = false;
   reading_script_file = false;
   reading_classdef_file = false;
@@ -3372,17 +3372,17 @@ octave_base_lexer::show_token (int tok)
 {
   if (Vdisplay_tokens)
     display_token (tok);
 
   if (lexer_debug_flag)
     {
       std::cerr << "R: ";
       display_token (tok);
-      std::cerr << std::endl; 
+      std::cerr << std::endl;
     }
 
   return tok;
 }
 
 int
 octave_lexer::fill_flex_buffer (char *buf, unsigned max_size)
 {
@@ -3405,17 +3405,17 @@ octave_lexer::fill_flex_buffer (char *bu
 
 int
 octave_push_lexer::fill_flex_buffer (char *buf, unsigned max_size)
 {
   int status = 0;
 
   if (input_buf.empty () && ! input_buf.at_eof ())
     input_buf.fill (std::string (1, static_cast<char> (1)), false);
- 
+
   if (! input_buf.empty ())
     status = input_buf.copy_chunk (buf, max_size);
   else
     status = YY_NULL;
 
   return status;
 }
 
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -298,41 +298,41 @@ static void yyerror (octave_base_parser&
 // here).
 
 %destructor { } <sep_type>
 %destructor { } <tok_val>
 %destructor { } <comment_type>
 %destructor { } <dummy_type>
 %destructor { } <>
 
-%destructor { delete $$; } <tree_type> 
-%destructor { delete $$; } <tree_matrix_type> 
-%destructor { delete $$; } <tree_cell_type> 
-%destructor { delete $$; } <tree_expression_type> 
-%destructor { delete $$; } <tree_constant_type> 
-%destructor { delete $$; } <tree_fcn_handle_type> 
-%destructor { delete $$; } <tree_anon_fcn_handle_type> 
-%destructor { delete $$; } <tree_identifier_type> 
-%destructor { delete $$; } <tree_index_expression_type> 
-%destructor { delete $$; } <tree_colon_expression_type> 
-%destructor { delete $$; } <tree_argument_list_type> 
-%destructor { delete $$; } <tree_parameter_list_type> 
-%destructor { delete $$; } <tree_command_type> 
-%destructor { delete $$; } <tree_if_command_type> 
-%destructor { delete $$; } <tree_if_clause_type> 
-%destructor { delete $$; } <tree_if_command_list_type> 
-%destructor { delete $$; } <tree_switch_command_type> 
-%destructor { delete $$; } <tree_switch_case_type> 
-%destructor { delete $$; } <tree_switch_case_list_type> 
-%destructor { delete $$; } <tree_decl_elt_type> 
-%destructor { delete $$; } <tree_decl_init_list_type> 
-%destructor { delete $$; } <tree_decl_command_type> 
-%destructor { delete $$; } <tree_statement_type> 
-%destructor { delete $$; } <tree_statement_list_type> 
-%destructor { delete $$; } <octave_user_function_type> 
+%destructor { delete $$; } <tree_type>
+%destructor { delete $$; } <tree_matrix_type>
+%destructor { delete $$; } <tree_cell_type>
+%destructor { delete $$; } <tree_expression_type>
+%destructor { delete $$; } <tree_constant_type>
+%destructor { delete $$; } <tree_fcn_handle_type>
+%destructor { delete $$; } <tree_anon_fcn_handle_type>
+%destructor { delete $$; } <tree_identifier_type>
+%destructor { delete $$; } <tree_index_expression_type>
+%destructor { delete $$; } <tree_colon_expression_type>
+%destructor { delete $$; } <tree_argument_list_type>
+%destructor { delete $$; } <tree_parameter_list_type>
+%destructor { delete $$; } <tree_command_type>
+%destructor { delete $$; } <tree_if_command_type>
+%destructor { delete $$; } <tree_if_clause_type>
+%destructor { delete $$; } <tree_if_command_list_type>
+%destructor { delete $$; } <tree_switch_command_type>
+%destructor { delete $$; } <tree_switch_case_type>
+%destructor { delete $$; } <tree_switch_case_list_type>
+%destructor { delete $$; } <tree_decl_elt_type>
+%destructor { delete $$; } <tree_decl_init_list_type>
+%destructor { delete $$; } <tree_decl_command_type>
+%destructor { delete $$; } <tree_statement_type>
+%destructor { delete $$; } <tree_statement_list_type>
+%destructor { delete $$; } <octave_user_function_type>
 
 %destructor {
     warning_with_id
       ("Octave:parser-destructor",
        "possible memory leak in cleanup following parse error");
  } <*>
 
 // Where to start.
@@ -3423,17 +3423,17 @@ octave_push_parser::init (void)
 int
 octave_push_parser::run (const std::string& input, bool eof)
 {
   int status = -1;
 
   dynamic_cast<octave_push_lexer&> (lexer).append_input (input, eof);
 
   do
-    {   
+    {
       YYSTYPE lval;
 
       int token = octave_lex (&lval, scanner);
 
       if (token < 0)
         {
           if (! eof && lexer.at_end_of_buffer ())
             {
@@ -3456,17 +3456,17 @@ safe_fclose (FILE *f)
 {
   if (f)
     fclose (static_cast<FILE *> (f));
 }
 
 static octave_function *
 parse_fcn_file (const std::string& full_file, const std::string& file,
                 const std::string& dispatch_type,
-                bool require_file, bool force_script, bool autoload,    
+                bool require_file, bool force_script, bool autoload,
                 bool relative_lookup, const std::string& warn_for)
 {
   unwind_protect frame;
 
   octave_function *fcn_ptr = 0;
 
   // Open function file and parse.
 
@@ -4605,17 +4605,17 @@ Undocumented internal function.\n\
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       std::string file = args(0).string_value ();
-      
+
       std::string full_file = octave_env::make_absolute (file);
 
       size_t file_len = file.length ();
 
       if ((file_len > 4 && file.substr (file_len-4) == ".oct")
           || (file_len > 4 && file.substr (file_len-4) == ".mex")
           || (file_len > 2 && file.substr (file_len-2) == ".m"))
         {
diff --git a/libinterp/parse-tree/octave.gperf b/libinterp/parse-tree/octave.gperf
--- a/libinterp/parse-tree/octave.gperf
+++ b/libinterp/parse-tree/octave.gperf
@@ -81,17 +81,17 @@ catch, CATCH, catch_kw
 classdef, CLASSDEF, classdef_kw
 continue, CONTINUE, continue_kw
 do, DO, do_kw
 else, ELSE, else_kw
 elseif, ELSEIF, elseif_kw
 end, END, end_kw
 end_try_catch, END, end_try_catch_kw
 end_unwind_protect, END, end_unwind_protect_kw
-endclassdef, END, endclassdef_kw 
+endclassdef, END, endclassdef_kw
 endenumeration, END, endenumeration_kw
 endevents, END, endevents_kw
 endfor, END, endfor_kw
 endfunction, END, endfunction_kw
 endif, END, endif_kw
 endmethods, END, endmethods_kw
 endparfor, END, endparfor_kw
 endproperties, END, endproperties_kw
diff --git a/liboctave/Makefile.am b/liboctave/Makefile.am
--- a/liboctave/Makefile.am
+++ b/liboctave/Makefile.am
@@ -78,17 +78,17 @@ TEMPLATE_SRC =
 include array/module.mk
 include numeric/module.mk
 include operators/module.mk
 include system/module.mk
 include util/module.mk
 
 ## liboctave merely collects a bunch of compiled convenience libraries.
 ## It has no source code itself.
-liboctave_la_SOURCES = 
+liboctave_la_SOURCES =
 
 liboctave_la_CPPFLAGS = @OCTAVE_DLL_DEFS@ @CRUFT_DLL_DEFS@ $(AM_CPPFLAGS)
 
 include link-deps.mk
 
 # Dummy C++ source to force C++ linking.
 nodist_EXTRA_liboctave_la_SOURCES = dummy.cc
 
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -2517,17 +2517,17 @@ template <> octave_idx_type \
 Array<T>::nnz (void) const\
 { return 0; } \
 template <> Array<octave_idx_type> \
 Array<T>::find (octave_idx_type, bool) const\
 { return Array<octave_idx_type> (); } \
  \
 template <> Array<T>  \
 Array<T>::nth_element (const idx_vector&, int) const { return Array<T> (); } \
- 
+
 
 template <class T>
 Array<T>
 Array<T>::diag (octave_idx_type k) const
 {
   dim_vector dv = dims ();
   octave_idx_type nd = dv.length ();
   Array<T> d;
diff --git a/liboctave/array/module.mk b/liboctave/array/module.mk
--- a/liboctave/array/module.mk
+++ b/liboctave/array/module.mk
@@ -118,17 +118,17 @@ ARRAY_SRC = \
   array/PermMatrix.cc \
   array/Range.cc \
   array/Sparse-b.cc \
   array/Sparse-C.cc \
   array/Sparse-d.cc \
   array/uint16NDArray.cc \
   array/uint32NDArray.cc \
   array/uint64NDArray.cc \
-  array/uint8NDArray.cc 
+  array/uint8NDArray.cc
 
 TEMPLATE_SRC += \
   array/Array.cc \
   array/DiagArray2.cc \
   array/intNDArray.cc \
   array/MArray.cc \
   array/MDiagArray2.cc \
   array/MSparse.cc \
diff --git a/liboctave/cruft/daspk/datv.f b/liboctave/cruft/daspk/datv.f
--- a/liboctave/cruft/daspk/datv.f
+++ b/liboctave/cruft/daspk/datv.f
@@ -1,10 +1,10 @@
 C Work performed under the auspices of the U.S. Department of Energy
-C by Lawrence Livermore National Laboratory under contract number 
+C by Lawrence Livermore National Laboratory under contract number
 C W-7405-Eng-48.
 C
       SUBROUTINE DATV (NEQ, Y, TN, YPRIME, SAVR, V, WGHT, YPTEM, RES,
      *   IRES, PSOL, Z, VTEM, WP, IWP, CJ, EPLIN, IER, NRE, NPSL,
      *   RPAR,IPAR)
 C
 C***BEGIN PROLOGUE  DATV
 C***DATE WRITTEN   890101   (YYMMDD)
@@ -47,17 +47,17 @@ C        YPTEM = Work array of length NE
 C
 C         VTEM = Work array of length NEQ used to store the
 C                unscaled version of V.
 C
 C         WP = Real work array used by preconditioner PSOL.
 C
 C         IWP = Integer work array used by preconditioner PSOL.
 C
-C           CJ = Scalar proportional to current value of 
+C           CJ = Scalar proportional to current value of
 C                1/(step size H).
 C
 C
 C      On return
 C
 C            Z = Array of length NEQ containing desired scaled
 C                matrix-vector product.
 C
diff --git a/liboctave/cruft/daspk/dcnst0.f b/liboctave/cruft/daspk/dcnst0.f
--- a/liboctave/cruft/daspk/dcnst0.f
+++ b/liboctave/cruft/daspk/dcnst0.f
@@ -7,17 +7,17 @@ C
 C***BEGIN PROLOGUE  DCNST0
 C***DATE WRITTEN   950808   (YYMMDD)
 C***REVISION DATE  950808   (YYMMDD)
 C
 C
 C-----------------------------------------------------------------------
 C***DESCRIPTION
 C
-C This subroutine checks for constraint violations in the initial 
+C This subroutine checks for constraint violations in the initial
 C approximate solution u.
 C
 C On entry
 C
 C   NEQ    -- size of the nonlinear system, and the length of arrays
 C             Y and ICNSTR.
 C
 C   Y      -- real array containing the initial approximate root.
@@ -52,24 +52,24 @@ C---------------------------------------
             IF (Y(I) .LE. ZERO) THEN
                IRET = I
                RETURN
             ENDIF
          ELSEIF (ICNSTR(I) .EQ. 1) THEN
             IF (Y(I) .LT. ZERO) THEN
                IRET = I
                RETURN
-            ENDIF 
+            ENDIF
          ELSEIF (ICNSTR(I) .EQ. -1) THEN
             IF (Y(I) .GT. ZERO) THEN
                IRET = I
                RETURN
-            ENDIF 
+            ENDIF
          ELSEIF (ICNSTR(I) .EQ. -2) THEN
             IF (Y(I) .GE. ZERO) THEN
                IRET = I
                RETURN
-            ENDIF 
+            ENDIF
         ENDIF
  100  CONTINUE
       RETURN
 C----------------------- END OF SUBROUTINE DCNST0 ----------------------
       END
diff --git a/liboctave/cruft/daspk/dcnstr.f b/liboctave/cruft/daspk/dcnstr.f
--- a/liboctave/cruft/daspk/dcnstr.f
+++ b/liboctave/cruft/daspk/dcnstr.f
@@ -7,17 +7,17 @@ C
 C***BEGIN PROLOGUE  DCNSTR
 C***DATE WRITTEN   950808   (YYMMDD)
 C***REVISION DATE  950814   (YYMMDD)
 C
 C
 C-----------------------------------------------------------------------
 C***DESCRIPTION
 C
-C This subroutine checks for constraint violations in the proposed 
+C This subroutine checks for constraint violations in the proposed
 C new approximate solution YNEW.
 C If a constraint violation occurs, then a new step length, TAU,
 C is calculated, and this value is to be given to the linesearch routine
 C to calculate a new approximate solution YNEW.
 C
 C On entry:
 C
 C   NEQ    -- size of the nonlinear system, and the length of arrays
diff --git a/liboctave/cruft/daspk/ddasic.f b/liboctave/cruft/daspk/ddasic.f
--- a/liboctave/cruft/daspk/ddasic.f
+++ b/liboctave/cruft/daspk/ddasic.f
@@ -1,10 +1,10 @@
 C Work performed under the auspices of the U.S. Department of Energy
-C by Lawrence Livermore National Laboratory under contract number 
+C by Lawrence Livermore National Laboratory under contract number
 C W-7405-Eng-48.
 C
       SUBROUTINE DDASIC (X, Y, YPRIME, NEQ, ICOPT, ID, RES, JAC, PSOL,
      *   H, WT, NIC, IDID, RPAR, IPAR, PHI, SAVR, DELTA, E, YIC, YPIC,
      *   PWK, WM, IWM, HMIN, UROUND, EPLI, SQRTN, RSQRTN, EPCONI,
      *   STPTOL, JFLG, ICNFLG, ICNSTR, NLSIC)
 C
 C***BEGIN PROLOGUE  DDASIC
@@ -12,17 +12,17 @@ C***REFER TO  DDASPK
 C***DATE WRITTEN   940628   (YYMMDD)
 C***REVISION DATE  941206   (YYMMDD)
 C***REVISION DATE  950714   (YYMMDD)
 C
 C-----------------------------------------------------------------------
 C***DESCRIPTION
 C
 C     DDASIC is a driver routine to compute consistent initial values
-C     for Y and YPRIME.  There are two different options:  
+C     for Y and YPRIME.  There are two different options:
 C     Denoting the differential variables in Y by Y_d, and
 C     the algebraic variables by Y_a, the problem solved is either:
 C     1.  Given Y_d, calculate Y_a and Y_d', or
 C     2.  Given Y', calculate Y.
 C     In either case, initial values for the given components
 C     are input, and initial guesses for the unknown components
 C     must also be provided as input.
 C
@@ -35,29 +35,29 @@ C     Y  --        Solution vector at X.
 C     YPRIME --    Derivative of solution vector.
 C     NEQ --       Number of equations to be integrated.
 C     ICOPT     -- Flag indicating initial condition option chosen.
 C                    ICOPT = 1 for option 1 above.
 C                    ICOPT = 2 for option 2.
 C     ID        -- Array of dimension NEQ, which must be initialized
 C                  if option 1 is chosen.
 C                    ID(i) = +1 if Y_i is a differential variable,
-C                    ID(i) = -1 if Y_i is an algebraic variable. 
+C                    ID(i) = -1 if Y_i is an algebraic variable.
 C     RES --       External user-supplied subroutine to evaluate the
 C                  residual.  See RES description in DDASPK prologue.
 C     JAC --       External user-supplied routine to update Jacobian
 C                  or preconditioner information in the nonlinear solver
 C                  (optional).  See JAC description in DDASPK prologue.
 C     PSOL --      External user-supplied routine to solve
-C                  a linear system using preconditioning. 
+C                  a linear system using preconditioning.
 C                  See PSOL in DDASPK prologue.
-C     H --         Scaling factor in iteration matrix.  DDASIC may 
+C     H --         Scaling factor in iteration matrix.  DDASIC may
 C                  reduce H to achieve convergence.
 C     WT --        Vector of weights for error criterion.
-C     NIC --       Input number of initial condition calculation call 
+C     NIC --       Input number of initial condition calculation call
 C                  (= 1 or 2).
 C     IDID --      Completion code.  See IDID in DDASPK prologue.
 C     RPAR,IPAR -- Real and integer parameter arrays that
 C                  are used for communication between the
 C                  calling program and external user routines.
 C                  They are not altered by DNSK
 C     PHI --       Work space for DDASIC of length at least 2*NEQ.
 C     SAVR --      Work vector for DDASIC of length NEQ.
@@ -110,17 +110,17 @@ C
       IDID = 1
       NH = 1
       JSKIP = 0
       IF (NIC .EQ. 2) JSKIP = 1
       CALL DCOPY (NEQ, Y, 1, PHI(1,1), 1)
       CALL DCOPY (NEQ, YPRIME, 1, PHI(1,2), 1)
 C
       IF (ICOPT .EQ. 2) THEN
-        CJ = 0.0D0 
+        CJ = 0.0D0
       ELSE
         CJ = 1.0D0/H
       ENDIF
 C
 C-----------------------------------------------------------------------
 C     BLOCK 2
 C     Call the nonlinear system solver to obtain
 C     consistent initial values for Y and YPRIME.
diff --git a/liboctave/cruft/daspk/ddasid.f b/liboctave/cruft/daspk/ddasid.f
--- a/liboctave/cruft/daspk/ddasid.f
+++ b/liboctave/cruft/daspk/ddasid.f
@@ -1,10 +1,10 @@
 C Work performed under the auspices of the U.S. Department of Energy
-C by Lawrence Livermore National Laboratory under contract number 
+C by Lawrence Livermore National Laboratory under contract number
 C W-7405-Eng-48.
 C
       SUBROUTINE DDASID(X,Y,YPRIME,NEQ,ICOPT,ID,RES,JACD,PDUM,H,WT,
      *  JSDUM,RPAR,IPAR,DUMSVR,DELTA,R,YIC,YPIC,DUMPWK,WM,IWM,CJ,UROUND,
      *  DUME,DUMS,DUMR,EPCON,RATEMX,STPTOL,JFDUM,
      *  ICNFLG,ICNSTR,IERNLS)
 C
 C***BEGIN PROLOGUE  DDASID
@@ -62,17 +62,17 @@ C     EPCON     -- Tolerance to test for
 C                  iteration.
 C     RATEMX    -- Maximum convergence rate for which Newton iteration
 C                  is considered converging.
 C     JFDUM     -- Dummy argument.
 C     STPTOL    -- Tolerance used in calculating the minimum lambda
 C                  value allowed.
 C     ICNFLG    -- Integer scalar.  If nonzero, then constraint
 C                  violations in the proposed new approximate solution
-C                  will be checked for, and the maximum step length 
+C                  will be checked for, and the maximum step length
 C                  will be adjusted accordingly.
 C     ICNSTR    -- Integer array of length NEQ containing flags for
 C                  checking constraints.
 C     IERNLS    -- Error flag for nonlinear solver.
 C                   0   ==> nonlinear solver converged.
 C                   1,2 ==> recoverable error inside nonlinear solver.
 C                           1 => retry with current Y, YPRIME
 C                           2 => retry with original Y, YPRIME
diff --git a/liboctave/cruft/daspk/ddasik.f b/liboctave/cruft/daspk/ddasik.f
--- a/liboctave/cruft/daspk/ddasik.f
+++ b/liboctave/cruft/daspk/ddasik.f
@@ -1,10 +1,10 @@
 C Work perfored under the auspices of the U.S. Department of Energy
-C by Lawrence Livermore National Laboratory under contract number 
+C by Lawrence Livermore National Laboratory under contract number
 C W-7405-Eng-48.
 C
       SUBROUTINE DDASIK(X,Y,YPRIME,NEQ,ICOPT,ID,RES,JACK,PSOL,H,WT,
      *   JSKIP,RPAR,IPAR,SAVR,DELTA,R,YIC,YPIC,PWK,WM,IWM,CJ,UROUND,
      *   EPLI,SQRTN,RSQRTN,EPCON,RATEMX,STPTOL,JFLG,
      *   ICNFLG,ICNSTR,IERNLS)
 C
 C***BEGIN PROLOGUE  DDASIK
@@ -69,17 +69,17 @@ C     SQRTN     -- Square root of NEQ.
 C     RSQRTN    -- reciprical of square root of NEQ.
 C     EPCON     -- Tolerance to test for convergence of the Newton
 C                  iteration.
 C     RATEMX    -- Maximum convergence rate for which Newton iteration
 C                  is considered converging.
 C     JFLG      -- Flag showing whether a Jacobian routine is supplied.
 C     ICNFLG    -- Integer scalar.  If nonzero, then constraint
 C                  violations in the proposed new approximate solution
-C                  will be checked for, and the maximum step length 
+C                  will be checked for, and the maximum step length
 C                  will be adjusted accordingly.
 C     ICNSTR    -- Integer array of length NEQ containing flags for
 C                  checking constraints.
 C     IERNLS    -- Error flag for nonlinear solver.
 C                   0   ==> nonlinear solver converged.
 C                   1,2 ==> recoverable error inside nonlinear solver.
 C                           1 => retry with current Y, YPRIME
 C                           2 => retry with original Y, YPRIME
@@ -146,17 +146,17 @@ C
       CALL DNSIK(X,Y,YPRIME,NEQ,ICOPT,ID,RES,PSOL,WT,RPAR,IPAR,
      *   SAVR,DELTA,R,YIC,YPIC,PWK,WM,IWM,CJ,SQRTN,RSQRTN,
      *   EPLIN,EPCON,RATEMX,MXNIT,STPTOL,ICNFLG,ICNSTR,IERNEW)
 C
       IF (IERNEW .EQ. 1 .AND. NJ .LT. MXNJ .AND. JFLG .EQ. 1) THEN
 C
 C       Up to MXNIT iterations were done, the convergence rate is < 1,
 C       a Jacobian routine is supplied, and the number of JACK calls
-C       is less than MXNJ.  
+C       is less than MXNJ.
 C       Copy the residual SAVR to DELTA, call JACK, and try again.
 C
         CALL DCOPY (NEQ,  SAVR, 1, DELTA, 1)
         GO TO 300
         ENDIF
 C
       IF (IERNEW .NE. 0) GO TO 380
       RETURN
diff --git a/liboctave/cruft/daspk/ddaspk.f b/liboctave/cruft/daspk/ddaspk.f
--- a/liboctave/cruft/daspk/ddaspk.f
+++ b/liboctave/cruft/daspk/ddaspk.f
@@ -1,18 +1,18 @@
 C Work performed under the auspices of the U.S. Department of Energy
-C by Lawrence Livermore National Laboratory under contract number 
+C by Lawrence Livermore National Laboratory under contract number
 C W-7405-Eng-48.
 C
       SUBROUTINE DDASPK (RES, NEQ, T, Y, YPRIME, TOUT, INFO, RTOL, ATOL,
      *   IDID, RWORK, LRW, IWORK, LIW, RPAR, IPAR, JAC, PSOL)
 C
 C***BEGIN PROLOGUE  DDASPK
 C***DATE WRITTEN   890101   (YYMMDD)
-C***REVISION DATE  910624   
+C***REVISION DATE  910624
 C***REVISION DATE  920929   (CJ in RES call, RES counter fix.)
 C***REVISION DATE  921215   (Warnings on poor iteration performance)
 C***REVISION DATE  921216   (NRMAX as optional input)
 C***REVISION DATE  930315   (Name change: DDINI to DDINIT)
 C***REVISION DATE  940822   (Replaced initial condition calculation)
 C***REVISION DATE  941101   (Added linesearch in I.C. calculations)
 C***REVISION DATE  941220   (Misc. corrections throughout)
 C***REVISION DATE  950125   (Added DINVWT routine)
@@ -28,21 +28,21 @@ C***CATEGORY NO.  I1A2
 C***KEYWORDS  DIFFERENTIAL/ALGEBRAIC, BACKWARD DIFFERENTIATION FORMULAS,
 C             IMPLICIT DIFFERENTIAL SYSTEMS, KRYLOV ITERATION
 C***AUTHORS   Linda R. Petzold, Peter N. Brown, Alan C. Hindmarsh, and
 C                  Clement W. Ulrich
 C             Center for Computational Sciences & Engineering, L-316
 C             Lawrence Livermore National Laboratory
 C             P.O. Box 808,
 C             Livermore, CA 94551
-C***PURPOSE  This code solves a system of differential/algebraic 
-C            equations of the form 
-C               G(t,y,y') = 0 , 
-C            using a combination of Backward Differentiation Formula 
-C            (BDF) methods and a choice of two linear system solution 
+C***PURPOSE  This code solves a system of differential/algebraic
+C            equations of the form
+C               G(t,y,y') = 0 ,
+C            using a combination of Backward Differentiation Formula
+C            (BDF) methods and a choice of two linear system solution
 C            methods: direct (dense or band) or Krylov (iterative).
 C            This version is in double precision.
 C-----------------------------------------------------------------------
 C***DESCRIPTION
 C
 C *Usage:
 C
 C      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
@@ -61,17 +61,17 @@ C
 C *Arguments:
 C
 C  RES:EXT          This is the name of a subroutine which you
 C                   provide to define the residual function G(t,y,y')
 C                   of the differential/algebraic system.
 C
 C  NEQ:IN           This is the number of equations in the system.
 C
-C  T:INOUT          This is the current value of the independent 
+C  T:INOUT          This is the current value of the independent
 C                   variable.
 C
 C  Y(*):INOUT       This array contains the solution components at T.
 C
 C  YPRIME(*):INOUT  This array contains the derivatives of the solution
 C                   components at T.
 C
 C  TOUT:IN          This is a point at which a solution is desired.
@@ -102,59 +102,59 @@ C                   the code with needed
 C
 C  LIW:IN           The length of IWORK.
 C
 C  RPAR,IPAR:IN     These are real and integer parameter arrays which
 C                   you can use for communication between your calling
 C                   program and the RES, JAC, and PSOL subroutines.
 C
 C  JAC:EXT          This is the name of a subroutine which you may
-C                   provide (optionally) for calculating Jacobian 
+C                   provide (optionally) for calculating Jacobian
 C                   (partial derivative) data involved in solving linear
 C                   systems within DDASPK.
 C
 C  PSOL:EXT         This is the name of a subroutine which you must
 C                   provide for solving linear systems if you selected
 C                   a Krylov method.  The purpose of PSOL is to solve
 C                   linear systems involving a left preconditioner P.
 C
 C *Overview
 C
 C  The DDASPK solver uses the backward differentiation formulas of
 C  orders one through five to solve a system of the form G(t,y,y') = 0
-C  for y = Y and y' = YPRIME.  Values for Y and YPRIME at the initial 
-C  time must be given as input.  These values should be consistent, 
-C  that is, if T, Y, YPRIME are the given initial values, they should 
+C  for y = Y and y' = YPRIME.  Values for Y and YPRIME at the initial
+C  time must be given as input.  These values should be consistent,
+C  that is, if T, Y, YPRIME are the given initial values, they should
 C  satisfy G(T,Y,YPRIME) = 0.  However, if consistent values are not
 C  known, in many cases you can have DDASPK solve for them -- see INFO(11).
 C  (This and other options are described in more detail below.)
 C
 C  Normally, DDASPK solves the system from T to TOUT.  It is easy to
 C  continue the solution to get results at additional TOUT.  This is
 C  the interval mode of operation.  Intermediate results can also be
 C  obtained easily by specifying INFO(3).
 C
-C  On each step taken by DDASPK, a sequence of nonlinear algebraic  
+C  On each step taken by DDASPK, a sequence of nonlinear algebraic
 C  systems arises.  These are solved by one of two types of
 C  methods:
 C    * a Newton iteration with a direct method for the linear
 C      systems involved (INFO(12) = 0), or
-C    * a Newton iteration with a preconditioned Krylov iterative 
+C    * a Newton iteration with a preconditioned Krylov iterative
 C      method for the linear systems involved (INFO(12) = 1).
 C
-C  The direct method choices are dense and band matrix solvers, 
-C  with either a user-supplied or an internal difference quotient 
+C  The direct method choices are dense and band matrix solvers,
+C  with either a user-supplied or an internal difference quotient
 C  Jacobian matrix, as specified by INFO(5) and INFO(6).
 C  In the band case, INFO(6) = 1, you must supply half-bandwidths
 C  in IWORK(1) and IWORK(2).
 C
-C  The Krylov method is the Generalized Minimum Residual (GMRES) 
-C  method, in either complete or incomplete form, and with 
+C  The Krylov method is the Generalized Minimum Residual (GMRES)
+C  method, in either complete or incomplete form, and with
 C  scaling and preconditioning.  The method is implemented
-C  in an algorithm called SPIGMR.  Certain options in the Krylov 
+C  in an algorithm called SPIGMR.  Certain options in the Krylov
 C  method case are specified by INFO(13) and INFO(15).
 C
 C  If the Krylov method is chosen, you may supply a pair of routines,
 C  JAC and PSOL, to apply preconditioning to the linear system.
 C  If the system is A*x = b, the matrix is A = dG/dY + CJ*dG/dYPRIME
 C  (of order NEQ).  This system can then be preconditioned in the form
 C  (P-inverse)*A*x = (P-inverse)*b, with left preconditioner P.
 C  (DDASPK does not allow right preconditioning.)
@@ -227,17 +227,17 @@ C       a variable.)
 C
 C  Y(*) -- Set this array to the initial values of the NEQ solution
 C          components at the initial point.  You must dimension Y of
 C          length at least NEQ in your calling program.
 C
 C  YPRIME(*) -- Set this array to the initial values of the NEQ first
 C               derivatives of the solution components at the initial
 C               point.  You must dimension YPRIME at least NEQ in your
-C               calling program. 
+C               calling program.
 C
 C  TOUT - Set it to the first point at which a solution is desired.
 C         You cannot take TOUT = T.  Integration either forward in T
 C         (TOUT .GT. T) or backward in T (TOUT .LT. T) is permitted.
 C
 C         The code advances the solution from T to TOUT using step
 C         sizes which are automatically selected so as to achieve the
 C         desired accuracy.  If you wish, the code will return with the
@@ -258,23 +258,23 @@ C         For some problems it may not b
 C         past a point TSTOP, because a discontinuity occurs there
 C         or the solution or its derivative is not defined beyond
 C         TSTOP.  When you have declared a TSTOP point (see INFO(4)
 C         and RWORK(1)), you have told the code not to integrate past
 C         TSTOP.  In this case any tout beyond TSTOP is invalid input.
 C
 C  INFO(*) - Use the INFO array to give the code more details about
 C            how you want your problem solved.  This array should be
-C            dimensioned of length 20, though DDASPK uses only the 
+C            dimensioned of length 20, though DDASPK uses only the
 C            first 15 entries.  You must respond to all of the following
 C            items, which are arranged as questions.  The simplest use
 C            of DDASPK corresponds to setting all entries of INFO to 0.
 C
 C       INFO(1) - This parameter enables the code to initialize itself.
-C              You must set it to indicate the start of every new 
+C              You must set it to indicate the start of every new
 C              problem.
 C
 C          **** Is this the first call for this problem ...
 C                yes - set INFO(1) = 0
 C                 no - not applicable here.
 C                      See below for continuation calls.  ****
 C
 C       INFO(2) - How much accuracy you want of your solution
@@ -341,18 +341,18 @@ C                       matrix of partia
 C
 C       INFO(6) - used only when INFO(12) = 0 (direct methods).
 C              DDASPK will perform much better if the matrix of
 C              partial derivatives, dG/dY + CJ*dG/dYPRIME (here CJ is
 C              a scalar determined by DDASPK), is banded and the code
 C              is told this.  In this case, the storage needed will be
 C              greatly reduced, numerical differencing will be performed
 C              much cheaper, and a number of important algorithms will
-C              execute much faster.  The differential equation is said 
-C              to have half-bandwidths ML (lower) and MU (upper) if 
+C              execute much faster.  The differential equation is said
+C              to have half-bandwidths ML (lower) and MU (upper) if
 C              equation i involves only unknowns Y(j) with
 C                             i-ML .le. j .le. i+MU .
 C              For all i=1,2,...,NEQ.  Thus, ML and MU are the widths
 C              of the lower and upper parts of the band, respectively,
 C              with the main diagonal being excluded.  If you do not
 C              indicate that the equation has a banded matrix of partial
 C              derivatives the code works with a full matrix of NEQ**2
 C              elements (stored in the conventional way).  Computations
@@ -381,32 +381,32 @@ C          ****  Do you want the code to
 C                stepsize ...
 C                 yes - set INFO(7) = 0
 C                  no - set INFO(7) = 1
 C                       and define HMAX by setting
 C                       RWORK(2) = HMAX ****
 C
 C       INFO(8) -  Differential/algebraic problems may occasionally
 C              suffer from severe scaling difficulties on the first
-C              step.  If you know a great deal about the scaling of 
-C              your problem, you can help to alleviate this problem 
+C              step.  If you know a great deal about the scaling of
+C              your problem, you can help to alleviate this problem
 C              by specifying an initial stepsize H0.
 C
 C          ****  Do you want the code to define its own initial
 C                stepsize ...
 C                 yes - set INFO(8) = 0
 C                  no - set INFO(8) = 1
 C                       and define H0 by setting
 C                       RWORK(3) = H0 ****
 C
 C       INFO(9) -  If storage is a severe problem, you can save some
 C              storage by restricting the maximum method order MAXORD.
 C              The default value is 5.  For each order decrease below 5,
-C              the code requires NEQ fewer locations, but it is likely 
-C              to be slower.  In any case, you must have 
+C              the code requires NEQ fewer locations, but it is likely
+C              to be slower.  In any case, you must have
 C              1 .le. MAXORD .le. 5.
 C          ****  Do you want the maximum order to default to 5 ...
 C                 yes - set INFO(9) = 0
 C                  no - set INFO(9) = 1
 C                       and define MAXORD by setting
 C                       IWORK(3) = MAXORD ****
 C
 C       INFO(10) - If you know that certain components of the
@@ -421,17 +421,17 @@ C              3.  To enforce both optio
 C
 C              When selecting option 2 or 3, it is probably best to try the
 C              code without using this option first, and only use
 C              this option if that does not work very well.
 C
 C          ****  Do you want the code to solve the problem without
 C                invoking any special inequality constraints ...
 C                 yes - set INFO(10) = 0
-C                  no - set INFO(10) = 1 to have option 1 enforced 
+C                  no - set INFO(10) = 1 to have option 1 enforced
 C                  no - set INFO(10) = 2 to have option 2 enforced
 C                  no - set INFO(10) = 3 to have option 3 enforced ****
 C
 C                  If you have specified INFO(10) = 1 or 3, then you
 C                  will also need to identify how each component of Y
 C                  in the initial condition calculation is constrained.
 C                  You must set:
 C                  IWORK(40+I) = +1 if Y(I) must be .GE. 0,
@@ -469,65 +469,65 @@ C                  whose derivatives do 
 C                  in the function G(T,Y,YPRIME)).  You must set:
 C                  IWORK(LID+I) = +1 if Y(I) is a differential variable
 C                  IWORK(LID+I) = -1 if Y(I) is an algebraic variable,
 C                  where LID = 40 if INFO(10) = 0 or 2 and LID = 40+NEQ
 C                  if INFO(10) = 1 or 3.
 C
 C       INFO(12) - Except for the addition of the RES argument CJ,
 C              DDASPK by default is downward-compatible with DDASSL,
-C              which uses only direct (dense or band) methods to solve 
+C              which uses only direct (dense or band) methods to solve
 C              the linear systems involved.  You must set INFO(12) to
 C              indicate whether you want the direct methods or the
 C              Krylov iterative method.
 C          ****   Do you want DDASPK to use standard direct methods
 C                 (dense or band) or the Krylov (iterative) method ...
 C                   direct methods - set INFO(12) = 0.
 C                   Krylov method  - set INFO(12) = 1,
 C                       and check the settings of INFO(13) and INFO(15).
 C
-C       INFO(13) - used when INFO(12) = 1 (Krylov methods).  
+C       INFO(13) - used when INFO(12) = 1 (Krylov methods).
 C              DDASPK uses scalars MAXL, KMP, NRMAX, and EPLI for the
-C              iterative solution of linear systems.  INFO(13) allows 
-C              you to override the default values of these parameters.  
+C              iterative solution of linear systems.  INFO(13) allows
+C              you to override the default values of these parameters.
 C              These parameters and their defaults are as follows:
-C              MAXL = maximum number of iterations in the SPIGMR 
-C                 algorithm (MAXL .le. NEQ).  The default is 
+C              MAXL = maximum number of iterations in the SPIGMR
+C                 algorithm (MAXL .le. NEQ).  The default is
 C                 MAXL = MIN(5,NEQ).
-C              KMP = number of vectors on which orthogonalization is 
-C                 done in the SPIGMR algorithm.  The default is 
-C                 KMP = MAXL, which corresponds to complete GMRES 
-C                 iteration, as opposed to the incomplete form.  
-C              NRMAX = maximum number of restarts of the SPIGMR 
+C              KMP = number of vectors on which orthogonalization is
+C                 done in the SPIGMR algorithm.  The default is
+C                 KMP = MAXL, which corresponds to complete GMRES
+C                 iteration, as opposed to the incomplete form.
+C              NRMAX = maximum number of restarts of the SPIGMR
 C                 algorithm per nonlinear iteration.  The default is
 C                 NRMAX = 5.
 C              EPLI = convergence test constant in SPIGMR algorithm.
 C                 The default is EPLI = 0.05.
-C              Note that the length of RWORK depends on both MAXL 
+C              Note that the length of RWORK depends on both MAXL
 C              and KMP.  See the definition of LRW below.
 C          ****   Are MAXL, KMP, and EPLI to be given their
 C                 default values ...
 C                  yes - set INFO(13) = 0
 C                   no - set INFO(13) = 1,
 C                        and set all of the following:
 C                        IWORK(24) = MAXL (1 .le. MAXL .le. NEQ)
 C                        IWORK(25) = KMP  (1 .le. KMP .le. MAXL)
 C                        IWORK(26) = NRMAX  (NRMAX .ge. 0)
 C                        RWORK(10) = EPLI (0 .lt. EPLI .lt. 1.0) ****
 C
-C        INFO(14) - used with INFO(11) > 0 (initial condition 
+C        INFO(14) - used with INFO(11) > 0 (initial condition
 C               calculation is requested).  In this case, you may
 C               request control to be returned to the calling program
 C               immediately after the initial condition calculation,
 C               before proceeding to the integration of the system
 C               (e.g. to examine the computed Y and YPRIME).
 C               If this is done, and if the initialization succeeded
 C               (IDID = 4), you should reset INFO(11) to 0 for the
-C               next call, to prevent the solver from repeating the 
-C               initialization (and to avoid an infinite loop). 
+C               next call, to prevent the solver from repeating the
+C               initialization (and to avoid an infinite loop).
 C          ****   Do you want to proceed to the integration after
 C                 the initial condition calculation is done ...
 C                 yes - set INFO(14) = 0
 C                  no - set INFO(14) = 1                        ****
 C
 C        INFO(15) - used when INFO(12) = 1 (Krylov methods).
 C               When using preconditioning in the Krylov method,
 C               you must supply a subroutine, PSOL, which solves the
@@ -546,35 +546,35 @@ C               (described under JAC and
 C               communicate data between JAC and PSOL.
 C          ****   Does PSOL operate with no prior preparation ...
 C                 yes - set INFO(15) = 0 (no JAC routine)
 C                  no - set INFO(15) = 1
 C                       and supply a JAC routine to evaluate and
 C                       preprocess any required Jacobian data.  ****
 C
 C         INFO(16) - option to exclude algebraic variables from
-C               the error test.  
+C               the error test.
 C          ****   Do you wish to control errors locally on
 C                 all the variables...
 C                 yes - set INFO(16) = 0
 C                  no - set INFO(16) = 1
 C                       If you have specified INFO(16) = 1, then you
 C                       will also need to identify  which are the
 C                       differential and which are the algebraic
 C                       components (algebraic components are components
 C                       whose derivatives do not appear explicitly
 C                       in the function G(T,Y,YPRIME)).  You must set:
-C                       IWORK(LID+I) = +1 if Y(I) is a differential 
+C                       IWORK(LID+I) = +1 if Y(I) is a differential
 C                                      variable, and
 C                       IWORK(LID+I) = -1 if Y(I) is an algebraic
 C                                      variable,
-C                       where LID = 40 if INFO(10) = 0 or 2 and 
+C                       where LID = 40 if INFO(10) = 0 or 2 and
 C                       LID = 40 + NEQ if INFO(10) = 1 or 3.
 C
-C       INFO(17) - used when INFO(11) > 0 (DDASPK is to do an 
+C       INFO(17) - used when INFO(11) > 0 (DDASPK is to do an
 C              initial condition calculation).
 C              DDASPK uses several heuristic control quantities in the
 C              initial condition calculation.  They have default values,
 C              but can  also be set by the user using INFO(17).
 C              These parameters and their defaults are as follows:
 C              MXNIT  = maximum number of Newton iterations
 C                 per Jacobian or preconditioner evaluation.
 C                 The default is:
@@ -599,29 +599,29 @@ C              EPINIT = swing factor in 
 C                 test.  The test is applied to the residual vector,
 C                 premultiplied by the approximate Jacobian (in the
 C                 direct case) or the preconditioner (in the Krylov
 C                 case).  For convergence, the weighted RMS norm of
 C                 this vector (scaled by the error weights) must be
 C                 less than EPINIT*EPCON, where EPCON = .33 is the
 C                 analogous test constant used in the time steps.
 C                 The default is EPINIT = .01.
-C          ****   Are the initial condition heuristic controls to be 
+C          ****   Are the initial condition heuristic controls to be
 C                 given their default values...
 C                  yes - set INFO(17) = 0
 C                   no - set INFO(17) = 1,
 C                        and set all of the following:
 C                        IWORK(32) = MXNIT (.GT. 0)
 C                        IWORK(33) = MXNJ (.GT. 0)
 C                        IWORK(34) = MXNH (.GT. 0)
 C                        IWORK(35) = LSOFF ( = 0 or 1)
 C                        RWORK(14) = STPTOL (.GT. 0.0)
 C                        RWORK(15) = EPINIT (.GT. 0.0)  ****
 C
-C         INFO(18) - option to get extra printing in initial condition 
+C         INFO(18) - option to get extra printing in initial condition
 C                calculation.
 C          ****   Do you wish to have extra printing...
 C                 no  - set INFO(18) = 0
 C                 yes - set INFO(18) = 1 for minimal printing, or
 C                       set INFO(18) = 2 for full printing.
 C                       If you have specified INFO(18) .ge. 1, data
 C                       will be printed with the error handler routines.
 C                       To print to a non-default unit number L, include
@@ -634,34 +634,34 @@ C               as variables because the
 C               you have two choices --
 C                     Both RTOL and ATOL are scalars (INFO(2) = 0), or
 C                     both RTOL and ATOL are vectors (INFO(2) = 1).
 C               In either case all components must be non-negative.
 C
 C               The tolerances are used by the code in a local error
 C               test at each step which requires roughly that
 C                        abs(local error in Y(i)) .le. EWT(i) ,
-C               where EWT(i) = RTOL*abs(Y(i)) + ATOL is an error weight 
+C               where EWT(i) = RTOL*abs(Y(i)) + ATOL is an error weight
 C               quantity, for each vector component.
 C               (More specifically, a root-mean-square norm is used to
 C               measure the size of vectors, and the error test uses the
 C               magnitude of the solution at the beginning of the step.)
 C
 C               The true (global) error is the difference between the
 C               true solution of the initial value problem and the
 C               computed approximation.  Practically all present day
 C               codes, including this one, control the local error at
 C               each step and do not even attempt to control the global
 C               error directly.
 C
 C               Usually, but not always, the true accuracy of
 C               the computed Y is comparable to the error tolerances.
 C               This code will usually, but not always, deliver a more
 C               accurate solution if you reduce the tolerances and
-C               integrate again.  By comparing two such solutions you 
+C               integrate again.  By comparing two such solutions you
 C               can get a fairly reliable idea of the true error in the
 C               solution at the larger tolerances.
 C
 C               Setting ATOL = 0. results in a pure relative error test
 C               on that component.  Setting RTOL = 0. results in a pure
 C               absolute error test on that component.  A mixed test
 C               with non-zero RTOL and ATOL corresponds roughly to a
 C               relative error test when the solution component is
@@ -695,17 +695,17 @@ C                 if INFO(6) = 1 (banded
 C                    if INFO(5) = 0, add (2*ML+MU+1)*NEQ + 2*(NEQ/(ML+MU+1)+1),
 C                    if INFO(5) = 1, add (2*ML+MU+1)*NEQ,
 C                 if INFO(16) = 1, add NEQ.
 C
 C              If INFO(12) = 1 (Krylov method), the base value is
 C              base = 50 + (MAXORD+5)*NEQ + (MAXL+3+MIN0(1,MAXL-KMP))*NEQ +
 C                      + (MAXL+3)*MAXL + 1 + LENWP.
 C              See PSOL for description of LENWP.  The default values are:
-C              MAXORD = 5 (see INFO(9)), MAXL = min(5,NEQ) and KMP = MAXL 
+C              MAXORD = 5 (see INFO(9)), MAXL = min(5,NEQ) and KMP = MAXL
 C              (see INFO(13)).
 C              With the default values for MAXORD, MAXL and KMP,
 C              base = 91 + 18*NEQ + LENWP.
 C              Additional storage must be added to the base value for
 C              any or all of the following options:
 C                if INFO(16) = 1, add NEQ.
 C
 C
@@ -740,50 +740,50 @@ C             parameters by treating the
 C             If you do choose to use them, dimension them in
 C             your calling program and in RES (and in JAC and PSOL)
 C             as arrays of appropriate length.
 C
 C  JAC -- This is the name of a routine that you may supply
 C         (optionally) that relates to the Jacobian matrix of the
 C         nonlinear system that the code must solve at each T step.
 C         The role of JAC (and its call sequence) depends on whether
-C         a direct (INFO(12) = 0) or Krylov (INFO(12) = 1) method 
+C         a direct (INFO(12) = 0) or Krylov (INFO(12) = 1) method
 C         is selected.
 C
 C         **** INFO(12) = 0 (direct methods):
 C           If you are letting the code generate partial derivatives
 C           numerically (INFO(5) = 0), then JAC can be absent
 C           (or perhaps a dummy routine to satisfy the loader).
 C           Otherwise you must supply a JAC routine to compute
 C           the matrix A = dG/dY + CJ*dG/dYPRIME.  It must have
 C           the form
 C
 C           SUBROUTINE JAC (T, Y, YPRIME, PD, CJ, RPAR, IPAR)
 C
 C           The JAC routine must dimension Y, YPRIME, and PD (and RPAR
 C           and IPAR if used).  CJ is a scalar which is input to JAC.
 C           For the given values of T, Y, and YPRIME, the JAC routine
-C           must evaluate the nonzero elements of the matrix A, and 
-C           store these values in the array PD.  The elements of PD are 
+C           must evaluate the nonzero elements of the matrix A, and
+C           store these values in the array PD.  The elements of PD are
 C           set to zero before each call to JAC, so that only nonzero
 C           elements need to be defined.
 C           The way you store the elements into the PD array depends
 C           on the structure of the matrix indicated by INFO(6).
 C           *** INFO(6) = 0 (full or dense matrix) ***
 C               Give PD a first dimension of NEQ.  When you evaluate the
 C               nonzero partial derivatives of equation i (i.e. of G(i))
 C               with respect to component j (of Y and YPRIME), you must
 C               store the element in PD according to
 C                  PD(i,j) = dG(i)/dY(j) + CJ*dG(i)/dYPRIME(j).
 C           *** INFO(6) = 1 (banded matrix with half-bandwidths ML, MU
 C                            as described under INFO(6)) ***
-C               Give PD a first dimension of 2*ML+MU+1.  When you 
-C               evaluate the nonzero partial derivatives of equation i 
-C               (i.e. of G(i)) with respect to component j (of Y and 
-C               YPRIME), you must store the element in PD according to 
+C               Give PD a first dimension of 2*ML+MU+1.  When you
+C               evaluate the nonzero partial derivatives of equation i
+C               (i.e. of G(i)) with respect to component j (of Y and
+C               YPRIME), you must store the element in PD according to
 C                  IROW = i - j + ML + MU + 1
 C                  PD(IROW,j) = dG(i)/dY(j) + CJ*dG(i)/dYPRIME(j).
 C
 C          **** INFO(12) = 1 (Krylov method):
 C            If you are not calculating Jacobian data in advance for use
 C            in PSOL (INFO(15) = 0), JAC can be absent (or perhaps a
 C            dummy routine to satisfy the loader).  Otherwise, you may
 C            supply a JAC routine to compute and preprocess any parts of
@@ -792,40 +792,40 @@ C            involved in the preconditio
 C            It is to have the form
 C
 C            SUBROUTINE JAC (RES, IRES, NEQ, T, Y, YPRIME, REWT, SAVR,
 C                            WK, H, CJ, WP, IWP, IER, RPAR, IPAR)
 C
 C           The JAC routine must dimension Y, YPRIME, REWT, SAVR, WK,
 C           and (if used) WP, IWP, RPAR, and IPAR.
 C           The Y, YPRIME, and SAVR arrays contain the current values
-C           of Y, YPRIME, and the residual G, respectively.  
-C           The array WK is work space of length NEQ.  
+C           of Y, YPRIME, and the residual G, respectively.
+C           The array WK is work space of length NEQ.
 C           H is the step size.  CJ is a scalar, input to JAC, that is
-C           normally proportional to 1/H.  REWT is an array of 
+C           normally proportional to 1/H.  REWT is an array of
 C           reciprocal error weights, 1/EWT(i), where EWT(i) is
 C           RTOL*abs(Y(i)) + ATOL (unless you supplied routine DDAWTS
 C           instead), for use in JAC if needed.  For example, if JAC
 C           computes difference quotient approximations to partial
 C           derivatives, the REWT array may be useful in setting the
 C           increments used.  The JAC routine should do any
 C           factorization operations called for, in preparation for
 C           solving linear systems in PSOL.  The matrix P should
 C           be an approximation to the Jacobian,
 C           A = dG/dY + CJ*dG/dYPRIME.
 C
 C           WP and IWP are real and integer work arrays which you may
 C           use for communication between your JAC routine and your
-C           PSOL routine.  These may be used to store elements of the 
+C           PSOL routine.  These may be used to store elements of the
 C           preconditioner P, or related matrix data (such as factored
 C           forms).  They are not altered by DDASPK.
 C           If you do not need WP or IWP, ignore these parameters by
 C           treating them as dummy arguments.  If you do use them,
 C           dimension them appropriately in your JAC and PSOL routines.
-C           See the PSOL description for instructions on setting 
+C           See the PSOL description for instructions on setting
 C           the lengths of WP and IWP.
 C
 C           On return, JAC should set the error flag IER as follows..
 C             IER = 0    if JAC was successful,
 C             IER .ne. 0 if JAC was unsuccessful (e.g. if Y or YPRIME
 C                        was illegal, or a singular matrix is found).
 C           (If IER .ne. 0, a smaller stepsize will be tried.)
 C           IER = 0 on entry to JAC, so need be reset only on a failure.
@@ -834,33 +834,33 @@ C           override any nonzero value o
 C
 C         Regardless of the method type, subroutine JAC must not
 C         alter T, Y(*), YPRIME(*), H, CJ, or REWT(*).
 C         You must declare the name JAC in an EXTERNAL statement in
 C         your program that calls DDASPK.
 C
 C PSOL --  This is the name of a routine you must supply if you have
 C         selected a Krylov method (INFO(12) = 1) with preconditioning.
-C         In the direct case (INFO(12) = 0), PSOL can be absent 
-C         (a dummy routine may have to be supplied to satisfy the 
-C         loader).  Otherwise, you must provide a PSOL routine to 
+C         In the direct case (INFO(12) = 0), PSOL can be absent
+C         (a dummy routine may have to be supplied to satisfy the
+C         loader).  Otherwise, you must provide a PSOL routine to
 C         solve linear systems arising from preconditioning.
-C         When supplied with INFO(12) = 1, the PSOL routine is to 
+C         When supplied with INFO(12) = 1, the PSOL routine is to
 C         have the form
 C
 C         SUBROUTINE PSOL (NEQ, T, Y, YPRIME, SAVR, WK, CJ, WGHT,
 C                          WP, IWP, B, EPLIN, IER, RPAR, IPAR)
 C
-C         The PSOL routine must solve linear systems of the form 
+C         The PSOL routine must solve linear systems of the form
 C         P*x = b where P is the left preconditioner matrix.
 C
 C         The right-hand side vector b is in the B array on input, and
 C         PSOL must return the solution vector x in B.
 C         The Y, YPRIME, and SAVR arrays contain the current values
-C         of Y, YPRIME, and the residual G, respectively.  
+C         of Y, YPRIME, and the residual G, respectively.
 C
 C         Work space required by JAC and/or PSOL, and space for data to
 C         be communicated from JAC to PSOL is made available in the form
 C         of arrays WP and IWP, which are parts of the RWORK and IWORK
 C         arrays, respectively.  The lengths of these real and integer
 C         work spaces WP and IWP must be supplied in LENWP and LENIWP,
 C         respectively, as follows..
 C           IWORK(27) = LENWP = length of real work space WP
@@ -895,37 +895,37 @@ C                 the step will be retri
 C           IER = 0 on entry to PSOL so need be reset only on a failure.
 C
 C         You must declare the name PSOL in an EXTERNAL statement in
 C         your program that calls DDASPK.
 C
 C
 C  OPTIONALLY REPLACEABLE SUBROUTINE:
 C
-C  DDASPK uses a weighted root-mean-square norm to measure the 
+C  DDASPK uses a weighted root-mean-square norm to measure the
 C  size of various error vectors.  The weights used in this norm
 C  are set in the following subroutine:
 C
 C    SUBROUTINE DDAWTS (NEQ, IWT, RTOL, ATOL, Y, EWT, RPAR, IPAR)
 C    DIMENSION RTOL(*), ATOL(*), Y(*), EWT(*), RPAR(*), IPAR(*)
 C
 C  A DDAWTS routine has been included with DDASPK which sets the
 C  weights according to
 C    EWT(I) = RTOL*ABS(Y(I)) + ATOL
 C  in the case of scalar tolerances (IWT = 0) or
 C    EWT(I) = RTOL(I)*ABS(Y(I)) + ATOL(I)
 C  in the case of array tolerances (IWT = 1).  (IWT is INFO(2).)
 C  In some special cases, it may be appropriate for you to define
-C  your own error weights by writing a subroutine DDAWTS to be 
-C  called instead of the version supplied.  However, this should 
-C  be attempted only after careful thought and consideration. 
-C  If you supply this routine, you may use the tolerances and Y 
+C  your own error weights by writing a subroutine DDAWTS to be
+C  called instead of the version supplied.  However, this should
+C  be attempted only after careful thought and consideration.
+C  If you supply this routine, you may use the tolerances and Y
 C  as appropriate, but do not overwrite these variables.  You
 C  may also use RPAR and IPAR to communicate data as appropriate.
-C  ***Note: Aside from the values of the weights, the choice of 
+C  ***Note: Aside from the values of the weights, the choice of
 C  norm used in DDASPK (weighted root-mean-square) is not subject
 C  to replacement by the user.  In this respect, DDASPK is not
 C  downward-compatible with the original DDASSL solver (in which
 C  the norm routine was optionally user-replaceable).
 C
 C
 C------OUTPUT - AFTER ANY RETURN FROM DDASPK----------------------------
 C
@@ -986,33 +986,33 @@ C                     last attempted ste
 C
 C           IDID = -7 -- the nonlinear system solver in the time integration
 C                     could not converge.
 C
 C           IDID = -8 -- the matrix of partial derivatives appears
 C                     to be singular (direct method).
 C
 C           IDID = -9 -- the nonlinear system solver in the time integration
-C                     failed to achieve convergence, and there were repeated 
+C                     failed to achieve convergence, and there were repeated
 C                     error test failures in this step.
 C
-C           IDID =-10 -- the nonlinear system solver in the time integration 
-C                     failed to achieve convergence because IRES was equal 
+C           IDID =-10 -- the nonlinear system solver in the time integration
+C                     failed to achieve convergence because IRES was equal
 C                     to -1.
 C
 C           IDID =-11 -- IRES = -2 was encountered and control is
 C                     being returned to the calling program.
 C
 C           IDID =-12 -- DDASPK failed to compute the initial Y, YPRIME.
 C
 C           IDID =-13 -- unrecoverable error encountered inside user's
 C                     PSOL routine, and control is being returned to
 C                     the calling program.
 C
-C           IDID =-14 -- the Krylov linear system solver could not 
+C           IDID =-14 -- the Krylov linear system solver could not
 C                     achieve convergence.
 C
 C           IDID =-15,..,-32 -- Not applicable for this code.
 C
 C                    *** TASK TERMINATED ***
 C                reported by the value of IDID=-33
 C
 C           IDID = -33 -- the code has encountered trouble from which
@@ -1024,45 +1024,45 @@ C
 C   RTOL, ATOL -- these quantities remain unchanged except when
 C               IDID = -2.  In this case, the error tolerances have been
 C               increased by the code to values which are estimated to
 C               be appropriate for continuing the integration.  However,
 C               the reported solution at T was obtained using the input
 C               values of RTOL and ATOL.
 C
 C   RWORK, IWORK -- contain information which is usually of no interest
-C               to the user but necessary for subsequent calls. 
+C               to the user but necessary for subsequent calls.
 C               However, you may be interested in the performance data
-C               listed below.  These quantities are accessed in RWORK 
+C               listed below.  These quantities are accessed in RWORK
 C               and IWORK but have internal mnemonic names, as follows..
 C
 C               RWORK(3)--contains H, the step size h to be attempted
 C                        on the next step.
 C
 C               RWORK(4)--contains TN, the current value of the
 C                        independent variable, i.e. the farthest point
-C                        integration has reached.  This will differ 
-C                        from T if interpolation has been performed 
+C                        integration has reached.  This will differ
+C                        from T if interpolation has been performed
 C                        (IDID = 3).
 C
 C               RWORK(7)--contains HOLD, the stepsize used on the last
 C                        successful step.  If INFO(11) = INFO(14) = 1,
 C                        this contains the value of H used in the
 C                        initial condition calculation.
 C
-C               IWORK(7)--contains K, the order of the method to be 
+C               IWORK(7)--contains K, the order of the method to be
 C                        attempted on the next step.
 C
 C               IWORK(8)--contains KOLD, the order of the method used
 C                        on the last step.
 C
-C               IWORK(11)--contains NST, the number of steps (in T) 
+C               IWORK(11)--contains NST, the number of steps (in T)
 C                        taken so far.
 C
-C               IWORK(12)--contains NRE, the number of calls to RES 
+C               IWORK(12)--contains NRE, the number of calls to RES
 C                        so far.
 C
 C               IWORK(13)--contains NJE, the number of calls to JAC so
 C                        far (Jacobian or preconditioner evaluations).
 C
 C               IWORK(14)--contains NETF, the total number of error test
 C                        failures so far.
 C
@@ -1070,37 +1070,37 @@ C               IWORK(15)--contains NCFN
 C                        convergence failures so far (includes counts
 C                        of singular iteration matrix or singular
 C                        preconditioners).
 C
 C               IWORK(16)--contains NCFL, the number of convergence
 C                        failures of the linear iteration so far.
 C
 C               IWORK(17)--contains LENIW, the length of IWORK actually
-C                        required.  This is defined on normal returns 
+C                        required.  This is defined on normal returns
 C                        and on an illegal input return for
 C                        insufficient storage.
 C
 C               IWORK(18)--contains LENRW, the length of RWORK actually
-C                        required.  This is defined on normal returns 
+C                        required.  This is defined on normal returns
 C                        and on an illegal input return for
 C                        insufficient storage.
 C
 C               IWORK(19)--contains NNI, the total number of nonlinear
 C                        iterations so far (each of which calls a
 C                        linear solver).
 C
 C               IWORK(20)--contains NLI, the total number of linear
 C                        (Krylov) iterations so far.
 C
 C               IWORK(21)--contains NPS, the number of PSOL calls so
 C                        far, for preconditioning solve operations or
 C                        for solutions with the user-supplied method.
 C
-C               Note: The various counters in IWORK do not include 
+C               Note: The various counters in IWORK do not include
 C               counts during a call made with INFO(11) > 0 and
 C               INFO(14) = 1.
 C
 C
 C------INPUT - WHAT TO DO TO CONTINUE THE INTEGRATION  -----------------
 C              (CALLS AFTER THE FIRST)
 C
 C     This code is organized so that subsequent calls to continue the
@@ -1108,19 +1108,19 @@ C     integration involve little (if any
 C     part.  You must monitor the IDID parameter in order to determine
 C     what to do next.
 C
 C     Recalling that the principal task of the code is to integrate
 C     from T to TOUT (the interval mode), usually all you will need
 C     to do is specify a new TOUT upon reaching the current TOUT.
 C
 C     Do not alter any quantity not specifically permitted below.  In
-C     particular do not alter NEQ, T, Y(*), YPRIME(*), RWORK(*), 
-C     IWORK(*), or the differential equation in subroutine RES.  Any 
-C     such alteration constitutes a new problem and must be treated 
+C     particular do not alter NEQ, T, Y(*), YPRIME(*), RWORK(*),
+C     IWORK(*), or the differential equation in subroutine RES.  Any
+C     such alteration constitutes a new problem and must be treated
 C     as such, i.e. you must start afresh.
 C
 C     You cannot change from array to scalar error control or vice
 C     versa (INFO(2)), but you can change the size of the entries of
 C     RTOL or ATOL.  Increasing a tolerance makes the equation easier
 C     to integrate.  Decreasing a tolerance will make the equation
 C     harder to integrate and should generally be avoided.
 C
@@ -1146,17 +1146,17 @@ C                  another step in the d
 C
 C     IDID = 2 or 3, define a new TOUT and call the code again.
 C                  TOUT must be different from T.  You cannot change
 C                  the direction of integration without restarting.
 C
 C     IDID = 4, reset INFO(11) = 0 and call the code again to begin
 C                  the integration.  (If you leave INFO(11) > 0 and
 C                  INFO(14) = 1, you may generate an infinite loop.)
-C                  In this situation, the next call to DASPK is 
+C                  In this situation, the next call to DASPK is
 C                  considered to be the first call for the problem,
 C                  in that all initializations are done.
 C
 C                    *** FOLLOWING AN INTERRUPTED TASK ***
 C
 C     To show the code that you realize the task was interrupted and
 C     that you want to continue, you must take appropriate action and
 C     set INFO(1) = 1.
@@ -1172,17 +1172,17 @@ C                  to values the code es
 C                  continuing.  You may want to change them yourself.
 C                  If you are sure you want to continue with relaxed
 C                  error tolerances, set INFO(1) = 1 and call the code
 C                  again.
 C
 C     IDID = -3, a solution component is zero and you set the
 C                  corresponding component of ATOL to zero.  If you
 C                  are sure you want to continue, you must first alter
-C                  the error criterion to use positive values of ATOL 
+C                  the error criterion to use positive values of ATOL
 C                  for those components corresponding to zero solution
 C                  components, then set INFO(1) = 1 and call the code
 C                  again.
 C
 C     IDID = -4  --- cannot occur with this code.
 C
 C     IDID = -5, your JAC routine failed with the Krylov method.  Check
 C                  for errors in JAC and restart the integration.
@@ -1223,24 +1223,24 @@ C                  because IRES was equa
 C                  absolutely certain you want to continue, you
 C                  should restart the integration.
 C
 C     IDID = -11, there was an unrecoverable error (IRES = -2) from RES
 C                  inside the nonlinear system solver.  Determine the
 C                  cause before trying again.
 C
 C     IDID = -12, DDASPK failed to compute the initial Y and YPRIME
-C                  vectors.  This could happen because the initial 
+C                  vectors.  This could happen because the initial
 C                  approximation to Y or YPRIME was not very good, or
 C                  because no consistent values of these vectors exist.
 C                  The problem could also be caused by an inaccurate or
 C                  singular iteration matrix, or a poor preconditioner.
 C
-C     IDID = -13, there was an unrecoverable error encountered inside 
-C                  your PSOL routine.  Determine the cause before 
+C     IDID = -13, there was an unrecoverable error encountered inside
+C                  your PSOL routine.  Determine the cause before
 C                  trying again.
 C
 C     IDID = -14, the Krylov linear system solver failed to achieve
 C                  convergence.  This may be due to ill-conditioning
 C                  in the iteration matrix, or a singularity in the
 C                  preconditioner (if one is being used).
 C                  Another possibility is that there is a better
 C                  choice of Krylov parameters (see INFO(13)).
@@ -1258,17 +1258,17 @@ C                  An attempt to do so w
 C                  terminated.
 C
 C  ---------------------------------------------------------------------
 C
 C***REFERENCES
 C  1.  L. R. Petzold, A Description of DASSL: A Differential/Algebraic
 C      System Solver, in Scientific Computing, R. S. Stepleman et al.
 C      (Eds.), North-Holland, Amsterdam, 1983, pp. 65-68.
-C  2.  K. E. Brenan, S. L. Campbell, and L. R. Petzold, Numerical 
+C  2.  K. E. Brenan, S. L. Campbell, and L. R. Petzold, Numerical
 C      Solution of Initial-Value Problems in Differential-Algebraic
 C      Equations, Elsevier, New York, 1989.
 C  3.  P. N. Brown and A. C. Hindmarsh, Reduced Storage Matrix Methods
 C      in Stiff ODE Systems, J. Applied Mathematics and Computation,
 C      31 (1989), pp. 40-91.
 C  4.  P. N. Brown, A. C. Hindmarsh, and L. R. Petzold, Using Krylov
 C      Methods in the Solution of Large-Scale Differential-Algebraic
 C      Systems, SIAM J. Sci. Comp., 15 (1994), pp. 1467-1488.
@@ -1286,17 +1286,17 @@ C   DYYPNW updates Y and YPRIME in lines
 C          calculation.
 C   DDSTP  carries out one step of the integration.
 C   DCNSTR/DCNST0 check the current solution for constraint violations.
 C   DDAWTS sets error weight quantities.
 C   DINVWT tests and inverts the error weights.
 C   DDATRP performs interpolation to get an output solution.
 C   DDWNRM computes the weighted root-mean-square norm of a vector.
 C   D1MACH provides the unit roundoff of the computer.
-C   XERRWD/XSETF/XSETUN/IXSAV is a package to handle error messages. 
+C   XERRWD/XSETF/XSETUN/IXSAV is a package to handle error messages.
 C   DDASID nonlinear equation driver to initialize Y and YPRIME using
 C          direct linear system solver methods.  Interfaces to Newton
 C          solver (direct case).
 C   DNSID  solves the nonlinear system for unknown initial values by
 C          modified Newton iteration and direct linear system methods.
 C   DLINSD carries out linesearch algorithm for initial condition
 C          calculation (direct case).
 C   DFNRMD calculates weighted norm of preconditioned residual in
@@ -1321,17 +1321,17 @@ C          methods.  Interfaces to Newto
 C   DNSK   solves the associated nonlinear system by Inexact Newton
 C          iteration and (linear) Krylov iteration.
 C   DSLVK  interfaces to linear system solver (Krylov case).
 C   DSPIGM solves a linear system by SPIGMR algorithm.
 C   DATV   computes matrix-vector product in Krylov algorithm.
 C   DORTH  performs orthogonalization of Krylov basis vectors.
 C   DHEQR  performs QR factorization of Hessenberg matrix.
 C   DHELS  finds least-squares solution of Hessenberg linear system.
-C   DGETRF, DGETRS, DGBTRF, DGBTRS are LAPACK routines for solving 
+C   DGETRF, DGETRS, DGBTRF, DGBTRS are LAPACK routines for solving
 C          linear systems (dense or band direct methods).
 C   DAXPY, DCOPY, DDOT, DNRM2, DSCAL are Basic Linear Algebra (BLAS)
 C          routines.
 C
 C The routines called directly by DDASPK are:
 C   DCNST0, DDAWTS, DINVWT, D1MACH, DDWNRM, DDASIC, DDATRP, DDSTP,
 C   XERRWD
 C
@@ -1345,17 +1345,17 @@ C
       DIMENSION RWORK(LRW),IWORK(LIW)
       DIMENSION RTOL(*),ATOL(*)
       DIMENSION RPAR(*),IPAR(*)
       CHARACTER MSG*80
       EXTERNAL  RES, JAC, PSOL, DDASID, DDASIK, DNEDD, DNEDK
 C
 C     Set pointers into IWORK.
 C
-      PARAMETER (LML=1, LMU=2, LMTYPE=4, 
+      PARAMETER (LML=1, LMU=2, LMTYPE=4,
      *   LIWM=1, LMXORD=3, LJCALC=5, LPHASE=6, LK=7, LKOLD=8,
      *   LNS=9, LNSTL=10, LNST=11, LNRE=12, LNJE=13, LETF=14, LNCFN=15,
      *   LNCFL=16, LNIW=17, LNRW=18, LNNI=19, LNLI=20, LNPS=21,
      *   LNPD=22, LMITER=23, LMAXL=24, LKMP=25, LNRMAX=26, LLNWP=27,
      *   LLNIWP=28, LLOCWP=29, LLCIWP=30, LKPRIN=31,
      *   LMXNIT=32, LMXNJ=33, LMXNH=34, LLSOFF=35, LICNS=41)
 C
 C     Set pointers into RWORK.
@@ -1488,17 +1488,17 @@ C
       IF (INFO(10) .EQ. 1 .OR. INFO(10) .EQ. 3) LENIC = NEQ
       LENID = 0
       IF (INFO(11) .EQ. 1 .OR. INFO(16) .EQ. 1) LENID = NEQ
       IF (INFO(12) .EQ. 0) THEN
 C
 C        Compute MTYPE, etc.  Check ML and MU.
 C
          NCPHI = MAX(MXORD + 1, 4)
-         IF(INFO(6).EQ.0) THEN 
+         IF(INFO(6).EQ.0) THEN
             LENPD = NEQ**2
             LENRW = 50 + (NCPHI+3)*NEQ + LENPD
             IF(INFO(5).EQ.0) THEN
                IWORK(LMTYPE)=2
             ELSE
                IWORK(LMTYPE)=1
             ENDIF
          ELSE
@@ -1687,17 +1687,17 @@ C
 C
 C     Compute unit roundoff and HMIN.
 C
       UROUND = D1MACH(4)
       RWORK(LROUND) = UROUND
       HMIN = 4.0D0*UROUND*MAX(ABS(T),ABS(TOUT))
 C
 C     Set/check STPTOL control for initial condition calculation.
-C     
+C
       IF (INFO(11) .NE. 0) THEN
         IF( INFO(17) .EQ. 0) THEN
           RWORK(LSTOL) = UROUND**.6667D0
         ELSE
           IF (RWORK(LSTOL) .LE. 0.0D0) GO TO 725
           ENDIF
         ENDIF
 C
@@ -1744,17 +1744,17 @@ 330   IF (INFO(4) .EQ. 0) GO TO 340
          IF ((TSTOP - T)*H0 .LT. 0.0D0) GO TO 715
          IF ((T + H0 - TSTOP)*H0 .GT. 0.0D0) H0 = TSTOP - T
          IF ((TSTOP - TOUT)*H0 .LT. 0.0D0) GO TO 709
 C
 340   IF (INFO(11) .EQ. 0) GO TO 370
 C
 C     Compute unknown components of initial Y and YPRIME, depending
 C     on INFO(11) and INFO(12).  INFO(12) represents the nonlinear
-C     solver type (direct/Krylov).  Pass the name of the specific 
+C     solver type (direct/Krylov).  Pass the name of the specific
 C     nonlinear solver, depending on INFO(12).  The location of the work
 C     arrays SAVR, YIC, YPIC, PWK also differ in the two cases.
 C
       NWT = 1
       EPCONI = RWORK(LEPIN)*RWORK(LEPCON)
 350   IF (INFO(12) .EQ. 0) THEN
          LYIC = LPHI + 2*NEQ
          LYPIC = LYIC + NEQ
diff --git a/liboctave/cruft/daspk/ddstp.f b/liboctave/cruft/daspk/ddstp.f
--- a/liboctave/cruft/daspk/ddstp.f
+++ b/liboctave/cruft/daspk/ddstp.f
@@ -1,10 +1,10 @@
 C Work performed under the auspices of the U.S. Department of Energy
-C by Lawrence Livermore National Laboratory under contract number 
+C by Lawrence Livermore National Laboratory under contract number
 C W-7405-Eng-48.
 C
       SUBROUTINE DDSTP(X,Y,YPRIME,NEQ,RES,JAC,PSOL,H,WT,VT,
      *  JSTART,IDID,RPAR,IPAR,PHI,SAVR,DELTA,E,WM,IWM,
      *  ALPHA,BETA,GAMMA,PSI,SIGMA,CJ,CJOLD,HOLD,S,HMIN,UROUND,
      *  EPLI,SQRTN,RSQRTN,EPCON,IPHASE,JCALC,JFLG,K,KOLD,NS,NONNEG,
      *  NTYPE,NLS)
 C
@@ -13,21 +13,21 @@ C***REFER TO  DDASPK
 C***DATE WRITTEN   890101   (YYMMDD)
 C***REVISION DATE  900926   (YYMMDD)
 C***REVISION DATE  940909   (YYMMDD) (Reset PSI(1), PHI(*,2) at 690)
 C
 C
 C-----------------------------------------------------------------------
 C***DESCRIPTION
 C
-C     DDSTP solves a system of differential/algebraic equations of 
+C     DDSTP solves a system of differential/algebraic equations of
 C     the form G(X,Y,YPRIME) = 0, for one step (normally from X to X+H).
 C
-C     The methods used are modified divided difference, fixed leading 
-C     coefficient forms of backward differentiation formulas.  
+C     The methods used are modified divided difference, fixed leading
+C     coefficient forms of backward differentiation formulas.
 C     The code adjusts the stepsize and order to control the local error
 C     per step.
 C
 C
 C     The parameters represent
 C     X  --        Independent variable.
 C     Y  --        Solution vector at X.
 C     YPRIME --    Derivative of solution vector
@@ -36,17 +36,17 @@ C     NEQ --       Number of equations t
 C     RES --       External user-supplied subroutine
 C                  to evaluate the residual.  See RES description
 C                  in DDASPK prologue.
 C     JAC --       External user-supplied routine to update
 C                  Jacobian or preconditioner information in the
 C                  nonlinear solver.  See JAC description in DDASPK
 C                  prologue.
 C     PSOL --      External user-supplied routine to solve
-C                  a linear system using preconditioning. 
+C                  a linear system using preconditioning.
 C                  (This is optional).  See PSOL in DDASPK prologue.
 C     H --         Appropriate step size for next step.
 C                  Normally determined by the code.
 C     WT --        Vector of weights for error criterion used in Newton test.
 C     VT --        Masked vector of weights used in error test.
 C     JSTART --    Integer variable set 0 for
 C                  first step, 1 otherwise.
 C     IDID --      Completion code returned from the nonlinear solver.
@@ -446,17 +446,17 @@ C     a failure in the nonlinear system 
 C
 675   CONTINUE
       CALL DDATRP(X,X,Y,YPRIME,NEQ,K,PHI,PSI)
       JSTART = 1
       IF (IDID .GE. 0) IDID = -7
       RETURN
 C
 C
-C     Go back and try this step again.  
+C     Go back and try this step again.
 C     If this is the first step, reset PSI(1) and rescale PHI(*,2).
 C
 690   IF (KOLD .EQ. 0) THEN
         PSI(1) = H
         DO 695 I = 1,NEQ
 695       PHI(I,2) = R*PHI(I,2)
         ENDIF
       GO TO 200
diff --git a/liboctave/cruft/daspk/ddwnrm.f b/liboctave/cruft/daspk/ddwnrm.f
--- a/liboctave/cruft/daspk/ddwnrm.f
+++ b/liboctave/cruft/daspk/ddwnrm.f
@@ -1,10 +1,10 @@
 C Work performed under the auspices of the U.S. Department of Energy
-C by Lawrence Livermore National Laboratory under contract number 
+C by Lawrence Livermore National Laboratory under contract number
 C W-7405-Eng-48.
 C
       DOUBLE PRECISION FUNCTION DDWNRM(NEQ,V,RWT,RPAR,IPAR)
 C
 C***BEGIN PROLOGUE  DDWNRM
 C***ROUTINES CALLED  (NONE)
 C***DATE WRITTEN   890101   (YYMMDD)
 C***REVISION DATE  900926   (YYMMDD)
diff --git a/liboctave/cruft/daspk/dfnrmd.f b/liboctave/cruft/daspk/dfnrmd.f
--- a/liboctave/cruft/daspk/dfnrmd.f
+++ b/liboctave/cruft/daspk/dfnrmd.f
@@ -1,10 +1,10 @@
 C Work performed under the auspices of the U.S. Department of Energy
-C by Lawrence Livermore National Laboratory under contract number 
+C by Lawrence Livermore National Laboratory under contract number
 C W-7405-Eng-48.
 C
       SUBROUTINE DFNRMD (NEQ, Y, T, YPRIME, R, CJ, WT, RES, IRES,
      *                   FNORM, WM, IWM, RPAR, IPAR)
 C
 C***BEGIN PROLOGUE  DFNRMD
 C***REFER TO  DLINSD
 C***DATE WRITTEN   941025   (YYMMDD)
diff --git a/liboctave/cruft/daspk/dfnrmk.f b/liboctave/cruft/daspk/dfnrmk.f
--- a/liboctave/cruft/daspk/dfnrmk.f
+++ b/liboctave/cruft/daspk/dfnrmk.f
@@ -1,10 +1,10 @@
 C Work performed under the auspices of the U.S. Department of Energy
-C by Lawrence Livermore National Laboratory under contract number 
+C by Lawrence Livermore National Laboratory under contract number
 C W-7405-Eng-48.
 C
       SUBROUTINE DFNRMK (NEQ, Y, T, YPRIME, SAVR, R, CJ, WT,
      *                   SQRTN, RSQRTN, RES, IRES, PSOL, IRIN, IER,
      *                   FNORM, EPLIN, WP, IWP, PWK, RPAR, IPAR)
 C
 C***BEGIN PROLOGUE  DFNRMK
 C***REFER TO  DLINSK
diff --git a/liboctave/cruft/daspk/dhels.f b/liboctave/cruft/daspk/dhels.f
--- a/liboctave/cruft/daspk/dhels.f
+++ b/liboctave/cruft/daspk/dhels.f
@@ -1,10 +1,10 @@
 C Work performed under the auspices of the U.S. Department of Energy
-C by Lawrence Livermore National Laboratory under contract number 
+C by Lawrence Livermore National Laboratory under contract number
 C W-7405-Eng-48.
 C
       SUBROUTINE DHELS (A, LDA, N, Q, B)
 C
 C***BEGIN PROLOGUE  DHELS
 C***DATE WRITTEN   890101   (YYMMDD)
 C***REVISION DATE  900926   (YYMMDD)
 C
@@ -46,17 +46,17 @@ C
 C        B       The solution vector X.
 C
 C
 C     Modification of LINPACK.
 C     Peter Brown, Lawrence Livermore Natl. Lab.
 C
 C-----------------------------------------------------------------------
 C***ROUTINES CALLED
-C   DAXPY 
+C   DAXPY
 C
 C***END PROLOGUE  DHELS
 C
       INTEGER LDA, N
       DOUBLE PRECISION A(LDA,*), B(*), Q(*)
       INTEGER IQ, K, KB, KP1
       DOUBLE PRECISION C, S, T, T1, T2
 C
diff --git a/liboctave/cruft/daspk/dheqr.f b/liboctave/cruft/daspk/dheqr.f
--- a/liboctave/cruft/daspk/dheqr.f
+++ b/liboctave/cruft/daspk/dheqr.f
@@ -1,10 +1,10 @@
 C Work performed under the auspices of the U.S. Department of Energy
-C by Lawrence Livermore National Laboratory under contract number 
+C by Lawrence Livermore National Laboratory under contract number
 C W-7405-Eng-48.
 C
       SUBROUTINE DHEQR (A, LDA, N, Q, INFO, IJOB)
 C
 C***BEGIN PROLOGUE  DHEQR
 C***DATE WRITTEN   890101   (YYMMDD)
 C***REVISION DATE  900926   (YYMMDD)
 C
diff --git a/liboctave/cruft/daspk/dinvwt.f b/liboctave/cruft/daspk/dinvwt.f
--- a/liboctave/cruft/daspk/dinvwt.f
+++ b/liboctave/cruft/daspk/dinvwt.f
@@ -1,10 +1,10 @@
 C Work performed under the auspices of the U.S. Department of Energy
-C by Lawrence Livermore National Laboratory under contract number 
+C by Lawrence Livermore National Laboratory under contract number
 C W-7405-Eng-48.
 C
       SUBROUTINE DINVWT(NEQ,WT,IER)
 C
 C***BEGIN PROLOGUE  DINVWT
 C***REFER TO  DDASPK
 C***ROUTINES CALLED  (NONE)
 C***DATE WRITTEN   950125   (YYMMDD)
diff --git a/liboctave/cruft/daspk/dlinsd.f b/liboctave/cruft/daspk/dlinsd.f
--- a/liboctave/cruft/daspk/dlinsd.f
+++ b/liboctave/cruft/daspk/dlinsd.f
@@ -1,10 +1,10 @@
 C Work performed under the auspices of the U.S. Department of Energy
-C by Lawrence Livermore National Laboratory under contract number 
+C by Lawrence Livermore National Laboratory under contract number
 C W-7405-Eng-48.
 C
       SUBROUTINE DLINSD (NEQ, Y, T, YPRIME, CJ, P, PNRM, WT, LSOFF,
      *                   STPTOL, IRET, RES, IRES, WM, IWM,
      *                   FNRM, ICOPT, ID, R, YNEW, YPNEW, ICNFLG,
      *                   ICNSTR, RLX, RPAR, IPAR)
 C
 C***BEGIN PROLOGUE  DLINSD
@@ -13,17 +13,17 @@ C***DATE WRITTEN   941025   (YYMMDD)
 C***REVISION DATE  941215   (YYMMDD)
 C***REVISION DATE  960129   Moved line RL = ONE to top block.
 C
 C
 C-----------------------------------------------------------------------
 C***DESCRIPTION
 C
 C     DLINSD uses a linesearch algorithm to calculate a new (Y,YPRIME)
-C     pair (YNEW,YPNEW) such that 
+C     pair (YNEW,YPNEW) such that
 C
 C     f(YNEW,YPNEW) .le. (1 - 2*ALPHA*RL)*f(Y,YPRIME) ,
 C
 C     where 0 < RL <= 1.  Here, f(y,y') is defined as
 C
 C      f(y,y') = (1/2)*norm( (J-inverse)*G(t,y,y') )**2 ,
 C
 C     where norm() is the weighted RMS vector norm, G is the DAE
@@ -46,21 +46,21 @@ C                adjusted accordingly.
 C     ICNSTR  -- Integer array of length NEQ containing flags for
 C                checking constraints.
 C     RLX     -- Real scalar restricting update size in DCNSTR.
 C     YNEW    -- Array of length NEQ used to hold the new Y in
 C                performing the linesearch.
 C     YPNEW   -- Array of length NEQ used to hold the new YPRIME in
 C                performing the linesearch.
 C     Y       -- Array of length NEQ containing the new Y (i.e.,=YNEW).
-C     YPRIME  -- Array of length NEQ containing the new YPRIME 
+C     YPRIME  -- Array of length NEQ containing the new YPRIME
 C                (i.e.,=YPNEW).
 C     FNRM    -- Real scalar containing SQRT(2*f(Y,YPRIME)) for the
 C                current (Y,YPRIME) on input and output.
-C     R       -- Work array of length NEQ, containing the scaled 
+C     R       -- Work array of length NEQ, containing the scaled
 C                residual (J-inverse)*G(t,y,y') on return.
 C     IRET    -- Return flag.
 C                IRET=0 means that a satisfactory (Y,YPRIME) was found.
 C                IRET=1 means that the routine failed to find a new
 C                       (Y,YPRIME) that was sufficiently distinct from
 C                       the current (Y,YPRIME) pair.
 C                IRET=2 means IRES .ne. 0 from RES.
 C-----------------------------------------------------------------------
@@ -91,17 +91,17 @@ C
         MSG = '------ IN ROUTINE DLINSD-- PNRM = (R1) )'
         CALL XERRWD(MSG, 40, 901, 0, 0, 0, 0, 1, PNRM, 0.0D0)
         ENDIF
       TAU = PNRM
       IVIO = 0
       RL = ONE
 C-----------------------------------------------------------------------
 C Check for violations of the constraints, if any are imposed.
-C If any violations are found, the step vector P is rescaled, and the 
+C If any violations are found, the step vector P is rescaled, and the
 C constraint check is repeated, until no violations are found.
 C-----------------------------------------------------------------------
       IF (ICNFLG .NE. 0) THEN
  10      CONTINUE
          CALL DYYPNW (NEQ,Y,YPRIME,CJ,RL,P,ICOPT,ID,YNEW,YPNEW)
          CALL DCNSTR (NEQ, Y, YNEW, ICNSTR, TAU, RLX, IRET, IVAR)
          IF (IRET .EQ. 1) THEN
             IVIO = 1
@@ -161,17 +161,17 @@ C---------------------------------------
       FNRM = FNRMP
       IF (KPRIN .GE. 1) THEN
         MSG = '------ LEAVING ROUTINE DLINSD, FNRM = (R1)'
         CALL XERRWD(MSG, 42, 906, 0, 0, 0, 0, 1, FNRM, 0.0D0)
         ENDIF
       RETURN
 C-----------------------------------------------------------------------
 C Alpha-condition not satisfied.  Perform backtrack to compute new RL
-C value.  If no satisfactory YNEW,YPNEW can be found sufficiently 
+C value.  If no satisfactory YNEW,YPNEW can be found sufficiently
 C distinct from Y,YPRIME, then return IRET = 1.
 C-----------------------------------------------------------------------
  200  CONTINUE
       IF (RL .LT. RLMIN) THEN
         IRET = 1
         RETURN
         ENDIF
 C
diff --git a/liboctave/cruft/daspk/dlinsk.f b/liboctave/cruft/daspk/dlinsk.f
--- a/liboctave/cruft/daspk/dlinsk.f
+++ b/liboctave/cruft/daspk/dlinsk.f
@@ -1,10 +1,10 @@
 C Work performed under the auspices of the U.S. Department of Energy
-C by Lawrence Livermore National Laboratory under contract number 
+C by Lawrence Livermore National Laboratory under contract number
 C W-7405-Eng-48.
 C
       SUBROUTINE DLINSK (NEQ, Y, T, YPRIME, SAVR, CJ, P, PNRM, WT,
      *   SQRTN, RSQRTN, LSOFF, STPTOL, IRET, RES, IRES, PSOL, WM, IWM,
      *   RHOK, FNRM, ICOPT, ID, WP, IWP, R, EPLIN, YNEW, YPNEW, PWK,
      *   ICNFLG, ICNSTR, RLX, RPAR, IPAR)
 C
 C***BEGIN PROLOGUE  DLINSK
@@ -13,39 +13,39 @@ C***DATE WRITTEN   940830   (YYMMDD)
 C***REVISION DATE  951006   (Arguments SQRTN, RSQRTN added.)
 C***REVISION DATE  960129   Moved line RL = ONE to top block.
 C
 C
 C-----------------------------------------------------------------------
 C***DESCRIPTION
 C
 C     DLINSK uses a linesearch algorithm to calculate a new (Y,YPRIME)
-C     pair (YNEW,YPNEW) such that 
+C     pair (YNEW,YPNEW) such that
 C
-C     f(YNEW,YPNEW) .le. (1 - 2*ALPHA*RL)*f(Y,YPRIME) + 
+C     f(YNEW,YPNEW) .le. (1 - 2*ALPHA*RL)*f(Y,YPRIME) +
 C                          ALPHA*RL*RHOK*RHOK ,
 C
 C     where 0 < RL <= 1, and RHOK is the scaled preconditioned norm of
-C     the final residual vector in the Krylov iteration.  
+C     the final residual vector in the Krylov iteration.
 C     Here, f(y,y') is defined as
 C
 C      f(y,y') = (1/2)*norm( (P-inverse)*G(t,y,y') )**2 ,
 C
 C     where norm() is the weighted RMS vector norm, G is the DAE
 C     system residual function, and P is the preconditioner used
 C     in the Krylov iteration.
 C
 C     In addition to the parameters defined elsewhere, we have
 C
 C     SAVR    -- Work array of length NEQ, containing the residual
 C                vector G(t,y,y') on return.
 C     P       -- Approximate Newton step used in backtracking.
 C     PNRM    -- Weighted RMS norm of P.
 C     LSOFF   -- Flag showing whether the linesearch algorithm is
-C                to be invoked.  0 means do the linesearch, 
+C                to be invoked.  0 means do the linesearch,
 C                1 means turn off linesearch.
 C     STPTOL  -- Tolerance used in calculating the minimum lambda
 C                value allowed.
 C     ICNFLG  -- Integer scalar.  If nonzero, then constraint violations
 C                in the proposed new approximate solution will be
 C                checked for, and the maximum step length will be
 C                adjusted accordingly.
 C     ICNSTR  -- Integer array of length NEQ containing flags for
@@ -53,17 +53,17 @@ C                checking constraints.
 C     RHOK    -- Weighted norm of preconditioned Krylov residual.
 C     RLX     -- Real scalar restricting update size in DCNSTR.
 C     YNEW    -- Array of length NEQ used to hold the new Y in
 C                performing the linesearch.
 C     YPNEW   -- Array of length NEQ used to hold the new YPRIME in
 C                performing the linesearch.
 C     PWK     -- Work vector of length NEQ for use in PSOL.
 C     Y       -- Array of length NEQ containing the new Y (i.e.,=YNEW).
-C     YPRIME  -- Array of length NEQ containing the new YPRIME 
+C     YPRIME  -- Array of length NEQ containing the new YPRIME
 C                (i.e.,=YPNEW).
 C     FNRM    -- Real scalar containing SQRT(2*f(Y,YPRIME)) for the
 C                current (Y,YPRIME) on input and output.
 C     R       -- Work space length NEQ for residual vector.
 C     IRET    -- Return flag.
 C                IRET=0 means that a satisfactory (Y,YPRIME) was found.
 C                IRET=1 means that the routine failed to find a new
 C                       (Y,YPRIME) that was sufficiently distinct from
@@ -96,17 +96,17 @@ C
         MSG = '------ IN ROUTINE DLINSK-- PNRM = (R1) )'
         CALL XERRWD(MSG, 40, 921, 0, 0, 0, 0, 1, PNRM, 0.0D0)
         ENDIF
       TAU = PNRM
       IVIO = 0
       RL = ONE
 C-----------------------------------------------------------------------
 C Check for violations of the constraints, if any are imposed.
-C If any violations are found, the step vector P is rescaled, and the 
+C If any violations are found, the step vector P is rescaled, and the
 C constraint check is repeated, until no violations are found.
 C-----------------------------------------------------------------------
       IF (ICNFLG .NE. 0) THEN
  10      CONTINUE
          CALL DYYPNW (NEQ,Y,YPRIME,CJ,RL,P,ICOPT,ID,YNEW,YPNEW)
          CALL DCNSTR (NEQ, Y, YNEW, ICNSTR, TAU, RLX, IRET, IVAR)
          IF (IRET .EQ. 1) THEN
             IVIO = 1
diff --git a/liboctave/cruft/daspk/dmatd.f b/liboctave/cruft/daspk/dmatd.f
--- a/liboctave/cruft/daspk/dmatd.f
+++ b/liboctave/cruft/daspk/dmatd.f
@@ -1,10 +1,10 @@
 C Work performed under the auspices of the U.S. Department of Energy
-C by Lawrence Livermore National Laboratory under contract number 
+C by Lawrence Livermore National Laboratory under contract number
 C W-7405-Eng-48.
 C
       SUBROUTINE DMATD(NEQ,X,Y,YPRIME,DELTA,CJ,H,IER,EWT,E,
      *                 WM,IWM,RES,IRES,UROUND,JACD,RPAR,IPAR)
 C
 C***BEGIN PROLOGUE  DMATD
 C***REFER TO  DDASPK
 C***DATE WRITTEN   890101   (YYMMDD)
diff --git a/liboctave/cruft/daspk/dnedd.f b/liboctave/cruft/daspk/dnedd.f
--- a/liboctave/cruft/daspk/dnedd.f
+++ b/liboctave/cruft/daspk/dnedd.f
@@ -1,10 +1,10 @@
 C Work performed under the auspices of the U.S. Department of Energy
-C by Lawrence Livermore National Laboratory under contract number 
+C by Lawrence Livermore National Laboratory under contract number
 C W-7405-Eng-48.
 C
       SUBROUTINE DNEDD(X,Y,YPRIME,NEQ,RES,JACD,PDUM,H,WT,
      *   JSTART,IDID,RPAR,IPAR,PHI,GAMMA,DUMSVR,DELTA,E,
      *   WM,IWM,CJ,CJOLD,CJLAST,S,UROUND,DUME,DUMS,DUMR,
      *   EPCON,JCALC,JFDUM,KP1,NONNEG,NTYPE,IERNLS)
 C
 C***BEGIN PROLOGUE  DNEDD
@@ -116,17 +116,17 @@ C
 C     The following group of variables are passed as arguments to
 C     the Newton iteration solver.  They are explained in greater detail
 C     in DNSD:
 C        TOLNEW, MULDEL, MAXIT, IERNEW
 C
 C     IERTYP -- Flag which tells whether this subroutine is correct.
 C               0 ==> correct subroutine.
 C               1 ==> incorrect subroutine.
-C 
+C
 C-----------------------------------------------------------------------
 C***ROUTINES CALLED
 C   DDWNRM, RES, DMATD, DNSD
 C
 C***END PROLOGUE  DNEDD
 C
 C
       IMPLICIT DOUBLE PRECISION(A-H,O-Z)
@@ -187,24 +187,24 @@ C
 310      YPRIME(I)=0.0D0
       DO 330 J=2,KP1
          DO 320 I=1,NEQ
             Y(I)=Y(I)+PHI(I,J)
 320         YPRIME(I)=YPRIME(I)+GAMMA(J)*PHI(I,J)
 330   CONTINUE
       PNORM = DDWNRM (NEQ,Y,WT,RPAR,IPAR)
       TOLNEW = 100.D0*UROUND*PNORM
-C     
+C
 C     Call RES to initialize DELTA.
 C
       IWM(LNRE)=IWM(LNRE)+1
       CALL RES(X,Y,YPRIME,CJ,DELTA,IRES,RPAR,IPAR)
       IF (IRES .LT. 0) GO TO 380
 C
-C     If indicated, reevaluate the iteration matrix 
+C     If indicated, reevaluate the iteration matrix
 C     J = dG/dY + CJ*dG/dYPRIME (where G(X,Y,YPRIME)=0).
 C     Set JCALC to 0 as an indicator that this has been done.
 C
       IF(JCALC .EQ. -1) THEN
          IWM(LNJE)=IWM(LNJE)+1
          JCALC=0
          CALL DMATD(NEQ,X,Y,YPRIME,DELTA,CJ,H,IERJ,WT,E,WM,IWM,
      *              RES,IRES,UROUND,JACD,RPAR,IPAR)
diff --git a/liboctave/cruft/daspk/dnedk.f b/liboctave/cruft/daspk/dnedk.f
--- a/liboctave/cruft/daspk/dnedk.f
+++ b/liboctave/cruft/daspk/dnedk.f
@@ -1,10 +1,10 @@
 C Work performed under the auspices of the U.S. Department of Energy
-C by Lawrence Livermore National Laboratory under contract number 
+C by Lawrence Livermore National Laboratory under contract number
 C W-7405-Eng-48.
 C
       SUBROUTINE DNEDK(X,Y,YPRIME,NEQ,RES,JACK,PSOL,
      *   H,WT,JSTART,IDID,RPAR,IPAR,PHI,GAMMA,SAVR,DELTA,E,
      *   WM,IWM,CJ,CJOLD,CJLAST,S,UROUND,EPLI,SQRTN,RSQRTN,
      *   EPCON,JCALC,JFLG,KP1,NONNEG,NTYPE,IERNLS)
 C
 C***BEGIN PROLOGUE  DNEDK
@@ -32,17 +32,17 @@ C     NEQ       -- Number of equations t
 C     RES       -- External user-supplied subroutine
 C                  to evaluate the residual.  See RES description
 C                  in DDASPK prologue.
 C     JACK     --  External user-supplied routine to update
 C                  the preconditioner.  (This is optional).
 C                  See JAC description for the case
 C                  INFO(12) = 1 in the DDASPK prologue.
 C     PSOL      -- External user-supplied routine to solve
-C                  a linear system using preconditioning. 
+C                  a linear system using preconditioning.
 C                  (This is optional).  See explanation inside DDASPK.
 C     H         -- Appropriate step size for this step.
 C     WT        -- Vector of weights for error criterion.
 C     JSTART    -- Indicates first call to this routine.
 C                  If JSTART = 0, then this is the first call,
 C                  otherwise it is not.
 C     IDID      -- Completion flag, output by DNEDK.
 C                  See IDID description in DDASPK prologue.
diff --git a/liboctave/cruft/daspk/dnsd.f b/liboctave/cruft/daspk/dnsd.f
--- a/liboctave/cruft/daspk/dnsd.f
+++ b/liboctave/cruft/daspk/dnsd.f
@@ -1,10 +1,10 @@
 C Work performed under the auspices of the U.S. Department of Energy
-C by Lawrence Livermore National Laboratory under contract number 
+C by Lawrence Livermore National Laboratory under contract number
 C W-7405-Eng-48.
 C
       SUBROUTINE DNSD(X,Y,YPRIME,NEQ,RES,PDUM,WT,RPAR,IPAR,
      *   DUMSVR,DELTA,E,WM,IWM,CJ,DUMS,DUMR,DUME,EPCON,
      *   S,CONFAC,TOLNEW,MULDEL,MAXIT,IRES,IDUM,IERNEW)
 C
 C***BEGIN PROLOGUE  DNSD
 C***REFER TO  DDASPK
@@ -85,17 +85,17 @@ C
 C
       IMPLICIT DOUBLE PRECISION(A-H,O-Z)
       DIMENSION Y(*),YPRIME(*),WT(*),DELTA(*),E(*)
       DIMENSION WM(*),IWM(*), RPAR(*),IPAR(*)
       EXTERNAL  RES
 C
       PARAMETER (LNRE=12, LNNI=19)
 C
-C     Initialize Newton counter M and accumulation vector E. 
+C     Initialize Newton counter M and accumulation vector E.
 C
       M = 0
       DO 100 I=1,NEQ
 100     E(I)=0.0D0
 C
 C     Corrector loop.
 C
 300   CONTINUE
diff --git a/liboctave/cruft/daspk/dnsid.f b/liboctave/cruft/daspk/dnsid.f
--- a/liboctave/cruft/daspk/dnsid.f
+++ b/liboctave/cruft/daspk/dnsid.f
@@ -1,10 +1,10 @@
 C Work performed under the auspices of the U.S. Department of Energy
-C by Lawrence Livermore National Laboratory under contract number 
+C by Lawrence Livermore National Laboratory under contract number
 C W-7405-Eng-48.
 C
       SUBROUTINE DNSID(X,Y,YPRIME,NEQ,ICOPT,ID,RES,WT,RPAR,IPAR,
      *   DELTA,R,YIC,YPIC,WM,IWM,CJ,EPCON,RATEMX,MAXIT,STPTOL,
      *   ICNFLG,ICNSTR,IERNEW)
 C
 C***BEGIN PROLOGUE  DNSID
 C***REFER TO  DDASPK
@@ -37,29 +37,29 @@ C     RPAR,IPAR -- Real and integer arra
 C                  between the calling program and external user
 C                  routines.  They are not altered within DASPK.
 C     DELTA     -- Residual vector on entry, and work vector of
 C                  length NEQ for DNSID.
 C     WM,IWM    -- Real and integer arrays storing matrix information
 C                  such as the matrix of partial derivatives,
 C                  permutation vector, and various other information.
 C     CJ        -- Matrix parameter = 1/H (ICOPT = 1) or 0 (ICOPT = 2).
-C     R         -- Array of length NEQ used as workspace by the 
+C     R         -- Array of length NEQ used as workspace by the
 C                  linesearch routine DLINSD.
 C     YIC,YPIC  -- Work vectors for DLINSD, each of length NEQ.
 C     EPCON     -- Tolerance to test for convergence of the Newton
 C                  iteration.
 C     RATEMX    -- Maximum convergence rate for which Newton iteration
 C                  is considered converging.
 C     MAXIT     -- Maximum allowed number of Newton iterations.
 C     STPTOL    -- Tolerance used in calculating the minimum lambda
 C                  value allowed.
 C     ICNFLG    -- Integer scalar.  If nonzero, then constraint
 C                  violations in the proposed new approximate solution
-C                  will be checked for, and the maximum step length 
+C                  will be checked for, and the maximum step length
 C                  will be adjusted accordingly.
 C     ICNSTR    -- Integer array of length NEQ containing flags for
 C                  checking constraints.
 C     IERNEW    -- Error flag for Newton iteration.
 C                   0  ==> Newton iteration converged.
 C                   1  ==> failed to converge, but RATE .le. RATEMX.
 C                   2  ==> failed to converge, RATE .gt. RATEMX.
 C                   3  ==> other recoverable error (IRES = -1, or
@@ -128,17 +128,17 @@ C     Test whether the maximum number of
 C
       M = M + 1
       IF (M .GE. MAXIT) GO TO 380
 C
 C     Copy the residual to DELTA and its norm to DELNRM, and loop for
 C     another iteration.
 C
       CALL DCOPY (NEQ, R, 1, DELTA, 1)
-      DELNRM = FNRM      
+      DELNRM = FNRM
       GO TO 300
 C
 C     The maximum number of iterations was done.  Set IERNEW and return.
 C
  380  IF (RATE .LE. RATEMX) THEN
          IERNEW = 1
       ELSE
          IERNEW = 2
diff --git a/liboctave/cruft/daspk/dnsik.f b/liboctave/cruft/daspk/dnsik.f
--- a/liboctave/cruft/daspk/dnsik.f
+++ b/liboctave/cruft/daspk/dnsik.f
@@ -1,10 +1,10 @@
 C Work performed under the auspices of the U.S. Department of Energy
-C by Lawrence Livermore National Laboratory under contract number 
+C by Lawrence Livermore National Laboratory under contract number
 C W-7405-Eng-48.
 C
       SUBROUTINE DNSIK(X,Y,YPRIME,NEQ,ICOPT,ID,RES,PSOL,WT,RPAR,IPAR,
      *   SAVR,DELTA,R,YIC,YPIC,PWK,WM,IWM,CJ,SQRTN,RSQRTN,EPLIN,EPCON,
      *   RATEMX,MAXIT,STPTOL,ICNFLG,ICNSTR,IERNEW)
 C
 C***BEGIN PROLOGUE  DNSIK
 C***REFER TO  DDASPK
@@ -30,17 +30,17 @@ C     YPRIME    -- Derivative of solutio
 C     NEQ       -- Number of unknowns.
 C     ICOPT     -- Initial condition option chosen (1 or 2).
 C     ID        -- Array of dimension NEQ, which must be initialized
 C                  if ICOPT = 1.  See DDASIC.
 C     RES       -- External user-supplied subroutine
 C                  to evaluate the residual.  See RES description
 C                  in DDASPK prologue.
 C     PSOL      -- External user-supplied routine to solve
-C                  a linear system using preconditioning. 
+C                  a linear system using preconditioning.
 C                  See explanation inside DDASPK.
 C     WT        -- Vector of weights for error criterion.
 C     RPAR,IPAR -- Real and integer arrays used for communication
 C                  between the calling program and external user
 C                  routines.  They are not altered within DASPK.
 C     SAVR      -- Work vector for DNSIK of length NEQ.
 C     DELTA     -- Residual vector on entry, and work vector of
 C                  length NEQ for DNSIK.
@@ -174,16 +174,16 @@ 380   IF (RATE .LE. RATEMX) THEN
          IERNEW = 2
       ENDIF
       RETURN
 C
 390   IF (IRES .LE. -2 .OR. IERSL .LT. 0) THEN
          IERNEW = -1
       ELSE
          IERNEW = 3
-         IF (IRES .EQ. 0 .AND. IERSL .EQ. 1 .AND. M .GE. 2 
+         IF (IRES .EQ. 0 .AND. IERSL .EQ. 1 .AND. M .GE. 2
      1       .AND. RATE .LT. 1.0D0) IERNEW = 1
       ENDIF
       RETURN
 C
 C
 C----------------------- END OF SUBROUTINE DNSIK------------------------
       END
diff --git a/liboctave/cruft/daspk/dnsk.f b/liboctave/cruft/daspk/dnsk.f
--- a/liboctave/cruft/daspk/dnsk.f
+++ b/liboctave/cruft/daspk/dnsk.f
@@ -1,10 +1,10 @@
 C Work performed under the auspices of the U.S. Department of Energy
-C by Lawrence Livermore National Laboratory under contract number 
+C by Lawrence Livermore National Laboratory under contract number
 C W-7405-Eng-48.
 C
       SUBROUTINE DNSK(X,Y,YPRIME,NEQ,RES,PSOL,WT,RPAR,IPAR,
      *   SAVR,DELTA,E,WM,IWM,CJ,SQRTN,RSQRTN,EPLIN,EPCON,
      *   S,CONFAC,TOLNEW,MULDEL,MAXIT,IRES,IERSL,IERNEW)
 C
 C***BEGIN PROLOGUE  DNSK
 C***REFER TO  DDASPK
@@ -27,17 +27,17 @@ C
 C     X         -- Independent variable.
 C     Y         -- Solution vector.
 C     YPRIME    -- Derivative of solution vector.
 C     NEQ       -- Number of unknowns.
 C     RES       -- External user-supplied subroutine
 C                  to evaluate the residual.  See RES description
 C                  in DDASPK prologue.
 C     PSOL      -- External user-supplied routine to solve
-C                  a linear system using preconditioning. 
+C                  a linear system using preconditioning.
 C                  See explanation inside DDASPK.
 C     WT        -- Vector of weights for error criterion.
 C     RPAR,IPAR -- Real and integer arrays used for communication
 C                  between the calling program and external user
 C                  routines.  They are not altered within DASPK.
 C     SAVR      -- Work vector for DNSK of length NEQ.
 C     DELTA     -- Work vector for DNSK of length NEQ.
 C     E         -- Error accumulation vector for DNSK of length NEQ.
diff --git a/liboctave/cruft/daspk/dorth.f b/liboctave/cruft/daspk/dorth.f
--- a/liboctave/cruft/daspk/dorth.f
+++ b/liboctave/cruft/daspk/dorth.f
@@ -1,10 +1,10 @@
 C Work performed under the auspices of the U.S. Department of Energy
-C by Lawrence Livermore National Laboratory under contract number 
+C by Lawrence Livermore National Laboratory under contract number
 C W-7405-Eng-48.
 C
       SUBROUTINE DORTH (VNEW, V, HES, N, LL, LDHES, KMP, SNORMW)
 C
 C***BEGIN PROLOGUE  DORTH
 C***DATE WRITTEN   890101   (YYMMDD)
 C***REVISION DATE  900926   (YYMMDD)
 C
@@ -45,17 +45,17 @@ C                where I0 = MAX(1, LL-KM
 C
 C         HES  = Upper Hessenberg matrix with column LL filled in with
 C                scaled inner products of A*V(*,LL) and V(*,I).
 C
 C       SNORMW = L-2 norm of VNEW.
 C
 C-----------------------------------------------------------------------
 C***ROUTINES CALLED
-C   DDOT, DNRM2, DAXPY 
+C   DDOT, DNRM2, DAXPY
 C
 C***END PROLOGUE  DORTH
 C
       INTEGER N, LL, LDHES, KMP
       DOUBLE PRECISION VNEW, V, HES, SNORMW
       DIMENSION VNEW(*), V(N,*), HES(LDHES,*)
       INTEGER I, I0
       DOUBLE PRECISION ARG, DDOT, DNRM2, SUMDSQ, TEM, VNRM
diff --git a/liboctave/cruft/daspk/dslvd.f b/liboctave/cruft/daspk/dslvd.f
--- a/liboctave/cruft/daspk/dslvd.f
+++ b/liboctave/cruft/daspk/dslvd.f
@@ -1,10 +1,10 @@
 C Work performed under the auspices of the U.S. Department of Energy
-C by Lawrence Livermore National Laboratory under contract number 
+C by Lawrence Livermore National Laboratory under contract number
 C W-7405-Eng-48.
 C
       SUBROUTINE DSLVD(NEQ,DELTA,WM,IWM)
 C
 C***BEGIN PROLOGUE  DSLVD
 C***REFER TO  DDASPK
 C***DATE WRITTEN   890101   (YYMMDD)
 C***REVISION DATE  900926   (YYMMDD)
@@ -44,14 +44,14 @@ C
 C     Dummy section for MTYPE=3.
 C
 300   CONTINUE
       RETURN
 C
 C     Banded matrix.
 C
 400   MEBAND=2*IWM(LML)+IWM(LMU)+1
-      CALL DGBTRS('N', NEQ, IWM(LML), IWM(LMU), 1, WM, MEBAND, 
+      CALL DGBTRS('N', NEQ, IWM(LML), IWM(LMU), 1, WM, MEBAND,
      *     IWM(LIPVT), DELTA, NEQ, INLPCK)
       RETURN
 C
 C------END OF SUBROUTINE DSLVD------------------------------------------
       END
diff --git a/liboctave/cruft/daspk/dslvk.f b/liboctave/cruft/daspk/dslvk.f
--- a/liboctave/cruft/daspk/dslvk.f
+++ b/liboctave/cruft/daspk/dslvk.f
@@ -1,10 +1,10 @@
 C Work performed under the auspices of the U.S. Department of Energy
-C by Lawrence Livermore National Laboratory under contract number 
+C by Lawrence Livermore National Laboratory under contract number
 C W-7405-Eng-48.
 C
       SUBROUTINE DSLVK (NEQ, Y, TN, YPRIME, SAVR, X, EWT, WM, IWM,
      *   RES, IRES, PSOL, IERSL, CJ, EPLIN, SQRTN, RSQRTN, RHOK,
      *   RPAR, IPAR)
 C
 C***BEGIN PROLOGUE  DSLVK
 C***REFER TO  DDASPK
@@ -38,43 +38,43 @@ C---------------------------------------
 C***ROUTINES CALLED
 C   DSCAL, DCOPY, DSPIGM
 C
 C***END PROLOGUE  DSLVK
 C
       INTEGER NEQ, IWM, IRES, IERSL, IPAR
       DOUBLE PRECISION Y, TN, YPRIME, SAVR, X, EWT, WM, CJ, EPLIN,
      1   SQRTN, RSQRTN, RHOK, RPAR
-      DIMENSION Y(*), YPRIME(*), SAVR(*), X(*), EWT(*), 
+      DIMENSION Y(*), YPRIME(*), SAVR(*), X(*), EWT(*),
      1  WM(*), IWM(*), RPAR(*), IPAR(*)
 C
       INTEGER IFLAG, IRST, NRSTS, NRMAX, LR, LDL, LHES, LGMR, LQ, LV,
      1        LWK, LZ, MAXLP1, NPSL
       INTEGER NLI, NPS, NCFL, NRE, MAXL, KMP, MITER
       EXTERNAL  RES, PSOL
-C    
-      PARAMETER (LNRE=12, LNCFL=16, LNLI=20, LNPS=21) 
+C
+      PARAMETER (LNRE=12, LNCFL=16, LNLI=20, LNPS=21)
       PARAMETER (LLOCWP=29, LLCIWP=30)
       PARAMETER (LMITER=23, LMAXL=24, LKMP=25, LNRMAX=26)
 C
 C-----------------------------------------------------------------------
 C IRST is set to 1, to indicate restarting is in effect.
 C NRMAX is the maximum number of restarts.
 C-----------------------------------------------------------------------
       DATA IRST/1/
 C
       LIWP = IWM(LLCIWP)
       NLI = IWM(LNLI)
       NPS = IWM(LNPS)
       NCFL = IWM(LNCFL)
       NRE = IWM(LNRE)
       LWP = IWM(LLOCWP)
-      MAXL = IWM(LMAXL) 
+      MAXL = IWM(LMAXL)
       KMP = IWM(LKMP)
-      NRMAX = IWM(LNRMAX) 
+      NRMAX = IWM(LNRMAX)
       MITER = IWM(LMITER)
       IERSL = 0
       IRES = 0
 C-----------------------------------------------------------------------
 C Use a restarting strategy to solve the linear system
 C P*X = -F.  Parse the work vector, and perform initializations.
 C Note that zero is the initial guess for X.
 C-----------------------------------------------------------------------
@@ -108,29 +108,29 @@ C---------------------------------------
       CALL DSPIGM (NEQ, TN, Y, YPRIME, SAVR, WM(LR), EWT, MAXL, MAXLP1,
      1   KMP, EPLIN, CJ, RES, IRES, NRES, PSOL, NPSL, WM(LZ), WM(LV),
      2   WM(LHES), WM(LQ), LGMR, WM(LWP), IWM(LIWP), WM(LWK),
      3   WM(LDL), RHOK, IFLAG, IRST, NRSTS, RPAR, IPAR)
       NLI = NLI + LGMR
       NPS = NPS + NPSL
       NRE = NRE + NRES
       DO 120 I = 1,NEQ
- 120     X(I) = X(I) + WM(LZ+I-1) 
+ 120     X(I) = X(I) + WM(LZ+I-1)
       IF ((IFLAG .EQ. 1) .AND. (NRSTS .LT. NRMAX) .AND. (IRES .EQ. 0))
      1   GO TO 115
 C-----------------------------------------------------------------------
 C The restart scheme is finished.  Test IRES and IFLAG to see if
 C convergence was not achieved, and set flags accordingly.
 C-----------------------------------------------------------------------
       IF (IRES .LT. 0) THEN
          NCFL = NCFL + 1
       ELSE IF (IFLAG .NE. 0) THEN
          NCFL = NCFL + 1
-         IF (IFLAG .GT. 0) IERSL = 1 
-         IF (IFLAG .LT. 0) IERSL = -1 
+         IF (IFLAG .GT. 0) IERSL = 1
+         IF (IFLAG .LT. 0) IERSL = -1
       ENDIF
 C-----------------------------------------------------------------------
 C Update IWM with counters, rescale EWT, and return.
 C-----------------------------------------------------------------------
       IWM(LNLI)  = NLI
       IWM(LNPS)  = NPS
       IWM(LNCFL) = NCFL
       IWM(LNRE)  = NRE
diff --git a/liboctave/cruft/daspk/dspigm.f b/liboctave/cruft/daspk/dspigm.f
--- a/liboctave/cruft/daspk/dspigm.f
+++ b/liboctave/cruft/daspk/dspigm.f
@@ -1,10 +1,10 @@
 C Work performed under the auspices of the U.S. Department of Energy
-C by Lawrence Livermore National Laboratory under contract number 
+C by Lawrence Livermore National Laboratory under contract number
 C W-7405-Eng-48.
 C
       SUBROUTINE DSPIGM (NEQ, TN, Y, YPRIME, SAVR, R, WGHT, MAXL,
      *   MAXLP1, KMP, EPLIN, CJ, RES, IRES, NRE, PSOL, NPSL, Z, V,
      *   HES, Q, LGMR, WP, IWP, WK, DL, RHOK, IFLAG, IRST, NRSTS,
      *   RPAR, IPAR)
 C
 C***BEGIN PROLOGUE  DSPIGM
@@ -45,17 +45,17 @@ C         MAXL = The maximum allowable o
 C
 C       MAXLP1 = MAXL + 1, used for dynamic dimensioning of HES.
 C
 C          KMP = The number of previous vectors the new vector, VNEW,
 C                must be made orthogonal to.  (KMP .LE. MAXL.)
 C
 C        EPLIN = Tolerance on residuals R-A*Z in weighted rms norm.
 C
-C           CJ = Scalar proportional to current value of 
+C           CJ = Scalar proportional to current value of
 C                1/(step size H).
 C
 C           WK = Real work array used by routine DATV and PSOL.
 C
 C           DL = Real work array used for calculation of the residual
 C                norm RHO when the method is incomplete (KMP.LT.MAXL)
 C                and/or when using restarting.
 C
@@ -95,17 +95,17 @@ C                entries are the scaled 
 C                and V(*,K).
 C
 C         Q    = Real array of length 2*MAXL containing the components
 C                of the givens rotations used in the QR decomposition
 C                of HES.  It is loaded in DHEQR and used in DHELS.
 C
 C         IRES = Error flag from RES.
 C
-C           DL = Scaled preconditioned residual, 
+C           DL = Scaled preconditioned residual,
 C                (D-inverse)*(P-inverse)*(R-A*Z). Only loaded when
 C                performing restarts of the Krylov iteration.
 C
 C         RHOK = Weighted norm of final preconditioned residual.
 C
 C        IFLAG = Integer error flag..
 C                0 Means convergence in LGMR iterations, LGMR.LE.MAXL.
 C                1 Means the convergence test did not pass in MAXL
@@ -250,17 +250,17 @@ C---------------------------------------
       IFLAG = 2
       DO 130 I = 1,NEQ
  130     Z(I) = 0.D0
       RETURN
  150  IFLAG = 1
 C-----------------------------------------------------------------------
 C The tolerance was not met, but the residual norm was reduced.
 C If performing restarting (IRST .gt. 0) calculate the residual vector
-C RL and store it in the DL array.  If the incomplete version is 
+C RL and store it in the DL array.  If the incomplete version is
 C being used (KMP .lt. MAXL) then DL has already been calculated.
 C-----------------------------------------------------------------------
       IF (IRST .GT. 0) THEN
          IF (KMP .EQ. MAXL) THEN
 C
 C           Calculate DL from the V(I)'s.
 C
             CALL DCOPY (NEQ, V(1,1), 1, DL, 1)
diff --git a/liboctave/cruft/daspk/dyypnw.f b/liboctave/cruft/daspk/dyypnw.f
--- a/liboctave/cruft/daspk/dyypnw.f
+++ b/liboctave/cruft/daspk/dyypnw.f
@@ -1,13 +1,13 @@
 C Work performed under the auspices of the U.S. Department of Energy
-C by Lawrence Livermore National Laboratory under contract number 
+C by Lawrence Livermore National Laboratory under contract number
 C W-7405-Eng-48.
 C
-      SUBROUTINE DYYPNW (NEQ, Y, YPRIME, CJ, RL, P, ICOPT, ID, 
+      SUBROUTINE DYYPNW (NEQ, Y, YPRIME, CJ, RL, P, ICOPT, ID,
      *                   YNEW, YPNEW)
 C
 C***BEGIN PROLOGUE  DYYPNW
 C***REFER TO  DLINSK
 C***DATE WRITTEN   940830   (YYMMDD)
 C
 C
 C-----------------------------------------------------------------------
diff --git a/liboctave/cruft/dasrt/ddasrt.f b/liboctave/cruft/dasrt/ddasrt.f
--- a/liboctave/cruft/dasrt/ddasrt.f
+++ b/liboctave/cruft/dasrt/ddasrt.f
@@ -849,17 +849,17 @@ C
 C                       *** Following a terminated task ***
 C     If IDID= -33, you cannot continue the solution of this
 C                  problem. An attempt to do so will result in your
 C                  run being terminated.
 C
 C  ---------------------------------------------------------------------
 C
 C***REFERENCE
-C      K. E. Brenan, S. L. Campbell, and L. R. Petzold, Numerical 
+C      K. E. Brenan, S. L. Campbell, and L. R. Petzold, Numerical
 C      Solution of Initial-Value Problems in Differential-Algebraic
 C      Equations, Elsevier, New York, 1989.
 C
 C***ROUTINES CALLED  DDASTP,DDAINI,DDANRM,DDAWTS,DDATRP,DRCHEK,DROOTS,
 C                    XERRWD,D1MACH
 C***END PROLOGUE  DDASRT
 C
 C**End
@@ -1279,17 +1279,17 @@ 525   CONTINUE
 C
 C     COMPUTE MINIMUM STEPSIZE
       HMIN=4.0D0*UROUND*DMAX1(DABS(TN),DABS(TOUT))
 C
 C     TEST H VS. HMAX
       IF (INFO(7) .EQ. 0) GO TO 526
          RH = ABS(H)/RWORK(LHMAX)
          IF (RH .GT. 1.0D0) H = H/RH
-526   CONTINUE     
+526   CONTINUE
 C
       CALL DDASTP(TN,Y,YPRIME,NEQ,
      *   RES,JAC,H,RWORK(LWT),INFO(1),IDID,RPAR,IPAR,
      *   RWORK(LPHI),RWORK(LDELTA),RWORK(LE),
      *   RWORK(LWM),IWORK(LIWM),
      *   RWORK(LALPHA),RWORK(LBETA),RWORK(LGAMMA),
      *   RWORK(LPSI),RWORK(LSIGMA),
      *   RWORK(LCJ),RWORK(LCJOLD),RWORK(LHOLD),
diff --git a/liboctave/cruft/dasrt/drchek.f b/liboctave/cruft/dasrt/drchek.f
--- a/liboctave/cruft/dasrt/drchek.f
+++ b/liboctave/cruft/dasrt/drchek.f
@@ -55,17 +55,17 @@ C          STORED IN THE GLOBAL ARRAY RW
 C TLAST  = LAST VALUE OF T RETURNED BY THE SOLVER (INPUT ONLY).
 C          STORED IN THE GLOBAL ARRAY RWORK.
 C TOUT   = FINAL OUTPUT TIME FOR THE SOLVER.
 C IRFND  = INPUT FLAG SHOWING WHETHER THE LAST STEP TAKEN HAD A ROOT.
 C          IRFND = 1 IF IT DID, = 0 IF NOT.
 C          STORED IN THE GLOBAL ARRAY IWORK.
 C INFO3  = COPY OF INFO(3) (INPUT ONLY).
 C-----------------------------------------------------------------------
-C     
+C
       H = PSI(1)
       IRT = 0
       DO 10 I = 1,NG
  10     JROOT(I) = 0
       HMING = (DABS(TN) + DABS(H))*UROUND*100.0D0
 C
       GO TO (100, 200, 300), JOB
 C
diff --git a/liboctave/cruft/dassl/ddaslv.f b/liboctave/cruft/dassl/ddaslv.f
--- a/liboctave/cruft/dassl/ddaslv.f
+++ b/liboctave/cruft/dassl/ddaslv.f
@@ -40,23 +40,23 @@ C
       PARAMETER (LMTYPE=4)
       PARAMETER (LIPVT=22)
 C
 C***FIRST EXECUTABLE STATEMENT  DDASLV
       MTYPE=IWM(LMTYPE)
       GO TO(100,100,300,400,400),MTYPE
 C
 C     DENSE MATRIX
-100   CALL DGETRS('N', NEQ, 1, WM(NPD), NEQ, IWM(LIPVT), DELTA, NEQ, 
+100   CALL DGETRS('N', NEQ, 1, WM(NPD), NEQ, IWM(LIPVT), DELTA, NEQ,
      *     INFO)
       RETURN
 C
 C     DUMMY SECTION FOR MTYPE=3
 300   CONTINUE
       RETURN
 C
 C     BANDED MATRIX
 400   MEBAND=2*IWM(LML)+IWM(LMU)+1
-      CALL DGBTRS ('N', NEQ, IWM(LML), IWM(LMU), 1, WM(NPD), MEBAND, 
+      CALL DGBTRS ('N', NEQ, IWM(LML), IWM(LMU), 1, WM(NPD), MEBAND,
      *     IWM(LIPVT), DELTA, NEQ, INLPCK)
       RETURN
 C------END OF SUBROUTINE DDASLV------
       END
diff --git a/liboctave/cruft/dassl/ddassl.f b/liboctave/cruft/dassl/ddassl.f
--- a/liboctave/cruft/dassl/ddassl.f
+++ b/liboctave/cruft/dassl/ddassl.f
@@ -1309,17 +1309,17 @@ 525   CONTINUE
 C
 C     COMPUTE MINIMUM STEPSIZE
       HMIN=4.0D0*UROUND*MAX(ABS(TN),ABS(TOUT))
 C
 C     TEST H VS. HMAX
       IF (INFO(7) .EQ. 0) GO TO 526
          RH = ABS(H)/RWORK(LHMAX)
          IF (RH .GT. 1.0D0) H = H/RH
-526   CONTINUE           
+526   CONTINUE
 C
       CALL DDASTP(TN,Y,YPRIME,NEQ,
      *   RES,JAC,H,RWORK(LWT),INFO(1),IDID,RPAR,IPAR,
      *   RWORK(LPHI),RWORK(LDELTA),RWORK(LE),
      *   RWORK(LWM),IWORK(LIWM),
      *   RWORK(LALPHA),RWORK(LBETA),RWORK(LGAMMA),
      *   RWORK(LPSI),RWORK(LSIGMA),
      *   RWORK(LCJ),RWORK(LCJOLD),RWORK(LHOLD),
diff --git a/liboctave/cruft/misc/blaswrap.c b/liboctave/cruft/misc/blaswrap.c
--- a/liboctave/cruft/misc/blaswrap.c
+++ b/liboctave/cruft/misc/blaswrap.c
@@ -144,17 +144,17 @@ typedef double (*F2C_CALL_8) (void *a1, 
     return ((F2C_CALL_0)f2c_lapack_func[f2c_ ## name]) (); \
   }
 
 #define F2C_LAPACK_CALL_NONE(name)
 
 #define F2C_LAPACK_CALL(name, args) F2C_LAPACK_CALL_ ## args (name)
 
 #define ENUM_ITEM(name, args)                   \
-  f2c_ ## name, 
+  f2c_ ## name,
 
 #define NAME_TO_STRING_CASE(name, args)         \
   case f2c_ ## name: return #name;
 
 #define DEFINE_LAPACK_ENUM(name, list)  \
   typedef enum {                        \
     list(ENUM_ITEM)                     \
   } name;                               \
diff --git a/liboctave/cruft/misc/module.mk b/liboctave/cruft/misc/module.mk
--- a/liboctave/cruft/misc/module.mk
+++ b/liboctave/cruft/misc/module.mk
@@ -1,11 +1,11 @@
 EXTRA_DIST += \
   misc/module.mk \
-  misc/d1mach-tst.for 
+  misc/d1mach-tst.for
 
 libcruft_la_SOURCES += \
   misc/blaswrap.c \
   misc/cquit.c \
   misc/d1mach.f \
   misc/f77-extern.cc \
   misc/f77-fcn.c \
   misc/i1mach.f \
diff --git a/liboctave/cruft/odepack/cfode.f b/liboctave/cruft/odepack/cfode.f
--- a/liboctave/cruft/odepack/cfode.f
+++ b/liboctave/cruft/odepack/cfode.f
@@ -5,29 +5,29 @@ CLLL. OPTIMIZE
       DOUBLE PRECISION ELCO, TESCO
       DOUBLE PRECISION AGAMQ, FNQ, FNQM1, PC, PINT, RAGQ,
      1   RQFAC, RQ1FAC, TSIGN, XPIN
       DIMENSION ELCO(13,12), TESCO(3,12)
 C-----------------------------------------------------------------------
 C CFODE IS CALLED BY THE INTEGRATOR ROUTINE TO SET COEFFICIENTS
 C NEEDED THERE.  THE COEFFICIENTS FOR THE CURRENT METHOD, AS
 C GIVEN BY THE VALUE OF METH, ARE SET FOR ALL ORDERS AND SAVED.
-C THE MAXIMUM ORDER ASSUMED HERE IS 12 IF METH = 1 AND 5 IF METH = 2. 
+C THE MAXIMUM ORDER ASSUMED HERE IS 12 IF METH = 1 AND 5 IF METH = 2.
 C (A SMALLER VALUE OF THE MAXIMUM ORDER IS ALSO ALLOWED.)
 C CFODE IS CALLED ONCE AT THE BEGINNING OF THE PROBLEM,
-C AND IS NOT CALLED AGAIN UNLESS AND UNTIL METH IS CHANGED. 
+C AND IS NOT CALLED AGAIN UNLESS AND UNTIL METH IS CHANGED.
 C
 C THE ELCO ARRAY CONTAINS THE BASIC METHOD COEFFICIENTS.
 C THE COEFFICIENTS EL(I), 1 .LE. I .LE. NQ+1, FOR THE METHOD OF
-C ORDER NQ ARE STORED IN ELCO(I,NQ).  THEY ARE GIVEN BY A GENETRATING 
-C POLYNOMIAL, I.E., 
+C ORDER NQ ARE STORED IN ELCO(I,NQ).  THEY ARE GIVEN BY A GENETRATING
+C POLYNOMIAL, I.E.,
 C     L(X) = EL(1) + EL(2)*X + ... + EL(NQ+1)*X**NQ.
 C FOR THE IMPLICIT ADAMS METHODS, L(X) IS GIVEN BY
-C     DL/DX = (X+1)*(X+2)*...*(X+NQ-1)/FACTORIAL(NQ-1),    L(-1) = 0. 
-C FOR THE BDF METHODS, L(X) IS GIVEN BY 
+C     DL/DX = (X+1)*(X+2)*...*(X+NQ-1)/FACTORIAL(NQ-1),    L(-1) = 0.
+C FOR THE BDF METHODS, L(X) IS GIVEN BY
 C     L(X) = (X+1)*(X+2)* ... *(X+NQ)/K,
 C WHERE         K = FACTORIAL(NQ)*(1 + 1/2 + ... + 1/NQ).
 C
 C THE TESCO ARRAY CONTAINS TEST CONSTANTS USED FOR THE
 C LOCAL ERROR TEST AND THE SELECTION OF STEP SIZE AND/OR ORDER.
 C AT ORDER NQ, TESCO(K,NQ) IS USED FOR THE SELECTION OF STEP
 C SIZE AT ORDER NQ - 1 IF K = 1, AT ORDER NQ IF K = 2, AND AT ORDER
 C NQ + 1 IF K = 3.
@@ -37,76 +37,76 @@ C
       GO TO (100, 200), METH
 C
  100  ELCO(1,1) = 1.0D0
       ELCO(2,1) = 1.0D0
       TESCO(1,1) = 0.0D0
       TESCO(2,1) = 2.0D0
       TESCO(1,2) = 1.0D0
       TESCO(3,12) = 0.0D0
-      PC(1) = 1.0D0 
-      RQFAC = 1.0D0 
+      PC(1) = 1.0D0
+      RQFAC = 1.0D0
       DO 140 NQ = 2,12
 C-----------------------------------------------------------------------
 C THE PC ARRAY WILL CONTAIN THE COEFFICIENTS OF THE POLYNOMIAL
 C     P(X) = (X+1)*(X+2)*...*(X+NQ-1).
 C INITIALLY, P(X) = 1.
 C-----------------------------------------------------------------------
         RQ1FAC = RQFAC
         RQFAC = RQFAC/DBLE(NQ)
         NQM1 = NQ - 1
-        FNQM1 = DBLE(NQM1)  
+        FNQM1 = DBLE(NQM1)
         NQP1 = NQ + 1
 C FORM COEFFICIENTS OF P(X)*(X+NQ-1). ----------------------------------
         PC(NQ) = 0.0D0
         DO 110 IB = 1,NQM1
           I = NQP1 - IB
- 110      PC(I) = PC(I-1) + FNQM1*PC(I) 
+ 110      PC(I) = PC(I-1) + FNQM1*PC(I)
         PC(1) = FNQM1*PC(1)
 C COMPUTE INTEGRAL, -1 TO 0, OF P(X) AND X*P(X). -----------------------
         PINT = PC(1)
         XPIN = PC(1)/2.0D0
         TSIGN = 1.0D0
         DO 120 I = 2,NQ
           TSIGN = -TSIGN
-          PINT = PINT + TSIGN*PC(I)/DBLE(I)     
- 120      XPIN = XPIN + TSIGN*PC(I)/DBLE(I+1)   
+          PINT = PINT + TSIGN*PC(I)/DBLE(I)
+ 120      XPIN = XPIN + TSIGN*PC(I)/DBLE(I+1)
 C STORE COEFFICIENTS IN ELCO AND TESCO. --------------------------------
         ELCO(1,NQ) = PINT*RQ1FAC
         ELCO(2,NQ) = 1.0D0
         DO 130 I = 2,NQ
- 130      ELCO(I+1,NQ) = RQ1FAC*PC(I)/DBLE(I)   
+ 130      ELCO(I+1,NQ) = RQ1FAC*PC(I)/DBLE(I)
         AGAMQ = RQFAC*XPIN
         RAGQ = 1.0D0/AGAMQ
         TESCO(2,NQ) = RAGQ
-        IF (NQ .LT. 12) TESCO(1,NQP1) = RAGQ*RQFAC/DBLE(NQP1)       
+        IF (NQ .LT. 12) TESCO(1,NQP1) = RAGQ*RQFAC/DBLE(NQP1)
         TESCO(3,NQM1) = RAGQ
  140    CONTINUE
       RETURN
 C
- 200  PC(1) = 1.0D0 
+ 200  PC(1) = 1.0D0
       RQ1FAC = 1.0D0
       DO 230 NQ = 1,5
 C-----------------------------------------------------------------------
 C THE PC ARRAY WILL CONTAIN THE COEFFICIENTS OF THE POLYNOMIAL
 C     P(X) = (X+1)*(X+2)*...*(X+NQ).
 C INITIALLY, P(X) = 1.
 C-----------------------------------------------------------------------
-        FNQ = DBLE(NQ)      
+        FNQ = DBLE(NQ)
         NQP1 = NQ + 1
 C FORM COEFFICIENTS OF P(X)*(X+NQ). ------------------------------------
         PC(NQP1) = 0.0D0
         DO 210 IB = 1,NQ
           I = NQ + 2 - IB
  210      PC(I) = PC(I-1) + FNQ*PC(I)
         PC(1) = FNQ*PC(1)
 C STORE COEFFICIENTS IN ELCO AND TESCO. --------------------------------
         DO 220 I = 1,NQP1
  220      ELCO(I,NQ) = PC(I)/PC(2)
         ELCO(2,NQ) = 1.0D0
         TESCO(1,NQ) = RQ1FAC
-        TESCO(2,NQ) = DBLE(NQP1)/ELCO(1,NQ)     
-        TESCO(3,NQ) = DBLE(NQ+2)/ELCO(1,NQ)     
+        TESCO(2,NQ) = DBLE(NQP1)/ELCO(1,NQ)
+        TESCO(3,NQ) = DBLE(NQ+2)/ELCO(1,NQ)
         RQ1FAC = RQ1FAC/FNQ
  230    CONTINUE
       RETURN
 C----------------------- END OF SUBROUTINE CFODE -----------------------
-      END 
+      END
diff --git a/liboctave/cruft/odepack/dlsode.f b/liboctave/cruft/odepack/dlsode.f
--- a/liboctave/cruft/odepack/dlsode.f
+++ b/liboctave/cruft/odepack/dlsode.f
@@ -1,106 +1,106 @@
       SUBROUTINE DLSODE (F, NEQ, Y, T, TOUT, ITOL, RTOL, ATOL, ITASK,
      1            ISTATE, IOPT, RWORK, LRW, IWORK, LIW, JAC, MF)
       EXTERNAL F, JAC
       INTEGER NEQ, ITOL, ITASK, ISTATE, IOPT, LRW, IWORK, LIW, MF
       DOUBLE PRECISION Y, T, TOUT, RTOL, ATOL, RWORK
       DIMENSION NEQ(*), Y(*), RTOL(*), ATOL(*), RWORK(LRW), IWORK(LIW)
 C-----------------------------------------------------------------------
-C THIS IS THE MARCH 30, 1987 VERSION OF 
+C THIS IS THE MARCH 30, 1987 VERSION OF
 C LSODE.. LIVERMORE SOLVER FOR ORDINARY DIFFERENTIAL EQUATIONS.
 C THIS VERSION IS IN DOUBLE PRECISION.
 C
 C LSODE SOLVES THE INITIAL VALUE PROBLEM FOR STIFF OR NONSTIFF
 C SYSTEMS OF FIRST ORDER ODE-S,
 C     DY/DT = F(T,Y) ,  OR, IN COMPONENT FORM,
 C     DY(I)/DT = F(I) = F(I,T,Y(1),Y(2),...,Y(NEQ)) (I = 1,...,NEQ).
-C LSODE IS A PACKAGE BASED ON THE GEAR AND GEARB PACKAGES, AND ON THE 
+C LSODE IS A PACKAGE BASED ON THE GEAR AND GEARB PACKAGES, AND ON THE
 C OCTOBER 23, 1978 VERSION OF THE TENTATIVE ODEPACK USER INTERFACE
 C STANDARD, WITH MINOR MODIFICATIONS.
 C-----------------------------------------------------------------------
 C REFERENCE..
 C     ALAN C. HINDMARSH,  ODEPACK, A SYSTEMATIZED COLLECTION OF ODE
 C     SOLVERS, IN SCIENTIFIC COMPUTING, R. S. STEPLEMAN ET AL. (EDS.),
 C     NORTH-HOLLAND, AMSTERDAM, 1983, PP. 55-64.
 C-----------------------------------------------------------------------
 C AUTHOR AND CONTACT.. ALAN C. HINDMARSH,
-C                      COMPUTING AND MATHEMATICS RESEARCH DIV., L-316 
+C                      COMPUTING AND MATHEMATICS RESEARCH DIV., L-316
 C                      LAWRENCE LIVERMORE NATIONAL LABORATORY
 C                      LIVERMORE, CA 94550.
 C-----------------------------------------------------------------------
-C SUMMARY OF USAGE. 
+C SUMMARY OF USAGE.
 C
 C COMMUNICATION BETWEEN THE USER AND THE LSODE PACKAGE, FOR NORMAL
 C SITUATIONS, IS SUMMARIZED HERE.  THIS SUMMARY DESCRIBES ONLY A SUBSET
-C OF THE FULL SET OF OPTIONS AVAILABLE.  SEE THE FULL DESCRIPTION FOR 
+C OF THE FULL SET OF OPTIONS AVAILABLE.  SEE THE FULL DESCRIPTION FOR
 C DETAILS, INCLUDING OPTIONAL COMMUNICATION, NONSTANDARD OPTIONS,
 C AND INSTRUCTIONS FOR SPECIAL SITUATIONS.  SEE ALSO THE EXAMPLE
-C PROBLEM (WITH PROGRAM AND OUTPUT) FOLLOWING THIS SUMMARY. 
+C PROBLEM (WITH PROGRAM AND OUTPUT) FOLLOWING THIS SUMMARY.
 C
 C A. FIRST PROVIDE A SUBROUTINE OF THE FORM..
 C               SUBROUTINE F (NEQ, T, Y, YDOT, IERR)
 C               DIMENSION Y(NEQ), YDOT(NEQ)
 C WHICH SUPPLIES THE VECTOR FUNCTION F BY LOADING YDOT(I) WITH F(I).
 C
 C B. NEXT DETERMINE (OR GUESS) WHETHER OR NOT THE PROBLEM IS STIFF.
 C STIFFNESS OCCURS WHEN THE JACOBIAN MATRIX DF/DY HAS AN EIGENVALUE
-C WHOSE REAL PART IS NEGATIVE AND LARGE IN MAGNITUDE, COMPARED TO THE 
+C WHOSE REAL PART IS NEGATIVE AND LARGE IN MAGNITUDE, COMPARED TO THE
 C RECIPROCAL OF THE T SPAN OF INTEREST.  IF THE PROBLEM IS NONSTIFF,
-C USE A METHOD FLAG MF = 10.  IF IT IS STIFF, THERE ARE FOUR STANDARD 
+C USE A METHOD FLAG MF = 10.  IF IT IS STIFF, THERE ARE FOUR STANDARD
 C CHOICES FOR MF, AND LSODE REQUIRES THE JACOBIAN MATRIX IN SOME FORM.
 C THIS MATRIX IS REGARDED EITHER AS FULL (MF = 21 OR 22),
 C OR BANDED (MF = 24 OR 25).  IN THE BANDED CASE, LSODE REQUIRES TWO
 C HALF-BANDWIDTH PARAMETERS ML AND MU.  THESE ARE, RESPECTIVELY, THE
-C WIDTHS OF THE LOWER AND UPPER PARTS OF THE BAND, EXCLUDING THE MAIN 
+C WIDTHS OF THE LOWER AND UPPER PARTS OF THE BAND, EXCLUDING THE MAIN
 C DIAGONAL.  THUS THE BAND CONSISTS OF THE LOCATIONS (I,J) WITH
-C I-ML .LE. J .LE. I+MU, AND THE FULL BANDWIDTH IS ML+MU+1. 
+C I-ML .LE. J .LE. I+MU, AND THE FULL BANDWIDTH IS ML+MU+1.
 C
 C C. IF THE PROBLEM IS STIFF, YOU ARE ENCOURAGED TO SUPPLY THE JACOBIAN
 C DIRECTLY (MF = 21 OR 24), BUT IF THIS IS NOT FEASIBLE, LSODE WILL
 C COMPUTE IT INTERNALLY BY DIFFERENCE QUOTIENTS (MF = 22 OR 25).
 C IF YOU ARE SUPPLYING THE JACOBIAN, PROVIDE A SUBROUTINE OF THE FORM..
 C               SUBROUTINE JAC (NEQ, T, Y, ML, MU, PD, NROWPD)
 C               DIMENSION Y(NEQ), PD(NROWPD,NEQ)
-C WHICH SUPPLIES DF/DY BY LOADING PD AS FOLLOWS.. 
+C WHICH SUPPLIES DF/DY BY LOADING PD AS FOLLOWS..
 C     FOR A FULL JACOBIAN (MF = 21), LOAD PD(I,J) WITH DF(I)/DY(J),
 C THE PARTIAL DERIVATIVE OF F(I) WITH RESPECT TO Y(J).  (IGNORE THE
 C ML AND MU ARGUMENTS IN THIS CASE.)
 C     FOR A BANDED JACOBIAN (MF = 24), LOAD PD(I-J+MU+1,J) WITH
-C DF(I)/DY(J), I.E. LOAD THE DIAGONAL LINES OF DF/DY INTO THE ROWS OF 
+C DF(I)/DY(J), I.E. LOAD THE DIAGONAL LINES OF DF/DY INTO THE ROWS OF
 C PD FROM THE TOP DOWN.
-C     IN EITHER CASE, ONLY NONZERO ELEMENTS NEED BE LOADED. 
+C     IN EITHER CASE, ONLY NONZERO ELEMENTS NEED BE LOADED.
 C
 C D. WRITE A MAIN PROGRAM WHICH CALLS SUBROUTINE LSODE ONCE FOR
 C EACH POINT AT WHICH ANSWERS ARE DESIRED.  THIS SHOULD ALSO PROVIDE
 C FOR POSSIBLE USE OF LOGICAL UNIT 6 FOR OUTPUT OF ERROR MESSAGES
 C BY LSODE.  ON THE FIRST CALL TO LSODE, SUPPLY ARGUMENTS AS FOLLOWS..
-C F      = NAME OF SUBROUTINE FOR RIGHT-HAND SIDE VECTOR F. 
+C F      = NAME OF SUBROUTINE FOR RIGHT-HAND SIDE VECTOR F.
 C          THIS NAME MUST BE DECLARED EXTERNAL IN CALLING PROGRAM.
-C NEQ    = NUMBER OF FIRST ORDER ODE-S. 
+C NEQ    = NUMBER OF FIRST ORDER ODE-S.
 C Y      = ARRAY OF INITIAL VALUES, OF LENGTH NEQ.
 C T      = THE INITIAL VALUE OF THE INDEPENDENT VARIABLE.
 C TOUT   = FIRST POINT WHERE OUTPUT IS DESIRED (.NE. T).
 C ITOL   = 1 OR 2 ACCORDING AS ATOL (BELOW) IS A SCALAR OR ARRAY.
-C RTOL   = RELATIVE TOLERANCE PARAMETER (SCALAR). 
+C RTOL   = RELATIVE TOLERANCE PARAMETER (SCALAR).
 C ATOL   = ABSOLUTE TOLERANCE PARAMETER (SCALAR OR ARRAY).
-C          THE ESTIMATED LOCAL ERROR IN Y(I) WILL BE CONTROLLED SO AS 
-C          TO BE ROUGHLY LESS (IN MAGNITUDE) THAN 
+C          THE ESTIMATED LOCAL ERROR IN Y(I) WILL BE CONTROLLED SO AS
+C          TO BE ROUGHLY LESS (IN MAGNITUDE) THAN
 C             EWT(I) = RTOL*ABS(Y(I)) + ATOL     IF ITOL = 1, OR
 C             EWT(I) = RTOL*ABS(Y(I)) + ATOL(I)  IF ITOL = 2.
 C          THUS THE LOCAL ERROR TEST PASSES IF, IN EACH COMPONENT,
 C          EITHER THE ABSOLUTE ERROR IS LESS THAN ATOL (OR ATOL(I)),
 C          OR THE RELATIVE ERROR IS LESS THAN RTOL.
 C          USE RTOL = 0.0 FOR PURE ABSOLUTE ERROR CONTROL, AND
 C          USE ATOL = 0.0 (OR ATOL(I) = 0.0) FOR PURE RELATIVE ERROR
 C          CONTROL.  CAUTION.. ACTUAL (GLOBAL) ERRORS MAY EXCEED THESE
-C          LOCAL TOLERANCES, SO CHOOSE THEM CONSERVATIVELY. 
+C          LOCAL TOLERANCES, SO CHOOSE THEM CONSERVATIVELY.
 C ITASK  = 1 FOR NORMAL COMPUTATION OF OUTPUT VALUES OF Y AT T = TOUT.
 C ISTATE = INTEGER FLAG (INPUT AND OUTPUT).  SET ISTATE = 1.
-C IOPT   = 0 TO INDICATE NO OPTIONAL INPUTS USED. 
+C IOPT   = 0 TO INDICATE NO OPTIONAL INPUTS USED.
 C RWORK  = REAL WORK ARRAY OF LENGTH AT LEAST..
 C             20 + 16*NEQ                    FOR MF = 10,
 C             22 +  9*NEQ + NEQ**2           FOR MF = 21 OR 22,
 C             22 + 10*NEQ + (2*ML + MU)*NEQ  FOR MF = 24 OR 25.
 C LRW    = DECLARED LENGTH OF RWORK (IN USER-S DIMENSION).
 C IWORK  = INTEGER WORK ARRAY OF LENGTH AT LEAST..
 C             20        FOR MF = 10,
 C             20 + NEQ  FOR MF = 21, 22, 24, OR 25.
@@ -110,26 +110,26 @@ C LIW    = DECLARED LENGTH OF IWORK (IN 
 C JAC    = NAME OF SUBROUTINE FOR JACOBIAN MATRIX (MF = 21 OR 24).
 C          IF USED, THIS NAME MUST BE DECLARED EXTERNAL IN CALLING
 C          PROGRAM.  IF NOT USED, PASS A DUMMY NAME.
 C MF     = METHOD FLAG.  STANDARD VALUES ARE..
 C          10 FOR NONSTIFF (ADAMS) METHOD, NO JACOBIAN USED.
 C          21 FOR STIFF (BDF) METHOD, USER-SUPPLIED FULL JACOBIAN.
 C          22 FOR STIFF METHOD, INTERNALLY GENERATED FULL JACOBIAN.
 C          24 FOR STIFF METHOD, USER-SUPPLIED BANDED JACOBIAN.
-C          25 FOR STIFF METHOD, INTERNALLY GENERATED BANDED JACOBIAN. 
+C          25 FOR STIFF METHOD, INTERNALLY GENERATED BANDED JACOBIAN.
 C NOTE THAT THE MAIN PROGRAM MUST DECLARE ARRAYS Y, RWORK, IWORK,
 C AND POSSIBLY ATOL.
 C
 C E. THE OUTPUT FROM THE FIRST CALL (OR ANY CALL) IS..
 C      Y = ARRAY OF COMPUTED VALUES OF Y(T) VECTOR.
 C      T = CORRESPONDING VALUE OF INDEPENDENT VARIABLE (NORMALLY TOUT).
 C ISTATE = 2  IF LSODE WAS SUCCESSFUL, NEGATIVE OTHERWISE.
-C          -1 MEANS EXCESS WORK DONE ON THIS CALL (PERHAPS WRONG MF). 
-C          -2 MEANS EXCESS ACCURACY REQUESTED (TOLERANCES TOO SMALL). 
+C          -1 MEANS EXCESS WORK DONE ON THIS CALL (PERHAPS WRONG MF).
+C          -2 MEANS EXCESS ACCURACY REQUESTED (TOLERANCES TOO SMALL).
 C          -3 MEANS ILLEGAL INPUT DETECTED (SEE PRINTED MESSAGE).
 C          -4 MEANS REPEATED ERROR TEST FAILURES (CHECK ALL INPUTS).
 C          -5 MEANS REPEATED CONVERGENCE FAILURES (PERHAPS BAD JACOBIAN
 C             SUPPLIED OR WRONG CHOICE OF MF OR TOLERANCES).
 C          -6 MEANS ERROR WEIGHT BECAME ZERO DURING PROBLEM. (SOLUTION
 C             COMPONENT I VANISHED, AND ATOL OR ATOL(I) = 0.)
 C         -13 MEANS EXIT REQUESTED IN USER-SUPPLIED FUNCTION.
 C
@@ -146,17 +146,17 @@ C     DY1/DT = -.04*Y1 + 1.E4*Y2*Y3
 C     DY2/DT = .04*Y1 - 1.E4*Y2*Y3 - 3.E7*Y2**2
 C     DY3/DT = 3.E7*Y2**2
 C ON THE INTERVAL FROM T = 0.0 TO T = 4.E10, WITH INITIAL CONDITIONS
 C Y1 = 1.0, Y2 = Y3 = 0.  THE PROBLEM IS STIFF.
 C
 C THE FOLLOWING CODING SOLVES THIS PROBLEM WITH LSODE, USING MF = 21
 C AND PRINTING RESULTS AT T = .4, 4., ..., 4.E10.  IT USES
 C ITOL = 2 AND ATOL MUCH SMALLER FOR Y2 THAN Y1 OR Y3 BECAUSE
-C Y2 HAS MUCH SMALLER VALUES. 
+C Y2 HAS MUCH SMALLER VALUES.
 C AT THE END OF THE RUN, STATISTICAL QUANTITIES OF INTEREST ARE
 C PRINTED (SEE OPTIONAL OUTPUTS IN THE FULL DESCRIPTION BELOW).
 C
 C     EXTERNAL FEX, JEX
 C     DOUBLE PRECISION ATOL, RTOL, RWORK, T, TOUT, Y
 C     DIMENSION Y(3), ATOL(3), RWORK(58), IWORK(23)
 C     NEQ = 3
 C     Y(1) = 1.D0
@@ -178,44 +178,44 @@ C     MF = 21
 C     DO 40 IOUT = 1,12
 C       CALL LSODE(FEX,NEQ,Y,T,TOUT,ITOL,RTOL,ATOL,ITASK,ISTATE,
 C    1     IOPT,RWORK,LRW,IWORK,LIW,JEX,MF)
 C       WRITE(6,20)T,Y(1),Y(2),Y(3)
 C 20    FORMAT(7H AT T =,E12.4,6H   Y =,3E14.6)
 C       IF (ISTATE .LT. 0) GO TO 80
 C 40    TOUT = TOUT*10.D0
 C     WRITE(6,60)IWORK(11),IWORK(12),IWORK(13)
-C 60  FORMAT(/12H NO. STEPS =,I4,11H  NO. F-S =,I4,11H  NO. J-S =,I4) 
+C 60  FORMAT(/12H NO. STEPS =,I4,11H  NO. F-S =,I4,11H  NO. J-S =,I4)
 C     STOP
 C 80  WRITE(6,90)ISTATE
 C 90  FORMAT(///22H ERROR HALT.. ISTATE =,I3)
 C     STOP
-C     END 
+C     END
 C
 C     SUBROUTINE FEX (NEQ, T, Y, YDOT)
 C     DOUBLE PRECISION T, Y, YDOT
-C     DIMENSION Y(3), YDOT(3) 
+C     DIMENSION Y(3), YDOT(3)
 C     YDOT(1) = -.04D0*Y(1) + 1.D4*Y(2)*Y(3)
 C     YDOT(3) = 3.D7*Y(2)*Y(2)
 C     YDOT(2) = -YDOT(1) - YDOT(3)
 C     RETURN
-C     END 
+C     END
 C
 C     SUBROUTINE JEX (NEQ, T, Y, ML, MU, PD, NRPD)
 C     DOUBLE PRECISION PD, T, Y
 C     DIMENSION Y(3), PD(NRPD,3)
 C     PD(1,1) = -.04D0
 C     PD(1,2) = 1.D4*Y(3)
 C     PD(1,3) = 1.D4*Y(2)
 C     PD(2,1) = .04D0
 C     PD(2,3) = -PD(1,3)
 C     PD(3,2) = 6.D7*Y(2)
 C     PD(2,2) = -PD(1,2) - PD(3,2)
 C     RETURN
-C     END 
+C     END
 C
 C THE OUTPUT OF THIS PROGRAM (ON A CDC-7600 IN SINGLE PRECISION)
 C IS AS FOLLOWS..
 C
 C   AT T =  4.0000E-01   Y =  9.851726E-01  3.386406E-05  1.479357E-02
 C   AT T =  4.0000E+00   Y =  9.055142E-01  2.240418E-05  9.446344E-02
 C   AT T =  4.0000E+01   Y =  7.158050E-01  9.184616E-06  2.841858E-01
 C   AT T =  4.0000E+02   Y =  4.504846E-01  3.222434E-06  5.495122E-01
@@ -223,115 +223,115 @@ C   AT T =  4.0000E+03   Y =  1.831701E-
 C   AT T =  4.0000E+04   Y =  3.897016E-02  1.621193E-07  9.610297E-01
 C   AT T =  4.0000E+05   Y =  4.935213E-03  1.983756E-08  9.950648E-01
 C   AT T =  4.0000E+06   Y =  5.159269E-04  2.064759E-09  9.994841E-01
 C   AT T =  4.0000E+07   Y =  5.306413E-05  2.122677E-10  9.999469E-01
 C   AT T =  4.0000E+08   Y =  5.494529E-06  2.197824E-11  9.999945E-01
 C   AT T =  4.0000E+09   Y =  5.129458E-07  2.051784E-12  9.999995E-01
 C   AT T =  4.0000E+10   Y = -7.170586E-08 -2.868234E-13  1.000000E+00
 C
-C   NO. STEPS = 330  NO. F-S = 405  NO. J-S =  69 
+C   NO. STEPS = 330  NO. F-S = 405  NO. J-S =  69
 C-----------------------------------------------------------------------
 C FULL DESCRIPTION OF USER INTERFACE TO LSODE.
 C
 C THE USER INTERFACE TO LSODE CONSISTS OF THE FOLLOWING PARTS.
 C
 C I.   THE CALL SEQUENCE TO SUBROUTINE LSODE, WHICH IS A DRIVER
 C      ROUTINE FOR THE SOLVER.  THIS INCLUDES DESCRIPTIONS OF BOTH
 C      THE CALL SEQUENCE ARGUMENTS AND OF USER-SUPPLIED ROUTINES.
 C      FOLLOWING THESE DESCRIPTIONS IS A DESCRIPTION OF
 C      OPTIONAL INPUTS AVAILABLE THROUGH THE CALL SEQUENCE, AND THEN
 C      A DESCRIPTION OF OPTIONAL OUTPUTS (IN THE WORK ARRAYS).
 C
 C II.  DESCRIPTIONS OF OTHER ROUTINES IN THE LSODE PACKAGE THAT MAY BE
-C      (OPTIONALLY) CALLED BY THE USER.  THESE PROVIDE THE ABILITY TO 
+C      (OPTIONALLY) CALLED BY THE USER.  THESE PROVIDE THE ABILITY TO
 C      ALTER ERROR MESSAGE HANDLING, SAVE AND RESTORE THE INTERNAL
-C      COMMON, AND OBTAIN SPECIFIED DERIVATIVES OF THE SOLUTION Y(T). 
+C      COMMON, AND OBTAIN SPECIFIED DERIVATIVES OF THE SOLUTION Y(T).
 C
 C III. DESCRIPTIONS OF COMMON BLOCKS TO BE DECLARED IN OVERLAY
 C      OR SIMILAR ENVIRONMENTS, OR TO BE SAVED WHEN DOING AN INTERRUPT
 C      OF THE PROBLEM AND CONTINUED SOLUTION LATER.
 C
 C IV.  DESCRIPTION OF TWO ROUTINES IN THE LSODE PACKAGE, EITHER OF
 C      WHICH THE USER MAY REPLACE WITH HIS OWN VERSION, IF DESIRED.
-C      THESE RELATE TO THE MEASUREMENT OF ERRORS. 
+C      THESE RELATE TO THE MEASUREMENT OF ERRORS.
 C
 C-----------------------------------------------------------------------
 C PART I.  CALL SEQUENCE.
 C
 C THE CALL SEQUENCE PARAMETERS USED FOR INPUT ONLY ARE
-C     F, NEQ, TOUT, ITOL, RTOL, ATOL, ITASK, IOPT, LRW, LIW, JAC, MF, 
+C     F, NEQ, TOUT, ITOL, RTOL, ATOL, ITASK, IOPT, LRW, LIW, JAC, MF,
 C AND THOSE USED FOR BOTH INPUT AND OUTPUT ARE
-C     Y, T, ISTATE. 
+C     Y, T, ISTATE.
 C THE WORK ARRAYS RWORK AND IWORK ARE ALSO USED FOR CONDITIONAL AND
-C OPTIONAL INPUTS AND OPTIONAL OUTPUTS.  (THE TERM OUTPUT HERE REFERS 
-C TO THE RETURN FROM SUBROUTINE LSODE TO THE USER-S CALLING PROGRAM.) 
+C OPTIONAL INPUTS AND OPTIONAL OUTPUTS.  (THE TERM OUTPUT HERE REFERS
+C TO THE RETURN FROM SUBROUTINE LSODE TO THE USER-S CALLING PROGRAM.)
 C
 C THE LEGALITY OF INPUT PARAMETERS WILL BE THOROUGHLY CHECKED ON THE
 C INITIAL CALL FOR THE PROBLEM, BUT NOT CHECKED THEREAFTER UNLESS A
 C CHANGE IN INPUT PARAMETERS IS FLAGGED BY ISTATE = 3 ON INPUT.
 C
 C THE DESCRIPTIONS OF THE CALL ARGUMENTS ARE AS FOLLOWS.
 C
 C F      = THE NAME OF THE USER-SUPPLIED SUBROUTINE DEFINING THE
 C          ODE SYSTEM.  THE SYSTEM MUST BE PUT IN THE FIRST-ORDER
 C          FORM DY/DT = F(T,Y), WHERE F IS A VECTOR-VALUED FUNCTION
 C          OF THE SCALAR T AND THE VECTOR Y.  SUBROUTINE F IS TO
 C          COMPUTE THE FUNCTION F.  IT IS TO HAVE THE FORM
 C               SUBROUTINE F (NEQ, T, Y, YDOT)
-C               DIMENSION Y(1), YDOT(1) 
-C          WHERE NEQ, T, AND Y ARE INPUT, AND THE ARRAY YDOT = F(T,Y) 
-C          IS OUTPUT.  Y AND YDOT ARE ARRAYS OF LENGTH NEQ. 
+C               DIMENSION Y(1), YDOT(1)
+C          WHERE NEQ, T, AND Y ARE INPUT, AND THE ARRAY YDOT = F(T,Y)
+C          IS OUTPUT.  Y AND YDOT ARE ARRAYS OF LENGTH NEQ.
 C          (IN THE DIMENSION STATEMENT ABOVE, 1 IS A DUMMY
 C          DIMENSION.. IT CAN BE REPLACED BY ANY VALUE.)
 C          SUBROUTINE F SHOULD NOT ALTER Y(1),...,Y(NEQ).
 C          F MUST BE DECLARED EXTERNAL IN THE CALLING PROGRAM.
 C
 C          SUBROUTINE F MAY ACCESS USER-DEFINED QUANTITIES IN
 C          NEQ(2),... AND/OR IN Y(NEQ(1)+1),... IF NEQ IS AN ARRAY
 C          (DIMENSIONED IN F) AND/OR Y HAS LENGTH EXCEEDING NEQ(1).
 C          SEE THE DESCRIPTIONS OF NEQ AND Y BELOW.
 C
 C          IF QUANTITIES COMPUTED IN THE F ROUTINE ARE NEEDED
 C          EXTERNALLY TO LSODE, AN EXTRA CALL TO F SHOULD BE MADE
 C          FOR THIS PURPOSE, FOR CONSISTENT AND ACCURATE RESULTS.
-C          IF ONLY THE DERIVATIVE DY/DT IS NEEDED, USE INTDY INSTEAD. 
+C          IF ONLY THE DERIVATIVE DY/DT IS NEEDED, USE INTDY INSTEAD.
 C
 C NEQ    = THE SIZE OF THE ODE SYSTEM (NUMBER OF FIRST ORDER
 C          ORDINARY DIFFERENTIAL EQUATIONS).  USED ONLY FOR INPUT.
 C          NEQ MAY BE DECREASED, BUT NOT INCREASED, DURING THE PROBLEM.
 C          IF NEQ IS DECREASED (WITH ISTATE = 3 ON INPUT), THE
 C          REMAINING COMPONENTS OF Y SHOULD BE LEFT UNDISTURBED, IF
 C          THESE ARE TO BE ACCESSED IN F AND/OR JAC.
 C
-C          NORMALLY, NEQ IS A SCALAR, AND IT IS GENERALLY REFERRED TO 
+C          NORMALLY, NEQ IS A SCALAR, AND IT IS GENERALLY REFERRED TO
 C          AS A SCALAR IN THIS USER INTERFACE DESCRIPTION.  HOWEVER,
 C          NEQ MAY BE AN ARRAY, WITH NEQ(1) SET TO THE SYSTEM SIZE.
-C          (THE LSODE PACKAGE ACCESSES ONLY NEQ(1).)  IN EITHER CASE, 
+C          (THE LSODE PACKAGE ACCESSES ONLY NEQ(1).)  IN EITHER CASE,
 C          THIS PARAMETER IS PASSED AS THE NEQ ARGUMENT IN ALL CALLS
 C          TO F AND JAC.  HENCE, IF IT IS AN ARRAY, LOCATIONS
 C          NEQ(2),... MAY BE USED TO STORE OTHER INTEGER DATA AND PASS
-C          IT TO F AND/OR JAC.  SUBROUTINES F AND/OR JAC MUST INCLUDE 
+C          IT TO F AND/OR JAC.  SUBROUTINES F AND/OR JAC MUST INCLUDE
 C          NEQ IN A DIMENSION STATEMENT IN THAT CASE.
 C
 C Y      = A REAL ARRAY FOR THE VECTOR OF DEPENDENT VARIABLES, OF
-C          LENGTH NEQ OR MORE.  USED FOR BOTH INPUT AND OUTPUT ON THE 
+C          LENGTH NEQ OR MORE.  USED FOR BOTH INPUT AND OUTPUT ON THE
 C          FIRST CALL (ISTATE = 1), AND ONLY FOR OUTPUT ON OTHER CALLS.
 C          ON THE FIRST CALL, Y MUST CONTAIN THE VECTOR OF INITIAL
 C          VALUES.  ON OUTPUT, Y CONTAINS THE COMPUTED SOLUTION VECTOR,
 C          EVALUATED AT T.  IF DESIRED, THE Y ARRAY MAY BE USED
 C          FOR OTHER PURPOSES BETWEEN CALLS TO THE SOLVER.
 C
 C          THIS ARRAY IS PASSED AS THE Y ARGUMENT IN ALL CALLS TO
-C          F AND JAC.  HENCE ITS LENGTH MAY EXCEED NEQ, AND LOCATIONS 
+C          F AND JAC.  HENCE ITS LENGTH MAY EXCEED NEQ, AND LOCATIONS
 C          Y(NEQ+1),... MAY BE USED TO STORE OTHER REAL DATA AND
-C          PASS IT TO F AND/OR JAC.  (THE LSODE PACKAGE ACCESSES ONLY 
+C          PASS IT TO F AND/OR JAC.  (THE LSODE PACKAGE ACCESSES ONLY
 C          Y(1),...,Y(NEQ).)
 C
-C T      = THE INDEPENDENT VARIABLE.  ON INPUT, T IS USED ONLY ON THE 
+C T      = THE INDEPENDENT VARIABLE.  ON INPUT, T IS USED ONLY ON THE
 C          FIRST CALL, AS THE INITIAL POINT OF THE INTEGRATION.
 C          ON OUTPUT, AFTER EACH CALL, T IS THE VALUE AT WHICH A
 C          COMPUTED SOLUTION Y IS EVALUATED (USUALLY THE SAME AS TOUT).
 C          ON AN ERROR RETURN, T IS THE FARTHEST POINT REACHED.
 C
 C TOUT   = THE NEXT VALUE OF T AT WHICH A COMPUTED SOLUTION IS DESIRED.
 C          USED ONLY FOR INPUT.
 C
@@ -348,33 +348,33 @@ C          THE FIRST CALL (I.E. THE FIRS
 C          OTHERWISE, TOUT IS REQUIRED ON EVERY CALL.
 C
 C          IF ITASK = 1, 3, OR 4, THE VALUES OF TOUT NEED NOT BE
 C          MONOTONE, BUT A VALUE OF TOUT WHICH BACKS UP IS LIMITED
 C          TO THE CURRENT INTERNAL T INTERVAL, WHOSE ENDPOINTS ARE
 C          TCUR - HU AND TCUR (SEE OPTIONAL OUTPUTS, BELOW, FOR
 C          TCUR AND HU).
 C
-C ITOL   = AN INDICATOR FOR THE TYPE OF ERROR CONTROL.  SEE 
+C ITOL   = AN INDICATOR FOR THE TYPE OF ERROR CONTROL.  SEE
 C          DESCRIPTION BELOW UNDER ATOL.  USED ONLY FOR INPUT.
 C
 C RTOL   = A RELATIVE ERROR TOLERANCE PARAMETER, EITHER A SCALAR OR
-C          AN ARRAY OF LENGTH NEQ.  SEE DESCRIPTION BELOW UNDER ATOL. 
+C          AN ARRAY OF LENGTH NEQ.  SEE DESCRIPTION BELOW UNDER ATOL.
 C          INPUT ONLY.
 C
 C ATOL   = AN ABSOLUTE ERROR TOLERANCE PARAMETER, EITHER A SCALAR OR
 C          AN ARRAY OF LENGTH NEQ.  INPUT ONLY.
 C
 C             THE INPUT PARAMETERS ITOL, RTOL, AND ATOL DETERMINE
 C          THE ERROR CONTROL PERFORMED BY THE SOLVER.  THE SOLVER WILL
 C          CONTROL THE VECTOR E = (E(I)) OF ESTIMATED LOCAL ERRORS
 C          IN Y, ACCORDING TO AN INEQUALITY OF THE FORM
 C                      RMS-NORM OF ( E(I)/EWT(I) )   .LE.   1,
 C          WHERE       EWT(I) = RTOL(I)*ABS(Y(I)) + ATOL(I),
-C          AND THE RMS-NORM (ROOT-MEAN-SQUARE NORM) HERE IS 
+C          AND THE RMS-NORM (ROOT-MEAN-SQUARE NORM) HERE IS
 C          RMS-NORM(V) = SQRT(SUM V(I)**2 / NEQ).  HERE EWT = (EWT(I))
 C          IS A VECTOR OF WEIGHTS WHICH MUST ALWAYS BE POSITIVE, AND
 C          THE VALUES OF RTOL AND ATOL SHOULD ALL BE NON-NEGATIVE.
 C          THE FOLLOWING TABLE GIVES THE TYPES (SCALAR/ARRAY) OF
 C          RTOL AND ATOL, AND THE CORRESPONDING FORM OF EWT(I).
 C
 C             ITOL    RTOL       ATOL          EWT(I)
 C              1     SCALAR     SCALAR     RTOL*ABS(Y(I)) + ATOL
@@ -388,33 +388,33 @@ C
 C          IF NONE OF THE ABOVE CHOICES (WITH ITOL, RTOL, AND ATOL
 C          FIXED THROUGHOUT THE PROBLEM) IS SUITABLE, MORE GENERAL
 C          ERROR CONTROLS CAN BE OBTAINED BY SUBSTITUTING
 C          USER-SUPPLIED ROUTINES FOR THE SETTING OF EWT AND/OR FOR
 C          THE NORM CALCULATION.  SEE PART IV BELOW.
 C
 C          IF GLOBAL ERRORS ARE TO BE ESTIMATED BY MAKING A REPEATED
 C          RUN ON THE SAME PROBLEM WITH SMALLER TOLERANCES, THEN ALL
-C          COMPONENTS OF RTOL AND ATOL (I.E. OF EWT) SHOULD BE SCALED 
+C          COMPONENTS OF RTOL AND ATOL (I.E. OF EWT) SHOULD BE SCALED
 C          DOWN UNIFORMLY.
 C
 C ITASK  = AN INDEX SPECIFYING THE TASK TO BE PERFORMED.
 C          INPUT ONLY.  ITASK HAS THE FOLLOWING VALUES AND MEANINGS.
 C          1  MEANS NORMAL COMPUTATION OF OUTPUT VALUES OF Y(T) AT
-C             T = TOUT (BY OVERSHOOTING AND INTERPOLATING). 
+C             T = TOUT (BY OVERSHOOTING AND INTERPOLATING).
 C          2  MEANS TAKE ONE STEP ONLY AND RETURN.
 C          3  MEANS STOP AT THE FIRST INTERNAL MESH POINT AT OR
 C             BEYOND T = TOUT AND RETURN.
 C          4  MEANS NORMAL COMPUTATION OF OUTPUT VALUES OF Y(T) AT
 C             T = TOUT BUT WITHOUT OVERSHOOTING T = TCRIT.
-C             TCRIT MUST BE INPUT AS RWORK(1).  TCRIT MAY BE EQUAL TO 
+C             TCRIT MUST BE INPUT AS RWORK(1).  TCRIT MAY BE EQUAL TO
 C             OR BEYOND TOUT, BUT NOT BEHIND IT IN THE DIRECTION OF
 C             INTEGRATION.  THIS OPTION IS USEFUL IF THE PROBLEM
 C             HAS A SINGULARITY AT OR BEYOND T = TCRIT.
-C          5  MEANS TAKE ONE STEP, WITHOUT PASSING TCRIT, AND RETURN. 
+C          5  MEANS TAKE ONE STEP, WITHOUT PASSING TCRIT, AND RETURN.
 C             TCRIT MUST BE INPUT AS RWORK(1).
 C
 C          NOTE..  IF ITASK = 4 OR 5 AND THE SOLVER REACHES TCRIT
 C          (WITHIN ROUNDOFF), IT WILL RETURN T = TCRIT (EXACTLY) TO
 C          INDICATE THIS (UNLESS ITASK = 4 AND TOUT COMES BEFORE TCRIT,
 C          IN WHICH CASE ANSWERS AT T = TOUT ARE RETURNED FIRST).
 C
 C ISTATE = AN INDEX USED FOR INPUT AND OUTPUT TO SPECIFY THE
@@ -425,17 +425,17 @@ C          1  MEANS THIS IS THE FIRST CA
 C             (INITIALIZATIONS WILL BE DONE).  SEE NOTE BELOW.
 C          2  MEANS THIS IS NOT THE FIRST CALL, AND THE CALCULATION
 C             IS TO CONTINUE NORMALLY, WITH NO CHANGE IN ANY INPUT
 C             PARAMETERS EXCEPT POSSIBLY TOUT AND ITASK.
 C             (IF ITOL, RTOL, AND/OR ATOL ARE CHANGED BETWEEN CALLS
 C             WITH ISTATE = 2, THE NEW VALUES WILL BE USED BUT NOT
 C             TESTED FOR LEGALITY.)
 C          3  MEANS THIS IS NOT THE FIRST CALL, AND THE
-C             CALCULATION IS TO CONTINUE NORMALLY, BUT WITH 
+C             CALCULATION IS TO CONTINUE NORMALLY, BUT WITH
 C             A CHANGE IN INPUT PARAMETERS OTHER THAN
 C             TOUT AND ITASK.  CHANGES ARE ALLOWED IN
 C             NEQ, ITOL, RTOL, ATOL, IOPT, LRW, LIW, MF, ML, MU,
 C             AND ANY OF THE OPTIONAL INPUTS EXCEPT H0.
 C             (SEE IWORK DESCRIPTION FOR ML AND MU.)
 C          NOTE..  A PRELIMINARY CALL WITH TOUT = T IS NOT COUNTED
 C          AS A FIRST CALL HERE, AS NO INITIALIZATION OR CHECKING OF
 C          INPUT IS DONE.  (SUCH A CALL IS SOMETIMES USEFUL FOR THE
@@ -458,30 +458,30 @@ C              (THE EXCESS WORK STEP COU
 C              IN ADDITION, THE USER MAY INCREASE MXSTEP TO AVOID
 C              THIS ERROR RETURN (SEE BELOW ON OPTIONAL INPUTS).
 C          -2  MEANS TOO MUCH ACCURACY WAS REQUESTED FOR THE PRECISION
 C              OF THE MACHINE BEING USED.  THIS WAS DETECTED BEFORE
 C              COMPLETING THE REQUESTED TASK, BUT THE INTEGRATION
 C              WAS SUCCESSFUL AS FAR AS T.  TO CONTINUE, THE TOLERANCE
 C              PARAMETERS MUST BE RESET, AND ISTATE MUST BE SET
 C              TO 3.  THE OPTIONAL OUTPUT TOLSF MAY BE USED FOR THIS
-C              PURPOSE.  (NOTE.. IF THIS CONDITION IS DETECTED BEFORE 
+C              PURPOSE.  (NOTE.. IF THIS CONDITION IS DETECTED BEFORE
 C              TAKING ANY STEPS, THEN AN ILLEGAL INPUT RETURN
 C              (ISTATE = -3) OCCURS INSTEAD.)
 C          -3  MEANS ILLEGAL INPUT WAS DETECTED, BEFORE TAKING ANY
 C              INTEGRATION STEPS.  SEE WRITTEN MESSAGE FOR DETAILS.
 C              NOTE..  IF THE SOLVER DETECTS AN INFINITE LOOP OF CALLS
 C              TO THE SOLVER WITH ILLEGAL INPUT, IT WILL CAUSE
 C              THE RUN TO STOP.
 C          -4  MEANS THERE WERE REPEATED ERROR TEST FAILURES ON
 C              ONE ATTEMPTED STEP, BEFORE COMPLETING THE REQUESTED
 C              TASK, BUT THE INTEGRATION WAS SUCCESSFUL AS FAR AS T.
 C              THE PROBLEM MAY HAVE A SINGULARITY, OR THE INPUT
 C              MAY BE INAPPROPRIATE.
-C          -5  MEANS THERE WERE REPEATED CONVERGENCE TEST FAILURES ON 
+C          -5  MEANS THERE WERE REPEATED CONVERGENCE TEST FAILURES ON
 C              ONE ATTEMPTED STEP, BEFORE COMPLETING THE REQUESTED
 C              TASK, BUT THE INTEGRATION WAS SUCCESSFUL AS FAR AS T.
 C              THIS MAY BE CAUSED BY AN INACCURATE JACOBIAN MATRIX,
 C              IF ONE IS BEING USED.
 C          -6  MEANS EWT(I) BECAME ZERO FOR SOME I DURING THE
 C              INTEGRATION.  PURE RELATIVE ERROR CONTROL (ATOL(I)=0.0)
 C              WAS REQUESTED ON A VARIABLE WHICH HAS NOW VANISHED.
 C              THE INTEGRATION WAS SUCCESSFUL AS FAR AS T.
@@ -489,21 +489,21 @@ C
 C          NOTE..  SINCE THE NORMAL OUTPUT VALUE OF ISTATE IS 2,
 C          IT DOES NOT NEED TO BE RESET FOR NORMAL CONTINUATION.
 C          ALSO, SINCE A NEGATIVE INPUT VALUE OF ISTATE WILL BE
 C          REGARDED AS ILLEGAL, A NEGATIVE OUTPUT VALUE REQUIRES THE
 C          USER TO CHANGE IT, AND POSSIBLY OTHER INPUTS, BEFORE
 C          CALLING THE SOLVER AGAIN.
 C
 C IOPT   = AN INTEGER FLAG TO SPECIFY WHETHER OR NOT ANY OPTIONAL
-C          INPUTS ARE BEING USED ON THIS CALL.  INPUT ONLY. 
-C          THE OPTIONAL INPUTS ARE LISTED SEPARATELY BELOW. 
+C          INPUTS ARE BEING USED ON THIS CALL.  INPUT ONLY.
+C          THE OPTIONAL INPUTS ARE LISTED SEPARATELY BELOW.
 C          IOPT = 0 MEANS NO OPTIONAL INPUTS ARE BEING USED.
 C                   DEFAULT VALUES WILL BE USED IN ALL CASES.
-C          IOPT = 1 MEANS ONE OR MORE OPTIONAL INPUTS ARE BEING USED. 
+C          IOPT = 1 MEANS ONE OR MORE OPTIONAL INPUTS ARE BEING USED.
 C
 C RWORK  = A REAL WORKING ARRAY (DOUBLE PRECISION).
 C          THE LENGTH OF RWORK MUST BE AT LEAST
 C             20 + NYH*(MAXORD + 1) + 3*NEQ + LWM    WHERE
 C          NYH    = THE INITIAL VALUE OF NEQ,
 C          MAXORD = 12 (IF METH = 1) OR 5 (IF METH = 2) (UNLESS A
 C                   SMALLER VALUE IS GIVEN AS AN OPTIONAL INPUT),
 C          LWM   = 0             IF MITER = 0,
@@ -536,17 +536,17 @@ C IWORK  = AN INTEGER WORK ARRAY.  THE L
 C             20        IF MITER = 0 OR 3 (MF = 10, 13, 20, 23), OR
 C             20 + NEQ  OTHERWISE (MF = 11, 12, 14, 15, 21, 22, 24, 25).
 C          THE FIRST FEW WORDS OF IWORK ARE USED FOR CONDITIONAL AND
 C          OPTIONAL INPUTS AND OPTIONAL OUTPUTS.
 C
 C          THE FOLLOWING 2 WORDS IN IWORK ARE CONDITIONAL INPUTS..
 C            IWORK(1) = ML     THESE ARE THE LOWER AND UPPER
 C            IWORK(2) = MU     HALF-BANDWIDTHS, RESPECTIVELY, OF THE
-C                       BANDED JACOBIAN, EXCLUDING THE MAIN DIAGONAL. 
+C                       BANDED JACOBIAN, EXCLUDING THE MAIN DIAGONAL.
 C                       THE BAND IS DEFINED BY THE MATRIX LOCATIONS
 C                       (I,J) WITH I-ML .LE. J .LE. I+MU.  ML AND MU
 C                       MUST SATISFY  0 .LE.  ML,MU  .LE. NEQ-1.
 C                       THESE ARE REQUIRED IF MITER IS 4 OR 5, AND
 C                       IGNORED OTHERWISE.  ML AND MU MAY IN FACT BE
 C                       THE BAND PARAMETERS FOR A MATRIX TO WHICH
 C                       DF/DY IS ONLY APPROXIMATELY EQUAL.
 C
@@ -578,140 +578,140 @@ C               IN THE BAND MATRIX CASE 
 C          WITHIN THE BAND ARE TO BE LOADED INTO PD IN COLUMNWISE
 C          MANNER, WITH DIAGONAL LINES OF DF/DY LOADED INTO THE ROWS
 C          OF PD.  THUS DF(I)/DY(J) IS TO BE LOADED INTO PD(I-J+MU+1,J).
 C          ML AND MU ARE THE HALF-BANDWIDTH PARAMETERS (SEE IWORK).
 C          THE LOCATIONS IN PD IN THE TWO TRIANGULAR AREAS WHICH
 C          CORRESPOND TO NONEXISTENT MATRIX ELEMENTS CAN BE IGNORED
 C          OR LOADED ARBITRARILY, AS THEY ARE OVERWRITTEN BY LSODE.
 C               JAC NEED NOT PROVIDE DF/DY EXACTLY.  A CRUDE
-C          APPROXIMATION (POSSIBLY WITH A SMALLER BANDWIDTH) WILL DO. 
+C          APPROXIMATION (POSSIBLY WITH A SMALLER BANDWIDTH) WILL DO.
 C               IN EITHER CASE, PD IS PRESET TO ZERO BY THE SOLVER,
 C          SO THAT ONLY THE NONZERO ELEMENTS NEED BE LOADED BY JAC.
 C          EACH CALL TO JAC IS PRECEDED BY A CALL TO F WITH THE SAME
 C          ARGUMENTS NEQ, T, AND Y.  THUS TO GAIN SOME EFFICIENCY,
-C          INTERMEDIATE QUANTITIES SHARED BY BOTH CALCULATIONS MAY BE 
+C          INTERMEDIATE QUANTITIES SHARED BY BOTH CALCULATIONS MAY BE
 C          SAVED IN A USER COMMON BLOCK BY F AND NOT RECOMPUTED BY JAC,
 C          IF DESIRED.  ALSO, JAC MAY ALTER THE Y ARRAY, IF DESIRED.
 C          JAC MUST BE DECLARED EXTERNAL IN THE CALLING PROGRAM.
 C               SUBROUTINE JAC MAY ACCESS USER-DEFINED QUANTITIES IN
 C          NEQ(2),... AND/OR IN Y(NEQ(1)+1),... IF NEQ IS AN ARRAY
-C          (DIMENSIONED IN JAC) AND/OR Y HAS LENGTH EXCEEDING NEQ(1). 
+C          (DIMENSIONED IN JAC) AND/OR Y HAS LENGTH EXCEEDING NEQ(1).
 C          SEE THE DESCRIPTIONS OF NEQ AND Y ABOVE.
 C
 C MF     = THE METHOD FLAG.  USED ONLY FOR INPUT.  THE LEGAL VALUES OF
-C          MF ARE 10, 11, 12, 13, 14, 15, 20, 21, 22, 23, 24, AND 25. 
+C          MF ARE 10, 11, 12, 13, 14, 15, 20, 21, 22, 23, 24, AND 25.
 C          MF HAS DECIMAL DIGITS METH AND MITER.. MF = 10*METH + MITER.
 C          METH INDICATES THE BASIC LINEAR MULTISTEP METHOD..
 C            METH = 1 MEANS THE IMPLICIT ADAMS METHOD.
 C            METH = 2 MEANS THE METHOD BASED ON BACKWARD
 C                     DIFFERENTIATION FORMULAS (BDF-S).
-C          MITER INDICATES THE CORRECTOR ITERATION METHOD.. 
-C            MITER = 0 MEANS FUNCTIONAL ITERATION (NO JACOBIAN MATRIX 
+C          MITER INDICATES THE CORRECTOR ITERATION METHOD..
+C            MITER = 0 MEANS FUNCTIONAL ITERATION (NO JACOBIAN MATRIX
 C                      IS INVOLVED).
 C            MITER = 1 MEANS CHORD ITERATION WITH A USER-SUPPLIED
 C                      FULL (NEQ BY NEQ) JACOBIAN.
 C            MITER = 2 MEANS CHORD ITERATION WITH AN INTERNALLY
 C                      GENERATED (DIFFERENCE QUOTIENT) FULL JACOBIAN
 C                      (USING NEQ EXTRA CALLS TO F PER DF/DY VALUE).
 C            MITER = 3 MEANS CHORD ITERATION WITH AN INTERNALLY
 C                      GENERATED DIAGONAL JACOBIAN APPROXIMATION.
 C                      (USING 1 EXTRA CALL TO F PER DF/DY EVALUATION).
 C            MITER = 4 MEANS CHORD ITERATION WITH A USER-SUPPLIED
-C                      BANDED JACOBIAN. 
+C                      BANDED JACOBIAN.
 C            MITER = 5 MEANS CHORD ITERATION WITH AN INTERNALLY
-C                      GENERATED BANDED JACOBIAN (USING ML+MU+1 EXTRA 
+C                      GENERATED BANDED JACOBIAN (USING ML+MU+1 EXTRA
 C                      CALLS TO F PER DF/DY EVALUATION).
 C          IF MITER = 1 OR 4, THE USER MUST SUPPLY A SUBROUTINE JAC
 C          (THE NAME IS ARBITRARY) AS DESCRIBED ABOVE UNDER JAC.
 C          FOR OTHER VALUES OF MITER, A DUMMY ARGUMENT CAN BE USED.
 C-----------------------------------------------------------------------
 C OPTIONAL INPUTS.
 C
 C THE FOLLOWING IS A LIST OF THE OPTIONAL INPUTS PROVIDED FOR IN THE
 C CALL SEQUENCE.  (SEE ALSO PART II.)  FOR EACH SUCH INPUT VARIABLE,
 C THIS TABLE LISTS ITS NAME AS USED IN THIS DOCUMENTATION, ITS
 C LOCATION IN THE CALL SEQUENCE, ITS MEANING, AND THE DEFAULT VALUE.
 C THE USE OF ANY OF THESE INPUTS REQUIRES IOPT = 1, AND IN THAT
 C CASE ALL OF THESE INPUTS ARE EXAMINED.  A VALUE OF ZERO FOR ANY
 C OF THESE OPTIONAL INPUTS WILL CAUSE THE DEFAULT VALUE TO BE USED.
 C THUS TO USE A SUBSET OF THE OPTIONAL INPUTS, SIMPLY PRELOAD
-C LOCATIONS 5 TO 10 IN RWORK AND IWORK TO 0.0 AND 0 RESPECTIVELY, AND 
+C LOCATIONS 5 TO 10 IN RWORK AND IWORK TO 0.0 AND 0 RESPECTIVELY, AND
 C THEN SET THOSE OF INTEREST TO NONZERO VALUES.
 C
-C NAME    LOCATION      MEANING AND DEFAULT VALUE 
+C NAME    LOCATION      MEANING AND DEFAULT VALUE
 C
 C H0      RWORK(5)  THE STEP SIZE TO BE ATTEMPTED ON THE FIRST STEP.
 C                   THE DEFAULT VALUE IS DETERMINED BY THE SOLVER.
 C
-C HMAX    RWORK(6)  THE MAXIMUM ABSOLUTE STEP SIZE ALLOWED. 
+C HMAX    RWORK(6)  THE MAXIMUM ABSOLUTE STEP SIZE ALLOWED.
 C                   THE DEFAULT VALUE IS INFINITE.
 C
-C HMIN    RWORK(7)  THE MINIMUM ABSOLUTE STEP SIZE ALLOWED. 
-C                   THE DEFAULT VALUE IS 0.  (THIS LOWER BOUND IS NOT 
+C HMIN    RWORK(7)  THE MINIMUM ABSOLUTE STEP SIZE ALLOWED.
+C                   THE DEFAULT VALUE IS 0.  (THIS LOWER BOUND IS NOT
 C                   ENFORCED ON THE FINAL STEP BEFORE REACHING TCRIT
 C                   WHEN ITASK = 4 OR 5.)
 C
 C MAXORD  IWORK(5)  THE MAXIMUM ORDER TO BE ALLOWED.  THE DEFAULT
 C                   VALUE IS 12 IF METH = 1, AND 5 IF METH = 2.
 C                   IF MAXORD EXCEEDS THE DEFAULT VALUE, IT WILL
 C                   BE REDUCED TO THE DEFAULT VALUE.
 C                   IF MAXORD IS CHANGED DURING THE PROBLEM, IT MAY
 C                   CAUSE THE CURRENT ORDER TO BE REDUCED.
 C
 C MXSTEP  IWORK(6)  MAXIMUM NUMBER OF (INTERNALLY DEFINED) STEPS
 C                   ALLOWED DURING ONE CALL TO THE SOLVER.
 C                   THE DEFAULT VALUE IS 500.
 C
 C MXHNIL  IWORK(7)  MAXIMUM NUMBER OF MESSAGES PRINTED (PER PROBLEM)
-C                   WARNING THAT T + H = T ON A STEP (H = STEP SIZE). 
+C                   WARNING THAT T + H = T ON A STEP (H = STEP SIZE).
 C                   THIS MUST BE POSITIVE TO RESULT IN A NON-DEFAULT
 C                   VALUE.  THE DEFAULT VALUE IS 10.
 C-----------------------------------------------------------------------
-C OPTIONAL OUTPUTS. 
+C OPTIONAL OUTPUTS.
 C
 C AS OPTIONAL ADDITIONAL OUTPUT FROM LSODE, THE VARIABLES LISTED
 C BELOW ARE QUANTITIES RELATED TO THE PERFORMANCE OF LSODE
 C WHICH ARE AVAILABLE TO THE USER.  THESE ARE COMMUNICATED BY WAY OF
 C THE WORK ARRAYS, BUT ALSO HAVE INTERNAL MNEMONIC NAMES AS SHOWN.
 C EXCEPT WHERE STATED OTHERWISE, ALL OF THESE OUTPUTS ARE DEFINED
 C ON ANY SUCCESSFUL RETURN FROM LSODE, AND ON ANY RETURN WITH
 C ISTATE = -1, -2, -4, -5, OR -6.  ON AN ILLEGAL INPUT RETURN
 C (ISTATE = -3), THEY WILL BE UNCHANGED FROM THEIR EXISTING VALUES
 C (IF ANY), EXCEPT POSSIBLY FOR TOLSF, LENRW, AND LENIW.
-C ON ANY ERROR RETURN, OUTPUTS RELEVANT TO THE ERROR WILL BE DEFINED, 
+C ON ANY ERROR RETURN, OUTPUTS RELEVANT TO THE ERROR WILL BE DEFINED,
 C AS NOTED BELOW.
 C
 C NAME    LOCATION      MEANING
 C
 C HU      RWORK(11) THE STEP SIZE IN T LAST USED (SUCCESSFULLY).
 C
 C HCUR    RWORK(12) THE STEP SIZE TO BE ATTEMPTED ON THE NEXT STEP.
 C
 C TCUR    RWORK(13) THE CURRENT VALUE OF THE INDEPENDENT VARIABLE
 C                   WHICH THE SOLVER HAS ACTUALLY REACHED, I.E. THE
 C                   CURRENT INTERNAL MESH POINT IN T.  ON OUTPUT, TCUR
 C                   WILL ALWAYS BE AT LEAST AS FAR AS THE ARGUMENT
 C                   T, BUT MAY BE FARTHER (IF INTERPOLATION WAS DONE).
 C
 C TOLSF   RWORK(14) A TOLERANCE SCALE FACTOR, GREATER THAN 1.0,
-C                   COMPUTED WHEN A REQUEST FOR TOO MUCH ACCURACY WAS 
-C                   DETECTED (ISTATE = -3 IF DETECTED AT THE START OF 
+C                   COMPUTED WHEN A REQUEST FOR TOO MUCH ACCURACY WAS
+C                   DETECTED (ISTATE = -3 IF DETECTED AT THE START OF
 C                   THE PROBLEM, ISTATE = -2 OTHERWISE).  IF ITOL IS
 C                   LEFT UNALTERED BUT RTOL AND ATOL ARE UNIFORMLY
-C                   SCALED UP BY A FACTOR OF TOLSF FOR THE NEXT CALL, 
+C                   SCALED UP BY A FACTOR OF TOLSF FOR THE NEXT CALL,
 C                   THEN THE SOLVER IS DEEMED LIKELY TO SUCCEED.
 C                   (THE USER MAY ALSO IGNORE TOLSF AND ALTER THE
 C                   TOLERANCE PARAMETERS IN ANY OTHER WAY APPROPRIATE.)
 C
-C NST     IWORK(11) THE NUMBER OF STEPS TAKEN FOR THE PROBLEM SO FAR. 
+C NST     IWORK(11) THE NUMBER OF STEPS TAKEN FOR THE PROBLEM SO FAR.
 C
 C NFE     IWORK(12) THE NUMBER OF F EVALUATIONS FOR THE PROBLEM SO FAR.
 C
-C NJE     IWORK(13) THE NUMBER OF JACOBIAN EVALUATIONS (AND OF MATRIX 
+C NJE     IWORK(13) THE NUMBER OF JACOBIAN EVALUATIONS (AND OF MATRIX
 C                   LU DECOMPOSITIONS) FOR THE PROBLEM SO FAR.
 C
 C NQU     IWORK(14) THE METHOD ORDER LAST USED (SUCCESSFULLY).
 C
 C NQCUR   IWORK(15) THE ORDER TO BE ATTEMPTED ON THE NEXT STEP.
 C
 C IMXER   IWORK(16) THE INDEX OF THE COMPONENT OF LARGEST MAGNITUDE IN
 C                   THE WEIGHTED LOCAL ERROR VECTOR ( E(I)/EWT(I) ),
@@ -723,33 +723,33 @@ C                   INPUT RETURN FOR INS
 C
 C LENIW   IWORK(18) THE LENGTH OF IWORK ACTUALLY REQUIRED.
 C                   THIS IS DEFINED ON NORMAL RETURNS AND ON AN ILLEGAL
 C                   INPUT RETURN FOR INSUFFICIENT STORAGE.
 C
 C THE FOLLOWING TWO ARRAYS ARE SEGMENTS OF THE RWORK ARRAY WHICH
 C MAY ALSO BE OF INTEREST TO THE USER AS OPTIONAL OUTPUTS.
 C FOR EACH ARRAY, THE TABLE BELOW GIVES ITS INTERNAL NAME,
-C ITS BASE ADDRESS IN RWORK, AND ITS DESCRIPTION. 
+C ITS BASE ADDRESS IN RWORK, AND ITS DESCRIPTION.
 C
-C NAME    BASE ADDRESS      DESCRIPTION 
+C NAME    BASE ADDRESS      DESCRIPTION
 C
 C YH      21             THE NORDSIECK HISTORY ARRAY, OF SIZE NYH BY
 C                        (NQCUR + 1), WHERE NYH IS THE INITIAL VALUE
 C                        OF NEQ.  FOR J = 0,1,...,NQCUR, COLUMN J+1
 C                        OF YH CONTAINS HCUR**J/FACTORIAL(J) TIMES
 C                        THE J-TH DERIVATIVE OF THE INTERPOLATING
 C                        POLYNOMIAL CURRENTLY REPRESENTING THE SOLUTION,
 C                        EVALUATED AT T = TCUR.
 C
 C ACOR     LENRW-NEQ+1   ARRAY OF SIZE NEQ USED FOR THE ACCUMULATED
 C                        CORRECTIONS ON EACH STEP, SCALED ON OUTPUT
 C                        TO REPRESENT THE ESTIMATED LOCAL ERROR IN Y
 C                        ON THE LAST STEP.  THIS IS THE VECTOR E IN
-C                        THE DESCRIPTION OF THE ERROR CONTROL.  IT IS 
+C                        THE DESCRIPTION OF THE ERROR CONTROL.  IT IS
 C                        DEFINED ONLY ON A SUCCESSFUL RETURN FROM LSODE.
 C
 C-----------------------------------------------------------------------
 C PART II.  OTHER ROUTINES CALLABLE.
 C
 C THE FOLLOWING ARE OPTIONAL CALLS WHICH THE USER MAY MAKE TO
 C GAIN ADDITIONAL CAPABILITIES IN CONJUNCTION WITH LSODE.
 C (THE ROUTINES XSETUN AND XSETF ARE DESIGNED TO CONFORM TO THE
@@ -758,67 +758,67 @@ C
 C     FORM OF CALL                  FUNCTION
 C   CALL XSETUN(LUN)          SET THE LOGICAL UNIT NUMBER, LUN, FOR
 C                             OUTPUT OF MESSAGES FROM LSODE, IF
 C                             THE DEFAULT IS NOT DESIRED.
 C                             THE DEFAULT VALUE OF LUN IS 6.
 C
 C   CALL XSETF(MFLAG)         SET A FLAG TO CONTROL THE PRINTING OF
 C                             MESSAGES BY LSODE.
-C                             MFLAG = 0 MEANS DO NOT PRINT. (DANGER.. 
+C                             MFLAG = 0 MEANS DO NOT PRINT. (DANGER..
 C                             THIS RISKS LOSING VALUABLE INFORMATION.)
 C                             MFLAG = 1 MEANS PRINT (THE DEFAULT).
 C
 C                             EITHER OF THE ABOVE CALLS MAY BE MADE AT
 C                             ANY TIME AND WILL TAKE EFFECT IMMEDIATELY.
 C
 C   CALL SRCOM(RSAV,ISAV,JOB) SAVES AND RESTORES THE CONTENTS OF
 C                             THE INTERNAL COMMON BLOCKS USED BY
 C                             LSODE (SEE PART III BELOW).
-C                             RSAV MUST BE A REAL ARRAY OF LENGTH 218 
+C                             RSAV MUST BE A REAL ARRAY OF LENGTH 218
 C                             OR MORE, AND ISAV MUST BE AN INTEGER
 C                             ARRAY OF LENGTH 41 OR MORE.
-C                             JOB=1 MEANS SAVE COMMON INTO RSAV/ISAV. 
+C                             JOB=1 MEANS SAVE COMMON INTO RSAV/ISAV.
 C                             JOB=2 MEANS RESTORE COMMON FROM RSAV/ISAV.
 C                                SRCOM IS USEFUL IF ONE IS
 C                             INTERRUPTING A RUN AND RESTARTING
 C                             LATER, OR ALTERNATING BETWEEN TWO OR
 C                             MORE PROBLEMS SOLVED WITH LSODE.
 C
 C   CALL INTDY(,,,,,)         PROVIDE DERIVATIVES OF Y, OF VARIOUS
 C        (SEE BELOW)          ORDERS, AT A SPECIFIED POINT T, IF
 C                             DESIRED.  IT MAY BE CALLED ONLY AFTER
 C                             A SUCCESSFUL RETURN FROM LSODE.
 C
-C THE DETAILED INSTRUCTIONS FOR USING INTDY ARE AS FOLLOWS. 
+C THE DETAILED INSTRUCTIONS FOR USING INTDY ARE AS FOLLOWS.
 C THE FORM OF THE CALL IS..
 C
-C   CALL INTDY (T, K, RWORK(21), NYH, DKY, IFLAG) 
+C   CALL INTDY (T, K, RWORK(21), NYH, DKY, IFLAG)
 C
 C THE INPUT PARAMETERS ARE..
 C
-C T         = VALUE OF INDEPENDENT VARIABLE WHERE ANSWERS ARE DESIRED 
+C T         = VALUE OF INDEPENDENT VARIABLE WHERE ANSWERS ARE DESIRED
 C             (NORMALLY THE SAME AS THE T LAST RETURNED BY LSODE).
 C             FOR VALID RESULTS, T MUST LIE BETWEEN TCUR - HU AND TCUR.
 C             (SEE OPTIONAL OUTPUTS FOR TCUR AND HU.)
 C K         = INTEGER ORDER OF THE DERIVATIVE DESIRED.  K MUST SATISFY
 C             0 .LE. K .LE. NQCUR, WHERE NQCUR IS THE CURRENT ORDER
 C             (SEE OPTIONAL OUTPUTS).  THE CAPABILITY CORRESPONDING
 C             TO K = 0, I.E. COMPUTING Y(T), IS ALREADY PROVIDED
 C             BY LSODE DIRECTLY.  SINCE NQCUR .GE. 1, THE FIRST
 C             DERIVATIVE DY/DT IS ALWAYS AVAILABLE WITH INTDY.
 C RWORK(21) = THE BASE ADDRESS OF THE HISTORY ARRAY YH.
-C NYH       = COLUMN LENGTH OF YH, EQUAL TO THE INITIAL VALUE OF NEQ. 
+C NYH       = COLUMN LENGTH OF YH, EQUAL TO THE INITIAL VALUE OF NEQ.
 C
-C THE OUTPUT PARAMETERS ARE.. 
+C THE OUTPUT PARAMETERS ARE..
 C
 C DKY       = A REAL ARRAY OF LENGTH NEQ CONTAINING THE COMPUTED VALUE
 C             OF THE K-TH DERIVATIVE OF Y(T).
 C IFLAG     = INTEGER FLAG, RETURNED AS 0 IF K AND T WERE LEGAL,
-C             -1 IF K WAS ILLEGAL, AND -2 IF T WAS ILLEGAL. 
+C             -1 IF K WAS ILLEGAL, AND -2 IF T WAS ILLEGAL.
 C             ON AN ERROR RETURN, A MESSAGE IS ALSO WRITTEN.
 C-----------------------------------------------------------------------
 C PART III.  COMMON BLOCKS.
 C
 C IF LSODE IS TO BE USED IN AN OVERLAY SITUATION, THE USER
 C MUST DECLARE, IN THE PRIMARY OVERLAY, THE VARIABLES IN..
 C   (1) THE CALL SEQUENCE TO LSODE,
 C   (2) THE INTERNAL COMMON BLOCK
@@ -862,47 +862,47 @@ C
 C IF THE USER SUPPLIES THIS SUBROUTINE, IT MUST RETURN IN EWT(I)
 C (I = 1,...,NEQ) A POSITIVE QUANTITY SUITABLE FOR COMPARING ERRORS
 C IN Y(I) TO.  THE EWT ARRAY RETURNED BY EWSET IS PASSED TO THE
 C VNORM ROUTINE (SEE BELOW), AND ALSO USED BY LSODE IN THE COMPUTATION
 C OF THE OPTIONAL OUTPUT IMXER, THE DIAGONAL JACOBIAN APPROXIMATION,
 C AND THE INCREMENTS FOR DIFFERENCE QUOTIENT JACOBIANS.
 C
 C IN THE USER-SUPPLIED VERSION OF EWSET, IT MAY BE DESIRABLE TO USE
-C THE CURRENT VALUES OF DERIVATIVES OF Y.  DERIVATIVES UP TO ORDER NQ 
+C THE CURRENT VALUES OF DERIVATIVES OF Y.  DERIVATIVES UP TO ORDER NQ
 C ARE AVAILABLE FROM THE HISTORY ARRAY YH, DESCRIBED ABOVE UNDER
 C OPTIONAL OUTPUTS.  IN EWSET, YH IS IDENTICAL TO THE YCUR ARRAY,
 C EXTENDED TO NQ + 1 COLUMNS WITH A COLUMN LENGTH OF NYH AND SCALE
 C FACTORS OF H**J/FACTORIAL(J).  ON THE FIRST CALL FOR THE PROBLEM,
 C GIVEN BY NST = 0, NQ IS 1 AND H IS TEMPORARILY SET TO 1.0.
 C THE QUANTITIES NQ, NYH, H, AND NST CAN BE OBTAINED BY INCLUDING
 C IN EWSET THE STATEMENTS..
-C     DOUBLE PRECISION H, RLS 
+C     DOUBLE PRECISION H, RLS
 C     COMMON /LS0001/ RLS(218),ILS(39)
 C     NQ = ILS(35)
-C     NYH = ILS(14) 
-C     NST = ILS(36) 
+C     NYH = ILS(14)
+C     NST = ILS(36)
 C     H = RLS(212)
 C THUS, FOR EXAMPLE, THE CURRENT VALUE OF DY/DT CAN BE OBTAINED AS
 C YCUR(NYH+I)/H  (I=1,...,NEQ)  (AND THE DIVISION BY H IS
 C UNNECESSARY WHEN NST = 0).
 C
 C (B) VNORM.
 C THE FOLLOWING IS A REAL FUNCTION ROUTINE WHICH COMPUTES THE WEIGHTED
-C ROOT-MEAN-SQUARE NORM OF A VECTOR V.. 
+C ROOT-MEAN-SQUARE NORM OF A VECTOR V..
 C     D = VNORM (N, V, W)
-C WHERE.. 
+C WHERE..
 C   N = THE LENGTH OF THE VECTOR,
 C   V = REAL ARRAY OF LENGTH N CONTAINING THE VECTOR,
 C   W = REAL ARRAY OF LENGTH N CONTAINING WEIGHTS,
 C   D = SQRT( (1/N) * SUM(V(I)*W(I))**2 ).
 C VNORM IS CALLED WITH N = NEQ AND WITH W(I) = 1.0/EWT(I), WHERE
 C EWT IS AS SET BY SUBROUTINE EWSET.
 C
-C IF THE USER SUPPLIES THIS FUNCTION, IT SHOULD RETURN A NON-NEGATIVE 
+C IF THE USER SUPPLIES THIS FUNCTION, IT SHOULD RETURN A NON-NEGATIVE
 C VALUE OF VNORM SUITABLE FOR USE IN THE ERROR CONTROL IN LSODE.
 C NONE OF THE ARGUMENTS SHOULD BE ALTERED BY VNORM.
 C FOR EXAMPLE, A USER-SUPPLIED VNORM ROUTINE MIGHT..
 C   -SUBSTITUTE A MAX-NORM OF (V(I)*W(I)) FOR THE RMS-NORM, OR
 C   -IGNORE SOME COMPONENTS OF V IN THE NORM, WITH THE EFFECT OF
 C    SUPPRESSING THE ERROR CONTROL ON THOSE COMPONENTS OF Y.
 C-----------------------------------------------------------------------
 C-----------------------------------------------------------------------
@@ -910,17 +910,17 @@ C OTHER ROUTINES IN THE LSODE PACKAGE.
 C
 C IN ADDITION TO SUBROUTINE LSODE, THE LSODE PACKAGE INCLUDES THE
 C FOLLOWING SUBROUTINES AND FUNCTION ROUTINES..
 C  INTDY    COMPUTES AN INTERPOLATED VALUE OF THE Y VECTOR AT T = TOUT.
 C  STODE    IS THE CORE INTEGRATOR, WHICH DOES ONE STEP OF THE
 C           INTEGRATION AND THE ASSOCIATED ERROR CONTROL.
 C  CFODE    SETS ALL METHOD COEFFICIENTS AND TEST CONSTANTS.
 C  PREPJ    COMPUTES AND PREPROCESSES THE JACOBIAN MATRIX J = DF/DY
-C           AND THE NEWTON ITERATION MATRIX P = I - H*L0*J. 
+C           AND THE NEWTON ITERATION MATRIX P = I - H*L0*J.
 C  SOLSY    MANAGES SOLUTION OF LINEAR SYSTEM IN CHORD ITERATION.
 C  EWSET    SETS THE ERROR WEIGHT VECTOR EWT BEFORE EACH STEP.
 C  VNORM    COMPUTES THE WEIGHTED R.M.S. NORM OF A VECTOR.
 C  SRCOM    IS A USER-CALLABLE ROUTINE TO SAVE AND RESTORE
 C           THE CONTENTS OF THE INTERNAL COMMON BLOCKS.
 C  DGETRF AND DGETRS   ARE ROUTINES FROM LAPACK FOR SOLVING FULL
 C           SYSTEMS OF LINEAR ALGEBRAIC EQUATIONS.
 C  DGBTRF AND DGBTRS   ARE ROUTINES FROM LAPACK FOR SOLVING BANDED
@@ -929,44 +929,44 @@ C  DAXPY, DSCAL, IDAMAX, AND DDOT   ARE 
 C           (BLAS) USED BY THE ABOVE LINPACK ROUTINES.
 C  D1MACH   COMPUTES THE UNIT ROUNDOFF IN A MACHINE-INDEPENDENT MANNER.
 C  XERRWD, XSETUN, AND XSETF   HANDLE THE PRINTING OF ALL ERROR
 C           MESSAGES AND WARNINGS.  XERRWD IS MACHINE-DEPENDENT.
 C NOTE..  VNORM, IDAMAX, DDOT, AND D1MACH ARE FUNCTION ROUTINES.
 C ALL THE OTHERS ARE SUBROUTINES.
 C
 C THE INTRINSIC AND EXTERNAL ROUTINES USED BY LSODE ARE..
-C DABS, DMAX1, DMIN1, DBLE, MAX0, MIN0, MOD, DSIGN, DSQRT, AND WRITE. 
+C DABS, DMAX1, DMIN1, DBLE, MAX0, MIN0, MOD, DSIGN, DSQRT, AND WRITE.
 C
 C A BLOCK DATA SUBPROGRAM IS ALSO INCLUDED WITH THE PACKAGE,
 C FOR LOADING SOME OF THE VARIABLES IN INTERNAL COMMON.
 C
 C-----------------------------------------------------------------------
 C THE FOLLOWING CARD IS FOR OPTIMIZED COMPILATION ON LLNL COMPILERS.
 CLLL. OPTIMIZE
 C-----------------------------------------------------------------------
       EXTERNAL PREPJ, SOLSY
       INTEGER ILLIN, INIT, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
      1   MXSTEP, MXHNIL, NHNIL, NTREP, NSLAST, NYH, IOWNS
-      INTEGER ICF, IERPJ, IERSL, JCUR, JSTART, KFLAG, L, METH, MITER, 
+      INTEGER ICF, IERPJ, IERSL, JCUR, JSTART, KFLAG, L, METH, MITER,
      1   MAXORD, MAXCOR, MSBP, MXNCF, N, NQ, NST, NFE, NJE, NQU
       INTEGER I, I1, I2, IFLAG, IMXER, KGO, LF0,
      1   LENIW, LENRW, LENWM, ML, MORD, MU, MXHNL0, MXSTP0
-      DOUBLE PRECISION ROWNS, 
+      DOUBLE PRECISION ROWNS,
      1   CCMAX, EL0, H, HMIN, HMXI, HU, RC, TN, UROUND
       DOUBLE PRECISION ATOLI, AYI, BIG, EWTI, H0, HMAX, HMX, RH, RTOLI,
      1   TCRIT, TDIST, TNEXT, TOL, TOLSF, TP, SIZE, SUM, W0,
      2   D1MACH, VNORM
       DIMENSION MORD(2)
       LOGICAL IHIT
 C-----------------------------------------------------------------------
 C THE FOLLOWING INTERNAL COMMON BLOCK CONTAINS
 C (A) VARIABLES WHICH ARE LOCAL TO ANY SUBROUTINE BUT WHOSE VALUES MUST
 C     BE PRESERVED BETWEEN CALLS TO THE ROUTINE (OWN VARIABLES), AND
-C (B) VARIABLES WHICH ARE COMMUNICATED BETWEEN SUBROUTINES. 
+C (B) VARIABLES WHICH ARE COMMUNICATED BETWEEN SUBROUTINES.
 C THE STRUCTURE OF THE BLOCK IS AS FOLLOWS..  ALL REAL VARIABLES ARE
 C LISTED FIRST, FOLLOWED BY ALL INTEGERS.  WITHIN EACH TYPE, THE
 C VARIABLES ARE GROUPED WITH THOSE LOCAL TO SUBROUTINE LSODE FIRST,
 C THEN THOSE LOCAL TO SUBROUTINE STODE, AND FINALLY THOSE USED
 C FOR COMMUNICATION.  THE BLOCK IS DECLARED IN SUBROUTINES
 C LSODE, INTDY, STODE, PREPJ, AND SOLSY.  GROUPS OF VARIABLES ARE
 C REPLACED BY DUMMY ARRAYS IN THE COMMON DECLARATIONS IN ROUTINES
 C WHERE THOSE VARIABLES ARE NOT USED.
@@ -980,17 +980,17 @@ C---------------------------------------
 C
       DATA  MORD(1),MORD(2)/12,5/, MXSTP0/500/, MXHNL0/10/
 C-----------------------------------------------------------------------
 C BLOCK A.
 C THIS CODE BLOCK IS EXECUTED ON EVERY CALL.
 C IT TESTS ISTATE AND ITASK FOR LEGALITY AND BRANCHES APPROPRIATELY.
 C IF ISTATE .GT. 1 BUT THE FLAG INIT SHOWS THAT INITIALIZATION HAS
 C NOT YET BEEN DONE, AN ERROR RETURN OCCURS.
-C IF ISTATE = 1 AND TOUT = T, JUMP TO BLOCK G AND RETURN IMMEDIATELY. 
+C IF ISTATE = 1 AND TOUT = T, JUMP TO BLOCK G AND RETURN IMMEDIATELY.
 C-----------------------------------------------------------------------
       IF (ISTATE .LT. 1 .OR. ISTATE .GT. 3) GO TO 601
       IF (ITASK .LT. 1 .OR. ITASK .GT. 5) GO TO 602
       IF (ISTATE .EQ. 1) GO TO 10
       IF (INIT .EQ. 0) GO TO 603
       IF (ISTATE .EQ. 2) GO TO 200
       GO TO 20
  10   INIT = 0
@@ -1004,25 +1004,25 @@ C IT CONTAINS CHECKING OF ALL INPUTS AND
 C
 C FIRST CHECK LEGALITY OF THE NON-OPTIONAL INPUTS NEQ, ITOL, IOPT,
 C MF, ML, AND MU.
 C-----------------------------------------------------------------------
       IF (NEQ(1) .LE. 0) GO TO 604
       IF (ISTATE .EQ. 1) GO TO 25
       IF (NEQ(1) .GT. N) GO TO 605
  25   N = NEQ(1)
-      IF (ITOL .LT. 1 .OR. ITOL .GT. 4) GO TO 606 
-      IF (IOPT .LT. 0 .OR. IOPT .GT. 1) GO TO 607 
+      IF (ITOL .LT. 1 .OR. ITOL .GT. 4) GO TO 606
+      IF (IOPT .LT. 0 .OR. IOPT .GT. 1) GO TO 607
       METH = MF/10
       MITER = MF - 10*METH
-      IF (METH .LT. 1 .OR. METH .GT. 2) GO TO 608 
+      IF (METH .LT. 1 .OR. METH .GT. 2) GO TO 608
       IF (MITER .LT. 0 .OR. MITER .GT. 5) GO TO 608
       IF (MITER .LE. 3) GO TO 30
-      ML = IWORK(1) 
-      MU = IWORK(2) 
+      ML = IWORK(1)
+      MU = IWORK(2)
       IF (ML .LT. 0 .OR. ML .GE. N) GO TO 609
       IF (MU .LT. 0 .OR. MU .GE. N) GO TO 610
  30   CONTINUE
 C NEXT PROCESS AND CHECK THE OPTIONAL INPUTS. --------------------------
       IF (IOPT .EQ. 1) GO TO 40
       MAXORD = MORD(METH)
       MXSTEP = MXSTP0
       MXHNIL = MXHNL0
@@ -1036,27 +1036,27 @@ C NEXT PROCESS AND CHECK THE OPTIONAL IN
       MAXORD = MIN0(MAXORD,MORD(METH))
       MXSTEP = IWORK(6)
       IF (MXSTEP .LT. 0) GO TO 612
       IF (MXSTEP .EQ. 0) MXSTEP = MXSTP0
       MXHNIL = IWORK(7)
       IF (MXHNIL .LT. 0) GO TO 613
       IF (MXHNIL .EQ. 0) MXHNIL = MXHNL0
       IF (ISTATE .NE. 1) GO TO 50
-      H0 = RWORK(5) 
+      H0 = RWORK(5)
       IF ((TOUT - T)*H0 .LT. 0.0D0) GO TO 614
  50   HMAX = RWORK(6)
       IF (HMAX .LT. 0.0D0) GO TO 615
       HMXI = 0.0D0
       IF (HMAX .GT. 0.0D0) HMXI = 1.0D0/HMAX
       HMIN = RWORK(7)
       IF (HMIN .LT. 0.0D0) GO TO 616
 C-----------------------------------------------------------------------
 C SET WORK ARRAY POINTERS AND CHECK LENGTHS LRW AND LIW.
-C POINTERS TO SEGMENTS OF RWORK AND IWORK ARE NAMED BY PREFIXING L TO 
+C POINTERS TO SEGMENTS OF RWORK AND IWORK ARE NAMED BY PREFIXING L TO
 C THE NAME OF THE SEGMENT.  E.G., THE SEGMENT YH STARTS AT RWORK(LYH).
 C SEGMENTS OF RWORK (IN ORDER) ARE DENOTED  YH, WM, EWT, SAVF, ACOR.
 C-----------------------------------------------------------------------
  60   LYH = 21
       IF (ISTATE .EQ. 1) NYH = N
       LWM = LYH + (MAXORD + 1)*NYH
       IF (MITER .EQ. 0) LENWM = 0
       IF (MITER .EQ. 1 .OR. MITER .EQ. 2) LENWM = N*N + 2
@@ -1071,86 +1071,86 @@ C---------------------------------------
       LENIW = 20 + N
       IF (MITER .EQ. 0 .OR. MITER .EQ. 3) LENIW = 20
       IWORK(18) = LENIW
       IF (LENRW .GT. LRW) GO TO 617
       IF (LENIW .GT. LIW) GO TO 618
 C CHECK RTOL AND ATOL FOR LEGALITY. ------------------------------------
       RTOLI = RTOL(1)
       ATOLI = ATOL(1)
-      DO 70 I = 1,N 
+      DO 70 I = 1,N
         IF (ITOL .GE. 3) RTOLI = RTOL(I)
         IF (ITOL .EQ. 2 .OR. ITOL .EQ. 4) ATOLI = ATOL(I)
-        IF (RTOLI .LT. 0.0D0) GO TO 619 
-        IF (ATOLI .LT. 0.0D0) GO TO 620 
+        IF (RTOLI .LT. 0.0D0) GO TO 619
+        IF (ATOLI .LT. 0.0D0) GO TO 620
  70     CONTINUE
       IF (ISTATE .EQ. 1) GO TO 100
 C IF ISTATE = 3, SET FLAG TO SIGNAL PARAMETER CHANGES TO STODE. --------
       JSTART = -1
       IF (NQ .LE. MAXORD) GO TO 90
 C MAXORD WAS REDUCED BELOW NQ.  COPY YH(*,MAXORD+2) INTO SAVF. ---------
-      DO 80 I = 1,N 
+      DO 80 I = 1,N
  80     RWORK(I+LSAVF-1) = RWORK(I+LWM-1)
 C RELOAD WM(1) = RWORK(LWM), SINCE LWM MAY HAVE CHANGED. ---------------
  90   IF (MITER .GT. 0) RWORK(LWM) = DSQRT(UROUND)
       IF (N .EQ. NYH) GO TO 200
 C NEQ WAS REDUCED.  ZERO PART OF YH TO AVOID UNDEFINED REFERENCES. -----
       I1 = LYH + L*NYH
       I2 = LYH + (MAXORD + 1)*NYH - 1
       IF (I1 .GT. I2) GO TO 200
       DO 95 I = I1,I2
  95     RWORK(I) = 0.0D0
       GO TO 200
 C-----------------------------------------------------------------------
 C BLOCK C.
-C THE NEXT BLOCK IS FOR THE INITIAL CALL ONLY (ISTATE = 1). 
+C THE NEXT BLOCK IS FOR THE INITIAL CALL ONLY (ISTATE = 1).
 C IT CONTAINS ALL REMAINING INITIALIZATIONS, THE INITIAL CALL TO F,
 C AND THE CALCULATION OF THE INITIAL STEP SIZE.
-C THE ERROR WEIGHTS IN EWT ARE INVERTED AFTER BEING LOADED. 
+C THE ERROR WEIGHTS IN EWT ARE INVERTED AFTER BEING LOADED.
 C-----------------------------------------------------------------------
  100  UROUND = D1MACH(4)
       TN = T
       IF (ITASK .NE. 4 .AND. ITASK .NE. 5) GO TO 110
       TCRIT = RWORK(1)
       IF ((TCRIT - TOUT)*(TOUT - T) .LT. 0.0D0) GO TO 625
       IF (H0 .NE. 0.0D0 .AND. (T + H0 - TCRIT)*H0 .GT. 0.0D0)
      1   H0 = TCRIT - T
  110  JSTART = 0
       IF (MITER .GT. 0) RWORK(LWM) = DSQRT(UROUND)
       NHNIL = 0
       NST = 0
       NJE = 0
       NSLAST = 0
       HU = 0.0D0
       NQU = 0
-      CCMAX = 0.3D0 
+      CCMAX = 0.3D0
       MAXCOR = 3
       MSBP = 20
       MXNCF = 10
 C INITIAL CALL TO F.  (LF0 POINTS TO YH(*,2).) -------------------------
       LF0 = LYH + NYH
       IERR = 0
       CALL F (NEQ, T, Y, RWORK(LF0), IERR)
       IF (IERR .LT. 0) THEN
         ISTATE = -13
         RETURN
       ENDIF
       NFE = 1
 C LOAD THE INITIAL VALUE VECTOR IN YH. ---------------------------------
       DO 115 I = 1,N
- 115    RWORK(I+LYH-1) = Y(I) 
+ 115    RWORK(I+LYH-1) = Y(I)
 C LOAD AND INVERT THE EWT ARRAY.  (H IS TEMPORARILY SET TO 1.0.) -------
       NQ = 1
       H = 1.0D0
       CALL EWSET (N, ITOL, RTOL, ATOL, RWORK(LYH), RWORK(LEWT))
       DO 120 I = 1,N
-        IF (RWORK(I+LEWT-1) .LE. 0.0D0) GO TO 621 
+        IF (RWORK(I+LEWT-1) .LE. 0.0D0) GO TO 621
  120    RWORK(I+LEWT-1) = 1.0D0/RWORK(I+LEWT-1)
 C-----------------------------------------------------------------------
-C THE CODING BELOW COMPUTES THE STEP SIZE, H0, TO BE ATTEMPTED ON THE 
+C THE CODING BELOW COMPUTES THE STEP SIZE, H0, TO BE ATTEMPTED ON THE
 C FIRST STEP, UNLESS THE USER HAS SUPPLIED A VALUE FOR THIS.
 C FIRST CHECK THAT TOUT - T DIFFERS SIGNIFICANTLY FROM ZERO.
 C A SCALAR TOLERANCE QUANTITY TOL IS COMPUTED, AS MAX(RTOL(I))
 C IF THIS IS POSITIVE, OR MAX(ATOL(I)/ABS(Y(I))) OTHERWISE, ADJUSTED
 C SO AS TO BE BETWEEN 100*UROUND AND 1.0E-3.
 C THEN THE COMPUTED VALUE H0 IS GIVEN BY..
 C                                      NEQ
 C   H0**2 = TOL / ( W0**-2 + (1/NEQ) * SUM ( F(I)/YWT(I) )**2  )
@@ -1159,17 +1159,17 @@ C WHERE   W0     = MAX ( ABS(T), ABS(TOU
 C         F(I)   = I-TH COMPONENT OF INITIAL VALUE OF F,
 C         YWT(I) = EWT(I)/TOL  (A WEIGHT FOR Y(I)).
 C THE SIGN OF H0 IS INFERRED FROM THE INITIAL VALUES OF TOUT AND T.
 C-----------------------------------------------------------------------
       IF (H0 .NE. 0.0D0) GO TO 180
       TDIST = DABS(TOUT - T)
       W0 = DMAX1(DABS(T),DABS(TOUT))
       IF (TDIST .LT. 2.0D0*UROUND*W0) GO TO 622
-      TOL = RTOL(1) 
+      TOL = RTOL(1)
       IF (ITOL .LE. 2) GO TO 140
       DO 130 I = 1,N
  130    TOL = DMAX1(TOL,RTOL(I))
  140  IF (TOL .GT. 0.0D0) GO TO 160
       ATOLI = ATOL(1)
       DO 150 I = 1,N
         IF (ITOL .EQ. 2 .OR. ITOL .EQ. 4) ATOLI = ATOL(I)
         AYI = DABS(Y(I))
@@ -1215,51 +1215,51 @@ C---------------------------------------
       T = TOUT
       GO TO 420
  240  TCRIT = RWORK(1)
       IF ((TN - TCRIT)*H .GT. 0.0D0) GO TO 624
  245  HMX = DABS(TN) + DABS(H)
       IHIT = DABS(TN - TCRIT) .LE. 100.0D0*UROUND*HMX
       IF (IHIT) GO TO 400
       TNEXT = TN + H*(1.0D0 + 4.0D0*UROUND)
-      IF ((TNEXT - TCRIT)*H .LE. 0.0D0) GO TO 250 
+      IF ((TNEXT - TCRIT)*H .LE. 0.0D0) GO TO 250
       H = (TCRIT - TN)*(1.0D0 - 4.0D0*UROUND)
       IF (ISTATE .EQ. 2) JSTART = -2
 C-----------------------------------------------------------------------
 C BLOCK E.
 C THE NEXT BLOCK IS NORMALLY EXECUTED FOR ALL CALLS AND CONTAINS
-C THE CALL TO THE ONE-STEP CORE INTEGRATOR STODE. 
+C THE CALL TO THE ONE-STEP CORE INTEGRATOR STODE.
 C
 C THIS IS A LOOPING POINT FOR THE INTEGRATION STEPS.
 C
 C FIRST CHECK FOR TOO MANY STEPS BEING TAKEN, UPDATE EWT (IF NOT AT
-C START OF PROBLEM), CHECK FOR TOO MUCH ACCURACY BEING REQUESTED, AND 
+C START OF PROBLEM), CHECK FOR TOO MUCH ACCURACY BEING REQUESTED, AND
 C CHECK FOR H BELOW THE ROUNDOFF LEVEL IN T.
 C-----------------------------------------------------------------------
  250  CONTINUE
       IF ((NST-NSLAST) .GE. MXSTEP) GO TO 500
       CALL EWSET (N, ITOL, RTOL, ATOL, RWORK(LYH), RWORK(LEWT))
       DO 260 I = 1,N
-        IF (RWORK(I+LEWT-1) .LE. 0.0D0) GO TO 510 
+        IF (RWORK(I+LEWT-1) .LE. 0.0D0) GO TO 510
  260    RWORK(I+LEWT-1) = 1.0D0/RWORK(I+LEWT-1)
  270  TOLSF = UROUND*VNORM (N, RWORK(LYH), RWORK(LEWT))
       IF (TOLSF .LE. 1.0D0) GO TO 280
       TOLSF = TOLSF*2.0D0
       IF (NST .EQ. 0) GO TO 626
       GO TO 520
  280  IF ((TN + H) .NE. TN) GO TO 290
       NHNIL = NHNIL + 1
       IF (NHNIL .GT. MXHNIL) GO TO 290
       CALL XERRWD('LSODE--  WARNING..INTERNAL T (=R1) AND H (=R2) ARE',
      1   50, 101, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
       CALL XERRWD(
      1  '      SUCH THAT IN THE MACHINE, T + H = T ON THE NEXT STEP  ',
      1   60, 101, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
       CALL XERRWD('      (H = STEP SIZE). SOLVER WILL CONTINUE ANYWAY',
-     1   50, 101, 0, 0, 0, 0, 2, TN, H) 
+     1   50, 101, 0, 0, 0, 0, 2, TN, H)
       IF (NHNIL .LT. MXHNIL) GO TO 290
       CALL XERRWD('LSODE--  ABOVE WARNING HAS BEEN ISSUED I1 TIMES.  ',
      1   50, 102, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
       CALL XERRWD('      IT WILL NOT BE ISSUED AGAIN FOR THIS PROBLEM',
      1   50, 102, 0, 1, MXHNIL, 0, 0, 0.0D0, 0.0D0)
  290  CONTINUE
 C-----------------------------------------------------------------------
 C     CALL STODE(NEQ,Y,YH,NYH,YH,EWT,SAVF,ACOR,WM,IWM,F,JAC,PREPJ,SOLSY)
@@ -1293,41 +1293,41 @@ C ITASK = 4.  SEE IF TOUT OR TCRIT WAS R
  340  IF ((TN - TOUT)*H .LT. 0.0D0) GO TO 345
       CALL INTDY (TOUT, 0, RWORK(LYH), NYH, Y, IFLAG)
       T = TOUT
       GO TO 420
  345  HMX = DABS(TN) + DABS(H)
       IHIT = DABS(TN - TCRIT) .LE. 100.0D0*UROUND*HMX
       IF (IHIT) GO TO 400
       TNEXT = TN + H*(1.0D0 + 4.0D0*UROUND)
-      IF ((TNEXT - TCRIT)*H .LE. 0.0D0) GO TO 250 
+      IF ((TNEXT - TCRIT)*H .LE. 0.0D0) GO TO 250
       H = (TCRIT - TN)*(1.0D0 - 4.0D0*UROUND)
       JSTART = -2
       GO TO 250
 C ITASK = 5.  SEE IF TCRIT WAS REACHED AND JUMP TO EXIT. ---------------
  350  HMX = DABS(TN) + DABS(H)
       IHIT = DABS(TN - TCRIT) .LE. 100.0D0*UROUND*HMX
 C-----------------------------------------------------------------------
 C BLOCK G.
 C THE FOLLOWING BLOCK HANDLES ALL SUCCESSFUL RETURNS FROM LSODE.
 C IF ITASK .NE. 1, Y IS LOADED FROM YH AND T IS SET ACCORDINGLY.
 C ISTATE IS SET TO 2, THE ILLEGAL INPUT COUNTER IS ZEROED, AND THE
 C OPTIONAL OUTPUTS ARE LOADED INTO THE WORK ARRAYS BEFORE RETURNING.
-C IF ISTATE = 1 AND TOUT = T, THERE IS A RETURN WITH NO ACTION TAKEN, 
-C EXCEPT THAT IF THIS HAS HAPPENED REPEATEDLY, THE RUN IS TERMINATED. 
+C IF ISTATE = 1 AND TOUT = T, THERE IS A RETURN WITH NO ACTION TAKEN,
+C EXCEPT THAT IF THIS HAS HAPPENED REPEATEDLY, THE RUN IS TERMINATED.
 C-----------------------------------------------------------------------
  400  DO 410 I = 1,N
- 410    Y(I) = RWORK(I+LYH-1) 
+ 410    Y(I) = RWORK(I+LYH-1)
       T = TN
       IF (ITASK .NE. 4 .AND. ITASK .NE. 5) GO TO 420
       IF (IHIT) T = TCRIT
  420  ISTATE = 2
       ILLIN = 0
       RWORK(11) = HU
-      RWORK(12) = H 
+      RWORK(12) = H
       RWORK(13) = TN
       IWORK(11) = NST
       IWORK(12) = NFE
       IWORK(13) = NJE
       IWORK(14) = NQU
       IWORK(15) = NQ
       RETURN
 C
@@ -1366,73 +1366,73 @@ C TOO MUCH ACCURACY REQUESTED FOR MACHIN
      1   50, 203, 0, 0, 0, 0, 2, TN, TOLSF)
       RWORK(14) = TOLSF
       ISTATE = -2
       GO TO 580
 C KFLAG = -1.  ERROR TEST FAILED REPEATEDLY OR WITH ABS(H) = HMIN. -----
  530  CALL XERRWD('LSODE--  AT T(=R1) AND STEP SIZE H(=R2), THE ERROR',
      1   50, 204, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
       CALL XERRWD('      TEST FAILED REPEATEDLY OR WITH ABS(H) = HMIN',
-     1   50, 204, 0, 0, 0, 0, 2, TN, H) 
+     1   50, 204, 0, 0, 0, 0, 2, TN, H)
       ISTATE = -4
       GO TO 560
 C KFLAG = -2.  CONVERGENCE FAILED REPEATEDLY OR WITH ABS(H) = HMIN. ----
  540  CALL XERRWD('LSODE--  AT T (=R1) AND STEP SIZE H (=R2), THE    ',
      1   50, 205, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
       CALL XERRWD('      CORRECTOR CONVERGENCE FAILED REPEATEDLY     ',
      1   50, 205, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
       CALL XERRWD('      OR WITH ABS(H) = HMIN   ',
-     1   30, 205, 0, 0, 0, 0, 2, TN, H) 
+     1   30, 205, 0, 0, 0, 0, 2, TN, H)
       ISTATE = -5
 C COMPUTE IMXER IF RELEVANT. -------------------------------------------
  560  BIG = 0.0D0
       IMXER = 1
       DO 570 I = 1,N
         SIZE = DABS(RWORK(I+LACOR-1)*RWORK(I+LEWT-1))
         IF (BIG .GE. SIZE) GO TO 570
         BIG = SIZE
         IMXER = I
  570    CONTINUE
       IWORK(16) = IMXER
 C SET Y VECTOR, T, ILLIN, AND OPTIONAL OUTPUTS. ------------------------
  580  DO 590 I = 1,N
- 590    Y(I) = RWORK(I+LYH-1) 
+ 590    Y(I) = RWORK(I+LYH-1)
       T = TN
       ILLIN = 0
       RWORK(11) = HU
-      RWORK(12) = H 
+      RWORK(12) = H
       RWORK(13) = TN
       IWORK(11) = NST
       IWORK(12) = NFE
       IWORK(13) = NJE
       IWORK(14) = NQU
       IWORK(15) = NQ
       RETURN
 C-----------------------------------------------------------------------
 C BLOCK I.
 C THE FOLLOWING BLOCK HANDLES ALL ERROR RETURNS DUE TO ILLEGAL INPUT
 C (ISTATE = -3), AS DETECTED BEFORE CALLING THE CORE INTEGRATOR.
-C FIRST THE ERROR MESSAGE ROUTINE IS CALLED.  THEN IF THERE HAVE BEEN 
+C FIRST THE ERROR MESSAGE ROUTINE IS CALLED.  THEN IF THERE HAVE BEEN
 C 5 CONSECUTIVE SUCH RETURNS JUST BEFORE THIS CALL TO THE SOLVER,
 C THE RUN IS HALTED.
 C-----------------------------------------------------------------------
  601  CALL XERRWD('LSODE--  ISTATE (=I1) ILLEGAL ',
-     1   30, 1, 0, 1, ISTATE, 0, 0, 0.0D0, 0.0D0) 
+     1   30, 1, 0, 1, ISTATE, 0, 0, 0.0D0, 0.0D0)
       GO TO 700
  602  CALL XERRWD('LSODE--  ITASK (=I1) ILLEGAL  ',
      1   30, 2, 0, 1, ITASK, 0, 0, 0.0D0, 0.0D0)
       GO TO 700
  603  CALL XERRWD('LSODE--  ISTATE .GT. 1 BUT LSODE NOT INITIALIZED  ',
      1   50, 3, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
       GO TO 700
  604  CALL XERRWD('LSODE--  NEQ (=I1) .LT. 1     ',
-     1   30, 4, 0, 1, NEQ(1), 0, 0, 0.0D0, 0.0D0) 
+     1   30, 4, 0, 1, NEQ(1), 0, 0, 0.0D0, 0.0D0)
       GO TO 700
  605  CALL XERRWD('LSODE--  ISTATE = 3 AND NEQ INCREASED (I1 TO I2)  ',
-     1   50, 5, 0, 2, N, NEQ(1), 0, 0.0D0, 0.0D0) 
+     1   50, 5, 0, 2, N, NEQ(1), 0, 0.0D0, 0.0D0)
       GO TO 700
  606  CALL XERRWD('LSODE--  ITOL (=I1) ILLEGAL   ',
      1   30, 6, 0, 1, ITOL, 0, 0, 0.0D0, 0.0D0)
       GO TO 700
  607  CALL XERRWD('LSODE--  IOPT (=I1) ILLEGAL   ',
      1   30, 7, 0, 1, IOPT, 0, 0, 0.0D0, 0.0D0)
       GO TO 700
  608  CALL XERRWD('LSODE--  MF (=I1) ILLEGAL     ',
@@ -1514,9 +1514,9 @@ C
       RETURN
  710  CALL XERRWD('LSODE--  REPEATED OCCURRENCES OF ILLEGAL INPUT    ',
      1   50, 302, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
 C
  800  CALL XERRWD('LSODE--  RUN ABORTED.. APPARENT INFINITE LOOP     ',
      1   50, 303, 2, 0, 0, 0, 0, 0.0D0, 0.0D0)
       RETURN
 C----------------------- END OF SUBROUTINE LSODE -----------------------
-      END 
+      END
diff --git a/liboctave/cruft/odepack/ewset.f b/liboctave/cruft/odepack/ewset.f
--- a/liboctave/cruft/odepack/ewset.f
+++ b/liboctave/cruft/odepack/ewset.f
@@ -4,29 +4,29 @@ C---------------------------------------
 C THIS SUBROUTINE SETS THE ERROR WEIGHT VECTOR EWT ACCORDING TO
 C     EWT(I) = RTOL(I)*ABS(YCUR(I)) + ATOL(I),  I = 1,...,N,
 C WITH THE SUBSCRIPT ON RTOL AND/OR ATOL POSSIBLY REPLACED BY 1 ABOVE,
 C DEPENDING ON THE VALUE OF ITOL.
 C-----------------------------------------------------------------------
       INTEGER N, ITOL
       INTEGER I
       DOUBLE PRECISION RTOL, ATOL, YCUR, EWT
-      DIMENSION RTOL(*), ATOL(*), YCUR(N), EWT(N) 
+      DIMENSION RTOL(*), ATOL(*), YCUR(N), EWT(N)
 C
       GO TO (10, 20, 30, 40), ITOL
  10   CONTINUE
-      DO 15 I = 1,N 
+      DO 15 I = 1,N
  15     EWT(I) = RTOL(1)*DABS(YCUR(I)) + ATOL(1)
       RETURN
  20   CONTINUE
-      DO 25 I = 1,N 
+      DO 25 I = 1,N
  25     EWT(I) = RTOL(1)*DABS(YCUR(I)) + ATOL(I)
       RETURN
  30   CONTINUE
-      DO 35 I = 1,N 
+      DO 35 I = 1,N
  35     EWT(I) = RTOL(I)*DABS(YCUR(I)) + ATOL(1)
       RETURN
  40   CONTINUE
-      DO 45 I = 1,N 
+      DO 45 I = 1,N
  45     EWT(I) = RTOL(I)*DABS(YCUR(I)) + ATOL(I)
       RETURN
 C----------------------- END OF SUBROUTINE EWSET -----------------------
-      END 
+      END
diff --git a/liboctave/cruft/odepack/intdy.f b/liboctave/cruft/odepack/intdy.f
--- a/liboctave/cruft/odepack/intdy.f
+++ b/liboctave/cruft/odepack/intdy.f
@@ -1,36 +1,36 @@
       SUBROUTINE INTDY (T, K, YH, NYH, DKY, IFLAG)
 CLLL. OPTIMIZE
       INTEGER K, NYH, IFLAG
       INTEGER IOWND, IOWNS,
      1   ICF, IERPJ, IERSL, JCUR, JSTART, KFLAG, L, METH, MITER,
      2   MAXORD, MAXCOR, MSBP, MXNCF, N, NQ, NST, NFE, NJE, NQU
       INTEGER I, IC, J, JB, JB2, JJ, JJ1, JP1
       DOUBLE PRECISION T, YH, DKY
-      DOUBLE PRECISION ROWNS, 
+      DOUBLE PRECISION ROWNS,
      1   CCMAX, EL0, H, HMIN, HMXI, HU, RC, TN, UROUND
       DOUBLE PRECISION C, R, S, TP
       DIMENSION YH(NYH,*), DKY(*)
       COMMON /LS0001/ ROWNS(209),
      2   CCMAX, EL0, H, HMIN, HMXI, HU, RC, TN, UROUND,
-     3   IOWND(14), IOWNS(6), 
+     3   IOWND(14), IOWNS(6),
      4   ICF, IERPJ, IERSL, JCUR, JSTART, KFLAG, L, METH, MITER,
      5   MAXORD, MAXCOR, MSBP, MXNCF, N, NQ, NST, NFE, NJE, NQU
 C-----------------------------------------------------------------------
 C INTDY COMPUTES INTERPOLATED VALUES OF THE K-TH DERIVATIVE OF THE
 C DEPENDENT VARIABLE VECTOR Y, AND STORES IT IN DKY.  THIS ROUTINE
 C IS CALLED WITHIN THE PACKAGE WITH K = 0 AND T = TOUT, BUT MAY
 C ALSO BE CALLED BY THE USER FOR ANY K UP TO THE CURRENT ORDER.
 C (SEE DETAILED INSTRUCTIONS IN THE USAGE DOCUMENTATION.)
 C-----------------------------------------------------------------------
 C THE COMPUTED VALUES IN DKY ARE GOTTEN BY INTERPOLATION USING THE
 C NORDSIECK HISTORY ARRAY YH.  THIS ARRAY CORRESPONDS UNIQUELY TO A
 C VECTOR-VALUED POLYNOMIAL OF DEGREE NQCUR OR LESS, AND DKY IS SET
-C TO THE K-TH DERIVATIVE OF THIS POLYNOMIAL AT T. 
+C TO THE K-TH DERIVATIVE OF THIS POLYNOMIAL AT T.
 C THE FORMULA FOR DKY IS..
 C              Q
 C  DKY(I)  =  SUM  C(J,K) * (T - TN)**(J-K) * H**(-J) * YH(I,J+1)
 C             J=K
 C WHERE  C(J,K) = J*(J-1)*...*(J-K+1), Q = NQCUR, TN = TCUR, H = HCUR.
 C THE QUANTITIES  NQ = NQCUR, L = NQ+1, N = NEQ, TN, AND H ARE
 C COMMUNICATED BY COMMON.  THE ABOVE SUM IS DONE IN REVERSE ORDER.
 C IFLAG IS RETURNED NEGATIVE IF EITHER K OR T IS OUT OF BOUNDS.
@@ -42,43 +42,43 @@ C---------------------------------------
 C
       S = (T - TN)/H
       IC = 1
       IF (K .EQ. 0) GO TO 15
       JJ1 = L - K
       DO 10 JJ = JJ1,NQ
  10     IC = IC*JJ
  15   C = DBLE(IC)
-      DO 20 I = 1,N 
+      DO 20 I = 1,N
  20     DKY(I) = C*YH(I,L)
-      IF (K .EQ. NQ) GO TO 55 
+      IF (K .EQ. NQ) GO TO 55
       JB2 = NQ - K
       DO 50 JB = 1,JB2
-        J = NQ - JB 
-        JP1 = J + 1 
+        J = NQ - JB
+        JP1 = J + 1
         IC = 1
         IF (K .EQ. 0) GO TO 35
         JJ1 = JP1 - K
         DO 30 JJ = JJ1,J
  30       IC = IC*JJ
  35     C = DBLE(IC)
         DO 40 I = 1,N
  40       DKY(I) = C*YH(I,JP1) + S*DKY(I)
  50     CONTINUE
       IF (K .EQ. 0) RETURN
  55   R = H**(-K)
-      DO 60 I = 1,N 
+      DO 60 I = 1,N
  60     DKY(I) = R*DKY(I)
       RETURN
 C
  80   CALL XERRWD('INTDY--  K (=I1) ILLEGAL      ',
      1   30, 51, 0, 1, K, 0, 0, 0.0D0, 0.0D0)
       IFLAG = -1
       RETURN
  90   CALL XERRWD('INTDY--  T (=R1) ILLEGAL      ',
      1   30, 52, 0, 0, 0, 0, 1, T, 0.0D0)
       CALL XERRWD(
      1  '      T NOT IN INTERVAL TCUR - HU (= R1) TO TCUR (=R2)      ',
-     1   60, 52, 0, 0, 0, 0, 2, TP, TN) 
+     1   60, 52, 0, 0, 0, 0, 2, TP, TN)
       IFLAG = -2
       RETURN
 C----------------------- END OF SUBROUTINE INTDY -----------------------
-      END 
+      END
diff --git a/liboctave/cruft/odepack/prepj.f b/liboctave/cruft/odepack/prepj.f
--- a/liboctave/cruft/odepack/prepj.f
+++ b/liboctave/cruft/odepack/prepj.f
@@ -3,160 +3,160 @@
 CLLL. OPTIMIZE
       EXTERNAL F, JAC
       INTEGER NEQ, NYH, IWM
       INTEGER IOWND, IOWNS,
      1   ICF, IERPJ, IERSL, JCUR, JSTART, KFLAG, L, METH, MITER,
      2   MAXORD, MAXCOR, MSBP, MXNCF, N, NQ, NST, NFE, NJE, NQU
       INTEGER I, I1, I2, IER, II, J, J1, JJ, LENP,
      1   MBA, MBAND, MEB1, MEBAND, ML, ML3, MU, NP1
-      DOUBLE PRECISION Y, YH, EWT, FTEM, SAVF, WM 
-      DOUBLE PRECISION ROWNS, 
+      DOUBLE PRECISION Y, YH, EWT, FTEM, SAVF, WM
+      DOUBLE PRECISION ROWNS,
      1   CCMAX, EL0, H, HMIN, HMXI, HU, RC, TN, UROUND
       DOUBLE PRECISION CON, DI, FAC, HL0, R, R0, SRUR, YI, YJ, YJJ,
      1   VNORM
       DIMENSION NEQ(*), Y(*), YH(NYH,*), EWT(*), FTEM(*), SAVF(*),
      1   WM(*), IWM(*)
       COMMON /LS0001/ ROWNS(209),
      2   CCMAX, EL0, H, HMIN, HMXI, HU, RC, TN, UROUND,
-     3   IOWND(14), IOWNS(6), 
+     3   IOWND(14), IOWNS(6),
      4   ICF, IERPJ, IERSL, JCUR, JSTART, KFLAG, L, METH, MITER,
      5   MAXORD, MAXCOR, MSBP, MXNCF, N, NQ, NST, NFE, NJE, NQU
 C-----------------------------------------------------------------------
 C PREPJ IS CALLED BY STODE TO COMPUTE AND PROCESS THE MATRIX
 C P = I - H*EL(1)*J , WHERE J IS AN APPROXIMATION TO THE JACOBIAN.
 C HERE J IS COMPUTED BY THE USER-SUPPLIED ROUTINE JAC IF
 C MITER = 1 OR 4, OR BY FINITE DIFFERENCING IF MITER = 2, 3, OR 5.
 C IF MITER = 3, A DIAGONAL APPROXIMATION TO J IS USED.
 C J IS STORED IN WM AND REPLACED BY P.  IF MITER .NE. 3, P IS THEN
 C SUBJECTED TO LU DECOMPOSITION IN PREPARATION FOR LATER SOLUTION
 C OF LINEAR SYSTEMS WITH P AS COEFFICIENT MATRIX. THIS IS DONE
 C BY DGETRF IF MITER = 1 OR 2, AND BY DGBTRF IF MITER = 4 OR 5.
 C
 C IN ADDITION TO VARIABLES DESCRIBED PREVIOUSLY, COMMUNICATION
 C WITH PREPJ USES THE FOLLOWING..
 C Y     = ARRAY CONTAINING PREDICTED VALUES ON ENTRY.
-C FTEM  = WORK ARRAY OF LENGTH N (ACOR IN STODE). 
+C FTEM  = WORK ARRAY OF LENGTH N (ACOR IN STODE).
 C SAVF  = ARRAY CONTAINING F EVALUATED AT PREDICTED Y.
 C WM    = REAL WORK SPACE FOR MATRICES.  ON OUTPUT IT CONTAINS THE
 C         INVERSE DIAGONAL MATRIX IF MITER = 3 AND THE LU DECOMPOSITION
 C         OF P IF MITER IS 1, 2 , 4, OR 5.
 C         STORAGE OF MATRIX ELEMENTS STARTS AT WM(3).
 C         WM ALSO CONTAINS THE FOLLOWING MATRIX-RELATED DATA..
 C         WM(1) = SQRT(UROUND), USED IN NUMERICAL JACOBIAN INCREMENTS.
 C         WM(2) = H*EL0, SAVED FOR LATER USE IF MITER = 3.
 C IWM   = INTEGER WORK SPACE CONTAINING PIVOT INFORMATION, STARTING AT
-C         IWM(21), IF MITER IS 1, 2, 4, OR 5.  IWM ALSO CONTAINS BAND 
+C         IWM(21), IF MITER IS 1, 2, 4, OR 5.  IWM ALSO CONTAINS BAND
 C         PARAMETERS ML = IWM(1) AND MU = IWM(2) IF MITER IS 4 OR 5.
 C EL0   = EL(1) (INPUT).
 C IERPJ = OUTPUT ERROR FLAG,  = 0 IF NO TROUBLE, .GT. 0 IF
 C         P MATRIX FOUND TO BE SINGULAR.
 C JCUR  = OUTPUT FLAG = 1 TO INDICATE THAT THE JACOBIAN MATRIX
 C         (OR APPROXIMATION) IS NOW CURRENT.
 C THIS ROUTINE ALSO USES THE COMMON VARIABLES EL0, H, TN, UROUND,
 C MITER, N, NFE, AND NJE.
 C-----------------------------------------------------------------------
-      NJE = NJE + 1 
+      NJE = NJE + 1
       IERPJ = 0
       JCUR = 1
       HL0 = H*EL0
       GO TO (100, 200, 300, 400, 500), MITER
 C IF MITER = 1, CALL JAC AND MULTIPLY BY SCALAR. -----------------------
  100  LENP = N*N
       DO 110 I = 1,LENP
  110    WM(I+2) = 0.0D0
       CALL JAC (NEQ, TN, Y, 0, 0, WM(3), N)
       CON = -HL0
       DO 120 I = 1,LENP
- 120    WM(I+2) = WM(I+2)*CON 
+ 120    WM(I+2) = WM(I+2)*CON
       GO TO 240
 C IF MITER = 2, MAKE N CALLS TO F TO APPROXIMATE J. --------------------
  200  FAC = VNORM (N, SAVF, EWT)
-      R0 = 1000.0D0*DABS(H)*UROUND*DBLE(N)*FAC  
+      R0 = 1000.0D0*DABS(H)*UROUND*DBLE(N)*FAC
       IF (R0 .EQ. 0.0D0) R0 = 1.0D0
       SRUR = WM(1)
       J1 = 2
       DO 230 J = 1,N
         YJ = Y(J)
         R = DMAX1(SRUR*DABS(YJ),R0/EWT(J))
         Y(J) = Y(J) + R
         FAC = -HL0/R
         IERR = 0
         CALL F (NEQ, TN, Y, FTEM, IERR)
         IF (IERR .LT. 0) RETURN
         DO 220 I = 1,N
  220      WM(I+J1) = (FTEM(I) - SAVF(I))*FAC
         Y(J) = YJ
-        J1 = J1 + N 
+        J1 = J1 + N
  230    CONTINUE
-      NFE = NFE + N 
+      NFE = NFE + N
 C ADD IDENTITY MATRIX. -------------------------------------------------
  240  J = 3
       NP1 = N + 1
       DO 250 I = 1,N
-        WM(J) = WM(J) + 1.0D0 
- 250    J = J + NP1 
+        WM(J) = WM(J) + 1.0D0
+ 250    J = J + NP1
 C DO LU DECOMPOSITION ON P. --------------------------------------------
       CALL DGETRF ( N, N, WM(3), N, IWM(21), IER)
       IF (IER .NE. 0) IERPJ = 1
       RETURN
 C IF MITER = 3, CONSTRUCT A DIAGONAL APPROXIMATION TO J AND P. ---------
  300  WM(2) = HL0
-      R = EL0*0.1D0 
+      R = EL0*0.1D0
       DO 310 I = 1,N
  310    Y(I) = Y(I) + R*(H*SAVF(I) - YH(I,2))
       IERR = 0
       CALL F (NEQ, TN, Y, WM(3), IERR)
       IF (IERR .LT. 0) RETURN
-      NFE = NFE + 1 
+      NFE = NFE + 1
       DO 320 I = 1,N
         R0 = H*SAVF(I) - YH(I,2)
         DI = 0.1D0*R0 - H*(WM(I+2) - SAVF(I))
         WM(I+2) = 1.0D0
         IF (DABS(R0) .LT. UROUND/EWT(I)) GO TO 320
         IF (DABS(DI) .EQ. 0.0D0) GO TO 330
-        WM(I+2) = 0.1D0*R0/DI 
+        WM(I+2) = 0.1D0*R0/DI
  320    CONTINUE
       RETURN
  330  IERPJ = 1
       RETURN
 C IF MITER = 4, CALL JAC AND MULTIPLY BY SCALAR. -----------------------
  400  ML = IWM(1)
       MU = IWM(2)
       ML3 = ML + 3
       MBAND = ML + MU + 1
       MEBAND = MBAND + ML
       LENP = MEBAND*N
       DO 410 I = 1,LENP
  410    WM(I+2) = 0.0D0
       CALL JAC (NEQ, TN, Y, ML, MU, WM(ML3), MEBAND)
       CON = -HL0
       DO 420 I = 1,LENP
- 420    WM(I+2) = WM(I+2)*CON 
+ 420    WM(I+2) = WM(I+2)*CON
       GO TO 570
 C IF MITER = 5, MAKE MBAND CALLS TO F TO APPROXIMATE J. ----------------
  500  ML = IWM(1)
       MU = IWM(2)
       MBAND = ML + MU + 1
       MBA = MIN0(MBAND,N)
       MEBAND = MBAND + ML
       MEB1 = MEBAND - 1
       SRUR = WM(1)
       FAC = VNORM (N, SAVF, EWT)
-      R0 = 1000.0D0*DABS(H)*UROUND*DBLE(N)*FAC  
+      R0 = 1000.0D0*DABS(H)*UROUND*DBLE(N)*FAC
       IF (R0 .EQ. 0.0D0) R0 = 1.0D0
       DO 560 J = 1,MBA
         DO 530 I = J,N,MBAND
-          YI = Y(I) 
+          YI = Y(I)
           R = DMAX1(SRUR*DABS(YI),R0/EWT(I))
  530      Y(I) = Y(I) + R
         IERR = 0
         CALL F (NEQ, TN, Y, FTEM, IERR)
         IF (IERR .LT. 0) RETURN
-        DO 550 JJ = J,N,MBAND 
+        DO 550 JJ = J,N,MBAND
           Y(JJ) = YH(JJ,1)
           YJJ = Y(JJ)
           R = DMAX1(SRUR*DABS(YJJ),R0/EWT(JJ))
           FAC = -HL0/R
           I1 = MAX0(JJ-MU,1)
           I2 = MIN0(JJ+ML,N)
           II = JJ*MEB1 - ML + 2
           DO 540 I = I1,I2
@@ -169,9 +169,9 @@ C ADD IDENTITY MATRIX. -----------------
       DO 580 I = 1,N
         WM(II) = WM(II) + 1.0D0
  580    II = II + MEBAND
 C DO LU DECOMPOSITION OF P. --------------------------------------------
       CALL DGBTRF ( N, N, ML, MU, WM(3), MEBAND, IWM(21), IER)
       IF (IER .NE. 0) IERPJ = 1
       RETURN
 C----------------------- END OF SUBROUTINE PREPJ -----------------------
-      END 
+      END
diff --git a/liboctave/cruft/odepack/sintdy.f b/liboctave/cruft/odepack/sintdy.f
--- a/liboctave/cruft/odepack/sintdy.f
+++ b/liboctave/cruft/odepack/sintdy.f
@@ -88,21 +88,21 @@ C
  40       DKY(I) = C*YH(I,JP1) + S*DKY(I)
  50     CONTINUE
       IF (K .EQ. 0) RETURN
  55   R = H**(-K)
       DO 60 I = 1,N
  60     DKY(I) = R*DKY(I)
       RETURN
 C
- 80   CALL XERRWD('SINTDY-  K (=I1) illegal      ', 
+ 80   CALL XERRWD('SINTDY-  K (=I1) illegal      ',
      1     30, 51, 0, 1, K, 0, 0, 0.0E0, 0.0E0)
       IFLAG = -1
       RETURN
- 90   CALL XERRWD('SINTDY-  T (=R1) illegal      ', 
+ 90   CALL XERRWD('SINTDY-  T (=R1) illegal      ',
      1     30, 52, 0, 0, 0, 0, 1, T, 0.0E0)
       CALL XERRWD(
      1   '      T not in interval TCUR - HU (= R1) to TCUR (=R2)      ',
      1    60, 52, 0, 0, 0, 0, 2, TP, TN)
       IFLAG = -2
       RETURN
 C----------------------- END OF SUBROUTINE SINTDY ----------------------
       END
diff --git a/liboctave/cruft/odepack/slsode.f b/liboctave/cruft/odepack/slsode.f
--- a/liboctave/cruft/odepack/slsode.f
+++ b/liboctave/cruft/odepack/slsode.f
@@ -290,20 +290,20 @@ C     and consists of the following thre
 C
 C        dy1/dt = -.04*y1 + 1.E4*y2*y3
 C        dy2/dt = .04*y1 - 1.E4*y2*y3 - 3.E7*y2**2
 C        dy3/dt = 3.E7*y2**2
 C
 C     on the interval from t = 0.0 to t = 4.E10, with initial conditions
 C     y1 = 1.0, y2 = y3 = 0. The problem is stiff.
 C
-C     The following coding solves this problem with SLSODE, using 
-C     MF = 21 and printing results at t = .4, 4., ..., 4.E10.  It uses 
-C     ITOL = 2 and ATOL much smaller for y2 than for y1 or y3 because y2 
-C     has much smaller values.  At the end of the run, statistical 
+C     The following coding solves this problem with SLSODE, using
+C     MF = 21 and printing results at t = .4, 4., ..., 4.E10.  It uses
+C     ITOL = 2 and ATOL much smaller for y2 than for y1 or y3 because y2
+C     has much smaller values.  At the end of the run, statistical
 C     quantities of interest are printed.
 C
 C        EXTERNAL  FEX, JEX
 C        INTEGER  IOPT, IOUT, ISTATE, ITASK, ITOL, IWORK(23), LIW, LRW,
 C       *         MF, NEQ
 C        REAL  ATOL(3), RTOL, RWORK(58), T, TOUT, Y(3)
 C        NEQ = 3
 C        Y(1) = 1.
@@ -384,17 +384,17 @@ C     tolerances, so choose them conserv
 C
 C *Cautions:
 C     The work arrays should not be altered between calls to SLSODE for
 C     the same problem, except possibly for the conditional and optional
 C     inputs.
 C
 C *Portability:
 C     Since NEQ is dimensioned inside SLSODE, some compilers may object
-C     to a call to SLSODE with NEQ a scalar variable.  In this event, 
+C     to a call to SLSODE with NEQ a scalar variable.  In this event,
 C     use DIMENSION NEQ(1).  Similar remarks apply to RTOL and ATOL.
 C
 C     Note to Cray users:
 C     For maximum efficiency, use the CFT77 compiler.  Appropriate
 C     compiler optimization directives have been inserted for CFT77.
 C
 C *Reference:
 C     Alan C. Hindmarsh, "ODEPACK, A Systematized Collection of ODE
@@ -872,19 +872,19 @@ C     MXHNIL  IWORK(7)   Maximum number 
 C                        problem) warning that T + H = T on a step
 C                        (H = step size).  This must be positive to
 C                        result in a nondefault value.  The default
 C                        value is 10.
 C
 C     Optional Outputs
 C     ----------------
 C     As optional additional output from SLSODE, the variables listed
-C     below are quantities related to the performance of SLSODE which 
+C     below are quantities related to the performance of SLSODE which
 C     are available to the user.  These are communicated by way of the
-C     work arrays, but also have internal mnemonic names as shown. 
+C     work arrays, but also have internal mnemonic names as shown.
 C     Except where stated otherwise, all of these outputs are defined on
 C     any successful return from SLSODE, and on any return with ISTATE =
 C     -1, -2, -4, -5, or -6.  On an illegal input return (ISTATE = -3),
 C     they will be unchanged from their existing values (if any), except
 C     possibly for TOLSF, LENRW, and LENIW.  On any error return,
 C     outputs relevant to the error will be defined, as noted below.
 C
 C     Name   Location   Meaning
@@ -1016,17 +1016,17 @@ C                On an error return, a m
 C
 C
 C                          Part 3.  Common Blocks
 C                          ----------------------
 C
 C     If SLSODE is to be used in an overlay situation, the user must
 C     declare, in the primary overlay, the variables in:
 C     (1) the call sequence to SLSODE,
-C     (2) the internal COMMON block /SLS001/, of length 255 
+C     (2) the internal COMMON block /SLS001/, of length 255
 C         (218 single precision words followed by 37 integer words).
 C
 C     If SLSODE is used on a system in which the contents of internal
 C     COMMON blocks are not preserved between calls, the user should
 C     declare the above COMMON block in his main program to insure that
 C     its contents are preserved.
 C
 C     If the solution of a given problem by SLSODE is to be interrupted
@@ -1152,17 +1152,17 @@ C 19920514  Updated with prologue edited
 C 19920515  Converted source lines to upper case.  (FNF)
 C 19920603  Revised XERRWV calls using mixed upper-lower case.  (ACH)
 C 19920616  Revised prologue comment regarding CFT.  (ACH)
 C 19921116  Revised prologue comments regarding Common.  (ACH).
 C 19930326  Added comment about non-reentrancy.  (FNF)
 C 19930723  Changed R1MACH to RUMACH. (FNF)
 C 19930801  Removed ILLIN and NTREP from Common (affects driver logic);
 C           minor changes to prologue and internal comments;
-C           changed Hollerith strings to quoted strings; 
+C           changed Hollerith strings to quoted strings;
 C           changed internal comments to mixed case;
 C           replaced XERRWV with new version using character type;
 C           changed dummy dimensions from 1 to *. (ACH)
 C 19930809  Changed to generic intrinsic names; changed names of
 C           subprograms and Common blocks to SLSODE etc. (ACH)
 C 19930929  Eliminated use of REAL intrinsic; other minor changes. (ACH)
 C 20010412  Removed all 'own' variables from Common block /SLS001/
 C           (affects declarations in 6 routines). (ACH)
@@ -1499,27 +1499,27 @@ C---------------------------------------
  270  TOLSF = UROUND*SVNORM (N, RWORK(LYH), RWORK(LEWT))
       IF (TOLSF .LE. 1.0E0) GO TO 280
       TOLSF = TOLSF*2.0E0
       IF (NST .EQ. 0) GO TO 626
       GO TO 520
  280  IF ((TN + H) .NE. TN) GO TO 290
       NHNIL = NHNIL + 1
       IF (NHNIL .GT. MXHNIL) GO TO 290
-      CALL XERRWD('SLSODE-  Warning..internal T (=R1) and H (=R2) are', 
+      CALL XERRWD('SLSODE-  Warning..internal T (=R1) and H (=R2) are',
      1     50, 101, 0, 0, 0, 0, 0, 0.0E0, 0.0E0)
       CALL XERRWD(
-     1  '      such that in the machine, T + H = T on the next step  ', 
+     1  '      such that in the machine, T + H = T on the next step  ',
      1     60, 101, 0, 0, 0, 0, 0, 0.0E0, 0.0E0)
-      CALL XERRWD('      (H = step size). Solver will continue anyway', 
+      CALL XERRWD('      (H = step size). Solver will continue anyway',
      1     50, 101, 0, 0, 0, 0, 2, TN, H)
       IF (NHNIL .LT. MXHNIL) GO TO 290
-      CALL XERRWD('SLSODE-  Above warning has been issued I1 times.  ', 
+      CALL XERRWD('SLSODE-  Above warning has been issued I1 times.  ',
      1     50, 102, 0, 0, 0, 0, 0, 0.0E0, 0.0E0)
-      CALL XERRWD('      It will not be issued again for this problem', 
+      CALL XERRWD('      It will not be issued again for this problem',
      1     50, 102, 0, 1, MXHNIL, 0, 0, 0.0E0, 0.0E0)
  290  CONTINUE
 C-----------------------------------------------------------------------
 C  CALL SSTODE(NEQ,Y,YH,NYH,YH,EWT,SAVF,ACOR,WM,IWM,F,JAC,SPREPJ,SSOLSY)
 C-----------------------------------------------------------------------
       CALL SSTODE (NEQ, Y, RWORK(LYH), NYH, RWORK(LYH), RWORK(LEWT),
      1   RWORK(LSAVF), RWORK(LACOR), RWORK(LWM), IWORK(LIWM),
      2   F, JAC, SPREPJ, SSOLSY)
@@ -1582,49 +1582,49 @@ C---------------------------------------
 C Block H.
 C The following block handles all unsuccessful returns other than
 C those for illegal input.  First the error message routine is called.
 C If there was an error test or convergence test failure, IMXER is set.
 C Then Y is loaded from YH and T is set to TN.  The optional outputs
 C are loaded into the work arrays before returning.
 C-----------------------------------------------------------------------
 C The maximum number of steps was taken before reaching TOUT. ----------
- 500  CALL XERRWD('SLSODE-  At current T (=R1), MXSTEP (=I1) steps   ', 
+ 500  CALL XERRWD('SLSODE-  At current T (=R1), MXSTEP (=I1) steps   ',
      1 50, 201, 0, 0, 0, 0, 0, 0.0E0, 0.0E0)
-      CALL XERRWD('      taken on this call before reaching TOUT     ', 
+      CALL XERRWD('      taken on this call before reaching TOUT     ',
      1     50, 201, 0, 1, MXSTEP, 0, 1, TN, 0.0E0)
       ISTATE = -1
       GO TO 580
 C EWT(I) .LE. 0.0 for some I (not at start of problem). ----------------
  510  EWTI = RWORK(LEWT+I-1)
-      CALL XERRWD('SLSODE-  At T (=R1), EWT(I1) has become R2 .LE. 0.', 
+      CALL XERRWD('SLSODE-  At T (=R1), EWT(I1) has become R2 .LE. 0.',
      1 50, 202, 0, 1, I, 0, 2, TN, EWTI)
       ISTATE = -6
       GO TO 580
 C Too much accuracy requested for machine precision. -------------------
- 520  CALL XERRWD('SLSODE-  At T (=R1), too much accuracy requested  ', 
+ 520  CALL XERRWD('SLSODE-  At T (=R1), too much accuracy requested  ',
      1     50, 203, 0, 0, 0, 0, 0, 0.0E0, 0.0E0)
-      CALL XERRWD('      for precision of machine..  see TOLSF (=R2) ', 
+      CALL XERRWD('      for precision of machine..  see TOLSF (=R2) ',
      1     50, 203, 0, 0, 0, 0, 2, TN, TOLSF)
       RWORK(14) = TOLSF
       ISTATE = -2
       GO TO 580
 C KFLAG = -1.  Error test failed repeatedly or with ABS(H) = HMIN. -----
- 530  CALL XERRWD('SLSODE-  At T(=R1) and step size H(=R2), the error', 
+ 530  CALL XERRWD('SLSODE-  At T(=R1) and step size H(=R2), the error',
      1     50, 204, 0, 0, 0, 0, 0, 0.0E0, 0.0E0)
-      CALL XERRWD('      test failed repeatedly or with ABS(H) = HMIN', 
+      CALL XERRWD('      test failed repeatedly or with ABS(H) = HMIN',
      1     50, 204, 0, 0, 0, 0, 2, TN, H)
       ISTATE = -4
       GO TO 560
 C KFLAG = -2.  Convergence failed repeatedly or with ABS(H) = HMIN. ----
  540  CALL XERRWD('SLSODE-  At T (=R1) and step size H (=R2), the    ',
      1     50, 205, 0, 0, 0, 0, 0, 0.0E0, 0.0E0)
-      CALL XERRWD('      corrector convergence failed repeatedly     ', 
+      CALL XERRWD('      corrector convergence failed repeatedly     ',
      1     50, 205, 0, 0, 0, 0, 0, 0.0E0, 0.0E0)
-      CALL XERRWD('      or with ABS(H) = HMIN   ', 
+      CALL XERRWD('      or with ABS(H) = HMIN   ',
      1     30, 205, 0, 0, 0, 0, 2, TN, H)
       ISTATE = -5
 C Compute IMXER if relevant. -------------------------------------------
  560  BIG = 0.0E0
       IMXER = 1
       DO 570 I = 1,N
         SIZE = ABS(RWORK(I+LACOR-1)*RWORK(I+LEWT-1))
         IF (BIG .GE. SIZE) GO TO 570
@@ -1644,94 +1644,94 @@ C Set Y vector, T, and optional outputs.
       IWORK(13) = NJE
       IWORK(14) = NQU
       IWORK(15) = NQ
       RETURN
 C-----------------------------------------------------------------------
 C Block I.
 C The following block handles all error returns due to illegal input
 C (ISTATE = -3), as detected before calling the core integrator.
-C First the error message routine is called.  If the illegal input 
+C First the error message routine is called.  If the illegal input
 C is a negative ISTATE, the run is aborted (apparent infinite loop).
 C-----------------------------------------------------------------------
  601  CALL XERRWD('SLSODE-  ISTATE (=I1) illegal ',
      1     30, 1, 0, 1, ISTATE, 0, 0, 0.0E0, 0.0E0)
       IF (ISTATE .LT. 0) GO TO 800
       GO TO 700
- 602  CALL XERRWD('SLSODE-  ITASK (=I1) illegal  ', 
+ 602  CALL XERRWD('SLSODE-  ITASK (=I1) illegal  ',
      1     30, 2, 0, 1, ITASK, 0, 0, 0.0E0, 0.0E0)
       GO TO 700
- 603  CALL XERRWD('SLSODE-  ISTATE .GT. 1 but SLSODE not initialized ', 
+ 603  CALL XERRWD('SLSODE-  ISTATE .GT. 1 but SLSODE not initialized ',
      1     50, 3, 0, 0, 0, 0, 0, 0.0E0, 0.0E0)
       GO TO 700
- 604  CALL XERRWD('SLSODE-  NEQ (=I1) .LT. 1     ', 
+ 604  CALL XERRWD('SLSODE-  NEQ (=I1) .LT. 1     ',
      1     30, 4, 0, 1, NEQ(1), 0, 0, 0.0E0, 0.0E0)
       GO TO 700
- 605  CALL XERRWD('SLSODE-  ISTATE = 3 and NEQ increased (I1 to I2)  ', 
+ 605  CALL XERRWD('SLSODE-  ISTATE = 3 and NEQ increased (I1 to I2)  ',
      1     50, 5, 0, 2, N, NEQ(1), 0, 0.0E0, 0.0E0)
       GO TO 700
  606  CALL XERRWD('SLSODE-  ITOL (=I1) illegal   ',
      1     30, 6, 0, 1, ITOL, 0, 0, 0.0E0, 0.0E0)
       GO TO 700
- 607  CALL XERRWD('SLSODE-  IOPT (=I1) illegal   ', 
+ 607  CALL XERRWD('SLSODE-  IOPT (=I1) illegal   ',
      1     30, 7, 0, 1, IOPT, 0, 0, 0.0E0, 0.0E0)
       GO TO 700
- 608  CALL XERRWD('SLSODE-  MF (=I1) illegal     ', 
+ 608  CALL XERRWD('SLSODE-  MF (=I1) illegal     ',
      1     30, 8, 0, 1, MF, 0, 0, 0.0E0, 0.0E0)
       GO TO 700
- 609  CALL XERRWD('SLSODE-  ML (=I1) illegal.. .LT.0 or .GE.NEQ (=I2)', 
+ 609  CALL XERRWD('SLSODE-  ML (=I1) illegal.. .LT.0 or .GE.NEQ (=I2)',
      1     50, 9, 0, 2, ML, NEQ(1), 0, 0.0E0, 0.0E0)
       GO TO 700
- 610  CALL XERRWD('SLSODE-  MU (=I1) illegal.. .LT.0 or .GE.NEQ (=I2)', 
+ 610  CALL XERRWD('SLSODE-  MU (=I1) illegal.. .LT.0 or .GE.NEQ (=I2)',
      1     50, 10, 0, 2, MU, NEQ(1), 0, 0.0E0, 0.0E0)
       GO TO 700
- 611  CALL XERRWD('SLSODE-  MAXORD (=I1) .LT. 0  ', 
+ 611  CALL XERRWD('SLSODE-  MAXORD (=I1) .LT. 0  ',
      1     30, 11, 0, 1, MAXORD, 0, 0, 0.0E0, 0.0E0)
       GO TO 700
- 612  CALL XERRWD('SLSODE-  MXSTEP (=I1) .LT. 0  ', 
+ 612  CALL XERRWD('SLSODE-  MXSTEP (=I1) .LT. 0  ',
      1 30, 12, 0, 1, MXSTEP, 0, 0, 0.0E0, 0.0E0)
       GO TO 700
- 613  CALL XERRWD('SLSODE-  MXHNIL (=I1) .LT. 0  ', 
+ 613  CALL XERRWD('SLSODE-  MXHNIL (=I1) .LT. 0  ',
      1     30, 13, 0, 1, MXHNIL, 0, 0, 0.0E0, 0.0E0)
       GO TO 700
- 614  CALL XERRWD('SLSODE-  TOUT (=R1) behind T (=R2)      ', 
+ 614  CALL XERRWD('SLSODE-  TOUT (=R1) behind T (=R2)      ',
      1     40, 14, 0, 0, 0, 0, 2, TOUT, T)
-      CALL XERRWD('      Integration direction is given by H0 (=R1)  ', 
+      CALL XERRWD('      Integration direction is given by H0 (=R1)  ',
      1     50, 14, 0, 0, 0, 0, 1, H0, 0.0E0)
       GO TO 700
- 615  CALL XERRWD('SLSODE-  HMAX (=R1) .LT. 0.0  ', 
+ 615  CALL XERRWD('SLSODE-  HMAX (=R1) .LT. 0.0  ',
      1     30, 15, 0, 0, 0, 0, 1, HMAX, 0.0E0)
       GO TO 700
- 616  CALL XERRWD('SLSODE-  HMIN (=R1) .LT. 0.0  ', 
+ 616  CALL XERRWD('SLSODE-  HMIN (=R1) .LT. 0.0  ',
      1     30, 16, 0, 0, 0, 0, 1, HMIN, 0.0E0)
       GO TO 700
  617  CALL XERRWD(
-     1  'SLSODE-  RWORK length needed, LENRW (=I1), exceeds LRW (=I2)', 
+     1  'SLSODE-  RWORK length needed, LENRW (=I1), exceeds LRW (=I2)',
      1   60, 17, 0, 2, LENRW, LRW, 0, 0.0E0, 0.0E0)
       GO TO 700
  618  CALL XERRWD(
      1   'SLSODE-  IWORK length needed, LENIW (=I1), exceeds LIW (=I2)',
      1    60, 18, 0, 2, LENIW, LIW, 0, 0.0E0, 0.0E0)
       GO TO 700
- 619  CALL XERRWD('SLSODE-  RTOL(I1) is R1 .LT. 0.0        ', 
+ 619  CALL XERRWD('SLSODE-  RTOL(I1) is R1 .LT. 0.0        ',
      1     40, 19, 0, 1, I, 0, 1, RTOLI, 0.0E0)
       GO TO 700
- 620  CALL XERRWD('SLSODE-  ATOL(I1) is R1 .LT. 0.0        ', 
+ 620  CALL XERRWD('SLSODE-  ATOL(I1) is R1 .LT. 0.0        ',
      1     40, 20, 0, 1, I, 0, 1, ATOLI, 0.0E0)
       GO TO 700
  621  EWTI = RWORK(LEWT+I-1)
-      CALL XERRWD('SLSODE-  EWT(I1) is R1 .LE. 0.0         ', 
+      CALL XERRWD('SLSODE-  EWT(I1) is R1 .LE. 0.0         ',
      1     40, 21, 0, 1, I, 0, 1, EWTI, 0.0E0)
       GO TO 700
  622  CALL XERRWD(
      1   'SLSODE-  TOUT (=R1) too close to T(=R2) to start integration',
      1     60, 22, 0, 0, 0, 0, 2, TOUT, T)
       GO TO 700
  623  CALL XERRWD(
-     1 'SLSODE-  ITASK = I1 and TOUT (=R1) behind TCUR - HU (= R2)  ', 
+     1 'SLSODE-  ITASK = I1 and TOUT (=R1) behind TCUR - HU (= R2)  ',
      1     60, 23, 0, 1, ITASK, 0, 2, TOUT, TP)
       GO TO 700
  624  CALL XERRWD(
      1   'SLSODE-  ITASK = 4 OR 5 and TCRIT (=R1) behind TCUR (=R2)   ',
      1    60, 24, 0, 0, 0, 0, 2, TCRIT, TN)
       GO TO 700
  625  CALL XERRWD(
      1  'SLSODE-  ITASK = 4 or 5 and TCRIT (=R1) behind TOUT (=R2)   ',
@@ -1739,19 +1739,19 @@ C---------------------------------------
       GO TO 700
  626  CALL XERRWD('SLSODE-  At start of problem, too much accuracy   ',
      1     50, 26, 0, 0, 0, 0, 0, 0.0E0, 0.0E0)
       CALL XERRWD(
      1   '      requested for precision of machine..  See TOLSF (=R1) ',
      1    60, 26, 0, 0, 0, 0, 1, TOLSF, 0.0E0)
       RWORK(14) = TOLSF
       GO TO 700
- 627  CALL XERRWD('SLSODE-  Trouble in SINTDY.  ITASK = I1, TOUT = R1', 
+ 627  CALL XERRWD('SLSODE-  Trouble in SINTDY.  ITASK = I1, TOUT = R1',
      1     50, 27, 0, 1, ITASK, 0, 1, TOUT, 0.0E0)
 C
  700  ISTATE = -3
       RETURN
 C
- 800  CALL XERRWD('SLSODE-  Run aborted.. apparent infinite loop     ', 
+ 800  CALL XERRWD('SLSODE-  Run aborted.. apparent infinite loop     ',
      1     50, 303, 2, 0, 0, 0, 0, 0.0E0, 0.0E0)
       RETURN
 C----------------------- END OF SUBROUTINE SLSODE ----------------------
       END
diff --git a/liboctave/cruft/odepack/solsy.f b/liboctave/cruft/odepack/solsy.f
--- a/liboctave/cruft/odepack/solsy.f
+++ b/liboctave/cruft/odepack/solsy.f
@@ -1,46 +1,46 @@
       SUBROUTINE SOLSY (WM, IWM, X, TEM)
 CLLL. OPTIMIZE
       INTEGER IWM
       INTEGER IOWND, IOWNS,
      1   ICF, IERPJ, IERSL, JCUR, JSTART, KFLAG, L, METH, MITER,
      2   MAXORD, MAXCOR, MSBP, MXNCF, N, NQ, NST, NFE, NJE, NQU
       INTEGER I, MEBAND, ML, MU
       DOUBLE PRECISION WM, X, TEM
-      DOUBLE PRECISION ROWNS, 
+      DOUBLE PRECISION ROWNS,
      1   CCMAX, EL0, H, HMIN, HMXI, HU, RC, TN, UROUND
-      DOUBLE PRECISION DI, HL0, PHL0, R 
+      DOUBLE PRECISION DI, HL0, PHL0, R
       DIMENSION WM(*), IWM(*), X(*), TEM(*)
       COMMON /LS0001/ ROWNS(209),
      2   CCMAX, EL0, H, HMIN, HMXI, HU, RC, TN, UROUND,
-     3   IOWND(14), IOWNS(6), 
+     3   IOWND(14), IOWNS(6),
      4   ICF, IERPJ, IERSL, JCUR, JSTART, KFLAG, L, METH, MITER,
      5   MAXORD, MAXCOR, MSBP, MXNCF, N, NQ, NST, NFE, NJE, NQU
 C-----------------------------------------------------------------------
-C THIS ROUTINE MANAGES THE SOLUTION OF THE LINEAR SYSTEM ARISING FROM 
+C THIS ROUTINE MANAGES THE SOLUTION OF THE LINEAR SYSTEM ARISING FROM
 C A CHORD ITERATION.  IT IS CALLED IF MITER .NE. 0.
 C IF MITER IS 1 OR 2, IT CALLS DGETRS TO ACCOMPLISH THIS.
 C IF MITER = 3 IT UPDATES THE COEFFICIENT H*EL0 IN THE DIAGONAL
 C MATRIX, AND THEN COMPUTES THE SOLUTION.
 C IF MITER IS 4 OR 5, IT CALLS DGBTRS.
 C COMMUNICATION WITH SOLSY USES THE FOLLOWING VARIABLES..
 C WM    = REAL WORK SPACE CONTAINING THE INVERSE DIAGONAL MATRIX IF
-C         MITER = 3 AND THE LU DECOMPOSITION OF THE MATRIX OTHERWISE. 
+C         MITER = 3 AND THE LU DECOMPOSITION OF THE MATRIX OTHERWISE.
 C         STORAGE OF MATRIX ELEMENTS STARTS AT WM(3).
 C         WM ALSO CONTAINS THE FOLLOWING MATRIX-RELATED DATA..
 C         WM(1) = SQRT(UROUND) (NOT USED HERE),
 C         WM(2) = HL0, THE PREVIOUS VALUE OF H*EL0, USED IF MITER = 3.
 C IWM   = INTEGER WORK SPACE CONTAINING PIVOT INFORMATION, STARTING AT
-C         IWM(21), IF MITER IS 1, 2, 4, OR 5.  IWM ALSO CONTAINS BAND 
+C         IWM(21), IF MITER IS 1, 2, 4, OR 5.  IWM ALSO CONTAINS BAND
 C         PARAMETERS ML = IWM(1) AND MU = IWM(2) IF MITER IS 4 OR 5.
 C X     = THE RIGHT-HAND SIDE VECTOR ON INPUT, AND THE SOLUTION VECTOR
 C         ON OUTPUT, OF LENGTH N.
-C TEM   = VECTOR OF WORK SPACE OF LENGTH N, NOT USED IN THIS VERSION. 
-C IERSL = OUTPUT FLAG (IN COMMON).  IERSL = 0 IF NO TROUBLE OCCURRED. 
+C TEM   = VECTOR OF WORK SPACE OF LENGTH N, NOT USED IN THIS VERSION.
+C IERSL = OUTPUT FLAG (IN COMMON).  IERSL = 0 IF NO TROUBLE OCCURRED.
 C         IERSL = 1 IF A SINGULAR MATRIX AROSE WITH MITER = 3.
 C THIS ROUTINE ALSO USES THE COMMON VARIABLES EL0, H, MITER, AND N.
 C-----------------------------------------------------------------------
       IERSL = 0
       GO TO (100, 100, 300, 400, 400), MITER
  100  CALL DGETRS ( 'N', N, 1, WM(3), N, IWM(21), X, N, INLPCK)
       RETURN
 C
@@ -57,13 +57,13 @@ C
  340    X(I) = WM(I+2)*X(I)
       RETURN
  390  IERSL = 1
       RETURN
 C
  400  ML = IWM(1)
       MU = IWM(2)
       MEBAND = 2*ML + MU + 1
-      CALL DGBTRS ( 'N', N, ML, MU, 1, WM(3), MEBAND, IWM(21), X, N, 
+      CALL DGBTRS ( 'N', N, ML, MU, 1, WM(3), MEBAND, IWM(21), X, N,
      * INLPCK)
       RETURN
 C----------------------- END OF SUBROUTINE SOLSY -----------------------
-      END 
+      END
diff --git a/liboctave/cruft/odepack/ssolsy.f b/liboctave/cruft/odepack/ssolsy.f
--- a/liboctave/cruft/odepack/ssolsy.f
+++ b/liboctave/cruft/odepack/ssolsy.f
@@ -79,13 +79,13 @@ C
  340    X(I) = WM(I+2)*X(I)
       RETURN
  390  IERSL = 1
       RETURN
 C
  400  ML = IWM(1)
       MU = IWM(2)
       MEBAND = 2*ML + MU + 1
-      CALL SGBTRS ( 'N', N, ML, MU, 1, WM(3), MEBAND, IWM(21), X, N, 
+      CALL SGBTRS ( 'N', N, ML, MU, 1, WM(3), MEBAND, IWM(21), X, N,
      * INLPCK)
       RETURN
 C----------------------- END OF SUBROUTINE SSOLSY ----------------------
       END
diff --git a/liboctave/cruft/odepack/stode.f b/liboctave/cruft/odepack/stode.f
--- a/liboctave/cruft/odepack/stode.f
+++ b/liboctave/cruft/odepack/stode.f
@@ -46,27 +46,27 @@ C          COMPARED TO 1.0/EWT(I) IN VAR
 C SAVF   = AN ARRAY OF WORKING STORAGE, OF LENGTH N.
 C          ALSO USED FOR INPUT OF YH(*,MAXORD+2) WHEN JSTART = -1
 C          AND MAXORD .LT. THE CURRENT ORDER NQ.
 C ACOR   = A WORK ARRAY OF LENGTH N, USED FOR THE ACCUMULATED
 C          CORRECTIONS.  ON A SUCCESSFUL RETURN, ACOR(I) CONTAINS
 C          THE ESTIMATED ONE-STEP LOCAL ERROR IN Y(I).
 C WM,IWM = REAL AND INTEGER WORK ARRAYS ASSOCIATED WITH MATRIX
 C          OPERATIONS IN CHORD ITERATION (MITER .NE. 0).
-C PJAC   = NAME OF ROUTINE TO EVALUATE AND PREPROCESS JACOBIAN MATRIX 
+C PJAC   = NAME OF ROUTINE TO EVALUATE AND PREPROCESS JACOBIAN MATRIX
 C          AND P = I - H*EL0*JAC, IF A CHORD METHOD IS BEING USED.
-C SLVS   = NAME OF ROUTINE TO SOLVE LINEAR SYSTEM IN CHORD ITERATION. 
+C SLVS   = NAME OF ROUTINE TO SOLVE LINEAR SYSTEM IN CHORD ITERATION.
 C CCMAX  = MAXIMUM RELATIVE CHANGE IN H*EL0 BEFORE PJAC IS CALLED.
 C H      = THE STEP SIZE TO BE ATTEMPTED ON THE NEXT STEP.
 C          H IS ALTERED BY THE ERROR CONTROL ALGORITHM DURING THE
 C          PROBLEM.  H CAN BE EITHER POSITIVE OR NEGATIVE, BUT ITS
 C          SIGN MUST REMAIN CONSTANT THROUGHOUT THE PROBLEM.
 C HMIN   = THE MINIMUM ABSOLUTE VALUE OF THE STEP SIZE H TO BE USED.
 C HMXI   = INVERSE OF THE MAXIMUM ABSOLUTE VALUE OF H TO BE USED.
-C          HMXI = 0.0 IS ALLOWED AND CORRESPONDS TO AN INFINITE HMAX. 
+C          HMXI = 0.0 IS ALLOWED AND CORRESPONDS TO AN INFINITE HMAX.
 C          HMIN AND HMXI MAY BE CHANGED AT ANY TIME, BUT WILL NOT
 C          TAKE EFFECT UNTIL THE NEXT CHANGE OF H IS CONSIDERED.
 C TN     = THE INDEPENDENT VARIABLE. TN IS UPDATED ON EACH STEP TAKEN.
 C JSTART = AN INTEGER USED FOR INPUT ONLY, WITH THE FOLLOWING
 C          VALUES AND MEANINGS..
 C               0  PERFORM THE FIRST STEP.
 C           .GT.0  TAKE A NEW STEP CONTINUING FROM THE LAST.
 C              -1  TAKE THE NEXT STEP WITH A NEW VALUE OF H, MAXORD,
@@ -77,21 +77,21 @@ C          ON RETURN, JSTART IS SET TO 1
 C KFLAG  = A COMPLETION CODE WITH THE FOLLOWING MEANINGS..
 C               0  THE STEP WAS SUCCESFUL.
 C              -1  THE REQUESTED ERROR COULD NOT BE ACHIEVED.
 C              -2  CORRECTOR CONVERGENCE COULD NOT BE ACHIEVED.
 C              -3  FATAL ERROR IN PJAC OR SLVS.
 C          A RETURN WITH KFLAG = -1 OR -2 MEANS EITHER
 C          ABS(H) = HMIN OR 10 CONSECUTIVE FAILURES OCCURRED.
 C          ON A RETURN WITH KFLAG NEGATIVE, THE VALUES OF TN AND
-C          THE YH ARRAY ARE AS OF THE BEGINNING OF THE LAST 
+C          THE YH ARRAY ARE AS OF THE BEGINNING OF THE LAST
 C          STEP, AND H IS THE LAST STEP SIZE ATTEMPTED.
 C MAXORD = THE MAXIMUM ORDER OF INTEGRATION METHOD TO BE ALLOWED.
 C MAXCOR = THE MAXIMUM NUMBER OF CORRECTOR ITERATIONS ALLOWED.
-C MSBP   = MAXIMUM NUMBER OF STEPS BETWEEN PJAC CALLS (MITER .GT. 0). 
+C MSBP   = MAXIMUM NUMBER OF STEPS BETWEEN PJAC CALLS (MITER .GT. 0).
 C MXNCF  = MAXIMUM NUMBER OF CONVERGENCE FAILURES ALLOWED.
 C METH/MITER = THE METHOD FLAGS.  SEE DESCRIPTION IN DRIVER.
 C N      = THE NUMBER OF FIRST-ORDER DIFFERENTIAL EQUATIONS.
 C IERR   = ERROR FLAG FROM USER-SUPPLIED FUNCTION
 C-----------------------------------------------------------------------
       KFLAG = 0
       TOLD = TN
       NCF = 0
@@ -100,30 +100,30 @@ C---------------------------------------
       JCUR = 0
       ICF = 0
       DELP = 0.0D0
       IF (JSTART .GT. 0) GO TO 200
       IF (JSTART .EQ. -1) GO TO 100
       IF (JSTART .EQ. -2) GO TO 160
 C-----------------------------------------------------------------------
 C ON THE FIRST CALL, THE ORDER IS SET TO 1, AND OTHER VARIABLES ARE
-C INITIALIZED.  RMAX IS THE MAXIMUM RATIO BY WHICH H CAN BE INCREASED 
-C IN A SINGLE STEP.  IT IS INITIALLY 1.E4 TO COMPENSATE FOR THE SMALL 
+C INITIALIZED.  RMAX IS THE MAXIMUM RATIO BY WHICH H CAN BE INCREASED
+C IN A SINGLE STEP.  IT IS INITIALLY 1.E4 TO COMPENSATE FOR THE SMALL
 C INITIAL H, BUT THEN IS NORMALLY EQUAL TO 10.  IF A FAILURE
 C OCCURS (IN CORRECTOR CONVERGENCE OR ERROR TEST), RMAX IS SET AT 2
 C FOR THE NEXT INCREASE.
 C-----------------------------------------------------------------------
       LMAX = MAXORD + 1
       NQ = 1
       L = 2
       IALTH = 2
       RMAX = 10000.0D0
       RC = 0.0D0
       EL0 = 1.0D0
-      CRATE = 0.7D0 
+      CRATE = 0.7D0
       HOLD = H
       MEO = METH
       NSLP = 0
       IPUP = MITER
       IRET = 3
       GO TO 140
 C-----------------------------------------------------------------------
 C THE FOLLOWING BLOCK HANDLES PRELIMINARIES NEEDED WHEN JSTART = -1.
@@ -153,17 +153,17 @@ C---------------------------------------
       L = LMAX
       DO 125 I = 1,L
  125    EL(I) = ELCO(I,NQ)
       NQNYH = NQ*NYH
       RC = RC*EL(1)/EL0
       EL0 = EL(1)
       CONIT = 0.5D0/DBLE(NQ+2)
       DDN = VNORM (N, SAVF, EWT)/TESCO(1,L)
-      EXDN = 1.0D0/DBLE(L)  
+      EXDN = 1.0D0/DBLE(L)
       RHDN = 1.0D0/(1.3D0*DDN**EXDN + 0.0000013D0)
       RH = DMIN1(RHDN,1.0D0)
       IREDO = 3
       IF (H .EQ. HOLD) GO TO 170
       RH = DMIN1(RH,DABS(H/HOLD))
       H = HOLD
       GO TO 175
 C-----------------------------------------------------------------------
@@ -192,93 +192,93 @@ C---------------------------------------
       GO TO 175
  170  RH = DMAX1(RH,HMIN/DABS(H))
  175  RH = DMIN1(RH,RMAX)
       RH = RH/DMAX1(1.0D0,DABS(H)*HMXI*RH)
       R = 1.0D0
       DO 180 J = 2,L
         R = R*RH
         DO 180 I = 1,N
- 180      YH(I,J) = YH(I,J)*R 
+ 180      YH(I,J) = YH(I,J)*R
       H = H*RH
       RC = RC*RH
       IALTH = L
       IF (IREDO .EQ. 0) GO TO 690
 C-----------------------------------------------------------------------
-C THIS SECTION COMPUTES THE PREDICTED VALUES BY EFFECTIVELY 
+C THIS SECTION COMPUTES THE PREDICTED VALUES BY EFFECTIVELY
 C MULTIPLYING THE YH ARRAY BY THE PASCAL TRIANGLE MATRIX.
 C RC IS THE RATIO OF NEW TO OLD VALUES OF THE COEFFICIENT  H*EL(1).
 C WHEN RC DIFFERS FROM 1 BY MORE THAN CCMAX, IPUP IS SET TO MITER
 C TO FORCE PJAC TO BE CALLED, IF A JACOBIAN IS INVOLVED.
 C IN ANY CASE, PJAC IS CALLED AT LEAST EVERY MSBP STEPS.
 C-----------------------------------------------------------------------
- 200  IF (DABS(RC-1.0D0) .GT. CCMAX) IPUP = MITER 
+ 200  IF (DABS(RC-1.0D0) .GT. CCMAX) IPUP = MITER
       IF (NST .GE. NSLP+MSBP) IPUP = MITER
       TN = TN + H
       I1 = NQNYH + 1
       DO 215 JB = 1,NQ
         I1 = I1 - NYH
 CDIR$ IVDEP
         DO 210 I = I1,NQNYH
  210      YH1(I) = YH1(I) + YH1(I+NYH)
  215    CONTINUE
 C-----------------------------------------------------------------------
-C UP TO MAXCOR CORRECTOR ITERATIONS ARE TAKEN.  A CONVERGENCE TEST IS 
+C UP TO MAXCOR CORRECTOR ITERATIONS ARE TAKEN.  A CONVERGENCE TEST IS
 C MADE ON THE R.M.S. NORM OF EACH CORRECTION, WEIGHTED BY THE ERROR
 C WEIGHT VECTOR EWT.  THE SUM OF THE CORRECTIONS IS ACCUMULATED IN THE
-C VECTOR ACOR(I).  THE YH ARRAY IS NOT ALTERED IN THE CORRECTOR LOOP. 
+C VECTOR ACOR(I).  THE YH ARRAY IS NOT ALTERED IN THE CORRECTOR LOOP.
 C-----------------------------------------------------------------------
  220  M = 0
       DO 230 I = 1,N
  230    Y(I) = YH(I,1)
       IERR = 0
       CALL F (NEQ, TN, Y, SAVF, IERR)
       IF (IERR .LT. 0) RETURN
-      NFE = NFE + 1 
+      NFE = NFE + 1
       IF (IPUP .LE. 0) GO TO 250
 C-----------------------------------------------------------------------
 C IF INDICATED, THE MATRIX P = I - H*EL(1)*J IS REEVALUATED AND
 C PREPROCESSED BEFORE STARTING THE CORRECTOR ITERATION.  IPUP IS SET
 C TO 0 AS AN INDICATOR THAT THIS HAS BEEN DONE.
 C-----------------------------------------------------------------------
       IERR = 0
       CALL PJAC (NEQ, Y, YH, NYH, EWT, ACOR, SAVF, WM, IWM, F, JAC,
      1   IERR)
       IF (IERR .LT. 0) RETURN
       IPUP = 0
       RC = 1.0D0
       NSLP = NST
-      CRATE = 0.7D0 
+      CRATE = 0.7D0
       IF (IERPJ .NE. 0) GO TO 430
  250  DO 260 I = 1,N
  260    ACOR(I) = 0.0D0
  270  IF (MITER .NE. 0) GO TO 350
 C-----------------------------------------------------------------------
 C IN THE CASE OF FUNCTIONAL ITERATION, UPDATE Y DIRECTLY FROM
 C THE RESULT OF THE LAST FUNCTION EVALUATION.
 C-----------------------------------------------------------------------
       DO 290 I = 1,N
         SAVF(I) = H*SAVF(I) - YH(I,2)
  290    Y(I) = SAVF(I) - ACOR(I)
-      DEL = VNORM (N, Y, EWT) 
+      DEL = VNORM (N, Y, EWT)
       DO 300 I = 1,N
         Y(I) = YH(I,1) + EL(1)*SAVF(I)
  300    ACOR(I) = SAVF(I)
       GO TO 400
 C-----------------------------------------------------------------------
 C IN THE CASE OF THE CHORD METHOD, COMPUTE THE CORRECTOR ERROR,
 C AND SOLVE THE LINEAR SYSTEM WITH THAT AS RIGHT-HAND SIDE AND
 C P AS COEFFICIENT MATRIX.
 C-----------------------------------------------------------------------
  350  DO 360 I = 1,N
  360    Y(I) = H*SAVF(I) - (YH(I,2) + ACOR(I))
       CALL SLVS (WM, IWM, Y, SAVF)
       IF (IERSL .LT. 0) GO TO 430
       IF (IERSL .GT. 0) GO TO 410
-      DEL = VNORM (N, Y, EWT) 
+      DEL = VNORM (N, Y, EWT)
       DO 380 I = 1,N
         ACOR(I) = ACOR(I) + Y(I)
  380    Y(I) = YH(I,1) + EL(1)*ACOR(I)
 C-----------------------------------------------------------------------
 C TEST FOR CONVERGENCE.  IF M.GT.0, AN ESTIMATE OF THE CONVERGENCE
 C RATE CONSTANT IS STORED IN CRATE, AND THIS IS USED IN THE TEST.
 C-----------------------------------------------------------------------
  400  IF (M .NE. 0) CRATE = DMAX1(0.2D0*CRATE,DEL/DELP)
@@ -286,31 +286,31 @@ C---------------------------------------
       IF (DCON .LE. 1.0D0) GO TO 450
       M = M + 1
       IF (M .EQ. MAXCOR) GO TO 410
       IF (M .GE. 2 .AND. DEL .GT. 2.0D0*DELP) GO TO 410
       DELP = DEL
       IERR = 0
       CALL F (NEQ, TN, Y, SAVF, IERR)
       IF (IERR .LT. 0) RETURN
-      NFE = NFE + 1 
+      NFE = NFE + 1
       GO TO 270
 C-----------------------------------------------------------------------
 C THE CORRECTOR ITERATION FAILED TO CONVERGE.
-C IF MITER .NE. 0 AND THE JACOBIAN IS OUT OF DATE, PJAC IS CALLED FOR 
+C IF MITER .NE. 0 AND THE JACOBIAN IS OUT OF DATE, PJAC IS CALLED FOR
 C THE NEXT TRY.  OTHERWISE THE YH ARRAY IS RETRACTED TO ITS VALUES
 C BEFORE PREDICTION, AND H IS REDUCED, IF POSSIBLE.  IF H CANNOT BE
 C REDUCED OR MXNCF FAILURES HAVE OCCURRED, EXIT WITH KFLAG = -2.
 C-----------------------------------------------------------------------
  410  IF (MITER .EQ. 0 .OR. JCUR .EQ. 1) GO TO 430
       ICF = 1
       IPUP = MITER
       GO TO 220
  430  ICF = 2
-      NCF = NCF + 1 
+      NCF = NCF + 1
       RMAX = 2.0D0
       TN = TOLD
       I1 = NQNYH + 1
       DO 445 JB = 1,NQ
         I1 = I1 - NYH
 CDIR$ IVDEP
         DO 440 I = I1,NQNYH
  440      YH1(I) = YH1(I) - YH1(I+NYH)
@@ -339,35 +339,35 @@ C IF IALTH IS THEN 1 AND NQ .LT. MAXORD,
 C USE IN A POSSIBLE ORDER INCREASE ON THE NEXT STEP.
 C IF A CHANGE IN H IS CONSIDERED, AN INCREASE OR DECREASE IN ORDER
 C BY ONE IS CONSIDERED ALSO.  A CHANGE IN H IS MADE ONLY IF IT IS BY A
 C FACTOR OF AT LEAST 1.1.  IF NOT, IALTH IS SET TO 3 TO PREVENT
 C TESTING FOR THAT MANY STEPS.
 C-----------------------------------------------------------------------
       KFLAG = 0
       IREDO = 0
-      NST = NST + 1 
+      NST = NST + 1
       HU = H
       NQU = NQ
       DO 470 J = 1,L
         DO 470 I = 1,N
  470      YH(I,J) = YH(I,J) + EL(J)*ACOR(I)
       IALTH = IALTH - 1
       IF (IALTH .EQ. 0) GO TO 520
       IF (IALTH .GT. 1) GO TO 700
       IF (L .EQ. LMAX) GO TO 700
       DO 490 I = 1,N
  490    YH(I,LMAX) = ACOR(I)
       GO TO 700
 C-----------------------------------------------------------------------
 C THE ERROR TEST FAILED.  KFLAG KEEPS TRACK OF MULTIPLE FAILURES.
 C RESTORE TN AND THE YH ARRAY TO THEIR PREVIOUS VALUES, AND PREPARE
 C TO TRY THE STEP AGAIN.  COMPUTE THE OPTIMUM STEP SIZE FOR THIS OR
-C ONE LOWER ORDER.  AFTER 2 OR MORE FAILURES, H IS FORCED TO DECREASE 
-C BY A FACTOR OF 0.2 OR LESS. 
+C ONE LOWER ORDER.  AFTER 2 OR MORE FAILURES, H IS FORCED TO DECREASE
+C BY A FACTOR OF 0.2 OR LESS.
 C-----------------------------------------------------------------------
  500  KFLAG = KFLAG - 1
       TN = TOLD
       I1 = NQNYH + 1
       DO 515 JB = 1,NQ
         I1 = I1 - NYH
 CDIR$ IVDEP
         DO 510 I = I1,NQNYH
@@ -375,53 +375,53 @@ CDIR$ IVDEP
  515    CONTINUE
       RMAX = 2.0D0
       IF (DABS(H) .LE. HMIN*1.00001D0) GO TO 660
       IF (KFLAG .LE. -3) GO TO 640
       IREDO = 2
       RHUP = 0.0D0
       GO TO 540
 C-----------------------------------------------------------------------
-C REGARDLESS OF THE SUCCESS OR FAILURE OF THE STEP, FACTORS 
+C REGARDLESS OF THE SUCCESS OR FAILURE OF THE STEP, FACTORS
 C RHDN, RHSM, AND RHUP ARE COMPUTED, BY WHICH H COULD BE MULTIPLIED
-C AT ORDER NQ - 1, ORDER NQ, OR ORDER NQ + 1, RESPECTIVELY. 
+C AT ORDER NQ - 1, ORDER NQ, OR ORDER NQ + 1, RESPECTIVELY.
 C IN THE CASE OF FAILURE, RHUP = 0.0 TO AVOID AN ORDER INCREASE.
 C THE LARGEST OF THESE IS DETERMINED AND THE NEW ORDER CHOSEN
 C ACCORDINGLY.  IF THE ORDER IS TO BE INCREASED, WE COMPUTE ONE
 C ADDITIONAL SCALED DERIVATIVE.
 C-----------------------------------------------------------------------
  520  RHUP = 0.0D0
       IF (L .EQ. LMAX) GO TO 540
       DO 530 I = 1,N
  530    SAVF(I) = ACOR(I) - YH(I,LMAX)
       DUP = VNORM (N, SAVF, EWT)/TESCO(3,NQ)
       EXUP = 1.0D0/DBLE(L+1)
       RHUP = 1.0D0/(1.4D0*DUP**EXUP + 0.0000014D0)
- 540  EXSM = 1.0D0/DBLE(L)  
+ 540  EXSM = 1.0D0/DBLE(L)
       RHSM = 1.0D0/(1.2D0*DSM**EXSM + 0.0000012D0)
       RHDN = 0.0D0
       IF (NQ .EQ. 1) GO TO 560
       DDN = VNORM (N, YH(1,L), EWT)/TESCO(1,NQ)
-      EXDN = 1.0D0/DBLE(NQ) 
+      EXDN = 1.0D0/DBLE(NQ)
       RHDN = 1.0D0/(1.3D0*DDN**EXDN + 0.0000013D0)
  560  IF (RHSM .GE. RHUP) GO TO 570
       IF (RHUP .GT. RHDN) GO TO 590
       GO TO 580
  570  IF (RHSM .LT. RHDN) GO TO 580
       NEWQ = NQ
       RH = RHSM
       GO TO 620
- 580  NEWQ = NQ - 1 
+ 580  NEWQ = NQ - 1
       RH = RHDN
       IF (KFLAG .LT. 0 .AND. RH .GT. 1.0D0) RH = 1.0D0
       GO TO 620
  590  NEWQ = L
       RH = RHUP
       IF (RH .LT. 1.1D0) GO TO 610
-      R = EL(L)/DBLE(L)     
+      R = EL(L)/DBLE(L)
       DO 600 I = 1,N
  600    YH(I,NEWQ+1) = ACOR(I)*R
       GO TO 630
  610  IALTH = 3
       GO TO 700
  620  IF ((KFLAG .EQ. 0) .AND. (RH .LT. 1.1D0)) GO TO 610
       IF (KFLAG .LE. -2) RH = DMIN1(RH,0.2D0)
 C-----------------------------------------------------------------------
@@ -433,31 +433,31 @@ C---------------------------------------
  630  NQ = NEWQ
       L = NQ + 1
       IRET = 2
       GO TO 150
 C-----------------------------------------------------------------------
 C CONTROL REACHES THIS SECTION IF 3 OR MORE FAILURES HAVE OCCURED.
 C IF 10 FAILURES HAVE OCCURRED, EXIT WITH KFLAG = -1.
 C IT IS ASSUMED THAT THE DERIVATIVES THAT HAVE ACCUMULATED IN THE
-C YH ARRAY HAVE ERRORS OF THE WRONG ORDER.  HENCE THE FIRST 
+C YH ARRAY HAVE ERRORS OF THE WRONG ORDER.  HENCE THE FIRST
 C DERIVATIVE IS RECOMPUTED, AND THE ORDER IS SET TO 1.  THEN
 C H IS REDUCED BY A FACTOR OF 10, AND THE STEP IS RETRIED,
 C UNTIL IT SUCCEEDS OR H REACHES HMIN.
 C-----------------------------------------------------------------------
  640  IF (KFLAG .EQ. -10) GO TO 660
       RH = 0.1D0
       RH = DMAX1(HMIN/DABS(H),RH)
       H = H*RH
       DO 645 I = 1,N
  645    Y(I) = YH(I,1)
       IERR = 0
       CALL F (NEQ, TN, Y, SAVF, IERR)
       IF (IERR .LT. 0) RETURN
-      NFE = NFE + 1 
+      NFE = NFE + 1
       DO 650 I = 1,N
  650    YH(I,2) = H*SAVF(I)
       IPUP = MITER
       IALTH = 5
       IF (NQ .EQ. 1) GO TO 200
       NQ = 1
       L = 2
       IRET = 3
@@ -467,17 +467,17 @@ C ALL RETURNS ARE MADE THROUGH THIS SECT
 C TO ALLOW THE CALLER TO CHANGE H ON THE NEXT STEP.
 C-----------------------------------------------------------------------
  660  KFLAG = -1
       GO TO 720
  670  KFLAG = -2
       GO TO 720
  680  KFLAG = -3
       GO TO 720
- 690  RMAX = 10.0D0 
+ 690  RMAX = 10.0D0
  700  R = 1.0D0/TESCO(2,NQU)
       DO 710 I = 1,N
  710    ACOR(I) = ACOR(I)*R
  720  HOLD = H
       JSTART = 1
       RETURN
 C----------------------- END OF SUBROUTINE STODE -----------------------
-      END 
+      END
diff --git a/liboctave/cruft/odepack/vnorm.f b/liboctave/cruft/odepack/vnorm.f
--- a/liboctave/cruft/odepack/vnorm.f
+++ b/liboctave/cruft/odepack/vnorm.f
@@ -5,14 +5,14 @@ C THIS FUNCTION ROUTINE COMPUTES THE WEI
 C OF THE VECTOR OF LENGTH N CONTAINED IN THE ARRAY V, WITH WEIGHTS
 C CONTAINED IN THE ARRAY W OF LENGTH N..
 C   VNORM = SQRT( (1/N) * SUM( V(I)*W(I) )**2 )
 C-----------------------------------------------------------------------
       INTEGER N,   I
       DOUBLE PRECISION V, W,   SUM
       DIMENSION V(N), W(N)
       SUM = 0.0D0
-      DO 10 I = 1,N 
+      DO 10 I = 1,N
  10     SUM = SUM + (V(I)*W(I))**2
-      VNORM = DSQRT(SUM/DBLE(N))      
+      VNORM = DSQRT(SUM/DBLE(N))
       RETURN
 C----------------------- END OF FUNCTION VNORM -------------------------
-      END 
+      END
diff --git a/liboctave/cruft/ranlib/Basegen.doc b/liboctave/cruft/ranlib/Basegen.doc
--- a/liboctave/cruft/ranlib/Basegen.doc
+++ b/liboctave/cruft/ranlib/Basegen.doc
@@ -28,17 +28,17 @@
 
 
 
 
                             Compiled and Written by:
 
                                  Barry W. Brown
                                   James Lovato
-                                   
+
 
 
 
 
 
 
 
 
@@ -172,211 +172,211 @@ the range 1..32.  The number of the curr
 by invoking subroutine GETCGN  which returns the number  in its single
 integer argument.
 
 
 V. CALLING SEQUENCES
 
       A. SETTING THE SEED OF ALL GENERATORS
 
-C**********************************************************************  
-C                                                                        
-C      SUBROUTINE SETALL(ISEED1,ISEED2)                                  
-C               SET ALL random number generators                         
-C                                                                        
-C     Sets the initial seed of generator 1 to ISEED1 and ISEED2. The     
-C     initial seeds of the other generators are set accordingly, and     
-C     all generators states are set to these seeds.                      
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C     ISEED1 -> First of two integer seeds                               
-C                                   INTEGER ISEED1                       
-C                                                                        
-C     ISEED2 -> Second of two integer seeds                              
-C                                   INTEGER ISEED1                       
-C                                                                        
-C**********************************************************************  
+C**********************************************************************
+C
+C      SUBROUTINE SETALL(ISEED1,ISEED2)
+C               SET ALL random number generators
+C
+C     Sets the initial seed of generator 1 to ISEED1 and ISEED2. The
+C     initial seeds of the other generators are set accordingly, and
+C     all generators states are set to these seeds.
+C
+C                              Arguments
+C
+C
+C     ISEED1 -> First of two integer seeds
+C                                   INTEGER ISEED1
+C
+C     ISEED2 -> Second of two integer seeds
+C                                   INTEGER ISEED1
+C
+C**********************************************************************
 
 
       B. OBTAINING RANDOM NUMBERS
 
-C**********************************************************************  
-C                                                                        
-C     INTEGER FUNCTION IGNLGI()                                          
-C               GeNerate LarGe Integer                                   
-C                                                                        
-C     Returns a random integer following a uniform distribution over     
-C     (1, 2147483562) using the current generator.                       
-C                                                                        
-C**********************************************************************  
+C**********************************************************************
+C
+C     INTEGER FUNCTION IGNLGI()
+C               GeNerate LarGe Integer
+C
+C     Returns a random integer following a uniform distribution over
+C     (1, 2147483562) using the current generator.
+C
+C**********************************************************************
 
-C**********************************************************************  
-C                                                                        
-C     REAL FUNCTION RANF()                                               
-C                RANDom number generator as a Function                   
-C                                                                        
-C     Returns a random floating point number from a uniform distribution 
-C     over 0 - 1 (endpoints of this interval are not returned) using the 
-C     current generator                                                  
-C                                                                        
-C**********************************************************************  
+C**********************************************************************
+C
+C     REAL FUNCTION RANF()
+C                RANDom number generator as a Function
+C
+C     Returns a random floating point number from a uniform distribution
+C     over 0 - 1 (endpoints of this interval are not returned) using the
+C     current generator
+C
+C**********************************************************************
 
 
 
 Base Random Number Generator                                    Page 4
 
 
       C. SETTING AND OBTAINING THE NUMBER OF THE CURRENT GENERATOR
 
-C**********************************************************************  
-C                                                                        
-C     SUBROUTINE SETCGN( G )                                             
-C                      Set GeNerator                                     
-C                                                                        
+C**********************************************************************
+C
+C     SUBROUTINE SETCGN( G )
+C                      Set GeNerator
+C
 C     Sets  the  current  generator to G. All references to a generator
-C     are to the current generator.                                      
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C     G --> Number of the current random number generator (1..32)        
-C                    INTEGER G                                           
-C                                                                        
+C     are to the current generator.
+C
+C                              Arguments
+C
+C     G --> Number of the current random number generator (1..32)
+C                    INTEGER G
+C
 C**********************************************************************
 
-C**********************************************************************  
-C                                                                        
-C      SUBROUTINE GETCGN(G)                                              
-C                         Get GeNerator                                  
-C                                                                        
-C     Returns in G the number of the current random number generator     
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C     G <-- Number of the current random number generator (1..32)        
-C                    INTEGER G                                           
-C                                                                        
-C**********************************************************************  
-  
+C**********************************************************************
+C
+C      SUBROUTINE GETCGN(G)
+C                         Get GeNerator
+C
+C     Returns in G the number of the current random number generator
+C
+C                              Arguments
+C
+C     G <-- Number of the current random number generator (1..32)
+C                    INTEGER G
+C
+C**********************************************************************
+
       D. OBTAINING OR CHANGING SEEDS IN CURRENT GENERATOR
 
-C**********************************************************************  
-C                                                                        
-C     SUBROUTINE ADVNST(K)                                               
-C               ADV-a-N-ce ST-ate                                        
-C                                                                        
-C     Advances the state  of  the current  generator  by 2^K values  and 
-C     resets the initial seed to that value.                             
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C     K -> The generator is advanced by 2^K values                        
-C                                   INTEGER K                            
-C                                                                        
-C**********************************************************************  
+C**********************************************************************
+C
+C     SUBROUTINE ADVNST(K)
+C               ADV-a-N-ce ST-ate
+C
+C     Advances the state  of  the current  generator  by 2^K values  and
+C     resets the initial seed to that value.
+C
+C                              Arguments
+C
+C
+C     K -> The generator is advanced by 2^K values
+C                                   INTEGER K
+C
+C**********************************************************************
 
 
 
 Base Random Number Generator                                    Page 5
 
 
-C**********************************************************************  
-C                                                                        
-C     SUBROUTINE GETSD(ISEED1,ISEED2)                                  
-C               GET SeeD                                                 
-C                                                                        
-C     Returns the value of two integer seeds of the current generator    
+C**********************************************************************
+C
+C     SUBROUTINE GETSD(ISEED1,ISEED2)
+C               GET SeeD
+C
+C     Returns the value of two integer seeds of the current generator
+C
+C                              Arguments
+C
+C
+C
+C     ISEED1 <- First integer seed of generator G
+C                                   INTEGER ISEED1
 C
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C                                                                        
-C     ISEED1 <- First integer seed of generator G                        
-C                                   INTEGER ISEED1                       
-C                                                                        
-C     ISEED2 <- Second integer seed of generator G                       
-C                                   INTEGER ISEED1                       
-C                                                                        
-C**********************************************************************  
+C     ISEED2 <- Second integer seed of generator G
+C                                   INTEGER ISEED1
+C
+C**********************************************************************
 
-C**********************************************************************  
-C                                                                        
-C     SUBROUTINE INITGN(ISDTYP)                                          
-C          INIT-ialize current G-e-N-erator                              
-C                                                                        
-C     Reinitializes the state of the current generator                   
+C**********************************************************************
+C
+C     SUBROUTINE INITGN(ISDTYP)
+C          INIT-ialize current G-e-N-erator
 C
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C     ISDTYP -> The state to which the generator is to be set            
+C     Reinitializes the state of the current generator
+C
+C                              Arguments
+C
+C
+C     ISDTYP -> The state to which the generator is to be set
 C          ISDTYP = -1  => sets the seeds to their initial value
 C          ISDTYP =  0  => sets the seeds to the first value of
 C                          the current block
 C          ISDTYP =  1  => sets the seeds to the first value of
 C                          the next block
-C                                                                        
-C                                   INTEGER ISDTYP                       
-C                                                                        
-C**********************************************************************  
+C
+C                                   INTEGER ISDTYP
+C
+C**********************************************************************
 
-C**********************************************************************  
-C                                                                        
-C     SUBROUTINE SETSD(ISEED1,ISEED2)                                    
-C               SET S-ee-D of current generator                          
-C                                                                        
+C**********************************************************************
+C
+C     SUBROUTINE SETSD(ISEED1,ISEED2)
+C               SET S-ee-D of current generator
+C
 C     Resets the initial  seed of  the current  generator to  ISEED1 and
 C     ISEED2. The seeds of the other generators remain unchanged.
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C     ISEED1 -> First integer seed                                       
-C                                   INTEGER ISEED1                       
-C                                                                        
-C     ISEED2 -> Second integer seed                                      
-C                                   INTEGER ISEED1                       
-C                                                                        
-C**********************************************************************  
+C
+C                              Arguments
+C
+C
+C     ISEED1 -> First integer seed
+C                                   INTEGER ISEED1
+C
+C     ISEED2 -> Second integer seed
+C                                   INTEGER ISEED1
+C
+C**********************************************************************
 
 
 
 Base Random Number Generator                                    Page 6
 
 
       E. MISCELLANY
 
-C**********************************************************************  
-C                                                                        
-C     INTEGER FUNCTION MLTMOD(A,S,M)                                     
-C                                                                        
-C                    Returns (A*S) MOD M                                 
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C     A, S, M  -->                                                       
-C                         INTEGER A,S,M                                  
-C                                                                        
-C**********************************************************************  
+C**********************************************************************
+C
+C     INTEGER FUNCTION MLTMOD(A,S,M)
+C
+C                    Returns (A*S) MOD M
+C
+C                              Arguments
+C
+C
+C     A, S, M  -->
+C                         INTEGER A,S,M
+C
+C**********************************************************************
 
-C**********************************************************************  
-C                                                                        
-C      SUBROUTINE SETANT(QVALUE)                                         
-C               SET ANTithetic                                           
-C                                                                        
-C     Sets whether the current generator produces antithetic values.  If 
-C     X   is  the value  normally returned  from  a uniform [0,1] random 
-C     number generator then 1  - X is the antithetic  value. If X is the 
-C     value  normally  returned  from a   uniform  [0,N]  random  number 
-C     generator then N - 1 - X is the antithetic value.                  
-C                                                                        
-C     All generators are initialized to NOT generate antithetic values.  
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C     QVALUE -> .TRUE. if generator G is to generating antithetic        
-C                    values, otherwise .FALSE.                           
-C                                   LOGICAL QVALUE                       
-C                                                                        
-C**********************************************************************  
+C**********************************************************************
+C
+C      SUBROUTINE SETANT(QVALUE)
+C               SET ANTithetic
+C
+C     Sets whether the current generator produces antithetic values.  If
+C     X   is  the value  normally returned  from  a uniform [0,1] random
+C     number generator then 1  - X is the antithetic  value. If X is the
+C     value  normally  returned  from a   uniform  [0,N]  random  number
+C     generator then N - 1 - X is the antithetic value.
+C
+C     All generators are initialized to NOT generate antithetic values.
+C
+C                              Arguments
+C
+C     QVALUE -> .TRUE. if generator G is to generating antithetic
+C                    values, otherwise .FALSE.
+C                                   LOGICAL QVALUE
+C
+C**********************************************************************
diff --git a/liboctave/cruft/ranlib/README b/liboctave/cruft/ranlib/README
--- a/liboctave/cruft/ranlib/README
+++ b/liboctave/cruft/ranlib/README
@@ -137,23 +137,23 @@ 17:98-111 (1991)
 This code was obtained from Netlib.
 
 Ahrens,  J.H. and  Dieter, U.   Computer Methods for Sampling From the
 Exponential and Normal  Distributions.  Comm. ACM,  15,10 (Oct. 1972),
 873 - 882.
 
                                 Gamma
 
-(Case R >= 1.0)                                          
+(Case R >= 1.0)
 
 Ahrens, J.H. and Dieter, U.  Generating Gamma  Variates by  a Modified
 Rejection Technique.  Comm. ACM, 25,1 (Jan. 1982), 47 - 54.
-Algorithm GD                                                       
+Algorithm GD
 
-(Case 0.0 <= R <= 1.0)                                   
+(Case 0.0 <= R <= 1.0)
 
 Ahrens, J.H. and Dieter, U.  Computer Methods for Sampling from Gamma,
 Beta,  Poisson  and Binomial   Distributions.    Computing, 12 (1974),
 223-246.  Adaptation of algorithm GS.
 
 
 
 
@@ -216,42 +216,42 @@ algorithms policy:
      copyright notice and the title of the publication and its date appear,
      and  notice is given that copying  is by permission of the Association
      for Computing Machinery.  To copy otherwise, or to republish, requires
      a fee and/or specific permission.
 
      Krogh, F.  Algorithms  Policy.  ACM  Tran.   Math.  Softw.   13(1987),
      183-186.
 
-We place the Randlib code that we have written in the public domain.  
+We place the Randlib code that we have written in the public domain.
 
                                  NO WARRANTY
-     
+
      WE PROVIDE ABSOLUTELY  NO WARRANTY  OF ANY  KIND  EITHER  EXPRESSED OR
      IMPLIED,  INCLUDING BUT   NOT LIMITED TO,  THE  IMPLIED  WARRANTIES OF
      MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK
      AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS  WITH YOU.  SHOULD
      THIS PROGRAM PROVE  DEFECTIVE, YOU ASSUME  THE COST  OF  ALL NECESSARY
      SERVICING, REPAIR OR CORRECTION.
-     
+
      IN NO  EVENT  SHALL THE UNIVERSITY  OF TEXAS OR  ANY  OF ITS COMPONENT
      INSTITUTIONS INCLUDING M. D.   ANDERSON HOSPITAL BE LIABLE  TO YOU FOR
      DAMAGES, INCLUDING ANY  LOST PROFITS, LOST MONIES,   OR OTHER SPECIAL,
      INCIDENTAL   OR  CONSEQUENTIAL DAMAGES   ARISING   OUT  OF  THE USE OR
      INABILITY TO USE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA OR
      ITS ANALYSIS BEING  RENDERED INACCURATE OR  LOSSES SUSTAINED  BY THIRD
      PARTIES) THE PROGRAM.
-     
+
      (Above NO WARRANTY modified from the GNU NO WARRANTY statement.)
 
 
 
                          WHAT'S NEW IN VERSION 1.1?
 
-  
+
 Random number generation  for  the Negative Binomial  and  Multinomial
 distributions has been included.
 
 Two errors in the code  which generates random  numbers from the Gamma
 distribution were fixed.
 
 
                          WHAT'S NEW IN VERSION 1.2?
diff --git a/liboctave/cruft/ranlib/genbet.f b/liboctave/cruft/ranlib/genbet.f
--- a/liboctave/cruft/ranlib/genbet.f
+++ b/liboctave/cruft/ranlib/genbet.f
@@ -122,17 +122,17 @@ C
 C
 C     Step 3
 C
       t = log(z)
       IF (s.GT.t) GO TO 70
 C
 C     Step 4
 C
-C     JJV added checker to see if log(alpha/(b+w)) will 
+C     JJV added checker to see if log(alpha/(b+w)) will
 C     JJV overflow.  If so, we count the log as -INF, and
 C     JJV consequently evaluate conditional as true, i.e.
 C     JJV the algorithm rejects the trial and starts over
 C     JJV May not need this here since ALPHA > 2.0
       IF (alpha/(b+w).LT.minlog) GO TO 40
 
       IF ((r+alpha*log(alpha/ (b+w))).LT.t) GO TO 40
 C
diff --git a/liboctave/cruft/ranlib/genexp.f b/liboctave/cruft/ranlib/genexp.f
--- a/liboctave/cruft/ranlib/genexp.f
+++ b/liboctave/cruft/ranlib/genexp.f
@@ -43,17 +43,17 @@ C***************************************
 C     .. Scalar Arguments ..
       REAL av
 C     ..
 C     .. External Functions ..
       REAL sexpo
       EXTERNAL sexpo
 C     ..
 C     .. Executable Statements ..
-C     JJV added check to ensure AV >= 0.0 
+C     JJV added check to ensure AV >= 0.0
       IF (av.GE.0.0) GO TO 10
       WRITE (*,*) 'AV < 0.0 in GENEXP - ABORT'
       WRITE (*,*) 'Value of AV: ',av
       CALL XSTOPX ('AV < 0.0 in GENEXP - ABORT')
 
  10   genexp = sexpo()*av
       RETURN
 
diff --git a/liboctave/cruft/ranlib/gennch.f b/liboctave/cruft/ranlib/gennch.f
--- a/liboctave/cruft/ranlib/gennch.f
+++ b/liboctave/cruft/ranlib/gennch.f
@@ -42,17 +42,17 @@ C     JJV changed these to call SGAMMA a
 C      REAL genchi,gennor
 C      EXTERNAL genchi,gennor
       REAL sgamma,snorm
       EXTERNAL sgamma,snorm
 C     ..
 C     .. Intrinsic Functions ..
       INTRINSIC sqrt
 C     ..
-C     JJV changed abort to df < 1, and added case: df = 1 
+C     JJV changed abort to df < 1, and added case: df = 1
 C     .. Executable Statements ..
       IF (.NOT. (df.LT.1.0.OR.xnonc.LT.0.0)) GO TO 10
       WRITE (*,*) 'DF < 1 or XNONC < 0 in GENNCH - ABORT'
       WRITE (*,*) 'Value of DF: ',df,' Value of XNONC',xnonc
       CALL XSTOPX ('DF < 1 or XNONC < 0 in GENNCH - ABORT')
 
 C     JJV changed this to call SGAMMA and SNORM directly
 C      gennch = genchi(df-1.0) + gennor(sqrt(xnonc),1.0)**2
@@ -60,10 +60,10 @@ C      gennch = genchi(df-1.0) + gennor(
  10   IF (df.GE.1.000001) GO TO 20
 C     JJV case DF = 1.0
       gennch = (snorm() + sqrt(xnonc))**2
       GO TO 30
 
 C     JJV case DF > 1.0
  20   gennch = 2.0*sgamma((df-1.0)/2.0) + (snorm() + sqrt(xnonc))**2
  30   RETURN
-      
+
       END
diff --git a/liboctave/cruft/ranlib/gennf.f b/liboctave/cruft/ranlib/gennf.f
--- a/liboctave/cruft/ranlib/gennf.f
+++ b/liboctave/cruft/ranlib/gennf.f
@@ -73,17 +73,17 @@ C     JJV case dfn = 1.0 - here I am tre
       xnum = (snorm() + sqrt(xnonc))**2
       GO TO 30
 
 C     JJV case dfn > 1.0
  20   xnum = (2.0*sgamma((dfn-1.0)/2.0) + (snorm()+sqrt(xnonc))**2)/dfn
 
 C     xden = genchi(dfd)/dfd
  30   xden = 2.0*sgamma(dfd/2.0)/dfd
-      
+
 C     JJV changed constant so that it will not underflow at compile time
 C     JJV while not slowing generator by using double precision or logs.
 C      IF (.NOT. (xden.LE. (1.0E-38*xnum))) GO TO 40
       IF (.NOT. (xden.LE. (1.0E-37*xnum))) GO TO 40
       WRITE (*,*) ' GENNF - generated numbers would cause overflow'
       WRITE (*,*) ' Numerator ',xnum,' Denominator ',xden
 C     JJV next 2 lines changed to maintain truncation of large deviates.
 C      WRITE (*,*) ' GENNF returning 1.0E38'
diff --git a/liboctave/cruft/ranlib/gennor.f b/liboctave/cruft/ranlib/gennor.f
--- a/liboctave/cruft/ranlib/gennor.f
+++ b/liboctave/cruft/ranlib/gennor.f
@@ -44,17 +44,17 @@ C***************************************
 C     .. Scalar Arguments ..
       REAL av,sd
 C     ..
 C     .. External Functions ..
       REAL snorm
       EXTERNAL snorm
 C     ..
 C     .. Executable Statements ..
-C     JJV added check to ensure SD >= 0.0 
+C     JJV added check to ensure SD >= 0.0
       IF (sd.GE.0.0) GO TO 10
       WRITE (*,*) 'SD < 0.0 in GENNOR - ABORT'
       WRITE (*,*) 'Value of SD: ',sd
       CALL XSTOPX ('SD < 0.0 in GENNOR - ABORT')
 
  10   gennor = sd*snorm() + av
       RETURN
 
diff --git a/liboctave/cruft/ranlib/getsd.f b/liboctave/cruft/ranlib/getsd.f
--- a/liboctave/cruft/ranlib/getsd.f
+++ b/liboctave/cruft/ranlib/getsd.f
@@ -57,17 +57,17 @@ C     ..
 C     .. Save statement ..
       SAVE /globe/
 C     ..
 C     .. Executable Statements ..
 C     Abort unless random number generator initialized
       IF (qrgnin()) GO TO 10
       WRITE (*,*) ' GETSD called before random number generator ',
      +  ' initialized -- abort!'
-      CALL XSTOPX 
+      CALL XSTOPX
      + (' GETSD called before random number generator initialized')
 
    10 CALL getcgn(g)
       iseed1 = cg1(g)
       iseed2 = cg2(g)
       RETURN
 
       END
diff --git a/liboctave/cruft/ranlib/initgn.f b/liboctave/cruft/ranlib/initgn.f
--- a/liboctave/cruft/ranlib/initgn.f
+++ b/liboctave/cruft/ranlib/initgn.f
@@ -61,17 +61,17 @@ C     ..
 C     .. Save statement ..
       SAVE /globe/
 C     ..
 C     .. Executable Statements ..
 C     Abort unless random number generator initialized
       IF (qrgnin()) GO TO 10
       WRITE (*,*) ' INITGN called before random number generator ',
      +  ' initialized -- abort!'
-      CALL XSTOPX 
+      CALL XSTOPX
      + (' INITGN called before random number generator initialized')
 
    10 CALL getcgn(g)
       IF ((-1).NE. (isdtyp)) GO TO 20
       lg1(g) = ig1(g)
       lg2(g) = ig2(g)
       GO TO 50
 
diff --git a/liboctave/cruft/ranlib/phrtsd.f b/liboctave/cruft/ranlib/phrtsd.f
--- a/liboctave/cruft/ranlib/phrtsd.f
+++ b/liboctave/cruft/ranlib/phrtsd.f
@@ -56,21 +56,21 @@ C     .. Local Arrays ..
 C     ..
 C     .. External Functions ..
       INTEGER lennob
       EXTERNAL lennob
 C     ..
 C     .. Intrinsic Functions ..
       INTRINSIC index,mod
 C     ..
-C     JJV added Save statement for variable in Data statement 
+C     JJV added Save statement for variable in Data statement
 C     .. Save statements ..
       SAVE shift
-C     JJV end addition 
-C     .. 
+C     JJV end addition
+C     ..
 C     .. Data statements ..
       DATA shift/1,64,4096,262144,16777216/
 C     ..
 C     .. Executable Statements ..
       seed1 = 1234567890
       seed2 = 123456789
       lphr = lennob(phrase)
       IF (lphr.LT.1) RETURN
diff --git a/liboctave/cruft/ranlib/randlib.fdoc b/liboctave/cruft/ranlib/randlib.fdoc
--- a/liboctave/cruft/ranlib/randlib.fdoc
+++ b/liboctave/cruft/ranlib/randlib.fdoc
@@ -28,17 +28,17 @@
 
 
 
 
                             Compiled and Written by:
 
                                  Barry W. Brown
                                   James Lovato
-                                   
+
 
 
 
 
 
 
 
 
@@ -46,254 +46,254 @@
                      Department of Biomathematics, Box 237
                      The University of Texas, M.D. Anderson Cancer Center
                      1515 Holcombe Boulevard
                      Houston, TX      77030
 
 
  This work was supported by grant CA-16672 from the National Cancer Institute.
 
-C**********************************************************************  
-C                                                                        
-C     SUBROUTINE ADVNST(K)                                               
-C               ADV-a-N-ce ST-ate                                        
-C                                                                        
-C     Advances the state  of  the current  generator  by 2^K values  and 
-C     resets the initial seed to that value.                             
-C                                                                        
-C     This is  a  transcription from   Pascal to  Fortran    of  routine 
-C     Advance_State from the paper                                       
-C                                                                        
-C     L'Ecuyer, P. and  Cote, S. "Implementing  a  Random Number Package 
-C     with  Splitting   Facilities."  ACM  Transactions  on Mathematical 
-C     Software, 17:98-111 (1991)                                         
-C                                                                        
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C     K -> The generator is advanced by2^K values                        
-C                                   INTEGER K                            
-C                                                                        
-C**********************************************************************  
-C**********************************************************************  
-C                                                                        
-C     REAL FUNCTION GENBET( A, B )                                       
-C               GeNerate BETa random deviate                             
-C                                                                        
-C                                                                        
-C                              Function                                  
-C                                                                        
-C                                                                        
-C     Returns a single random deviate from the beta distribution with    
-C     parameters A and B.  The density of the beta is                    
-C               x^(a-1) * (1-x)^(b-1) / B(a,b) for 0 < x < 1             
-C                                                                        
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C     A --> First parameter of the beta distribution                     
-C                         REAL A                                         
+C**********************************************************************
+C
+C     SUBROUTINE ADVNST(K)
+C               ADV-a-N-ce ST-ate
+C
+C     Advances the state  of  the current  generator  by 2^K values  and
+C     resets the initial seed to that value.
+C
+C     This is  a  transcription from   Pascal to  Fortran    of  routine
+C     Advance_State from the paper
+C
+C     L'Ecuyer, P. and  Cote, S. "Implementing  a  Random Number Package
+C     with  Splitting   Facilities."  ACM  Transactions  on Mathematical
+C     Software, 17:98-111 (1991)
+C
+C
+C                              Arguments
+C
+C
+C     K -> The generator is advanced by2^K values
+C                                   INTEGER K
+C
+C**********************************************************************
+C**********************************************************************
+C
+C     REAL FUNCTION GENBET( A, B )
+C               GeNerate BETa random deviate
+C
+C
+C                              Function
+C
+C
+C     Returns a single random deviate from the beta distribution with
+C     parameters A and B.  The density of the beta is
+C               x^(a-1) * (1-x)^(b-1) / B(a,b) for 0 < x < 1
+C
+C
+C                              Arguments
+C
+C
+C     A --> First parameter of the beta distribution
+C                         REAL A
 C                         (A >= 1.0E-37)
-C                                                                        
-C     B --> Second parameter of the beta distribution                    
-C                         REAL B                                         
+C
+C     B --> Second parameter of the beta distribution
+C                         REAL B
 C                         (B >= 1.0E-37)
-C                                                                        
-C                                                                        
-C                              Method                                    
-C                                                                        
-C                                                                        
-C     R. C. H. Cheng                                                     
-C     Generating Beta Variables with Nonintegral Shape Parameters         
-C     Communications of the ACM, 21:317-322  (1978)                      
-C     (Algorithms BB and BC)                                             
-C                                                                        
-C**********************************************************************  
-C**********************************************************************  
-C                                                                        
-C     REAL FUNCTION GENCHI( DF )                                         
-C                Generate random value of CHIsquare variable             
-C                                                                        
-C                                                                        
-C                              Function                                  
-C                                                                        
-C                                                                        
-C     Generates random deviate from the distribution of a chisquare      
-C     with DF degrees of freedom random variable.                        
-C                                                                        
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C     DF --> Degrees of freedom of the chisquare                         
-C            (Must be positive)                                          
-C                         REAL DF                                        
-C                                                                        
-C                                                                        
-C                              Method                                    
-C                                                                        
-C                                                                        
-C     Uses relation between chisquare and gamma.                         
-C                                                                        
-C**********************************************************************  
-C**********************************************************************  
-C                                                                        
-C     REAL FUNCTION GENEXP( AV )                                         
-C                                                                        
-C                    GENerate EXPonential random deviate                 
-C                                                                        
-C                                                                        
-C                              Function                                  
-C                                                                        
-C                                                                        
-C     Generates a single random deviate from an exponential              
-C     distribution with mean AV.                                         
-C                                                                        
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C     AV --> The mean of the exponential distribution from which         
-C            a random deviate is to be generated.                        
-C                              REAL AV                                   
+C
+C
+C                              Method
+C
+C
+C     R. C. H. Cheng
+C     Generating Beta Variables with Nonintegral Shape Parameters
+C     Communications of the ACM, 21:317-322  (1978)
+C     (Algorithms BB and BC)
+C
+C**********************************************************************
+C**********************************************************************
+C
+C     REAL FUNCTION GENCHI( DF )
+C                Generate random value of CHIsquare variable
+C
+C
+C                              Function
+C
+C
+C     Generates random deviate from the distribution of a chisquare
+C     with DF degrees of freedom random variable.
+C
+C
+C                              Arguments
+C
+C
+C     DF --> Degrees of freedom of the chisquare
+C            (Must be positive)
+C                         REAL DF
+C
+C
+C                              Method
+C
+C
+C     Uses relation between chisquare and gamma.
+C
+C**********************************************************************
+C**********************************************************************
+C
+C     REAL FUNCTION GENEXP( AV )
+C
+C                    GENerate EXPonential random deviate
+C
+C
+C                              Function
+C
+C
+C     Generates a single random deviate from an exponential
+C     distribution with mean AV.
+C
+C
+C                              Arguments
+C
+C
+C     AV --> The mean of the exponential distribution from which
+C            a random deviate is to be generated.
+C                              REAL AV
 C                              (AV >= 0)
-C                                                                        
-C     GENEXP <-- The random deviate.                                     
-C                              REAL GENEXP                               
-C                                                                        
-C                                                                        
-C                              Method                                    
-C                                                                        
-C                                                                        
-C     Renames SEXPO from TOMS as slightly modified by BWB to use RANF    
-C     instead of SUNIF.                                                  
-C                                                                        
-C     For details see:                                                   
-C                                                                        
-C               Ahrens, J.H. and Dieter, U.                              
-C               Computer Methods for Sampling From the                   
-C               Exponential and Normal Distributions.                    
-C               Comm. ACM, 15,10 (Oct. 1972), 873 - 882.                 
-C                                                                        
-C**********************************************************************  
-C**********************************************************************  
-C                                                                        
-C     REAL FUNCTION GENF( DFN, DFD )                                     
-C                GENerate random deviate from the F distribution         
-C                                                                        
-C                                                                        
-C                              Function                                  
-C                                                                        
-C                                                                        
-C     Generates a random deviate from the F (variance ratio)             
-C     distribution with DFN degrees of freedom in the numerator          
-C     and DFD degrees of freedom in the denominator.                     
-C                                                                        
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C     DFN --> Numerator degrees of freedom                               
-C             (Must be positive)                                         
-C                              REAL DFN                                  
-C      DFD --> Denominator degrees of freedom                            
-C             (Must be positive)                                         
-C                              REAL DFD                                  
-C                                                                        
-C                                                                        
-C                              Method                                    
-C                                                                        
-C                                                                        
-C     Directly generates ratio of chisquare variates                     
-C                                                                        
-C**********************************************************************  
-C**********************************************************************  
-C                                                                        
-C     REAL FUNCTION GENGAM( A, R )                                       
-C           GENerates random deviates from GAMma distribution            
-C                                                                        
-C                                                                        
-C                              Function                                  
-C                                                                        
-C                                                                        
-C     Generates random deviates from the gamma distribution whose        
-C     density is                                                         
-C          (A**R)/Gamma(R) * X**(R-1) * Exp(-A*X)                        
-C                                                                        
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C     A --> Location parameter of Gamma distribution                     
+C
+C     GENEXP <-- The random deviate.
+C                              REAL GENEXP
+C
+C
+C                              Method
+C
+C
+C     Renames SEXPO from TOMS as slightly modified by BWB to use RANF
+C     instead of SUNIF.
+C
+C     For details see:
+C
+C               Ahrens, J.H. and Dieter, U.
+C               Computer Methods for Sampling From the
+C               Exponential and Normal Distributions.
+C               Comm. ACM, 15,10 (Oct. 1972), 873 - 882.
+C
+C**********************************************************************
+C**********************************************************************
+C
+C     REAL FUNCTION GENF( DFN, DFD )
+C                GENerate random deviate from the F distribution
+C
+C
+C                              Function
+C
+C
+C     Generates a random deviate from the F (variance ratio)
+C     distribution with DFN degrees of freedom in the numerator
+C     and DFD degrees of freedom in the denominator.
+C
+C
+C                              Arguments
+C
+C
+C     DFN --> Numerator degrees of freedom
+C             (Must be positive)
+C                              REAL DFN
+C      DFD --> Denominator degrees of freedom
+C             (Must be positive)
+C                              REAL DFD
+C
+C
+C                              Method
+C
+C
+C     Directly generates ratio of chisquare variates
+C
+C**********************************************************************
+C**********************************************************************
+C
+C     REAL FUNCTION GENGAM( A, R )
+C           GENerates random deviates from GAMma distribution
+C
+C
+C                              Function
+C
+C
+C     Generates random deviates from the gamma distribution whose
+C     density is
+C          (A**R)/Gamma(R) * X**(R-1) * Exp(-A*X)
+C
+C
+C                              Arguments
+C
+C
+C     A --> Location parameter of Gamma distribution
 C                              REAL A ( A > 0 )
-C                                                                        
-C     R --> Shape parameter of Gamma distribution                        
+C
+C     R --> Shape parameter of Gamma distribution
 C                              REAL R ( R > 0 )
-C                                                                        
-C                                                                        
-C                              Method                                    
-C                                                                        
-C                                                                        
-C     Renames SGAMMA from TOMS as slightly modified by BWB to use RANF   
-C     instead of SUNIF.                                                  
-C                                                                        
-C     For details see:                                                   
-C               (Case R >= 1.0)                                          
-C               Ahrens, J.H. and Dieter, U.                              
-C               Generating Gamma Variates by a                           
-C               Modified Rejection Technique.                            
-C               Comm. ACM, 25,1 (Jan. 1982), 47 - 54.                    
-C     Algorithm GD                                                       
-C                                                                        
-C               (Case 0.0 < R < 1.0)                                   
-C               Ahrens, J.H. and Dieter, U.                              
-C               Computer Methods for Sampling from Gamma,                
-C               Beta, Poisson and Binomial Distributions.                
-C               Computing, 12 (1974), 223-246/                           
-C     Adapted algorithm GS.                                              
-C                                                                        
-C**********************************************************************  
-C********************************************************************** 
-C                                                                       
-C     SUBROUTINE GENMN(PARM,X,WORK)                                     
-C              GENerate Multivariate Normal random deviate              
-C                                                                       
-C                                                                       
-C                              Arguments                                
-C                                                                       
-C                                                                       
-C     PARM --> Parameters needed to generate multivariate normal        
-C               deviates (MEANV and Cholesky decomposition of           
-C               COVM). Set by a previous call to SETGMN.                
-C                                                                       
-C               1 : 1                - size of deviate, P               
-C               2 : P + 1            - mean vector                      
-C               P+2 : P*(P+3)/2 + 1  - upper half of cholesky           
-C                                       decomposition of cov matrix     
-C                                             REAL PARM(*)              
-C                                                                       
-C     X    <-- Vector deviate generated.                                
-C                                             REAL X(P)                 
-C                                                                       
-C     WORK <--> Scratch array                                           
-C                                             REAL WORK(P)              
-C                                                                       
-C                                                                       
-C                              Method                                   
-C                                                                       
-C                                                                       
-C     1) Generate P independent standard normal deviates - Ei ~ N(0,1)  
-C                                                                       
+C
+C
+C                              Method
+C
+C
+C     Renames SGAMMA from TOMS as slightly modified by BWB to use RANF
+C     instead of SUNIF.
+C
+C     For details see:
+C               (Case R >= 1.0)
+C               Ahrens, J.H. and Dieter, U.
+C               Generating Gamma Variates by a
+C               Modified Rejection Technique.
+C               Comm. ACM, 25,1 (Jan. 1982), 47 - 54.
+C     Algorithm GD
+C
+C               (Case 0.0 < R < 1.0)
+C               Ahrens, J.H. and Dieter, U.
+C               Computer Methods for Sampling from Gamma,
+C               Beta, Poisson and Binomial Distributions.
+C               Computing, 12 (1974), 223-246/
+C     Adapted algorithm GS.
+C
+C**********************************************************************
+C**********************************************************************
+C
+C     SUBROUTINE GENMN(PARM,X,WORK)
+C              GENerate Multivariate Normal random deviate
+C
+C
+C                              Arguments
+C
+C
+C     PARM --> Parameters needed to generate multivariate normal
+C               deviates (MEANV and Cholesky decomposition of
+C               COVM). Set by a previous call to SETGMN.
+C
+C               1 : 1                - size of deviate, P
+C               2 : P + 1            - mean vector
+C               P+2 : P*(P+3)/2 + 1  - upper half of cholesky
+C                                       decomposition of cov matrix
+C                                             REAL PARM(*)
+C
+C     X    <-- Vector deviate generated.
+C                                             REAL X(P)
+C
+C     WORK <--> Scratch array
+C                                             REAL WORK(P)
+C
+C
+C                              Method
+C
+C
+C     1) Generate P independent standard normal deviates - Ei ~ N(0,1)
+C
 C     2) SETGMN uses Cholesky decomposition find A s.t. trans(A)*A = COV
-C                                                                       
-C     3) Generate trans(A)*E + MEANV ~ N(MEANV,COVM)                    
-C                                                                       
-C********************************************************************** 
+C
+C     3) Generate trans(A)*E + MEANV ~ N(MEANV,COVM)
+C
+C**********************************************************************
 C**********************************************************************
 C
 C            SUBROUTINE GENMUL( N, P, NCAT, IX )
 C     GENerate an observation from the MULtinomial distribution
 C
 C
 C                              Arguments
 C
@@ -325,266 +325,266 @@ C
 C     Algorithm from page 559 of
 C
 C     Devroye, Luc
 C
 C     Non-Uniform Random Variate Generation.  Springer-Verlag,
 C     New York, 1986.
 C
 C**********************************************************************
-C**********************************************************************  
-C                                                                        
-C     REAL FUNCTION GENNCH( DF, XNONC )                                  
-C           Generate random value of Noncentral CHIsquare variable       
-C                                                                        
-C                                                                        
-C                              Function                                  
-C                                                                        
-C                                                                        
-C                                                                         
-C     Generates random deviate  from the  distribution  of a  noncentral 
-C     chisquare with DF degrees  of freedom and noncentrality  parameter 
-C     XNONC.                                                             
-C                                                                        
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C     DF --> Degrees of freedom of the chisquare                         
-C            (Must be >= 1.0)                                             
-C                         REAL DF                                        
-C                                                                        
-C     XNONC --> Noncentrality parameter of the chisquare                 
-C               (Must be >= 0.0)                                         
-C                         REAL XNONC                                     
-C                                                                        
-C                                                                        
-C                              Method                                    
-C                                                                        
-C                                                                        
-C     Uses fact that  noncentral chisquare  is  the  sum of a  chisquare 
-C     deviate with DF-1  degrees of freedom plus the  square of a normal 
-C     deviate with mean XNONC and standard deviation 1.                  
-C                                                                        
-C**********************************************************************  
-C**********************************************************************  
-C                                                                        
-C     REAL FUNCTION GENNF( DFN, DFD, XNONC )                             
-C           GENerate random deviate from the Noncentral F distribution   
-C                                                                        
-C                                                                        
-C                              Function                                  
-C                                                                        
-C                                                                        
-C     Generates a random deviate from the  noncentral F (variance ratio) 
-C     distribution with DFN degrees of freedom in the numerator, and DFD 
-C     degrees of freedom in the denominator, and noncentrality parameter 
-C     XNONC.                                                             
-C                                                                        
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C     DFN --> Numerator degrees of freedom                               
-C             (Must be >= 1.0)                                           
-C                              REAL DFN                                  
-C      DFD --> Denominator degrees of freedom                            
-C             (Must be positive)                                         
-C                              REAL DFD                                  
-C                                                                        
-C     XNONC --> Noncentrality parameter                                  
-C               (Must be nonnegative)                                    
-C                              REAL XNONC                                
-C                                                                        
-C                                                                        
-C                              Method                                    
-C                                                                        
-C                                                                        
-C     Directly generates ratio of noncentral numerator chisquare variate 
-C     to central denominator chisquare variate.                          
-C                                                                        
-C**********************************************************************  
-C**********************************************************************  
-C                                                                        
-C     REAL FUNCTION GENNOR( AV, SD )                                     
-C                                                                        
-C         GENerate random deviate from a NORmal distribution             
-C                                                                        
-C                                                                        
-C                              Function                                  
-C                                                                        
-C                                                                        
-C     Generates a single random deviate from a normal distribution       
-C     with mean, AV, and standard deviation, SD.                         
-C                                                                        
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C     AV --> Mean of the normal distribution.                            
-C                              REAL AV                                   
-C                                                                        
-C     SD --> Standard deviation of the normal distribution.              
-C                              REAL SD                                   
+C**********************************************************************
+C
+C     REAL FUNCTION GENNCH( DF, XNONC )
+C           Generate random value of Noncentral CHIsquare variable
+C
+C
+C                              Function
+C
+C
+C
+C     Generates random deviate  from the  distribution  of a  noncentral
+C     chisquare with DF degrees  of freedom and noncentrality  parameter
+C     XNONC.
+C
+C
+C                              Arguments
+C
+C
+C     DF --> Degrees of freedom of the chisquare
+C            (Must be >= 1.0)
+C                         REAL DF
+C
+C     XNONC --> Noncentrality parameter of the chisquare
+C               (Must be >= 0.0)
+C                         REAL XNONC
+C
+C
+C                              Method
+C
+C
+C     Uses fact that  noncentral chisquare  is  the  sum of a  chisquare
+C     deviate with DF-1  degrees of freedom plus the  square of a normal
+C     deviate with mean XNONC and standard deviation 1.
+C
+C**********************************************************************
+C**********************************************************************
+C
+C     REAL FUNCTION GENNF( DFN, DFD, XNONC )
+C           GENerate random deviate from the Noncentral F distribution
+C
+C
+C                              Function
+C
+C
+C     Generates a random deviate from the  noncentral F (variance ratio)
+C     distribution with DFN degrees of freedom in the numerator, and DFD
+C     degrees of freedom in the denominator, and noncentrality parameter
+C     XNONC.
+C
+C
+C                              Arguments
+C
+C
+C     DFN --> Numerator degrees of freedom
+C             (Must be >= 1.0)
+C                              REAL DFN
+C      DFD --> Denominator degrees of freedom
+C             (Must be positive)
+C                              REAL DFD
+C
+C     XNONC --> Noncentrality parameter
+C               (Must be nonnegative)
+C                              REAL XNONC
+C
+C
+C                              Method
+C
+C
+C     Directly generates ratio of noncentral numerator chisquare variate
+C     to central denominator chisquare variate.
+C
+C**********************************************************************
+C**********************************************************************
+C
+C     REAL FUNCTION GENNOR( AV, SD )
+C
+C         GENerate random deviate from a NORmal distribution
+C
+C
+C                              Function
+C
+C
+C     Generates a single random deviate from a normal distribution
+C     with mean, AV, and standard deviation, SD.
+C
+C
+C                              Arguments
+C
+C
+C     AV --> Mean of the normal distribution.
+C                              REAL AV
+C
+C     SD --> Standard deviation of the normal distribution.
+C                              REAL SD
 C                              (SD >= 0)
-C                                                                        
-C     GENNOR <-- Generated normal deviate.                               
-C                              REAL GENNOR                               
-C                                                                        
-C                                                                        
-C                              Method                                    
-C                                                                        
-C                                                                        
-C     Renames SNORM from TOMS as slightly modified by BWB to use RANF    
-C     instead of SUNIF.                                                  
-C                                                                        
-C     For details see:                                                   
-C               Ahrens, J.H. and Dieter, U.                              
-C               Extensions of Forsythe's Method for Random               
-C               Sampling from the Normal Distribution.                   
-C               Math. Comput., 27,124 (Oct. 1973), 927 - 937.            
-C                                                                        
-C                                                                        
-C**********************************************************************  
-C**********************************************************************  
-C                                                                        
-C    SUBROUTINE GENPRM( IARRAY, LARRAY )                                 
-C               GENerate random PeRMutation of iarray                    
-C                                                                        
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C     IARRAY <--> On output IARRAY is a random permutation of its        
-C                 value on input                                         
-C                         INTEGER IARRAY( LARRAY )                       
-C                                                                        
-C     LARRAY <--> Length of IARRAY                                       
-C                         INTEGER LARRAY                                 
-C                                                                        
-C**********************************************************************  
-C**********************************************************************  
-C                                                                        
-C     REAL FUNCTION GENUNF( LOW, HIGH )                                  
-C                                                                        
-C               GeNerate Uniform Real between LOW and HIGH               
-C                                                                        
-C                                                                        
-C                              Function                                  
-C                                                                        
-C                                                                        
-C     Generates a real uniformly distributed between LOW and HIGH.       
-C                                                                        
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C     LOW --> Low bound (exclusive) on real value to be generated        
-C                         REAL LOW                                       
-C                                                                        
-C     HIGH --> High bound (exclusive) on real value to be generated      
-C                         REAL HIGH                                      
-C                                                                        
-C**********************************************************************  
-C**********************************************************************  
-C                                                                        
-C      SUBROUTINE GETCGN(G)                                              
-C                         Get GeNerator                                  
-C                                                                        
-C     Returns in G the number of the current random number generator     
-C                                                                        
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C     G <-- Number of the current random number generator (1..32)        
-C                    INTEGER G                                           
-C                                                                        
-C**********************************************************************  
-C**********************************************************************  
-C                                                                        
-C     SUBROUTINE GETSD(ISEED1,ISEED2)                                  
-C               GET SeeD                                                 
-C                                                                        
-C     Returns the value of two integer seeds of the current generator    
-C                                                                        
-C     This  is   a  transcription from  Pascal   to  Fortran  of routine 
-C     Get_State from the paper                                           
-C                                                                        
-C     L'Ecuyer, P. and  Cote,  S. "Implementing a Random Number  Package 
-C     with   Splitting Facilities."  ACM  Transactions   on Mathematical 
-C     Software, 17:98-111 (1991)                                         
-C                                                                        
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C                                                                        
-C     ISEED1 <- First integer seed of generator G                        
-C                                   INTEGER ISEED1                       
-C                                                                        
-C     ISEED2 <- Second integer seed of generator G                       
-C                                   INTEGER ISEED1                       
-C                                                                        
-C**********************************************************************  
-C**********************************************************************  
-C                                                                        
-C     INTEGER FUNCTION IGNBIN( N, P )                                    
-C                                                                        
-C                    GENerate BINomial random deviate                    
-C                                                                        
-C                                                                        
-C                              Function                                  
-C                                                                        
-C                                                                        
-C     Generates a single random deviate from a binomial                  
-C     distribution whose number of trials is N and whose                 
-C     probability of an event in each trial is P.                        
-C                                                                        
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C     N  --> The number of trials in the binomial distribution           
-C            from which a random deviate is to be generated.             
-C                              INTEGER N                                 
+C
+C     GENNOR <-- Generated normal deviate.
+C                              REAL GENNOR
+C
+C
+C                              Method
+C
+C
+C     Renames SNORM from TOMS as slightly modified by BWB to use RANF
+C     instead of SUNIF.
+C
+C     For details see:
+C               Ahrens, J.H. and Dieter, U.
+C               Extensions of Forsythe's Method for Random
+C               Sampling from the Normal Distribution.
+C               Math. Comput., 27,124 (Oct. 1973), 927 - 937.
+C
+C
+C**********************************************************************
+C**********************************************************************
+C
+C    SUBROUTINE GENPRM( IARRAY, LARRAY )
+C               GENerate random PeRMutation of iarray
+C
+C
+C                              Arguments
+C
+C
+C     IARRAY <--> On output IARRAY is a random permutation of its
+C                 value on input
+C                         INTEGER IARRAY( LARRAY )
+C
+C     LARRAY <--> Length of IARRAY
+C                         INTEGER LARRAY
+C
+C**********************************************************************
+C**********************************************************************
+C
+C     REAL FUNCTION GENUNF( LOW, HIGH )
+C
+C               GeNerate Uniform Real between LOW and HIGH
+C
+C
+C                              Function
+C
+C
+C     Generates a real uniformly distributed between LOW and HIGH.
+C
+C
+C                              Arguments
+C
+C
+C     LOW --> Low bound (exclusive) on real value to be generated
+C                         REAL LOW
+C
+C     HIGH --> High bound (exclusive) on real value to be generated
+C                         REAL HIGH
+C
+C**********************************************************************
+C**********************************************************************
+C
+C      SUBROUTINE GETCGN(G)
+C                         Get GeNerator
+C
+C     Returns in G the number of the current random number generator
+C
+C
+C                              Arguments
+C
+C
+C     G <-- Number of the current random number generator (1..32)
+C                    INTEGER G
+C
+C**********************************************************************
+C**********************************************************************
+C
+C     SUBROUTINE GETSD(ISEED1,ISEED2)
+C               GET SeeD
+C
+C     Returns the value of two integer seeds of the current generator
+C
+C     This  is   a  transcription from  Pascal   to  Fortran  of routine
+C     Get_State from the paper
+C
+C     L'Ecuyer, P. and  Cote,  S. "Implementing a Random Number  Package
+C     with   Splitting Facilities."  ACM  Transactions   on Mathematical
+C     Software, 17:98-111 (1991)
+C
+C
+C                              Arguments
+C
+C
+C
+C     ISEED1 <- First integer seed of generator G
+C                                   INTEGER ISEED1
+C
+C     ISEED2 <- Second integer seed of generator G
+C                                   INTEGER ISEED1
+C
+C**********************************************************************
+C**********************************************************************
+C
+C     INTEGER FUNCTION IGNBIN( N, P )
+C
+C                    GENerate BINomial random deviate
+C
+C
+C                              Function
+C
+C
+C     Generates a single random deviate from a binomial
+C     distribution whose number of trials is N and whose
+C     probability of an event in each trial is P.
+C
+C
+C                              Arguments
+C
+C
+C     N  --> The number of trials in the binomial distribution
+C            from which a random deviate is to be generated.
+C                              INTEGER N
 C                              (N >= 0)
-C                                                                        
-C     P  --> The probability of an event in each trial of the            
-C            binomial distribution from which a random deviate           
-C            is to be generated.                                         
-C                              REAL P                                    
+C
+C     P  --> The probability of an event in each trial of the
+C            binomial distribution from which a random deviate
+C            is to be generated.
+C                              REAL P
 C                              (0.0 <= P <= 1.0)
-C                                                                        
-C     IGNBIN <-- A random deviate yielding the number of events          
-C                from N independent trials, each of which has            
-C                a probability of event P.                               
-C                              INTEGER IGNBIN                            
-C                                                                        
-C                                                                        
-C                              Note                                      
-C                                                                        
-C                                                                        
-C     Uses RANF so the value of the seeds, ISEED1 and ISEED2 must be set 
-C     by a call similar to the following                                 
-C          DUM = RANSET( ISEED1, ISEED2 )                                
-C                                                                        
-C                                                                        
-C                              Method                                    
-C                                                                        
-C                                                                        
-C     This is algorithm BTPE from:                                       
-C                                                                        
-C         Kachitvichyanukul, V. and Schmeiser, B. W.                     
-C                                                                        
-C         Binomial Random Variate Generation.                            
-C         Communications of the ACM, 31, 2                               
-C         (February, 1988) 216.                                          
-C                                                                        
-C**********************************************************************  
+C
+C     IGNBIN <-- A random deviate yielding the number of events
+C                from N independent trials, each of which has
+C                a probability of event P.
+C                              INTEGER IGNBIN
+C
+C
+C                              Note
+C
+C
+C     Uses RANF so the value of the seeds, ISEED1 and ISEED2 must be set
+C     by a call similar to the following
+C          DUM = RANSET( ISEED1, ISEED2 )
+C
+C
+C                              Method
+C
+C
+C     This is algorithm BTPE from:
+C
+C         Kachitvichyanukul, V. and Schmeiser, B. W.
+C
+C         Binomial Random Variate Generation.
+C         Communications of the ACM, 31, 2
+C         (February, 1988) 216.
+C
+C**********************************************************************
 C**********************************************************************
 C
 C     INTEGER FUNCTION IGNNBN( N, P )
 C
 C                GENerate Negative BiNomial random deviate
 C
 C
 C                              Function
@@ -613,289 +613,289 @@ C
 C     Algorithm from page 480 of
 C
 C     Devroye, Luc
 C
 C     Non-Uniform Random Variate Generation.  Springer-Verlag,
 C     New York, 1986.
 C
 C**********************************************************************
-C**********************************************************************  
-C                                                                        
-C     INTEGER FUNCTION IGNLGI()                                          
-C               GeNerate LarGe Integer                                   
-C                                                                        
-C     Returns a random integer following a uniform distribution over     
-C     (1, 2147483562) using the current generator.                       
-C                                                                        
-C     This is a transcription from Pascal to Fortran of routine          
-C     Random from the paper                                              
-C                                                                        
-C     L'Ecuyer, P. and Cote, S. "Implementing a Random Number Package    
-C     with Splitting Facilities." ACM Transactions on Mathematical       
-C     Software, 17:98-111 (1991)                                         
-C                                                                        
-C**********************************************************************  
-C**********************************************************************  
-C                                                                        
-C     INTEGER FUNCTION IGNPOI( MU )                                      
-C                                                                        
-C                    GENerate POIsson random deviate                     
-C                                                                        
-C                                                                        
-C                              Function                                  
-C                                                                        
-C                                                                        
-C     Generates a single random deviate from a Poisson                   
-C     distribution with mean MU.                                         
-C                                                                        
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C     MU --> The mean of the Poisson distribution from which             
-C            a random deviate is to be generated.                        
-C                              REAL MU                                   
+C**********************************************************************
+C
+C     INTEGER FUNCTION IGNLGI()
+C               GeNerate LarGe Integer
+C
+C     Returns a random integer following a uniform distribution over
+C     (1, 2147483562) using the current generator.
+C
+C     This is a transcription from Pascal to Fortran of routine
+C     Random from the paper
+C
+C     L'Ecuyer, P. and Cote, S. "Implementing a Random Number Package
+C     with Splitting Facilities." ACM Transactions on Mathematical
+C     Software, 17:98-111 (1991)
+C
+C**********************************************************************
+C**********************************************************************
+C
+C     INTEGER FUNCTION IGNPOI( MU )
+C
+C                    GENerate POIsson random deviate
+C
+C
+C                              Function
+C
+C
+C     Generates a single random deviate from a Poisson
+C     distribution with mean MU.
+C
+C
+C                              Arguments
+C
+C
+C     MU --> The mean of the Poisson distribution from which
+C            a random deviate is to be generated.
+C                              REAL MU
 C                            (MU >= 0.0)
-C                                                                        
-C     IGNPOI <-- The random deviate.                                     
+C
+C     IGNPOI <-- The random deviate.
 C                              REAL IGNPOI (non-negative)
-C                                                                        
-C                                                                        
-C                              Method                                    
-C                                                                        
-C                                                                        
-C     Renames KPOIS from TOMS as slightly modified by BWB to use RANF    
-C     instead of SUNIF.                                                  
-C                                                                        
-C     For details see:                                                   
-C                                                                        
-C               Ahrens, J.H. and Dieter, U.                              
-C               Computer Generation of Poisson Deviates                  
-C               From Modified Normal Distributions.                      
-C               ACM Trans. Math. Software, 8, 2                          
-C               (June 1982),163-179                                      
-C                                                                        
-C**********************************************************************  
-C**********************************************************************  
-C                                                                        
-C     INTEGER FUNCTION IGNUIN( LOW, HIGH )                               
-C                                                                        
-C               GeNerate Uniform INteger                                 
-C                                                                        
-C                                                                        
-C                              Function                                  
-C                                                                        
-C                                                                        
-C     Generates an integer uniformly distributed between LOW and HIGH.   
-C                                                                        
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C     LOW --> Low bound (inclusive) on integer value to be generated     
-C                         INTEGER LOW                                    
-C                                                                        
-C     HIGH --> High bound (inclusive) on integer value to be generated   
-C                         INTEGER HIGH                                   
-C                                                                        
-C                                                                        
-C                              Note                                      
-C                                                                        
-C                                                                        
-C     If (HIGH-LOW) > 2,147,483,561 prints error message on * unit and   
-C     stops the program.                                                 
-C                                                                        
-C**********************************************************************  
-C**********************************************************************  
-C                                                                        
-C     SUBROUTINE INITGN(ISDTYP)                                          
-C          INIT-ialize current G-e-N-erator                              
-C                                                                        
-C     Reinitializes the state of the current generator                   
-C          ISDTYP = -1  => sets the state to its initial seed            
-C          ISDTYP =  0  => sets the state to its last (previous) seed    
-C          ISDTYP =  1  => sets the state to a new seed 2^w values       
-C                              from its last seed                        
-C                                                                        
-C     This is a transcription from Pascal to Fortran of routine          
-C     Init_Generator from the paper                                      
-C                                                                        
-C     L'Ecuyer, P. and Cote, S. "Implementing a Random Number Package    
-C     with Splitting Facilities." ACM Transactions on Mathematical       
-C     Software, 17:98-111 (1991)                                         
-C                                                                        
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C     ISDTYP -> The state to which the generator is to be set            
-C                                                                        
-C                                   INTEGER ISDTYP                       
-C                                                                        
-C**********************************************************************  
-C**********************************************************************  
-C                                                                        
-C     SUBROUTINE INRGCM()                                                
-C          INitialize Random number Generator CoMmon                     
-C                                                                        
-C                                                                        
-C                              Function                                  
-C                                                                        
-C                                                                        
-C     Initializes common area  for random number  generator.  This saves 
-C     the  nuisance  of  a  BLOCK DATA  routine  and the  difficulty  of 
-C     assuring that the routine is loaded with the other routines.       
-C                                                                        
-C**********************************************************************  
-C**********************************************************************  
-C                                                                        
-C     INTEGER FUNCTION MLTMOD(A,S,M)                                     
-C                                                                        
-C                    Returns (A*S) MOD M                                 
-C                                                                        
-C     This is a transcription from Pascal to Fortran of routine          
-C     MULtMod_Decompos from the paper                                    
-C                                                                        
-C     L'Ecuyer, P. and Cote, S. "Implementing a Random Number Package    
-C     with Splitting Facilities." ACM Transactions on Mathematical       
-C     Software, 17:98-111 (1991)                                         
-C                                                                        
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C     A, S, M  -->                                                       
-C                         INTEGER A,S,M                                  
-C                                                                        
-C**********************************************************************  
-C**********************************************************************  
-C                                                                        
-C     SUBROUTINE PHRTSD( PHRASE, SEED1, SEED2 )                          
-C               PHRase To SeeDs                                          
-C                                                                        
-C                                                                        
-C                              Function                                  
-C                                                                        
-C                                                                        
-C     Uses a phrase (character string) to generate two seeds for the RGN 
-C     random number generator.                                           
-C                                                                        
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C     PHRASE --> Phrase to be used for random number generation          
-C                         CHARACTER*(*) PHRASE                           
-C                                                                        
-C     SEED1 <-- First seed for RGN generator                             
-C                         INTEGER SEED1                                  
-C                                                                        
-C     SEED2 <-- Second seed for RGN generator                            
-C                         INTEGER SEED2                                  
-C                                                                        
-C                                                                        
-C                              Note                                      
-C                                                                        
-C                                                                        
-C     Trailing blanks are eliminated before the seeds are generated.     
-C                                                                        
-C     Generated seed values will fall in the range 1..2^30               
-C     (1..1,073,741,824)                                                 
-C                                                                        
-C**********************************************************************  
-C**********************************************************************  
-C                                                                        
-C     REAL FUNCTION RANF()                                               
-C                RANDom number generator as a Function                   
-C                                                                        
-C     Returns a random floating point number from a uniform distribution 
-C     over 0 - 1 (endpoints of this interval are not returned) using the 
-C     current generator                                                  
-C                                                                        
-C     This is a transcription from Pascal to Fortran of routine          
-C     Uniform_01 from the paper                                          
-C                                                                        
-C     L'Ecuyer, P. and Cote, S. "Implementing a Random Number Package    
-C     with Splitting Facilities." ACM Transactions on Mathematical       
-C     Software, 17:98-111 (1991)                                         
-C                                                                        
-C**********************************************************************  
-C**********************************************************************  
-C                                                                        
-C      SUBROUTINE SETALL(ISEED1,ISEED2)                                  
-C               SET ALL random number generators                         
-C                                                                        
-C     Sets the initial seed of generator 1 to ISEED1 and ISEED2. The     
-C     initial seeds of the other generators are set accordingly, and     
-C     all generators states are set to these seeds.                      
-C                                                                        
-C     This is a transcription from Pascal to Fortran of routine          
-C     Set_Initial_Seed from the paper                                    
-C                                                                        
-C     L'Ecuyer, P. and Cote, S. "Implementing a Random Number Package    
-C     with Splitting Facilities." ACM Transactions on Mathematical       
-C     Software, 17:98-111 (1991)                                         
-C                                                                        
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C     ISEED1 -> First of two integer seeds                               
-C                                   INTEGER ISEED1                       
-C                                                                        
-C     ISEED2 -> Second of two integer seeds                              
-C                                   INTEGER ISEED1                       
-C                                                                        
-C**********************************************************************  
-C**********************************************************************  
-C                                                                        
-C      SUBROUTINE SETANT(QVALUE)                                         
-C               SET ANTithetic                                           
-C                                                                        
-C     Sets whether the current generator produces antithetic values.  If 
-C     X   is  the value  normally returned  from  a uniform [0,1] random 
-C     number generator then 1  - X is the antithetic  value. If X is the 
-C     value  normally  returned  from a   uniform  [0,N]  random  number 
-C     generator then N - 1 - X is the antithetic value.                  
-C                                                                        
-C     All generators are initialized to NOT generate antithetic values.  
-C                                                                        
-C     This is a transcription from Pascal to Fortran of routine          
-C     Set_Antithetic from the paper                                      
-C                                                                        
-C     L'Ecuyer, P. and Cote, S. "Implementing a Random Number Package    
-C     with Splitting Facilities." ACM Transactions on Mathematical       
-C     Software, 17:98-111 (1991)                                         
-C                                                                        
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C     QVALUE -> .TRUE. if generator G is to generating antithetic        
-C                    values, otherwise .FALSE.                           
-C                                   LOGICAL QVALUE                       
-C                                                                        
-C**********************************************************************  
-C**********************************************************************  
-C                                                                        
-C     SUBROUTINE SETCGN( G )                                             
-C                      Set GeNerator                                     
-C                                                                        
+C
+C
+C                              Method
+C
+C
+C     Renames KPOIS from TOMS as slightly modified by BWB to use RANF
+C     instead of SUNIF.
+C
+C     For details see:
+C
+C               Ahrens, J.H. and Dieter, U.
+C               Computer Generation of Poisson Deviates
+C               From Modified Normal Distributions.
+C               ACM Trans. Math. Software, 8, 2
+C               (June 1982),163-179
+C
+C**********************************************************************
+C**********************************************************************
+C
+C     INTEGER FUNCTION IGNUIN( LOW, HIGH )
+C
+C               GeNerate Uniform INteger
+C
+C
+C                              Function
+C
+C
+C     Generates an integer uniformly distributed between LOW and HIGH.
+C
+C
+C                              Arguments
+C
+C
+C     LOW --> Low bound (inclusive) on integer value to be generated
+C                         INTEGER LOW
+C
+C     HIGH --> High bound (inclusive) on integer value to be generated
+C                         INTEGER HIGH
+C
+C
+C                              Note
+C
+C
+C     If (HIGH-LOW) > 2,147,483,561 prints error message on * unit and
+C     stops the program.
+C
+C**********************************************************************
+C**********************************************************************
+C
+C     SUBROUTINE INITGN(ISDTYP)
+C          INIT-ialize current G-e-N-erator
+C
+C     Reinitializes the state of the current generator
+C          ISDTYP = -1  => sets the state to its initial seed
+C          ISDTYP =  0  => sets the state to its last (previous) seed
+C          ISDTYP =  1  => sets the state to a new seed 2^w values
+C                              from its last seed
+C
+C     This is a transcription from Pascal to Fortran of routine
+C     Init_Generator from the paper
+C
+C     L'Ecuyer, P. and Cote, S. "Implementing a Random Number Package
+C     with Splitting Facilities." ACM Transactions on Mathematical
+C     Software, 17:98-111 (1991)
+C
+C
+C                              Arguments
+C
+C
+C     ISDTYP -> The state to which the generator is to be set
+C
+C                                   INTEGER ISDTYP
+C
+C**********************************************************************
+C**********************************************************************
+C
+C     SUBROUTINE INRGCM()
+C          INitialize Random number Generator CoMmon
+C
+C
+C                              Function
+C
+C
+C     Initializes common area  for random number  generator.  This saves
+C     the  nuisance  of  a  BLOCK DATA  routine  and the  difficulty  of
+C     assuring that the routine is loaded with the other routines.
+C
+C**********************************************************************
+C**********************************************************************
+C
+C     INTEGER FUNCTION MLTMOD(A,S,M)
+C
+C                    Returns (A*S) MOD M
+C
+C     This is a transcription from Pascal to Fortran of routine
+C     MULtMod_Decompos from the paper
+C
+C     L'Ecuyer, P. and Cote, S. "Implementing a Random Number Package
+C     with Splitting Facilities." ACM Transactions on Mathematical
+C     Software, 17:98-111 (1991)
+C
+C
+C                              Arguments
+C
+C
+C     A, S, M  -->
+C                         INTEGER A,S,M
+C
+C**********************************************************************
+C**********************************************************************
+C
+C     SUBROUTINE PHRTSD( PHRASE, SEED1, SEED2 )
+C               PHRase To SeeDs
+C
+C
+C                              Function
+C
+C
+C     Uses a phrase (character string) to generate two seeds for the RGN
+C     random number generator.
+C
+C
+C                              Arguments
+C
+C
+C     PHRASE --> Phrase to be used for random number generation
+C                         CHARACTER*(*) PHRASE
+C
+C     SEED1 <-- First seed for RGN generator
+C                         INTEGER SEED1
+C
+C     SEED2 <-- Second seed for RGN generator
+C                         INTEGER SEED2
+C
+C
+C                              Note
+C
+C
+C     Trailing blanks are eliminated before the seeds are generated.
+C
+C     Generated seed values will fall in the range 1..2^30
+C     (1..1,073,741,824)
+C
+C**********************************************************************
+C**********************************************************************
+C
+C     REAL FUNCTION RANF()
+C                RANDom number generator as a Function
+C
+C     Returns a random floating point number from a uniform distribution
+C     over 0 - 1 (endpoints of this interval are not returned) using the
+C     current generator
+C
+C     This is a transcription from Pascal to Fortran of routine
+C     Uniform_01 from the paper
+C
+C     L'Ecuyer, P. and Cote, S. "Implementing a Random Number Package
+C     with Splitting Facilities." ACM Transactions on Mathematical
+C     Software, 17:98-111 (1991)
+C
+C**********************************************************************
+C**********************************************************************
+C
+C      SUBROUTINE SETALL(ISEED1,ISEED2)
+C               SET ALL random number generators
+C
+C     Sets the initial seed of generator 1 to ISEED1 and ISEED2. The
+C     initial seeds of the other generators are set accordingly, and
+C     all generators states are set to these seeds.
+C
+C     This is a transcription from Pascal to Fortran of routine
+C     Set_Initial_Seed from the paper
+C
+C     L'Ecuyer, P. and Cote, S. "Implementing a Random Number Package
+C     with Splitting Facilities." ACM Transactions on Mathematical
+C     Software, 17:98-111 (1991)
+C
+C
+C                              Arguments
+C
+C
+C     ISEED1 -> First of two integer seeds
+C                                   INTEGER ISEED1
+C
+C     ISEED2 -> Second of two integer seeds
+C                                   INTEGER ISEED1
+C
+C**********************************************************************
+C**********************************************************************
+C
+C      SUBROUTINE SETANT(QVALUE)
+C               SET ANTithetic
+C
+C     Sets whether the current generator produces antithetic values.  If
+C     X   is  the value  normally returned  from  a uniform [0,1] random
+C     number generator then 1  - X is the antithetic  value. If X is the
+C     value  normally  returned  from a   uniform  [0,N]  random  number
+C     generator then N - 1 - X is the antithetic value.
+C
+C     All generators are initialized to NOT generate antithetic values.
+C
+C     This is a transcription from Pascal to Fortran of routine
+C     Set_Antithetic from the paper
+C
+C     L'Ecuyer, P. and Cote, S. "Implementing a Random Number Package
+C     with Splitting Facilities." ACM Transactions on Mathematical
+C     Software, 17:98-111 (1991)
+C
+C
+C                              Arguments
+C
+C
+C     QVALUE -> .TRUE. if generator G is to generating antithetic
+C                    values, otherwise .FALSE.
+C                                   LOGICAL QVALUE
+C
+C**********************************************************************
+C**********************************************************************
+C
+C     SUBROUTINE SETCGN( G )
+C                      Set GeNerator
+C
 C     Sets  the  current  generator to G.    All references to a generato
-C     are to the current generator.                                      
-C                                                                        
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C     G --> Number of the current random number generator (1..32)        
-C                    INTEGER G                                           
-C                                                                        
-C**********************************************************************  
+C     are to the current generator.
+C
+C
+C                              Arguments
+C
+C
+C     G --> Number of the current random number generator (1..32)
+C                    INTEGER G
+C
+C**********************************************************************
 C**********************************************************************
 C
 C     SUBROUTINE SETGMN( MEANV, COVM, LDCOVM, P, PARM)
 C            SET Generate Multivariate Normal random deviate
 C
 C
 C                              Function
 C
@@ -927,35 +927,35 @@ C     PARM <-- Array of parameters neede
 C                normal deviates (P, MEANV and Cholesky decomposition
 C                of COVM).
 C                1 : 1                - P
 C                2 : P + 1            - MEANV
 C                P+2 : P*(P+3)/2 + 1  - Cholesky decomposition of COVM
 C                                             REAL PARM(P*(P+3)/2 + 1)
 C
 C**********************************************************************
-C**********************************************************************  
-C                                                                        
-C     SUBROUTINE SETSD(ISEED1,ISEED2)                                    
-C               SET S-ee-D of current generator                          
-C                                                                        
-C     Resets the initial seed and state of generator g to ISEED1 and     
-C     ISEED2. The seeds and states of the other generators  remain       
-C     unchanged.                                                         
-C                                                                        
-C     This is a transcription from Pascal to Fortran of routine          
-C     Set_Seed from the paper                                            
-C                                                                        
-C     L'Ecuyer, P. and Cote, S. "Implementing a Random Number Package    
-C     with Splitting Facilities." ACM Transactions on Mathematical       
-C     Software, 17:98-111 (1991)                                         
-C                                                                        
-C                                                                        
-C                              Arguments                                 
-C                                                                        
-C                                                                        
-C     ISEED1 -> First integer seed                                       
-C                                   INTEGER ISEED1                       
-C                                                                        
-C     ISEED2 -> Second integer seed                                      
-C                                   INTEGER ISEED1                       
-C                                                                        
-C**********************************************************************  
+C**********************************************************************
+C
+C     SUBROUTINE SETSD(ISEED1,ISEED2)
+C               SET S-ee-D of current generator
+C
+C     Resets the initial seed and state of generator g to ISEED1 and
+C     ISEED2. The seeds and states of the other generators  remain
+C     unchanged.
+C
+C     This is a transcription from Pascal to Fortran of routine
+C     Set_Seed from the paper
+C
+C     L'Ecuyer, P. and Cote, S. "Implementing a Random Number Package
+C     with Splitting Facilities." ACM Transactions on Mathematical
+C     Software, 17:98-111 (1991)
+C
+C
+C                              Arguments
+C
+C
+C     ISEED1 -> First integer seed
+C                                   INTEGER ISEED1
+C
+C     ISEED2 -> Second integer seed
+C                                   INTEGER ISEED1
+C
+C**********************************************************************
diff --git a/liboctave/cruft/ranlib/setsd.f b/liboctave/cruft/ranlib/setsd.f
--- a/liboctave/cruft/ranlib/setsd.f
+++ b/liboctave/cruft/ranlib/setsd.f
@@ -57,17 +57,17 @@ C     ..
 C     .. Save statement ..
       SAVE /globe/
 C     ..
 C     .. Executable Statements ..
 C     Abort unless random number generator initialized
       IF (qrgnin()) GO TO 10
       WRITE (*,*) ' SETSD called before random number generator ',
      +  ' initialized -- abort!'
-      CALL XSTOPX 
+      CALL XSTOPX
      + (' SETSD called before random number generator initialized')
 
    10 CALL getcgn(g)
       ig1(g) = iseed1
       ig2(g) = iseed2
       CALL initgn(-1)
       RETURN
 
diff --git a/liboctave/cruft/ranlib/tstgmn.for b/liboctave/cruft/ranlib/tstgmn.for
--- a/liboctave/cruft/ranlib/tstgmn.for
+++ b/liboctave/cruft/ranlib/tstgmn.for
@@ -25,17 +25,17 @@ C      covar = 0.0
       onecov = 0.0
       DO 10,i = 1,n
 C      covar = covar + (x(i)-avx)* (y(i)-avy)
          onecov = onecov + (x(i)-avx)* (y(i)-avy)
  10   CONTINUE
 C      covar = covar/real(n-1)
       onecov = onecov/real(n-1)
       RETURN
-      
+
       END
 
 C     JJV Added argument LDXCOV (leading dimension of XCOVAR) to be
 C     JJV consistent with the program TSTGMN, see comments below.
 C     JJV This change necessitated changes in the declarations.
 C      SUBROUTINE prcomp(p,mean,xcovar,answer)
       SUBROUTINE prcomp(p,mean,xcovar,ldxcov,answer)
 
diff --git a/liboctave/cruft/ranlib/tstmid.for b/liboctave/cruft/ranlib/tstmid.for
--- a/liboctave/cruft/ranlib/tstmid.for
+++ b/liboctave/cruft/ranlib/tstmid.for
@@ -339,17 +339,17 @@ C
   300 CONTINUE
       CALL stat(array,1000,av,var,xmin,xmax)
       CALL trstat(type,param,avtr,vartr)
       WRITE (*,9020) av,avtr,var,vartr,xmin,xmax
       GO TO 420
 
  310  IF ((13).NE. (iwhich)) GO TO 360
 
-C      
+C
 C     Multinomial outcomes
 C
       WRITE (*,*) ' Enter (int) number of observations: '
       READ (*,*) ntry
  320  WRITE (*,*) ' Enter (int) num. of categories: <= ',mxncat
       READ (*,*) ncat
       IF (ncat.GT.mxncat) THEN
          WRITE (*,*) ' number of categories must be <= ',mxncat
diff --git a/liboctave/cruft/slatec-fn/atanh.f b/liboctave/cruft/slatec-fn/atanh.f
--- a/liboctave/cruft/slatec-fn/atanh.f
+++ b/liboctave/cruft/slatec-fn/atanh.f
@@ -53,17 +53,17 @@ C***FIRST EXECUTABLE STATEMENT  ATANH
          NTERMS = INITS (ATNHCS, 15, 0.1*R1MACH(3))
          DXREL = SQRT (R1MACH(4))
          SQEPS = SQRT (3.0*R1MACH(3))
       ENDIF
       FIRST = .FALSE.
 C
       Y = ABS(X)
       IF (Y .GE. 1.0) THEN
-         IF (Y .GT. 1.0) THEN 
+         IF (Y .GT. 1.0) THEN
             ATANH = (X - X) / (X - X)
          ELSE
             ATANH = X / 0.0
          ENDIF
          RETURN
       ENDIF
 C
       IF (1.0-Y .LT. DXREL) CALL XERMSG ('SLATEC', 'ATANH',
diff --git a/liboctave/cruft/slatec-fn/datanh.f b/liboctave/cruft/slatec-fn/datanh.f
--- a/liboctave/cruft/slatec-fn/datanh.f
+++ b/liboctave/cruft/slatec-fn/datanh.f
@@ -64,17 +64,17 @@ C***FIRST EXECUTABLE STATEMENT  DATANH
          NTERMS = INITDS (ATNHCS, 27, 0.1*REAL(D1MACH(3)) )
          DXREL = SQRT(D1MACH(4))
          SQEPS = SQRT(3.0D0*D1MACH(3))
       ENDIF
       FIRST = .FALSE.
 C
       Y = ABS(X)
       IF (Y .GE. 1.D0) THEN
-         IF (Y .GT. 1.D0) THEN 
+         IF (Y .GT. 1.D0) THEN
             DATANH = (X - X) / (X - X)
          ELSE
             DATANH = X / 0.D0
          ENDIF
          RETURN
       ENDIF
 C
       IF (1.D0-Y .LT. DXREL) CALL XERMSG ('SLATEC', 'DATANH',
diff --git a/liboctave/cruft/slatec-fn/xgmainc.f b/liboctave/cruft/slatec-fn/xgmainc.f
--- a/liboctave/cruft/slatec-fn/xgmainc.f
+++ b/liboctave/cruft/slatec-fn/xgmainc.f
@@ -8,17 +8,17 @@ c -- Do a better job than dgami for larg
       intrinsic exp, log, sqrt, sign, aint
       external dgami, dlngam, d9lgit, d9lgic, d9gmit
 
 C     external dgamr
 C     DOUBLE PRECISION DGAMR
 
       DOUBLE PRECISION AEPS, AINTA, ALGAP1, ALNEPS, ALNG, ALX,
      $     BOT, H, SGA, SGNGAM, SQEPS, T, D1MACH, D9GMIT,
-     $     D9LGIC, D9LGIT, DLNGAM, DGAMI 
+     $     D9LGIC, D9LGIT, DLNGAM, DGAMI
 
       LOGICAL FIRST
 
       SAVE ALNEPS, SQEPS, BOT, FIRST
 
       DATA FIRST /.TRUE./
 
       if (x .eq. 0.0d0) then
diff --git a/liboctave/cruft/slatec-fn/xsgmainc.f b/liboctave/cruft/slatec-fn/xsgmainc.f
--- a/liboctave/cruft/slatec-fn/xsgmainc.f
+++ b/liboctave/cruft/slatec-fn/xsgmainc.f
@@ -8,17 +8,17 @@ c -- Do a better job than gami for large
       intrinsic exp, log, sqrt, sign, aint
       external gami, alngam, r9lgit, r9lgic, r9gmit
 
 C     external gamr
 C     real GAMR
 
       REAL AEPS, AINTA, ALGAP1, ALNEPS, ALNG, ALX,
      $     BOT, H, SGA, SGNGAM, SQEPS, T, R1MACH, R9GMIT,
-     $     R9LGIC, R9LGIT, ALNGAM, GAMI 
+     $     R9LGIC, R9LGIT, ALNGAM, GAMI
 
       LOGICAL FIRST
 
       SAVE ALNEPS, SQEPS, BOT, FIRST
 
       DATA FIRST /.TRUE./
 
       if (x .eq. 0.0e0) then
diff --git a/liboctave/numeric/module.mk b/liboctave/numeric/module.mk
--- a/liboctave/numeric/module.mk
+++ b/liboctave/numeric/module.mk
@@ -85,17 +85,17 @@ NUMERIC_INC = \
   numeric/randpoisson.h \
   numeric/sparse-base-chol.h \
   numeric/sparse-base-lu.h \
   numeric/SparseCmplxCHOL.h \
   numeric/SparseCmplxLU.h \
   numeric/SparseCmplxQR.h \
   numeric/SparsedbleCHOL.h \
   numeric/SparsedbleLU.h \
-  numeric/SparseQR.h 
+  numeric/SparseQR.h
 
 NUMERIC_C_SRC = \
   numeric/randgamma.c \
   numeric/randmtzig.c \
   numeric/randpoisson.c
 
 NUMERIC_SRC = \
   numeric/CmplxAEPBAL.cc \
diff --git a/liboctave/operators/mk-ops.awk b/liboctave/operators/mk-ops.awk
--- a/liboctave/operators/mk-ops.awk
+++ b/liboctave/operators/mk-ops.awk
@@ -1,22 +1,22 @@
 # Copyright (C) 2003-2013 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 BEGIN {
   declare_types = 0;
   generate_ops = 0;
   ntypes = 0;
@@ -53,17 +53,17 @@ BEGIN {
           fwd_decl_ok[ntypes] = $5 == "YES";
           header[ntypes] = $4 == "NONE" ? "" : $4;
           class[ntypes] = $3;
           type[ntypes] = $2;
           tag[ntypes] = $1;
           rev_tag[$1] = ntypes;
         }
       else
-        printf ("skipping line %d: %s\n", NR, $0); 
+        printf ("skipping line %d: %s\n", NR, $0);
     }
   else if (generate_ops)
     {
       if (NF >= 4)
         {
           result_tag = $1;
           lhs_tag = $2;
           rhs_tag = $3;
@@ -228,15 +228,15 @@ BEGIN {
           if (bool_ops)
             printf ("%s%s_BOOL_OPS (%s, %s)\n", lhs_class, rhs_class,
                     lhs_type, rhs_type) >> cc_file
 
 
           close (cc_file);
         }
       else
-        printf ("skipping line %d: %s\n", NR, $0); 
+        printf ("skipping line %d: %s\n", NR, $0);
     }
 }
 END {
   if (make_inclusive_header)
     print "#endif";
 }
diff --git a/liboctave/operators/mx-ops b/liboctave/operators/mx-ops
--- a/liboctave/operators/mx-ops
+++ b/liboctave/operators/mx-ops
@@ -1,22 +1,22 @@
 # Copyright (C) 2003-2013 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 # NOTE: if this file changes, you must run bootstrap and configure to
 # rebuild the source file lists for Make.
 
 # types
diff --git a/liboctave/operators/sparse-mk-ops.awk b/liboctave/operators/sparse-mk-ops.awk
--- a/liboctave/operators/sparse-mk-ops.awk
+++ b/liboctave/operators/sparse-mk-ops.awk
@@ -1,22 +1,22 @@
 # Copyright (C) 2004-2013 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 BEGIN {
   declare_types = 0;
   generate_ops = 0;
   ntypes = 0;
@@ -50,17 +50,17 @@ BEGIN {
           fwd_decl_ok[ntypes] = $5 == "YES";
           header[ntypes] = $4 == "NONE" ? "" : $4;
           class[ntypes] = $3;
           type[ntypes] = $2;
           tag[ntypes] = $1;
           rev_tag[$1] = ntypes;
         }
       else
-        printf ("skipping line %d: %s\n", NR, $0); 
+        printf ("skipping line %d: %s\n", NR, $0);
     }
   else if (generate_ops)
     {
       if (NF >= 5)
         {
           result_tag_1 = $1;
           result_tag_2 = $2;
           lhs_tag = $3;
@@ -169,17 +169,17 @@ BEGIN {
               else
                 printf ("#include \"%s\"\n", rhs_header) >> h_file;
             }
 
           printf ("#include \"Sparse-op-defs.h\"\n") >> h_file;
 
           if (bin_ops)
             printf ("SPARSE_%s%s_BIN_OP_DECLS (%s, %s, %s, %s, OCTAVE_API)\n", lhs_class,
-                    rhs_class, result_type_1, result_type_2, lhs_type, 
+                    rhs_class, result_type_1, result_type_2, lhs_type,
                     rhs_type) >> h_file
 
           if (cmp_ops)
             printf ("SPARSE_%s%s_CMP_OP_DECLS (%s, %s, OCTAVE_API)\n", lhs_class,
                     rhs_class, lhs_type, rhs_type) >> h_file
 
           if (eqne_ops)
             printf ("SPARSE_%s%s_EQNE_OP_DECLS (%s, %s, OCTAVE_API)\n", lhs_class,
@@ -220,38 +220,38 @@ BEGIN {
 
           if (lhs_header && ! (lhs_header == result_header_1 || lhs_header == result_header_2))
             printf ("#include \"%s\"\n", lhs_header) >> cc_file;
 
           if (rhs_header && ! (rhs_header == lhs_header || rhs_header == result_header_1 || rhs_heaer == result_header_2))
             printf ("#include \"%s\"\n", rhs_header) >> cc_file;
 
           if (bin_ops)
-            printf ("SPARSE_%s%s_BIN_OPS (%s, %s, %s, %s)\n", lhs_class, 
-                    rhs_class, result_type_1, result_type_2, lhs_type, 
+            printf ("SPARSE_%s%s_BIN_OPS (%s, %s, %s, %s)\n", lhs_class,
+                    rhs_class, result_type_1, result_type_2, lhs_type,
                     rhs_type) >> cc_file
 
           if (cmp_ops)
-            printf ("SPARSE_%s%s_CMP_OPS (%s, %s, %s, %s, %s, %s)\n", 
+            printf ("SPARSE_%s%s_CMP_OPS (%s, %s, %s, %s, %s, %s)\n",
                     lhs_class, rhs_class, lhs_type, lhs_scalar_zero_val,
                     lhs_conv, rhs_type, rhs_scalar_zero_val, rhs_conv) >> cc_file
 
           if (eqne_ops)
-            printf ("SPARSE_%s%s_EQNE_OPS (%s, %s, %s, %s, %s, %s)\n", 
+            printf ("SPARSE_%s%s_EQNE_OPS (%s, %s, %s, %s, %s, %s)\n",
                     lhs_class, rhs_class, lhs_type, lhs_scalar_zero_val,
                     lhs_conv, rhs_type, rhs_scalar_zero_val, rhs_conv) >> cc_file
 
           if (bool_ops)
-            printf ("SPARSE_%s%s_BOOL_OPS2 (%s, %s, %s, %s)\n", lhs_class, 
+            printf ("SPARSE_%s%s_BOOL_OPS2 (%s, %s, %s, %s)\n", lhs_class,
                     rhs_class, lhs_type, rhs_type, lhs_scalar_zero_val,
                     rhs_scalar_zero_val) >> cc_file
 
 
           close (cc_file);
         }
       else
-        printf ("skipping line %d: %s\n", NR, $0); 
+        printf ("skipping line %d: %s\n", NR, $0);
     }
 }
 END {
   if (make_inclusive_header)
     print "#endif";
 }
diff --git a/liboctave/operators/sparse-mx-ops b/liboctave/operators/sparse-mx-ops
--- a/liboctave/operators/sparse-mx-ops
+++ b/liboctave/operators/sparse-mx-ops
@@ -1,22 +1,22 @@
 # Copyright (C) 2004-2013 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 # NOTE: if this file changes, you must run bootstrap and configure to
 # rebuild the source file lists for Make.
 
 # types
diff --git a/liboctave/operators/vx-ops b/liboctave/operators/vx-ops
--- a/liboctave/operators/vx-ops
+++ b/liboctave/operators/vx-ops
@@ -1,22 +1,22 @@
 # Copyright (C) 2003-2013 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 # NOTE: if this file changes, you must run bootstrap and configure to
 # rebuild the source file lists for Make.
 
 # types
diff --git a/liboctave/util/module.mk b/liboctave/util/module.mk
--- a/liboctave/util/module.mk
+++ b/liboctave/util/module.mk
@@ -44,17 +44,17 @@ UTIL_INC = \
   util/sun-utils.h \
   util/unwind-prot.h \
   util/url-transfer.h
 
 UTIL_C_SRC = \
   util/f2c-main.c \
   util/lo-cutils.c \
   util/oct-rl-edit.c \
-  util/oct-rl-hist.c 
+  util/oct-rl-hist.c
 
 UTIL_SRC = \
   util/cmd-edit.cc \
   util/cmd-hist.cc \
   util/data-conv.cc \
   util/glob-match.cc \
   util/lo-array-gripes.cc \
   util/lo-ieee.cc \
diff --git a/run-octave.in b/run-octave.in
--- a/run-octave.in
+++ b/run-octave.in
@@ -1,36 +1,36 @@
 #! /bin/sh
 ##
 ## run-octave -- run Octave in the build tree.
-## 
+##
 ## Copyright (C) 2006-2013 John W. Eaton
 ##
 ## This file is part of Octave.
-## 
+##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
-## 
+##
 ## Octave is distributed in the hope that it will be useful, but WITHOUT
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 AWK=%AWK%
 FIND=%FIND%
 SED=%SED%
 
 # FIXME -- is there a better way to handle the possibility of spaces
-# in these names? 
+# in these names?
 
 top_srcdir='%abs_top_srcdir%'
 builddir='%builddir%'
 
 d1="$top_srcdir/scripts"
 d2="$builddir/scripts"
 d3="$builddir/libinterp"
 
diff --git a/scripts/@ftp/ftp.m b/scripts/@ftp/ftp.m
--- a/scripts/@ftp/ftp.m
+++ b/scripts/@ftp/ftp.m
@@ -26,27 +26,27 @@
 ##
 ## The list of actions for an FTP object are shown below.  All functions
 ## require an FTP object as the first argument.
 ##
 ## @multitable @columnfractions 0.15 0.8
 ## @headitem Method @tab Description
 ## @item ascii @tab Set transfer type to ascii
 ## @item binary @tab Set transfer type to binary
-## @item cd @tab Change remote working directory 
+## @item cd @tab Change remote working directory
 ## @item close @tab Close FTP connection
-## @item delete @tab Delete remote file 
-## @item dir @tab List remote directory contents 
+## @item delete @tab Delete remote file
+## @item dir @tab List remote directory contents
 ## @item mget @tab Download remote files
 ## @item mkdir @tab Create remote directory
 ## @item mput @tab Upload local files
 ## @item rename @tab Rename remote file or directory
 ## @item rmdir @tab Remove remote directory
 ## @end multitable
-## 
+##
 ## @end deftypefn
 
 function obj = ftp (host = "", username = "anonymous", password = "")
   if (nargin == 1 && isa (host, "ftp"))
     obj = host;   # Copy constructor
   else
     p.host = host;
     p.username = username;
diff --git a/scripts/audio/wavread.m b/scripts/audio/wavread.m
--- a/scripts/audio/wavread.m
+++ b/scripts/audio/wavread.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{y} =} wavread (@var{filename})
 ## @deftypefnx {Function File} {[@var{y}, @var{Fs}, @var{bps}] =} wavread (@var{filename})
 ## @deftypefnx {Function File} {[@dots{}] =} wavread (@var{filename}, @var{n})
 ## @deftypefnx {Function File} {[@dots{}] =} wavread (@var{filename}, [@var{n1} @var{n2}])
 ## @deftypefnx {Function File} {[@var{samples}, @var{channels}] =} wavread (@var{filename}, "size")
-## 
+##
 ## Load the RIFF/WAVE sound file @var{filename}, and return the samples
 ## in vector @var{y}.  If the file contains multichannel data, then
 ## @var{y} is a matrix with the channels represented as columns.
 ##
 ## @code{[@var{y}, @var{Fs}, @var{bps}] = wavread (@var{filename})}
 ##
 ## Additionally return the sample rate (@var{fs}) in Hz and the number of bits
 ## per sample (@var{bps}).
diff --git a/scripts/deprecated/java_convert_matrix.m b/scripts/deprecated/java_convert_matrix.m
--- a/scripts/deprecated/java_convert_matrix.m
+++ b/scripts/deprecated/java_convert_matrix.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Built-in Function} {@var{val} =} java_convert_matrix ()
 ## @deftypefnx {Built-in Function} {@var{old_val} =} java_convert_matrix (@var{new_val})
 ## @deftypefnx {Built-in Function} {} java_convert_matrix (@var{new_val}, "local")
 ## Query or set the internal variable that controls whether Java arrays are
 ## automatically converted to Octave matrices.  The default value is false.
-## 
+##
 ## When called from inside a function with the @qcode{"local"} option, the
 ## variable is changed locally for the function and any subroutines it calls.
 ##  The original variable value is restored when exiting the function.
 ## @seealso{java_matrix_autoconversion, java_unsigned_conversion, java_debug}
 ## @end deftypefn
 
 function old_val = java_convert_matrix (varargin)
 
diff --git a/scripts/deprecated/java_debug.m b/scripts/deprecated/java_debug.m
--- a/scripts/deprecated/java_debug.m
+++ b/scripts/deprecated/java_debug.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Built-in Function} {@var{val} =} java_debug ()
 ## @deftypefnx {Built-in Function} {@var{old_val} =} java_debug (@var{new_val})
 ## @deftypefnx {Built-in Function} {} java_debug (@var{new_val}, "local")
 ## Query or set the internal variable that determines whether extra debugging
 ## information regarding the initialization of the JVM and any Java exceptions
 ## is printed.
-## 
+##
 ## When called from inside a function with the @qcode{"local"} option, the
 ## variable is changed locally for the function and any subroutines it calls.
 ##  The original variable value is restored when exiting the function.
 ## @seealso{debug_java, java_convert_matrix, java_unsigned_conversion}
 ## @end deftypefn
 
 function old_val = java_debug (varargin)
 
diff --git a/scripts/deprecated/java_invoke.m b/scripts/deprecated/java_invoke.m
--- a/scripts/deprecated/java_invoke.m
+++ b/scripts/deprecated/java_invoke.m
@@ -16,42 +16,42 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Built-in Function} {@var{ret} =} java_invoke (@var{obj}, @var{methodname})
 ## @deftypefnx {Built-in Function} {@var{ret} =} java_invoke (@var{obj}, @var{methodname}, @var{arg1}, @dots{})
 ## Invoke the method @var{methodname} on the Java object @var{obj} with the
 ## arguments @var{arg1}, @dots{}  For static methods, @var{obj} can be a
-## string representing the fully qualified name of the corresponding class. 
+## string representing the fully qualified name of the corresponding class.
 ## The function returns the result of the method invocation.
-## 
+##
 ## When @var{obj} is a regular Java object, structure-like indexing can be
 ## used as a shortcut syntax.  For instance, the two following statements are
 ## equivalent
-## 
+##
 ## @example
 ## @group
 ##   ret = java_invoke (x, "method1", 1.0, "a string")
 ##   ret = x.method1 (1.0, "a string")
 ## @end group
 ## @end example
-## 
+##
 ## @seealso{javaMethod, javaObject}
 ## @end deftypefn
 
 function retval = java_invoke (obj, methodname, varargin)
 
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
              "java_invoke is obsolete and will be removed from a future version of Octave, please use javaMethod instead");
   endif
-  
+
   if (nargin < 2)
     print_usage ();
   endif
 
   retval = javaMethod (methodname, obj, varargin{:});
 
 endfunction
 
diff --git a/scripts/deprecated/java_new.m b/scripts/deprecated/java_new.m
--- a/scripts/deprecated/java_new.m
+++ b/scripts/deprecated/java_new.m
@@ -16,24 +16,24 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Loadable Function} {@var{obj} =} java_new (@var{name})
 ## @deftypefnx {Loadable Function} {@var{obj} =} java_new (@var{name}, @var{arg1}, @dots{})
 ## Create a Java object of class @var{name}, by calling the class constructor
 ## with the arguments @var{arg1}, @dots{}
-## 
+##
 ## @example
 ## @group
 ##   x = java_new ("java.lang.StringBuffer")
 ##   x = java_new ("java.lang.StringBuffer", "Initial string")
 ## @end group
 ## @end example
-## 
+##
 ## @seealso{javaObject, javaMethod}
 ## @end deftypefn
 
 function retval = java_new (varargin)
 
   persistent warned = false;
   if (! warned)
     warned = true;
diff --git a/scripts/deprecated/java_unsigned_conversion.m b/scripts/deprecated/java_unsigned_conversion.m
--- a/scripts/deprecated/java_unsigned_conversion.m
+++ b/scripts/deprecated/java_unsigned_conversion.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Built-in Function} {@var{val} =} java_unsigned_conversion ()
 ## @deftypefnx {Built-in Function} {@var{old_val} =} java_unsigned_conversion (@var{new_val})
 ## @deftypefnx {Built-in Function} {} java_unsigned_conversion (@var{new_val}, "local")
 ## Query or set the internal variable that controls how integer classes are
 ## converted when Java matrix autoconversion is enabled.  When enabled, Java
 ## arrays of class Byte or Integer are converted to matrices of class uint8 or
 ## uint32 respectively.
-## 
+##
 ## When called from inside a function with the @qcode{"local"} option, the
 ## variable is changed locally for the function and any subroutines it calls.
 ##  The original variable value is restored when exiting the function.
 ## @seealso{java_unsigned_autoconversion, java_convert_matrix, debug_java}
 ## @end deftypefn
 
 function old_val = java_unsigned_conversion (varargin)
 
diff --git a/scripts/deprecated/javafields.m b/scripts/deprecated/javafields.m
--- a/scripts/deprecated/javafields.m
+++ b/scripts/deprecated/javafields.m
@@ -15,35 +15,35 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} javafields (@var{javaobj})
 ## @deftypefnx {Function File} {} javafields ("@var{classname}")
 ## @deftypefnx {Function File} {@var{fld_names} =} javafields (@dots{})
-## Return the fields of a Java object or Java class in the form of a cell 
+## Return the fields of a Java object or Java class in the form of a cell
 ## array of strings.  If no output is requested, print the result
 ## to the standard output.
 ## @seealso{fieldnames, methods, javaObject}
 ## @end deftypefn
 
 function fld_names = javafields (javaobj)
 
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
              "javafields is obsolete and will be removed from a future version of Octave, please use fieldnames instead");
   endif
-  
+
   if (nargin != 1)
     print_usage ();
   endif
-  
+
   c_methods = javaMethod ("getFields", "org.octave.ClassHelper", javaobj);
   method_list = ostrsplit (c_methods, ';');
 
   if (nargout == 0)
     if (! isempty (method_list))
       disp (method_list);
     endif
   else
diff --git a/scripts/deprecated/javamethods.m b/scripts/deprecated/javamethods.m
--- a/scripts/deprecated/javamethods.m
+++ b/scripts/deprecated/javamethods.m
@@ -15,31 +15,31 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} javamethods (@var{javaobj})
 ## @deftypefnx {Function File} {} javamethods ("@var{classname}")
 ## @deftypefnx {Function File} {@var{mtd_names} =} javamethods (@dots{})
-## Return the methods of a Java object or Java class in the form of a cell 
+## Return the methods of a Java object or Java class in the form of a cell
 ## array of strings.  If no output is requested, print the result to the
 ## standard output.
 ## @seealso{methods, fieldnames, javaMethod, javaObject}
 ## @end deftypefn
 
 function mtd_names = javamethods (classname)
 
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
              "javamethods is obsolete and will be removed from a future version of Octave, please use methods instead");
   endif
-  
+
   if (nargin != 1)
     print_usage ();
   endif
 
   cls_methods = javaMethod ("getMethods", "org.octave.ClassHelper", classname);
   method_list = ostrsplit (cls_methods, ';');
 
   if (nargout == 0)
diff --git a/scripts/general/accumarray.m b/scripts/general/accumarray.m
--- a/scripts/general/accumarray.m
+++ b/scripts/general/accumarray.m
@@ -137,17 +137,17 @@ function A = accumarray (subs, vals, sz 
     subs = cellfun (@vec, subs, "uniformoutput", false);
     ndims = numel (subs);
     if (ndims == 1)
       subs = subs{1};
     endif
 
     lensubs = cellfun (@length, subs);
 
-    if (any (lensubs != lensubs(1)) || 
+    if (any (lensubs != lensubs(1)) ||
         (lenvals > 1 && lenvals != lensubs(1)))
       error ("accumarray: dimension mismatch");
     endif
 
   else
     ndims = columns (subs);
     if (lenvals > 1 && lenvals != rows (subs))
       error ("accumarray: dimension mismatch");
diff --git a/scripts/general/display.m b/scripts/general/display.m
--- a/scripts/general/display.m
+++ b/scripts/general/display.m
@@ -32,20 +32,20 @@
 ## @seealso{class, subsref, subsasgn}
 ## @end deftypefn
 
 function idx = display (a)
 
   if (nargin != 1)
     print_usage ();
   endif
- 
+
   ## Only reason we got here is that there was no overloaded display()
   ## function for object a.  This may mean it is a built-in.
   str = disp (a);
   if (isempty (strfind (str, "<class ")))
-    disp (str);   
+    disp (str);
   else
     error ('display: not defined for class "%s"', class (a));
   endif
 
 endfunction
 
diff --git a/scripts/general/fieldnames.m b/scripts/general/fieldnames.m
--- a/scripts/general/fieldnames.m
+++ b/scripts/general/fieldnames.m
@@ -32,47 +32,47 @@
 ##
 ## When the input is a Java object @var{javaobj} or Java classname
 ## @var{jclassname} the name are the public data elements of the object or
 ## class.
 ## @seealso{nfields, isfield, orderfields, struct, methods}
 ## @end deftypefn
 
 function names = fieldnames (obj)
-  
+
   if (nargin != 1)
     print_usage ();
   endif
-  
+
   if (isstruct (obj) || isobject (obj))
     ## Call internal C++ function for structs or Octave objects
     names = __fieldnames__ (obj);
   elseif (isjava (obj) || ischar (obj))
     ## FIXME: Function prototype that excepts java obj exists, but doesn't
     ##        work if obj is java.lang.String.  Convert obj to classname.
     if (! ischar (obj))
       obj = class (obj);
     endif
     names_str = javaMethod ("getFields", "org.octave.ClassHelper", obj);
     names = ostrsplit (names_str, ';');
   else
-    error ("fieldnames: Invalid input argument"); 
+    error ("fieldnames: Invalid input argument");
   endif
 
 endfunction
 
 
 ## test preservation of fieldname order
 %!test
 %! x(3).d=1;  x(2).a=2;  x(1).b=3;  x(2).c=3;
 %! assert (fieldnames (x), {"d"; "a"; "b"; "c"});
 
 ## test empty structure
 %!test
 %! s = struct ();
 %! assert (fieldnames (s), cell (0, 1));
 
 ## test Java classname
-%!testif HAVE_JAVA 
+%!testif HAVE_JAVA
 %! names = fieldnames ("java.lang.Double");
 %! search = strfind (names, "java.lang.Double.MAX_VALUE");
 %! assert (! isempty ([search{:}]));
 
diff --git a/scripts/general/interp1.m b/scripts/general/interp1.m
--- a/scripts/general/interp1.m
+++ b/scripts/general/interp1.m
@@ -59,17 +59,17 @@
 ## and is never slower.  The default method is @qcode{"linear"}.
 ##
 ## If @var{extrap} is the string @qcode{"extrap"}, then extrapolate values
 ## beyond the endpoints using the current @var{method}.  If @var{extrap} is a
 ## number, then replace values beyond the endpoints with that number.  When
 ## unspecified, @var{extrap} defaults to NA.
 ##
 ## If the string argument @qcode{"pp"} is specified, then @var{xi} should not
-## be supplied and @code{interp1} returns a piecewise polynomial object.  This 
+## be supplied and @code{interp1} returns a piecewise polynomial object.  This
 ## object can later be used with @code{ppval} to evaluate the interpolation.
 ## There is an equivalence, such that @code{ppval (interp1 (@var{x},
 ## @var{y}, @var{method}, @qcode{"pp"}), @var{xi}) == interp1 (@var{x}, @var{y},
 ## @var{xi}, @var{method}, @qcode{"extrap"})}.
 ##
 ## Duplicate points in @var{x} specify a discontinuous interpolant.  There
 ## may be at most 2 consecutive points with the same value.
 ## If @var{x} is increasing, the default discontinuous interpolant is
diff --git a/scripts/general/interp2.m b/scripts/general/interp2.m
--- a/scripts/general/interp2.m
+++ b/scripts/general/interp2.m
@@ -616,17 +616,17 @@ endfunction
 %! z = [1 3 5; 3 5 7; 5 7 9];
 %! zout = [1 2 3 4 5; 2 3 4 5 6; 3 4 5 6 7; 4 5 6 7 8; 5 6 7 8 9];
 %! tol = 2 * eps;
 %!assert (interp2 (z), zout, tol)
 %!assert (interp2 (z, "linear"), zout, tol)
 %!assert (interp2 (z, "pchip"), zout, tol)
 %!assert (interp2 (z, "cubic"), zout, 10 * tol)
 %!assert (interp2 (z, "spline"), zout, tol)
-%!assert (interp2 (z, [2 3 1], [2 2 2]', "linear"), repmat ([5, 7, 3], [3, 1]), tol) 
-%!assert (interp2 (z, [2 3 1], [2 2 2]', "pchip"), repmat ([5, 7, 3], [3, 1]), tol) 
-%!assert (interp2 (z, [2 3 1], [2 2 2]', "cubic"), repmat ([5, 7, 3], [3, 1]), 10 * tol) 
-%!assert (interp2 (z, [2 3 1], [2 2 2]', "spline"), repmat ([5, 7, 3], [3, 1]), tol) 
+%!assert (interp2 (z, [2 3 1], [2 2 2]', "linear"), repmat ([5, 7, 3], [3, 1]), tol)
+%!assert (interp2 (z, [2 3 1], [2 2 2]', "pchip"), repmat ([5, 7, 3], [3, 1]), tol)
+%!assert (interp2 (z, [2 3 1], [2 2 2]', "cubic"), repmat ([5, 7, 3], [3, 1]), 10 * tol)
+%!assert (interp2 (z, [2 3 1], [2 2 2]', "spline"), repmat ([5, 7, 3], [3, 1]), tol)
 %!assert (interp2 (z, [2 3 1], [2 2 2], "linear"), [5 7 3], tol)
 %!assert (interp2 (z, [2 3 1], [2 2 2], "pchip"), [5 7 3], tol)
 %!assert (interp2 (z, [2 3 1], [2 2 2], "cubic"), [5 7 3], 10 * tol)
 %!assert (interp2 (z, [2 3 1], [2 2 2], "spline"), [5 7 3], tol)
 
diff --git a/scripts/general/interp3.m b/scripts/general/interp3.m
--- a/scripts/general/interp3.m
+++ b/scripts/general/interp3.m
@@ -184,17 +184,17 @@ endfunction
 %!shared z, zout, tol
 %! z = zeros (3, 3, 3);
 %! zout = zeros (5, 5, 5);
 %! z(:,:,1) = [1 3 5; 3 5 7; 5 7 9];
 %! z(:,:,2) = z(:,:,1) + 2;
 %! z(:,:,3) = z(:,:,2) + 2;
 %! for n = 1:5
 %!   zout(:,:,n) = [1 2 3 4 5;
-%!                  2 3 4 5 6; 
+%!                  2 3 4 5 6;
 %!                  3 4 5 6 7;
 %!                  4 5 6 7 8;
 %!                  5 6 7 8 9] + (n-1);
 %! end
 %! tol = 10 * eps;
 %!assert (interp3 (z), zout, tol)
 %!assert (interp3 (z, "linear"), zout, tol)
 %!assert (interp3 (z, "spline"), zout, tol)
diff --git a/scripts/general/methods.m b/scripts/general/methods.m
--- a/scripts/general/methods.m
+++ b/scripts/general/methods.m
@@ -24,21 +24,21 @@
 ## Return a cell array containing the names of the methods for the
 ## object @var{obj} or the named class @var{classname}.
 ## @var{obj} may be an Octave class object or a Java object.
 ##
 ## @seealso{fieldnames}
 ## @end deftypefn
 
 function mtds = methods (obj)
-  
+
   if (nargin != 1)
     print_usage ();
   endif
-  
+
   if (isobject (obj))
     ## Call internal C++ function for Octave objects
     mtds_list = __methods__ (obj);
   elseif (ischar (obj))
     ## Could be a classname for an Octave class or Java class.
     ## Try Octave class first.
     mtds_list = __methods__ (obj);
     if (isempty (mtds_list))
@@ -67,13 +67,13 @@ endfunction
 
 
 ## test Octave classname
 %!test
 %! mtds = methods ("ftp");
 %! assert (mtds{1}, "ascii");
 
 ## test Java classname
-%!testif HAVE_JAVA 
+%!testif HAVE_JAVA
 %! mtds = methods ("java.lang.Double");
 %! search = strfind (mtds, "java.lang.Double valueOf");
 %! assert (! isempty ([search{:}]));
 
diff --git a/scripts/general/sortrows.m b/scripts/general/sortrows.m
--- a/scripts/general/sortrows.m
+++ b/scripts/general/sortrows.m
@@ -33,17 +33,17 @@
 
 function [s, i] = sortrows (A, c)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (nargin == 2)
-    if (! (isnumeric (c) && isvector (c))) 
+    if (! (isnumeric (c) && isvector (c)))
       error ("sortrows: C must be a numeric vector");
     elseif (any (c == 0) || any (abs (c) > columns (A)))
       error ("sortrows: all elements of C must be in the range [1, columns (A)]");
     endif
   endif
 
   default_mode = "ascend";
   reverse_mode = "descend";
diff --git a/scripts/geometry/convhull.m b/scripts/geometry/convhull.m
--- a/scripts/geometry/convhull.m
+++ b/scripts/geometry/convhull.m
@@ -25,18 +25,18 @@
 ##
 ## An optional third argument, which must be a string or cell array of strings,
 ## contains options passed to the underlying qhull command.
 ## See the documentation for the Qhull library for details
 ## @url{http://www.qhull.org/html/qh-quick.htm#options}.
 ## The default option is @code{@{"Qt"@}}.
 ##
 ## If @var{options} is not present or @code{[]} then the default arguments are
-## used.  Otherwise, @var{options} replaces the default argument list. 
-## To append user options to the defaults it is necessary to repeat the 
+## used.  Otherwise, @var{options} replaces the default argument list.
+## To append user options to the defaults it is necessary to repeat the
 ## default arguments in @var{options}.  Use a null string to pass no arguments.
 ##
 ## @seealso{convhulln, delaunay, voronoi}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 
 function H = convhull (x, y, options)
diff --git a/scripts/geometry/delaunay.m b/scripts/geometry/delaunay.m
--- a/scripts/geometry/delaunay.m
+++ b/scripts/geometry/delaunay.m
@@ -36,21 +36,21 @@
 ##
 ## The optional last argument, which must be a string or cell array of strings,
 ## contains options passed to the underlying qhull command.
 ## See the documentation for the Qhull library for details
 ## @url{http://www.qhull.org/html/qh-quick.htm#options}.
 ## The default options are @code{@{"Qt", "Qbb", "Qc", "Qz"@}}.
 ##
 ## If @var{options} is not present or @code{[]} then the default arguments are
-## used.  Otherwise, @var{options} replaces the default argument list. 
-## To append user options to the defaults it is necessary to repeat the 
+## used.  Otherwise, @var{options} replaces the default argument list.
+## To append user options to the defaults it is necessary to repeat the
 ## default arguments in @var{options}.  Use a null string to pass no arguments.
 ##
-## If no output argument is specified the resulting Delaunay triangulation 
+## If no output argument is specified the resulting Delaunay triangulation
 ## is plotted along with the original set of points.
 ##
 ## @example
 ## @group
 ## x = rand (1, 10);
 ## y = rand (1, 10);
 ## T = delaunay (x, y);
 ## VX = [ x(T(:,1)); x(T(:,2)); x(T(:,3)); x(T(:,1)) ];
@@ -76,17 +76,17 @@ function tri = delaunay (varargin)
 
     case 1
       if (! ismatrix (varargin{1}) || columns (varargin{1}) != 2)
           error ("delaunay: X must be a matrix with 2 columns");
       else
         x = varargin{1}(:,1);
         y = varargin{1}(:,2);
       endif
-    
+
     case 2
       if (isnumeric (varargin{2}))
         x = varargin{1};
         y = varargin{2};
       elseif (ischar (varargin{2}) || iscellstr (varargin{2}))
         options = varargin{2};
         if (! ismatrix (varargin{1}) && columns (varargin{1}) != 2)
             error ("delaunay: X must be a matrix with 2 columns");
diff --git a/scripts/geometry/delaunay3.m b/scripts/geometry/delaunay3.m
--- a/scripts/geometry/delaunay3.m
+++ b/scripts/geometry/delaunay3.m
@@ -33,18 +33,18 @@
 ##
 ## An optional fourth argument, which must be a string or cell array of strings,
 ## contains options passed to the underlying qhull command.
 ## See the documentation for the Qhull library for details
 ## @url{http://www.qhull.org/html/qh-quick.htm#options}.
 ## The default options are @code{@{"Qt", "Qbb", "Qc", "Qz"@}}.
 ##
 ## If @var{options} is not present or @code{[]} then the default arguments are
-## used.  Otherwise, @var{options} replaces the default argument list. 
-## To append user options to the defaults it is necessary to repeat the 
+## used.  Otherwise, @var{options} replaces the default argument list.
+## To append user options to the defaults it is necessary to repeat the
 ## default arguments in @var{options}.  Use a null string to pass no arguments.
 ##
 ## @seealso{delaunay, delaunayn, convhull, voronoi, tetramesh}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 
 function tetr = delaunay3 (x, y, z, options)
diff --git a/scripts/geometry/delaunayn.m b/scripts/geometry/delaunayn.m
--- a/scripts/geometry/delaunayn.m
+++ b/scripts/geometry/delaunayn.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{T} =} delaunayn (@var{pts})
 ## @deftypefnx {Function File} {@var{T} =} delaunayn (@var{pts}, @var{options})
 ## Compute the Delaunay triangulation for an N-dimensional set of points.
 ## The Delaunay triangulation is a tessellation of the convex hull of a set
 ## of points such that no N-sphere defined by the N-triangles contains
 ## any other points from the set.
-## 
+##
 ## The input matrix @var{pts} of size [n, dim] contains n points in a space of
 ## dimension dim.  The return matrix @var{T} has size [m, dim+1].  Each row
 ## of @var{T} contains a set of indices back into the original set of points
 ## @var{pts} which describes a simplex of dimension dim.  For example, a 2-D
 ## simplex is a triangle and 3-D simplex is a tetrahedron.
 ##
 ## An optional second argument, which must be a string or cell array of strings,
 ## contains options passed to the underlying qhull command.
@@ -38,18 +38,18 @@
 ##
 ## @itemize
 ## @item 2-D and 3-D: @var{options} = @code{@{"Qt", "Qbb", "Qc", "Qz"@}}
 ##
 ## @item 4-D and higher: @var{options} = @code{@{"Qt", "Qbb", "Qc", "Qx"@}}
 ## @end itemize
 ##
 ## If @var{options} is not present or @code{[]} then the default arguments are
-## used.  Otherwise, @var{options} replaces the default argument list. 
-## To append user options to the defaults it is necessary to repeat the 
+## used.  Otherwise, @var{options} replaces the default argument list.
+## To append user options to the defaults it is necessary to repeat the
 ## default arguments in @var{options}.  Use a null string to pass no arguments.
 ##
 ## @seealso{delaunay, delaunay3, convhulln, voronoin, trimesh, tetramesh}
 ## @end deftypefn
 
 function T = delaunayn (pts, varargin)
 
   if (nargin < 1)
diff --git a/scripts/geometry/griddata.m b/scripts/geometry/griddata.m
--- a/scripts/geometry/griddata.m
+++ b/scripts/geometry/griddata.m
@@ -48,17 +48,17 @@ function [rx, ry, rz] = griddata (x, y, 
   if (ischar (method))
     method = tolower (method);
   endif
 
   ## Meshgrid if x and y are vectors but z is matrix
   if (isvector (x) && isvector (y) && all ([numel(y), numel(x)] == size (z)))
     [x, y] = meshgrid (x, y);
   endif
-    
+
   if (isvector (x) && isvector (y) && isvector (z))
     if (! isequal (length (x), length (y), length (z)))
       error ("griddata: X, Y, and Z must be vectors of the same length");
     endif
   elseif (! size_equal (x, y, z))
     error ("griddata: lengths of X, Y must match the columns and rows of Z");
   endif
 
diff --git a/scripts/geometry/griddatan.m b/scripts/geometry/griddatan.m
--- a/scripts/geometry/griddatan.m
+++ b/scripts/geometry/griddatan.m
@@ -22,17 +22,17 @@
 ## @deftypefnx {Function File} {@var{yi} =} griddatan (@var{x}, @var{y}, @var{xi}, @var{method}, @var{options})
 ##
 ## Generate a regular mesh from irregular data using interpolation.
 ## The function is defined by @code{@var{y} = f (@var{x})}.
 ## The interpolation points are all @var{xi}.
 ##
 ## The interpolation method can be @qcode{"nearest"} or @qcode{"linear"}.
 ## If method is omitted it defaults to @qcode{"linear"}.
-## 
+##
 ## The optional argument @var{options} is passed directly to Qhull when
 ## computing the Delaunay triangulation used for interpolation.  See
 ## @code{delaunayn} for information on the defaults and how to pass different
 ## values.
 ## @seealso{griddata, griddata3, delaunayn}
 ## @end deftypefn
 
 ## Author: David Bateman <dbateman@free.fr>
diff --git a/scripts/geometry/voronoi.m b/scripts/geometry/voronoi.m
--- a/scripts/geometry/voronoi.m
+++ b/scripts/geometry/voronoi.m
@@ -20,17 +20,17 @@
 ## @deftypefn  {Function File} {} voronoi (@var{x}, @var{y})
 ## @deftypefnx {Function File} {} voronoi (@var{x}, @var{y}, @var{options})
 ## @deftypefnx {Function File} {} voronoi (@dots{}, "linespec")
 ## @deftypefnx {Function File} {} voronoi (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} voronoi (@dots{})
 ## @deftypefnx {Function File} {[@var{vx}, @var{vy}] =} voronoi (@dots{})
 ## Plot the Voronoi diagram of points @code{(@var{x}, @var{y})}.
 ## The Voronoi facets with points at infinity are not drawn.
-## 
+##
 ## If @qcode{"linespec"} is given it is used to set the color and line style
 ## of the plot.  If an axis graphics handle @var{hax} is supplied then the
 ## Voronoi diagram is drawn on the specified axis rather than in a new
 ## figure.
 ##
 ## The @var{options} argument, which must be a string or cell array of strings,
 ## contains options passed to the underlying qhull command.
 ## See the documentation for the Qhull library for details
diff --git a/scripts/geometry/voronoin.m b/scripts/geometry/voronoin.m
--- a/scripts/geometry/voronoin.m
+++ b/scripts/geometry/voronoin.m
@@ -33,18 +33,18 @@
 ##
 ## @itemize
 ## @item 2-D and 3-D: @var{options} = @code{@{"Qbb"@}}
 ##
 ## @item 4-D and higher: @var{options} = @code{@{"Qbb", "Qx"@}}
 ## @end itemize
 ##
 ## If @var{options} is not present or @code{[]} then the default arguments are
-## used.  Otherwise, @var{options} replaces the default argument list. 
-## To append user options to the defaults it is necessary to repeat the 
+## used.  Otherwise, @var{options} replaces the default argument list.
+## To append user options to the defaults it is necessary to repeat the
 ## default arguments in @var{options}.  Use a null string to pass no arguments.
 ##
 ## @seealso{voronoi, convhulln, delaunayn}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## First Release: 20/08/2000
 
diff --git a/scripts/gui/guihandles.m b/scripts/gui/guihandles.m
--- a/scripts/gui/guihandles.m
+++ b/scripts/gui/guihandles.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{hdata} =} guihandles (@var{h})
 ## @deftypefnx {Function File} {@var{hdata} =} guihandles
 ## Return a structure of object handles for the figure associated with
 ## handle @var{h}.
-## 
+##
 ## If no handle is specified the current figure returned by @code{gcf} is used.
 ##
 ## The fieldname for each entry of @var{hdata} is taken from the @qcode{"tag"}
 ## property of the graphic object.  If the tag is empty then the handle is not
 ## returned.  If there are multiple graphic objects with the same tag then
 ## the entry in @var{hdata} will be a vector of handles.  @code{guihandles}
 ## includes all possible handles, including those for
 ## which @qcode{"HandleVisibility"} is @qcode{"off"}.
diff --git a/scripts/gui/inputdlg.m b/scripts/gui/inputdlg.m
--- a/scripts/gui/inputdlg.m
+++ b/scripts/gui/inputdlg.m
@@ -24,31 +24,31 @@
 ## Return user input from a multi-textfield dialog box in a cell array
 ## of strings, or an empty cell array if the dialog is closed by the
 ## Cancel button.
 ##
 ## Inputs:
 ##
 ## @table @var
 ## @item prompt
-## A cell array with strings labeling each text field.  This input is required. 
+## A cell array with strings labeling each text field.  This input is required.
 ##
 ## @item title
 ## String to use for the caption of the dialog.  The default is @qcode{"Input
 ## Dialog"}.
 ##
 ## @item rowscols
 ## Specifies the size of the text fields and can take three forms:
 ##
 ## @enumerate
 ## @item a scalar value which defines the number of rows used for each
 ## text field.
 ##
 ## @item a vector which defines the individual number of rows
-## used for each text field. 
+## used for each text field.
 ##
 ## @item a matrix which defines the individual number of rows and
 ## columns used for each text field.  In the matrix each row describes
 ## a single text field.  The first column specifies the number of input
 ## rows to use and the second column specifies the text field width.
 ## @end enumerate
 ##
 ## @item defaults
@@ -86,17 +86,17 @@ function cstr = inputdlg (prompt, title 
       linespec = varargin{1};
       defaults = cellstr (cell (size (prompt)));
 
     case 2
       linespec = varargin{1};
       defaults = varargin{2};
   endswitch
 
-  ## specification of text field sizes as in Matlab 
+  ## specification of text field sizes as in Matlab
   ## Matlab requires a matrix for linespec, not a cell array...
   ## rc = [1,10; 2,20; 3,30];
   ##     c1  c2
   ## r1  1   10   first  text field is 1x10
   ## r2  2   20   second text field is 2x20
   ## r3  3   30   third  text field is 3x30
   if (isscalar (linespec))
     ## only scalar value in lineTo, copy from linespec and add defaults
@@ -117,26 +117,26 @@ function cstr = inputdlg (prompt, title 
     else
       error ("inputdlg: ROWSCOLS matrix does not match size of PROMPT");
     endif
   else
     ## dunno
     error ("inputdlg: unknown form of ROWSCOLS argument");
   endif
   rowscols = ceil (rowscols);
-  
+
   ## convert numeric values in defaults cell array to strings
   defs = cellfun (@num2str, defaults, "UniformOutput", false);
   rc = arrayfun (@num2str, rowscols, "UniformOutput", false);
 
   if (__octave_link_enabled__ ())
     cstr = __octave_link_input_dialog__ (prompt, title, rowscols, defs);
   elseif (__have_feature__ ("JAVA"))
     user_inputs = javaMethod ("inputdlg", "org.octave.JDialogBox",
-                              prompt, title, rc, defs);  
+                              prompt, title, rc, defs);
     if (isempty (user_inputs))
       cstr = {};
     else
       cstr = cellstr (user_inputs);
     endif
   else
     error ("inputdlg is not available in this version of Octave");
   endif
diff --git a/scripts/gui/listdlg.m b/scripts/gui/listdlg.m
--- a/scripts/gui/listdlg.m
+++ b/scripts/gui/listdlg.m
@@ -13,25 +13,25 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{sel}, @var{ok}] =} listdlg (@var{key}, @var{value}, @dots{})
-## Return user inputs from a list dialog box in a vector of 
+## Return user inputs from a list dialog box in a vector of
 ## selection indices @var{sel} and a flag @var{ok} indicating how the
 ## user closed the dialog box.  The value of @var{ok} is 1 if the user
 ## closed the box with the OK button, otherwise it is 0 and @var{sel} is
 ## empty.
 ##
 ## The indices in @var{sel} are 1-based.
 ##
-## The arguments are specified in form of @var{key}, @var{value} pairs. 
+## The arguments are specified in form of @var{key}, @var{value} pairs.
 ## The @qcode{"ListString"} argument pair must be specified.
 ##
 ## Valid @var{key} and @var{value} pairs are:
 ##
 ## @table @asis
 ## @item @qcode{"ListString"}
 ## a cell array of strings comprising the content of the list.
 ##
diff --git a/scripts/gui/msgbox.m b/scripts/gui/msgbox.m
--- a/scripts/gui/msgbox.m
+++ b/scripts/gui/msgbox.m
@@ -15,24 +15,24 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{h} =} msgbox (@var{msg})
 ## @deftypefnx {Function File} {@var{h} =} msgbox (@var{msg}, @var{title})
 ## @deftypefnx {Function File} {@var{h} =} msgbox (@var{msg}, @var{title}, @var{icon})
-## Display @var{msg} using a message dialog box. 
+## Display @var{msg} using a message dialog box.
 ##
 ## The message may have multiple lines separated by newline characters
 ## (@qcode{"\n"}), or it may be a cellstr array with one element for each
 ## line.  The optional input @var{title} (character string) can be used to
 ## decorate the dialog caption.
 ##
-## The optional argument @var{icon} selects a dialog icon. 
+## The optional argument @var{icon} selects a dialog icon.
 ## It can be one of @qcode{"none"} (default), @qcode{"error"},
 ## @qcode{"help"}, or @qcode{"warn"}.
 ##
 ## The return value is always 1.
 ## @seealso{errordlg, helpdlg, inputdlg, listdlg, questdlg, warndlg}
 ## @end deftypefn
 
 function retval = msgbox (msg, title = "", varargin)
diff --git a/scripts/gui/questdlg.m b/scripts/gui/questdlg.m
--- a/scripts/gui/questdlg.m
+++ b/scripts/gui/questdlg.m
@@ -27,37 +27,37 @@
 ##
 ## The dialog may contain two or three buttons which will all close the dialog.
 ##
 ## The message may have multiple lines separated by newline characters
 ## ("\n"), or it may be a cellstr array with one element for each
 ## line.  The optional @var{title} (character string) can be used to
 ## decorate the dialog caption.
 ##
-## The string @var{default} identifies the default button, 
+## The string @var{default} identifies the default button,
 ## which is activated by pressing the @key{ENTER} key.
 ## It must match one of the strings given in @var{btn1}, @var{btn2}, or
 ## @var{btn3}.
 ##
 ## If only @var{msg} and @var{title} are specified, three buttons with
 ## the default captions @qcode{"Yes"}, @qcode{"No"}, and @qcode{"Cancel"} are
 ## used.
 ##
-## If only two button captions, @var{btn1} and @var{btn2}, are specified 
+## If only two button captions, @var{btn1} and @var{btn2}, are specified
 ## the dialog will have only these two buttons.
 ##
 ## @seealso{errordlg, helpdlg, inputdlg, listdlg, warndlg}
 ## @end deftypefn
 
 function btn = questdlg (msg, title = "Question Dialog", varargin)
 
   if (nargin < 1 || nargin > 6)
     print_usage ();
   endif
-  
+
   if (! ischar (msg))
     if (iscell (msg))
       msg = sprintf ("%s\n", msg{:});
       msg(end) = "";
     else
       error ("questdlg: MSG must be a character string or cellstr array");
     endif
   endif
diff --git a/scripts/gui/uigetfile.m b/scripts/gui/uigetfile.m
--- a/scripts/gui/uigetfile.m
+++ b/scripts/gui/uigetfile.m
@@ -75,17 +75,17 @@ function [retfile, retpath, retindex] = 
       if (! __is_function__ (funcname))
         error ("uigetfile: fltk graphics toolkit required");
       elseif (! strcmp (defaulttoolkit, "gnuplot"))
         warning ("uigetfile: no implementation for toolkit '%s', using 'fltk' instead",
                defaulttoolkit);
       endif
     endif
   endif
-  
+
   if (nargin > 7)
     error ("uigetfile: number of input arguments must be less than eight");
   endif
 
   defaultvals = {cell(0, 2),         # File Filter
                  "Open File",        # Dialog Title
                  "",                 # Default file name
                  [240, 120],         # Dialog Position (pixel x/y)
diff --git a/scripts/gui/waitbar.m b/scripts/gui/waitbar.m
--- a/scripts/gui/waitbar.m
+++ b/scripts/gui/waitbar.m
@@ -24,17 +24,17 @@
 ## @deftypefnx {Function File} {} waitbar (@var{frac}, @var{hwbar})
 ## @deftypefnx {Function File} {} waitbar (@var{frac}, @var{hwbar}, @var{msg})
 ## Return a handle @var{h} to a new waitbar object.
 ##
 ## The waitbar is filled to fraction @var{frac} which must be in the range
 ## [0, 1].  The optional message @var{msg} is centered and displayed above the
 ## waitbar.  The appearance of the waitbar figure window can be configured by
 ## passing property/value pairs to the function.
-## 
+##
 ## When called with a single input the current waitbar, if it exists, is
 ## updated to the new value @var{frac}.  If there are multiple outstanding
 ## waitbars they can be updated individually by passing the handle @var{hwbar}
 ## of the specific waitbar to modify.
 ## @end deftypefn
 
 ## Author: jwe
 
@@ -90,17 +90,17 @@ function h = waitbar (varargin)
 
     set (hp, "xdata", [0; frac; frac; 0]);
 
     if (ischar (msg) || iscellstr (msg))
       th = get (ax, "title");
       curr_msg = get (th, "string");
       ## graphics handles always store data as column vectors
       if (iscellstr (msg))
-        msg = msg(:);  
+        msg = msg(:);
       endif
       cmp = strcmp (msg, curr_msg);
       if (! all (cmp(:)))
         set (th, "string", msg);
       endif
     endif
   else
     ## Save and restore current figure
diff --git a/scripts/gui/warndlg.m b/scripts/gui/warndlg.m
--- a/scripts/gui/warndlg.m
+++ b/scripts/gui/warndlg.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{h} =} warndlg (@var{msg})
 ## @deftypefnx {Function File} {@var{h} =} warndlg (@var{msg}, @var{title})
-## Display @var{msg} using a warning dialog box. 
+## Display @var{msg} using a warning dialog box.
 ##
 ## The message may have multiple lines separated by newline characters
 ## ("\n"), or it may be a cellstr array with one element for each
 ## line.  The optional input @var{title} (character string) can be used to
 ## set the dialog caption.  The default title is @qcode{"Warning Dialog"}.
 ##
 ## @seealso{helpdlg, inputdlg, listdlg, questdlg}
 ## @end deftypefn
diff --git a/scripts/help/doc.m b/scripts/help/doc.m
--- a/scripts/help/doc.m
+++ b/scripts/help/doc.m
@@ -52,17 +52,17 @@ function retval = doc (fname)
     else
       fname = "";
     endif
 
     ## if GUI is running, let it display the function
     if isguirunning ()
       __octave_link_show_doc__ (fname);
     else
-  
+
       if (ftype == 2 || ftype == 3)
         ffile = which (fname);
       else
         ffile = "";
       endif
 
       if (isempty (ffile))
         info_dir = octave_config_info ("infodir");
@@ -93,17 +93,17 @@ function retval = doc (fname)
       cmd = sprintf ("\"%s\" --file \"%s\" --directory \"%s\"",
                      info_program (), info_file_name, info_dir);
 
       have_fname = ! isempty (fname);
 
       if (have_fname)
         status = system (sprintf ("%s --index-search \"%s\"", cmd, fname));
       endif
-   
+
 
       if (! (have_fname && status == 0))
         status = system (cmd);
         if (status == 127)
           warning ("unable to find info program '%s'", info_program ());
         endif
       endif
 
diff --git a/scripts/help/help.m b/scripts/help/help.m
--- a/scripts/help/help.m
+++ b/scripts/help/help.m
@@ -122,17 +122,17 @@ function retval = help (name)
 
   else
     error ("help: invalid input\n");
   endif
 
 endfunction
 
 function retval = do_list_operators ()
-  
+
   retval = sprintf ("*** operators:\n\n%s\n\n",
                        list_in_columns (__operators__ ()));
 endfunction
 
 function retval = do_list_functions ()
 
   operators = do_list_operators ();
 
diff --git a/scripts/help/type.m b/scripts/help/type.m
--- a/scripts/help/type.m
+++ b/scripts/help/type.m
@@ -132,9 +132,9 @@ endfunction
 
 %!assert (type ("amd"){1}, "amd is a dynamically-linked function")
 %!assert (type ("cat"){1}, "cat is a built-in function")
 %!assert (type ("+"){1}, "+ is an operator")
 %!assert (type ("end"){1}, "end is a keyword")
 
 %!error type ()
 %!error <'__NO_NAME__' undefined> type ('__NO_NAME__')
- 
+
diff --git a/scripts/image/bone.m b/scripts/image/bone.m
--- a/scripts/image/bone.m
+++ b/scripts/image/bone.m
@@ -65,17 +65,17 @@ function map = bone (n)
     r(1:idx,1) = 7/8 * x(1:idx);
     r(idx:n,1) = linspace (7/8 * x(idx) + base, 1, nel);
 
     idx = floor (3/8 * n);
     nel = idx + 1;
     g(1:idx,1) = 7/8 * x(1:idx);
     g(idx:2*idx,1) = linspace (7/8 * x(idx), 7/8 * x(2*idx) + 1/8, nel);
     g(2*idx+1:n,1) = 7/8 * x(2*idx+1:n) + 1/8;
-    
+
     base = 1 / (8*idx);
     nel = idx;
     b(1:idx,1) = linspace (base, 7/8 * x(idx) + 1/8, nel);
     b(idx:n,1) = 7/8 * x(idx:n) + 1/8;
 
     map = [r, g, b];
   else
     map = zeros (0, 3);
diff --git a/scripts/image/cmpermute.m b/scripts/image/cmpermute.m
--- a/scripts/image/cmpermute.m
+++ b/scripts/image/cmpermute.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 2004 Josep Mones i Teixidor
-## Copyright (C) 2012-2013 Rik Wehbring 
+## Copyright (C) 2012-2013 Rik Wehbring
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -64,21 +64,21 @@ function [Y, newmap] = cmpermute (X, map
   endif
 
   ## new colormap
   newmap = map(index,:);
 
   ## build reverse index
   rindex = zeros (size (index));
   rindex(index) = 1:length (index);
- 
+
   ## preserve class of input image in output
-  if (strcmp (cls, "double")) 
+  if (strcmp (cls, "double"))
     Y = rindex(X);
-  elseif (strcmp (cls, "single")) 
+  elseif (strcmp (cls, "single"))
     rindex = single (rindex);
     Y = rindex(X);
   else
     ## adapt indices
     rindex = feval (cls, rindex - 1);
     ## 0-based indices
     Y = rindex(single (X) + 1);
   endif
@@ -92,17 +92,17 @@ endfunction
 
 %!shared X, map
 %! X = uint8 (magic (16));
 %! [X, map] = cmunique (X);
 
 %!test # random permutation, 0-based index
 %! [Y, newmap] = cmpermute (X, map);
 %! ## test we didn't lose colors
-%! assert (sort (map), sortrows (newmap)); 
+%! assert (sort (map), sortrows (newmap));
 %! ## test if images are equal
 %! assert (map(double (X)+1), newmap(double (Y)+1));
 
 %!test # reverse map, 0-based index
 %! [Y, newmap] = cmpermute (X, map, rows (map):-1:1);
 %! ## we expect a reversed colormap
 %! assert (flipud (newmap), map);
 %! ## we expect reversed indices in image
@@ -110,17 +110,17 @@ endfunction
 
 %!shared X,map
 %! X = uint16 (magic (20));
 %! [X, map] = cmunique (X);
 
 %!test # random permutation, 1-based index
 %! [Y, newmap] = cmpermute (X, map);
 %! ## test we didn't lose colors
-%! assert (sort (map), sortrows (newmap)); 
+%! assert (sort (map), sortrows (newmap));
 %! ## test if images are equal
 %! assert (map(X), newmap(Y));
 
 %!test # reverse map, 1-based index
 %! [Y, newmap] = cmpermute (X, map, rows (map):-1:1);
 %! ## we expect a reversed colormap
 %! assert (newmap (rows (newmap):-1:1,:), map);
 %! ## we expect reversed indices in image
diff --git a/scripts/image/cmunique.m b/scripts/image/cmunique.m
--- a/scripts/image/cmunique.m
+++ b/scripts/image/cmunique.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 2004 Josep Mones i Teixidor
-## Copyright (C) 2012-2013 Rik Wehbring 
+## Copyright (C) 2012-2013 Rik Wehbring
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -19,17 +19,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{Y}, @var{newmap}] =} cmunique (@var{X}, @var{map})
 ## @deftypefnx {Function File} {[@var{Y}, @var{newmap}] =} cmunique (@var{RGB})
 ## @deftypefnx {Function File} {[@var{Y}, @var{newmap}] =} cmunique (@var{I})
 ## Convert an input image @var{X} to an ouput indexed image @var{Y} which uses
 ## the smallest colormap possible @var{newmap}.
 ##
-## When the input is an indexed image (@var{X} with colormap @var{map}) the 
+## When the input is an indexed image (@var{X} with colormap @var{map}) the
 ## output is a colormap @var{newmap} from which any repeated rows have been
 ## eliminated.  The output image, @var{Y}, is the original input image with
 ## the indices adjusted to match the new, possibly smaller, colormap.
 ##
 ## When the input is an RGB image (an @nospell{MxNx3} array), the output
 ## colormap will contain one entry for every unique color in the original image.
 ## In the worst case the new map could have as many rows as the number of
 ## pixels in the original image.
@@ -87,17 +87,17 @@ function [Y, newmap] = cmunique (X, map)
         ## RGB case
         ## build a map with all values
         map = [X(:,:,1)(:), X(:,:,2)(:), X(:,:,3)(:)];
         [newmap,i,j] = unique (map, "rows");     # calculate unique colormap
         Y = reshape (j, rows (X), columns (X));  # Y is j reshaped
       otherwise
         error ("cmunique: X is not a valid image");
     endswitch
-    
+
     ## if image was uint8 or uint16 we have to convert newmap to [0,1] range
     if (isinteger (X))
       newmap = double (newmap) / double (intmax (cls));
     endif
   endif
 
   if (rows (newmap) <= 256)
     ## convert Y to uint8 and 0-based indexing
diff --git a/scripts/image/colorcube.m b/scripts/image/colorcube.m
--- a/scripts/image/colorcube.m
+++ b/scripts/image/colorcube.m
@@ -43,17 +43,17 @@ function map = colorcube (n)
 
   if (n < 9)
     map = gray (n);
     return;
   endif
 
   ## Create colorcube of evenly spaced points with side length of n^1/3
   cubelen = fix (cbrt (n));
-  reserve = n - cubelen^3; 
+  reserve = n - cubelen^3;
 
   if (reserve == 0)
     ## Steal space from blue to put the gray gradient
     [r, g, b] = meshgrid (linspace (0,1,cubelen),
                           linspace (0,1,cubelen),
                           linspace (0,1,cubelen-1));
   else
     [r, g, b] = meshgrid (linspace (0,1,cubelen),
@@ -76,17 +76,17 @@ function map = colorcube (n)
   cstepsz = 1 / csteps;
   cgrad = (cstepsz:cstepsz:1)';
   gsteps = reserve - 3*csteps;
   gstepsz = 1 / gsteps;
   ggrad = (gstepsz:gstepsz:1)';
   map = [map
          cgrad, zeros(csteps, 1), zeros(csteps, 1)
          zeros(csteps, 1), cgrad, zeros(csteps, 1)
-         zeros(csteps, 1), zeros(csteps, 1), cgrad 
+         zeros(csteps, 1), zeros(csteps, 1), cgrad
          0, 0, 0
          ggrad, ggrad, ggrad];
 
 endfunction
 
 
 %!demo
 %! ## Show the 'colorcube' colormap as an image
diff --git a/scripts/image/colormap.m b/scripts/image/colormap.m
--- a/scripts/image/colormap.m
+++ b/scripts/image/colormap.m
@@ -153,26 +153,26 @@ endfunction
 %! assert (colormap (), jet (64));
 %! colormap ("ocean");
 %! assert (colormap, ocean (64));
 %! close (hf);  # done with temp. figure
 
 %!test
 %! cmaplst = colormap ("list");
 %! assert (iscell (cmaplst));
-%! colormap ("register", "__mycmap__"); 
+%! colormap ("register", "__mycmap__");
 %! cmaplst2 = colormap ("list");
 %! assert (numel (cmaplst2), numel (cmaplst) + 1);
 %! assert (any (strcmp (cmaplst2, "__mycmap__")));
-%! colormap ("unregister", "__mycmap__"); 
+%! colormap ("unregister", "__mycmap__");
 %! cmaplst2 = colormap ("list");
 %! assert (numel (cmaplst2), numel (cmaplst));
 %! assert (! any (strcmp (cmaplst2, "__mycmap__")));
 %! ## Unregister again and verify that nothing has happened
-%! colormap ("unregister", "__mycmap__"); 
+%! colormap ("unregister", "__mycmap__");
 %! cmaplst3 = colormap ("list");
 %! assert (isequal (cmaplst2, cmaplst3));
 
 ## Test input validation
 %!error colormap (1,2,3)
 %!error <MAP must be a real-valued N x 3> colormap ({1,2,3})
 %!error <MAP must be a real-valued N x 3> colormap ([1 i 1])
 %!error <MAP must be a real-valued N x 3> colormap (ones(3,3,3))
diff --git a/scripts/image/contrast.m b/scripts/image/contrast.m
--- a/scripts/image/contrast.m
+++ b/scripts/image/contrast.m
@@ -50,15 +50,15 @@ endfunction
 %!demo
 %! figure;
 %! img = reshape (1:100, 10, 10);
 %! imagesc (img);
 %! colormap (gray (64));
 %! title ("Image with default 64 gray levels");
 %! pos = get (gcf, "position");
 %! pos(1) += pos(3) + 25;
-%! figure ("position", pos); 
+%! figure ("position", pos);
 %! colormap (contrast (img, 10));
 %! imagesc (img);
 %! title ("Image with contrast enhanced");
 
 %!assert (contrast (1:100,10), [([0:9]/9)',([0:9]/9)',([0:9]/9)'], 1e-10)
 
diff --git a/scripts/image/gray2ind.m b/scripts/image/gray2ind.m
--- a/scripts/image/gray2ind.m
+++ b/scripts/image/gray2ind.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{img} =} gray2ind (@var{I})
 ## @deftypefnx {Function File} {@var{img} =} gray2ind (@var{I}, @var{n})
 ## @deftypefnx {Function File} {@var{img} =} gray2ind (@var{BW})
 ## @deftypefnx {Function File} {@var{img} =} gray2ind (@var{BW}, @var{n})
 ## @deftypefnx {Function File} {[@var{img}, @var{map}] =} gray2ind (@dots{})
 ## Convert a grayscale or binary intensity image to an indexed image.
-## 
+##
 ## The indexed image will consist of @var{n} different intensity values.
 ## If not given @var{n} defaults to 64 for grayscale images or 2 for
 ## binary black and white images.
 ##
 ## The output @var{img} is of class uint8 if @var{n} is less than or
 ## equal to 256; Otherwise the return class is uint16.
 ## @seealso{ind2gray, rgb2ind}
 ## @end deftypefn
diff --git a/scripts/image/image.m b/scripts/image/image.m
--- a/scripts/image/image.m
+++ b/scripts/image/image.m
@@ -59,24 +59,24 @@
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function h = image (varargin)
 
   [hax, varargin, nargin] = __plt_get_axis_arg__ ("image", varargin{:});
-  
+
   chararg = find (cellfun ("isclass", varargin, "char"), 1, "first");
-  
+
   do_new = true;
   if (nargin == 0)
     img = imread ("default.img");
     x = y = [];
-  elseif (chararg == 1) 
+  elseif (chararg == 1)
     ## Low-Level syntax
     do_new = false;
     x = y = img = [];
     idx = find (strcmpi (varargin, "cdata"), 1);
     if (idx)
       img = varargin{idx+1};
       varargin(idx:idx+1) = [];
     endif
@@ -136,17 +136,17 @@ endfunction
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function h = __img__ (hax, do_new, x, y, img, varargin)
 
   ## FIXME: Hack for integer formats which use zero-based indexing
   ##        Hack favors correctness of display over size of image in memory.
-  ##        True fix must be done in C++ code for renderer. 
+  ##        True fix must be done in C++ code for renderer.
   if (ndims (img) == 2 && (isinteger (img) || islogical (img)))
     img = single (img) + 1;
   endif
 
   if (! isempty (img))
 
     if (isempty (x))
       x = [1, columns(img)];
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -40,23 +40,23 @@
 ## shown.
 ##
 ## If given, the parameter @var{string_param1} has value
 ## @var{value1}.  @var{string_param1} can be any of the following:
 ##
 ## @table @asis
 ## @item @qcode{"displayrange"}
 ## @var{value1} is the display range as described above.
-## 
+##
 ## @item @qcode{"xdata"}
 ## If @var{value1} is a two element vector, it must contain horizontal axis
 ## limits in the form [xmin xmax]; Otherwise @var{value1} must be a
 ## vector and only the first and last elements will be used for xmin and
 ## xmax respectively.
-## 
+##
 ## @item @qcode{"ydata"}
 ## If @var{value1} is a two element vector, it must contain vertical axis
 ## limits in the form [ymin ymax]; Otherwise @var{value1} must be a
 ## vector and only the first and last elements will be used for ymin and
 ## ymax respectively.
 ##
 ## @end table
 ##
diff --git a/scripts/image/ind2gray.m b/scripts/image/ind2gray.m
--- a/scripts/image/ind2gray.m
+++ b/scripts/image/ind2gray.m
@@ -42,17 +42,17 @@
 
 function I = ind2gray (x, map)
 
   if (nargin != 2)
     print_usage ();
   endif
   [x, map] = ind2x ("ind2gray", x, map);
 
-  ## Convert colormap to luminance intensity values 
+  ## Convert colormap to luminance intensity values
   map *= [0.29894; 0.58704; 0.11402];
 
   ## Convert colormap to same class as that of input so that reshape
   ## will produce output of the same type as the input.
   cls = class (x);
   if (isinteger (x))
     ## if we later add support for int16 images, this will not work. Look into
     ## im2int16 from image package for such case
diff --git a/scripts/image/jet.m b/scripts/image/jet.m
--- a/scripts/image/jet.m
+++ b/scripts/image/jet.m
@@ -55,38 +55,38 @@ function map = jet (n)
       idx1++;
     endif
     idx2 = idx1 + nel - 1;      # ~5/8*n for large n
     idx3 = min (idx2 + nel, n); # ~7/8*n for large n
 
     r = zeros (n, 1);
     r(idx1:idx2, 1) = [1:nel] / nel;
     r(idx2:idx3, 1) = 1;
-    nel2 = n - idx3; 
+    nel2 = n - idx3;
     r(idx3:(idx3+nel2), 1) = [nel:-1:(nel - nel2)] / nel;
 
     idx1 = idx1 - nel;          # ~1/8*n for large n
     idx2 = idx1 + nel - 1;      # ~3/8*n for large n
     idx3 = min (idx2 + nel, n); # ~5/8*n for large n
 
     g = zeros (n, 1);
     g(idx1:idx2, 1) = [1:nel] / nel;
     g(idx2:idx3, 1) = 1;
-    nel2 = min (nel, n - idx3); 
+    nel2 = min (nel, n - idx3);
     g(idx3:(idx3+nel2), 1) = [nel:-1:(nel - nel2)] / nel;
 
     idx1 = max (idx2 - nel, 1); # ~1/8*n for large n
     idx2 = idx2;                # ~3/8*n for large n
     idx3 = idx3;                # ~5/8*n for large n
 
     b = zeros (n, 1);
-    nel2 = min (nel, idx1-1); 
+    nel2 = min (nel, idx1-1);
     b(1:idx1, 1) = [(nel - nel2):nel] / nel;
     b(idx1:idx2, 1) = 1;
-    nel2 = min (nel, n - idx3); 
+    nel2 = min (nel, n - idx3);
     b(idx2:(idx2+nel2), 1) = [nel:-1:(nel - nel2)] / nel;
 
     map = [r, g, b];
   else
     map = zeros (0, 3);
   endif
 
 endfunction
diff --git a/scripts/image/rgb2ntsc.m b/scripts/image/rgb2ntsc.m
--- a/scripts/image/rgb2ntsc.m
+++ b/scripts/image/rgb2ntsc.m
@@ -23,19 +23,19 @@
 ## luminance-chrominance (NTSC) space.  The input may be of class uint8,
 ## uint16, single, or double.  The output is of class double.
 ##
 ## Implementation Note:
 ## The reference matrix for the transformation is
 ##
 ## @example
 ## @group
-## /Y\     0.299  0.587  0.114  /R\ 
-## |I|  =  0.596 -0.274 -0.322  |G| 
-## \Q/     0.211 -0.523  0.312  \B/ 
+## /Y\     0.299  0.587  0.114  /R\
+## |I|  =  0.596 -0.274 -0.322  |G|
+## \Q/     0.211 -0.523  0.312  \B/
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## as documented in @url{http://en.wikipedia.org/wiki/YIQ} and truncated to 3
 ## significant figures.  Note: The FCC version of NTSC uses only 2
 ## significant digits and is slightly different.
 ## @seealso{ntsc2rgb, rgb2hsv, rgb2ind}
@@ -81,17 +81,17 @@ function yiq = rgb2ntsc (rgb)
 
   ## Reference matrix for transformation from http://en.wikipedia.org/wiki/YIQ
   ## and truncated to 3 significant figures.  Matlab uses this matrix for their
   ## conversion.
   trans = [ 0.299,  0.596,  0.211;
             0.587, -0.274, -0.523;
             0.114, -0.322,  0.312 ];
 
-  ## Convert data. 
+  ## Convert data.
   yiq = rgb * trans;
 
   ## If input was an image, convert it back into one.
   if (is_image)
     yiq = reshape (yiq, sz);
   endif
 
 endfunction
diff --git a/scripts/image/spinmap.m b/scripts/image/spinmap.m
--- a/scripts/image/spinmap.m
+++ b/scripts/image/spinmap.m
@@ -34,17 +34,17 @@
 
 ## Author: Kai Habel <kai.habel at gmx.de>
 
 function spinmap (t = 5, inc = 2)
 
   if (nargin > 2)
     print_usage ();
   elseif (ischar (t))
-    if (strcmpi (t, "inf")) 
+    if (strcmpi (t, "inf"))
       t = Inf;
     else
       error ('spinmap: time T must be a real scalar or "inf"');
     endif
   elseif (! isscalar (t) || ! isreal (t))
     error ("spinmap: time T must be a real scalar");
   endif
 
diff --git a/scripts/io/importdata.m b/scripts/io/importdata.m
--- a/scripts/io/importdata.m
+++ b/scripts/io/importdata.m
@@ -24,17 +24,17 @@
 ## @deftypefnx {Function File} {[@var{A}, @var{delimiter}, @var{header_rows}] =} importdata (@dots{})
 ## Import data from the file @var{fname}.
 ##
 ## Input parameters:
 ##
 ## @itemize
 ## @item @var{fname}
 ## The name of the file containing data.
-## 
+##
 ## @item @var{delimiter}
 ## The character separating columns of data.  Use @code{\t} for tab.
 ## (Only valid for ASCII files)
 ##
 ## @item @var{header_rows}
 ## The number of header rows before the data begins.  (Only valid for ASCII
 ## files)
 ## @end itemize
@@ -95,17 +95,17 @@ function [output, delimiter, header_rows
   ## Get the extension from the file name.
   [~, ~, ext, ~] = fileparts (fname);
   ext = lower (ext);
 
   switch (ext)
     case {".au", ".snd", ".flac", ".ogg"}
       error ("importdata: not implemented for file format %s", ext);
     case {".avi", ".mj2", ".mpg", ".asf", ".asx", ".wmv", ".mp4", ".m4v", ...
-          ".mov"} 
+          ".mov"}
       error ("importdata: not implemented for file format %s", ext);
     case {".bmp", ".cur", ".gif", ".hdf", ".ico", ".jpe", ".jpeg", ".jpg", ...
           ".jp2", ".jpf", ".jpx", ".j2c", ".j2k", ".pbm", ".pcx", ".pgm", ...
           ".png", ".pnm", ".ppm", ".ras", ".tif", ".tiff", ".xwd"}
       delimiter = NaN;
       header_rows = 0;
       [output.cdata, output.colormap, output.alpha] = imread (fname);
     case ".mat"
@@ -164,17 +164,17 @@ function [output, delimiter, header_rows
 
   [fid, msg] = fopen (fname, "r");
   if (fid == -1)
     error (msg);
   endif
 
   header_rows = 0;
   header_cols = 0;
-    
+
   ## Work through first few rows line by line until a delimiter is found.
   while (ischar (row = fgetl (fid)))
 
     ## If no delimiter determined yet, make a guess.
     if (isempty (delimiter))
       ## This pattern can be fooled, but mostly does the job just fine.
       delim = regexpi (row, '[-+\d.e*ij ]+([^-+\de.ij])[-+\de*.ij ]',
                       'tokens', 'once');
@@ -240,17 +240,17 @@ function [output, delimiter, header_rows
     na_rows = find (any (na_idx, 2));
     for ridx = na_rows(:)'
       row = file_content{ridx+header_rows};
       if (delimiter == " ")
         fields = regexp (strtrim (row), ' +', 'split');
       else
         fields = ostrsplit (row, delimiter);
       endif
-      
+
       text = fields(na_idx(ridx,:));
       text = text(! strcmpi (text, "NA"));  #  Remove valid "NA" entries
       if (! isempty (text))
         output.textdata(end+1:end+numel (text), 1) = text;
       endif
       if (header_cols)
         output.rowheaders(end+1, :) = fields(1:header_cols);
       endif
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -156,33 +156,33 @@
 ##
 ## When the number of words in @var{str} doesn't match an exact multiple
 ## of the number of format conversion specifiers, strread's behavior
 ## depends on the last character of @var{str}:
 ##
 ## @table @asis
 ## @item last character = @qcode{"\n"}
 ## Data columns are padded with empty fields or Nan so that all columns
-## have equal length 
+## have equal length
 ##
 ## @item last character is not @qcode{"\n"}
 ## Data columns are not padded; strread returns columns of unequal length
 ##
 ## @end table
 ##
 ## @seealso{textscan, textread, load, dlmread, fscanf}
 ## @end deftypefn
 
 function varargout = strread (str, format = "%f", varargin)
 
   ## Check input
   if (nargin < 1)
     print_usage ();
   endif
-  
+
   if (isempty (str))
     ## Return empty args (no match), rather than raising an error
     varargout = cell (1, nargout);
     return;
   endif
 
   if (isempty (format))
     format = "%f";
@@ -297,17 +297,17 @@ function varargout = strread (str, forma
     ## Default format specified.  Expand it (to desired nargout)
     fmt_words = cell (max (nargout, 1), 1);
     fmt_words (1:max (nargout, 1)) = format;
   else
     ## Determine the number of words per line as a first guess.  Forms
     ## like %f<literal>) (w/o delimiter in between) are fixed further on
     format = strrep (format, "%", " %");
     fmt_words = regexp (format, '[^ ]+', "match");
-    
+
     ## Find position of conversion specifiers (they start with %)
     idy2 = find (! cellfun ("isempty", regexp (fmt_words, '^%')));
 
     ## Check for unsupported format specifiers
     errpat = '(\[.*\]|[cq]|[nfdu]8|[nfdu]16|[nfdu]32|[nfdu]64)';
     if (! all (cellfun ("isempty", regexp (fmt_words(idy2), errpat))))
       error ("strread: %q, %c, %[] or bit width format specifiers are not supported yet.");
     endif
diff --git a/scripts/io/textread.m b/scripts/io/textread.m
--- a/scripts/io/textread.m
+++ b/scripts/io/textread.m
@@ -128,17 +128,17 @@ function varargout = textread (filename,
       eol_char = "\r";
     ## Otherwise, use plain *nix (LF)
     else
       eol_char = "\n";
     endif
     ## Set up default endofline param value
     varargin(end+1:end+2) = {"endofline", eol_char};
   endif
- 
+
   ## Now that we know what EOL looks like, we can process format_repeat_count.
   ## FIXME The below isn't ML-compatible: counts lines, not format string uses
   if (isfinite (nlines) && (nlines > 0))
     l_eol_char = length (eol_char);
     eoi = findstr (str, eol_char);
     n_eoi = length (eoi);
     nblks = 0;
     ## Avoid slow repeated str concatenation, first seek requested end of data
@@ -165,29 +165,29 @@ function varargout = textread (filename,
     endif
     fseek (fid, st_pos, "bof");
     str = fscanf (fid, "%c", eoi_pos);
   else
     fseek (fid, st_pos, "bof");
     str = fread (fid, "char=>char").';
   endif
   fclose (fid);
- 
+
   ## Set up default whitespace param value if needed
   if (isempty (find (strcmpi ("whitespace", varargin))))
     varargin(end+1:end+2) = {"whitespace", " \b\t"};
   endif
 
   ## Call strread to make it do the real work
   [varargout{1:max (nargout, 1)}] = strread (str, format, varargin {:});
 
   ## Hack to concatenate/reshape numeric output into 2D array (undocumented ML)
   ## In ML this only works in case of an empty format string
   if (isempty (format))
-    ## Get number of fields per line. 
+    ## Get number of fields per line.
     ## 1. Get eol_char position
     iwhsp = find (strcmpi ("whitespace", varargin));
     whsp = varargin{iwhsp + 1};
     idx = regexp (str, eol_char, "once");
     ## 2. Get first data line til EOL. Avoid corner case of just one line
     if (! isempty (idx))
       str = str(1:idx-1);
     endif
diff --git a/scripts/io/textscan.m b/scripts/io/textscan.m
--- a/scripts/io/textscan.m
+++ b/scripts/io/textscan.m
@@ -199,17 +199,17 @@ function [C, position] = textscan (fid, 
       if (args{headerlines + 1} > 0)
         ## Beware of zero valued headerline, fskipl would skip to EOF
         fskipl (fid, args{headerlines + 1});
         args(headerlines:headerlines+1) = [];
         st_pos = ftell (fid);
       elseif (args{headerlines + 1} < 0)
         warning ("textscan.m: negative headerline value ignored");
       endif
-    endif    
+    endif
     ## Read a first file chunk. Rest follows after endofline processing
     [str, count] = fscanf (fid, "%c", BUFLENGTH);
 
   endif
 
   ## Check for empty result
   if (isempty (str))
     warning ("textscan: no data read");
@@ -312,33 +312,33 @@ function [C, position] = textscan (fid, 
     eoi = index (str, eol_char);
     if (eoi)
       ## str contains an EOL, proceed with assessing nr. of columns
       ncols = countcols (C, str(1 : eoi-1), delimiter, whitespace);
       ## See if lowermost data row must be completed
       pad = mod (numel (C{1}), ncols);
       if (pad)
         ## Textscan returns NaNs for empty fields
-        C(1) = [C{1}; NaN(ncols - pad, 1)]; 
+        C(1) = [C{1}; NaN(ncols - pad, 1)];
       endif
       ## Replace NaNs with EmptyValue, if any
       ipos = find (strcmpi (args, "emptyvalue"));
       if (ipos)
         C{1}(find (isnan (C{1}))) = args{ipos+1};
       endif
       ## Compute nr. of rows
       nrows = floor (numel (C{1}) / ncols);
       ## Reshape C; watch out, transpose needed
       C(1) = reshape (C{1}, ncols, numel (C{1}) / ncols)';
       ## Distribute columns over C and wipe cols 2:end of C{1}
       for ii=2:ncols
         C(ii) = C{1}(:, ii);
       endfor
       C{1} = C{1}(:, 1);
-    endif 
+    endif
   endif
 
   ## If requested, collect output columns of same class
   if (collop)
     C = colloutp (C);
   endif
 
   if (nargout == 2)
diff --git a/scripts/java/java_get.m b/scripts/java/java_get.m
--- a/scripts/java/java_get.m
+++ b/scripts/java/java_get.m
@@ -16,28 +16,28 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{val} =} java_get (@var{obj}, @var{name})
 ## Get the value of the field @var{name} of the Java object @var{obj}.  For
 ## static fields, @var{obj} can be a string representing the fully qualified
 ## name of the corresponding class.
-## 
+##
 ## When @var{obj} is a regular Java object, structure-like indexing can be
 ## used as a shortcut syntax.  For instance, the two following statements are
 ## equivalent
-## 
+##
 ## @example
 ## @group
 ##   java_get (x, "field1")
 ##   x.field1
 ## @end group
 ## @end example
-## 
+##
 ## @seealso{java_set, javaMethod, javaObject}
 ## @end deftypefn
 
 function retval = java_get (obj, name)
 
   if (nargin != 2)
     print_usage ();
   endif
diff --git a/scripts/java/java_set.m b/scripts/java/java_set.m
--- a/scripts/java/java_set.m
+++ b/scripts/java/java_set.m
@@ -16,28 +16,28 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{obj} =} java_set (@var{obj}, @var{name}, @var{val})
 ## Set the value of the field @var{name} of the Java object @var{obj} to
 ## @var{val}.  For static fields, @var{obj} can be a string representing the
 ## fully qualified named of the corresponding Java class.
-## 
+##
 ## When @var{obj} is a regular Java object, structure-like indexing can be
 ## used as a shortcut syntax.  For instance, the two following statements are
 ## equivalent
-## 
+##
 ## @example
 ## @group
 ##   java_set (x, "field1", val)
 ##   x.field1 = val
 ## @end group
 ## @end example
-## 
+##
 ## @seealso{java_get, javaMethod, javaObject}
 ## @end deftypefn
 
 function retval = java_set (obj, name, val)
 
   if (nargin != 3)
     print_usage ();
   endif
diff --git a/scripts/java/javaaddpath.m b/scripts/java/javaaddpath.m
--- a/scripts/java/javaaddpath.m
+++ b/scripts/java/javaaddpath.m
@@ -48,12 +48,12 @@ function javaaddpath (varargin)
       error ("javaaddpath: CLSPATH does not exist: %s", clspath);
     endif
 
     success = javaMethod ("addClassPath", "org.octave.ClassHelper", new_path);
 
     if (! success)
       warning ("javaaddpath: failed to add '%s' to Java classpath", new_path);
     endif
-  endfor 
-   
+  endfor
+
 endfunction
 
diff --git a/scripts/java/javaclasspath.m b/scripts/java/javaclasspath.m
--- a/scripts/java/javaclasspath.m
+++ b/scripts/java/javaclasspath.m
@@ -18,32 +18,32 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} javaclasspath ()
 ## @deftypefnx {Function File} {@var{dpath} =} javaclasspath ()
 ## @deftypefnx {Function File} {[@var{dpath}, @var{spath}] =} javaclasspath ()
 ## @deftypefnx {Function File} {@var{clspath} =} javaclasspath (@var{what})
 ## Return the class path of the Java virtual machine in the form of a cell
-## array of strings. 
+## array of strings.
 ##
 ## If called with no inputs:
 ##
 ## @itemize
-## @item If no output is requested, the dynamic and static classpaths are printed 
+## @item If no output is requested, the dynamic and static classpaths are printed
 ## to the standard output.
 ##
 ## @item If one output value @var{dpath} is requested, the result is
 ## the dynamic classpath.
 ##
-## @item If two output values@var{dpath} and @var{spath} are 
+## @item If two output values@var{dpath} and @var{spath} are
 ## requested, the first variable will contain the dynamic classpath and
 ## the second will be contain the static classpath.
 ## @end itemize
-## 
+##
 ## If called with a single input parameter @var{what}:
 ##
 ## @table @asis
 ## @item @qcode{"-dynamic"}
 ## Return the dynamic classpath.
 ##
 ## @item @qcode{"-static"}
 ## Return the static classpath.
@@ -80,17 +80,17 @@ function varargout = javaclasspath (whic
 
         case 1
           varargout{1} = cellstr (dynamic_path_list);
 
         case 2
           varargout{1} = cellstr (dynamic_path_list);
           varargout{2} = cellstr (static_path_list);
       endswitch
-        
+
     case 1
       switch (nargout)
         case 0
           if (strcmp (which, "-static"))
             disp_path_list ("STATIC", static_path_list)
           elseif (strcmp (which, "-dynamic"))
             disp_path_list ("DYNAMIC", dynamic_path_list)
           elseif (strcmp (which, "-all") == 1)
@@ -104,17 +104,17 @@ function varargout = javaclasspath (whic
             varargout{1} = cellstr (static_path_list);
           elseif (strcmp (which, "-dynamic") == 1)
             varargout{1} = cellstr (dynamic_path_list);
           elseif (strcmp (which, "-all") == 1)
             varargout{1} = cellstr ([static_path_list, dynamic_path_list]);
           endif
       endswitch
   endswitch
-  
+
 endfunction
 
 ## Display cell array of paths
 
 function disp_path_list (which, path_list)
   printf ("   %s JAVA PATH\n\n", which);
   if (numel (path_list) > 0)
     printf ("      %s\n", path_list{:});
diff --git a/scripts/java/javamem.m b/scripts/java/javamem.m
--- a/scripts/java/javamem.m
+++ b/scripts/java/javamem.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 2010, 2013 Philip Nienhuis
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
@@ -56,17 +56,17 @@
 ## "Free memory" is self-explanatory.  During operation of Java-based
 ## Octave functions the amount of Total and Free memory will vary,
 ## due to Java's own cleaning up and your operating system's memory
 ## management.
 ## @end deftypefn
 
 ## Author: Philip Nienhuis
 ## Created: 2010-03-25
-## Updates: 
+## Updates:
 ## 2010-03-26 Changed name to javamem & indentation to double spaces
 ## 2010-08-25 Corrected text on java memory assignments
 ## 2010-09-05 Further overhauled help text
 
 function jmem = javamem ()
 
   rt = javaMethod ("getRuntime", "java.lang.Runtime");
   rt.gc;
diff --git a/scripts/linear-algebra/linsolve.m b/scripts/linear-algebra/linsolve.m
--- a/scripts/linear-algebra/linsolve.m
+++ b/scripts/linear-algebra/linsolve.m
@@ -86,31 +86,31 @@ function [x, R] = linsolve (A, b, opts)
     endif
     trans_A = false;
     if (isfield (opts, "TRANSA") && opts.TRANSA)
       trans_A = true;
       A = A';
     endif
     if (isfield (opts, "POSDEF") && opts.POSDEF)
       A = matrix_type (A, "positive definite");
-    endif  
+    endif
     if (isfield (opts, "LT") && opts.LT)
       if (trans_A)
         A = matrix_type (A, "upper");
       else
         A = matrix_type (A, "lower");
       endif
     endif
     if (isfield (opts, "UT") && opts.UT)
       if (trans_A)
         A = matrix_type (A, "lower");
       else
         A = matrix_type (A, "upper");
       endif
-    endif        
+    endif
   endif
 
   x = A \ b;
 
   if (nargout > 1)
     if (issquare (A))
       R = rcond (A);
     else
diff --git a/scripts/linear-algebra/qzhess.m b/scripts/linear-algebra/qzhess.m
--- a/scripts/linear-algebra/qzhess.m
+++ b/scripts/linear-algebra/qzhess.m
@@ -34,17 +34,17 @@
 ## @end group
 ## @end example
 ##
 ## The Hessenberg-triangular decomposition is the first step in
 ## Moler and Stewart's QZ@tie{}decomposition algorithm.
 ##
 ## Algorithm taken from Golub and Van Loan,
 ## @cite{Matrix Computations, 2nd edition}.
-## 
+##
 ## @seealso{lu, chol, hess, qr, qz, schur, svd}
 ## @end deftypefn
 
 ## Author: A. S. Hodel <scotte@eng.auburn.edu>
 ## Created: August 1993
 ## Adapted-By: jwe
 
 function [aa, bb, q, z] = qzhess (A, B)
diff --git a/scripts/miscellaneous/debug.m b/scripts/miscellaneous/debug.m
--- a/scripts/miscellaneous/debug.m
+++ b/scripts/miscellaneous/debug.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} debug ()
 ## Summary of debugging commands.  For more information on each command
 ## and available options use @code{help CMD}.
-## 
+##
 ## The debugging commands available in Octave are
 ##
 ## @table @code
 ## @item dbstop
 ## Add a breakpoint.
 ##
 ## @item dbclear
 ## Remove a breakpoint.
diff --git a/scripts/miscellaneous/desktop.m b/scripts/miscellaneous/desktop.m
--- a/scripts/miscellaneous/desktop.m
+++ b/scripts/miscellaneous/desktop.m
@@ -28,17 +28,17 @@ function retval = desktop (arg)
     if (isguirunning ())
       return;  # desktop() is a NOP when GUI running
     else
       print_usage ();
     endif
   elseif (nargin > 1)
     error ('desktop: only one argument, "-inuse", is allowed');
   endif
-  
+
   switch (tolower (arg))
     case "-inuse"
       retval = isguirunning ();
     otherwise
       print_usage ();
   endswitch
 
 endfunction
diff --git a/scripts/miscellaneous/dir.m b/scripts/miscellaneous/dir.m
--- a/scripts/miscellaneous/dir.m
+++ b/scripts/miscellaneous/dir.m
@@ -23,26 +23,26 @@
 ## Display file listing for directory @var{directory}.
 ##
 ## If @var{directory} is not specified then list the present working directory.
 ##
 ## If a return value is requested, return a structure array with the fields
 ##
 ## @table @asis
 ## @item name
-## File or directory name. 
+## File or directory name.
 ##
 ## @item date
 ## Timestamp of file modification (string value).
 ##
 ## @item bytes
 ## File size in bytes.
 ##
 ## @item isdir
-## True if name is a directory. 
+## True if name is a directory.
 ##
 ## @item datenum
 ## Timestamp of file modification as serial date number (double).
 ##
 ## @item statinfo
 ## Information structure returned from @code{stat}.
 ## @end table
 ##
diff --git a/scripts/miscellaneous/dos.m b/scripts/miscellaneous/dos.m
--- a/scripts/miscellaneous/dos.m
+++ b/scripts/miscellaneous/dos.m
@@ -48,17 +48,17 @@ endfunction
 
 %!test
 %! cmd = ls_command ();
 %! old_wstate = warning ("query");
 %! warning ("off", "Octave:undefined-return-values");
 %! unwind_protect
 %!   [status, output] = dos (cmd);
 %! unwind_protect_cleanup
-%!   warning (old_wstate); 
+%!   warning (old_wstate);
 %! end_unwind_protect
 %!
 %! if (ispc () && ! isunix ())
 %!   [status, output] = dos (cmd);
 %!   assert (status, 0);
 %!   assert (ischar (output));
 %!   assert (! isempty (output));
 %! else
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -136,17 +136,17 @@ function ret = edit (varargin)
 
   ## Get default editor every time in case the user has changed it
   FUNCTION.EDITOR = [EDITOR() " %s"];
 
   if (nargin == 1)
     ## User has supplied one arg, this can be a single file name
     ## or a cell array of strings containing multiple files to be opened
     if (iscellstr (varargin{1}))
-      ## If first arg is a cell array of strings, 
+      ## If first arg is a cell array of strings,
       ## it becomes the list of files to be edited
       editfilelist = varargin{1};
     elseif (ischar (varargin{1}))
       ## If first arg is a string, create a cell array of strings
       ## of length 1 (by copying the input cell array)
       editfilelist = varargin(1);
     else
       error ("edit: expected file to be a string or cell array of strings");
@@ -235,17 +235,17 @@ function ret = edit (varargin)
   if (numel (editfilelist) > 1)
 
     ## Call edit on each of the files in the list if there are more than 1
     for i = 1:numel (editfilelist)
       edit (editfilelist{i});
     endfor
 
   else
-  
+
     ## Only one file name was supplied, get it from the cell array
     file = tilde_expand (editfilelist{1});
 
     ## Check whether the user is trying to edit a builtin or compiled function.
     switch (exist (file))
       case {3, 5}
         error ("edit: unable to edit a built-in or compiled function");
     endswitch
@@ -497,17 +497,17 @@ SUCH DAMAGE.\
     fid = fopen (fileandpath, "wt");
     if (fid < 0)
       error ("edit: could not create %s", fileandpath);
     endif
     fputs (fid, text);
     fclose (fid);
 
     do_edit (FUNCTION.EDITOR, fileandpath, FUNCTION.MODE);
-            
+
   endif
 
 endfunction
 
 function retval = default_home ()
 
   retval = getenv ("HOME");
   if (isempty (retval))
diff --git a/scripts/miscellaneous/fact.m b/scripts/miscellaneous/fact.m
--- a/scripts/miscellaneous/fact.m
+++ b/scripts/miscellaneous/fact.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2013 Jordi Gutirrez Hermoso 
+## Copyright (C) 2007-2013 Jordi Gutirrez Hermoso
 ## Copyright (C) 2007 Stallmanfacts.com
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/miscellaneous/getappdata.m b/scripts/miscellaneous/getappdata.m
--- a/scripts/miscellaneous/getappdata.m
+++ b/scripts/miscellaneous/getappdata.m
@@ -14,20 +14,20 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{value} =} getappdata (@var{h}, @var{name})
 ## @deftypefnx {Function File} {@var{appdata} =} getappdata (@var{h})
-## 
+##
 ## Return the @var{value} for named application data for the object(s) with
 ## handle(s) @var{h}.
-## 
+##
 ## @code{getappdata(@var{h})} returns a structure, @var{appdata}, whose fields
 ## correspond to the appdata properties.
 ##
 ## @seealso{setappdata, guidata, get, set, getpref, setpref}
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: 2010-07-15
diff --git a/scripts/miscellaneous/inputname.m b/scripts/miscellaneous/inputname.m
--- a/scripts/miscellaneous/inputname.m
+++ b/scripts/miscellaneous/inputname.m
@@ -47,13 +47,13 @@ endfunction
 ## them.  It does this using the following template:
 ##
 ##     function [<shared>] = testfn(<shared>)
 ##        <test>
 ##
 ## To test inputname, I need a function context invoked
 ## with known parameter names.  So define a couple of
 ## shared parameters, et voila!, the test is trivial.
-  
+
 %!shared hello, worldly
 %!assert (inputname (1), "hello")
 %!assert (inputname (2), "worldly")
 
diff --git a/scripts/miscellaneous/license.m b/scripts/miscellaneous/license.m
--- a/scripts/miscellaneous/license.m
+++ b/scripts/miscellaneous/license.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} license
 ## @deftypefnx {Function File} {} license ("inuse")
 ## @deftypefnx {Function File} {@var{retval} =} license ("inuse")
 ## @deftypefnx {Function File} {@var{retval} =} license ("test", @var{feature})
 ## @deftypefnx {Function File} {} license ("test", @var{feature}, @var{toggle})
 ## @deftypefnx {Function File} {@var{retval} =} license ("checkout", @var{feature})
-## 
+##
 ## Display the license of Octave.
 ##
 ## @code{license ("inuse")}
 ##
 ## Display a list of packages currently being used.
 ##
 ## @code{@var{retval} = license ("inuse")}
 ##
@@ -84,17 +84,17 @@ function retval = license (varargin)
   nout = nargout;
   nin = nargin;
   nr_licenses = rows (__octave_licenses__);
 
   if (nout > 1 || nin > 3)
     print_usage ();
   endif
 
-  if (nin == 0)  
+  if (nin == 0)
 
     found = find (strcmp (__octave_licenses__(:,1), "Octave"), 1);
 
     if (! isempty (found))
       result = __octave_licenses__{found,2};
     else
       result = "unknown";
     endif
diff --git a/scripts/miscellaneous/ls_command.m b/scripts/miscellaneous/ls_command.m
--- a/scripts/miscellaneous/ls_command.m
+++ b/scripts/miscellaneous/ls_command.m
@@ -55,13 +55,13 @@ function old_cmd = ls_command (cmd)
 
 endfunction
 
 
 %!test
 %! cmd = ls_command ();
 %! assert (ischar (cmd));
 %! if (ispc () && ! isunix ())
-%!   assert (cmd(1:3), "dir"); 
+%!   assert (cmd(1:3), "dir");
 %! else
-%!   assert (cmd(1:2), "ls"); 
+%!   assert (cmd(1:2), "ls");
 %! endif
 
diff --git a/scripts/miscellaneous/run.m b/scripts/miscellaneous/run.m
--- a/scripts/miscellaneous/run.m
+++ b/scripts/miscellaneous/run.m
@@ -28,17 +28,17 @@
 ## The file name @var{script} can be a bare, fully qualified, or relative
 ## filename and with or without a file extension.  If no extension is specified,
 ## Octave will first search for a script with the @file{".m"} extension before
 ## falling back to the script name without an extension.
 ##
 ## Implementation Note: If @var{script} includes a path component, then
 ## @code{run} first changes the directory to the directory where @var{script}
 ## is found.  @code{run} then executes the script, and returns to the original
-## directory. 
+## directory.
 ## @seealso{path, addpath, source}
 ## @end deftypefn
 
 function run (script)
 
   if (nargin != 1)
     print_usage ();
   endif
@@ -47,21 +47,21 @@ function run (script)
   if (! strcmp (ext, ".m"))
     ## prefer files with .m extension for compatibility with Matlab
     if (exist ([script ".m"], "file"))
       f = [f ext];
       ext = ".m";
       script = [script ".m"];
     endif
   endif
-  
+
   if (! exist (script, "file"))
     error ("run: file SCRIPT must exist and be a valid Octave scriptfile");
   endif
-  
+
   if (! isempty (d))
     if (exist (d, "dir"))
       wd = pwd ();
       unwind_protect
         cd (d);
         evalin ("caller", sprintf ('source ("%s%s");', f, ext),
                 "rethrow (lasterror ())");
       unwind_protect_cleanup
diff --git a/scripts/miscellaneous/setfield.m b/scripts/miscellaneous/setfield.m
--- a/scripts/miscellaneous/setfield.m
+++ b/scripts/miscellaneous/setfield.m
@@ -16,17 +16,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{s} =} setfield (@var{s}, @var{field}, @var{val})
 ## @deftypefnx {Function File} {@var{s} =} setfield (@var{s}, @var{idx1}, @var{field1}, @var{idx2}, @var{field2}, @dots{}, @var{val})
 ##
-## Set a field member @var{field} in a structure @var{s} equal to @var{val}. 
+## Set a field member @var{field} in a structure @var{s} equal to @var{val}.
 ## For example:
 ##
 ## @example
 ## @group
 ## @var{s} = struct ();
 ## @var{s} = setfield (@var{s}, "foo bar", 42);
 ## @end group
 ## @end example
diff --git a/scripts/miscellaneous/unix.m b/scripts/miscellaneous/unix.m
--- a/scripts/miscellaneous/unix.m
+++ b/scripts/miscellaneous/unix.m
@@ -48,17 +48,17 @@ endfunction
 
 %!test
 %! cmd = ls_command ();
 %! old_wstate = warning ("query");
 %! warning ("off", "Octave:undefined-return-values");
 %! unwind_protect
 %!   [status, output] = unix (cmd);
 %! unwind_protect_cleanup
-%!   warning (old_wstate); 
+%!   warning (old_wstate);
 %! end_unwind_protect
 %!
 %! if (isunix ())
 %!   assert (status, 0);
 %!   assert (ischar (output));
 %!   assert (! isempty (output));
 %! else
 %!   assert (status, []);
diff --git a/scripts/miscellaneous/ver.m b/scripts/miscellaneous/ver.m
--- a/scripts/miscellaneous/ver.m
+++ b/scripts/miscellaneous/ver.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ver ()
 ## @deftypefnx {Function File} {v =} ver ()
 ## @deftypefnx {Function File} {v =} ver ("Octave")
 ## @deftypefnx {Function File} {v =} ver (@var{package})
-## 
+##
 ## Display a header containing the current Octave version number, license
 ## string, and operating system followed by a list of installed packages,
 ## versions, and installation directories.
 ##
 ## @code{v = ver ()}
 ##
 ## Return a vector of structures describing Octave and each installed package.
 ## The structure includes the following fields.
diff --git a/scripts/mk-pkg-add b/scripts/mk-pkg-add
--- a/scripts/mk-pkg-add
+++ b/scripts/mk-pkg-add
@@ -1,24 +1,24 @@
 #! /bin/sh
 #
 # Copyright (C) 2002-2013 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 ## Expecting arguments in this order:
 ##
 ##  SRCDIR SRCDIR-FILES ... -- LOCAL-FILES ...
 
diff --git a/scripts/mkdoc.pl b/scripts/mkdoc.pl
--- a/scripts/mkdoc.pl
+++ b/scripts/mkdoc.pl
@@ -65,17 +65,17 @@ MFILE: foreach $m_fname (@ARGV)
   }
 }
 
 ################################################################################
 # Subroutines
 ################################################################################
 sub gethelp
 {
-  ($fcn, $fname) = @_[0..1]; 
+  ($fcn, $fname) = @_[0..1];
   open (FH, $fname) or return "";
 
   do
   {
     @help_txt = ();
 
     ## Advance to non-blank line
     while (defined ($_ = <FH>) and /^\s*$/) {;}
@@ -90,14 +90,14 @@ sub gethelp
     ## Extract help text stopping when comment block ends
     do
     {
       ## Remove comment characters at start of line
       s/^\s*(?:#|%){1,2} ?//;
       push (@help_txt, $_);
     } until (! defined ($_ = <FH>) or ! /^\s*(?:#|%)/);
 
-  } until ($help_txt[0] !~ /^(?:Copyright|Author)/); 
+  } until ($help_txt[0] !~ /^(?:Copyright|Author)/);
 
   close (FH);
 
   return @help_txt;
 }
diff --git a/scripts/optimization/fminsearch.m b/scripts/optimization/fminsearch.m
--- a/scripts/optimization/fminsearch.m
+++ b/scripts/optimization/fminsearch.m
@@ -23,17 +23,17 @@
 ## @deftypefnx {Function File} {[@var{x}, @var{fval}] =} fminsearch (@dots{})
 ##
 ## Find a value of @var{x} which minimizes the function @var{fun}.
 ## The search begins at the point @var{x0} and iterates using the
 ## Nelder & Mead Simplex algorithm (a derivative-free method).  This algorithm
 ## is better-suited to functions which have discontinuities or for which
 ## a gradient-based search such as @code{fminunc} fails.
 ##
-## Options for the search are provided in the parameter @var{options} using 
+## Options for the search are provided in the parameter @var{options} using
 ## the function @code{optimset}.  Currently, @code{fminsearch} accepts the
 ## options: @qcode{"TolX"}, @qcode{"MaxFunEvals"}, @qcode{"MaxIter"},
 ## @qcode{"Display"}.  For a description of these options, see
 ## @code{optimset}.
 ##
 ## On exit, the function returns @var{x}, the minimum point,
 ## and @var{fval}, the function value thereof.
 ##
diff --git a/scripts/optimization/optimset.m b/scripts/optimization/optimset.m
--- a/scripts/optimization/optimset.m
+++ b/scripts/optimization/optimset.m
@@ -51,17 +51,17 @@
 ##
 ## @item FinDiffType
 ##
 ## @item FunValCheck
 ## When enabled, display an error if the objective function returns an invalid
 ## value (a complex number, NaN, or Inf).  Must be set to @qcode{"on"} or
 ## @qcode{"off"} [default].  Note: the functions @code{fzero} and
 ## @code{fminbnd} correctly handle Inf values and only complex values or NaN
-## will cause an error in this case. 
+## will cause an error in this case.
 ##
 ## @item GradObj
 ## When set to @qcode{"on"}, the function to be minimized must return a
 ## second argument which is the gradient, or first derivative, of the
 ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
 ## gradient is computed via finite differences.
 ##
 ## @item Jacobian
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -405,17 +405,17 @@ function [x, obj, info, iter, nf, lambda
 
     [p, obj_qp, INFO, lambda] = qp (x, B, c, F, g, [], [], d, C,
                                     Inf (size (d)));
 
     info = INFO.info;
 
     ## FIXME -- check QP solution and attempt to recover if it has
     ## failed.  For now, just warn about possible problems.
-    
+
     id = "Octave:SQP-QP-subproblem";
     switch (info)
       case 2
         warning (id, "sqp: QP subproblem is non-convex and unbounded");
       case 3
         warning (id, "sqp: QP subproblem failed to converge in %d iterations",
                  INFO.solveiter);
       case 6
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -133,17 +133,17 @@
 ## installed packages into those which were installed by the current user,
 ## and those which were installed by the system administrator.
 ##
 ## @example
 ## [user_packages, system_packages] = pkg ("list")
 ## @end example
 ##
 ## The option @qcode{"-forge"} lists packages available at the Octave-Forge
-## repository.  This requires an internet connection and the cURL library. 
+## repository.  This requires an internet connection and the cURL library.
 ## For example:
 ##
 ## @example
 ## oct_forge_pkgs = pkg ("list", "-forge")
 ## @end example
 ##
 ## @item describe
 ## Show a short description of the named installed packages, with the option
@@ -444,25 +444,25 @@ function [local_packages, global_package
             endif
             warning ("creating the directory %s\n", archprefix);
             global_packages = archprefix = canonicalize_file_name (archprefix);
           endif
         endif
       else
         error ("you must specify a prefix directory, or request an output argument");
       endif
-      
+
     case "local_list"
       if (length (files) == 0 && nargout == 0)
         disp (local_list);
       elseif (length (files) == 0 && nargout == 1)
         local_packages = local_list;
       elseif (length (files) == 1 && nargout == 0 && ischar (files{1}))
         local_list = files{1};
-        if (! exist (local_list, "file"))          
+        if (! exist (local_list, "file"))
           try
             ## Force file to be created
             fclose (fopen (local_list, "wt"));
           catch
             error ("cannot create file %s", local_list);
           end_try_catch
         endif
         local_list = canonicalize_file_name (local_list);
@@ -472,17 +472,17 @@ function [local_packages, global_package
 
     case "global_list"
       if (length (files) == 0 && nargout == 0)
         disp(global_list);
       elseif (length (files) == 0 && nargout == 1)
         local_packages = global_list;
       elseif (length (files) == 1 && nargout == 0 && ischar (files{1}))
         global_list = files{1};
-        if (! exist (global_list, "file"))  
+        if (! exist (global_list, "file"))
           try
             ## Force file to be created
             fclose (fopen (files{1}, "wt"));
           catch
             error ("cannot create file %s", global_list);
           end_try_catch
         endif
         global_list = canonicalize_file_name (global_list);
diff --git a/scripts/pkg/private/create_pkgadddel.m b/scripts/pkg/private/create_pkgadddel.m
--- a/scripts/pkg/private/create_pkgadddel.m
+++ b/scripts/pkg/private/create_pkgadddel.m
@@ -24,17 +24,17 @@
 
 function create_pkgadddel (desc, packdir, nm, global_install)
   instpkg = fullfile (desc.dir, nm);
   instfid = fopen (instpkg, "wt");
   ## If it is exists, most of the  PKG_* file should go into the
   ## architecture dependent directory so that the autoload/mfilename
   ## commands work as expected. The only part that doesn't is the
   ## part in the main directory.
-  archdir = fullfile (getarchprefix (desc, global_install), 
+  archdir = fullfile (getarchprefix (desc, global_install),
                       [desc.name "-" desc.version], getarch ());
   if (exist (getarchdir (desc, global_install), "dir"))
     archpkg = fullfile (getarchdir (desc, global_install), nm);
     archfid = fopen (archpkg, "at");
   else
     archpkg = instpkg;
     archfid = instfid;
   endif
diff --git a/scripts/pkg/private/fix_depends.m b/scripts/pkg/private/fix_depends.m
--- a/scripts/pkg/private/fix_depends.m
+++ b/scripts/pkg/private/fix_depends.m
@@ -30,17 +30,17 @@ function deps_cell = fix_depends (depend
   deps_cell = cell (1, length (deps));
   dep_pat = ...
   '\s*(?<name>[-\w]+)\s*(\(\s*(?<op>[<>=]+)\s*(?<ver>\d+\.\d+(\.\d+)*)\s*\))*\s*';
 
   ## For each dependency.
   for i = 1:length (deps)
     dep = deps{i};
     [start, nm] = regexp (dep, dep_pat, 'start', 'names');
-    ## Is the dependency specified 
+    ## Is the dependency specified
     ## in the correct format?
     if (! isempty (start))
       package = tolower (strtrim (nm.name));
       ## Does the dependency specify a version
       ## Example: package(>= version).
       if (! isempty (nm.ver))
         operator = nm.op;
         if (! any (strcmp (operator, {">", ">=", "<=", "<", "=="})))
@@ -50,17 +50,17 @@ function deps_cell = fix_depends (depend
         ## If no version is specified for the dependency
         ## we say that the version should be greater than
         ## or equal to "0.0.0".
       else
         package = tolower (strtrim (dep));
         operator = ">=";
         version  = "0.0.0";
       endif
-      deps_cell{i} = struct ("package", package, 
+      deps_cell{i} = struct ("package", package,
                              "operator", operator,
                              "version", version);
     else
       error ("incorrect syntax for dependency '%s' in the DESCRIPTION file\n",
              dep);
     endif
   endfor
 endfunction
diff --git a/scripts/pkg/private/install.m b/scripts/pkg/private/install.m
--- a/scripts/pkg/private/install.m
+++ b/scripts/pkg/private/install.m
@@ -257,17 +257,17 @@ function install (files, handle_deps, au
   ## requested that it is, then mark the package as autoloaded.
   str_true = {"true", "on", "yes", "1"};
   for i = length (descriptions):-1:1
 
     desc_autoload = false;
     if (isfield (descriptions{i}, "autoload"))
       a = descriptions{i}.autoload;
       desc_autoload = ((isnumeric (a) && a > 0)
-                       || (ischar (a) 
+                       || (ischar (a)
                            && any (strcmpi (a, str_true))));
     endif
 
     if (autoload > 0 || (autoload == 0 && desc_autoload))
       fclose (fopen (fullfile (descriptions{i}.dir, "packinfo",
                                ".autoload"), "wt"));
       descriptions{i}.autoload = 1;
     else
diff --git a/scripts/plot/appearance/axis.m b/scripts/plot/appearance/axis.m
--- a/scripts/plot/appearance/axis.m
+++ b/scripts/plot/appearance/axis.m
@@ -195,17 +195,17 @@ function limits = __axis__ (ca, ax, vara
         ## FIXME - gnuplot applies the aspect ratio activepostionproperty.
         set (ca, "activepositionproperty", "position");
         ## The following line is a trick used to trigger the recalculation of
         ## aspect related magnitudes even if the aspect ratio is the same
         ## (useful with the x11 gnuplot terminal after a window resize)
         set (ca, "dataaspectratiomode", "auto");
       endif
       set (ca, "dataaspectratio", [1, 1, 1], "plotboxaspectratio", [5 4 4]);
-      
+
     elseif (strcmpi (ax, "normal"))
       ## Set plotboxaspectratio to something obtuse so that switching
       ## back to "auto" will force a re-calculation.
       set (ca, "plotboxaspectratio", [3 2 1]);
       set (ca, "plotboxaspectratiomode", "auto",
                "dataaspectratiomode", "auto");
 
       ## axis limits
@@ -328,33 +328,33 @@ function lims = __get_tight_lims__ (ca, 
   hg_kids = findobj (kids, "type", "hggroup");
   kids = setdiff (kids, hg_kids);
   if (isempty (kids))
     ## Return the current limits.
     lims = get (ca, strcat (ax, "lim"));
   else
     data = get (kids, strcat (ax, "data"));
     types = get (kids, "type");
-    
+
     scale = get (ca, strcat (ax, "scale"));
     if (! iscell (data))
       data = {data};
     endif
-    
+
     ## Extend image data one pixel
     idx = strcmp (types, "image");
     if (any (idx) && (ax == "x" || ax == "y"))
       imdata = data(idx);
       px = arrayfun (@__image_pixel_size__, kids(idx), "uniformoutput", false);
       ipx = ifelse (ax == "x", 1, 2);
       imdata = cellfun (@(x,dx) [(min (x) - dx(ipx)), (max (x) + dx(ipx))],
                         imdata, px, "uniformoutput", false);
       data(idx) = imdata;
     endif
-    
+
     if (strcmp (scale, "log"))
       tmp = data;
       data = cellfun (@(x) x(x>0), tmp, "uniformoutput", false);
       n = cellfun ("isempty", data);
       data(n) = cellfun (@(x) x(x<0), tmp(n), "uniformoutput", false);
     endif
     data = cellfun (@(x) x(isfinite (x)), data, "uniformoutput", false);
     data = data(! cellfun ("isempty", data));
diff --git a/scripts/plot/appearance/box.m b/scripts/plot/appearance/box.m
--- a/scripts/plot/appearance/box.m
+++ b/scripts/plot/appearance/box.m
@@ -35,17 +35,17 @@
 
 function box (varargin)
 
   [hax, varargin, nargs] = __plt_get_axis_arg__ ("box", varargin{:});
 
   if (isempty (hax))
     hax = gca ();
   endif
-  
+
   if (nargs == 0)
     box_state = get (hax, "box");
     if (strcmp (box_state, "on"))
       box_state = "off";
     else
       box_state = "on";
     endif
   elseif (nargs == 1)
diff --git a/scripts/plot/appearance/clabel.m b/scripts/plot/appearance/clabel.m
--- a/scripts/plot/appearance/clabel.m
+++ b/scripts/plot/appearance/clabel.m
@@ -22,17 +22,17 @@
 ## @deftypefnx {Function File} {} clabel (@var{c}, @var{h}, "manual")
 ## @deftypefnx {Function File} {} clabel (@var{c})
 ## @deftypefnx {Function File} {} clabel (@dots{}, @var{prop}, @var{val}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} clabel (@dots{})
 ## Add labels to the contours of a contour plot.
 ##
 ## The contour levels are specified by the contour matrix @var{c} which is
 ## returned by @code{contour}, @code{contourc}, @code{contourf}, and
-## @code{contour3}.  Contour labels are rotated to match the local line 
+## @code{contour3}.  Contour labels are rotated to match the local line
 ## orientation and centered on the line.  The position of labels along the
 ## contour line is chosen randomly.
 ##
 ## If the argument @var{h} is a handle to a contour group object, then label
 ## this plot rather than the one in the current axes returned by @code{gca}.
 ##
 ## By default, all contours are labeled.  However, the contours to label can be
 ## specified by the vector @var{v}.  If the @qcode{"manual"} argument is
@@ -100,17 +100,17 @@ function h = clabel (c, varargin)
     error ('clabel: "manual" contour mode is not supported');
   endif
 
   idx = find (strcmpi (varargin(1:2:end), "labelspacing"), 1);
   if (! isempty (idx))
     have_labelspacing = true;
     label_spacing = varargin{2*idx};
     varargin(2*idx+(-1:0)) = [];
-  endif    
+  endif
 
   if (have_hg)
     if (! isempty (v))
       if (have_labelspacing)
         set (hg, "textlistmode", "manual", "textlist", v,
                  "labelspacing", label_spacing, "showtext", "on");
       else
         set (hg, "textlistmode", "manual", "textlist", v, "showtext", "on");
diff --git a/scripts/plot/appearance/daspect.m b/scripts/plot/appearance/daspect.m
--- a/scripts/plot/appearance/daspect.m
+++ b/scripts/plot/appearance/daspect.m
@@ -21,30 +21,30 @@
 ## @deftypefnx {Function File} {} daspect (@var{data_aspect_ratio})
 ## @deftypefnx {Function File} {} daspect (@var{mode})
 ## @deftypefnx {Function File} {@var{data_aspect_ratio_mode} =} daspect ("mode")
 ## @deftypefnx {Function File} {} daspect (@var{hax}, @dots{})
 ## Query or set the data aspect ratio of the current axes.
 ##
 ## The aspect ratio is a normalized 3-element vector representing the span of
 ## the x, y, and z-axis limits.
-## 
+##
 ## @code{daspect (@var{mode})}
 ##
 ## Set the data aspect ratio mode of the current axes.  @var{mode} is
 ## either @qcode{"auto"} or @qcode{"manual"}.
-## 
+##
 ## @code{daspect (@qcode{"mode"})}
 ##
 ## Return the data aspect ratio mode of the current axes.
-## 
+##
 ## @code{daspect (@var{hax}, @dots{})}
 ##
 ## Operate on the axes in handle @var{hax} instead of the current axes.
-## 
+##
 ## @seealso{axis, pbaspect, xlim, ylim, zlim}
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: 2010-01-26
 
 function daratio = daspect (varargin)
 
diff --git a/scripts/plot/appearance/datetick.m b/scripts/plot/appearance/datetick.m
--- a/scripts/plot/appearance/datetick.m
+++ b/scripts/plot/appearance/datetick.m
@@ -36,17 +36,17 @@ function datetick (varargin)
   [hax, varargin, nargin] = __plt_get_axis_arg__ ("datetick", varargin{:});
 
   oldfig = [];
   if (! isempty (hax))
     oldfig = get (0, "currentfigure");
   endif
   if (isempty (hax))
     hax = gca ();
-  endif 
+  endif
 
   unwind_protect
     ## FIXME: This will bring the axes to the top of the stack.
     ##        This may not always be desirable if there are multiple axes
     ##        objects.
     axes (hax);
     __datetick__ (varargin{:});
   unwind_protect_cleanup
@@ -94,17 +94,17 @@ function __datetick__ (varargin)
   endif
   keepticks = false;
   idx = strcmpi (varargin, "keepticks");
   if (any (idx))
     keepticks = true;
     varargin = varargin(! idx);
   endif
 
-  nargin = numel (varargin); 
+  nargin = numel (varargin);
   form = [];
   ax = "x";
 
   if (nargin != 0)
     arg = varargin{1};
     if (ischar (arg) && any (strcmpi (arg, {"x", "y", "z"})))
       ax = tolower (arg);
       if (nargin > 1)
diff --git a/scripts/plot/appearance/grid.m b/scripts/plot/appearance/grid.m
--- a/scripts/plot/appearance/grid.m
+++ b/scripts/plot/appearance/grid.m
@@ -48,17 +48,17 @@
 
 function grid (varargin)
 
   [hax, varargin, nargs] = __plt_get_axis_arg__ ("grid", varargin{:});
 
   if (isempty (hax))
     hax = gca ();
   endif
-  
+
   if (nargs > 2)
     print_usage ();
   endif
 
   grid_on = (   strcmp (get (hax, "xgrid"), "on")
              && strcmp (get (hax, "ygrid"), "on")
              && strcmp (get (hax, "zgrid"), "on"));
 
diff --git a/scripts/plot/appearance/legend.m b/scripts/plot/appearance/legend.m
--- a/scripts/plot/appearance/legend.m
+++ b/scripts/plot/appearance/legend.m
@@ -580,17 +580,17 @@ function [hleg, hleg_obj, hplot, labels]
                           "visible", ifelse (strcmp (box, "on"), "on", "off"),
                           "activepositionproperty", "position",
                           "interpreter", "tex");
           ## Inherit properties from current axis
           ## "fontunits" shoud be first because it affects interpretation
           ## of "fontsize" property
           proplist = {"fontunits", "fontangle", "fontname", "fontsize", ...
                       "fontweight"};
-          ca_props = get (ca(1), proplist); 
+          ca_props = get (ca(1), proplist);
           set (hlegend, proplist, ca_props);
         else
           addprops = false;
           axes (hlegend);
           delete (get (hlegend, "children"));
         endif
         if (addprops)
           addproperty ("edgecolor", hlegend, "color", [0, 0, 0]);
diff --git a/scripts/plot/appearance/orient.m b/scripts/plot/appearance/orient.m
--- a/scripts/plot/appearance/orient.m
+++ b/scripts/plot/appearance/orient.m
@@ -89,17 +89,17 @@ function retval = orient (varargin)
           set (cf, "papersize", papersize([2, 1]));
           set (cf, "paperposition", paperposition([2, 1, 4, 3]));
         endif
         if (strcmpi (orientation, "portrait"))
           ## portrait restores the default
           ## FIXME: Should use "default" here, but Octave complains
           ##        that "paperposition" is not a default property.
           set (cf, "paperposition", "factory");
-        else 
+        else
           ## landscape also sets the plot to occupy the entire page
           papersize = get (cf, "papersize");
           set (cf, "paperposition", [0.25, 0.25, (papersize - 0.5)]);
         endif
       elseif (strcmpi (varargin{1}, "tall"))
         orient ("portrait");
         papersize = get (cf, "papersize");
         set (cf, "paperposition", [0.25, 0.25, (papersize - 0.5)]);
diff --git a/scripts/plot/appearance/shading.m b/scripts/plot/appearance/shading.m
--- a/scripts/plot/appearance/shading.m
+++ b/scripts/plot/appearance/shading.m
@@ -64,17 +64,17 @@ function shading (varargin)
     types = get (kids, "type");
     hlist = [hlist; kids(strcmp(types, "patch"))];
     hlist = [hlist; kids(strcmp(types, "surface"))];
     parents = kids(strcmp (types, "axes"));
     hglist = kids(strcmp (types, "hggroup"));
     for i = 1 : numel (hglist)
       props = get (hglist(i));
       if (! isfield (props, "levelstep"))
-        parents(end+1) = hglist(i); 
+        parents(end+1) = hglist(i);
       endif
     endfor
     kids = get (parents, "children");
   endwhile
 
   ## FIXME: This is the old, simple code.
   ##        Unfortunately, it also shades contour plots which is not desirable.
   ##hp = findobj (hax, "type", "patch");
diff --git a/scripts/plot/appearance/text.m b/scripts/plot/appearance/text.m
--- a/scripts/plot/appearance/text.m
+++ b/scripts/plot/appearance/text.m
@@ -76,31 +76,31 @@ function h = text (varargin)
         ## FIXME: "default" or "factory" as first row
         ##        should be escaped to "\default" or "\factory"
         ##        Other rows do not require escaping.
         do_keyword_repl = false;
         string = {string};
       elseif (nx > 1 && nt == nx)
         ## Mutiple text objects with different strings
         string = cellstr (string);
-      else 
+      else
         ## Mutiple text objects with same string
         string = repmat ({string}, [nx, 1]);
         nt = nx;
       endif
 
       ## Escape special keywords
       if (do_keyword_repl)
         string = regexprep (string, '^(default|factory)$', '\\$1');
       endif
 
     elseif (iscell (string))
 
       nt = numel (string);
-      if (nx == 1)      
+      if (nx == 1)
         ## Single text object with one or more lines
         string = {string};
         nt = 1;
       elseif (nx > 1 && nt == nx)
         ## Mutiple text objects with different strings
       else
         ## Mutiple text objects with same string
         string = repmat ({string}, [nx, 1]);
diff --git a/scripts/plot/appearance/title.m b/scripts/plot/appearance/title.m
--- a/scripts/plot/appearance/title.m
+++ b/scripts/plot/appearance/title.m
@@ -38,17 +38,17 @@
 
 function h = title (varargin)
 
   [hax, varargin, nargin] = __plt_get_axis_arg__ ("title", varargin{:});
 
   if (isempty (hax))
     hax = gca ();
   endif
-  
+
   if (rem (nargin, 2) != 1)
     print_usage ();
   endif
 
   htmp = __axis_label__ (hax, "title", varargin{:});
 
   if (nargout > 0)
     h = htmp;
diff --git a/scripts/plot/appearance/xlabel.m b/scripts/plot/appearance/xlabel.m
--- a/scripts/plot/appearance/xlabel.m
+++ b/scripts/plot/appearance/xlabel.m
@@ -38,17 +38,17 @@
 
 function h = xlabel (varargin)
 
   [hax, varargin, nargin] = __plt_get_axis_arg__ ("xlabel", varargin{:});
 
   if (isempty (hax))
     hax = gca ();
   endif
-  
+
   if (rem (nargin, 2) != 1)
     print_usage ();
   endif
 
   htmp = __axis_label__ (hax, "xlabel", varargin{1},
                          "color", get (hax, "xcolor"), varargin{2:end});
 
   if (nargout > 0)
diff --git a/scripts/plot/appearance/ylabel.m b/scripts/plot/appearance/ylabel.m
--- a/scripts/plot/appearance/ylabel.m
+++ b/scripts/plot/appearance/ylabel.m
@@ -40,17 +40,17 @@
 
 function h = ylabel (varargin)
 
   [hax, varargin, nargin] = __plt_get_axis_arg__ ("ylabel", varargin{:});
 
   if (isempty (hax))
     hax = gca ();
   endif
-  
+
   if (rem (nargin, 2) != 1)
     print_usage ();
   endif
 
   htmp = __axis_label__ (hax, "ylabel", varargin{1},
                          "color", get (hax, "ycolor"), varargin{2:end});
 
   if (nargout > 0)
diff --git a/scripts/plot/appearance/zlabel.m b/scripts/plot/appearance/zlabel.m
--- a/scripts/plot/appearance/zlabel.m
+++ b/scripts/plot/appearance/zlabel.m
@@ -37,17 +37,17 @@
 
 function h = zlabel (varargin)
 
   [hax, varargin, nargin] = __plt_get_axis_arg__ ("zlabel", varargin{:});
 
   if (isempty (hax))
     hax = gca ();
   endif
-  
+
   if (rem (nargin, 2) != 1)
     print_usage ();
   endif
 
   htmp = __axis_label__ (hax, "zlabel", varargin{1},
                          "color", get (hax, "zcolor"), varargin{2:end});
 
   if (nargout > 0)
diff --git a/scripts/plot/draw/area.m b/scripts/plot/draw/area.m
--- a/scripts/plot/draw/area.m
+++ b/scripts/plot/draw/area.m
@@ -65,24 +65,24 @@ function h = area (varargin)
     print_usage ();
   endif
 
   x = y = [];
   bv = 0;
 
   num_numeric = find (cellfun ("isclass", varargin, "char"), 1) - 1;
   if (isempty (num_numeric))
-    num_numeric = nargin;     
+    num_numeric = nargin;
   endif
 
   switch (num_numeric)
     case 1
       y = varargin{1};
     case 2
-      if (isscalar (varargin{2})) 
+      if (isscalar (varargin{2}))
         y = varargin{1};
         bv = varargin{2};
       else
         x = varargin{1};
         y = varargin{2};
       endif
     case 3
       x = varargin{1};
@@ -242,17 +242,17 @@ endfunction
 
 %!demo
 %! ## Verify identity sin^2 + cos^2 = 1
 %! clf;
 %! t = linspace (0, 2*pi, 100)';
 %! y = [sin(t).^2, cos(t).^2];
 %! area (t, y);
 %! axis tight
-%! legend ('sin^2', 'cos^2', 'location', 'NorthEastOutside');  
+%! legend ('sin^2', 'cos^2', 'location', 'NorthEastOutside');
 %! title ('area() plot');
 
 %!demo
 %! ## Show effects of setting BaseValue
 %! clf;
 %! x = [-2:0.1:2]';
 %! y = x.^2 - 1;
 %! subplot (1, 2, 1)
diff --git a/scripts/plot/draw/bar.m b/scripts/plot/draw/bar.m
--- a/scripts/plot/draw/bar.m
+++ b/scripts/plot/draw/bar.m
@@ -34,19 +34,19 @@
 ## The default width is 0.8.
 ##
 ## If @var{y} is a matrix, then each column of @var{y} is taken to be a
 ## separate bar graph plotted on the same graph.  By default the columns
 ## are plotted side-by-side.  This behavior can be changed by the @var{style}
 ## argument which can take the following values:
 ##
 ## @table @asis
-## @item @qcode{"grouped"} (default) 
+## @item @qcode{"grouped"} (default)
 ## Side-by-side bars with a gap between bars and centered over the X-coordinate.
-## 
+##
 ## @item  @qcode{"stacked"}
 ## Bars are stacked so that each X value has a single bar composed of
 ## multiple segments.
 ##
 ## @item @qcode{"hist"}
 ## Side-by-side bars with no gap between bars and centered over the
 ## X-coordinate.
 ##
diff --git a/scripts/plot/draw/barh.m b/scripts/plot/draw/barh.m
--- a/scripts/plot/draw/barh.m
+++ b/scripts/plot/draw/barh.m
@@ -34,19 +34,19 @@
 ## The default width is 0.8.
 ##
 ## If @var{y} is a matrix, then each column of @var{y} is taken to be a
 ## separate bar graph plotted on the same graph.  By default the columns
 ## are plotted side-by-side.  This behavior can be changed by the @var{style}
 ## argument which can take the following values:
 ##
 ## @table @asis
-## @item @qcode{"grouped"} (default) 
+## @item @qcode{"grouped"} (default)
 ## Side-by-side bars with a gap between bars and centered over the Y-coordinate.
-## 
+##
 ## @item  @qcode{"stacked"}
 ## Bars are stacked so that each Y value has a single bar composed of
 ## multiple segments.
 ##
 ## @item @qcode{"hist"}
 ## Side-by-side bars with no gap between bars and centered over the
 ## Y-coordinate.
 ##
@@ -55,17 +55,17 @@
 ## Y-coordinate.
 ## @end table
 ##
 ## Optional property/value pairs are passed directly to the underlying patch
 ## objects.
 ##
 ## If the first argument @var{hax} is an axes handle, then plot into this axis,
 ## rather than the current axes returned by @code{gca}.
-## 
+##
 ## The optional return value @var{h} is a graphics handle to the created
 ## bar series hggroup.  For a description of the use of the
 ## bar series, @pxref{XREFbar,,bar}.
 ## @seealso{bar, hist, pie, plot, patch}
 ## @end deftypefn
 
 ## Author: jwe
 
diff --git a/scripts/plot/draw/colorbar.m b/scripts/plot/draw/colorbar.m
--- a/scripts/plot/draw/colorbar.m
+++ b/scripts/plot/draw/colorbar.m
@@ -57,33 +57,33 @@
 ## Place the colorbar under the plot.
 ##
 ## @item @qcode{"South"}
 ## Place the colorbar at the bottom of the plot.
 ## @end table
 ##
 ## To remove a colorbar from a plot use any one of the following keywords for
 ## the @var{delete_option}: @qcode{"delete"}, @qcode{"hide"}, @qcode{"off"}.
-## 
+##
 ## If the argument @qcode{"peer"} is given, then the following argument is
 ## treated as the axes handle in which to add the colorbar.  Alternatively,
 ## If the first argument @var{hax} is an axes handle, then the colorbar is
 ## added to this axis, rather than the current axes returned by @code{gca}.
 ##
 ## If the first argument @var{hcb} is a handle to a colorbar object, then
 ## operate on this colorbar directly.
 ##
 ## Additional property/value pairs are passed directly to the underlying axes
 ## object.
 ##
 ## The optional return value @var{h} is a graphics handle to the created
 ## colorbar object.
 ##
 ## Implementation Note: A colorbar is created as an additional axes to the
-## current figure with the @qcode{"tag"} property set to @qcode{"colorbar"}. 
+## current figure with the @qcode{"tag"} property set to @qcode{"colorbar"}.
 ## The created axes object has the extra property @qcode{"location"} which
 ## controls the positioning of the colorbar.
 ## @seealso{colormap}
 ## @end deftypefn
 
 function h = colorbar (varargin)
 
   [hcb, varargin, nargin] = __plt_get_axis_arg__ ("colorbar", varargin{:});
@@ -144,20 +144,20 @@ function h = colorbar (varargin)
       ##        colorbar whenever an option changes.
       ##        re-instate this code if listener is developed.
       # if (! isempty (loc))
       #   set (hcb, "location", loc);
       # endif
       # if (! isempty (args))
       #   set (hcb, args{:});
       # endif
-      ax = get (get (hcb, "parent"), "currrentaxes");      
+      ax = get (get (hcb, "parent"), "currrentaxes");
     endif
   endif
-    
+
   if (isempty (loc))
     loc = "eastoutside";
   endif
   if (isempty (ax))
     ax = gca ();
   endif
 
   showhiddenhandles = get (0, "showhiddenhandles");
@@ -175,17 +175,17 @@ function h = colorbar (varargin)
     ## FIXME: Matlab does not require the "position" property to be active.
     ##        Is there a way to determine the plotbox position for the
     ##        gnuplot graphics toolkit with the outerposition is active?
     set (ax, "activepositionproperty", "position");
     obj = get (ax);
     obj.__cbar_hax__ = ax;
     position = obj.position;
     ## FIXME: Should this be ancestor to accommodate hggroups?
-    hpar = get (ax, "parent");  
+    hpar = get (ax, "parent");
     clen = rows (get (hpar, "colormap"));
     cext = get (ax, "clim");
     cdiff = (cext(2) - cext(1)) / clen / 2;
     cmin = cext(1) + cdiff;
     cmax = cext(2) - cdiff;
 
     [pos, cpos, vertical, mirror] =  ...
         __position_colorbox__ (loc, obj, ancestor (ax, "figure"));
@@ -317,17 +317,17 @@ function update_colorbar_clim (hax, d, h
     ##        a redraw of the axis object.
     ##
     ## Debug Example:
     ## Uncomment the line below.
     ##   keyboard;
     ## Now run the the following code.
     ##   clf; colorbar (); contour (peaks ())
     ## Once the keyboard command has been hit in the debugger try
-    ##   set (hiax, "ylim", [0 0.5]) 
+    ##   set (hiax, "ylim", [0 0.5])
     pos = get (hiax, "position");
     pos(1) += eps;
     set (hiax, "position", pos);
     pos(1) -= eps;
     set (hiax, "position", pos);
   endif
 endfunction
 
diff --git a/scripts/plot/draw/contour.m b/scripts/plot/draw/contour.m
--- a/scripts/plot/draw/contour.m
+++ b/scripts/plot/draw/contour.m
@@ -64,17 +64,17 @@ function [c, h] = contour (varargin)
   [hax, varargin] = __plt_get_axis_arg__ ("contour", varargin{:});
 
   oldfig = [];
   if (! isempty (hax))
     oldfig = get (0, "currentfigure");
   endif
   unwind_protect
     hax = newplot (hax);
-    
+
     [ctmp, htmp] = __contour__ (hax, "none", varargin{:});
   unwind_protect_cleanup
     if (! isempty (oldfig))
       set (0, "currentfigure", oldfig);
     endif
   end_unwind_protect
 
   if (nargout > 0)
diff --git a/scripts/plot/draw/contour3.m b/scripts/plot/draw/contour3.m
--- a/scripts/plot/draw/contour3.m
+++ b/scripts/plot/draw/contour3.m
@@ -66,17 +66,17 @@ function [c, h] = contour3 (varargin)
   [hax, varargin, nargin] = __plt_get_axis_arg__ ("contour3", varargin{:});
 
   oldfig = [];
   if (! isempty (hax))
     oldfig = get (0, "currentfigure");
   endif
   unwind_protect
     hax = newplot (hax);
-    
+
     [ctmp, htmp] = __contour__ (hax, "auto", varargin{:});
   unwind_protect_cleanup
     if (! isempty (oldfig))
       set (0, "currentfigure", oldfig);
     endif
   end_unwind_protect
 
   if (! ishold ())
diff --git a/scripts/plot/draw/contourf.m b/scripts/plot/draw/contourf.m
--- a/scripts/plot/draw/contourf.m
+++ b/scripts/plot/draw/contourf.m
@@ -65,17 +65,17 @@ function [c, h] = contourf (varargin)
   [hax, varargin] = __plt_get_axis_arg__ ("contour", varargin{:});
 
   oldfig = [];
   if (! isempty (hax))
     oldfig = get (0, "currentfigure");
   endif
   unwind_protect
     hax = newplot (hax);
-    
+
     [ctmp, htmp] = __contour__ (hax, "none", "fill", "on",
                                      "linecolor", "black", varargin{:});
   unwind_protect_cleanup
     if (! isempty (oldfig))
       set (0, "currentfigure", oldfig);
     endif
   end_unwind_protect
 
diff --git a/scripts/plot/draw/ellipsoid.m b/scripts/plot/draw/ellipsoid.m
--- a/scripts/plot/draw/ellipsoid.m
+++ b/scripts/plot/draw/ellipsoid.m
@@ -23,17 +23,17 @@
 ## @deftypefnx {Function File} {[@var{x}, @var{y}, @var{z}] =} ellipsoid (@dots{})
 ## Plot a 3-D ellipsoid.
 ##
 ## The inputs @var{xc}, @var{yc}, @var{zc} specify the center of the ellipsoid.
 ## The inputs @var{xr}, @var{yr}, @var{zr} specify the semi-major axis lengths.
 ##
 ## The optional input @var{n} determines the number of faces around the
 ## the circumference of the cylinder.  The default value is 20.
-## 
+##
 ## If the first argument @var{hax} is an axes handle, then plot into this axis,
 ## rather than the current axes returned by @code{gca}.
 ##
 ## If outputs are requested @code{ellipsoid} returns three matrices in
 ## @code{meshgrid} format, such that @code{surf (@var{x}, @var{y}, @var{z})}
 ## generates the ellipsoid.
 ## @seealso{cylinder, rectangle, sphere}
 ## @end deftypefn
@@ -75,17 +75,17 @@ function [xx, yy, zz] = ellipsoid (varar
     zz = z;
   else
     oldfig = [];
     if (! isempty (hax))
       oldfig = get (0, "currentfigure");
     endif
     unwind_protect
       hax = newplot (hax);
-    
+
       surf (x, y, z);
     unwind_protect_cleanup
       if (! isempty (oldfig))
         set (0, "currentfigure", oldfig);
       endif
     end_unwind_protect
   endif
 
diff --git a/scripts/plot/draw/errorbar.m b/scripts/plot/draw/errorbar.m
--- a/scripts/plot/draw/errorbar.m
+++ b/scripts/plot/draw/errorbar.m
@@ -52,17 +52,17 @@
 ## parameters specifying the error values depending on the nature of the error
 ## values and the plot format @var{fmt}.
 ##
 ## @table @asis
 ## @item @var{err} (scalar)
 ## When the error is a scalar all points share the same error value.
 ## The errorbars are symmetric and are drawn from @var{data}-@var{err} to
 ## @var{data}+@var{err}.
-## The @var{fmt} argument determines whether @var{err} is in the x-direction, 
+## The @var{fmt} argument determines whether @var{err} is in the x-direction,
 ## y-direction (default), or both.
 ##
 ## @item @var{err} (vector or matrix)
 ## Each data point has a particular error value.
 ## The errorbars are symmetric and are drawn from @var{data}(n)-@var{err}(n) to
 ## @var{data}(n)+@var{err}(n).
 ##
 ## @item @var{lerr}, @var{uerr} (scalar)
diff --git a/scripts/plot/draw/ezcontour.m b/scripts/plot/draw/ezcontour.m
--- a/scripts/plot/draw/ezcontour.m
+++ b/scripts/plot/draw/ezcontour.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezcontour (@var{f})
 ## @deftypefnx {Function File} {} ezcontour (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezcontour (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezcontour (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezcontour (@dots{})
 ##
 ## Plot the contour lines of a function.
-## 
+##
 ## @var{f} is a string, inline function, or function handle with two arguments
 ## defining the function.  By default the plot is over the meshed domain
 ## @code{-2*pi <= @var{x} | @var{y} <= 2*pi} with 60 points in each dimension.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## values of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
 ## then the minimum and maximum values are @code{[xmin xmax ymin ymax]}.
 ##
diff --git a/scripts/plot/draw/ezcontourf.m b/scripts/plot/draw/ezcontourf.m
--- a/scripts/plot/draw/ezcontourf.m
+++ b/scripts/plot/draw/ezcontourf.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezcontourf (@var{f})
 ## @deftypefnx {Function File} {} ezcontourf (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezcontourf (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezcontourf (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezcontourf (@dots{})
 ##
 ## Plot the filled contour lines of a function.
-## 
+##
 ## @var{f} is a string, inline function, or function handle with two arguments
 ## defining the function.  By default the plot is over the meshed domain
 ## @code{-2*pi <= @var{x} | @var{y} <= 2*pi} with 60 points in each dimension.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## values of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
 ## then the minimum and maximum values are @code{[xmin xmax ymin ymax]}.
 ##
diff --git a/scripts/plot/draw/ezmesh.m b/scripts/plot/draw/ezmesh.m
--- a/scripts/plot/draw/ezmesh.m
+++ b/scripts/plot/draw/ezmesh.m
@@ -42,17 +42,17 @@
 ## @var{n} is a scalar defining the number of points to use in each dimension.
 ##
 ## If the argument @qcode{"circ"} is given, then the function is plotted over
 ## a disk centered on the middle of the domain @var{dom}.
 ##
 ## If the first argument @var{hax} is an axes handle, then plot into this axis,
 ## rather than the current axes returned by @code{gca}.
 ##
-## The optional return value @var{h} is a graphics handle to the created 
+## The optional return value @var{h} is a graphics handle to the created
 ## surface object.
 ##
 ## Example 1: 2-argument function
 ##
 ## @example
 ## @group
 ## f = @@(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezmesh (f, [-3, 3]);
diff --git a/scripts/plot/draw/ezpolar.m b/scripts/plot/draw/ezpolar.m
--- a/scripts/plot/draw/ezpolar.m
+++ b/scripts/plot/draw/ezpolar.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezpolar (@var{f})
 ## @deftypefnx {Function File} {} ezpolar (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezpolar (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezpolar (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezpolar (@dots{})
 ##
 ## Plot a 2-D function in polar coordinates.
-## 
+##
 ## The function @var{f} is a string, inline function, or function handle with
 ## a single argument.  The expected form of the function is
 ## @code{@var{rho} = @var{f}(@var{theta})}.
 ## By default the plot is over the domain @code{0 <= @var{theta} <= 2*pi}
 ## with 500 points.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## values of @var{theta}.
diff --git a/scripts/plot/draw/fill.m b/scripts/plot/draw/fill.m
--- a/scripts/plot/draw/fill.m
+++ b/scripts/plot/draw/fill.m
@@ -22,17 +22,17 @@
 ## @deftypefnx {Function File} {} fill (@dots{}, @var{prop}, @var{val})
 ## @deftypefnx {Function File} {} fill (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} fill (@dots{})
 ## Create one or more filled 2-D polygons.
 ##
 ## The inputs @var{x} and @var{y} are the coordinates of the polygon vertices.
 ## If the inputs are matrices then the rows represent different vertices and
 ## each column produces a different polygon.  @code{fill} will close any open
-## polygons before plotting. 
+## polygons before plotting.
 ##
 ## The input @var{c} determines the color of the polygon.  The simplest form
 ## is a single color specification such as a @code{plot} format or an
 ## RGB-triple.  In this case the polygon(s) will have one unique color.  If
 ## @var{c} is a vector or matrix then the color data is first scaled using
 ## @code{caxis} and then indexed into the current colormap.  A row vector will
 ## color each polygon (a column from matrices @var{x} and @var{y}) with a
 ## single computed color.  A matrix @var{c} of the same size as @var{x} and
@@ -71,17 +71,17 @@ function h = fill (varargin)
 
   hlist = [];
   iargs = __find_patches__ (varargin{:});
 
   opts = {};
   if (numel (varargin) > iargs(end) + 2)
     opts = varargin(iargs(end)+3 : end);
   endif
-  
+
   if (! all (cellfun (@(x) iscolorspec (x), varargin(iargs + 2))))
     print_usage ();
   endif
 
   oldfig = [];
   if (! isempty (hax))
     oldfig = get (0, "currentfigure");
   endif
@@ -101,17 +101,17 @@ function h = fill (varargin)
           endif
         endif
 
         [htmp, fail] = __patch__ (hax, varargin{iargs(i)+(0:1)}, cdata,
                                        opts{:});
         if (fail)
           print_usage ();
         endif
-        
+
         hlist(end+1, 1) = htmp;
       endfor
 
     unwind_protect_cleanup
       if (strcmp (old_nxtplt, "replace"))
         set (hax, "nextplot", old_nxtplt);
       endif
     end_unwind_protect
diff --git a/scripts/plot/draw/fplot.m b/scripts/plot/draw/fplot.m
--- a/scripts/plot/draw/fplot.m
+++ b/scripts/plot/draw/fplot.m
@@ -111,18 +111,18 @@ function [X, Y] = fplot (varargin)
       else
         tol = arg;
       endif
     else
       error ("fplot: bad input in position %d", i+2);
     endif
   endfor
 
-  if (n != 5) 
-    ## n was specified 
+  if (n != 5)
+    ## n was specified
     x0 = linspace (limits(1), limits(2), n/2 + 1)';
     y0 = feval (fn, x0);
     x = linspace (limits(1), limits(2), n)';
     y = feval (fn, x);
   else
     x0 = linspace (limits(1), limits(2), 5)';
     y0 = feval (fn, x0);
     n = 8;
@@ -133,17 +133,17 @@ function [X, Y] = fplot (varargin)
   if (rows (x0) != rows (y0))
     ## FN is a constant value function
     y0 = repmat (y0, size (x0));
     y = repmat (y, size (x));
   endif
 
   err0 = Inf;
 
-  ## FIXME: This algorithm should really use adaptive scaling as the 
+  ## FIXME: This algorithm should really use adaptive scaling as the
   ##        the numerical quadrature algorithms do so that extra points are
   ##        used where they are needed and not spread evenly over the entire
   ##        x-range.  Try any function with a discontinuity, such as
   ##        fplot (@tan, [-2, 2]) or fplot ("1./x", [-3, 2]), to see the
   ##        problems with the current solution.
 
   while (n < 2^18)    # Something is wrong if we need more than 250K points
     yi = interp1 (x0, y0, x, "linear");
diff --git a/scripts/plot/draw/hist.m b/scripts/plot/draw/hist.m
--- a/scripts/plot/draw/hist.m
+++ b/scripts/plot/draw/hist.m
@@ -75,17 +75,17 @@
 
 function [nn, xx] = hist (varargin)
 
   [hax, varargin, nargin] = __plt_get_axis_arg__ ("hist", varargin{:});
 
   if (nargin < 1)
     print_usage ();
   endif
-  
+
   y = varargin{1};
   varargin = varargin(2:end);
 
   arg_is_vector = isvector (y);
 
   if (arg_is_vector)
     y = y(:);
   endif
@@ -156,19 +156,19 @@ function [nn, xx] = hist (varargin)
 
   if (nargin > 2 && ! ischar (varargin{iarg}))
     ## Normalize the histogram.
     norm = varargin{iarg++};
     freq = bsxfun (@times, freq, norm ./ sum (! isnan (y)));
   endif
 
   if (nargout > 0)
-    if (arg_is_vector)  
+    if (arg_is_vector)
       ## Matlab compatibility requires a row vector return
-      nn = freq';  
+      nn = freq';
       xx = x';
     else
       nn = freq;
       xx = x;
     endif
   else
     if (isempty (hax))
       hax = gca ();
diff --git a/scripts/plot/draw/meshc.m b/scripts/plot/draw/meshc.m
--- a/scripts/plot/draw/meshc.m
+++ b/scripts/plot/draw/meshc.m
@@ -28,17 +28,17 @@
 ## The wireframe mesh is plotted using rectangles.  The vertices of the
 ## rectangles [@var{x}, @var{y}] are typically the output of @code{meshgrid}.
 ## over a 2-D rectangular region in the x-y plane.  @var{z} determines the
 ## height above the plane of each vertex.  If only a single @var{z} matrix is
 ## given, then it is plotted over the meshgrid
 ## @code{@var{x} = 1:columns (@var{z}), @var{y} = 1:rows (@var{z})}.
 ## Thus, columns of @var{z} correspond to different @var{x} values and rows
 ## of @var{z} correspond to different @var{y} values.
-## 
+##
 ## The color of the mesh is computed by linearly scaling the @var{z} values
 ## to fit the range of the current colormap.  Use @code{caxis} and/or
 ## change the colormap to control the appearance.
 ##
 ## Optionally the color of the mesh can be specified independently of @var{z}
 ## by supplying a color matrix, @var{c}.
 ##
 ## Any property/value pairs are passed directly to the underlying surface
diff --git a/scripts/plot/draw/meshz.m b/scripts/plot/draw/meshz.m
--- a/scripts/plot/draw/meshz.m
+++ b/scripts/plot/draw/meshz.m
@@ -61,19 +61,19 @@ function h = meshz (varargin)
 
   [hax, varargin, nargin] = __plt_get_axis_arg__ ("meshz", varargin{:});
 
   ## Find where property/value pairs start
   charidx = find (cellfun ("isclass", varargin, "char"), 1);
 
   have_c = false;
   if (isempty (charidx))
-    if (nargin == 2 || nargin == 4) 
+    if (nargin == 2 || nargin == 4)
       have_c = true;
-      charidx = nargin;   # bundle C matrix back into varargin 
+      charidx = nargin;   # bundle C matrix back into varargin
     else
       charidx = nargin + 1;
     endif
   endif
 
   if (charidx == 2)
     z = varargin{1};
     [m, n] = size (z);
@@ -105,17 +105,17 @@ function h = meshz (varargin)
   if (have_c)
     c = varargin{charidx};
     cref = min (c(isfinite (c)));
     c = [cref .* ones(1, columns(c) + 2);
          cref .* ones(rows(c), 1), c, cref .* ones(rows(c), 1);
          cref .* ones(1, columns(c) + 2)];
     varargin(charidx) = c;
   endif
-    
+
   oldfig = [];
   if (! isempty (hax))
     oldfig = get (0, "currentfigure");
   endif
   unwind_protect
     hax = newplot (hax);
     htmp = mesh (x, y, z, varargin{charidx:end});
   unwind_protect_cleanup
@@ -150,13 +150,13 @@ endfunction
 %!  meshz (Z);
 %!  daspect ([2.5, 2.5, 1]);
 %!  title ('meshz() plot');
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! [X,Y,Z] = peaks ();
-%! [fx, fy] = gradient (Z); 
+%! [fx, fy] = gradient (Z);
 %! C = sqrt (fx.^2 + fy.^2);
 %! meshz (X,Y,Z,C);
 %! title ('meshz() plot with color determined by gradient');
 
diff --git a/scripts/plot/draw/pareto.m b/scripts/plot/draw/pareto.m
--- a/scripts/plot/draw/pareto.m
+++ b/scripts/plot/draw/pareto.m
@@ -27,17 +27,17 @@
 ## A Pareto chart is a bar graph that arranges information in such a way
 ## that priorities for process improvement can be established; It organizes
 ## and displays information to show the relative importance of data.  The chart
 ## is similar to the histogram or bar chart, except that the bars are arranged
 ## in decreasing magnitude from left to right along the x-axis.
 ##
 ## The fundamental idea (Pareto principle) behind the use of Pareto
 ## diagrams is that the majority of an effect is due to a small subset of the
-## causes.  For quality improvement, the first few contributing causes 
+## causes.  For quality improvement, the first few contributing causes
 ## (leftmost bars as presented on the diagram) to a problem usually account for
 ## the majority of the result.  Thus, targeting these "major causes" for
 ## elimination results in the most cost-effective improvement scheme.
 ##
 ## Typically only the magnitude data @var{y} is present in which case
 ## @var{x} is taken to be the range @code{1 : length (@var{y})}.  If @var{x}
 ## is given it may be a string array, a cell array of strings, or a numerical
 ## vector.
diff --git a/scripts/plot/draw/patch.m b/scripts/plot/draw/patch.m
--- a/scripts/plot/draw/patch.m
+++ b/scripts/plot/draw/patch.m
@@ -72,21 +72,21 @@
 ## @seealso{fill, get, set}
 ## @end deftypefn
 
 ## Author: jwe
 
 function h = patch (varargin)
 
   [hax, varargin] = __plt_get_axis_arg__ ("patch", varargin{:});
-  
+
   if (isempty (hax))
     hax = gca ();
   endif
-  
+
   [htmp, failed] = __patch__ (hax, varargin{:});
 
   if (failed)
     print_usage ();
   endif
 
   if (nargout > 0)
     h = htmp;
diff --git a/scripts/plot/draw/peaks.m b/scripts/plot/draw/peaks.m
--- a/scripts/plot/draw/peaks.m
+++ b/scripts/plot/draw/peaks.m
@@ -34,29 +34,29 @@
 ## f(x,y) = 3*(1-x)^2*exp(-x^2 - (y+1)^2) ...
 ##          - 10*(x/5 - x^3 - y^5)*exp(-x^2-y^2) ...
 ##          - 1/3*exp(-(x+1)^2 - y^2)
 ## @end verbatim
 ## @end ifnottex
 ##
 ## Called without a return argument, @code{peaks} plots the surface of the
 ## above function using @code{surf}.
-## 
+##
 ## If @var{n} is a scalar, @code{peaks} plots the value of the above
 ## function on an @var{n}-by-@var{n} mesh over the range [-3,3].  The
 ## default value for @var{n} is 49.
 ##
 ## If @var{n} is a vector, then it represents the grid values over which
 ## to calculate the function.  If @var{x} and @var{y} are specified then
 ## the function value is calculated over the specified grid of vertices.
 ##
 ## When called with output arguments, return the data for the function
 ## evaluated over the meshgrid.  This can subsequently be plotted with
 ## @code{surf (@var{x}, @var{y}, @var{z})}.
-## 
+##
 ## @seealso{sombrero, meshgrid, mesh, surf}
 ## @end deftypefn
 
 ## Expression for the peaks function was taken from the following paper:
 ## http://www.control.hut.fi/Kurssit/AS-74.115/Material/GENALGgoga.pdf
 
 function [X_out, Y_out, Z_out] = peaks (x, y)
 
diff --git a/scripts/plot/draw/pie.m b/scripts/plot/draw/pie.m
--- a/scripts/plot/draw/pie.m
+++ b/scripts/plot/draw/pie.m
@@ -22,24 +22,24 @@
 ## @deftypefnx {Function File} {} pie (@dots{}, @var{labels})
 ## @deftypefnx {Function File} {} pie (@var{hax}, @dots{});
 ## @deftypefnx {Function File} {@var{h} =} pie (@dots{});
 ## Plot a 2-D pie chart.
 ##
 ## When called with a single vector argument, produce a pie chart of the
 ## elements in @var{x}.  The size of the ith slice is the percentage that the
 ## element @var{x}i represents of the total sum of @var{x}:
-## @code{pct = @var{x}(i) / sum (@var{x})}. 
+## @code{pct = @var{x}(i) / sum (@var{x})}.
 ##
 ## The optional input @var{explode} is a vector of the same length as @var{x}
 ## that, if non-zero, "explodes" the slice from the pie chart.
 ##
 ## The optional input @var{labels} is a cell array of strings of the same
 ## length as @var{x} specifying the label for each slice.
-## 
+##
 ## If the first argument @var{hax} is an axes handle, then plot into this axis,
 ## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a list of handles to the patch
 ## and text objects generating the plot.
 ##
 ## Note: If @code{sum (@var{x}) @leq{} 1} then the elements of @var{x} are
 ## interpreted as percentages directly and are not normalized by @code{sum (x)}.
diff --git a/scripts/plot/draw/pie3.m b/scripts/plot/draw/pie3.m
--- a/scripts/plot/draw/pie3.m
+++ b/scripts/plot/draw/pie3.m
@@ -23,17 +23,17 @@
 ## @deftypefnx {Function File} {} pie3 (@dots{}, @var{labels})
 ## @deftypefnx {Function File} {} pie3 (@var{hax}, @dots{});
 ## @deftypefnx {Function File} {@var{h} =} pie3 (@dots{});
 ## Plot a 3-D pie chart.
 ##
 ## Called with a single vector argument, produces a 3-D pie chart of the
 ## elements in @var{x}.  The size of the ith slice is the percentage that the
 ## element @var{x}i represents of the total sum of @var{x}:
-## @code{pct = @var{x}(i) / sum (@var{x})}. 
+## @code{pct = @var{x}(i) / sum (@var{x})}.
 ##
 ## The optional input @var{explode} is a vector of the same length as @var{x}
 ## that, if non-zero, "explodes" the slice from the pie chart.
 ##
 ## The optional input @var{labels} is a cell array of strings of the same
 ## length as @var{x} specifying the label for each slice.
 ##
 ## If the first argument @var{hax} is an axes handle, then plot into this axis,
diff --git a/scripts/plot/draw/plot.m b/scripts/plot/draw/plot.m
--- a/scripts/plot/draw/plot.m
+++ b/scripts/plot/draw/plot.m
@@ -68,17 +68,17 @@
 ## the elements, starting with 1.
 ##
 ## @item
 ## If @var{x} and @var{y} are scalars, a single point is plotted.
 ##
 ## @item
 ## @code{squeeze()} is applied to arguments with more than two dimensions,
 ## but no more than two singleton dimensions.
-## 
+##
 ## @item
 ## If both arguments are vectors, the elements of @var{y} are plotted versus
 ## the elements of @var{x}.
 ##
 ## @item
 ## If @var{x} is a vector and @var{y} is a matrix, then
 ## the columns (or rows) of @var{y} are plotted versus @var{x}.
 ## (using whichever combination matches, with columns tried first.)
@@ -97,17 +97,17 @@
 ##
 ## Multiple property-value pairs may be specified, but they must appear
 ## in pairs.  These arguments are applied to the line objects drawn by
 ## @code{plot}.  Useful properties to modify are @qcode{"linestyle"},
 ## @qcode{"linewidth"}, @qcode{"color"}, @qcode{"marker"},
 ## @qcode{"markersize"}, @qcode{"markeredgecolor"}, @qcode{"markerfacecolor"}.
 ##
 ## The @var{fmt} format argument can also be used to control the plot style.
-## The format is composed of three parts: linestyle, markerstyle, color. 
+## The format is composed of three parts: linestyle, markerstyle, color.
 ## When a markerstyle is specified, but no linestyle, only the markers are
 ## plotted.  Similarly, if a linestyle is specified, but no markerstyle, then
 ## only lines are drawn.  If both are specified then lines and markers will
 ## be plotted.  If no @var{fmt} and no @var{property}/@var{value} pairs are
 ## given, then the default plot style is solid lines with no markers and the
 ## color determined by the @qcode{"colororder"} property of the current axes.
 ##
 ## Format arguments:
@@ -242,17 +242,17 @@ endfunction
 %! title ('plot() of green stars along a line at 45 degrees');
 
 %!demo
 %! x1 = 1:5;  y1 = 1:5;
 %! x2 = 5:9; y2 = 5:-1:1;
 %! plot (x1,y1,'bo-', x2,y2,'rs-');
 %! axis ('tight');
 %! title ({'plot() of blue circles ascending and red squares descending';
-%!         'connecting lines drawn'}); 
+%!         'connecting lines drawn'});
 
 %!demo
 %! x = 0:10;
 %! plot (x, rand (numel (x), 3))
 %! axis ([0 10 0 1])
 %! title ({'Three random variables', 'x[1x11], y[11x3]'})
 
 %!demo
diff --git a/scripts/plot/draw/plotyy.m b/scripts/plot/draw/plotyy.m
--- a/scripts/plot/draw/plotyy.m
+++ b/scripts/plot/draw/plotyy.m
@@ -169,17 +169,17 @@ function [ax, h1, h2] = __plotyy__ (ax, 
   set (ax(2), "colororder", [colors(2:end,:); colors(1,:)]);
 
   if (strcmp (get (ax(1), "autopos_tag"), "subplot"))
     set (ax(2), "autopos_tag", "subplot");
   else
     set (ax, "activepositionproperty", "position");
   endif
 
-  ## Kluge, until __plt_get_axis_arg__ and newplot are reworked. 
+  ## Kluge, until __plt_get_axis_arg__ and newplot are reworked.
   set (ax(2), "nextplot", "replacechildren");
   h2 = feval (fun2, ax(2), x2, y2);
   set (ax(2), "yaxislocation", "right");
   set (ax(2), "ycolor", getcolor (h2(1)));
 
   if (strcmp (get(ax(1), "activepositionproperty"), "position"))
     set (ax(2), "position", get (ax(1), "position"));
   else
diff --git a/scripts/plot/draw/private/__bar__.m b/scripts/plot/draw/private/__bar__.m
--- a/scripts/plot/draw/private/__bar__.m
+++ b/scripts/plot/draw/private/__bar__.m
@@ -70,17 +70,17 @@ function varargout = __bar__ (vertical, 
     if (ischar (varargin{idx}) && strcmpi (varargin{idx}, "grouped"))
       group = true;
       idx++;
     elseif (ischar (varargin{idx}) && strcmpi (varargin{idx}, "stacked"))
       group = false;
       idx++;
     elseif (ischar (varargin{idx}) && strcmpi (varargin{idx}, "histc"))
       group = true;
-      histc = true; 
+      histc = true;
       idx++;
     elseif (ischar (varargin{idx}) && strcmpi (varargin{idx}, "hist"))
       group = true;
       histc = false;
       idx++;
     else
       if ((ischar (varargin{idx}) || iscellstr (varargin{idx}))
           && ! have_line_spec)
@@ -142,17 +142,17 @@ function varargout = __bar__ (vertical, 
   ## Groups of bars are spaced by gwidth.  If gwidth is 1.0 then adjacent
   ## groups will just touch.
   if (numel (x) > 1)
     cutoff = min (diff (double (x))) / 2;
   else
     cutoff = 1;
   endif
   if (group)
-    gdelta = cutoff * gwidth / nbars; 
+    gdelta = cutoff * gwidth / nbars;
     cdelta = repmat ((1 - ((1 - cwidth) / 2)) * gdelta, size (x));
   else
     cdelta = repmat (cutoff * gwidth, size (x));
   endif
   x1 = (x - cdelta)(:)';
   x2 = (x + cdelta)(:)';
   xb = repmat ([x1; x1; x2; x2](:), 1, nbars);
 
@@ -368,17 +368,17 @@ function update_baseline (h, ~)
       set (obj.bargroup, "showbaseline", visible, "basevalue", ydata);
       break;
     endif
   endfor
 endfunction
 
 function show_baseline (h, ~, prop = "")
   persistent recursion = false;
-  
+
   ## Don't allow recursion
   if (! recursion)
     unwind_protect
       recursion = true;
       hlist = get (h, "bargroup");
       if (strcmp (prop, "showbl"))
         showbaseline = get (h, "showbaseline");
         hlist = hlist(hlist != h);  # remove current handle being updated
diff --git a/scripts/plot/draw/private/__contour__.m b/scripts/plot/draw/private/__contour__.m
--- a/scripts/plot/draw/private/__contour__.m
+++ b/scripts/plot/draw/private/__contour__.m
@@ -212,17 +212,17 @@ function add_patch_children (hg)
   lc = get (hg, "linecolor");
   lw = get (hg, "linewidth");
   ls = get (hg, "linestyle");
   filled = get (hg, "fill");
   ca = gca ();
 
   ## Turn off automatic updating of clim while adding patches
   climmode = get (ca, "climmode");
-  set (ca, "climmode", "manual"); 
+  set (ca, "climmode", "manual");
 
   if (strcmp (lc, "auto"))
     lc = "flat";
   endif
 
   if (strcmp (filled, "on"))
 
     lvl_eps = get_lvl_eps (lev);
diff --git a/scripts/plot/draw/private/__errplot__.m b/scripts/plot/draw/private/__errplot__.m
--- a/scripts/plot/draw/private/__errplot__.m
+++ b/scripts/plot/draw/private/__errplot__.m
@@ -25,17 +25,17 @@
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
 function h = __errplot__ (fstr, hax, varargin)
 
   fmt = __pltopt__ ("__errplot__", fstr);
 
   ## Set the plot type based on linestyle.
-  switch (fmt.errorstyle) 
+  switch (fmt.errorstyle)
     case "~"
       ifmt = "yerr";
     case ">"
       ifmt = "xerr";
     case "~>"
       ifmt = "xyerr";
     case "#"
       ifmt = "box";
@@ -194,17 +194,17 @@ function h = __errplot__ (fstr, hax, var
     addlistener (hax, "xscale", fcn);
     addlistener (hax, "yscale", fcn);
 
     update_data (hg, [], hl);
 
   endfor
 
   ## Process legend key
-  if (! isempty (fmt.key))    
+  if (! isempty (fmt.key))
     hlegend = [];
     fkids = get (gcf (), "children");
     for i = 1 : numel (fkids)
       if (   strcmp (get (fkids(i), "type"), "axes")
           && strcmp (get (fkids(i), "tag"), "legend"))
         udata = get (fkids(i), "userdata");
         if (! isempty (intersect (udata.handle, gca ())))
           hlegend = fkids (i);
@@ -214,17 +214,17 @@ function h = __errplot__ (fstr, hax, var
     endfor
 
     if (isempty (hlegend))
       hlgnd = [];
       tlgnd = {};
     else
       [hlgnd, tlgnd] = __getlegenddata__ (hlegend);
     endif
- 
+
     hlgnd(end+1) = hg;
     tlgnd(end+1) = fmt.key;
 
     legend (gca (), hlgnd, tlgnd);
   endif
 
 endfunction
 
diff --git a/scripts/plot/draw/private/__ezplot__.m b/scripts/plot/draw/private/__ezplot__.m
--- a/scripts/plot/draw/private/__ezplot__.m
+++ b/scripts/plot/draw/private/__ezplot__.m
@@ -20,17 +20,17 @@
 ## @deftypefn {Function File} {[@var{h}, @var{needusage}] =} __ezplot__ (@var{pltfunc}, @var{varargin})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Overview: This function is the back-end for the 9 ez* plot functions.
 ##           As such, most of the function is actually dedicated to sorting
 ##           out the inputs and verifying that the particular ez* function
 ##           called was called correctly.  The actual plotting occurs near
-##           the end in an unwind_protect block. 
+##           the end in an unwind_protect block.
 
 function [h, needusage] = __ezplot__ (pltfunc, varargin)
 
   ezfunc = ["ez" pltfunc];
 
   [hax, varargin, nargin] = __plt_get_axis_arg__ (ezfunc, varargin{:});
 
   ## Define outputs early in case of shorting out of function with return;
@@ -50,21 +50,21 @@ function [h, needusage] = __ezplot__ (pl
   nargs = 1;
   switch (pltfunc)
     case "plot"
       ## defaults already set
 
     case "plot3"
       isplot  = false;
       isplot3 = true;
-  
+
     case "polar"
       isplot  = false;
       ispolar = true;
-    
+
     otherwise
       ## contour, mesh, surf plots
       isplot  = false;
       nargs = 2;
 
   endswitch
 
   parametric = false;
@@ -492,17 +492,17 @@ endfunction
 ## Find: 1) range of function where there are not NaN values,
 ##       2) function is changing (not just flat surface)
 function domain = find_valid_domain (X, Y, Z);
 
   if (isvector (Z))
     ## 2-D data for isplot
     domain = [X(1) X(end)];
 
-    ## Guess a range which includes the "mass" of the data by using a 
+    ## Guess a range which includes the "mass" of the data by using a
     ## median-based approach.  The center 3/4 of the data is used to
     ## determine the range of the data.
     ## This seems to be vaguely what Matlab does, but can't be sure.
     XX = sort (Z(isfinite (Z)));
     if (length (X) > 4)
       irlo = XX(fix (1/8 * length (XX)));
       irhi = XX(fix (7/8 * length (XX)));
       d = irhi - irlo;
@@ -518,25 +518,25 @@ function domain = find_valid_domain (X, 
     idx = 2 : length (Z);
     idx = find (((Z(idx) > yrange(2) / 2) & (Z(idx-1) < yrange(1) / 2)) |
                 ((Z(idx) < yrange(1) / 2) & (Z(idx-1) > yrange(2) / 2)));
     Z(idx) = NaN;
     #}
 
   else
     ## 3-D data such as mesh, surf
-    Zfinite = ! isnan (Z); 
-    Zrows = any (Zfinite, 2); 
-    rmin = find (Zrows, 1, "first"); 
-    rmax = find (Zrows, 1, "last"); 
-    Zcols = any (Zfinite, 1); 
-    cmin = find (Zcols, 1, "first"); 
-    cmax = find (Zcols, 1, "last"); 
+    Zfinite = ! isnan (Z);
+    Zrows = any (Zfinite, 2);
+    rmin = find (Zrows, 1, "first");
+    rmax = find (Zrows, 1, "last");
+    Zcols = any (Zfinite, 1);
+    cmin = find (Zcols, 1, "first");
+    cmax = find (Zcols, 1, "last");
 
-    ## Handle nasty case of all NaNs 
+    ## Handle nasty case of all NaNs
     if (isempty (rmin))
       rmin = 1, rmax = rows (Z);
     endif
     if (isempty (cmin))
       cmin = 1, cmax = columns (Z);
     endif
 
     if (   ! any (isnan (Z([rmin, rmax],:)(:)))
@@ -545,21 +545,21 @@ function domain = find_valid_domain (X, 
       ## Technically, this calculation might be better done with actual
       ## deltaX, deltaY values.  But, data is usually meshgridded
       ## (constant spacing) so working with deltaROW#, deltaCOL# is fine.
       [Zx, Zy] = gradient (Z(rmin:rmax, cmin:cmax));
       Zgrad = sqrt (Zx.^2 + Zy.^2);
       slope = ((max (Z(:)) - min (Z(:)))
                 / sqrt ((rmax - rmin)^2 + (cmax - cmin)^2));
       slope /= 125;  # threshold for discarding points.
-      Zrows = any (Zgrad > slope, 2); 
-      rmin += find (Zrows, 1, "first") - 1; 
-      rmax += find (Zrows, 1, "last") - rows (Zrows); 
-      Zcols = any (Zgrad > slope, 1); 
-      cmin += find (Zcols, 1, "first") - 1; 
-      cmax += find (Zcols, 1, "last") - columns (Zcols); 
+      Zrows = any (Zgrad > slope, 2);
+      rmin += find (Zrows, 1, "first") - 1;
+      rmax += find (Zrows, 1, "last") - rows (Zrows);
+      Zcols = any (Zgrad > slope, 1);
+      cmin += find (Zcols, 1, "first") - 1;
+      cmax += find (Zcols, 1, "last") - columns (Zcols);
     endif
 
     domain = [X(1,cmin) X(1,cmax) Y(rmin,1) Y(rmax,1)];
   endif
-  
+
 endfunction
 
diff --git a/scripts/plot/draw/private/__patch__.m b/scripts/plot/draw/private/__patch__.m
--- a/scripts/plot/draw/private/__patch__.m
+++ b/scripts/plot/draw/private/__patch__.m
@@ -79,17 +79,17 @@ function [h, failed] = __patch__ (p, var
         endif
       elseif (nargin > 2 && all (is_numeric_arg(1:2)))
         x = varargin{1};
         y = varargin{2};
         z = [];
         iarg = 3;
         if (rem (nargin - iarg, 2) == 1)
           c = varargin {iarg};
-          iarg++; 
+          iarg++;
         else
           c = [];
         endif
       endif
 
       if (isvector (x))
         x = x(:);
         y = y(:);
diff --git a/scripts/plot/draw/private/__stem__.m b/scripts/plot/draw/private/__stem__.m
--- a/scripts/plot/draw/private/__stem__.m
+++ b/scripts/plot/draw/private/__stem__.m
@@ -170,21 +170,21 @@ endfunction
 
 function [x, y, z, dofill, lc, ls, mc, ms, args] = check_stem_arg (have_z, varargin)
 
   if (have_z)
     caller = "stem3";
   else
     caller = "stem";
   endif
-  nargin = nargin - 1;  # account for have_z argument 
+  nargin = nargin - 1;  # account for have_z argument
 
   num_numeric = find (cellfun ("isclass", varargin, "char"), 1) - 1;
   if (isempty (num_numeric))
-    num_numeric = nargin;     
+    num_numeric = nargin;
   endif
 
   if (num_numeric < 1 || num_numeric > 3)
     print_usage (caller);
   endif
 
   x = y = z = [];
   if (num_numeric == 1)
diff --git a/scripts/plot/draw/rectangle.m b/scripts/plot/draw/rectangle.m
--- a/scripts/plot/draw/rectangle.m
+++ b/scripts/plot/draw/rectangle.m
@@ -20,17 +20,17 @@
 ## @deftypefn  {Function File} {} rectangle ()
 ## @deftypefnx {Function File} {} rectangle (@dots{}, "Position", @var{pos})
 ## @deftypefnx {Function File} {} rectangle (@dots{}, "Curvature", @var{curv})
 ## @deftypefnx {Function File} {} rectangle (@dots{}, "EdgeColor", @var{ec})
 ## @deftypefnx {Function File} {} rectangle (@dots{}, "FaceColor", @var{fc})
 ## @deftypefnx {Function File} {} rectangle (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} rectangle (@dots{})
 ## Draw a rectangular patch defined by @var{pos} and @var{curv}.
-## 
+##
 ## The variable @code{@var{pos}(1:2)} defines the lower left-hand corner of
 ## the patch and @code{@var{pos}(3:4)} defines its width and height.  By
 ## default, the value of @var{pos} is @code{[0, 0, 1, 1]}.
 ##
 ## The variable @var{curv} defines the curvature of the sides of the rectangle
 ## and may be a scalar or two-element vector with values between 0 and 1.
 ## A value of 0 represents no curvature of the side, whereas a value of 1
 ## means that the side is entirely curved into the arc of a circle.
@@ -40,18 +40,18 @@
 ## If @var{curv} is a scalar, it represents the curvature of the shorter of the
 ## two sides of the rectangle and the curvature of the other side is defined
 ## by
 ##
 ## @example
 ## min (pos(1:2)) / max (pos(1:2)) * curv
 ## @end example
 ##
-## Additional property/value pairs are passed to the underlying patch command. 
-## 
+## Additional property/value pairs are passed to the underlying patch command.
+##
 ## If the first argument @var{hax} is an axes handle, then plot into this axis,
 ## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a graphics handle to the created
 ## rectangle object.
 ## @end deftypefn
 ## @seealso{patch, line, cylinder, ellipsoid, sphere}
 
@@ -222,17 +222,17 @@ function update_data (h, ~)
     end_unwind_protect
   endif
 endfunction
 
 function update_props (h, ~)
   kids = get (h, "children");
   set (kids, {"edgecolor", "linewidth", "linestyle", "facecolor"},
      get (h, {"edgecolor", "linewidth", "linestyle", "facecolor"}));
-  
+
 endfunction
 
 
 %!demo
 %! clf;
 %! axis equal;
 %! rectangle ('Position', [0.05, 0.05, 0.9, 0.9], 'Curvature', [0.5, 0.5]);
 %! title ('rectangle() with corners curved');
diff --git a/scripts/plot/draw/ribbon.m b/scripts/plot/draw/ribbon.m
--- a/scripts/plot/draw/ribbon.m
+++ b/scripts/plot/draw/ribbon.m
@@ -91,17 +91,17 @@ function h = ribbon (varargin)
       yy = x(:,c);
       xx = [c - width / 2, c + width / 2];
       [xx, yy] = meshgrid (xx, yy);
       cc = repmat (c, size (zz));
       htmp(c) = surface (xx, yy, zz, cc);
     endfor
 
     if (! ishold ())
-      set (hax, "view", [-37.5, 30], "box", "off", 
+      set (hax, "view", [-37.5, 30], "box", "off",
                 "xgrid", "on", "ygrid", "on", "zgrid", "on");
     endif
 
   unwind_protect_cleanup
     if (! isempty (oldfig))
       set (0, "currentfigure", oldfig);
     endif
   end_unwind_protect
diff --git a/scripts/plot/draw/rose.m b/scripts/plot/draw/rose.m
--- a/scripts/plot/draw/rose.m
+++ b/scripts/plot/draw/rose.m
@@ -35,17 +35,17 @@
 ## given by the number of elements in @var{bins}.
 ##
 ## If the first argument @var{hax} is an axes handle, then plot into this axis,
 ## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a vector of graphics handles to the
 ## line objects representing each histogram.
 ##
-## If two output arguments are requested then no plot is made and 
+## If two output arguments are requested then no plot is made and
 ## the polar vectors necessary to plot the histogram are returned instead.
 ##
 ## @example
 ## @group
 ## [th, r] = rose ([2*randn(1e5,1), pi + 2*randn(1e5,1)]);
 ## polar (th, r);
 ## @end group
 ## @end example
diff --git a/scripts/plot/draw/scatter.m b/scripts/plot/draw/scatter.m
--- a/scripts/plot/draw/scatter.m
+++ b/scripts/plot/draw/scatter.m
@@ -49,17 +49,17 @@
 ## Additional property/value pairs are passed directly to the underlying
 ## patch object.
 ##
 ## If the first argument @var{hax} is an axes handle, then plot into this axis,
 ## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a graphics handle to the created patch
 ## object.
-## 
+##
 ## Example:
 ##
 ## @example
 ## @group
 ## x = randn (100, 1);
 ## y = randn (100, 1);
 ## scatter (x, y, [], sqrt (x.^2 + y.^2));
 ## @end group
@@ -77,17 +77,17 @@ function retval = scatter (varargin)
   endif
 
   oldfig = [];
   if (! isempty (hax))
     oldfig = get (0, "currentfigure");
   endif
   unwind_protect
     hax = newplot (hax);
-    
+
     htmp = __scatter__ (hax, 2, "scatter", varargin{:});
   unwind_protect_cleanup
     if (! isempty (oldfig))
       set (0, "currentfigure", oldfig);
     endif
   end_unwind_protect
 
   if (nargout > 0)
diff --git a/scripts/plot/draw/scatter3.m b/scripts/plot/draw/scatter3.m
--- a/scripts/plot/draw/scatter3.m
+++ b/scripts/plot/draw/scatter3.m
@@ -74,17 +74,17 @@ function retval = scatter3 (varargin)
   endif
 
   oldfig = [];
   if (! isempty (hax))
     oldfig = get (0, "currentfigure");
   endif
   unwind_protect
     hax = newplot (hax);
-    
+
     htmp = __scatter__ (hax, 3, "scatter3", varargin{:});
 
     if (! ishold (hax))
       set (hax, "view", [-37.5, 30], "box", "off",
                 "xgrid", "on", "ygrid", "on", "zgrid", "on");
     endif
   unwind_protect_cleanup
     if (! isempty (oldfig))
diff --git a/scripts/plot/draw/semilogx.m b/scripts/plot/draw/semilogx.m
--- a/scripts/plot/draw/semilogx.m
+++ b/scripts/plot/draw/semilogx.m
@@ -22,17 +22,17 @@
 ## @deftypefnx {Function File} {} semilogx (@var{x}, @var{y}, @var{property}, @var{value}, @dots{})
 ## @deftypefnx {Function File} {} semilogx (@var{x}, @var{y}, @var{fmt})
 ## @deftypefnx {Function File} {} semilogx (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} semilogx (@dots{})
 ## Produce a 2-D plot using a logarithmic scale for the x-axis.
 ##
 ## See the documentation of @code{plot} for a description of the
 ## arguments that @code{semilogx} will accept.
-## 
+##
 ## If the first argument @var{hax} is an axes handle, then plot into this axis,
 ## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a graphics handle to the created plot.
 ## @seealso{plot, semilogy, loglog}
 ## @end deftypefn
 
 ## Author: jwe
diff --git a/scripts/plot/draw/shrinkfaces.m b/scripts/plot/draw/shrinkfaces.m
--- a/scripts/plot/draw/shrinkfaces.m
+++ b/scripts/plot/draw/shrinkfaces.m
@@ -20,17 +20,17 @@
 ## @deftypefn  {Function File} {} shrinkfaces (@var{p}, @var{sf})
 ## @deftypefnx {Function File} {@var{nfv} =} shrinkfaces (@var{p}, @var{sf})
 ## @deftypefnx {Function File} {@var{nfv} =} shrinkfaces (@var{fv}, @var{sf})
 ## @deftypefnx {Function File} {@var{nfv} =} shrinkfaces (@var{f}, @var{v}, @var{sf})
 ## @deftypefnx {Function File} {[@var{nf}, @var{nv}] =} shrinkfaces (@dots{})
 ##
 ## Reduce the faces area for a given patch, structure or explicit faces
 ## and points matrices by a scale factor @var{sf}.  The structure
-## @var{fv} must contain the fields @qcode{"faces"} and @qcode{"vertices"}. 
+## @var{fv} must contain the fields @qcode{"faces"} and @qcode{"vertices"}.
 ## If the factor @var{sf} is omitted then a default of 0.3 is used.
 ##
 ## Given a patch handle as the first input argument and no output
 ## parameters, perform the shrinking of the patch faces in place and
 ## redraw the patch.
 ##
 ## If called with one output argument, return a structure with fields
 ## @qcode{"faces"}, @qcode{"vertices"}, and @qcode{"facevertexcdata"}
@@ -64,17 +64,17 @@
 
 ## Author: Martin Helm <martin@mhelm.de>
 
 function [nf, nv] = shrinkfaces (varargin)
 
   if (nargin < 1 || nargin > 3 || nargout > 2)
     print_usage ();
   endif
-  
+
   sf = 0.3;
   p = varargin{1};
   colors = [];
 
   if (ishandle (p) && nargin < 3)
     faces = get (p, "Faces");
     vertices = get (p, "Vertices");
     colors = get (p, "FaceVertexCData");
@@ -94,17 +94,17 @@ function [nf, nv] = shrinkfaces (varargi
     faces = p;
     vertices = varargin{2};
     if (nargin == 3)
       sf = varargin{3};
     endif
   else
     print_usage ();
   endif
-  
+
   if (! isscalar (sf) || sf <= 0)
     error ("shrinkfaces: scale factor must be a positive scalar");
   endif
 
   n = columns (vertices);
   if (n < 2 || n > 3)
     error ("shrinkfaces: only 2-D and 3-D patches are supported");
   endif
@@ -125,17 +125,17 @@ function [nf, nv] = shrinkfaces (varargi
   endif
   sv = rows (v);
   ## we have to deal with a probably very large number of vertices, so
   ## use sparse we use as midpoint (1/m, ..., 1/m) in generalized
   ## barycentric coordinates.
   midpoints = full (kron ( speye (sv / m), ones (m, m) / m) * sparse (v));
   v = sqrt (sf) * (v - midpoints) + midpoints;
   f = reshape (1:sv, m, sv / m)';
-  
+
   switch (nargout)
     case 0
       if (ishandle (p))
         ## avoid exceptions
         set (p, "FaceVertexCData", [], "CData", []);
         set (p, "Vertices", v, "Faces", f, "FaceVertexCData", c);
       else
         nf = struct ("faces", f, "vertices", v, "facevertexcdata", c);
diff --git a/scripts/plot/draw/sombrero.m b/scripts/plot/draw/sombrero.m
--- a/scripts/plot/draw/sombrero.m
+++ b/scripts/plot/draw/sombrero.m
@@ -31,17 +31,17 @@
 ##
 ## @example
 ## z = sin (sqrt (x^2 + y^2)) / (sqrt (x^2 + y^2))
 ## @end example
 ##
 ## @end ifnottex
 ## Called without a return argument, @code{sombrero} plots the surface of the
 ## above function over the meshgrid [-8,8] using @code{surf}.
-## 
+##
 ## If @var{n} is a scalar the plot is made with @var{n} grid lines.
 ## The default value for @var{n} is 41.
 ##
 ## When called with output arguments, return the data for the function
 ## evaluated over the meshgrid.  This can subsequently be plotted with
 ## @code{surf (@var{x}, @var{y}, @var{z})}.
 ##
 ## @seealso{peaks, meshgrid, mesh, surf}
diff --git a/scripts/plot/draw/sphere.m b/scripts/plot/draw/sphere.m
--- a/scripts/plot/draw/sphere.m
+++ b/scripts/plot/draw/sphere.m
@@ -72,17 +72,17 @@ function [xx, yy, zz] = sphere (varargin
     zz = z;
   else
     oldfig = [];
     if (! isempty (hax))
       oldfig = get (0, "currentfigure");
     endif
     unwind_protect
       hax = newplot (hax);
-    
+
       surf (x, y, z);
     unwind_protect_cleanup
       if (! isempty (oldfig))
         set (0, "currentfigure", oldfig);
       endif
     end_unwind_protect
   endif
 
diff --git a/scripts/plot/draw/stairs.m b/scripts/plot/draw/stairs.m
--- a/scripts/plot/draw/stairs.m
+++ b/scripts/plot/draw/stairs.m
@@ -24,17 +24,17 @@
 ## @deftypefnx {Function File} {} stairs (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} stairs (@dots{})
 ## @deftypefnx {Function File} {[@var{xstep}, @var{ystep}] =} stairs (@dots{})
 ## Produce a stairstep plot.
 ##
 ## The arguments @var{x} and @var{y} may be vectors or matrices.
 ## If only one argument is given, it is taken as a vector of Y values
 ## and the X coordinates are taken to be the indices of the elements.
-## 
+##
 ## The style to use for the plot can be defined with a line style @var{style}
 ## of the same format as the @code{plot} command.
 ##
 ## Multiple property/value pairs may be specified, but they must appear in
 ## pairs.
 ##
 ## If the first argument @var{hax} is an axis handle, then plot into this axis,
 ## rather than the current axis handle returned by @code{gca}.
diff --git a/scripts/plot/draw/stem.m b/scripts/plot/draw/stem.m
--- a/scripts/plot/draw/stem.m
+++ b/scripts/plot/draw/stem.m
@@ -94,17 +94,17 @@
 ##
 ## @item marker
 ## The marker symbol to use at the top of each stem.  (Default: @qcode{"o"})
 ##
 ## @item markeredgecolor
 ## The edge color of the marker.  (Default: @qcode{"color"} property)
 ##
 ## @item markerfacecolor
-## The color to use for @nospell{"filling"} the marker.  
+## The color to use for @nospell{"filling"} the marker.
 ## (Default: @qcode{"none"} [unfilled])
 ##
 ## @item markersize
 ## The size of the marker.  (Default: 6)
 ##
 ## @item baseline
 ## The handle of the line object which implements the baseline.  Use @code{set}
 ## with the returned handle to change graphic properties of the baseline.
diff --git a/scripts/plot/draw/stemleaf.m b/scripts/plot/draw/stemleaf.m
--- a/scripts/plot/draw/stemleaf.m
+++ b/scripts/plot/draw/stemleaf.m
@@ -44,38 +44,38 @@
 ##
 ## @example
 ## @group
 ##
 ##         Fenced Letter Display
 ## #% nx|___________________     nx = numel (x)
 ## M% mi|       md         |     mi median index, md median
 ## H% hi|hl              hu| hs  hi lower hinge index, hl,hu hinges,
-## 1    |x(1)         x(nx)|     hs h_spreadx(1), x(nx) first 
+## 1    |x(1)         x(nx)|     hs h_spreadx(1), x(nx) first
 ##            _______            and last data value.
 ##      ______|step |_______     step 1.5*h_spread
 ##     f|ifl            ifh|     inner fence, lower and higher
 ##      |nfl            nfh|     no.\ of data points within fences
 ##     F|ofl            ofh|     outer fence, lower and higher
 ##      |nFl            nFh|     no.\ of data points outside outer
 ##                               fences
 ## @end group
 ## @end example
 ##
 ## The stem-and-leaf plot shows on each line the stem value followed by the
 ## string made up of the leaf digits.  If the @var{stem_sz} is not 1 the
 ## successive leaf values are separated by ",".
 ##
 ## With no return argument, the plot is immediately displayed.  If an output
-## argument is provided, the plot is returned as an array of strings. 
+## argument is provided, the plot is returned as an array of strings.
 ##
 ## The leaf digits are not sorted.  If sorted leaf values are desired, use
 ## @code{@var{xs} = sort (@var{x})} before calling @code{stemleaf (@var{xs})}.
 ##
-## The stem and leaf plot and associated displays are described in: 
+## The stem and leaf plot and associated displays are described in:
 ## Ch. 3, @cite{Exploratory Data Analysis} by J. W. Tukey, Addison-Wesley, 1977.
 ## @seealso{hist, printd}
 ## @end deftypefn
 
 ## Author: Michael D. Godfrey <michaeldgodfrey@gmail.com>
 ## Description: Compute stem and leaf plot
 
 function plotstr = stemleaf (x, caption, stem_sz)
@@ -199,17 +199,17 @@ function plotstr = stemleaf (x, caption,
   plot_out = sprintf ("       Data: %s", caption);
   plot_out = [plot_out; sprintf(" ")];
   plot_out = [plot_out; sprintf("         Fenced Letter Display")];
   plot_out = [plot_out; sprintf(" ")];
   plot_out = [plot_out; sprintf("     #%3d|___________________", nx)];
   plot_out = [plot_out; sprintf("     M%3d|       %5d      |", mdidx, md)];
   plot_out = [plot_out; sprintf("     H%3d|%5d        %5d|   %d", hlidx, hl, hu, h_spread)];
   plot_out = [plot_out; sprintf("     1   |%5d        %5d|", xs(1), xs(nx))];
-  plot_out = [plot_out; sprintf("               _______")];   
+  plot_out = [plot_out; sprintf("               _______")];
   plot_out = [plot_out; sprintf("         ______|%5d|_______",step)];
   plot_out = [plot_out; sprintf("        f|%5d        %5d|", i_fence_l, i_fence_h)];
   plot_out = [plot_out; sprintf("         |%5d        %5d|  out", n_out_l, n_out_h)];
   plot_out = [plot_out; sprintf("        F|%5d        %5g|", o_fence_l, o_fence_h)];
   plot_out = [plot_out; sprintf("         |%5d        %5d|  far",n_far_l,n_far_h)];
   plot_out = [plot_out; " "];
 
   ## Determine stem values
@@ -283,17 +283,17 @@ function plotstr = stemleaf (x, caption,
     else
       line = "";
     endif
 
     if (! isempty (lf_str) || stems(kx) == 0 || stems(kx-1) == 0)
       plot_out = [plot_out; line];
       new_line = 1;
     else
-      if (new_line == 1) 
+      if (new_line == 1)
         plot_out = [plot_out; "     :"];  # just print one : if no leaves
         new_line = 0;
       endif
     endif
 
   endfor    # kx = 2: numel (stems)
 
   if (nargout == 0)
@@ -344,23 +344,23 @@ endfunction
 %!      122 109 124 115 43 120 43 27 27 18 28 48 125 107 114 34 133 45 120 30  ...
 %!      127 31 116 146 21 23 30 10 20 21 30 0 100 110 1 20 0];
 %! x = sort (x);
 %! rexp = char (
 %! "       Data: test minus to plus"    ,
 %! " "                                  ,
 %! "         Fenced Letter Display"     ,
 %! " "                                  ,
-%! "     #138|___________________"      ,     
-%! "     M 69|          52      |"      ,     
+%! "     #138|___________________"      ,
+%! "     M 69|          52      |"      ,
 %! "     H 35|   30          116|   86" ,
 %! "     1   |  -28          146|"      ,
 %! "               _______"             ,
 %! "         ______|  129|_______"      ,
-%! "        f|  -99          245|"      ,     
+%! "        f|  -99          245|"      ,
 %! "         |    0            0|  out" ,
 %! "        F| -228          374|"      ,
 %! "         |    0            0|  far" ,
 %! " "                                  ,
 %! "  -2 | 82"                          ,
 %! "  -1 | 3"                           ,
 %! "  -0 | 2"                           ,
 %! "   0 | 00177"                       ,
@@ -384,23 +384,23 @@ endfunction
 %!test
 %! ## positive values above 0
 %! x = [5 22 12 28 52 39 12 11 11 42 38 44 18 44];
 %! rexp = char (
 %! "       Data: positive values above 0",
 %! " "                                   ,
 %! "         Fenced Letter Display"      ,
 %! " "                                   ,
-%! "     # 14|___________________"       ,     
-%! "     M  7|          22      |"       ,     
+%! "     # 14|___________________"       ,
+%! "     M  7|          22      |"       ,
 %! "     H  4|   12           42|   30"  ,
 %! "     1   |    5           52|"       ,
 %! "               _______"              ,
 %! "         ______|   45|_______"       ,
-%! "        f|  -33           87|"       ,     
+%! "        f|  -33           87|"       ,
 %! "         |    0            0|  out"  ,
 %! "        F|  -78          132|"       ,
 %! "         |    0            0|  far"  ,
 %! " "                                   ,
 %! "   0 | 5"                            ,
 %! "   1 | 22118"                        ,
 %! "   2 | 28"                           ,
 %! "   3 | 98"                           ,
@@ -413,23 +413,23 @@ endfunction
 %! ## negative values below 0
 %! x = [5 22 12 28 52 39 12 11 11 42 38 44 18 44];
 %! x = -x;
 %! rexp = char (
 %! "       Data: negative values below 0",
 %! " "                                   ,
 %! "         Fenced Letter Display"      ,
 %! " "                                   ,
-%! "     # 14|___________________"       ,     
-%! "     M  7|         -28      |"       ,     
+%! "     # 14|___________________"       ,
+%! "     M  7|         -28      |"       ,
 %! "     H  4|  -42          -12|   30"  ,
 %! "     1   |  -52           -5|"       ,
 %! "               _______"              ,
 %! "         ______|   45|_______"       ,
-%! "        f|  -87           33|"       ,     
+%! "        f|  -87           33|"       ,
 %! "         |    0            0|  out"  ,
 %! "        F| -132           78|"       ,
 %! "         |    0            0|  far"  ,
 %! " "                                   ,
 %! "  -5 | 2"                            ,
 %! "  -4 | 244"                          ,
 %! "  -3 | 98"                           ,
 %! "  -2 | 28"                           ,
@@ -441,23 +441,23 @@ endfunction
 %!test
 %! ## positive values from 0
 %! x = [22 12 28 52 39 2 12 0 11 11 42 38 44 18 44];
 %! rexp = char (
 %! "       Data: positive values from 0",
 %! " "                                  ,
 %! "         Fenced Letter Display"     ,
 %! " "                                  ,
-%! "     # 15|___________________"      ,     
-%! "     M  8|          22      |"      ,     
+%! "     # 15|___________________"      ,
+%! "     M  8|          22      |"      ,
 %! "     H  4|   11           42|   31" ,
 %! "     1   |    0           52|"      ,
 %! "               _______"             ,
 %! "         ______|   46|_______"      ,
-%! "        f|  -35           88|"      ,     
+%! "        f|  -35           88|"      ,
 %! "         |    0            0|  out" ,
 %! "        F|  -82          135|"      ,
 %! "         |    0            0|  far" ,
 %! " "                                  ,
 %! "   0 | 20"                          ,
 %! "   1 | 22118"                       ,
 %! "   2 | 28"                          ,
 %! "   3 | 98"                          ,
@@ -470,23 +470,23 @@ endfunction
 %! ## negative values from 0
 %! x = [22 12 28 52 39 2 12 0 11 11 42 38 44 18 44];
 %! x = -x;
 %! rexp = char (
 %! "       Data: negative values from 0",
 %! " "                                  ,
 %! "         Fenced Letter Display"     ,
 %! " "                                  ,
-%! "     # 15|___________________"      ,     
-%! "     M  8|         -22      |"      ,     
+%! "     # 15|___________________"      ,
+%! "     M  8|         -22      |"      ,
 %! "     H  4|  -42          -11|   31" ,
 %! "     1   |  -52            0|"      ,
 %! "               _______"             ,
 %! "         ______|   46|_______"      ,
-%! "        f|  -88           35|"      ,     
+%! "        f|  -88           35|"      ,
 %! "         |    0            0|  out" ,
 %! "        F| -135           82|"      ,
 %! "         |    0            0|  far" ,
 %! " "                                  ,
 %! "  -5 | 2"                           ,
 %! "  -4 | 244"                         ,
 %! "  -3 | 98"                          ,
 %! "  -2 | 28"                          ,
@@ -498,23 +498,23 @@ endfunction
 %!test
 %! ## both +0 and -0 present
 %! x = [-9 -7 -0 0 -0];
 %! rexp = char (
 %! "       Data: both +0 and -0 present",
 %! " "                                  ,
 %! "         Fenced Letter Display"     ,
 %! " "                                  ,
-%! "     #  5|___________________"      ,     
-%! "     M  3|           0      |"      ,     
+%! "     #  5|___________________"      ,
+%! "     M  3|           0      |"      ,
 %! "     H  2|   -7            0|   7"  ,
 %! "     1   |   -9            0|"      ,
 %! "               _______"             ,
 %! "         ______|   10|_______"      ,
-%! "        f|  -17           10|"      ,     
+%! "        f|  -17           10|"      ,
 %! "         |    0            0|  out" ,
 %! "        F|  -28           21|"      ,
 %! "         |    0            0|  far" ,
 %! " "                                  ,
 %! "  -0 | 9700"                        ,
 %! "   0 | 0"                           );
 %! r = stemleaf (x, "both +0 and -0 present");
 %! assert (r, rexp);
@@ -522,23 +522,23 @@ endfunction
 %!test
 %! ## both <= 0 and -0 present
 %! x = [-9 -7 0 -0];
 %! rexp = char (
 %! "       Data: both <= 0 and -0 present",
 %! " "                                    ,
 %! "         Fenced Letter Display"       ,
 %! " "                                    ,
-%! "     #  4|___________________"        ,     
-%! "     M  2|          -7      |"        ,     
+%! "     #  4|___________________"        ,
+%! "     M  2|          -7      |"        ,
 %! "     H  1|   -9            0|   9"    ,
 %! "     1   |   -9            0|"        ,
 %! "               _______"               ,
 %! "         ______|   13|_______"        ,
-%! "        f|  -22           13|"        ,     
+%! "        f|  -22           13|"        ,
 %! "         |    0            0|  out"   ,
 %! "        F|  -36           27|"        ,
 %! "         |    0            0|  far"   ,
 %! " "                                    ,
 %! "  -0 | 970"                           ,
 %! "   0 | 0"                             );
 %! r = stemleaf (x, "both <= 0 and -0 present");
 %! assert (r, rexp);
@@ -547,17 +547,17 @@ endfunction
 %! ##   Example from EDA: Chevrolet Prices pg. 30
 %! x = [150 250 688 695 795 795 895 895 895 ...
 %!      1099 1166 1333 1499 1693 1699 1775 1995];
 %! rexp = char (
 %! "       Data: Chevrolet Prices EDA pg.30",
 %! " "                                      ,
 %! "         Fenced Letter Display"         ,
 %! " "                                      ,
-%! "     # 17|___________________"          ,          
+%! "     # 17|___________________"          ,
 %! "     M  9|         895      |"          ,
 %! "     H  5|  795         1499|   704"    ,
 %! "     1   |  150         1995|"          ,
 %! "               _______"                 ,
 %! "         ______| 1056|_______"          ,
 %! "        f| -261         2555|"          ,
 %! "         |    0            0|  out"     ,
 %! "        F|-1317         3611|"          ,
diff --git a/scripts/plot/draw/surf.m b/scripts/plot/draw/surf.m
--- a/scripts/plot/draw/surf.m
+++ b/scripts/plot/draw/surf.m
@@ -63,17 +63,17 @@ function retval = surf (varargin)
   [hax, varargin] = __plt_get_axis_arg__ ("surf", varargin{:});
 
   oldfig = [];
   if (! isempty (hax))
     oldfig = get (0, "currentfigure");
   endif
   unwind_protect
     hax = newplot (hax);
-    
+
     htmp = surface (varargin{:});
 
     if (! ishold (hax))
       set (hax, "view", [-37.5, 30],
                 "xgrid", "on", "ygrid", "on", "zgrid", "on");
     endif
 
   unwind_protect_cleanup
diff --git a/scripts/plot/draw/surface.m b/scripts/plot/draw/surface.m
--- a/scripts/plot/draw/surface.m
+++ b/scripts/plot/draw/surface.m
@@ -31,17 +31,17 @@
 ## If @var{x} and @var{y} are vectors, then a typical vertex is
 ## (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus, columns of @var{z} correspond
 ## to different @var{x} values and rows of @var{z} correspond to different
 ## @var{y} values.  If only a single input @var{z} is given then @var{x} is
 ## taken to be @code{1:rows (@var{z})} and @var{y} is
 ## @code{1:columns (@var{z})}.
 ##
 ## Any property/value input pairs are assigned to the surface object.
-## 
+##
 ## If the first argument @var{hax} is an axes handle, then plot into this axis,
 ## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a graphics handle to the created
 ## surface object.
 ## @seealso{surf, mesh, patch, line}
 ## @end deftypefn
 
@@ -51,17 +51,17 @@ function h = surface (varargin)
 
   [hax, varargin] = __plt_get_axis_arg__ ("surface", varargin{:});
 
   if (isempty (hax))
     hax = gca ();
   else
     hax = hax(1);
   endif
-  
+
   [htmp, bad_usage] = __surface__ (hax, varargin{:});
 
   if (bad_usage)
     print_usage ();
   endif
 
   if (nargout > 0)
     h = htmp;
diff --git a/scripts/plot/draw/surfc.m b/scripts/plot/draw/surfc.m
--- a/scripts/plot/draw/surfc.m
+++ b/scripts/plot/draw/surfc.m
@@ -65,17 +65,17 @@ function h = surfc (varargin)
   endif
 
   oldfig = [];
   if (! isempty (hax))
     oldfig = get (0, "currentfigure");
   endif
   unwind_protect
     hax = newplot (hax);
-    
+
     htmp = surface (varargin{:});
 
     set (htmp, "facecolor", "flat");
     if (! ishold ())
       set (hax, "view", [-37.5, 30],
                 "xgrid", "on", "ygrid", "on", "zgrid", "on",
                 "xlimmode", "manual", "ylimmode", "manual");
     endif
diff --git a/scripts/plot/draw/surfl.m b/scripts/plot/draw/surfl.m
--- a/scripts/plot/draw/surfl.m
+++ b/scripts/plot/draw/surfl.m
@@ -124,17 +124,17 @@ function h = surfl (varargin)
   if (isnumeric (varargin{end}))
     len = numel (varargin{end});
     lastarg = varargin{end};
     if (len == 3)
       lv = lastarg;
       varargin(end) = [];
       have_lv = true;
     elseif (len == 2)
-      [lv(1), lv(2), lv(3)] = sph2cart ((lastarg(1) - 90) * pi/180, 
+      [lv(1), lv(2), lv(3)] = sph2cart ((lastarg(1) - 90) * pi/180,
                                          lastarg(2) * pi/180,
                                          1.0);
       varargin(end) = [];
       have_lv = true;
     endif
   endif
 
   oldfig = [];
diff --git a/scripts/plot/draw/surfnorm.m b/scripts/plot/draw/surfnorm.m
--- a/scripts/plot/draw/surfnorm.m
+++ b/scripts/plot/draw/surfnorm.m
@@ -115,29 +115,29 @@ function [Nx, Ny, Nz] = surfnorm (vararg
 
   if (nargout == 0)
     oldfig = [];
     if (! isempty (hax))
       oldfig = get (0, "currentfigure");
     endif
     unwind_protect
       hax = newplot (hax);
-      
+
       surf (x, y, z, varargin{ioff:end});
       old_hold_state = get (hax, "nextplot");
       unwind_protect
         set (hax, "nextplot", "add");
         plot3 ([x(:)'; x(:).' + nx(:).' ; NaN(size(x(:).'))](:),
                [y(:)'; y(:).' + ny(:).' ; NaN(size(y(:).'))](:),
                [z(:)'; z(:).' + nz(:).' ; NaN(size(z(:).'))](:),
                varargin{ioff:end});
       unwind_protect_cleanup
         set (hax, "nextplot", old_hold_state);
       end_unwind_protect
-      
+
     unwind_protect_cleanup
       if (! isempty (oldfig))
         set (0, "currentfigure", oldfig);
       endif
     end_unwind_protect
   else
     Nx = nx;
     Ny = ny;
diff --git a/scripts/plot/draw/tetramesh.m b/scripts/plot/draw/tetramesh.m
--- a/scripts/plot/draw/tetramesh.m
+++ b/scripts/plot/draw/tetramesh.m
@@ -21,29 +21,29 @@
 ## @deftypefnx {Function File} {} tetramesh (@var{T}, @var{X}, @var{C})
 ## @deftypefnx {Function File} {} tetramesh (@dots{}, @var{property}, @var{val}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} tetramesh (@dots{})
 ## Display the tetrahedrons defined in the m-by-4 matrix @var{T} as 3-D patches.
 ##
 ## @var{T} is typically the output of a Delaunay triangulation
 ## of a 3-D set of points.  Every row of @var{T} contains four indices into
 ## the n-by-3 matrix @var{X} of the vertices of a tetrahedron.  Every row in
-## @var{X} represents one point in 3-D space. 
+## @var{X} represents one point in 3-D space.
 ##
 ## The vector @var{C} specifies the color of each tetrahedron as an index
 ## into the current colormap.  The default value is 1:m where m is the number
 ## of tetrahedrons; the indices are scaled to map to the full range of the
 ## colormap.  If there are more tetrahedrons than colors in the colormap then
 ## the values in @var{C} are cyclically repeated.
-## 
+##
 ## Calling @code{tetramesh (@dots{}, "property", "value", @dots{})} passes all
 ## property/value pairs directly to the patch function as additional arguments.
 ##
 ## The optional return value @var{h} is a vector of patch handles where each
-## handle represents one tetrahedron in the order given by @var{T}. 
+## handle represents one tetrahedron in the order given by @var{T}.
 ## A typical use case for @var{h} is to turn the respective patch
 ## @qcode{"visible"} property @qcode{"on"} or @qcode{"off"}.
 ##
 ## Type @code{demo tetramesh} to see examples on using @code{tetramesh}.
 ## @seealso{trimesh, delaunay3, delaunayn, patch}
 ## @end deftypefn
 
 ## Author: Martin Helm <martin@mhelm.de>
@@ -62,21 +62,21 @@ function h = tetramesh (varargin)
   if (! ismatrix (T) || columns (T) != 4)
     error ("tetramesh: T must be an n-by-4 matrix");
   elseif (! ismatrix (X) || columns (X) != 3)
     error ("tetramesh: X must be an n-by-3 matrix");
   endif
 
   size_T = rows (T);
   cmap = colormap ();
-  
+
   if (length (reg) < 3)
     size_cmap = rows (cmap);
     C = mod ((1:size_T)' - 1, size_cmap) + 1;
-    if (size_T < size_cmap && size_T > 1) 
+    if (size_T < size_cmap && size_T > 1)
       ## expand to the available range of colors
       C = floor ((C - 1) * (size_cmap - 1) / (size_T - 1)) + 1;
     endif
   else
     C = reg{3};
     if (! isvector (C) || size_T != length (C))
       error ("tetramesh: C must be a vector of the same length as T");
     endif
@@ -85,25 +85,25 @@ function h = tetramesh (varargin)
   hax = newplot ();
 
   hvec = zeros (size_T, 1);
   if (strcmp (graphics_toolkit (), "gnuplot"))
     ## Tiny reduction of the tetrahedron size to help gnuplot by
     ## avoiding identical faces with different colors
     for i = 1:size_T
       [th, p] = __shrink__ ([1 2 3 4], X(T(i, :), :), 1 - 1e-7);
-      hvec(i) = patch ("Faces", th, "Vertices", p, 
+      hvec(i) = patch ("Faces", th, "Vertices", p,
                        "FaceColor", cmap(C(i), :), "FaceAlpha", 0.9,
                        prop{:});
     endfor
   else
     ## FLTK does not support FaceAlpha.
     for i = 1:size_T
       th = [1 2 3; 2 3 4; 3 4 1; 4 1 2];
-      hvec(i) = patch ("Faces", th, "Vertices", X(T(i, :), :), 
+      hvec(i) = patch ("Faces", th, "Vertices", X(T(i, :), :),
                        "FaceColor", cmap(C(i), :), "FaceAlpha", 1.0,
                        prop{:});
     endfor
   endif
 
   if (! ishold ())
     set (hax, "view", [-37.5, 30], "box", "off");
   endif
diff --git a/scripts/plot/draw/trimesh.m b/scripts/plot/draw/trimesh.m
--- a/scripts/plot/draw/trimesh.m
+++ b/scripts/plot/draw/trimesh.m
@@ -18,27 +18,27 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} trimesh (@var{tri}, @var{x}, @var{y}, @var{z}, @var{c})
 ## @deftypefnx {Function File} {} trimesh (@var{tri}, @var{x}, @var{y}, @var{z})
 ## @deftypefnx {Function File} {} trimesh (@var{tri}, @var{x}, @var{y})
 ## @deftypefnx {Function File} {} trimesh (@dots{}, @var{prop}, @var{val}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} trimesh (@dots{})
 ## Plot a 3-D triangular wireframe mesh.
-## 
+##
 ## In contrast to @code{mesh}, which plots a mesh using rectangles,
 ## @code{trimesh} plots the mesh using triangles.
 ##
 ## @var{tri} is typically the output of a Delaunay triangulation over the
 ## grid of @var{x}, @var{y}.  Every row of @var{tri} represents one triangle
 ## and contains three indices into [@var{x}, @var{y}] which are the
 ## vertices of the triangles in the x-y plane.  @var{z} determines the
 ## height above the plane of each vertex.  If no @var{z} input is given then
 ## the triangles are plotted as a 2-D figure.
-## 
+##
 ## The color of the trimesh is computed by linearly scaling the @var{z} values
 ## to fit the range of the current colormap.  Use @code{caxis} and/or
 ## change the colormap to control the appearance.
 ##
 ## Optionally, the color of the mesh can be specified independently of @var{z}
 ## by supplying a color matrix, @var{c}.  If @var{z} has N elements, then
 ## @var{c} should be an Nx1 vector for colormap data or an Nx3 matrix for
 ## RGB data.
diff --git a/scripts/plot/draw/triplot.m b/scripts/plot/draw/triplot.m
--- a/scripts/plot/draw/triplot.m
+++ b/scripts/plot/draw/triplot.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} triplot (@var{tri}, @var{x}, @var{y})
 ## @deftypefnx {Function File} {} triplot (@var{tri}, @var{x}, @var{y}, @var{linespec})
 ## @deftypefnx {Function File} {@var{h} =} triplot (@dots{})
 ## Plot a 2-D triangular mesh.
-## 
+##
 ## @var{tri} is typically the output of a Delaunay triangulation over the
 ## grid of @var{x}, @var{y}.  Every row of @var{tri} represents one triangle
 ## and contains three indices into [@var{x}, @var{y}] which are the
 ## vertices of the triangles in the x-y plane.
 ##
 ## The linestyle to use for the plot can be defined with the argument
 ## @var{linespec} of the same format as the @code{plot} command.
 ##
diff --git a/scripts/plot/draw/trisurf.m b/scripts/plot/draw/trisurf.m
--- a/scripts/plot/draw/trisurf.m
+++ b/scripts/plot/draw/trisurf.m
@@ -17,26 +17,26 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} trisurf (@var{tri}, @var{x}, @var{y}, @var{z}, @var{c})
 ## @deftypefnx {Function File} {} trisurf (@var{tri}, @var{x}, @var{y}, @var{z})
 ## @deftypefnx {Function File} {} trisurf (@dots{}, @var{prop}, @var{val}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} trisurf (@dots{})
 ## Plot a 3-D triangular surface.
-## 
+##
 ## In contrast to @code{surf}, which plots a surface mesh using rectangles,
 ## @code{trisurf} plots the mesh using triangles.
 ##
 ## @var{tri} is typically the output of a Delaunay triangulation over the
 ## grid of @var{x}, @var{y}.  Every row of @var{tri} represents one triangle
 ## and contains three indices into [@var{x}, @var{y}] which are the
 ## vertices of the triangles in the x-y plane.  @var{z} determines the
 ## height above the plane of each vertex.
-## 
+##
 ## The color of the trimesh is computed by linearly scaling the @var{z} values
 ## to fit the range of the current colormap.  Use @code{caxis} and/or
 ## change the colormap to control the appearance.
 ##
 ## Optionally, the color of the mesh can be specified independently of @var{z}
 ## by supplying a color matrix, @var{c}.  If @var{z} has N elements, then
 ## @var{c} should be an Nx1 vector for colormap data or an Nx3 matrix for
 ## RGB data.
diff --git a/scripts/plot/util/__gnuplot_drawnow__.m b/scripts/plot/util/__gnuplot_drawnow__.m
--- a/scripts/plot/util/__gnuplot_drawnow__.m
+++ b/scripts/plot/util/__gnuplot_drawnow__.m
@@ -381,17 +381,17 @@ function have_enhanced = gnuplot_is_enha
   if (nargin < 2)
     ## Determine the default gnuplot terminal.
     term = gnuplot_default_term (plot_stream);
   endif
   have_enhanced = any (strcmp (term, enhanced_terminals));
 endfunction
 
 function ret = output_to_screen (term)
-  ret = any (strcmpi (term, 
+  ret = any (strcmpi (term,
                      {"aqua", "dumb", "pm", "qt", "windows", "wxt", "x11"}));
 endfunction
 
 function retval = have_non_legend_axes (h)
   retval = false;
   all_axes = findall (h, "type", "axes");
   if (! isempty (all_axes))
     n_all_axes = numel (all_axes);
diff --git a/scripts/plot/util/__plt_get_axis_arg__.m b/scripts/plot/util/__plt_get_axis_arg__.m
--- a/scripts/plot/util/__plt_get_axis_arg__.m
+++ b/scripts/plot/util/__plt_get_axis_arg__.m
@@ -22,17 +22,17 @@
 ## @end deftypefn
 
 ## Author: jwe
 
 function [h, varargin, narg] = __plt_get_axis_arg__ (caller, varargin)
 
   h = [];
   parent = find (strcmpi (varargin, "parent"), 1);
-  
+
   ## Look for a scalar which is a graphics handle but not the
   ## Root Figure (0) or an ordinary figure (integer).
   if (numel (varargin) > 0 && numel (varargin{1}) == 1
       && ishandle (varargin{1}) && varargin{1} != 0 && ! isfigure (varargin{1}))
     htmp = varargin{1};
     if (! isaxes (htmp))
       error ("%s: expecting first argument to be axes handle", caller);
     endif
diff --git a/scripts/plot/util/axes.m b/scripts/plot/util/axes.m
--- a/scripts/plot/util/axes.m
+++ b/scripts/plot/util/axes.m
@@ -28,17 +28,17 @@
 ## construct a new axes.  For accepted properties and corresponding
 ## values, @pxref{XREFset,,set}.
 ##
 ## Called with a single axes handle argument @var{hax}, the function makes
 ## @var{hax} the current axis.  It also restacks the axes in the
 ## corresponding figure so that @var{hax} is the first entry in the list
 ## of children.  This causes @var{hax} to be displayed on top of any other
 ## axes objects (Z-order stacking).
-## 
+##
 ## @seealso {gca, set, get}
 ## @end deftypefn
 
 ## Author: jwe
 
 function h = axes (varargin)
 
   if (nargin == 0 || nargin > 1)
diff --git a/scripts/plot/util/clf.m b/scripts/plot/util/clf.m
--- a/scripts/plot/util/clf.m
+++ b/scripts/plot/util/clf.m
@@ -18,28 +18,28 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} clf
 ## @deftypefnx {Command} {} clf reset
 ## @deftypefnx {Function File} {} clf (@var{hfig})
 ## @deftypefnx {Function File} {} clf (@var{hfig}, "reset")
 ## @deftypefnx {Function File} {@var{h} =} clf (@dots{})
 ## Clear the current figure window.
-## 
+##
 ## @code{clf} operates by deleting child graphics objects with visible
 ## handles (HandleVisibility = @qcode{"on"}).
 ##
 ## If the optional argument @qcode{"reset"} is specified, delete all child
 ## objects including those with hidden handles and reset all figure
 ## properties to their defaults.  However, the following properties are not
 ## reset: Position, Units, PaperPosition, PaperUnits.
 ##
 ## If the first argument @var{hfig} is a figure handle, then operate on
 ## this figure rather than the current figure returned by @code{gcf}.
-## 
+##
 ## The optional return value @var{h} is the graphics handle of the figure
 ## window that was cleared.
 ## @seealso{cla, close, delete, reset}
 ## @end deftypefn
 
 ## Author: jwe
 
 function h = clf (varargin)
diff --git a/scripts/plot/util/copyobj.m b/scripts/plot/util/copyobj.m
--- a/scripts/plot/util/copyobj.m
+++ b/scripts/plot/util/copyobj.m
@@ -42,17 +42,17 @@ function hnew = copyobj (horig, hparent 
     hparent = figure (fix (hparent));
   elseif (! any (strcmpi (get (hparent).type, partypes)))
     print_usage ();
   endif
 
   ## current figure and axes
   cf = gcf ();
   ca = gca ();
-  
+
   ## compatibility of input handles
   kididx = find (strcmp (alltypes, get (horig).type));
   paridx = find (strcmp (alltypes, get (hparent).type));
 
   if (kididx <= paridx)
     error ("copyobj: %s object can't be children to %s.",
            alltypes{kididx}, alltypes{paridx});
   elseif (nargin == 1)
@@ -63,17 +63,17 @@ function hnew = copyobj (horig, hparent 
     hnew = struct2hdl (str, hparent);
   endif
 
   ## reset current figure (and eventually axes) to original
   set (0, "currentfigure", cf);
   if (get (hnew, "parent") == cf)
     set (cf, "currentaxes", ca)
   endif
-  
+
 endfunction
 
 
 %!demo
 %! hdl = figure (1234);
 %! clf;
 %! hold on;
 %! x = 1:10;
diff --git a/scripts/plot/util/figure.m b/scripts/plot/util/figure.m
--- a/scripts/plot/util/figure.m
+++ b/scripts/plot/util/figure.m
@@ -25,17 +25,17 @@
 ## Create a new figure window for plotting.
 ##
 ## If no arguments are specified, a new figure with the next available number
 ## is created.
 ##
 ## If called with an integer @var{n}, and no such numbered figure exists, then
 ## a new figure with the specified number is created.  If the figure already
 ## exists then it is made visible and becomes the current figure for plotting.
-## 
+##
 ## Multiple property-value pairs may be specified for the figure object, but
 ## they must appear in pairs.
 ##
 ## The optional return value @var{h} is a graphics handle to the created figure
 ## object.
 ## @seealso{axes, gcf, clf, close}
 ## @end deftypefn
 
diff --git a/scripts/plot/util/gcbo.m b/scripts/plot/util/gcbo.m
--- a/scripts/plot/util/gcbo.m
+++ b/scripts/plot/util/gcbo.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{h} =} gcbo ()
 ## @deftypefnx {Function File} {[@var{h}, @var{fig}] =} gcbo ()
 ## Return a handle to the object whose callback is currently executing.
-## 
+##
 ## If no callback is executing, this function returns the empty matrix.  This
 ## handle is obtained from the root object property @qcode{"CallbackObject"}.
 ##
 ## When called with a second output argument, return the handle of the figure
 ## containing the object whose callback is currently executing.  If no callback
 ## is executing the second output is also set to the empty matrix.
 ##
 ## @seealso{gcbf, gco, gca, gcf, get, set}
diff --git a/scripts/plot/util/graphics_toolkit.m b/scripts/plot/util/graphics_toolkit.m
--- a/scripts/plot/util/graphics_toolkit.m
+++ b/scripts/plot/util/graphics_toolkit.m
@@ -17,27 +17,27 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{name} =} graphics_toolkit ()
 ## @deftypefnx {Function File} {@var{name} =} graphics_toolkit (@var{hlist})
 ## @deftypefnx {Function File} {} graphics_toolkit (@var{name})
 ## @deftypefnx {Function File} {} graphics_toolkit (@var{hlist}, @var{name})
 ## Query or set the default graphics toolkit which is assigned to new figures.
-## 
+##
 ## With no inputs, return the current default graphics toolkit.  If the input
 ## is a list of figure graphic handles, @var{hlist}, then return the name
 ## of the graphics toolkit in use for each figure.
-## 
+##
 ## When called with a single input @var{name} set the default graphics toolkit
 ## to @var{name}.  If the toolkit is not already loaded, it is initialized by
 ## calling the function @code{__init_@var{name}__}.  If the first input
 ## is a list of figure handles, @var{hlist}, then the graphics toolkit is set
 ## to @var{name} for these figures only.
-## 
+##
 ## @seealso{available_graphics_toolkits}
 ## @end deftypefn
 
 function retval = graphics_toolkit (name, hlist = [])
 
   if (nargin > 2)
     print_usage ();
   endif
diff --git a/scripts/plot/util/hggroup.m b/scripts/plot/util/hggroup.m
--- a/scripts/plot/util/hggroup.m
+++ b/scripts/plot/util/hggroup.m
@@ -31,30 +31,30 @@
 ## The optional return value @var{h} is a graphics handle to the created
 ## hggroup object.
 ##
 ## Programming Note: An hggroup is a way to group base graphics objects such
 ## as line objects or patch objects into a single unit which can react
 ## appropriately.  For example, the individual lines of a contour plot are
 ## collected into a single hggroup so that they can be made visible/invisible
 ## with a single command, @code{set (hg_handle, "visible", "off")}.
-## 
+##
 ## @seealso{addproperty, addlistener}
 ## @end deftypefn
 
 ## Author: goffioul
 
 function h = hggroup (varargin)
 
   [hax, varargin] = __plt_get_axis_arg__ ("hggroup", varargin{:});
-  
+
   if (isempty (hax))
     hax = gca ();
   endif
-  
+
   htmp = __go_hggroup__ (hax, varargin{:});
 
   if (nargout > 0)
     h = htmp;
   endif
 
 endfunction
 
diff --git a/scripts/plot/util/meshgrid.m b/scripts/plot/util/meshgrid.m
--- a/scripts/plot/util/meshgrid.m
+++ b/scripts/plot/util/meshgrid.m
@@ -34,17 +34,17 @@
 ## @code{meshgrid} is most frequently used to produce input for a 2-D or 3-D
 ## function that will be plotted.  The following example creates a surface
 ## plot of the ``sombrero'' function.
 ##
 ## @example
 ## @group
 ## f = @@(x,y) sin (sqrt (x.^2 + y.^2)) ./ sqrt (x.^2 + y.^2);
 ## range = linspace (-8, 8, 41);
-## [@var{X}, @var{Y}] = meshgrid (range, range);  
+## [@var{X}, @var{Y}] = meshgrid (range, range);
 ## Z = f (X, Y);
 ## surf (X, Y, Z);
 ## @end group
 ## @end example
 ##
 ## Programming Note: @code{meshgrid} is restricted to 2-D or 3-D grid
 ## generation.  The @code{ndgrid} function will generate 1-D through N-D
 ## grids.  However, the functions are not completely equivalent.  If @var{x}
diff --git a/scripts/plot/util/newplot.m b/scripts/plot/util/newplot.m
--- a/scripts/plot/util/newplot.m
+++ b/scripts/plot/util/newplot.m
@@ -84,28 +84,28 @@ function hax = newplot (hsave = [])
   if (nargin > 1)
     print_usage ();
   endif
 
   cf = [];
   ca = [];
 
   if (! isempty (hsave))
-    ## Find the first valid axes 
-    ca = ancestor (hsave, "axes", "toplevel"); 
+    ## Find the first valid axes
+    ca = ancestor (hsave, "axes", "toplevel");
     if (iscell (ca))
       ca = [ca{:}];
     endif
     ca = ca(find (ca, 1));
     hsave(hsave == ca) = [];
     ## Next, find the figure associated with any axis found
     if (! isempty (ca))
       cf = ancestor (ca, "figure", "toplevel");
     else
-      cf = ancestor (hsave, "figure", "toplevel"); 
+      cf = ancestor (hsave, "figure", "toplevel");
       if (iscell (cf))
         cf = [cf{:}];
       endif
       cf = cf(find (cf, 1));
     endif
   endif
 
   if (isempty (cf))
@@ -232,25 +232,25 @@ endfunction
 %!   hg2 = hggroup ("parent", hg1);
 %!   li0 = line (1:10, 1:10);
 %!   li1 = line (1:10, -1:-1:-10, "parent", hg1);
 %!   li2 = line (1:10, sin (1:10), "parent", hg2);
 %!   hold off;
 %!   newplot (hg2);
 %!   assert (ishandle (li0), false);
 %!   assert (get (hax, "children"), hg1);
-%! 
+%!
 %!   ## kids are preserved for hggroups
 %!   kids = get (hg1, "children");
-%!   newplot (hg1); 
+%!   newplot (hg1);
 %!   assert (get (hg1, "children"), kids);
-%! 
+%!
 %!   ## preserve objects
 %!   newplot (li1);
 %!   assert (ishandle (li1));
-%! 
+%!
 %!   ## kids are deleted for axes
-%!   newplot (hax);  
+%!   newplot (hax);
 %!   assert (isempty (get (hax, "children")));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
diff --git a/scripts/plot/util/print.m b/scripts/plot/util/print.m
--- a/scripts/plot/util/print.m
+++ b/scripts/plot/util/print.m
@@ -275,17 +275,17 @@
 ## @end example
 ##
 ## Example: Print to printer named PS_printer using ps format.
 ##
 ## @example
 ## @group
 ## clf ();
 ## surf (peaks);
-## print -dpswrite -PPS_printer 
+## print -dpswrite -PPS_printer
 ## @end group
 ## @end example
 ##
 ## @seealso{saveas, orient, figure}
 ## @end deftypefn
 
 function print (varargin)
 
diff --git a/scripts/plot/util/private/__add_default_menu__.m b/scripts/plot/util/private/__add_default_menu__.m
--- a/scripts/plot/util/private/__add_default_menu__.m
+++ b/scripts/plot/util/private/__add_default_menu__.m
@@ -51,17 +51,17 @@ function __add_default_menu__ (fig)
       uimenu (__e, "label", "Auto&scale", "callback", @autoscale_cb);
       gm = uimenu (__e, "label", "GUI &Mode");
         uimenu (gm, "label", "Pan+Zoom", "callback", @guimode_cb);
         uimenu (gm, "label", "Rotate+Zoom", "callback", @guimode_cb);
         uimenu (gm, "label", "None+Zoom", "callback", @guimode_cb);
 
     ## FIXME: This drawnow () must occur after at least one menu item has
     ##        been defined to avoid sizing issues in new figures.
-    ##        This may lead to flicker.  The real fix must be in the C++ code. 
+    ##        This may lead to flicker.  The real fix must be in the C++ code.
     drawnow ();
 
     set (fig, "menubar", menubar_state);
   endif
 
 endfunction
 
 function save_cb (h, e)
diff --git a/scripts/plot/util/private/__fltk_print__.m b/scripts/plot/util/private/__fltk_print__.m
--- a/scripts/plot/util/private/__fltk_print__.m
+++ b/scripts/plot/util/private/__fltk_print__.m
@@ -55,17 +55,17 @@ function opts = __fltk_print__ (opts)
                   {strcat(".", suffix), ".tex", "."})))
         name = opts.name(1:dot-1);
         if (dot < numel (opts.name)
             && any (strcmpi (opts.name(dot+1:end), {"eps", "ps", "pdf"})))
           ## If user provides eps/ps/pdf suffix, use it.
           suffix = opts.name(dot+1:end);
         endif
       else
-        error ("print:invalid-suffix", 
+        error ("print:invalid-suffix",
                "invalid suffix '%s' for device '%s'.",
                opts.name(dot:end), lower (opts.devopt));
       endif
       gl2ps_device = {sprintf("%snotxt", lower (suffix))};
       gl2ps_device{2} = "tex";
       if (dos_shell)
         ## FIXME: this will only work on MinGW with the MSYS shell
         pipeline = {sprintf("cat > %s-inc.%s", name, suffix)};
diff --git a/scripts/plot/util/private/__gnuplot_print__.m b/scripts/plot/util/private/__gnuplot_print__.m
--- a/scripts/plot/util/private/__gnuplot_print__.m
+++ b/scripts/plot/util/private/__gnuplot_print__.m
@@ -70,17 +70,17 @@ function opts = __gnuplot_print__ (opts)
     case {"epslatex", "pslatex", "pstex", "epslatexstandalone"}
       dot = find (opts.name == ".", 1, "last");
       n = find (opts.devopt == "l", 1);
       suffix = opts.devopt(1:n-1);
       if (! isempty (dot))
         if (any (strcmpi (opts.name(dot:end), {["." suffix], ".tex", "."})))
           name = opts.name(1:dot-1);
         else
-          error ("print:invalid-suffix", 
+          error ("print:invalid-suffix",
                  "invalid suffix '%s' for device '%s'.",
                  opts.name(dot:end), lower (opts.devopt));
         endif
       endif
       if (strfind (opts.devopt, "standalone"))
         term = sprintf ("%s ",
                         strrep (opts.devopt, "standalone", " standalone"));
       else
diff --git a/scripts/plot/util/private/__print_parse_opts__.m b/scripts/plot/util/private/__print_parse_opts__.m
--- a/scripts/plot/util/private/__print_parse_opts__.m
+++ b/scripts/plot/util/private/__print_parse_opts__.m
@@ -317,17 +317,17 @@ function arg_st = __print_parse_opts__ (
     arg_st.ghostscript.device = arg_st.devopt;
     arg_st.ghostscript.output = arg_st.name;
     arg_st.ghostscript.antialiasing = false;
     arg_st.ghostscript.epscrop = ! arg_st.loose;
   endif
 
   if (arg_st.send_to_printer)
     if (isempty (arg_st.name))
-      ## Pipe the ghostscript output 
+      ## Pipe the ghostscript output
       arg_st.name = "-";
     else
       error ("print: a file name may not specified when spooling to a printer")
     endif
     if (! any (strcmp (arg_st.devopt, gs_device_list))
       || ! any (strcmp (arg_st.devopt, {"pswrite", "ps2write"})))
       ## Only postscript and supported ghostscript devices
       error ("print: invalid format for spooling to a printer")
diff --git a/scripts/plot/util/refreshdata.m b/scripts/plot/util/refreshdata.m
--- a/scripts/plot/util/refreshdata.m
+++ b/scripts/plot/util/refreshdata.m
@@ -93,17 +93,17 @@ function refreshdata (h, workspace)
     m = flds(!cellfun (@isempty, m));
     for j = 1 : numel (m)
       if (isempty (obj.(m{j})))
         continue;  # datasource field doesn't point to anything
       endif
       expr = obj.(m{j});       # datasource field
       val = evalin (workspace, expr);
       pdname = m{j}(1:end-6);  # property data name without "source"
-      set (h(i), pdname, val); 
+      set (h(i), pdname, val);
     endfor
   endfor
 endfunction
 
 
 %!demo
 %! clf;
 %! x = 0:0.1:10;
diff --git a/scripts/plot/util/subplot.m b/scripts/plot/util/subplot.m
--- a/scripts/plot/util/subplot.m
+++ b/scripts/plot/util/subplot.m
@@ -124,17 +124,17 @@ function h = subplot (varargin)
         varargin(1:2) = [];
         have_position = true;
         initial_args_decoded = true;
       else
         error ("subplot: POSITION must be a 4-element numeric array");
       endif
     endif
   endif
-    
+
   if (! initial_args_decoded && nargin > 0)
     arg = varargin{1};
     if (nargin == 1 && isaxes (arg))
       ## Axes handle
       axes (arg);
       cf = get (0, "currentfigure");
       set (cf, "nextplot", "add");
       return;
diff --git a/scripts/polynomial/conv.m b/scripts/polynomial/conv.m
--- a/scripts/polynomial/conv.m
+++ b/scripts/polynomial/conv.m
@@ -62,17 +62,17 @@ function y = conv (a, b, shape = "full")
 
   if (ly == 0)
     y = zeros (1, 0);
     return;
   endif
 
   ## Use shortest vector as the coefficent vector to filter.
   if (la > lb)
-    [a, b] = deal (b, a);  # Swap vectors 
+    [a, b] = deal (b, a);  # Swap vectors
     lb = la;
   endif
   x = b;
 
   ## Pad longer vector to convolution length.
   if (ly > lb)
     x(end+1:end+ly-lb) = 0;
   endif
diff --git a/scripts/polynomial/poly.m b/scripts/polynomial/poly.m
--- a/scripts/polynomial/poly.m
+++ b/scripts/polynomial/poly.m
@@ -34,17 +34,17 @@
 ## @end group
 ## @end example
 ##
 ## In fact, all three eigenvalues are exactly 1 which emphasizes that for
 ## numerical performance the @code{eig} function should be used to compute
 ## eigenvalues.
 ##
 ## If @var{x} is a vector, @code{poly (@var{x})} is a vector of the
-## coefficients of the polynomial whose roots are the elements of @var{x}. 
+## coefficients of the polynomial whose roots are the elements of @var{x}.
 ## That is, if @var{c} is a polynomial, then the elements of @code{@var{d} =
 ## roots (poly (@var{c}))} are contained in @var{c}.  The vectors @var{c} and
 ## @var{d} are not identical, however, due to sorting and numerical errors.
 ## @seealso{roots, eig}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 24 December 1993
diff --git a/scripts/polynomial/polyeig.m b/scripts/polynomial/polyeig.m
--- a/scripts/polynomial/polyeig.m
+++ b/scripts/polynomial/polyeig.m
@@ -33,17 +33,17 @@
 ## eigenvectors.
 ##
 ## @seealso{eig, eigs, compan}
 ## @end deftypefn
 
 ## Author: Fotios Kasolis
 
 function [z, v] = polyeig (varargin)
-  
+
   if (nargin < 1 || nargout > 2)
     print_usage ();
   endif
 
   nin = numel (varargin);
   n = rows (varargin{1});
 
   for i = 1 : nin
diff --git a/scripts/polynomial/polyfit.m b/scripts/polynomial/polyfit.m
--- a/scripts/polynomial/polyfit.m
+++ b/scripts/polynomial/polyfit.m
@@ -36,17 +36,17 @@
 ##
 ## @item X
 ## The Vandermonde matrix used to compute the polynomial coefficients.
 ##
 ## @item C
 ## The unscaled covariance matrix, formally equal to the inverse of
 ## @var{x'}*@var{x}, but computed in a way minimizing roundoff error
 ## propagation.
-## 
+##
 ## @item df
 ## The degrees of freedom.
 ##
 ## @item normr
 ## The norm of the residuals.
 ##
 ## @item yf
 ## The values of the polynomial for each value of @var{x}.
@@ -109,31 +109,31 @@ function [p, s, mu] = polyfit (x, y, n)
 
   ## Construct the Vandermonde matrix.
   v = vander (x, n+1);
 
   ## Solve by QR decomposition.
   [q, r, k] = qr (v(:, polymask), 0);
   p = r \ (q' * y);
   p(k) = p;
-  
+
   if (n != m)
-    q = p; p = zeros (n+1, 1); 
+    q = p; p = zeros (n+1, 1);
     p(polymask) = q;
   endif
-  
+
   if (nargout > 1)
     yf = v*p;
 
     if (y_is_row_vector)
       s.yf = yf.';
     else
       s.yf = yf;
     endif
-    s.X = v; 
+    s.X = v;
 
     ## r.'*r is positive definite if X(:, polymask) is of full rank.
     ## Invert it by cholinv to avoid taking the square root of squared
     ## quantities. If cholinv fails, then X(:, polymask) is rank
     ## deficient and not invertible.
     try
       C = cholinv (r.'*r)(k, k);
     catch
@@ -141,17 +141,17 @@ function [p, s, mu] = polyfit (x, y, n)
     end_try_catch
 
     if (n != m)
       ## fill matrices if required
       s.X(:, !polymask) = 0;
       s.R = zeros (n+1, n+1); s.R(polymask, polymask) = r;
       s.C = zeros (n+1, n+1); s.C(polymask, polymask) = C;
     else
-      s.R = r; 
+      s.R = r;
       s.C = C;
     endif
     s.df = l - m - 1;
     s.normr = norm (yf - y);
   endif
 
   ## Return a row vector.
   p = p.';
diff --git a/scripts/polynomial/polyval.m b/scripts/polynomial/polyval.m
--- a/scripts/polynomial/polyval.m
+++ b/scripts/polynomial/polyval.m
@@ -16,29 +16,29 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{y} =} polyval (@var{p}, @var{x})
 ## @deftypefnx {Function File} {@var{y} =} polyval (@var{p}, @var{x}, [], @var{mu})
 ## @deftypefnx {Function File} {[@var{y}, @var{dy}] =} polyval (@var{p}, @var{x}, @var{s})
 ## @deftypefnx {Function File} {[@var{y}, @var{dy}] =} polyval (@var{p}, @var{x}, @var{s}, @var{mu})
-## 
+##
 ## Evaluate the polynomial @var{p} at the specified values of @var{x}.  When
 ## @var{mu} is present, evaluate the polynomial for
 ## (@var{x}-@var{mu}(1))/@var{mu}(2).
 ## If @var{x} is a vector or matrix, the polynomial is evaluated for each of
 ## the elements of @var{x}.
-## 
+##
 ## In addition to evaluating the polynomial, the second output
 ## represents the prediction interval, @var{y} +/- @var{dy}, which
 ## contains at least 50% of the future predictions.  To calculate the
 ## prediction interval, the structured variable @var{s}, originating
 ## from @code{polyfit}, must be supplied.
-## 
+##
 ## @seealso{polyvalm, polyaffine, polyfit, roots, poly}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function [y, dy] = polyval (p, x, s = [], mu)
diff --git a/scripts/polynomial/private/__splinefit__.m b/scripts/polynomial/private/__splinefit__.m
--- a/scripts/polynomial/private/__splinefit__.m
+++ b/scripts/polynomial/private/__splinefit__.m
@@ -1,36 +1,36 @@
 ## This function is private because it is maintained by Jonas Lundgren
 ## separtely from Octave.  Please do not reformat to match Octave coding
 ## conventions as that would make it harder to integrate upstream
 ## changes.
 
 % Copyright (c) 2010, Jonas Lundgren
 % All rights reserved.
-% 
-% Redistribution and use in source and binary forms, with or without 
-% modification, are permitted provided that the following conditions are 
+%
+% Redistribution and use in source and binary forms, with or without
+% modification, are permitted provided that the following conditions are
 % met:
-% 
-%     * Redistributions of source code must retain the above copyright 
+%
+%     * Redistributions of source code must retain the above copyright
 %       notice, this list of conditions and the following disclaimer.
-%     * Redistributions in binary form must reproduce the above copyright 
-%       notice, this list of conditions and the following disclaimer in 
+%     * Redistributions in binary form must reproduce the above copyright
+%       notice, this list of conditions and the following disclaimer in
 %       the documentation and/or other materials provided with the distribution
-%       
-% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
-% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
-% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
-% ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
-% LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
-% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
-% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
-% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
-% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
-% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
+%
+% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+% ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+% LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 % POSSIBILITY OF SUCH DAMAGE.
 function pp = __splinefit__(varargin)
 %SPLINEFIT Fit a spline to noisy data.
 %   PP = SPLINEFIT(X,Y,BREAKS) fits a piecewise cubic spline with breaks
 %   (knots) BREAKS to the noisy data (X,Y). X is a vector and Y is a vector
 %   or an ND array. If Y is an ND array, then X(j) and Y(:,...,:,j) are
 %   matched. Use PPVAL to evaluate PP.
 %
diff --git a/scripts/polynomial/spline.m b/scripts/polynomial/spline.m
--- a/scripts/polynomial/spline.m
+++ b/scripts/polynomial/spline.m
@@ -16,17 +16,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{pp} =} spline (@var{x}, @var{y})
 ## @deftypefnx {Function File} {@var{yi} =} spline (@var{x}, @var{y}, @var{xi})
 ## Return the cubic spline interpolant of points @var{x} and @var{y}.
-## 
+##
 ## When called with two arguments, return the piecewise polynomial @var{pp}
 ## that may be used with @code{ppval} to evaluate the polynomial at specific
 ## points.  When called with a third input argument, @code{spline} evaluates
 ## the spline at the points @var{xi}.  The third calling form @code{spline
 ## (@var{x}, @var{y}, @var{xi})} is equivalent to @code{ppval (spline
 ## (@var{x}, @var{y}), @var{xi})}.
 ##
 ## The variable @var{x} must be a vector of length @var{n}.  @var{y} can be
diff --git a/scripts/prefs/prefdir.m b/scripts/prefs/prefdir.m
--- a/scripts/prefs/prefdir.m
+++ b/scripts/prefs/prefdir.m
@@ -12,18 +12,18 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Command} {} prefdir 
-## @deftypefnx {Command} {@var{dir} =} prefdir 
+## @deftypefn  {Command} {} prefdir
+## @deftypefnx {Command} {@var{dir} =} prefdir
 ## Return the directory that contains the preferences for Octave.
 ##
 ## Examples:
 ##
 ## Display the preferences directory
 ##
 ## @example
 ## prefdir
diff --git a/scripts/prefs/preferences.m b/scripts/prefs/preferences.m
--- a/scripts/prefs/preferences.m
+++ b/scripts/prefs/preferences.m
@@ -12,17 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Command} {} preferences 
+## @deftypefn {Command} {} preferences
 ## Display the GUI preferences dialog window for Octave.
 ## @end deftypefn
 
 ## Author: John Donoghue
 ## Version: 0.01
 
 function preferences ()
   if (isguirunning ())
diff --git a/scripts/prefs/private/prefsfile.m b/scripts/prefs/private/prefsfile.m
--- a/scripts/prefs/private/prefsfile.m
+++ b/scripts/prefs/private/prefsfile.m
@@ -21,16 +21,16 @@
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = prefsfile ()
 
   retval = [prefdir() filesep() ".octave_prefs"];
-  
+
 endfunction
 
 
 %% Testing these functions will require some care to avoid wiping out
 %% existing (or creating unwanted) preferences for the user running the
 %% tests.
 
diff --git a/scripts/prefs/rmpref.m b/scripts/prefs/rmpref.m
--- a/scripts/prefs/rmpref.m
+++ b/scripts/prefs/rmpref.m
@@ -59,17 +59,17 @@ function retval = rmpref (group, pref)
     if (all (valid))
       prefs = loadprefs ();
       prefs.(group) = rmfield (prefs.(group), pref);
       saveprefs (prefs);
     else
       if (! ispref (group))
         error ("rmpref: group <%s> does not exist", group);
       else
-        idx = find (! valid, 1); 
+        idx = find (! valid, 1);
         error ("rmpref: pref <%s> does not exist", (cellstr (pref)){idx} );
       endif
     endif
   endif
 
 endfunction
 
 
diff --git a/scripts/signal/freqz.m b/scripts/signal/freqz.m
--- a/scripts/signal/freqz.m
+++ b/scripts/signal/freqz.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{h}, @var{w}] =} freqz (@var{b}, @var{a}, @var{n}, "whole")
 ## @deftypefnx {Function File} {[@var{h}, @var{w}] =} freqz (@var{b})
 ## @deftypefnx {Function File} {[@var{h}, @var{w}] =} freqz (@var{b}, @var{a})
 ## @deftypefnx {Function File} {[@var{h}, @var{w}] =} freqz (@var{b}, @var{a}, @var{n})
 ## @deftypefnx {Function File} {@var{h} =} freqz (@var{b}, @var{a}, @var{w})
 ## @deftypefnx {Function File} {[@dots{}] =} freqz (@dots{}, @var{Fs})
 ## @deftypefnx {Function File} {} freqz (@dots{})
-## 
+##
 ## Return the complex frequency response @var{h} of the rational IIR filter
 ## whose numerator and denominator coefficients are @var{b} and @var{a},
 ## respectively.  The response is evaluated at @var{n} angular frequencies
 ## between 0 and
 ## @ifnottex
 ## 2*pi.
 ## @end ifnottex
 ## @tex
diff --git a/scripts/signal/module.mk b/scripts/signal/module.mk
--- a/scripts/signal/module.mk
+++ b/scripts/signal/module.mk
@@ -1,15 +1,15 @@
 FCN_FILE_DIRS += signal
 
 signal_PRIVATE_FCN_FILES = \
   signal/private/rectangle_lw.m  \
   signal/private/rectangle_sw.m  \
   signal/private/triangle_lw.m  \
-  signal/private/triangle_sw.m 
+  signal/private/triangle_sw.m
 
 signal_FCN_FILES = \
   signal/arch_fit.m \
   signal/arch_rnd.m \
   signal/arch_test.m \
   signal/arma_rnd.m \
   signal/autoreg_matrix.m \
   signal/bartlett.m \
diff --git a/scripts/sparse/eigs.m b/scripts/sparse/eigs.m
--- a/scripts/sparse/eigs.m
+++ b/scripts/sparse/eigs.m
@@ -35,17 +35,17 @@
 ## @deftypefnx {Function File} {@var{d} =} eigs (@var{af}, @var{n}, @var{B}, @var{k}, @var{sigma}, @var{opts})
 ## @deftypefnx {Function File} {[@var{V}, @var{d}] =} eigs (@var{A}, @dots{})
 ## @deftypefnx {Function File} {[@var{V}, @var{d}] =} eigs (@var{af}, @var{n}, @dots{})
 ## @deftypefnx {Function File} {[@var{V}, @var{d}, @var{flag}] =} eigs (@var{A}, @dots{})
 ## @deftypefnx {Function File} {[@var{V}, @var{d}, @var{flag}] =} eigs (@var{af}, @var{n}, @dots{})
 ## Calculate a limited number of eigenvalues and eigenvectors of @var{A},
 ## based on a selection criteria.  The number of eigenvalues and eigenvectors to
 ## calculate is given by @var{k} and defaults to 6.
-## 
+##
 ## By default, @code{eigs} solve the equation
 ## @tex
 ## $A \nu = \lambda \nu$,
 ## @end tex
 ## @ifinfo
 ## @code{A * v = lambda * v},
 ## @end ifinfo
 ## where
@@ -58,140 +58,140 @@
 ## is the corresponding eigenvector.  If given the positive definite matrix
 ## @var{B} then @code{eigs} solves the general eigenvalue equation
 ## @tex
 ## $A \nu = \lambda B \nu$.
 ## @end tex
 ## @ifinfo
 ## @code{A * v = lambda * B * v}.
 ## @end ifinfo
-## 
+##
 ## The argument @var{sigma} determines which eigenvalues are returned.
 ## @var{sigma} can be either a scalar or a string.  When @var{sigma} is a
 ## scalar, the @var{k} eigenvalues closest to @var{sigma} are returned.  If
 ## @var{sigma} is a string, it must have one of the following values.
-## 
+##
 ## @table @asis
 ## @item @qcode{"lm"}
 ## Largest Magnitude (default).
-## 
+##
 ## @item @qcode{"sm"}
 ## Smallest Magnitude.
-## 
+##
 ## @item @qcode{"la"}
 ## Largest Algebraic (valid only for real symmetric problems).
-## 
+##
 ## @item @qcode{"sa"}
 ## Smallest Algebraic (valid only for real symmetric problems).
-## 
+##
 ## @item @qcode{"be"}
 ## Both Ends, with one more from the high-end if @var{k} is odd (valid only for
 ## real symmetric problems).
-## 
+##
 ## @item @qcode{"lr"}
 ## Largest Real part (valid only for complex or unsymmetric problems).
-## 
+##
 ## @item @qcode{"sr"}
 ## Smallest Real part (valid only for complex or unsymmetric problems).
-## 
+##
 ## @item @qcode{"li"}
 ## Largest Imaginary part (valid only for complex or unsymmetric problems).
-## 
+##
 ## @item @qcode{"si"}
 ## Smallest Imaginary part (valid only for complex or unsymmetric problems).
 ## @end table
-## 
+##
 ## If @var{opts} is given, it is a structure defining possible options that
 ## @code{eigs} should use.  The fields of the @var{opts} structure are:
-## 
+##
 ## @table @code
 ## @item issym
 ## If @var{af} is given, then flags whether the function @var{af} defines a
 ## symmetric problem.  It is ignored if @var{A} is given.  The default is false.
-## 
+##
 ## @item isreal
 ## If @var{af} is given, then flags whether the function @var{af} defines a
 ## real problem.  It is ignored if @var{A} is given.  The default is true.
-## 
+##
 ## @item tol
 ## Defines the required convergence tolerance, calculated as
 ## @code{tol * norm (A)}.  The default is @code{eps}.
-## 
+##
 ## @item maxit
 ## The maximum number of iterations.  The default is 300.
-## 
+##
 ## @item p
 ## The number of Lanzcos basis vectors to use.  More vectors will result in
 ## faster convergence, but a greater use of memory.  The optimal value of
 ## @code{p} is problem dependent and should be in the range @var{k} to @var{n}.
 ## The default value is @code{2 * @var{k}}.
-## 
+##
 ## @item v0
 ## The starting vector for the algorithm.  An initial vector close to the
 ## final vector will speed up convergence.  The default is for @sc{arpack}
 ## to randomly generate a starting vector.  If specified, @code{v0} must be
 ## an @var{n}-by-1 vector where @code{@var{n} = rows (@var{A})}
-## 
+##
 ## @item disp
 ## The level of diagnostic printout (0|1|2).  If @code{disp} is 0 then
 ## diagnostics are disabled.  The default value is 0.
-## 
+##
 ## @item cholB
 ## Flag if @code{chol (@var{B})} is passed rather than @var{B}.  The default is
 ## false.
-## 
+##
 ## @item permB
 ## The permutation vector of the Cholesky@tie{}factorization of @var{B} if
 ## @code{cholB} is true.  That is @code{chol (@var{B}(permB, permB))}.  The
 ## default is @code{1:@var{n}}.
-## 
+##
 ## @end table
-## 
+##
 ## It is also possible to represent @var{A} by a function denoted @var{af}.
 ## @var{af} must be followed by a scalar argument @var{n} defining the length
 ## of the vector argument accepted by @var{af}.  @var{af} can be
 ## a function handle, an inline function, or a string.  When @var{af} is a
 ## string it holds the name of the function to use.
-## 
+##
 ## @var{af} is a function of the form @code{y = af (x)}
 ## where the required return value of @var{af} is determined by
 ## the value of @var{sigma}.  The four possible forms are
-## 
+##
 ## @table @code
 ## @item A * x
 ## if @var{sigma} is not given or is a string other than "sm".
-## 
+##
 ## @item A \ x
 ## if @var{sigma} is 0 or "sm".
-## 
+##
 ## @item (A - sigma * I) \ x
 ## for the standard eigenvalue problem, where @code{I} is the identity matrix of
 ## the same size as @var{A}.
-## 
+##
 ## @item (A - sigma * B) \ x
 ## for the general eigenvalue problem.
 ## @end table
-## 
+##
 ## The return arguments of @code{eigs} depend on the number of return arguments
 ## requested.  With a single return argument, a vector @var{d} of length @var{k}
 ## is returned containing the @var{k} eigenvalues that have been found.  With
 ## two return arguments, @var{V} is a @var{n}-by-@var{k} matrix whose columns
 ## are the @var{k} eigenvectors corresponding to the returned eigenvalues.  The
 ## eigenvalues themselves are returned in @var{d} in the form of a
 ## @var{n}-by-@var{k} matrix, where the elements on the diagonal are the
 ## eigenvalues.
-## 
+##
 ## Given a third return argument @var{flag}, @code{eigs} returns the status
 ## of the convergence.  If @var{flag} is 0 then all eigenvalues have converged.
 ## Any other value indicates a failure to converge.
-## 
+##
 ## This function is based on the @sc{arpack} package, written by R. Lehoucq,
 ## K. Maschhoff, D. Sorensen, and C. Yang.  For more information see
 ## @url{http://www.caam.rice.edu/software/ARPACK/}.
-## 
+##
 ## @seealso{eig, svds}
 ## @end deftypefn
 
 function varargout = eigs (varargin)
 
   ## For compatibility with Matlab, handle small matrix cases here
   ## that ARPACK does not.
 
@@ -210,17 +210,17 @@ function varargout = eigs (varargin)
         && issquare (varargin{2}) && size_equal (a, varargin{2}))
       b = varargin{2};
       offset = 1;
     endif
 
     if (rows (a) < 9)
       call_eig = true;
     endif
-    
+
     if (nargin > 1 + offset)
       tmp = varargin{2+offset};
       if (isnumeric (tmp) && isscalar (tmp) && isreal (tmp)
           && round (tmp) == tmp)
         k = tmp;
 
         if (rows (a) - k < 3)
           call_eig = true;
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -104,17 +104,17 @@
 ## @item
 ## @var{eigest} returns the estimate for the smallest @code{@var{eigest}(1)}
 ## and largest @code{@var{eigest}(2)} eigenvalues of the preconditioned matrix
 ## @w{@code{@var{P} = @var{m} \ @var{A}}}.  In particular, if no
 ## preconditioning is used, the estimates for the extreme eigenvalues of
 ## @var{A} are returned.  @code{@var{eigest}(1)} is an overestimate and
 ## @code{@var{eigest}(2)} is an underestimate, so that
 ## @code{@var{eigest}(2) / @var{eigest}(1)} is a lower bound for
-## @code{cond (@var{P}, 2)}, which nevertheless in the limit should 
+## @code{cond (@var{P}, 2)}, which nevertheless in the limit should
 ## theoretically be equal to the actual value of the condition number.
 ## The method which computes @var{eigest} works only for symmetric positive
 ## definite @var{A} and @var{m}, and the user is responsible for verifying this
 ## assumption.
 ## @end itemize
 ##
 ## Let us consider a trivial problem with a diagonal matrix (we exploit the
 ## sparsity of A)
@@ -198,17 +198,17 @@
 ## References:
 ##
 ## @enumerate
 ## @item
 ## C.T. Kelley, @cite{Iterative Methods for Linear and Nonlinear Equations},
 ## SIAM, 1995. (the base PCG algorithm)
 ##
 ## @item
-## Y. Saad, @cite{Iterative Methods for Sparse Linear Systems}, 
+## Y. Saad, @cite{Iterative Methods for Sparse Linear Systems},
 ## @nospell{PWS} 1996. (condition number estimate from PCG)
 ## Revised version of this book is available online at
 ## @url{http://www-users.cs.umn.edu/~saad/books.html}
 ## @end enumerate
 ##
 ## @seealso{sparse, pcr}
 ## @end deftypefn
 
diff --git a/scripts/sparse/private/__sprand_impl__.m b/scripts/sparse/private/__sprand_impl__.m
--- a/scripts/sparse/private/__sprand_impl__.m
+++ b/scripts/sparse/private/__sprand_impl__.m
@@ -60,17 +60,17 @@ function S = __sprand_impl__ (varargin)
 
     idx = unique (fix (rand (min (k*1.01, k+10), 1) * mn)) + 1;
 
     ## idx contains random numbers in [1,mn]
     ## generate 1% or 10 more random values than necessary in order to
     ## reduce the probability that there are less than k distinct
     ## values; maybe a better strategy could be used but I don't think
     ## it's worth the price
-    
+
     ## actual number of entries in S
     k = min (length (idx), k);
     j = floor ((idx(1:k) - 1) / m);
     i = idx(1:k) - j * m;
     j++;
   else
     idx = randperm (mn, k);
     [i, j] = ind2sub ([m, n], idx);
diff --git a/scripts/sparse/sprand.m b/scripts/sparse/sprand.m
--- a/scripts/sparse/sprand.m
+++ b/scripts/sparse/sprand.m
@@ -76,12 +76,12 @@ endfunction
 %!error sprand (3.5, 3, 0.5)
 %!error sprand (0, 3, 0.5)
 %!error sprand (3, ones (3), 0.5)
 %!error sprand (3, 3.5, 0.5)
 %!error sprand (3, 0, 0.5)
 %!error sprand (3, 3, -1)
 %!error sprand (3, 3, 2)
 
-%% Test very large, very low density matrix doesn't fail 
+%% Test very large, very low density matrix doesn't fail
 %!test
 %! s = sprand(1e6,1e6,1e-7);
 
diff --git a/scripts/sparse/sprandn.m b/scripts/sparse/sprandn.m
--- a/scripts/sparse/sprandn.m
+++ b/scripts/sparse/sprandn.m
@@ -67,12 +67,12 @@ endfunction
 %!error sprandn (3.5, 3, 0.5)
 %!error sprandn (0, 3, 0.5)
 %!error sprandn (3, ones (3), 0.5)
 %!error sprandn (3, 3.5, 0.5)
 %!error sprandn (3, 0, 0.5)
 %!error sprandn (3, 3, -1)
 %!error sprandn (3, 3, 2)
 
-%% Test very large, very low density matrix doesn't fail 
+%% Test very large, very low density matrix doesn't fail
 %!test
 %! s = sprandn(1e6,1e6,1e-7);
 
diff --git a/scripts/sparse/spy.m b/scripts/sparse/spy.m
--- a/scripts/sparse/spy.m
+++ b/scripts/sparse/spy.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} spy (@var{x})
 ## @deftypefnx {Function File} {} spy (@dots{}, @var{markersize})
 ## @deftypefnx {Function File} {} spy (@dots{}, @var{line_spec})
 ## Plot the sparsity pattern of the sparse matrix @var{x}.
-## 
+##
 ## If the argument @var{markersize} is given as a scalar value, it is used to
 ## determine the point size in the plot.  If the string @var{line_spec} is
 ## given it is passed to @code{plot} and determines the appearance of the plot.
 ## @seealso{plot, gplot}
 ## @end deftypefn
 
 function spy (x, varargin)
 
diff --git a/scripts/sparse/svds.m b/scripts/sparse/svds.m
--- a/scripts/sparse/svds.m
+++ b/scripts/sparse/svds.m
@@ -138,17 +138,17 @@ function [u, s, v, flag] = svds (A, k, s
 
   [m, n] = size (A);
   max_a = max (abs (nonzeros (A)));
   if (isempty (max_a))
     max_a = 0;
   endif
   ## Must initialize variable value, otherwise it may appear to interpreter
   ## that code is trying to call flag() colormap function.
-  flag = 0;  
+  flag = 0;
 
   if (max_a == 0)
     s = zeros (k, 1);  # special case of zero matrix
   else
     if (nargin < 2)
       k = min ([6, m, n]);
     else
       k = min ([k, m, n]);
diff --git a/scripts/specfun/expint.m b/scripts/specfun/expint.m
--- a/scripts/specfun/expint.m
+++ b/scripts/specfun/expint.m
@@ -212,28 +212,28 @@ endfunction
 %!          0.056204378;
 %!          0.052414380;
 %!          0.048900511 ];
 %! y = expint (x);
 %! assert (y, y_exp, 1e-9);
 
 ## Series expansion (-2 < x < 0)
 ## Expected values from Mathematica
-%!test  
+%!test
 %! x = [-0.1; -0.5; -1; -1.5; -2];
 %! y_exp = [ 1.6228128139692767  - i*pi;
 %!          -0.45421990486317358 - i*pi;
 %!          -1.8951178163559368  - i*pi;
 %!          -3.3012854491297978  - i*pi;
 %!          -4.9542343560018902  - i*pi];
 %! y = expint (x);
 %! assert (y, y_exp, eps (real (y_exp)));
 
 ## (x < -2, x real)
-%!test  
+%!test
 %! x = [-2.5; -3; -10;-15; -25];
 %! y_exp = [-7.0737658945786007   - i*pi;
 %!          -9.9338325706254165   - i*pi;
 %!          -2492.2289762418777   - i*pi;
 %!          -234955.85249076830   - i*pi;
 %!          -3.0059509065255486e9 - i*pi];
 %! y = expint (x);
 %! assert (y, y_exp, 8*eps (real (y_exp)));
@@ -244,17 +244,17 @@ endfunction
 %! y_exp = [-0.33740392290096813   - i*0.62471325642771360;
 %!          -1.7646259855638540    + i*0.75382280207927082;
 %!          1.90746381979783120e-6 + i*3.67354374003294739e-6;
 %!          1.90746381979783120e-6 - i*3.67354374003294739e-6];
 %! y = expint (x);
 %! assert (y, y_exp, 1e-12);
 
 ## Exceptional values (-Inf, Inf, NaN, 0, 0.37250741078)
-%!test  
+%!test
 %! x = [-Inf; Inf; NaN; 0; -0.3725074107813668];
 %! y_exp = [-Inf - i*pi;
 %!          -Inf;  # should be 0;
 %!          NaN;
 %!          Inf;
 %!          0 - i*pi];
 %! y = expint (x);
 %! assert (y, y_exp, 5*eps);
diff --git a/scripts/specfun/factor.m b/scripts/specfun/factor.m
--- a/scripts/specfun/factor.m
+++ b/scripts/specfun/factor.m
@@ -22,17 +22,17 @@
 ##
 ## Return the prime factorization of @var{q}.  That is,
 ## @code{prod (@var{p}) == @var{q}} and every element of @var{p} is a prime
 ## number.  If @code{@var{q} == 1}, return 1.
 ##
 ## With two output arguments, return the unique primes @var{p} and
 ## their multiplicities.  That is, @code{prod (@var{p} .^ @var{n}) ==
 ## @var{q}}.
-## 
+##
 ## Implementation Note: The input @var{q} must not be greater than
 ## @code{bitmax} (9.0072e+15) in order to factor correctly.
 ## @seealso{gcd, lcm, isprime}
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 
 ## 2002-01-28 Paul Kienzle
diff --git a/scripts/special-matrix/gallery.m b/scripts/special-matrix/gallery.m
--- a/scripts/special-matrix/gallery.m
+++ b/scripts/special-matrix/gallery.m
@@ -1289,17 +1289,17 @@ function [v, beta] = house (x)
   ##         Theory: (textbook references Golub & Van Loan 1989, 38-43;
   ##                  Stewart 1973, 231-234, 262; Wilkinson 1965, 48-50).
   ##         Hx = y: (I - beta*v*v')x = -s*e_1.
   ##         Must have |s| = norm(x), v = x+s*e_1, and
   ##         x'y = x'Hx =(x'Hx)' real => arg(s) = arg(x(1)).
   ##         So take s = sign(x(1))*norm(x) (which avoids cancellation).
   ##         v'v = (x(1)+s)^2 + x(2)^2 + ... + x(n)^2
   ##             = 2*norm(x)*(norm(x) + |x(1)|).
-  ## 
+  ##
   ##         References:
   ##         G.H. Golub and C.F. Van Loan, Matrix Computations, second edition,
   ##            Johns Hopkins University Press, Baltimore, Maryland, 1989.
   ##         G.W. Stewart, Introduction to Matrix Computations, Academic Press,
   ##            New York, 1973,
   ##         J.H. Wilkinson, The Algebraic Eigenvalue Problem, Oxford University
   ##            Press, 1965.
 
@@ -1338,31 +1338,31 @@ function A = integerdata (varargin)
   elseif (ischar (varargin{end}))
     if (nargin < 4)
       error (["gallery: CLASS argument requires 4 inputs " ...
               "for integerdata matrix."]);
     endif
     jidx = varargin{end-1};
     svec = [varargin{1:end-1}];
     varargin(end-1) = [];
-  else 
+  else
     error (["gallery: J must be an integer in the range [0, 2^32-1] " ...
             "for integerdata matrix"]);
   endif
 
   if (! (isnumeric (jidx) && isscalar (jidx)
          && jidx == fix (jidx)
          && jidx >= 0 && jidx <= 0xFFFFFFFF))
     error (["gallery: J must be an integer in the range [0, 2^32-1] " ...
             "for integerdata matrix"]);
   endif
 
   ## Save and restore random state.  Initialization done so that reproducible
   ## data is available from gallery depending on the jidx and size vector.
-  randstate = rand ("state"); 
+  randstate = rand ("state");
   unwind_protect
     rand ("state", svec);
     A = randi (varargin{:});
   unwind_protect_cleanup
     rand ("state", randstate);
   end_unwind_protect
 
 endfunction
@@ -1456,17 +1456,17 @@ function [A, detA] = ipjfact (n, k = 0)
   ##                     A(i,j) = (i+j)!    (K = 0, default)
   ##                     A(i,j) = 1/(i+j)!  (K = 1)
   ##           Both are Hankel matrices.
   ##           The determinant and inverse are known explicitly.
   ##           If a second output argument is present, d = DET(A) is returned:
   ##           [A, d] = IPJFACT(N, K);
   ##
   ##           Suggested by P. R. Graves-Morris.
-  ## 
+  ##
   ##           Reference:
   ##           M.J.C. Gover, The explicit inverse of factorial Hankel matrices,
   ##           Dept. of Mathematics, University of Bradford, 1993.
 
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 to 2 arguments are required for ipjfact matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for ipjfact matrix.");
@@ -1857,31 +1857,31 @@ function A = normaldata (varargin)
   elseif (ischar (varargin{end}))
     if (nargin < 3)
       error (["gallery: CLASS argument requires 3 inputs " ...
               "for normaldata matrix."]);
     endif
     jidx = varargin{end-1};
     svec = [varargin{1:end-1}];
     varargin(end-1) = [];
-  else 
+  else
     error (["gallery: J must be an integer in the range [0, 2^32-1] " ...
             "for normaldata matrix"]);
   endif
 
   if (! (isnumeric (jidx) && isscalar (jidx)
          && jidx == fix (jidx)
          && jidx >= 0 && jidx <= 0xFFFFFFFF))
     error (["gallery: J must be an integer in the range [0, 2^32-1] " ...
             "for normaldata matrix"]);
   endif
 
   ## Save and restore random state.  Initialization done so that reproducible
   ## data is available from gallery depending on the jidx and size vector.
-  randstate = randn ("state"); 
+  randstate = randn ("state");
   unwind_protect
     randn ("state", svec);
     A = randn (varargin{:});
   unwind_protect_cleanup
     randn ("state", randstate);
   end_unwind_protect
 
 endfunction
@@ -1976,17 +1976,17 @@ function A = parter (n)
   ## PARTER    Parter matrix - a Toeplitz matrix with singular values near PI.
   ##           PARTER(N) is the matrix with (i,j) element 1/(i-j+0.5).
   ##           It is a Cauchy matrix and a Toeplitz matrix.
   ##
   ##           At the Second SIAM Conference on Linear Algebra, Raleigh, N.C.,
   ##           1985, Cleve Moler noted that most of the singular values of
   ##           PARTER(N) are very close to PI.  An explanation of the phenomenon
   ##           was given by Parter; see also the paper by Tyrtyshnikov.
-  ## 
+  ##
   ##           References:
   ##           The MathWorks Newsletter, Volume 1, Issue 1, March 1986, page 2.
   ##           S.V. Parter, On the distribution of the singular values of Toeplitz
   ##                matrices, Linear Algebra and Appl., 80 (1986), pp. 115-130.
   ##           E.E. Tyrtyshnikov, Cauchy-Toeplitz matrices and some applications,
   ##                Linear Algebra and Appl., 149 (1991), pp. 1-18.
 
   if (nargin != 1)
@@ -2082,17 +2082,17 @@ function H = randhess (x)
   ##        In both cases H is constructed via a product of N-1 Givens rotations.
   ##
   ##        Note: See Gragg (1986) for how to represent an N-by-N (complex)
   ##        unitary Hessenberg matrix with positive subdiagonal elements in terms
   ##        of 2N-1 real parameters (the Schur parametrization).
   ##        This M-file handles the real case only and is intended simply as a
   ##        convenient way to generate random or non-random orthogonal Hessenberg
   ##        matrices.
-  ## 
+  ##
   ##        Reference:
   ##        W.B. Gragg, The QR algorithm for unitary Hessenberg matrices,
   ##        J. Comp. Appl. Math., 16 (1986), pp. 1-8.
 
   if (nargin != 1)
     error ("gallery: 1 argument is required for randhess matrix.");
   elseif (! isnumeric (x) || ! isreal (x))
     error ("gallery: N or X must be numeric real values for randhess matrix.");
@@ -2578,31 +2578,31 @@ function A = uniformdata (varargin)
   elseif (ischar (varargin{end}))
     if (nargin < 3)
       error (["gallery: CLASS argument requires 3 inputs " ...
               "for uniformdata matrix."]);
     endif
     jidx = varargin{end-1};
     svec = [varargin{1:end-1}];
     varargin(end-1) = [];
-  else 
+  else
     error (["gallery: J must be an integer in the range [0, 2^32-1] " ...
             "for uniformdata matrix"]);
   endif
 
   if (! (isnumeric (jidx) && isscalar (jidx)
          && jidx == fix (jidx)
          && jidx >= 0 && jidx <= 0xFFFFFFFF))
     error (["gallery: J must be an integer in the range [0, 2^32-1] " ...
             "for uniformdata matrix"]);
   endif
 
   ## Save and restore random state.  Initialization done so that reproducible
   ## data is available from gallery depending on the jidx and size vector.
-  randstate = rand ("state"); 
+  randstate = rand ("state");
   unwind_protect
     rand ("state", svec);
     A = rand (varargin{:});
   unwind_protect_cleanup
     rand ("state", randstate);
   end_unwind_protect
 
 endfunction
@@ -2708,19 +2708,19 @@ function A = wathen (nx, ny, k = 0)
   n = 3*nx*ny + 2*nx + 2*ny + 1;
 
   A = sparse (n, n);
 
   rho = 100 * rand (nx, ny);
 
   for j = 1:ny
     for i = 1:nx
-      ## 
+      ##
       ##   For the element (I,J), determine the indices of the 8 nodes.
-      ## 
+      ##
       nn(1) = 3*j*nx + 2*i + 2*j + 1;
       nn(2) = nn(1) - 1;
       nn(3) = nn(2) - 1;
       nn(4) = (3*j - 1) * nx + 2*j + i - 1;
       nn(5) = 3 * (j-1) * nx + 2*i + 2*j - 3;
       nn(6) = nn(5) + 1;
       nn(7) = nn(6) + 1;
       nn(8) = nn(4) + 1;
@@ -2810,17 +2810,17 @@ function A = bandred (A, kl, ku)
   ##          (i.e. B(i,j) = 0 if i > j+KL or j > i+KU).
   ##          The reduction is performed using Householder transformations.
   ##          If KU is omitted it defaults to KL.
   ##
   ##          Called by RANDSVD.
   ##          This is a `standard' reduction.  Cf. reduction to bidiagonal form
   ##          prior to computing the SVD.  This code is a little wasteful in that
   ##          it computes certain elements which are immediately set to zero!
-  ## 
+  ##
   ##          Reference:
   ##          G.H. Golub and C.F. Van Loan, Matrix Computations, second edition,
   ##          Johns Hopkins University Press, Baltimore, Maryland, 1989.
   ##          Section 5.4.3.
 
   ##  Check for special case where order of left/right transformations matters.
   ##  Easiest approach is to work on the transpose, flipping back at the end.
   flip = false;
diff --git a/scripts/special-matrix/hankel.m b/scripts/special-matrix/hankel.m
--- a/scripts/special-matrix/hankel.m
+++ b/scripts/special-matrix/hankel.m
@@ -60,28 +60,28 @@ function retval = hankel (c, r)
     endif
 
     nr = length (c);
     nc = nr;
     data = [c(:) ; zeros(nr, 1)];
 
   else
 
-    if (! (isvector (c) && isvector (r))) 
+    if (! (isvector (c) && isvector (r)))
       error ("hankel: C and R must be vectors");
     elseif (r(1) != c(end))
       warning ("hankel: column wins anti-diagonal conflict");
     endif
 
     nr = length (c);
     nc = length (r);
     data = [c(:) ; r(2:end)(:)];
 
   endif
-   
+
   slices = cellslices (data, 1:nc, nr:1:nc+nr-1);
   retval = horzcat (slices{:});
 
 endfunction
 
 
 %!assert (hankel (1), [1])
 %!assert (hankel ([1, 2]), [1, 2; 2, 0])
diff --git a/scripts/special-matrix/toeplitz.m b/scripts/special-matrix/toeplitz.m
--- a/scripts/special-matrix/toeplitz.m
+++ b/scripts/special-matrix/toeplitz.m
@@ -66,17 +66,17 @@ function retval = toeplitz (c, r)
     if (! isvector (c))
       error ("toeplitz: C must be a vector");
     endif
 
     r = c;
     nr = length (c);
     nc = nr;
   else
-    if (! (isvector (c) && isvector (r))) 
+    if (! (isvector (c) && isvector (r)))
       error ("toeplitz: C and R must be vectors");
     elseif (r(1) != c(1))
       warning ("toeplitz: column wins diagonal conflict");
     endif
 
     nr = length (c);
     nc = length (r);
   endif
diff --git a/scripts/startup/inputrc b/scripts/startup/inputrc
--- a/scripts/startup/inputrc
+++ b/scripts/startup/inputrc
@@ -1,23 +1,23 @@
 ## This file configures the behavior of line-input editing for all
 ## Octave users when Octave is configured to use GNU Readline library
 ## for input-line editing.
 
 ## history-search-backward:
-## 
+##
 ##   Search backward through the history for the string of characters
 ##   between the start of the current line and the point.  This is a
 ##   non-incremental search.  Bound to "\e[A", the ANSI escape
 ##   sequence for the UP arrow.
 
 "\e[A": history-search-backward
 
 ## history-search-forward:
-## 
+##
 ##   Search forward through the history for the string of characters
 ##   between the start of the current line and the point.  This is a
 ##   non-incremental search.  Bound to "\e[B", the ANSI escape
 ##   sequence for the DOWN arrow.
 
 "\e[B": history-search-forward
 
 ## Disable so the usual paste shortcut will work on Windows systems.
diff --git a/scripts/statistics/base/kurtosis.m b/scripts/statistics/base/kurtosis.m
--- a/scripts/statistics/base/kurtosis.m
+++ b/scripts/statistics/base/kurtosis.m
@@ -113,17 +113,17 @@ function y = kurtosis (x, flag, dim)
 
   x = center (x, dim);   # center also promotes integer, logical to double
   v = var (x, 1, dim);   # normalize with 1/N
   y = sum (x .^ 4, dim);
   idx = (v != 0);
   y(idx) = y(idx) ./ (n * v(idx) .^ 2);
   y(! idx) = NaN;
 
-  ## Apply bias correction to the second and fourth central sample moment  
+  ## Apply bias correction to the second and fourth central sample moment
   if (flag == 0)
     if (n > 3)
       C = (n - 1) / ((n - 2) * (n - 3));
       y = 3 + C * ((n + 1) * y - 3 * (n - 1));
     else
       y(:) = NaN;
     endif
   endif
diff --git a/scripts/statistics/base/moment.m b/scripts/statistics/base/moment.m
--- a/scripts/statistics/base/moment.m
+++ b/scripts/statistics/base/moment.m
@@ -33,26 +33,26 @@
 ##
 ## @example
 ## @group
 ## 1/N SUM_i (x(i) - mean(x))^p
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
-## 
+##
 ## If @var{x} is a matrix, return the row vector containing the @var{p}-th
 ## central moment of each column.
 ##
 ## The optional string @var{type} specifies the type of moment to be computed.
 ## Valid options are:
 ##
 ## @table @asis
 ## @item @qcode{"c"}
-##   Central Moment (default). 
+##   Central Moment (default).
 ##
 ## @item  @qcode{"a"}
 ## @itemx @qcode{"ac"}
 ##   Absolute Central Moment.  The moment about the mean ignoring sign
 ## defined as
 ## @tex
 ## $$
 ## {\sum_{i=1}^N {\left| x_i - \bar{x} \right|}^p \over N}
@@ -64,18 +64,18 @@
 ## @group
 ## 1/N SUM_i (abs (x(i) - mean(x)))^p
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ##
 ## @item @qcode{"r"}
-##   Raw Moment.  The moment about zero defined as 
-## 
+##   Raw Moment.  The moment about zero defined as
+##
 ## @tex
 ## $$
 ## {\rm moment} (x) = { \sum_{i=1}^N {x_i}^p \over N }
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
diff --git a/scripts/statistics/base/qqplot.m b/scripts/statistics/base/qqplot.m
--- a/scripts/statistics/base/qqplot.m
+++ b/scripts/statistics/base/qqplot.m
@@ -87,17 +87,17 @@ function [qout, sout] = qqplot (x, dist,
     q_label = func2str (f);
   else
     q = f (t, varargin{:});
     if (nargin == 3)
       q_label = sprintf ("%s with parameter %g", func2str (f), varargin{1});
     else
       q_label = sprintf ("%s with parameters %g", func2str (f), varargin{1});
       param_str = sprintf (", %g", varargin{2:end});
-      q_label = [q_label param_str]; 
+      q_label = [q_label param_str];
     endif
   endif
 
   if (nargout == 0)
     plot (q, s);
     q_label = strrep (q_label, '_inv', '\_inv');
     if (q_label(1) == '@')
       q_label = q_label(6:end);  # Strip "@(y) " from anon. function
diff --git a/scripts/statistics/base/var.m b/scripts/statistics/base/var.m
--- a/scripts/statistics/base/var.m
+++ b/scripts/statistics/base/var.m
@@ -46,17 +46,17 @@
 ## @item 0:
 ##   normalize with @math{N-1}, provides the best unbiased estimator of the
 ## variance [default]
 ##
 ## @item 1:
 ##   normalizes with @math{N}, this provides the second moment around the mean
 ## @end table
 ##
-## If @math{N==1} the value of @var{opt} is ignored and normalization 
+## If @math{N==1} the value of @var{opt} is ignored and normalization
 ## by @math{N} is used.
 ##
 ## If the optional argument @var{dim} is given, operate along this dimension.
 ## @seealso{cov, std, skewness, kurtosis, moment}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Compute variance
diff --git a/scripts/statistics/distributions/betarnd.m b/scripts/statistics/distributions/betarnd.m
--- a/scripts/statistics/distributions/betarnd.m
+++ b/scripts/statistics/distributions/betarnd.m
@@ -25,17 +25,17 @@
 ## Return a matrix of random samples from the Beta distribution with parameters
 ## @var{a} and @var{b}.
 ##
 ## When called with a single size argument, return a square matrix with
 ## the dimension specified.  When called with more than one scalar argument the
 ## first two arguments are taken as the number of rows and columns and any
 ## further arguments specify additional matrix dimensions.  The size may also
 ## be specified with a vector of dimensions @var{sz}.
-## 
+##
 ## If no size arguments are given then the result matrix is the common size of
 ## @var{a} and @var{b}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the Beta distribution
 
 function rnd = betarnd (a, b, varargin)
diff --git a/scripts/statistics/distributions/binoinv.m b/scripts/statistics/distributions/binoinv.m
--- a/scripts/statistics/distributions/binoinv.m
+++ b/scripts/statistics/distributions/binoinv.m
@@ -15,17 +15,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} binoinv (@var{x}, @var{n}, @var{p})
 ## For each element of @var{x}, compute the quantile (the inverse of
-## the CDF) at @var{x} of the binomial distribution with parameters 
+## the CDF) at @var{x} of the binomial distribution with parameters
 ## @var{n} and @var{p}, where @var{n} is the number of trials and
 ## @var{p} is the probability of success.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the binomial distribution
 
 function inv = binoinv (x, n, p)
diff --git a/scripts/statistics/distributions/binopdf.m b/scripts/statistics/distributions/binopdf.m
--- a/scripts/statistics/distributions/binopdf.m
+++ b/scripts/statistics/distributions/binopdf.m
@@ -61,19 +61,19 @@ function pdf = binopdf (x, n, p)
                   + x(k)*log (p) + (n-x(k))*log (1-p));
   else
     pdf(k) = exp (gammaln (n(k)+1) - gammaln (x(k)+1) - gammaln (n(k)-x(k)+1)
                   + x(k).*log (p(k)) + (n(k)-x(k)).*log (1-p(k)));
   endif
 
   ## Special case inputs
   ksp = k & (p == 0) & (x == 0);
-  pdf(ksp) = 1; 
+  pdf(ksp) = 1;
   ksp = k & (p == 1) & (x == n);
-  pdf(ksp) = 1; 
+  pdf(ksp) = 1;
 
 endfunction
 
 
 %!shared x,y,tol
 %! if (ismac ())
 %!   tol = eps ();
 %! else
diff --git a/scripts/statistics/distributions/binornd.m b/scripts/statistics/distributions/binornd.m
--- a/scripts/statistics/distributions/binornd.m
+++ b/scripts/statistics/distributions/binornd.m
@@ -26,17 +26,17 @@
 ## parameters @var{n} and @var{p}, where @var{n} is the number of trials
 ## and @var{p} is the probability of success.
 ##
 ## When called with a single size argument, return a square matrix with
 ## the dimension specified.  When called with more than one scalar argument the
 ## first two arguments are taken as the number of rows and columns and any
 ## further arguments specify additional matrix dimensions.  The size may also
 ## be specified with a vector of dimensions @var{sz}.
-## 
+##
 ## If no size arguments are given then the result matrix is the common size of
 ## @var{n} and @var{p}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the binomial distribution
 
 function rnd = binornd (n, p, varargin)
diff --git a/scripts/statistics/distributions/cauchy_rnd.m b/scripts/statistics/distributions/cauchy_rnd.m
--- a/scripts/statistics/distributions/cauchy_rnd.m
+++ b/scripts/statistics/distributions/cauchy_rnd.m
@@ -25,17 +25,17 @@
 ## Return a matrix of random samples from the Cauchy distribution with
 ## parameters @var{location} and @var{scale}.
 ##
 ## When called with a single size argument, return a square matrix with
 ## the dimension specified.  When called with more than one scalar argument the
 ## first two arguments are taken as the number of rows and columns and any
 ## further arguments specify additional matrix dimensions.  The size may also
 ## be specified with a vector of dimensions @var{sz}.
-## 
+##
 ## If no size arguments are given then the result matrix is the common size of
 ## @var{location} and @var{scale}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the Cauchy distribution
 
 function rnd = cauchy_rnd (location, scale, varargin)
diff --git a/scripts/statistics/distributions/chi2rnd.m b/scripts/statistics/distributions/chi2rnd.m
--- a/scripts/statistics/distributions/chi2rnd.m
+++ b/scripts/statistics/distributions/chi2rnd.m
@@ -25,17 +25,17 @@
 ## Return a matrix of random samples from the chi-square distribution with
 ## @var{n} degrees of freedom.
 ##
 ## When called with a single size argument, return a square matrix with
 ## the dimension specified.  When called with more than one scalar argument the
 ## first two arguments are taken as the number of rows and columns and any
 ## further arguments specify additional matrix dimensions.  The size may also
 ## be specified with a vector of dimensions @var{sz}.
-## 
+##
 ## If no size arguments are given then the result matrix is the size of
 ## @var{n}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the chi-square distribution
 
 function rnd = chi2rnd (n, varargin)
diff --git a/scripts/statistics/distributions/discrete_pdf.m b/scripts/statistics/distributions/discrete_pdf.m
--- a/scripts/statistics/distributions/discrete_pdf.m
+++ b/scripts/statistics/distributions/discrete_pdf.m
@@ -39,17 +39,17 @@ function pdf = discrete_pdf (x, v, p)
     error ("discrete_pdf: V must not have any NaN elements");
   elseif (! isvector (p) || (length (p) != length (v)))
     error ("discrete_pdf: P must be a vector with length (V) elements");
   elseif (! (all (p >= 0) && any (p)))
     error ("discrete_pdf: P must be a nonzero, non-negative vector");
   endif
 
   ## Reshape and normalize probability vector.  Values not in table get 0 prob.
-  p = [0 ; p(:)/sum(p)];   
+  p = [0 ; p(:)/sum(p)];
 
   if (isa (x, "single") || isa (v, "single") || isa (p, "single"))
     pdf = NaN (size (x), "single");
   else
     pdf = NaN (size (x));
   endif
 
   k = !isnan (x);
diff --git a/scripts/statistics/distributions/discrete_rnd.m b/scripts/statistics/distributions/discrete_rnd.m
--- a/scripts/statistics/distributions/discrete_rnd.m
+++ b/scripts/statistics/distributions/discrete_rnd.m
@@ -25,17 +25,17 @@
 ## Return a matrix of random samples from the univariate distribution which
 ## assumes the values in @var{v} with probabilities @var{p}.
 ##
 ## When called with a single size argument, return a square matrix with
 ## the dimension specified.  When called with more than one scalar argument the
 ## first two arguments are taken as the number of rows and columns and any
 ## further arguments specify additional matrix dimensions.  The size may also
 ## be specified with a vector of dimensions @var{sz}.
-## 
+##
 ## If no size arguments are given then the result matrix is the common size of
 ## @var{v} and @var{p}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from a discrete distribution
 
 function rnd = discrete_rnd (v, p, varargin)
diff --git a/scripts/statistics/distributions/empirical_rnd.m b/scripts/statistics/distributions/empirical_rnd.m
--- a/scripts/statistics/distributions/empirical_rnd.m
+++ b/scripts/statistics/distributions/empirical_rnd.m
@@ -25,17 +25,17 @@
 ## Return a matrix of random samples from the empirical distribution obtained
 ## from the univariate sample @var{data}.
 ##
 ## When called with a single size argument, return a square matrix with
 ## the dimension specified.  When called with more than one scalar argument the
 ## first two arguments are taken as the number of rows and columns and any
 ## further arguments specify additional matrix dimensions.  The size may also
 ## be specified with a vector of dimensions @var{sz}.
-## 
+##
 ## If no size arguments are given then the result matrix is a random ordering
 ## of the sample @var{data}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Bootstrap samples from the empirical distribution
 
 function rnd = empirical_rnd (data, varargin)
diff --git a/scripts/statistics/distributions/exprnd.m b/scripts/statistics/distributions/exprnd.m
--- a/scripts/statistics/distributions/exprnd.m
+++ b/scripts/statistics/distributions/exprnd.m
@@ -25,17 +25,17 @@
 ## Return a matrix of random samples from the exponential distribution with
 ## mean @var{lambda}.
 ##
 ## When called with a single size argument, return a square matrix with
 ## the dimension specified.  When called with more than one scalar argument the
 ## first two arguments are taken as the number of rows and columns and any
 ## further arguments specify additional matrix dimensions.  The size may also
 ## be specified with a vector of dimensions @var{sz}.
-## 
+##
 ## If no size arguments are given then the result matrix is the size of
 ## @var{lambda}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the exponential distribution
 
 function rnd = exprnd (lambda, varargin)
diff --git a/scripts/statistics/distributions/frnd.m b/scripts/statistics/distributions/frnd.m
--- a/scripts/statistics/distributions/frnd.m
+++ b/scripts/statistics/distributions/frnd.m
@@ -25,17 +25,17 @@
 ## Return a matrix of random samples from the F distribution with
 ## @var{m} and @var{n} degrees of freedom.
 ##
 ## When called with a single size argument, return a square matrix with
 ## the dimension specified.  When called with more than one scalar argument the
 ## first two arguments are taken as the number of rows and columns and any
 ## further arguments specify additional matrix dimensions.  The size may also
 ## be specified with a vector of dimensions @var{sz}.
-## 
+##
 ## If no size arguments are given then the result matrix is the common size of
 ## @var{m} and @var{n}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the F distribution
 
 function rnd = frnd (m, n, varargin)
diff --git a/scripts/statistics/distributions/gamrnd.m b/scripts/statistics/distributions/gamrnd.m
--- a/scripts/statistics/distributions/gamrnd.m
+++ b/scripts/statistics/distributions/gamrnd.m
@@ -25,17 +25,17 @@
 ## Return a matrix of random samples from the Gamma distribution with
 ## shape parameter @var{a} and scale @var{b}.
 ##
 ## When called with a single size argument, return a square matrix with
 ## the dimension specified.  When called with more than one scalar argument the
 ## first two arguments are taken as the number of rows and columns and any
 ## further arguments specify additional matrix dimensions.  The size may also
 ## be specified with a vector of dimensions @var{sz}.
-## 
+##
 ## If no size arguments are given then the result matrix is the common size of
 ## @var{a} and @var{b}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the Gamma distribution
 
 function rnd = gamrnd (a, b, varargin)
@@ -80,17 +80,17 @@ function rnd = gamrnd (a, b, varargin)
     cls = "single";
   else
     cls = "double";
   endif
 
   if (isscalar (a) && isscalar (b))
     if ((a > 0) && (a < Inf) && (b > 0) && (b < Inf))
       rnd = b * randg (a, sz, cls);
-    else 
+    else
       rnd = NaN (sz, cls);
     endif
   else
     rnd = NaN (sz, cls);
 
     k = (a > 0) & (a < Inf) & (b > 0) & (b < Inf);
     rnd(k) = b(k) .* randg (a(k), cls);
   endif
diff --git a/scripts/statistics/distributions/geornd.m b/scripts/statistics/distributions/geornd.m
--- a/scripts/statistics/distributions/geornd.m
+++ b/scripts/statistics/distributions/geornd.m
@@ -25,17 +25,17 @@
 ## Return a matrix of random samples from the geometric distribution with
 ## parameter @var{p}.
 ##
 ## When called with a single size argument, return a square matrix with
 ## the dimension specified.  When called with more than one scalar argument the
 ## first two arguments are taken as the number of rows and columns and any
 ## further arguments specify additional matrix dimensions.  The size may also
 ## be specified with a vector of dimensions @var{sz}.
-## 
+##
 ## If no size arguments are given then the result matrix is the size of
 ## @var{p}.
 ##
 ## The geometric distribution models the number of failures (@var{x}-1) of a
 ## Bernoulli trial with probability @var{p} before the first success (@var{x}).
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
diff --git a/scripts/statistics/distributions/hygernd.m b/scripts/statistics/distributions/hygernd.m
--- a/scripts/statistics/distributions/hygernd.m
+++ b/scripts/statistics/distributions/hygernd.m
@@ -28,17 +28,17 @@
 ## The parameters @var{t}, @var{m}, and @var{n} must be positive integers
 ## with @var{m} and @var{n} not greater than @var{t}.
 ##
 ## When called with a single size argument, return a square matrix with
 ## the dimension specified.  When called with more than one scalar argument the
 ## first two arguments are taken as the number of rows and columns and any
 ## further arguments specify additional matrix dimensions.  The size may also
 ## be specified with a vector of dimensions @var{sz}.
-## 
+##
 ## If no size arguments are given then the result matrix is the common size of
 ## @var{t}, @var{m}, and @var{n}.
 ## @end deftypefn
 
 function rnd = hygernd (t, m, n, varargin)
 
   if (nargin < 3)
     print_usage ();
diff --git a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
--- a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
+++ b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
@@ -14,17 +14,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} kolmogorov_smirnov_cdf (@var{x}, @var{tol})
-## Return the cumulative distribution function (CDF) at @var{x} of the 
+## Return the cumulative distribution function (CDF) at @var{x} of the
 ## Kolmogorov-Smirnov distribution,
 ## @tex
 ## $$ Q(x) = \sum_{k=-\infty}^\infty (-1)^k \exp (-2 k^2 x^2) $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
diff --git a/scripts/statistics/distributions/laplace_cdf.m b/scripts/statistics/distributions/laplace_cdf.m
--- a/scripts/statistics/distributions/laplace_cdf.m
+++ b/scripts/statistics/distributions/laplace_cdf.m
@@ -38,17 +38,17 @@ function cdf = laplace_cdf (x)
 
   cdf = (1 + sign (x) .* (1 - exp (- abs (x)))) / 2;
 
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf -log(2) 0 log(2) Inf];
-%! y = [0, 1/4, 1/2, 3/4, 1]; 
+%! y = [0, 1/4, 1/2, 3/4, 1];
 %!assert (laplace_cdf ([x, NaN]), [y, NaN])
 
 %% Test class of input preserved
 %!assert (laplace_cdf (single ([x, NaN])), single ([y, NaN]))
 
 %% Test input validation
 %!error laplace_cdf ()
 %!error laplace_cdf (1,2)
diff --git a/scripts/statistics/distributions/laplace_pdf.m b/scripts/statistics/distributions/laplace_pdf.m
--- a/scripts/statistics/distributions/laplace_pdf.m
+++ b/scripts/statistics/distributions/laplace_pdf.m
@@ -26,29 +26,29 @@
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the Laplace distribution
 
 function pdf = laplace_pdf (x)
 
   if (nargin != 1)
     print_usage ();
   endif
-  
+
   if (iscomplex (x))
     error ("laplace_pdf: X must not be complex");
   endif
 
   pdf = exp (- abs (x)) / 2;
 
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf -log(2) 0 log(2) Inf];
-%! y = [0, 1/4, 1/2, 1/4, 0]; 
+%! y = [0, 1/4, 1/2, 1/4, 0];
 %!assert (laplace_pdf ([x, NaN]), [y, NaN])
 
 %% Test class of input preserved
 %!assert (laplace_pdf (single ([x, NaN])), single ([y, NaN]))
 
 %% Test input validation
 %!error laplace_pdf ()
 %!error laplace_pdf (1,2)
diff --git a/scripts/statistics/distributions/logistic_cdf.m b/scripts/statistics/distributions/logistic_cdf.m
--- a/scripts/statistics/distributions/logistic_cdf.m
+++ b/scripts/statistics/distributions/logistic_cdf.m
@@ -38,17 +38,17 @@ function cdf = logistic_cdf (x)
 
   cdf = 1 ./ (1 + exp (-x));
 
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf -log(3) 0 log(3) Inf];
-%! y = [0, 1/4, 1/2, 3/4, 1]; 
+%! y = [0, 1/4, 1/2, 3/4, 1];
 %!assert (logistic_cdf ([x, NaN]), [y, NaN], eps)
 
 %% Test class of input preserved
 %!assert (logistic_cdf (single ([x, NaN])), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error logistic_cdf ()
 %!error logistic_cdf (1,2)
diff --git a/scripts/statistics/distributions/logistic_pdf.m b/scripts/statistics/distributions/logistic_pdf.m
--- a/scripts/statistics/distributions/logistic_pdf.m
+++ b/scripts/statistics/distributions/logistic_pdf.m
@@ -38,17 +38,17 @@ function pdf = logistic_pdf (x)
   cdf = logistic_cdf (x);
   pdf = cdf .* (1 - cdf);
 
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf -log(4) 0 log(4) Inf];
-%! y = [0, 0.16, 1/4, 0.16, 0]; 
+%! y = [0, 0.16, 1/4, 0.16, 0];
 %!assert (logistic_pdf ([x, NaN]), [y, NaN], eps)
 
 %% Test class of input preserved
 %!assert (logistic_pdf (single ([x, NaN])), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error logistic_pdf ()
 %!error logistic_pdf (1,2)
diff --git a/scripts/statistics/distributions/lognrnd.m b/scripts/statistics/distributions/lognrnd.m
--- a/scripts/statistics/distributions/lognrnd.m
+++ b/scripts/statistics/distributions/lognrnd.m
@@ -25,17 +25,17 @@
 ## Return a matrix of random samples from the lognormal distribution with
 ## parameters @var{mu} and @var{sigma}.
 ##
 ## When called with a single size argument, return a square matrix with
 ## the dimension specified.  When called with more than one scalar argument the
 ## first two arguments are taken as the number of rows and columns and any
 ## further arguments specify additional matrix dimensions.  The size may also
 ## be specified with a vector of dimensions @var{sz}.
-## 
+##
 ## If no size arguments are given then the result matrix is the common size of
 ## @var{mu} and @var{sigma}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the log normal distribution
 
 function rnd = lognrnd (mu, sigma, varargin)
diff --git a/scripts/statistics/distributions/nbincdf.m b/scripts/statistics/distributions/nbincdf.m
--- a/scripts/statistics/distributions/nbincdf.m
+++ b/scripts/statistics/distributions/nbincdf.m
@@ -20,17 +20,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} nbincdf (@var{x}, @var{n}, @var{p})
 ## For each element of @var{x}, compute the cumulative distribution function
 ## (CDF) at @var{x} of the negative binomial distribution with
 ## parameters @var{n} and @var{p}.
 ##
 ## When @var{n} is integer this is the Pascal distribution.  When
 ## @var{n} is extended to real numbers this is the Polya distribution.
-## 
+##
 ## The number of failures in a Bernoulli experiment with success
 ## probability @var{p} before the @var{n}-th success follows this
 ## distribution.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: CDF of the Pascal (negative binomial) distribution
 
@@ -52,17 +52,17 @@ function cdf = nbincdf (x, n, p)
   endif
 
   if (isa (x, "single") || isa (n, "single") || isa (p, "single"))
     cdf = zeros (size (x), "single");
   else
     cdf = zeros (size (x));
   endif
 
-  k = (isnan (x) | isnan (n) | (n < 1) | (n == Inf) 
+  k = (isnan (x) | isnan (n) | (n < 1) | (n == Inf)
        | (p < 0) | (p > 1) | isnan (p));
   cdf(k) = NaN;
 
   k = (x == Inf) & (n > 0) & (n < Inf) & (p >= 0) & (p <= 1);
   cdf(k) = 1;
 
   k = ((x >= 0) & (x < Inf) & (x == fix (x))
        & (n > 0) & (n < Inf) & (p > 0) & (p <= 1));
diff --git a/scripts/statistics/distributions/nbininv.m b/scripts/statistics/distributions/nbininv.m
--- a/scripts/statistics/distributions/nbininv.m
+++ b/scripts/statistics/distributions/nbininv.m
@@ -20,17 +20,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} nbininv (@var{x}, @var{n}, @var{p})
 ## For each element of @var{x}, compute the quantile (the inverse of
 ## the CDF) at @var{x} of the negative binomial distribution
 ## with parameters @var{n} and @var{p}.
 ##
 ## When @var{n} is integer this is the Pascal distribution.  When
 ## @var{n} is extended to real numbers this is the Polya distribution.
-## 
+##
 ## The number of failures in a Bernoulli experiment with success
 ## probability @var{p} before the @var{n}-th success follows this
 ## distribution.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the Pascal distribution
 
diff --git a/scripts/statistics/distributions/nbinpdf.m b/scripts/statistics/distributions/nbinpdf.m
--- a/scripts/statistics/distributions/nbinpdf.m
+++ b/scripts/statistics/distributions/nbinpdf.m
@@ -20,17 +20,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} nbinpdf (@var{x}, @var{n}, @var{p})
 ## For each element of @var{x}, compute the probability density function
 ## (PDF) at @var{x} of the negative binomial distribution with
 ## parameters @var{n} and @var{p}.
 ##
 ## When @var{n} is integer this is the Pascal distribution.  When
 ## @var{n} is extended to real numbers this is the Polya distribution.
-## 
+##
 ## The number of failures in a Bernoulli experiment with success
 ## probability @var{p} before the @var{n}-th success follows this
 ## distribution.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the Pascal (negative binomial) distribution
 
@@ -63,17 +63,17 @@ function pdf = nbinpdf (x, n, p)
   pdf(k) = 0;
 
   k = (x >= 0) & ok;
   if (isscalar (n) && isscalar (p))
     pdf(k) = bincoeff (-n, x(k)) .* (p ^ n) .* ((p - 1) .^ x(k));
   else
     pdf(k) = bincoeff (-n(k), x(k)) .* (p(k) .^ n(k)) .* ((p(k) - 1) .^ x(k));
   endif
-  
+
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 1 2 Inf];
 %! y = [0 1/2 1/4 1/8 NaN];
 %!assert (nbinpdf (x, ones (1,5), 0.5*ones (1,5)), y)
diff --git a/scripts/statistics/distributions/nbinrnd.m b/scripts/statistics/distributions/nbinrnd.m
--- a/scripts/statistics/distributions/nbinrnd.m
+++ b/scripts/statistics/distributions/nbinrnd.m
@@ -25,17 +25,17 @@
 ## Return a matrix of random samples from the negative binomial
 ## distribution with parameters @var{n} and @var{p}.
 ##
 ## When called with a single size argument, return a square matrix with
 ## the dimension specified.  When called with more than one scalar argument the
 ## first two arguments are taken as the number of rows and columns and any
 ## further arguments specify additional matrix dimensions.  The size may also
 ## be specified with a vector of dimensions @var{sz}.
-## 
+##
 ## If no size arguments are given then the result matrix is the common size of
 ## @var{n} and @var{p}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the Pascal distribution
 
 function rnd = nbinrnd (n, p, varargin)
diff --git a/scripts/statistics/distributions/normrnd.m b/scripts/statistics/distributions/normrnd.m
--- a/scripts/statistics/distributions/normrnd.m
+++ b/scripts/statistics/distributions/normrnd.m
@@ -25,17 +25,17 @@
 ## Return a matrix of random samples from the normal distribution with
 ## parameters mean @var{mu} and standard deviation @var{sigma}.
 ##
 ## When called with a single size argument, return a square matrix with
 ## the dimension specified.  When called with more than one scalar argument the
 ## first two arguments are taken as the number of rows and columns and any
 ## further arguments specify additional matrix dimensions.  The size may also
 ## be specified with a vector of dimensions @var{sz}.
-## 
+##
 ## If no size arguments are given then the result matrix is the common size of
 ## @var{mu} and @var{sigma}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the normal distribution
 
 function rnd = normrnd (mu, sigma, varargin)
diff --git a/scripts/statistics/distributions/poissinv.m b/scripts/statistics/distributions/poissinv.m
--- a/scripts/statistics/distributions/poissinv.m
+++ b/scripts/statistics/distributions/poissinv.m
@@ -57,17 +57,17 @@ function inv = poissinv (x, lambda)
   inv(k) = Inf;
 
   k = find ((x > 0) & (x < 1) & (lambda > 0));
   if (isscalar (lambda))
     cdf = exp (-lambda) * ones (size (k));
   else
     cdf = exp (-lambda(k));
   endif
-  
+
   while (1)
     m = find (cdf < x(k));
     if (any (m))
       inv(k(m)) += 1;
       if (isscalar (lambda))
         cdf(m) = cdf(m) + poisspdf (inv(k(m)), lambda);
       else
         cdf(m) = cdf(m) + poisspdf (inv(k(m)), lambda(k(m)));
diff --git a/scripts/statistics/distributions/poissrnd.m b/scripts/statistics/distributions/poissrnd.m
--- a/scripts/statistics/distributions/poissrnd.m
+++ b/scripts/statistics/distributions/poissrnd.m
@@ -25,17 +25,17 @@
 ## Return a matrix of random samples from the Poisson distribution with
 ## parameter @var{lambda}.
 ##
 ## When called with a single size argument, return a square matrix with
 ## the dimension specified.  When called with more than one scalar argument the
 ## first two arguments are taken as the number of rows and columns and any
 ## further arguments specify additional matrix dimensions.  The size may also
 ## be specified with a vector of dimensions @var{sz}.
-## 
+##
 ## If no size arguments are given then the result matrix is the size of
 ## @var{lambda}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the Poisson distribution
 
 function rnd = poissrnd (lambda, varargin)
diff --git a/scripts/statistics/distributions/tinv.m b/scripts/statistics/distributions/tinv.m
--- a/scripts/statistics/distributions/tinv.m
+++ b/scripts/statistics/distributions/tinv.m
@@ -15,17 +15,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} tinv (@var{x}, @var{n})
 ## For each element of @var{x}, compute the quantile (the inverse of
-## the CDF) at @var{x} of the t (Student) distribution with @var{n} 
+## the CDF) at @var{x} of the t (Student) distribution with @var{n}
 ## degrees of freedom.  This function is analogous to looking in a table
 ## for the t-value of a single-tailed distribution.
 ## @end deftypefn
 
 ## For very large n, the "correct" formula does not really work well,
 ## and the quantiles of the standard normal distribution are used
 ## directly.
 
diff --git a/scripts/statistics/distributions/trnd.m b/scripts/statistics/distributions/trnd.m
--- a/scripts/statistics/distributions/trnd.m
+++ b/scripts/statistics/distributions/trnd.m
@@ -25,17 +25,17 @@
 ## Return a matrix of random samples from the t (Student) distribution with
 ## @var{n} degrees of freedom.
 ##
 ## When called with a single size argument, return a square matrix with
 ## the dimension specified.  When called with more than one scalar argument the
 ## first two arguments are taken as the number of rows and columns and any
 ## further arguments specify additional matrix dimensions.  The size may also
 ## be specified with a vector of dimensions @var{sz}.
-## 
+##
 ## If no size arguments are given then the result matrix is the size of
 ## @var{n}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the t distribution
 
 function rnd = trnd (n, varargin)
diff --git a/scripts/statistics/distributions/unidcdf.m b/scripts/statistics/distributions/unidcdf.m
--- a/scripts/statistics/distributions/unidcdf.m
+++ b/scripts/statistics/distributions/unidcdf.m
@@ -47,17 +47,17 @@ function cdf = unidcdf (x, n)
     cdf = zeros (size (x));
   endif
 
   knan = isnan (x) | ! (n > 0 & n == fix (n));
   if (any (knan(:)))
     cdf(knan) = NaN;
   endif
 
-  k = (x >= n) & !knan;  
+  k = (x >= n) & !knan;
   cdf(k) = 1;
 
   k = (x >= 1) & (x < n) & !knan;
   if (isscalar (n))
     cdf(k) = floor (x(k)) / n;
   else
     cdf(k) = floor (x(k)) ./ n(k);
   endif
diff --git a/scripts/statistics/distributions/unidpdf.m b/scripts/statistics/distributions/unidpdf.m
--- a/scripts/statistics/distributions/unidpdf.m
+++ b/scripts/statistics/distributions/unidpdf.m
@@ -19,17 +19,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} unidpdf (@var{x}, @var{n})
 ## For each element of @var{x}, compute the probability density function
 ## (PDF) at @var{x} of a discrete uniform distribution which assumes
 ## the integer values 1--@var{n} with equal probability.
 ##
 ## Warning: The underlying implementation uses the double class and
-## will only be accurate for @var{n} @leq{} @code{bitmax} 
+## will only be accurate for @var{n} @leq{} @code{bitmax}
 ## (@w{@math{2^{53} - 1}} on IEEE-754 compatible systems).
 ## @end deftypefn
 
 function pdf = unidpdf (x, n)
 
   if (nargin != 2)
     print_usage ();
   endif
diff --git a/scripts/statistics/distributions/unidrnd.m b/scripts/statistics/distributions/unidrnd.m
--- a/scripts/statistics/distributions/unidrnd.m
+++ b/scripts/statistics/distributions/unidrnd.m
@@ -26,17 +26,17 @@
 ## which assumes the integer values 1--@var{n} with equal probability.
 ## @var{n} may be a scalar or a multi-dimensional array.
 ##
 ## When called with a single size argument, return a square matrix with
 ## the dimension specified.  When called with more than one scalar argument the
 ## first two arguments are taken as the number of rows and columns and any
 ## further arguments specify additional matrix dimensions.  The size may also
 ## be specified with a vector of dimensions @var{sz}.
-## 
+##
 ## If no size arguments are given then the result matrix is the size of
 ## @var{n}.
 ## @end deftypefn
 
 ## Author: jwe
 
 function rnd = unidrnd (n, varargin)
 
diff --git a/scripts/statistics/distributions/unifrnd.m b/scripts/statistics/distributions/unifrnd.m
--- a/scripts/statistics/distributions/unifrnd.m
+++ b/scripts/statistics/distributions/unifrnd.m
@@ -25,17 +25,17 @@
 ## Return a matrix of random samples from the uniform distribution on
 ## [@var{a}, @var{b}].
 ##
 ## When called with a single size argument, return a square matrix with
 ## the dimension specified.  When called with more than one scalar argument the
 ## first two arguments are taken as the number of rows and columns and any
 ## further arguments specify additional matrix dimensions.  The size may also
 ## be specified with a vector of dimensions @var{sz}.
-## 
+##
 ## If no size arguments are given then the result matrix is the common size of
 ## @var{a} and @var{b}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the uniform distribution
 
 function rnd = unifrnd (a, b, varargin)
diff --git a/scripts/statistics/distributions/wblrnd.m b/scripts/statistics/distributions/wblrnd.m
--- a/scripts/statistics/distributions/wblrnd.m
+++ b/scripts/statistics/distributions/wblrnd.m
@@ -25,17 +25,17 @@
 ## Return a matrix of random samples from the Weibull distribution with
 ## parameters @var{scale} and @var{shape}.
 ##
 ## When called with a single size argument, return a square matrix with
 ## the dimension specified.  When called with more than one scalar argument the
 ## first two arguments are taken as the number of rows and columns and any
 ## further arguments specify additional matrix dimensions.  The size may also
 ## be specified with a vector of dimensions @var{sz}.
-## 
+##
 ## If no size arguments are given then the result matrix is the common size of
 ## @var{scale} and @var{shape}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the Weibull distribution
 
 function rnd = wblrnd (scale, shape, varargin)
diff --git a/scripts/statistics/models/module.mk b/scripts/statistics/models/module.mk
--- a/scripts/statistics/models/module.mk
+++ b/scripts/statistics/models/module.mk
@@ -1,15 +1,15 @@
 FCN_FILE_DIRS += statistics/models
 
 statistics_models_PRIVATE_FCN_FILES = \
   statistics/models/private/logistic_regression_derivatives.m \
   statistics/models/private/logistic_regression_likelihood.m
 
 statistics_models_FCN_FILES = \
   statistics/models/logistic_regression.m \
-  $(statistics_models_PRIVATE_FCN_FILES) 
+  $(statistics_models_PRIVATE_FCN_FILES)
 
 FCN_FILES += $(statistics_models_FCN_FILES)
 
 PKG_ADD_FILES += statistics/models/PKG_ADD
 
 DIRSTAMP_FILES += statistics/models/$(octave_dirstamp)
diff --git a/scripts/statistics/tests/kruskal_wallis_test.m b/scripts/statistics/tests/kruskal_wallis_test.m
--- a/scripts/statistics/tests/kruskal_wallis_test.m
+++ b/scripts/statistics/tests/kruskal_wallis_test.m
@@ -32,17 +32,17 @@
 ## @var{k} is divided by
 ##
 ## 1 - @var{sum_ties} / (@var{n}^3 - @var{n})
 ##
 ## where @var{sum_ties} is the sum of @var{t}^2 - @var{t} over each group
 ## of ties where @var{t} is the number of ties in the group and @var{n}
 ## is the total number of values in the input data.  For more info on
 ## this adjustment see William H. Kruskal and W. Allen Wallis,
-## @cite{Use of Ranks in One-Criterion Variance Analysis}, 
+## @cite{Use of Ranks in One-Criterion Variance Analysis},
 ## Journal of the American Statistical Association, Vol. 47,
 ## No. 260 (Dec 1952).
 ##
 ## The p-value (1 minus the CDF of this distribution at @var{k}) is
 ## returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value is displayed.
 ## @end deftypefn
diff --git a/scripts/strings/base2dec.m b/scripts/strings/base2dec.m
--- a/scripts/strings/base2dec.m
+++ b/scripts/strings/base2dec.m
@@ -91,17 +91,17 @@ function out = base2dec (s, base)
     num_nonbl = sum (nonbl);
     nc = max (num_nonbl);
     num_blank = nc - num_nonbl;
     R = repmat ([1 2; 0 0], 1, nr);
     R(2, 1:2:2*nr) = num_blank;
     R(2, 2:2:2*nr) = num_nonbl;
     idx = repelems ([false, true], R);
     idx = reshape (idx, nc, nr);
-    
+
     ## Create a blank matrix and position the nonblank characters.
     s2 = repmat (" ", nc, nr);
     s2(idx) = s(nonbl);
     s = s2.';
   endif
 
   ## Lookup value of symbols in symbol table, with invalid symbols
   ## evaluating to NaN and space evaluating to 0.
diff --git a/scripts/strings/deblank.m b/scripts/strings/deblank.m
--- a/scripts/strings/deblank.m
+++ b/scripts/strings/deblank.m
@@ -54,17 +54,17 @@ function s = deblank (s)
     else
       s = s(:,1:ceil (max (k) / rows (s)));
     endif
 
   elseif (iscell (s))
 
     char_idx = cellfun ("isclass", s, "char");
     cell_idx = cellfun ("isclass", s, "cell");
-    if (! all (char_idx | cell_idx))  
+    if (! all (char_idx | cell_idx))
       error ("deblank: S argument must be a string or cellstring");
     endif
 
     ## Divide work load.  Recursive cellfun deblank call is slow
     ## and avoided where possible.
     s(char_idx) = regexprep (s(char_idx), "[\\s\v\\0]+$", '');
     s(cell_idx) = cellfun ("deblank", s(cell_idx), "UniformOutput", false);
 
diff --git a/scripts/strings/dec2base.m b/scripts/strings/dec2base.m
--- a/scripts/strings/dec2base.m
+++ b/scripts/strings/dec2base.m
@@ -25,17 +25,17 @@
 ## @example
 ## @group
 ## dec2base (123, 3)
 ##    @result{} "11120"
 ## @end group
 ## @end example
 ##
 ## If @var{d} is a matrix or cell array, return a string matrix with one
-## row per element in @var{d}, padded with leading zeros to the width of 
+## row per element in @var{d}, padded with leading zeros to the width of
 ## the largest value.
 ##
 ## If @var{base} is a string then the characters of @var{base} are used as
 ## the symbols for the digits of @var{d}.  Space (' ') may not be used
 ## as a symbol.
 ##
 ## @example
 ## @group
@@ -61,17 +61,17 @@ function retval = dec2base (d, base, len
   if (iscell (d))
     d = cell2mat (d);
   endif
 
   ## Create column vector for algorithm
   if (! iscolumn (d))
     d = d(:);
   endif
-  
+
   ## Treat logical as numeric for compatibility with ML
   if (islogical (d))
     d = double (d);
   elseif (! isnumeric (d) || iscomplex (d) || any (d < 0 | d != fix (d)))
     error ("dec2base: input must be real non-negative integers");
   endif
 
   symbols = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
diff --git a/scripts/strings/dec2bin.m b/scripts/strings/dec2bin.m
--- a/scripts/strings/dec2bin.m
+++ b/scripts/strings/dec2bin.m
@@ -24,17 +24,17 @@
 ## @example
 ## @group
 ## dec2bin (14)
 ##      @result{} "1110"
 ## @end group
 ## @end example
 ##
 ## If @var{d} is a matrix or cell array, return a string matrix with one
-## row per element in @var{d}, padded with leading zeros to the width of 
+## row per element in @var{d}, padded with leading zeros to the width of
 ## the largest value.
 ##
 ## The optional second argument, @var{len}, specifies the minimum
 ## number of digits in the result.
 ## @seealso{bin2dec, dec2base, dec2hex}
 ## @end deftypefn
 
 ## Author: Daniel Calvelo <dcalvelo@yahoo.com>
diff --git a/scripts/strings/dec2hex.m b/scripts/strings/dec2hex.m
--- a/scripts/strings/dec2hex.m
+++ b/scripts/strings/dec2hex.m
@@ -24,17 +24,17 @@
 ## @example
 ## @group
 ## dec2hex (2748)
 ##      @result{} "ABC"
 ## @end group
 ## @end example
 ##
 ## If @var{d} is a matrix or cell array, return a string matrix with one
-## row per element in @var{d}, padded with leading zeros to the width of 
+## row per element in @var{d}, padded with leading zeros to the width of
 ## the largest value.
 ##
 ## The optional second argument, @var{len}, specifies the minimum
 ## number of digits in the result.
 ## @seealso{hex2dec, dec2base, dec2bin}
 ## @end deftypefn
 
 ## Author: Daniel Calvelo <dcalvelo@yahoo.com>
diff --git a/scripts/strings/mat2str.m b/scripts/strings/mat2str.m
--- a/scripts/strings/mat2str.m
+++ b/scripts/strings/mat2str.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{s} =} mat2str (@var{x}, @var{n})
 ## @deftypefnx {Function File} {@var{s} =} mat2str (@var{x}, @var{n}, "class")
-## Format real, complex, and logical matrices as strings.  The 
+## Format real, complex, and logical matrices as strings.  The
 ## returned string may be used to reconstruct the original matrix by using
 ## the @code{eval} function.
 ##
 ## The precision of the values is given by @var{n}.  If @var{n} is a
 ## scalar then both real and imaginary parts of the matrix are printed
 ## to the same precision.  Otherwise @code{@var{n}(1)} defines the
 ## precision of the real part and @code{@var{n}(2)} defines the
 ## precision of the imaginary part.  The default for @var{n} is 15.
diff --git a/scripts/strings/ostrsplit.m b/scripts/strings/ostrsplit.m
--- a/scripts/strings/ostrsplit.m
+++ b/scripts/strings/ostrsplit.m
@@ -64,17 +64,17 @@ function cstr = ostrsplit (s, sep, strip
   if (isempty (s))
     cstr = cell (size (s));
   else
     if (rows (s) > 1)
       ## For 2-D arrays, add separator character at line boundaries
       ## and transform to single string
       s(:, end+1) = sep(1);
       s = reshape (s.', 1, numel (s));
-      s(end) = []; 
+      s(end) = [];
     endif
 
     ## Split s according to delimiter
     if (isscalar (sep))
       ## Single separator
       idx = find (s == sep);
     else
       ## Multiple separators
diff --git a/scripts/strings/regexptranslate.m b/scripts/strings/regexptranslate.m
--- a/scripts/strings/regexptranslate.m
+++ b/scripts/strings/regexptranslate.m
@@ -58,18 +58,18 @@ function y = regexptranslate (op, s)
   endif
 
   if (! ischar (op))
     error ("regexptranslate: operation OP must be a string");
   endif
 
   op = tolower (op);
   if (strcmp ("wildcard", op))
-    y = regexprep (regexprep (regexprep (s, '\.', '\.'), 
-                                            '\*', '.*'), 
+    y = regexprep (regexprep (regexprep (s, '\.', '\.'),
+                                            '\*', '.*'),
                                             '\?', '.');
   elseif (strcmp ("escape", op))
     y = regexprep (s, '([^\w])', '\\$1');
   else
     error ("regexptranslate: invalid operation OP");
   endif
 
 endfunction
diff --git a/scripts/strings/str2num.m b/scripts/strings/str2num.m
--- a/scripts/strings/str2num.m
+++ b/scripts/strings/str2num.m
@@ -45,17 +45,17 @@
 ## For cell array of strings use @code{str2double}.
 ## @seealso{str2double, eval}
 ## @end deftypefn
 
 ## Author: jwe
 
 function [m, state] = str2num (s)
 
-  if (nargin != 1) 
+  if (nargin != 1)
     print_usage ();
   elseif (! ischar (s))
     error ("str2num: S must be a string or string array");
   endif
 
   s(:, end+1) = ";";
   s = sprintf ("m = [%s];", reshape (s', 1, numel (s)));
   state = true;
diff --git a/scripts/strings/strcat.m b/scripts/strings/strcat.m
--- a/scripts/strings/strcat.m
+++ b/scripts/strings/strcat.m
@@ -63,17 +63,17 @@
 ##
 ## @example
 ## @group
 ## s = @{ "ab"; "cd " @};
 ## strcat (s, s, s)
 ##     @result{}
 ##         @{
 ##           [1,1] = ababab
-##           [2,1] = cd cd cd 
+##           [2,1] = cd cd cd
 ##         @}
 ## @end group
 ## @end example
 ##
 ## @seealso{cstrcat, char, strvcat}
 ## @end deftypefn
 
 ## Author: jwe
diff --git a/scripts/strings/strjoin.m b/scripts/strings/strjoin.m
--- a/scripts/strings/strjoin.m
+++ b/scripts/strings/strjoin.m
@@ -60,18 +60,18 @@ function rval = strjoin (cstr, delimiter
     rval = cstr{1};
     return;
   endif
 
   if (ischar (delimiter))
     delimiter = do_string_escapes (delimiter);
     delimiter = {delimiter};
   endif
- 
-  num = numel (cstr); 
+
+  num = numel (cstr);
   if (numel (delimiter) == 1 && num > 1)
     delimiter = repmat (delimiter, 1, num);
     delimiter(end) = {""};
   elseif (num > 0 && numel (delimiter) != num - 1)
     error ("strjoin:cellstring_delimiter_mismatch",
       "strjoin: the number of delimiters does not match the number of strings")
   else
     delimiter(end+1) = {""};
diff --git a/scripts/strings/strsplit.m b/scripts/strings/strsplit.m
--- a/scripts/strings/strsplit.m
+++ b/scripts/strings/strsplit.m
@@ -57,76 +57,76 @@
 ##             [1,2] = b
 ##             [1,3] = c
 ##           @}
 ##
 ## strsplit ("a,,b, c", @{",", " "@}, false)
 ##       @result{}
 ##           @{
 ##             [1,1] = a
-##             [1,2] = 
+##             [1,2] =
 ##             [1,3] = b
-##             [1,4] = 
+##             [1,4] =
 ##             [1,5] = c
 ##           @}
 ##
 ## @end example
 ##
 ## Supported @var{name}/@var{value} pair arguments are;
 ##
 ## @itemize
 ## @item @var{collapsedelimiters} may take the value of @var{true} or
 ## @var{false} with the default being @var{false}.
 ##
 ## @item @var{delimitertype} may take the value of @code{simple} or
 ## @code{regularexpression}.  The default is @var{delimitertype} is
 ## @code{simple}.
 ## @end itemize
-## 
+##
 ## Example:
 ##
 ## @example
 ## strsplit ("a foo b,bar c", ",|\\s|foo|bar", "delimitertype", "regularexpression")
 ##       @result{}
 ##           @{
 ##             [1,1] = a
 ##             [1,2] = b
 ##             [1,3] = c
 ##           @}
-## 
+##
 ## strsplit ("a,,b, c", "[, ]", false, "delimitertype", "regularexpression")
 ##       @result{}
 ##           @{
 ##             [1,1] = a
-##             [1,2] = 
+##             [1,2] =
 ##             [1,3] = b
-##             [1,4] = 
+##             [1,4] =
 ##             [1,5] = c
 ##           @}
-## 
+##
 ## strsplit ("a,\t,b, c", @{',', '\s'@}, "delimitertype", "regularexpression")
 ##       @result{}
 ##           @{
 ##             [1,1] = a
 ##             [1,2] = b
 ##             [1,3] = c
 ##           @}
-## 
+##
 ## strsplit ("a,\t,b, c", @{',', ' ', '\t'@}, "collapsedelimiters", false)
 ##       @result{}
 ##           @{
 ##             [1,1] = a
-##             [1,2] = 
-##             [1,3] = 
+##             [1,2] =
+##             [1,3] =
 ##             [1,4] = b
-##             [1,5] = 
+##             [1,5] =
 ##             [1,6] = c
 ##           @}
 ## @end example
-## 
+##
 ## @seealso{ostrsplit, strjoin, strtok, regexp}
 ## @end deftypefn
 
 function [result, matches] = strsplit (str, del, varargin)
 
   args.collapsedelimiters = true;
   args.delimitertype = "default";
 
diff --git a/scripts/strings/strtok.m b/scripts/strings/strtok.m
--- a/scripts/strings/strtok.m
+++ b/scripts/strings/strtok.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{tok}, @var{rem}] =} strtok (@var{str})
 ## @deftypefnx {Function File} {[@var{tok}, @var{rem}] =} strtok (@var{str}, @var{delim})
 ##
-## Find all characters in the string @var{str} up to, but not including, the 
+## Find all characters in the string @var{str} up to, but not including, the
 ## first character which is in the string @var{delim}.  If @var{rem} is
 ## requested, it contains the remainder of the string, starting at the first
 ## delimiter.  Leading delimiters are ignored.  If @var{delim} is not
 ## specified, whitespace is assumed.  @var{str} may also be a cell array of
 ## strings in which case the function executes on every individual string
 ## and returns a cell array of tokens and remainders.
 ##
 ## Examples:
@@ -63,17 +63,17 @@ function [tok, rem] = strtok (str, delim
   if (isempty (str))
     tok = rem = "";
   elseif (ischar (str))
     if (ws_delim)
       idx = isspace (str);
     elseif (length (delim) <= 7)
       ## Build index of delimiters incrementally for low N.
       idx = str == delim(1);
-      for i = 2:length (delim) 
+      for i = 2:length (delim)
         idx |= str == delim(i);
       endfor
     else
       ## Index the str into a mask of valid values.  Faster for large N.
       f = false (256, 1);
       ## This is slower than it could be because of the +1 issue.
       f(uint8 (delim)+1) = true;
       ## Default goes via double -- unnecessarily long.
@@ -85,22 +85,22 @@ function [tok, rem] = strtok (str, delim
 
     idx_dlim = find (idx, 1);
     idx_nodlim = find (! idx, 1);
     if (isempty (idx_dlim))
       ## No delimiter.  Return whole string.
       tok = str;
       rem = "";
     elseif (idx_dlim > idx_nodlim)
-      ## Normal case.  No leading delimiters and at least 1 delimiter in STR. 
+      ## Normal case.  No leading delimiters and at least 1 delimiter in STR.
       tok = str(1:idx_dlim-1);
       rem = str(idx_dlim:end);
     else
       ## Leading delimiter found.
-      idx_dlim = find (idx(idx_nodlim+1:end), 1); 
+      idx_dlim = find (idx(idx_nodlim+1:end), 1);
       if (isempty (idx_dlim))
         ## No further delimiters.  Return STR stripped of delimiter prefix.
         tok = str(idx_nodlim:end);
         rem = "";
       else
         ## Strip delimiter prefix.  Return STR up to 1st delimiter
         tok = str(idx_nodlim:(idx_dlim + idx_nodlim -1));
         rem = str((idx_dlim + idx_nodlim):end);
diff --git a/scripts/strings/strtrim.m b/scripts/strings/strtrim.m
--- a/scripts/strings/strtrim.m
+++ b/scripts/strings/strtrim.m
@@ -53,17 +53,17 @@ function s = strtrim (s)
     else
       s = s(:, ceil (min (k) / rows (s)):ceil (max (k) / rows (s)));
     endif
 
   elseif (iscell (s))
 
     char_idx = cellfun ("isclass", s, "char");
     cell_idx = cellfun ("isclass", s, "cell");
-    if (! all (char_idx | cell_idx))  
+    if (! all (char_idx | cell_idx))
       error ("strtrim: S argument must be a string or cellstring");
     endif
 
     ## Divide work load.  Recursive cellfun strtrim call is slow
     ## and avoided where possible.
     s(char_idx) = regexprep (s(char_idx), "^[\\s\v]+|[\\s\v]+$", '');
     s(cell_idx) = cellfun ("strtrim", s(cell_idx), "UniformOutput", false);
 
diff --git a/scripts/strings/strtrunc.m b/scripts/strings/strtrunc.m
--- a/scripts/strings/strtrunc.m
+++ b/scripts/strings/strtrunc.m
@@ -59,18 +59,18 @@ endfunction
 %!assert (strtrunc ("abcdefg", 10), "abcdefg")
 %!assert (strtrunc (char ("abcdef", "fedcba"), 3), ["abc"; "fed"])
 %!assert (strtrunc ({"abcdef", "fedcba"}, 3), {"abc", "fed"})
 %!assert (strtrunc ({"", "1", "21", "321"}, 1), {"", "1", "2", "3"})
 %!assert (strtrunc ({"1", "", "2"}, 1), {"1", "", "2"})
 %!test
 %! cstr = {"line1"; ["line2"; "line3"]; "line4"};
 %! y = strtrunc (cstr, 4);
-%! assert (size (y), [3, 1]); 
-%! assert (size (y{2}), [2, 4]); 
+%! assert (size (y), [3, 1]);
+%! assert (size (y{2}), [2, 4]);
 %! assert (y{2}, repmat ("line", 2, 1));
 
 %% Test input validation
 %!error strtrunc ()
 %!error strtrunc ("abcd")
 %!error strtrunc ("abcd", 4, 5)
 %!error <N must be a positive integer> strtrunc ("abcd", ones (2,2))
 %!error <N must be a positive integer> strtrunc ("abcd", -1)
diff --git a/scripts/strings/substr.m b/scripts/strings/substr.m
--- a/scripts/strings/substr.m
+++ b/scripts/strings/substr.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} substr (@var{s}, @var{offset})
 ## @deftypefnx {Function File} {} substr (@var{s}, @var{offset}, @var{len})
 ## Return the substring of @var{s} which starts at character number
 ## @var{offset} and is @var{len} characters long.
 ##
 ## Position numbering for offsets begins with 1.  If @var{offset} is negative,
 ## extraction starts that far from the end of the string.
-## 
+##
 ## If @var{len} is omitted, the substring extends to the end of @var{S}.  A
 ## negative value for @var{len} extracts to within @var{len} characters of
 ## the end of the string
 ##
 ## Examples:
 ##
 ## @example
 ## @group
diff --git a/scripts/testfun/__run_test_suite__.m b/scripts/testfun/__run_test_suite__.m
--- a/scripts/testfun/__run_test_suite__.m
+++ b/scripts/testfun/__run_test_suite__.m
@@ -251,17 +251,17 @@ function [dp, dn, dxf, dsk] = run_test_s
         dsk += sk;
         files_with_tests(end+1) = f;
       else
         ## To reduce the list length, only mark .cc files that contain
         ## DEFUN definitions.
         files_with_no_tests(end+1) = f;
       endif
     endif
-  endfor 
+  endfor
   ##  printf("%s%s -> passes %d of %d tests\n", ident, d, dp, dn);
 endfunction
 
 function n = num_elts_matching_pattern (lst, pat)
   n = sum (! cellfun ("isempty", regexp (lst, pat, 'once')));
 endfunction
 
 function report_files_with_no_tests (with, without, typ)
diff --git a/scripts/testfun/speed.m b/scripts/testfun/speed.m
--- a/scripts/testfun/speed.m
+++ b/scripts/testfun/speed.m
@@ -137,17 +137,17 @@
 ##
 ## Assuming one of the two versions is in xcorr_orig, this
 ## would compare their speed and their output values.  Note that the
 ## FFT version is not exact, so one must specify an acceptable tolerance on
 ## the comparison @code{100*eps}.  In this case, the comparison should be
 ## computed relatively, as @code{abs ((@var{x} - @var{y}) ./ @var{y})} rather
 ## than absolutely as @code{abs (@var{x} - @var{y})}.
 ##
-## Type @kbd{example ("speed")} to see some real examples or 
+## Type @kbd{example ("speed")} to see some real examples or
 ## @kbd{demo ("speed")} to run them.
 ## @end deftypefn
 
 ## FIXME: consider two dimensional speedup surfaces for functions like kron.
 function [__order, __test_n, __tnew, __torig] = speed (__f1, __init, __max_n = 100, __f2 = "", __tol = eps)
 
   if (nargin < 1 || nargin > 6)
     print_usage ();
@@ -263,20 +263,20 @@ function [__order, __test_n, __tnew, __t
   if (nargout > 0)
     __order.p = p(1);
     __order.a = exp (p(2));
   endif
 
   if (do_display)
     figure;
     ## Strip semicolon added to code fragments before displaying
-    __init(end) = ""; 
-    __f1(end) = ""; 
+    __init(end) = "";
+    __f1(end) = "";
     if (! isempty (__f2))
-      __f2(end) = ""; 
+      __f2(end) = "";
     endif
   endif
 
   if (do_display && isempty (__f2))
 
     loglog (__test_n, __tnew*1000, "*-g;execution time;");
     xlabel ("test length");
     ylabel ("best execution time (ms)");
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -471,17 +471,17 @@ function [__ret1, __ret2, __ret3, __ret4
       ## Code already processed.
       __code = "";
 
 ### TESTIF
 
     elseif (strcmp (__type, "testif"))
       __e = regexp (__code, '.$', 'lineanchors', 'once');
       ## Strip comment any comment from testif line before looking for features
-      __feat_line = strtok (__code(1:__e), '#%'); 
+      __feat_line = strtok (__code(1:__e), '#%');
       __feat = regexp (__feat_line, '\w+', 'match');
       __feat = strrep (__feat, "HAVE_", "");
       __have_feat = __have_feature__ (__feat);
       if (__have_feat)
         __istest = 1;
         __code = __code(__e + 1 : end);
       else
         __xskip++;
diff --git a/scripts/time/asctime.m b/scripts/time/asctime.m
--- a/scripts/time/asctime.m
+++ b/scripts/time/asctime.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} asctime (@var{tm_struct})
-## Convert a time structure to a string using the following 
+## Convert a time structure to a string using the following
 ## format: @qcode{"ddd mmm mm HH:MM:SS yyyy"}.  For example:
 ##
 ## @example
 ## @group
 ## asctime (localtime (time ()))
 ##      @result{} "Mon Feb 17 01:15:06 1997"
 ## @end group
 ## @end example
diff --git a/scripts/time/datenum.m b/scripts/time/datenum.m
--- a/scripts/time/datenum.m
+++ b/scripts/time/datenum.m
@@ -30,17 +30,17 @@
 ## defined as day 1.
 ##
 ## The integer part, @code{floor (@var{days})} counts the number of
 ## complete days in the date input.
 ##
 ## The fractional part, @code{rem (@var{days}, 1)} corresponds to the time
 ## on the given day.
 ##
-## The input may be a date vector (see @code{datevec}), 
+## The input may be a date vector (see @code{datevec}),
 ## datestr (see @code{datestr}), or directly specified as input.
 ##
 ## When processing input datestrings, @var{f} is the format string used to
 ## interpret date strings (see @code{datestr}).  If no format @var{f} is
 ## specified, then a relatively slow search is performed through various
 ## formats.  It is always preferable to specify the format string @var{f} if
 ## it is known.  Formats which do not specify a particular time component
 ## will have the value set to zero.  Formats which do not specify a date
@@ -91,17 +91,17 @@
 ## Author: pkienzle <pkienzle@users.sf.net>
 
 function [days, secs] = datenum (year, month = [], day = [], hour = 0, minute = 0, second = 0)
 
   ## Days until start of month assuming year starts March 1.
   persistent monthstart = [306; 337; 0; 31; 61; 92; 122; 153; 184; 214; 245; 275];
   persistent monthlength = [31; 28; 31; 30; 31; 30; 31; 31; 30; 31; 30; 31];
 
-  if (nargin == 0 || nargin > 6 || 
+  if (nargin == 0 || nargin > 6 ||
      (nargin > 2 && (ischar (year) || iscellstr (year))))
     print_usage ();
   endif
 
   if (ischar (year) || iscellstr (year))
     [year, month, day, hour, minute, second] = datevec (year, month);
   else
     if (nargin == 1)
@@ -124,17 +124,17 @@ function [days, secs] = datenum (year, m
   endif
 
   month(month<1) = 1;  # For compatibility.  Otherwise allow negative months.
 
   ## Treat fractional months, by converting the fraction to days
   if (floor (month) != month)
     fracmonth = month - floor (month);
     month = floor (month);
-    if ((mod (month-1,12) + 1) == 2 && 
+    if ((mod (month-1,12) + 1) == 2 &&
         (floor (year/4) - floor (year/100) + floor (year/400)) != 0)
       ## leap year
       day += fracmonth * 29;
     else
       day += fracmonth * monthlength ((mod (month-1,12) + 1));
     endif
   endif
 
diff --git a/scripts/time/datevec.m b/scripts/time/datevec.m
--- a/scripts/time/datevec.m
+++ b/scripts/time/datevec.m
@@ -230,30 +230,30 @@ function [f, rY, ry, fy, fm, fd, fh, fmi
   fmi = index (f, "%M");
   fs = index (f, "%S");
 
 endfunction
 
 function [found, y, m, d, h, mi, s] = __date_str2vec__ (ds, p, f, rY, ry, fy, fm, fd, fh, fmi, fs)
 
   idx = strfind (f, "FFF");
-  if (! isempty (idx)) 
+  if (! isempty (idx))
     ## Kludge to handle FFF millisecond format since strptime does not
-    f(idx:idx+2) = []; 
+    f(idx:idx+2) = [];
     [~, nc] = strptime (ds, f);
     if (nc > 0)
-      msec = ds(nc:min(nc+2, end)); 
-      f = [f(1:idx-1) msec f(idx:end)]; 
+      msec = ds(nc:min(nc+2, end));
+      f = [f(1:idx-1) msec f(idx:end)];
       [tm, nc] = strptime (ds, f);
       tm.usec = 1000 * str2double (msec);
     endif
   else
     [tm, nc] = strptime (ds, f);
   endif
-  
+
   if (nc == columns (ds) + 1)
     found = true;
     y = tm.year + 1900; m = tm.mon + 1; d = tm.mday;
     h = tm.hour; mi = tm.min; s = tm.sec + tm.usec / 1e6;
     if (rY < ry)
       if (y > 1999)
         y -= 2000;
       else
diff --git a/scripts/time/weekday.m b/scripts/time/weekday.m
--- a/scripts/time/weekday.m
+++ b/scripts/time/weekday.m
@@ -35,17 +35,17 @@
 ## @item 1 @tab Sun @tab Sunday
 ## @item 2 @tab Mon @tab Monday
 ## @item 3 @tab Tue @tab Tuesday
 ## @item 4 @tab Wed @tab Wednesday
 ## @item 5 @tab Thu @tab Thursday
 ## @item 6 @tab Fri @tab Friday
 ## @item 7 @tab Sat @tab Saturday
 ## @end multitable
-## 
+##
 ## @seealso{eomday, is_leap_year, calendar, datenum, datevec}
 ## @end deftypefn
 
 ## Author: pkienzle <pkienzle@users.sf.net>
 ## Created: 10 October 2001 (CVS)
 ## Adapted-By: William Poetra Yoga Hadisoeseno <williampoetra@gmail.com>
 
 function [d, s] = weekday (d, format = "short")
diff --git a/src/Makefile.am b/src/Makefile.am
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -131,17 +131,17 @@ all-local: $(OCTAVE_VERSION_LINKS)
 
 octave-config.cc: octave-config.in.cc Makefile
 	@$(do_subst_default_vals)
 
 mkoctfile.cc: mkoctfile.in.cc Makefile
 	@$(do_subst_config_vals)
 
 ## main.cc must depend on Makefile.  Calling configure may change
-## default/config values.  However, calling configure will also 
+## default/config values.  However, calling configure will also
 ## regenerate the Makefiles from Makefile.am and trigger the rules below.
 main.cc: main.in.cc Makefile
 	@$(do_subst_default_vals)
 
 install-exec-hook: make-version-links
 
 uninstall-local: remove-version-links
 
diff --git a/test/Makefile.am b/test/Makefile.am
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -1,24 +1,24 @@
 # Makefile for Octave's test directory
 #
 # Copyright (C) 1994-2013 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
 FCN_FILES = \
   fntests.m \
diff --git a/test/build-bc-overload-tests.sh b/test/build-bc-overload-tests.sh
--- a/test/build-bc-overload-tests.sh
+++ b/test/build-bc-overload-tests.sh
@@ -1,24 +1,24 @@
 #! /bin/sh
 
 # Copyright (C) 2010-2013 VZLU Prague
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 CLASSES="
   double
   single
   char
diff --git a/test/build-sparse-tests.sh b/test/build-sparse-tests.sh
--- a/test/build-sparse-tests.sh
+++ b/test/build-sparse-tests.sh
@@ -1,24 +1,24 @@
 #!/bin/sh
 
 # Copyright (C) 2006-2013 David Bateman
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 # Some tests are commented out because they are known to be broken!
 # Search for "# fails"
 
 # ./build_sparse_tests.sh preset
diff --git a/test/jit.tst b/test/jit.tst
--- a/test/jit.tst
+++ b/test/jit.tst
@@ -1,22 +1,22 @@
 ## Copyright (C) 2012-2013 Max Brister
-## 
+##
 ## This file is part of Octave.
-## 
+##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 3 of the License, or (at your
 ## option) any later version.
-## 
+##
 ## Octave is distributed in the hope that it will be useful, but WITHOUT
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## Author: Max Brister <max@2bass.com>
 
 ## Turn on JIT and set defaults before running tests
 %!testif HAVE_LLVM
diff --git a/test/line-continue.tst b/test/line-continue.tst
--- a/test/line-continue.tst
+++ b/test/line-continue.tst
@@ -23,17 +23,17 @@
 
 %!test
 %! y = [a... # comments here ok
 %! b];
 %! assert (y, x);
 
 ## FIXME: Next 3 tests use '\' continuation outside of a double-quoted string
 ##        This behavior is deprecated and will be removed at some point.
-##        When it does these 
+##        When it does these
 %!test
 %! x = [1;2];
 %! y = [a... # comments here ok
 %! ;\
 %!
 %! b];
 %! assert (y, x);
 
