# HG changeset patch
# User Jaroslav Hajek <highegg@gmail.com>
# Date 1267181078 -3600
#      Fri Feb 26 11:44:38 2010 +0100
# Node ID a0728e81ed25e5ad1878d11137b0ae4bd52926ce
# Parent  b47ab50a6aa852d994f19ce1df03c74fc683bf09
improve diag matrix interface & implementation

diff --git a/liboctave/CColVector.cc b/liboctave/CColVector.cc
--- a/liboctave/CColVector.cc
+++ b/liboctave/CColVector.cc
@@ -226,24 +226,26 @@ ComplexColumnVector::hermitian (void) co
 }
 
 ComplexRowVector
 ComplexColumnVector::transpose (void) const
 {
   return MArray<Complex>::transpose ();
 }
 
+ColumnVector
+ComplexColumnVector::abs (void) const
+{
+  return do_mx_unary_map<double, Complex, std::abs> (*this);
+}
+
 ComplexColumnVector
 conj (const ComplexColumnVector& a)
 {
-  octave_idx_type a_len = a.length ();
-  ComplexColumnVector retval;
-  if (a_len > 0)
-    retval = ComplexColumnVector (mx_inline_conj_dup (a.data (), a_len), a_len);
-  return retval;
+  return do_mx_unary_map<Complex, Complex, std::conj> (a);
 }
 
 // resize is the destructive equivalent for this one
 
 ComplexColumnVector
 ComplexColumnVector::extract (octave_idx_type r1, octave_idx_type r2) const
 {
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
diff --git a/liboctave/CColVector.h b/liboctave/CColVector.h
--- a/liboctave/CColVector.h
+++ b/liboctave/CColVector.h
@@ -116,16 +116,18 @@ public:
   friend OCTAVE_API ComplexColumnVector operator * (const ComplexDiagMatrix& a,
                                          const ComplexColumnVector& b);
 
   // other operations
 
   Complex min (void) const;
   Complex max (void) const;
 
+  ColumnVector abs (void) const;
+
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const ComplexColumnVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, ComplexColumnVector& a);
 
   void resize (octave_idx_type n, const Complex& rfv = Array<Complex>::resize_fill_value ())
     { Array<Complex>::resize (n, 1, rfv); }
 
diff --git a/liboctave/CDiagMatrix.cc b/liboctave/CDiagMatrix.cc
--- a/liboctave/CDiagMatrix.cc
+++ b/liboctave/CDiagMatrix.cc
@@ -232,31 +232,23 @@ ComplexDiagMatrix::fill (const ComplexRo
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 DiagMatrix
 ComplexDiagMatrix::abs (void) const
 {
-  DiagMatrix retval (rows (), cols ());
-  for (octave_idx_type i = 0; i < rows (); i++)
-    retval(i, i) = std::abs (elem (i, i));
-  return retval;
+  return DiagMatrix (diag ().abs (), rows (), columns ());
 }
 
 ComplexDiagMatrix
 conj (const ComplexDiagMatrix& a)
 {
-  ComplexDiagMatrix retval;
-  octave_idx_type a_len = a.length ();
-  if (a_len > 0)
-    retval = ComplexDiagMatrix (mx_inline_conj_dup (a.data (), a_len),
-                                a.rows (), a.cols ());
-  return retval;
+  return ComplexDiagMatrix (conj (a.diag ()), a.rows (), a.columns ());
 }
 
 // resize is the destructive analog for this one
 
 ComplexMatrix
 ComplexDiagMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
 {
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
diff --git a/liboctave/CDiagMatrix.h b/liboctave/CDiagMatrix.h
--- a/liboctave/CDiagMatrix.h
+++ b/liboctave/CDiagMatrix.h
@@ -42,27 +42,24 @@ public:
 
   ComplexDiagMatrix (void) : MDiagArray2<Complex> () { }
 
   ComplexDiagMatrix (octave_idx_type r, octave_idx_type c) : MDiagArray2<Complex> (r, c) { }
 
   ComplexDiagMatrix (octave_idx_type r, octave_idx_type c, const Complex& val)
     : MDiagArray2<Complex> (r, c, val) { }
 
-  explicit ComplexDiagMatrix (const RowVector& a)
-    : MDiagArray2<Complex> (ComplexRowVector (a)) { }
-
-  explicit ComplexDiagMatrix (const ComplexRowVector& a)
+  explicit ComplexDiagMatrix (const Array<Complex>& a)
     : MDiagArray2<Complex> (a) { }
 
-  explicit ComplexDiagMatrix (const ColumnVector& a)
-    : MDiagArray2<Complex> (ComplexColumnVector (a)) { }
+  explicit ComplexDiagMatrix (const Array<double>& a)
+    : MDiagArray2<Complex> (Array<Complex> (a)) { }
 
-  explicit ComplexDiagMatrix (const ComplexColumnVector& a)
-    : MDiagArray2<Complex> (a) { }
+  ComplexDiagMatrix (const Array<Complex>& a, octave_idx_type r, octave_idx_type c) 
+    : MDiagArray2<Complex> (a, r, c) { }
 
   explicit ComplexDiagMatrix (const DiagMatrix& a);
 
   ComplexDiagMatrix (const MDiagArray2<Complex>& a)
     : MDiagArray2<Complex> (a) { }
 
   ComplexDiagMatrix (const ComplexDiagMatrix& a)
     : MDiagArray2<Complex> (a) { }
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -887,18 +887,17 @@ ComplexMatrix::stack (const ComplexDiagM
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 conj (const ComplexMatrix& a)
 {
-  return ComplexMatrix (mx_inline_conj_dup (a.data (), a.length ()),
-                        a.rows (), a.cols ());
+  return do_mx_unary_map<Complex, Complex, std::conj> (a);
 }
 
 // resize is the destructive equivalent for this one
 
 ComplexMatrix
 ComplexMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
 {
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
@@ -3238,18 +3237,17 @@ ComplexMatrix::sum (int dim) const
 ComplexMatrix
 ComplexMatrix::sumsq (int dim) const
 {
   return do_mx_red_op<double, Complex> (*this, dim, mx_inline_sumsq);
 }
 
 Matrix ComplexMatrix::abs (void) const
 {
-  return Matrix (mx_inline_cabs_dup (data (), length ()),
-                 rows (), cols ());
+  return do_mx_unary_map<double, Complex, std::abs> (*this);
 }
 
 ComplexMatrix
 ComplexMatrix::diag (octave_idx_type k) const
 {
   return MArray<Complex>::diag (k);
 }
 
diff --git a/liboctave/CRowVector.cc b/liboctave/CRowVector.cc
--- a/liboctave/CRowVector.cc
+++ b/liboctave/CRowVector.cc
@@ -227,21 +227,17 @@ ComplexColumnVector
 ComplexRowVector::transpose (void) const
 {
   return MArray<Complex>::transpose ();
 }
 
 ComplexRowVector
 conj (const ComplexRowVector& a)
 {
-  octave_idx_type a_len = a.length ();
-  ComplexRowVector retval;
-  if (a_len > 0)
-    retval = ComplexRowVector (mx_inline_conj_dup (a.data (), a_len), a_len);
-  return retval;
+  return do_mx_unary_map<Complex, Complex, std::conj> (a);
 }
 
 // resize is the destructive equivalent for this one
 
 ComplexRowVector
 ComplexRowVector::extract (octave_idx_type c1, octave_idx_type c2) const
 {
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,48 @@
+2010-02-26  Jaroslav Hajek  <highegg@gmail.com>
+
+	* DiagArray2.h (DiagArray2): Clean up ctors. Remove Proxy class.
+	Remove non-const two-index elem methods.
+	* DiagArray2.cc: Update.
+	* MDiagArray2.h: Update.
+
+	* dDiagArray2.h: Update.
+	* dDiagArray2.cc: Update.
+	* fDiagArray2.h: Update.
+	* fDiagArray2.cc: Update.
+	* CDiagArray2.h: Update.
+	* CDiagArray2.cc: Update.
+	* fCDiagArray2.h: Update.
+	* fCDiagArray2.cc: Update.
+
+	* dMatrix.cc: Update.
+	* fMatrix.cc: Update.
+	* CMatrix.cc: Update.
+	* fCMatrix.cc: Update.
+
+	* dRowVector.cc: Update.
+	* fRowVector.cc: Update.
+	* CRowVector.cc: Update.
+	* fCRowVector.cc: Update.
+
+	* dColVector.cc: Update.
+	* fColVector.cc: Update.
+	* CColVector.cc: Update.
+	* fCColVector.cc: Update.
+
+	* dColVector.cc (ColumnVector::abs): New method.
+	* dColVector.h: Declare it.
+	* fColVector.cc (FloatColumnVector::abs): New method.
+	* fColVector.h: Declare it.
+	* CColVector.cc (ComplexColumnVector::abs): New method.
+	* CColVector.h: Declare it.
+	* fCColVector.cc (FloatComplexColumnVector::abs): New method.
+	* fCColVector.h: Declare it.
+
 2010-02-26  Jaroslav Hajek  <highegg@gmail.com>
 
 	* mx-inlines.cc: Parameterize all appliers by value types rather than
 	Array types. Return & accept Array instances.
 	* mx-op-defs.h: Update references.
 	* CMatrix.cc: Ditto.
 	* CNDArray.cc: Ditto.
 	* DiagArray2.h: Ditto.
diff --git a/liboctave/DiagArray2.cc b/liboctave/DiagArray2.cc
--- a/liboctave/DiagArray2.cc
+++ b/liboctave/DiagArray2.cc
@@ -32,41 +32,22 @@ along with Octave; see the file COPYING.
 
 #include <algorithm>
 
 #include "DiagArray2.h"
 
 #include "lo-error.h"
 
 template <class T>
-const typename DiagArray2<T>::Proxy& 
-DiagArray2<T>::Proxy::operator = (const T& val) const
+DiagArray2<T>::DiagArray2 (const Array<T>& a, octave_idx_type r, octave_idx_type c)
+  : Array<T> (a.as_column ()), d1 (r), d2 (c)
 {
-  if (i == j)
-    {
-      if (object)
-        object->set (val, i);
-    }
-  else
-    (*current_liboctave_error_handler)
-      ("invalid assignment to off-diagonal in diagonal array");
-
-  return *this;
-}
-
-template <class T>
-DiagArray2<T>::Proxy::operator T () const
-{
-  if (object && i == j)
-    return object->get (i);
-  else
-    {
-      static T foo;
-      return foo;
-    }
+  octave_idx_type rcmin = std::min (r, c);
+  if (rcmin != a.length ())
+      Array<T>::resize (rcmin, 1);
 }
 
 template <class T>
 Array<T>
 DiagArray2<T>::diag (octave_idx_type k) const
 {
   Array<T> d;
 
@@ -83,59 +64,36 @@ DiagArray2<T>::diag (octave_idx_type k) 
 
   return d;
 }
 
 template <class T>
 DiagArray2<T>
 DiagArray2<T>::transpose (void) const
 {
-  DiagArray2<T> retval (*this);
-  retval.d1 = d2;
-  retval.d2 = d1;
-  return retval;
+  return DiagArray2<T> (*this, d2, d1);
 }
 
 template <class T>
 DiagArray2<T>
 DiagArray2<T>::hermitian (T (* fcn) (const T&)) const
 {
-  DiagArray2<T> retval (dim2 (), dim1 ());
-  const T *p = this->data ();
-  T *q = retval.fortran_vec ();
-  for (octave_idx_type i = 0; i < this->length (); i++)
-    q [i] = fcn (p [i]);
-  return retval;
+  return DiagArray2<T> (Array<T>::template map<T> (fcn), d2, d1);
 }
 
 // A two-dimensional array with diagonal elements only.
 
 template <class T>
 T
 DiagArray2<T>::checkelem (octave_idx_type r, octave_idx_type c) const
 {
   if (r < 0 || c < 0 || r >= dim1 () || c >= dim2 ())
-    {
-      (*current_liboctave_error_handler) ("range error in DiagArray2");
-      return T ();
-    }
-  return elem (r, c);
-}
+    (*current_liboctave_error_handler) ("range error in DiagArray2");
 
-template <class T>
-typename DiagArray2<T>::Proxy
-DiagArray2<T>::checkelem (octave_idx_type r, octave_idx_type c) 
-{
-  if (r < 0 || c < 0 || r >= dim1 () || c >= dim2 ())
-    {
-      (*current_liboctave_error_handler) ("range error in DiagArray2");
-      return Proxy (0, r, c);
-    }
-  else
-    return Proxy (this, r, c);
+  return elem (r, c);
 }
 
 template <class T>
 void
 DiagArray2<T>::resize (octave_idx_type r, octave_idx_type c,
                        const T& rfv)
 {
   if (r < 0 || c < 0)
@@ -147,16 +105,16 @@ DiagArray2<T>::resize (octave_idx_type r
   if (r != dim1 () || c != dim2 ())
     {
       Array<T>::resize (std::min (r, c), 1, rfv);
       d1 = r; d2 = c;
     }
 }
 
 template <class T>
-DiagArray2<T>::operator Array<T> (void) const
+Array<T> DiagArray2<T>::array_value (void) const
 {
   Array<T> result (dim1 (), dim2 ());
   for (octave_idx_type i = 0, len = length (); i < len; i++)
     result.xelem (i, i) = dgelem (i);
 
   return result;
 }
diff --git a/liboctave/DiagArray2.h b/liboctave/DiagArray2.h
--- a/liboctave/DiagArray2.h
+++ b/liboctave/DiagArray2.h
@@ -25,71 +25,24 @@ along with Octave; see the file COPYING.
 
 #if !defined (octave_DiagArray2_h)
 #define octave_DiagArray2_h 1
 
 #include <cassert>
 #include <cstdlib>
 
 #include "Array.h"
-#include "lo-error.h"
-
-// A two-dimensional array with diagonal elements only.
-// Idea and example code for Proxy class and functions from:
-//
-// From: kanze@us-es.sel.de (James Kanze)
-// Subject: Re: How to overload [] to do READ/WRITE differently ?
-// Message-ID: <KANZE.93Nov29151407@slsvhdt.us-es.sel.de>
-// Sender: news@us-es.sel.de
-// Date: 29 Nov 1993 14:14:07 GMT
-// --
-// James Kanze                             email: kanze@us-es.sel.de
-// GABI Software, Sarl., 8 rue du Faisan, F-67000 Strasbourg, France
 
 // Array<T> is inherited privately so that some methods, like index, don't
 // produce unexpected results.
 
 template <class T>
 class
 DiagArray2 : protected Array<T>
 {
-private:
-
-  T get (octave_idx_type i) { return Array<T>::xelem (i); }
-
-  void set (const T& val, octave_idx_type i) { Array<T>::xelem (i) = val; }
-
-  class Proxy
-  {
-  public:
-
-    Proxy (DiagArray2<T> *ref, octave_idx_type r, octave_idx_type c)
-      : i (r), j (c), object (ref) { } 
-
-    const Proxy& operator = (const T& val) const;
-
-    operator T () const;
-
-  private:
-
-    // FIXME -- this is declared private to keep the user from
-    // taking the address of a Proxy.  Maybe it should be implemented
-    // by means of a companion function in the DiagArray2 class.
-
-    T *operator& () const { assert (0); return 0; }
-
-    octave_idx_type i;
-    octave_idx_type j;
-
-    DiagArray2<T> *object;
-
-  };
-
-  friend class Proxy;
-
 protected:
   octave_idx_type d1, d2;
 
   DiagArray2 (T *d, octave_idx_type r, octave_idx_type c) 
     : Array<T> (d, std::min (r, c), 1), d1 (r), d2 (c) { }
 
 public:
 
@@ -99,28 +52,20 @@ public:
     : Array<T> (), d1 (0), d2 (0) { }
 
   DiagArray2 (octave_idx_type r, octave_idx_type c) 
     : Array<T> (std::min (r, c), 1), d1 (r), d2 (c) { }
 
   DiagArray2 (octave_idx_type r, octave_idx_type c, const T& val) 
     : Array<T> (std::min (r, c), 1, val), d1 (r), d2 (c) { }
 
-  DiagArray2 (const dim_vector& dv)
-    : Array<T> (std::min (dv(0), dv(1)), 1), d1 (dv(0)), d2 (dv(0))
-    {
-      if (dv.length () != 2)
-        (*current_liboctave_error_handler) ("too many dimensions");
-    }
-
-  DiagArray2 (const Array<T>& a) 
+  explicit DiagArray2 (const Array<T>& a) 
     : Array<T> (a.as_column ()), d1 (a.numel ()), d2 (a.numel ()) { }
 
-  DiagArray2 (const Array<T>& a, octave_idx_type r, octave_idx_type c) 
-    : Array<T> (a.as_column ()), d1 (r), d2 (c) { }
+  DiagArray2 (const Array<T>& a, octave_idx_type r, octave_idx_type c);
 
   DiagArray2 (const DiagArray2<T>& a) 
     : Array<T> (a), d1 (a.d1), d2 (a.d2) { }
 
   template <class U>
   DiagArray2 (const DiagArray2<U>& a) 
   : Array<T> (a.diag ()), d1 (a.dim1 ()), d2 (a.dim2 ()) { }
 
@@ -173,40 +118,26 @@ public:
 
   T dgelem (octave_idx_type i) const
     { return Array<T>::elem (i); }
 
   T& dgelem (octave_idx_type i) 
     { return Array<T>::elem (i); }
 
   T checkelem (octave_idx_type r, octave_idx_type c) const;
-  Proxy checkelem (octave_idx_type r, octave_idx_type c);
 
   T operator () (octave_idx_type r, octave_idx_type c) const
     {
 #if defined (BOUNDS_CHECKING)
       return checkelem (r, c);
 #else
       return elem (r, c);
 #endif
     }
 
-  // FIXME: can this cause problems?
-#if defined (BOUNDS_CHECKING)
-  Proxy operator () (octave_idx_type r, octave_idx_type c)
-    {
-      return checkelem (r, c);
-    }
-#else
-  T& operator () (octave_idx_type r, octave_idx_type c) 
-    {
-      return elem (r, c);
-    }
-#endif
-
   // No checking.
 
   T xelem (octave_idx_type r, octave_idx_type c) const
     {
       return (r == c) ? Array<T>::xelem (r) : T (0);
     }
 
   T& dgxelem (octave_idx_type i)
@@ -216,17 +147,17 @@ public:
     { return Array<T>::xelem (i); }
 
   void resize (octave_idx_type n, octave_idx_type m, 
                const T& rfv = Array<T>::resize_fill_value ());
 
   DiagArray2<T> transpose (void) const;
   DiagArray2<T> hermitian (T (*fcn) (const T&) = 0) const;
 
-  operator Array<T> (void) const;
+  Array<T> array_value (void) const;
 
   const T *data (void) const { return Array<T>::data (); }
 
   const T *fortran_vec (void) const { return Array<T>::fortran_vec (); }
 
   T *fortran_vec (void) { return Array<T>::fortran_vec (); }
 
   void print_info (std::ostream& os, const std::string& prefix) const
diff --git a/liboctave/MDiagArray2.h b/liboctave/MDiagArray2.h
--- a/liboctave/MDiagArray2.h
+++ b/liboctave/MDiagArray2.h
@@ -47,18 +47,16 @@ protected:
 public:
   
   MDiagArray2 (void) : DiagArray2<T> () { }
 
   MDiagArray2 (octave_idx_type r, octave_idx_type c) : DiagArray2<T> (r, c) { }
 
   MDiagArray2 (octave_idx_type r, octave_idx_type c, const T& val) : DiagArray2<T> (r, c, val) { }
 
-  MDiagArray2 (const dim_vector& dv) : DiagArray2<T> (dv) { }
-
   MDiagArray2 (const MDiagArray2<T>& a) : DiagArray2<T> (a) { }
 
   MDiagArray2 (const DiagArray2<T>& a) : DiagArray2<T> (a) { }
 
   template <class U>
   MDiagArray2 (const DiagArray2<U>& a) : DiagArray2<T> (a) { }
 
   explicit MDiagArray2 (const Array<T>& a) : DiagArray2<T> (a) { }
@@ -69,19 +67,19 @@ public:
   ~MDiagArray2 (void) { }
 
   MDiagArray2<T>& operator = (const MDiagArray2<T>& a)
     {
       DiagArray2<T>::operator = (a);
       return *this;
     }
 
-  operator MArray<T> () const
+  MArray<T> array_value () const
     {
-      return DiagArray2<T>::operator Array<T> ();
+      return DiagArray2<T>::array_value ();
     }
 
   octave_idx_type nnz (void) const
     {
       octave_idx_type retval = 0;
 
       const T *d = this->data ();
 
diff --git a/liboctave/dColVector.cc b/liboctave/dColVector.cc
--- a/liboctave/dColVector.cc
+++ b/liboctave/dColVector.cc
@@ -141,33 +141,31 @@ ColumnVector::stack (const ColumnVector&
 
 RowVector
 ColumnVector::transpose (void) const
 {
   return MArray<double>::transpose();
 }
 
 ColumnVector
+ColumnVector::abs (void) const
+{
+  return do_mx_unary_map<double, double, std::abs> (*this);
+}
+
+ColumnVector
 real (const ComplexColumnVector& a)
 {
-  octave_idx_type a_len = a.length ();
-  ColumnVector retval;
-  if (a_len > 0)
-    retval = ColumnVector (mx_inline_real_dup (a.data (), a_len), a_len);
-  return retval;
+  return do_mx_unary_op<double, Complex> (a, mx_inline_real);
 }
 
 ColumnVector
 imag (const ComplexColumnVector& a)
 {
-  octave_idx_type a_len = a.length ();
-  ColumnVector retval;
-  if (a_len > 0)
-    retval = ColumnVector (mx_inline_imag_dup (a.data (), a_len), a_len);
-  return retval;
+  return do_mx_unary_op<double, Complex> (a, mx_inline_imag);
 }
 
 // resize is the destructive equivalent for this one
 
 ColumnVector
 ColumnVector::extract (octave_idx_type r1, octave_idx_type r2) const
 {
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
diff --git a/liboctave/dColVector.h b/liboctave/dColVector.h
--- a/liboctave/dColVector.h
+++ b/liboctave/dColVector.h
@@ -85,16 +85,18 @@ public:
 
   friend OCTAVE_API ColumnVector operator * (const DiagMatrix& a, const ColumnVector& b);
 
   // other operations
 
   double min (void) const;
   double max (void) const;
 
+  ColumnVector abs (void) const;
+
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const ColumnVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, ColumnVector& a);
 
   void resize (octave_idx_type n, const double& rfv = Array<double>::resize_fill_value ())
     { Array<double>::resize (n, 1, rfv); }
 
diff --git a/liboctave/dDiagMatrix.cc b/liboctave/dDiagMatrix.cc
--- a/liboctave/dDiagMatrix.cc
+++ b/liboctave/dDiagMatrix.cc
@@ -137,42 +137,29 @@ DiagMatrix::fill (const RowVector& a, oc
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 DiagMatrix
 DiagMatrix::abs (void) const
 {
-  DiagMatrix retval (rows (), cols ());
-  for (octave_idx_type i = 0; i < rows (); i++)
-    retval(i, i) = std::abs (elem (i, i));
-  return retval;
+  return DiagMatrix (diag ().abs (), rows (), columns ());
 }
 
 DiagMatrix
 real (const ComplexDiagMatrix& a)
 {
-  DiagMatrix retval;
-  octave_idx_type a_len = a.length ();
-  if (a_len > 0)
-    retval = DiagMatrix (mx_inline_real_dup (a.data (), a_len), a.rows (),
-                         a.cols ());
-  return retval;
+  return DiagMatrix (real (a.diag ()), a.rows (), a.cols ());
 }
 
 DiagMatrix
 imag (const ComplexDiagMatrix& a)
 {
-  DiagMatrix retval;
-  octave_idx_type a_len = a.length ();
-  if (a_len > 0)
-    retval = DiagMatrix (mx_inline_imag_dup (a.data (), a_len), a.rows (),
-                         a.cols ());
-  return retval;
+  return DiagMatrix (imag (a.diag ()), a.rows (), a.cols ());
 }
 
 Matrix
 DiagMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
 {
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
diff --git a/liboctave/dDiagMatrix.h b/liboctave/dDiagMatrix.h
--- a/liboctave/dDiagMatrix.h
+++ b/liboctave/dDiagMatrix.h
@@ -49,19 +49,20 @@ public:
 
   DiagMatrix (const DiagMatrix& a) : MDiagArray2<double> (a) { }
 
   DiagMatrix (const MDiagArray2<double>& a) : MDiagArray2<double> (a) { }
 
   template <class U>
   DiagMatrix (const DiagArray2<U>& a) : MDiagArray2<double> (a) { }
 
-  explicit DiagMatrix (const RowVector& a) : MDiagArray2<double> (a) { }
+  explicit DiagMatrix (const Array<double>& a) : MDiagArray2<double> (a) { }
 
-  explicit DiagMatrix (const ColumnVector& a) : MDiagArray2<double> (a) { }
+  DiagMatrix (const Array<double>& a, octave_idx_type r, octave_idx_type c) 
+    : MDiagArray2<double> (a, r, c) { }
 
   DiagMatrix& operator = (const DiagMatrix& a)
     {
       MDiagArray2<double>::operator = (a);
       return *this;
     }
 
   bool operator == (const DiagMatrix& a) const;
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -560,25 +560,23 @@ Matrix::stack (const DiagMatrix& a) cons
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 Matrix
 real (const ComplexMatrix& a)
 {
-  return Matrix (mx_inline_real_dup (a.data (), a.length ()),
-                 a.rows (), a.cols ());
+  return do_mx_unary_op<double, Complex> (a, mx_inline_real);
 }
 
 Matrix
 imag (const ComplexMatrix& a)
 {
-  return Matrix (mx_inline_imag_dup (a.data (), a.length ()),
-                 a.rows (), a.cols ());
+  return do_mx_unary_op<double, Complex> (a, mx_inline_imag);
 }
 
 Matrix
 Matrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
 {
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
@@ -2817,18 +2815,17 @@ Matrix
 Matrix::sumsq (int dim) const
 {
   return do_mx_red_op<double, double> (*this, dim, mx_inline_sumsq);
 }
 
 Matrix
 Matrix::abs (void) const
 {
-  return Matrix (mx_inline_fabs_dup (data (), length ()),
-                 rows (), cols ());
+  return do_mx_unary_map<double, double, std::abs> (*this);
 }
 
 Matrix
 Matrix::diag (octave_idx_type k) const
 {
   return MArray<double>::diag (k);
 }
 
diff --git a/liboctave/dRowVector.cc b/liboctave/dRowVector.cc
--- a/liboctave/dRowVector.cc
+++ b/liboctave/dRowVector.cc
@@ -145,31 +145,23 @@ ColumnVector
 RowVector::transpose (void) const
 {
   return MArray<double>::transpose();
 }
 
 RowVector
 real (const ComplexRowVector& a)
 {
-  octave_idx_type a_len = a.length ();
-  RowVector retval;
-  if (a_len > 0)
-    retval = RowVector (mx_inline_real_dup (a.data (), a_len), a_len);
-  return retval;
+  return do_mx_unary_op<double, Complex> (a, mx_inline_real);
 }
 
 RowVector
 imag (const ComplexRowVector& a)
 {
-  octave_idx_type a_len = a.length ();
-  RowVector retval;
-  if (a_len > 0)
-    retval = RowVector (mx_inline_imag_dup (a.data (), a_len), a_len);
-  return retval;
+  return do_mx_unary_op<double, Complex> (a, mx_inline_imag);
 }
 
 RowVector
 RowVector::extract (octave_idx_type c1, octave_idx_type c2) const
 {
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
   octave_idx_type new_c = c2 - c1 + 1;
diff --git a/liboctave/fCColVector.cc b/liboctave/fCColVector.cc
--- a/liboctave/fCColVector.cc
+++ b/liboctave/fCColVector.cc
@@ -226,24 +226,26 @@ FloatComplexColumnVector::hermitian (voi
 }
 
 FloatComplexRowVector 
 FloatComplexColumnVector::transpose (void) const
 {
   return MArray<FloatComplex>::transpose ();
 }
 
+FloatColumnVector
+FloatComplexColumnVector::abs (void) const
+{
+  return do_mx_unary_map<float, FloatComplex, std::abs> (*this);
+}
+
 FloatComplexColumnVector
 conj (const FloatComplexColumnVector& a)
 {
-  octave_idx_type a_len = a.length ();
-  FloatComplexColumnVector retval;
-  if (a_len > 0)
-    retval = FloatComplexColumnVector (mx_inline_conj_dup (a.data (), a_len), a_len);
-  return retval;
+  return do_mx_unary_map<FloatComplex, FloatComplex, std::conj> (a);
 }
 
 // resize is the destructive equivalent for this one
 
 FloatComplexColumnVector
 FloatComplexColumnVector::extract (octave_idx_type r1, octave_idx_type r2) const
 {
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
diff --git a/liboctave/fCColVector.h b/liboctave/fCColVector.h
--- a/liboctave/fCColVector.h
+++ b/liboctave/fCColVector.h
@@ -116,16 +116,18 @@ public:
   friend OCTAVE_API FloatComplexColumnVector operator * (const FloatComplexDiagMatrix& a,
                                          const FloatComplexColumnVector& b);
 
   // other operations
 
   FloatComplex min (void) const;
   FloatComplex max (void) const;
 
+  FloatColumnVector abs (void) const;
+
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatComplexColumnVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatComplexColumnVector& a);
 
   void resize (octave_idx_type n, const FloatComplex& rfv = Array<FloatComplex>::resize_fill_value ())
     { Array<FloatComplex>::resize (n, 1, rfv); }
 
diff --git a/liboctave/fCDiagMatrix.cc b/liboctave/fCDiagMatrix.cc
--- a/liboctave/fCDiagMatrix.cc
+++ b/liboctave/fCDiagMatrix.cc
@@ -232,31 +232,23 @@ FloatComplexDiagMatrix::fill (const Floa
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 FloatDiagMatrix
 FloatComplexDiagMatrix::abs (void) const
 {
-  FloatDiagMatrix retval (rows (), cols ());
-  for (octave_idx_type i = 0; i < rows (); i++)
-    retval(i, i) = std::abs (elem (i, i));
-  return retval;
+  return FloatDiagMatrix (diag ().abs (), rows (), columns ());
 }
 
 FloatComplexDiagMatrix
 conj (const FloatComplexDiagMatrix& a)
 {
-  FloatComplexDiagMatrix retval;
-  octave_idx_type a_len = a.length ();
-  if (a_len > 0)
-    retval = FloatComplexDiagMatrix (mx_inline_conj_dup (a.data (), a_len),
-                                a.rows (), a.cols ());
-  return retval;
+  return FloatComplexDiagMatrix (conj (a.diag ()), a.rows (), a.columns ());
 }
 
 // resize is the destructive analog for this one
 
 FloatComplexMatrix
 FloatComplexDiagMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
 {
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
diff --git a/liboctave/fCDiagMatrix.h b/liboctave/fCDiagMatrix.h
--- a/liboctave/fCDiagMatrix.h
+++ b/liboctave/fCDiagMatrix.h
@@ -42,27 +42,24 @@ public:
 
   FloatComplexDiagMatrix (void) : MDiagArray2<FloatComplex> () { }
 
   FloatComplexDiagMatrix (octave_idx_type r, octave_idx_type c) : MDiagArray2<FloatComplex> (r, c) { }
 
   FloatComplexDiagMatrix (octave_idx_type r, octave_idx_type c, const FloatComplex& val)
     : MDiagArray2<FloatComplex> (r, c, val) { }
 
-  explicit FloatComplexDiagMatrix (const FloatRowVector& a)
-    : MDiagArray2<FloatComplex> (FloatComplexRowVector (a)) { }
-
-  explicit FloatComplexDiagMatrix (const FloatComplexRowVector& a)
+  explicit FloatComplexDiagMatrix (const Array<FloatComplex>& a)
     : MDiagArray2<FloatComplex> (a) { }
 
-  explicit FloatComplexDiagMatrix (const FloatColumnVector& a)
-    : MDiagArray2<FloatComplex> (FloatComplexColumnVector (a)) { }
+  FloatComplexDiagMatrix (const Array<FloatComplex>& a, octave_idx_type r, octave_idx_type c) 
+    : MDiagArray2<FloatComplex> (a, r, c) { }
 
-  explicit FloatComplexDiagMatrix (const FloatComplexColumnVector& a)
-    : MDiagArray2<FloatComplex> (a) { }
+  explicit FloatComplexDiagMatrix (const Array<float>& a)
+    : MDiagArray2<FloatComplex> (Array<FloatComplex> (a)) { }
 
   explicit FloatComplexDiagMatrix (const FloatDiagMatrix& a);
 
   FloatComplexDiagMatrix (const MDiagArray2<FloatComplex>& a)
     : MDiagArray2<FloatComplex> (a) { }
 
   FloatComplexDiagMatrix (const FloatComplexDiagMatrix& a)
     : MDiagArray2<FloatComplex> (a) { }
diff --git a/liboctave/fCMatrix.cc b/liboctave/fCMatrix.cc
--- a/liboctave/fCMatrix.cc
+++ b/liboctave/fCMatrix.cc
@@ -886,18 +886,17 @@ FloatComplexMatrix::stack (const FloatCo
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 FloatComplexMatrix
 conj (const FloatComplexMatrix& a)
 {
-  return FloatComplexMatrix (mx_inline_conj_dup (a.data (), a.length ()),
-                             a.rows (), a.cols ());
+  return do_mx_unary_map<FloatComplex, FloatComplex, std::conj> (a);
 }
 
 // resize is the destructive equivalent for this one
 
 FloatComplexMatrix
 FloatComplexMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
 {
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
@@ -3231,18 +3230,17 @@ FloatComplexMatrix::sum (int dim) const
 FloatComplexMatrix
 FloatComplexMatrix::sumsq (int dim) const
 {
   return do_mx_red_op<float, FloatComplex> (*this, dim, mx_inline_sumsq);
 }
 
 FloatMatrix FloatComplexMatrix::abs (void) const
 {
-  return FloatMatrix (mx_inline_cabs_dup (data (), length ()),
-                      rows (), cols ());
+  return do_mx_unary_map<float, FloatComplex, std::abs> (*this);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::diag (octave_idx_type k) const
 {
   return MArray<FloatComplex>::diag (k);
 }
 
diff --git a/liboctave/fCRowVector.cc b/liboctave/fCRowVector.cc
--- a/liboctave/fCRowVector.cc
+++ b/liboctave/fCRowVector.cc
@@ -227,21 +227,17 @@ FloatComplexColumnVector
 FloatComplexRowVector::transpose (void) const
 {
   return MArray<FloatComplex>::transpose ();
 }
 
 FloatComplexRowVector
 conj (const FloatComplexRowVector& a)
 {
-  octave_idx_type a_len = a.length ();
-  FloatComplexRowVector retval;
-  if (a_len > 0)
-    retval = FloatComplexRowVector (mx_inline_conj_dup (a.data (), a_len), a_len);
-  return retval;
+  return do_mx_unary_map<FloatComplex, FloatComplex, std::conj> (a);
 }
 
 // resize is the destructive equivalent for this one
 
 FloatComplexRowVector
 FloatComplexRowVector::extract (octave_idx_type c1, octave_idx_type c2) const
 {
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
diff --git a/liboctave/fColVector.cc b/liboctave/fColVector.cc
--- a/liboctave/fColVector.cc
+++ b/liboctave/fColVector.cc
@@ -141,33 +141,31 @@ FloatColumnVector::stack (const FloatCol
 
 FloatRowVector
 FloatColumnVector::transpose (void) const
 {
   return MArray<float>::transpose();
 }
 
 FloatColumnVector
+FloatColumnVector::abs (void) const
+{
+  return do_mx_unary_map<float, float, std::abs> (*this);
+}
+
+FloatColumnVector
 real (const FloatComplexColumnVector& a)
 {
-  octave_idx_type a_len = a.length ();
-  FloatColumnVector retval;
-  if (a_len > 0)
-    retval = FloatColumnVector (mx_inline_real_dup (a.data (), a_len), a_len);
-  return retval;
+  return do_mx_unary_op<float, FloatComplex> (a, mx_inline_real);
 }
 
 FloatColumnVector
 imag (const FloatComplexColumnVector& a)
 {
-  octave_idx_type a_len = a.length ();
-  FloatColumnVector retval;
-  if (a_len > 0)
-    retval = FloatColumnVector (mx_inline_imag_dup (a.data (), a_len), a_len);
-  return retval;
+  return do_mx_unary_op<float, FloatComplex> (a, mx_inline_imag);
 }
 
 // resize is the destructive equivalent for this one
 
 FloatColumnVector
 FloatColumnVector::extract (octave_idx_type r1, octave_idx_type r2) const
 {
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
diff --git a/liboctave/fColVector.h b/liboctave/fColVector.h
--- a/liboctave/fColVector.h
+++ b/liboctave/fColVector.h
@@ -85,16 +85,18 @@ public:
 
   friend OCTAVE_API FloatColumnVector operator * (const FloatDiagMatrix& a, const FloatColumnVector& b);
 
   // other operations
 
   float min (void) const;
   float max (void) const;
 
+  FloatColumnVector abs (void) const;
+
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatColumnVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatColumnVector& a);
 
   void resize (octave_idx_type n, const float& rfv = Array<float>::resize_fill_value ())
     { Array<float>::resize (n, 1, rfv); }
 
diff --git a/liboctave/fDiagMatrix.cc b/liboctave/fDiagMatrix.cc
--- a/liboctave/fDiagMatrix.cc
+++ b/liboctave/fDiagMatrix.cc
@@ -137,42 +137,29 @@ FloatDiagMatrix::fill (const FloatRowVec
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 FloatDiagMatrix
 FloatDiagMatrix::abs (void) const
 {
-  FloatDiagMatrix retval (rows (), cols ());
-  for (octave_idx_type i = 0; i < rows (); i++)
-    retval(i, i) = std::abs (elem (i, i));
-  return retval;
+  return FloatDiagMatrix (diag ().abs (), rows (), columns ());
 }
 
 FloatDiagMatrix
 real (const FloatComplexDiagMatrix& a)
 {
-  FloatDiagMatrix retval;
-  octave_idx_type a_len = a.length ();
-  if (a_len > 0)
-    retval = FloatDiagMatrix (mx_inline_real_dup (a.data (), a_len), a.rows (),
-                         a.cols ());
-  return retval;
+  return FloatDiagMatrix (real (a.diag ()), a.rows (), a.columns ());
 }
 
 FloatDiagMatrix
 imag (const FloatComplexDiagMatrix& a)
 {
-  FloatDiagMatrix retval;
-  octave_idx_type a_len = a.length ();
-  if (a_len > 0)
-    retval = FloatDiagMatrix (mx_inline_imag_dup (a.data (), a_len), a.rows (),
-                         a.cols ());
-  return retval;
+  return FloatDiagMatrix (imag (a.diag ()), a.rows (), a.columns ());
 }
 
 FloatMatrix
 FloatDiagMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
 {
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
diff --git a/liboctave/fDiagMatrix.h b/liboctave/fDiagMatrix.h
--- a/liboctave/fDiagMatrix.h
+++ b/liboctave/fDiagMatrix.h
@@ -49,19 +49,20 @@ public:
 
   FloatDiagMatrix (const FloatDiagMatrix& a) : MDiagArray2<float> (a) { }
 
   FloatDiagMatrix (const MDiagArray2<float>& a) : MDiagArray2<float> (a) { }
 
   template <class U>
   FloatDiagMatrix (const DiagArray2<U>& a) : MDiagArray2<float> (a) { }
 
-  explicit FloatDiagMatrix (const FloatRowVector& a) : MDiagArray2<float> (a) { }
+  explicit FloatDiagMatrix (const Array<double>& a) : MDiagArray2<float> (a) { }
 
-  explicit FloatDiagMatrix (const FloatColumnVector& a) : MDiagArray2<float> (a) { }
+  FloatDiagMatrix (const Array<float>& a, octave_idx_type r, octave_idx_type c) 
+    : MDiagArray2<float> (a, r, c) { }
 
   FloatDiagMatrix& operator = (const FloatDiagMatrix& a)
     {
       MDiagArray2<float>::operator = (a);
       return *this;
     }
 
   bool operator == (const FloatDiagMatrix& a) const;
diff --git a/liboctave/fMatrix.cc b/liboctave/fMatrix.cc
--- a/liboctave/fMatrix.cc
+++ b/liboctave/fMatrix.cc
@@ -559,25 +559,23 @@ FloatMatrix::stack (const FloatDiagMatri
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 FloatMatrix
 real (const FloatComplexMatrix& a)
 {
-  return FloatMatrix (mx_inline_real_dup (a.data (), a.length ()),
-                      a.rows (), a.cols ());
+  return do_mx_unary_op<float, FloatComplex> (a, mx_inline_real);
 }
 
 FloatMatrix
 imag (const FloatComplexMatrix& a)
 {
-  return FloatMatrix (mx_inline_imag_dup (a.data (), a.length ()),
-                      a.rows (), a.cols ());
+  return do_mx_unary_op<float, FloatComplex> (a, mx_inline_imag);
 }
 
 FloatMatrix
 FloatMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
 {
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
@@ -2816,18 +2814,17 @@ FloatMatrix
 FloatMatrix::sumsq (int dim) const
 {
   return do_mx_red_op<float, float> (*this, dim, mx_inline_sumsq);
 }
 
 FloatMatrix
 FloatMatrix::abs (void) const
 {
-  return FloatMatrix (mx_inline_fabs_dup (data (), length ()),
-                      rows (), cols ());
+  return do_mx_unary_map<float, float, std::abs> (*this);
 }
 
 FloatMatrix
 FloatMatrix::diag (octave_idx_type k) const
 {
   return MArray<float>::diag (k);
 }
 
diff --git a/liboctave/fRowVector.cc b/liboctave/fRowVector.cc
--- a/liboctave/fRowVector.cc
+++ b/liboctave/fRowVector.cc
@@ -145,31 +145,23 @@ FloatColumnVector
 FloatRowVector::transpose (void) const
 {
   return MArray<float>::transpose();
 }
 
 FloatRowVector
 real (const FloatComplexRowVector& a)
 {
-  octave_idx_type a_len = a.length ();
-  FloatRowVector retval;
-  if (a_len > 0)
-    retval = FloatRowVector (mx_inline_real_dup (a.data (), a_len), a_len);
-  return retval;
+  return do_mx_unary_op<float, FloatComplex> (a, mx_inline_real);
 }
 
 FloatRowVector
 imag (const FloatComplexRowVector& a)
 {
-  octave_idx_type a_len = a.length ();
-  FloatRowVector retval;
-  if (a_len > 0)
-    retval = FloatRowVector (mx_inline_imag_dup (a.data (), a_len), a_len);
-  return retval;
+  return do_mx_unary_op<float, FloatComplex> (a, mx_inline_imag);
 }
 
 FloatRowVector
 FloatRowVector::extract (octave_idx_type c1, octave_idx_type c2) const
 {
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
   octave_idx_type new_c = c2 - c1 + 1;
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,13 @@
+2010-02-26  Jaroslav Hajek  <highegg@gmail.com>
+
+	* src/xpow.cc: Update.
+	* src/ov-base-diag.cc: Update.
+
 2010-02-25  Jaroslav Hajek  <highegg@gmail.com>
 
 	* DLD-FUNCTIONS/str2double.cc (single_number): New helper func.
 	(extract_number): Call it instead of >> to get Inf's and NaN's
 	correctly.
 
 2010-02-25  Jaroslav Hajek  <highegg@gmail.com>
 
diff --git a/src/ov-base-diag.cc b/src/ov-base-diag.cc
--- a/src/ov-base-diag.cc
+++ b/src/ov-base-diag.cc
@@ -77,18 +77,17 @@ octave_base_diag<DMT, MT>::do_index_op (
 
   if (idx.length () == 2 && ! resize_ok)
     {
       idx_vector idx0 = idx(0).index_vector ();
       idx_vector idx1 = idx(1).index_vector ();
 
       if (idx0.is_scalar () && idx1.is_scalar ())
         {
-          // FIXME: the proxy mechanism of DiagArray2 causes problems here.
-          retval = el_type (matrix.checkelem (idx0(0), idx1(0)));
+          retval = matrix.checkelem (idx0(0), idx1(0));
         }
       else
         {
           octave_idx_type m = idx0.length (matrix.rows ());
           octave_idx_type n = idx1.length (matrix.columns ());
           if (idx0.is_colon_equiv (m) && idx1.is_colon_equiv (n)
               && m <= matrix.rows () && n <= matrix.rows ())
             {
@@ -126,17 +125,17 @@ octave_base_diag<DMT, MT>::subsasgn (con
             if (jdx.length () == 2 && jdx(0).is_scalar_type () && jdx(1).is_scalar_type ())
               {
                 typename DMT::element_type val;
                 idx_vector i0 = jdx(0).index_vector (), i1 = jdx(1).index_vector ();
                 if (! error_state  && i0(0) == i1(0) 
                     && i0(0) < matrix.rows () && i1(0) < matrix.cols ()
                     && chk_valid_scalar (rhs, val))
                   {
-                    matrix (i0(0), i1(0)) = val;                    
+                    matrix.dgelem (i0(0)) = val;                    
                     retval = this;
                     this->count++;
                     // invalidate cache
                     dense_cache = octave_value ();
                   }
               }
 
             if (! error_state && ! retval.is_defined ())
diff --git a/src/xpow.cc b/src/xpow.cc
--- a/src/xpow.cc
+++ b/src/xpow.cc
@@ -276,24 +276,24 @@ xpow (const DiagMatrix& a, double b)
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be square");
   else
     {
       if (static_cast<int> (b) == b)
         {
           DiagMatrix r (nr, nc);
           for (octave_idx_type i = 0; i < nc; i++)
-            r(i, i) = std::pow (a(i, i), b);
+            r.dgelem (i) = std::pow (a.dgelem (i), b);
           retval = r;
         }
       else
         {
           ComplexDiagMatrix r (nr, nc);
           for (octave_idx_type i = 0; i < nc; i++)
-            r(i, i) = std::pow (static_cast<Complex> (a(i, i)), b);
+            r.dgelem (i) = std::pow (static_cast<Complex> (a.dgelem (i)), b);
           retval = r;
         }
     }
 
   return retval;
 }
 
 // -*- 5p -*-
@@ -1689,24 +1689,24 @@ xpow (const FloatDiagMatrix& a, float b)
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be square");
   else
     {
       if (static_cast<int> (b) == b)
         {
           FloatDiagMatrix r (nr, nc);
           for (octave_idx_type i = 0; i < nc; i++)
-            r(i, i) = std::pow (a(i, i), b);
+            r.dgelem (i) = std::pow (a.dgelem (i), b);
           retval = r;
         }
       else
         {
           FloatComplexDiagMatrix r (nr, nc);
           for (octave_idx_type i = 0; i < nc; i++)
-            r(i, i) = std::pow (static_cast<FloatComplex> (a(i, i)), b);
+            r.dgelem (i) = std::pow (static_cast<FloatComplex> (a.dgelem (i)), b);
           retval = r;
         }
     }
 
   return retval;
 }
 
 // -*- 6 -*-
