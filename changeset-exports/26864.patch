# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1552026274 0
#      Fri Mar 08 06:24:34 2019 +0000
# Node ID 041caa61ed340039c5e6587a53b1b670b444c27f
# Parent  c589db954a4e58b86f84ff878235dcf44a787c16
use get_function_handle instead of extract_function

* cellfun.cc (Fcellfun, Farrayfun): Use get_function_handle instead of
extract_function.

* daspk.cc (daspk_fcn, daspk_jac): Now octave_value objects instead
of a pointers to octave_function objects.  Change all uses.
(Fdaspk): Use get_function_handle instead of extract_function.

* dasrt.cc (dasrt_fcn, dasrt_jac, dasrt_cf): Now octave_value objects
instead of a pointers to octave_function objects.  Change all uses.
(Fdasrt): Use get_function_handle instead of extract_function.

* dassl.cc (dassl_fcn, dassl_jac): Now octave_value objects instead
of a pointers to octave_function objects.  Change all uses.
(Fdassl): Use get_function_handle instead of extract_function.

* lsode.cc (lsode_fcn, lsode_jac): Now octave_value objects instead
of a pointers to octave_function objects.  Change all uses.
(Flsode): Use get_function_handle instead of extract_function.

* quad.cc (quad_fcn): Now an octave_value object instead of a pointer
to an octave_function object.  Change all uses.
(Fquad): Use get_function_handle instead of extract_function.
New tests.

* quadcc.cc (fcn): Now an octave_value object instead of a pointer
to an octave_function object.  Change all uses.
(Fquadcc): Use get_function_handle instead of extract_function.

* __eigs__.cc (eigs_fcn): Now an octave_value object instead of a pointer
to an octave_function object.  Change all uses.
(F__eigs__): Use get_function_handle instead of extract_function.
New tests.

* interpreter-private.cc (get_function_handle): Don't scold users for
poor choices.

* variables.h (extract_function): Tag as deprecated.

diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -34,16 +34,17 @@ along with Octave; see the file COPYING.
 
 #include "lo-mappers.h"
 #include "oct-locbuf.h"
 #include "oct-string.h"
 
 #include "Cell.h"
 #include "oct-map.h"
 #include "defun.h"
+#include "interpreter-private.h"
 #include "interpreter.h"
 #include "parse.h"
 #include "variables.h"
 #include "unwind-prot.h"
 #include "errwarn.h"
 #include "utils.h"
 
 #include "ov-bool.h"
@@ -421,27 +422,17 @@ v = cellfun (@@det, a); # faster
       if (! retval.empty ())
         return retval;
 
       // See if we can convert the string into a function.
 
       std::string name = args(0).string_value ();
 
       if (! octave::valid_identifier (name))
-        {
-          std::string fcn_name = unique_symbol_name ("__cellfun_fcn__");
-          std::string fname = "function y = " + fcn_name + "(x) y = ";
-
-          octave_function *ptr_func
-            = extract_function (args(0), "cellfun", fcn_name,
-                                fname, "; endfunction");
-
-          if (ptr_func)
-            func = octave_value (ptr_func, true);
-        }
+        func = octave::get_function_handle (interp, args(0), "x");
       else
         {
           func = symtab.find_function (name);
 
           if (func.is_undefined ())
             error ("cellfun: invalid function NAME: %s", name.c_str ());
         }
     }
@@ -1142,27 +1133,17 @@ arrayfun (@@str2num, [1234],
   octave::symbol_table& symtab = interp.get_symbol_table ();
 
   if (func.is_string ())
     {
       // See if we can convert the string into a function.
       std::string name = args(0).string_value ();
 
       if (! octave::valid_identifier (name))
-        {
-          std::string fcn_name = unique_symbol_name ("__arrayfun_fcn__");
-          std::string fname = "function y = " + fcn_name + "(x) y = ";
-
-          octave_function *ptr_func
-            = extract_function (args(0), "arrayfun", fcn_name,
-                                fname, "; endfunction");
-
-          if (ptr_func)
-            func = octave_value (ptr_func, true);
-        }
+        func = octave::get_function_handle (interp, args(0), "x");
       else
         {
           func = symtab.find_function (name);
 
           if (func.is_undefined ())
             error_with_id ("Octave:invalid-input-arg",
                            "arrayfun: invalid function NAME: %s",
                            name.c_str ());
diff --git a/libinterp/corefcn/daspk.cc b/libinterp/corefcn/daspk.cc
--- a/libinterp/corefcn/daspk.cc
+++ b/libinterp/corefcn/daspk.cc
@@ -19,39 +19,41 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
+#include <list>
 #include <string>
 
 #include "DASPK.h"
 
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
+#include "interpreter-private.h"
 #include "ovl.h"
 #include "ov-fcn.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "parse.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 #include "DASPK-opts.cc"
 
 // Global pointer for user defined function required by daspk.
-static octave_function *daspk_fcn;
+static octave_value daspk_fcn;
 
 // Global pointer for optional user defined jacobian function.
-static octave_function *daspk_jac;
+static octave_value daspk_jac;
 
 // Have we warned about imaginary values returned from user function?
 static bool warned_fcn_imaginary = false;
 static bool warned_jac_imaginary = false;
 
 // Is this a recursive call?
 static int call_depth = 0;
 
@@ -64,17 +66,17 @@ daspk_user_function (const ColumnVector&
   assert (x.numel () == xdot.numel ());
 
   octave_value_list args;
 
   args(2) = t;
   args(1) = xdot;
   args(0) = x;
 
-  if (daspk_fcn)
+  if (daspk_fcn.is_defined ())
     {
       octave_value_list tmp;
 
       try
         {
           tmp = octave::feval (daspk_fcn, args, 1);
         }
       catch (octave::execution_exception& e)
@@ -114,17 +116,17 @@ daspk_user_jacobian (const ColumnVector&
 
   octave_value_list args;
 
   args(3) = cj;
   args(2) = t;
   args(1) = xdot;
   args(0) = x;
 
-  if (daspk_jac)
+  if (daspk_jac.is_defined ())
     {
       octave_value_list tmp;
 
       try
         {
           tmp = octave::feval (daspk_jac, args, 1);
         }
       catch (octave::execution_exception& e)
@@ -264,127 +266,91 @@ parameters for @code{daspk}.
 
   octave_value_list retval (4);
 
   octave::unwind_protect frame;
 
   frame.protect_var (call_depth);
   call_depth++;
 
-  octave::symbol_table& symtab = interp.get_symbol_table ();
-
   if (call_depth > 1)
     error ("daspk: invalid recursive call");
 
   std::string fcn_name, fname, jac_name, jname;
-  daspk_fcn = nullptr;
-  daspk_jac = nullptr;
+
+  daspk_fcn = octave_value ();
+  daspk_jac = octave_value ();
 
   octave_value f_arg = args(0);
 
+  std::list<std::string> fcn_param_names ({"x", "xdot", "t"});
+  std::list<std::string> jac_param_names ({"x", "xdot", "t", "cj"});
+
   if (f_arg.iscell ())
     {
       Cell c = f_arg.cell_value ();
       if (c.numel () == 1)
         f_arg = c(0);
       else if (c.numel () == 2)
         {
-          if (c(0).is_function_handle () || c(0).is_inline_function ())
-            daspk_fcn = c(0).function_value ();
-          else
-            {
-              fcn_name = unique_symbol_name ("__daspk_fcn__");
-              fname = "function y = ";
-              fname.append (fcn_name);
-              fname.append (" (x, xdot, t) y = ");
-              daspk_fcn = extract_function (c(0), "daspk", fcn_name,
-                                            fname, "; endfunction");
-            }
+          daspk_fcn = octave::get_function_handle (interp, c(0),
+                                                   fcn_param_names);
 
-          if (daspk_fcn)
+          if (daspk_fcn.is_defined ())
             {
-              if (c(1).is_function_handle () || c(1).is_inline_function ())
-                daspk_jac = c(1).function_value ();
-              else
-                {
-                  jac_name = unique_symbol_name ("__daspk_jac__");
-                  jname = "function jac = ";
-                  jname.append (jac_name);
-                  jname.append (" (x, xdot, t, cj) jac = ");
-                  daspk_jac = extract_function (c(1), "daspk", jac_name,
-                                                jname, "; endfunction");
+              daspk_jac = octave::get_function_handle (interp, c(1),
+                                                       jac_param_names);
 
-                  if (! daspk_jac)
-                    {
-                      if (fcn_name.length ())
-                        symtab.clear_function (fcn_name);
-                      daspk_fcn = nullptr;
-                    }
-                }
+              if (daspk_jac.is_undefined ())
+                daspk_fcn = octave_value ();
             }
         }
       else
         error ("daspk: incorrect number of elements in cell array");
     }
 
-  if (! daspk_fcn && ! f_arg.iscell ())
+  if (daspk_fcn.is_undefined () && ! f_arg.iscell ())
     {
       if (f_arg.is_function_handle () || f_arg.is_inline_function ())
-        daspk_fcn = f_arg.function_value ();
+        daspk_fcn = f_arg;
       else
         {
           switch (f_arg.rows ())
             {
             case 1:
-              do
-                {
-                  fcn_name = unique_symbol_name ("__daspk_fcn__");
-                  fname = "function y = ";
-                  fname.append (fcn_name);
-                  fname.append (" (x, xdot, t) y = ");
-                  daspk_fcn = extract_function (f_arg, "daspk", fcn_name,
-                                                fname, "; endfunction");
-                }
-              while (0);
+              daspk_fcn = octave::get_function_handle (interp, f_arg,
+                                                       fcn_param_names);
               break;
 
             case 2:
               {
                 string_vector tmp = f_arg.string_vector_value ();
 
-                fcn_name = unique_symbol_name ("__daspk_fcn__");
-                fname = "function y = ";
-                fname.append (fcn_name);
-                fname.append (" (x, xdot, t) y = ");
-                daspk_fcn = extract_function (tmp(0), "daspk", fcn_name,
-                                              fname, "; endfunction");
+                daspk_fcn = octave::get_function_handle (interp, tmp(0),
+                                                         fcn_param_names);
 
-                if (daspk_fcn)
+                if (daspk_fcn.is_defined ())
                   {
-                    jac_name = unique_symbol_name ("__daspk_jac__");
-                    jname = "function jac = ";
-                    jname.append (jac_name);
-                    jname.append (" (x, xdot, t, cj) jac = ");
-                    daspk_jac = extract_function (tmp(1), "daspk", jac_name,
-                                                  jname, "; endfunction");
+                    daspk_jac = octave::get_function_handle (interp, tmp(1),
+                                                             jac_param_names);
 
-                    if (! daspk_jac)
-                      {
-                        if (fcn_name.length ())
-                          symtab.clear_function (fcn_name);
-                        daspk_fcn = nullptr;
-                      }
+                    if (daspk_jac.is_undefined ())
+                      daspk_fcn = octave_value ();
                   }
               }
+              break;
+
+            default:
+              error ("daspk: first arg should be a string or 2-element string array");
             }
         }
     }
 
-  if (! daspk_fcn)
-    return retval;
+  if (daspk_fcn.is_undefined ())
+    error ("daspk: FCN argument is not a valid function name or handle");
 
   ColumnVector state = args(1).xvector_value ("daspk: initial state X_0 must be a vector");
 
   ColumnVector deriv = args(2).xvector_value ("daspk: initial derivatives XDOT_0 must be a vector");
 
   ColumnVector out_times = args(3).xvector_value ("daspk: output time variable T must be a vector");
 
   ColumnVector crit_times;
@@ -397,35 +363,30 @@ parameters for @code{daspk}.
     }
 
   if (state.numel () != deriv.numel ())
     error ("daspk: X_0 and XDOT_0 must have the same size");
 
   double tzero = out_times (0);
 
   DAEFunc func (daspk_user_function);
-  if (daspk_jac)
+  if (daspk_jac.is_defined ())
     func.set_jacobian_function (daspk_user_jacobian);
 
   DASPK dae (state, deriv, tzero, func);
   dae.set_options (daspk_opts);
 
   Matrix output;
   Matrix deriv_output;
 
   if (crit_times_set)
     output = dae.integrate (out_times, deriv_output, crit_times);
   else
     output = dae.integrate (out_times, deriv_output);
 
-  if (fcn_name.length ())
-    symtab.clear_function (fcn_name);
-  if (jac_name.length ())
-    symtab.clear_function (jac_name);
-
   std::string msg = dae.error_message ();
 
   if (dae.integration_ok ())
     {
       retval(0) = output;
       retval(1) = deriv_output;
     }
   else
diff --git a/libinterp/corefcn/dasrt.cc b/libinterp/corefcn/dasrt.cc
--- a/libinterp/corefcn/dasrt.cc
+++ b/libinterp/corefcn/dasrt.cc
@@ -19,39 +19,41 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
+#include <list>
 #include <string>
 
 #include "DASRT.h"
 #include "lo-mappers.h"
 
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
+#include "interpreter-private.h"
 #include "ovl.h"
 #include "ov-fcn.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "parse.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 #include "DASRT-opts.cc"
 
 // Global pointers for user defined function required by dasrt.
-static octave_function *dasrt_f;
-static octave_function *dasrt_j;
-static octave_function *dasrt_cf;
+static octave_value dasrt_fcn;
+static octave_value dasrt_jac;
+static octave_value dasrt_cf;
 
 // Have we warned about imaginary values returned from user function?
 static bool warned_fcn_imaginary = false;
 static bool warned_jac_imaginary = false;
 static bool warned_cf_imaginary = false;
 
 // Is this a recursive call?
 static int call_depth = 0;
@@ -65,23 +67,23 @@ dasrt_user_f (const ColumnVector& x, con
   assert (x.numel () == xdot.numel ());
 
   octave_value_list args;
 
   args(2) = t;
   args(1) = xdot;
   args(0) = x;
 
-  if (dasrt_f)
+  if (dasrt_fcn.is_defined ())
     {
       octave_value_list tmp;
 
       try
         {
-          tmp = octave::feval (dasrt_f, args, 1);
+          tmp = octave::feval (dasrt_fcn, args, 1);
         }
       catch (octave::execution_exception& e)
         {
           err_user_supplied_eval (e, "dasrt");
         }
 
       if (tmp.empty () || ! tmp(0).is_defined ())
         err_user_supplied_eval ("dasrt");
@@ -106,17 +108,17 @@ dasrt_user_cf (const ColumnVector& x, do
 {
   ColumnVector retval;
 
   octave_value_list args;
 
   args(1) = t;
   args(0) = x;
 
-  if (dasrt_cf)
+  if (dasrt_cf.is_defined ())
     {
       octave_value_list tmp;
 
       try
         {
           tmp = octave::feval (dasrt_cf, args, 1);
         }
       catch (octave::execution_exception& e)
@@ -152,23 +154,23 @@ dasrt_user_j (const ColumnVector& x, con
 
   octave_value_list args;
 
   args(3) = cj;
   args(2) = t;
   args(1) = xdot;
   args(0) = x;
 
-  if (dasrt_j)
+  if (dasrt_jac.is_defined ())
     {
       octave_value_list tmp;
 
       try
         {
-          tmp = octave::feval (dasrt_j, args, 1);
+          tmp = octave::feval (dasrt_jac, args, 1);
         }
       catch (octave::execution_exception& e)
         {
           err_user_supplied_eval (e, "dasrt");
         }
 
       int tlen = tmp.length ();
       if (tlen == 0 || ! tmp(0).is_defined ())
@@ -348,151 +350,115 @@ parameters for @code{dasrt}.
   frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     error ("dasrt: invalid recursive call");
 
   int argp = 0;
   std::string fcn_name, fname, jac_name, jname;
-  dasrt_f = nullptr;
-  dasrt_j = nullptr;
-  dasrt_cf = nullptr;
 
-  octave::symbol_table& symtab = interp.get_symbol_table ();
+  dasrt_fcn = octave_value ();
+  dasrt_jac = octave_value ();
+  dasrt_cf = octave_value ();
 
   // Check all the arguments.  Are they the right animals?
 
   // Here's where I take care of f and j in one shot:
 
   octave_value f_arg = args(0);
 
+  std::list<std::string> fcn_param_names ({"x", "xdot", "t"});
+  std::list<std::string> jac_param_names ({"x", "xdot", "t", "cj"});
+
   if (f_arg.iscell ())
     {
       Cell c = f_arg.cell_value ();
       if (c.numel () == 1)
         f_arg = c(0);
       else if (c.numel () == 2)
         {
-          if (c(0).is_function_handle () || c(0).is_inline_function ())
-            dasrt_f = c(0).function_value ();
-          else
-            {
-              fcn_name = unique_symbol_name ("__dasrt_fcn__");
-              fname = "function y = ";
-              fname.append (fcn_name);
-              fname.append (" (x, xdot, t) y = ");
-              dasrt_f = extract_function (c(0), "dasrt", fcn_name, fname,
-                                          "; endfunction");
-            }
+          dasrt_fcn = octave::get_function_handle (interp, c(0),
+                                                   fcn_param_names);
 
-          if (dasrt_f)
+          if (dasrt_fcn.is_defined ())
             {
-              if (c(1).is_function_handle () || c(1).is_inline_function ())
-                dasrt_j = c(1).function_value ();
-              else
-                {
-                  jac_name = unique_symbol_name ("__dasrt_jac__");
-                  jname = "function jac = ";
-                  jname.append (jac_name);
-                  jname.append (" (x, xdot, t, cj) jac = ");
-                  dasrt_j = extract_function (c(1), "dasrt", jac_name, jname,
-                                              "; endfunction");
+              dasrt_jac = octave::get_function_handle (interp, c(1),
+                                                       jac_param_names);
 
-                  if (! dasrt_j)
-                    {
-                      if (fcn_name.length ())
-                        symtab.clear_function (fcn_name);
-                      dasrt_f = nullptr;
-                    }
-                }
+              if (dasrt_jac.is_undefined ())
+                dasrt_fcn = octave_value ();
             }
         }
       else
         error ("dasrt: incorrect number of elements in cell array");
     }
 
-  if (! dasrt_f && ! f_arg.iscell ())
+  if (dasrt_fcn.is_undefined () && ! f_arg.iscell ())
     {
       if (f_arg.is_function_handle () || f_arg.is_inline_function ())
-        dasrt_f = f_arg.function_value ();
+        dasrt_fcn = f_arg;
       else
         {
           switch (f_arg.rows ())
             {
             case 1:
-              fcn_name = unique_symbol_name ("__dasrt_fcn__");
-              fname = "function y = ";
-              fname.append (fcn_name);
-              fname.append (" (x, xdot, t) y = ");
-              dasrt_f = extract_function (f_arg, "dasrt", fcn_name, fname,
-                                          "; endfunction");
+              dasrt_fcn = octave::get_function_handle (interp, f_arg,
+                                                       fcn_param_names);
               break;
 
             case 2:
               {
-                string_vector tmp = args(0).string_vector_value ();
+                string_vector tmp = f_arg.string_vector_value ();
 
-                fcn_name = unique_symbol_name ("__dasrt_fcn__");
-                fname = "function y = ";
-                fname.append (fcn_name);
-                fname.append (" (x, xdot, t) y = ");
-                dasrt_f = extract_function (tmp(0), "dasrt", fcn_name,
-                                            fname, "; endfunction");
+                dasrt_fcn = octave::get_function_handle (interp, tmp(0),
+                                                         fcn_param_names);
 
-                if (dasrt_f)
+                if (dasrt_fcn.is_defined ())
                   {
-                    jac_name = unique_symbol_name ("__dasrt_jac__");
-                    jname = "function jac = ";
-                    jname.append (jac_name);
-                    jname.append (" (x, xdot, t, cj) jac = ");
-                    dasrt_j = extract_function (tmp(1), "dasrt", jac_name,
-                                                jname, "; endfunction");
+                    dasrt_jac = octave::get_function_handle (interp, tmp(1),
+                                                             jac_param_names);
 
-                    if (! dasrt_j)
-                      dasrt_f = nullptr;
+                    if (dasrt_jac.is_undefined ())
+                      dasrt_fcn = octave_value ();
                   }
               }
               break;
 
             default:
               error ("dasrt: first arg should be a string or 2-element string array");
             }
         }
     }
 
-  if (! dasrt_f)
-    return retval;
+  if (dasrt_fcn.is_undefined ())
+    error ("dasrt: FCN argument is not a valid function name or handle");
 
   DAERTFunc func (dasrt_user_f);
 
   argp++;
 
   if (args(1).isempty () && args(1).is_double_type ())
     {
       // Allow [] to skip constraint function.  This feature is
       // undocumented now, but was supported by earlier versions.
 
       argp++;
     }
   else
     {
-      if (args(1).is_function_handle () || args(1).is_inline_function ())
-        dasrt_cf = args(1).function_value ();
-      else if (args(1).is_string ())
+      if (args(1).is_function_handle () || args(1).is_inline_function ()
+          || args(1).is_string ())
         {
-          fcn_name = unique_symbol_name ("__dasrt_constraint_fcn__");
-          fname = "function g_out = ";
-          fname.append (fcn_name);
-          fname.append (" (x, t) g_out = ");
-          dasrt_cf = extract_function (args(1), "dasrt", fcn_name, fname,
-                                       "; endfunction");
+          std::list<std::string> cf_param_names ({"x", "t"});
+
+          dasrt_cf = octave::get_function_handle (interp, args(1), cf_param_names);
         }
 
-      if (dasrt_cf)
+      if (dasrt_cf.is_defined ())
         {
           argp++;
 
           func.set_constraint_function (dasrt_user_cf);
         }
     }
 
   if (argp + 3 > nargin)
@@ -513,35 +479,30 @@ parameters for @code{dasrt}.
   if (argp < nargin)
     {
       crit_times = args(argp).xvector_value ("dasrt: list of critical times T_CRIT must be a vector");
       argp++;
 
       crit_times_set = true;
     }
 
-  if (dasrt_j)
+  if (dasrt_jac.is_defined ())
     func.set_jacobian_function (dasrt_user_j);
 
   DASRT_result output;
 
   DASRT dae = DASRT (state, stateprime, tzero, func);
 
   dae.set_options (dasrt_opts);
 
   if (crit_times_set)
     output = dae.integrate (out_times, crit_times);
   else
     output = dae.integrate (out_times);
 
-  if (fcn_name.length ())
-    symtab.clear_function (fcn_name);
-  if (jac_name.length ())
-    symtab.clear_function (jac_name);
-
   std::string msg = dae.error_message ();
 
   if (dae.integration_ok ())
     {
       retval(0) = output.state ();
       retval(1) = output.deriv ();
       retval(2) = output.times ();
     }
diff --git a/libinterp/corefcn/dassl.cc b/libinterp/corefcn/dassl.cc
--- a/libinterp/corefcn/dassl.cc
+++ b/libinterp/corefcn/dassl.cc
@@ -26,32 +26,33 @@ along with Octave; see the file COPYING.
 
 #include <string>
 
 #include "DASSL.h"
 
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
+#include "interpreter-private.h"
 #include "ovl.h"
 #include "ov-fcn.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "parse.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 #include "DASSL-opts.cc"
 
 // Global pointer for user defined function required by dassl.
-static octave_function *dassl_fcn;
+static octave_value dassl_fcn;
 
 // Global pointer for optional user defined jacobian function.
-static octave_function *dassl_jac;
+static octave_value dassl_jac;
 
 // Have we warned about imaginary values returned from user function?
 static bool warned_fcn_imaginary = false;
 static bool warned_jac_imaginary = false;
 
 // Is this a recursive call?
 static int call_depth = 0;
 
@@ -64,17 +65,17 @@ dassl_user_function (const ColumnVector&
   assert (x.numel () == xdot.numel ());
 
   octave_value_list args;
 
   args(2) = t;
   args(1) = xdot;
   args(0) = x;
 
-  if (dassl_fcn)
+  if (dassl_fcn.is_defined ())
     {
       octave_value_list tmp;
 
       try
         {
           tmp = octave::feval (dassl_fcn, args, 1);
         }
       catch (octave::execution_exception& e)
@@ -114,17 +115,17 @@ dassl_user_jacobian (const ColumnVector&
 
   octave_value_list args;
 
   args(3) = cj;
   args(2) = t;
   args(1) = xdot;
   args(0) = x;
 
-  if (dassl_jac)
+  if (dassl_jac.is_defined ())
     {
       octave_value_list tmp;
 
       try
         {
           tmp = octave::feval (dassl_jac, args, 1);
         }
       catch (octave::execution_exception& e)
@@ -268,125 +269,88 @@ parameters for @code{dassl}.
   octave::unwind_protect frame;
 
   frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     error ("dassl: invalid recursive call");
 
-  octave::symbol_table& symtab = interp.get_symbol_table ();
+  std::string fcn_name, fname, jac_name, jname;
 
-  std::string fcn_name, fname, jac_name, jname;
-  dassl_fcn = nullptr;
-  dassl_jac = nullptr;
+  dassl_fcn = octave_value ();
+  dassl_jac = octave_value ();
 
   octave_value f_arg = args(0);
 
+  std::list<std::string> fcn_param_names ({"x", "xdot", "t"});
+  std::list<std::string> jac_param_names ({"x", "xdot", "t", "cj"});
+
   if (f_arg.iscell ())
     {
       Cell c = f_arg.cell_value ();
       if (c.numel () == 1)
         f_arg = c(0);
       else if (c.numel () == 2)
         {
-          if (c(0).is_function_handle () || c(0).is_inline_function ())
-            dassl_fcn = c(0).function_value ();
-          else
-            {
-              fcn_name = unique_symbol_name ("__dassl_fcn__");
-              fname = "function y = ";
-              fname.append (fcn_name);
-              fname.append (" (x, xdot, t) y = ");
-              dassl_fcn = extract_function (c(0), "dassl", fcn_name, fname,
-                                            "; endfunction");
-            }
+          dassl_fcn = octave::get_function_handle (interp, c(0),
+                                                   fcn_param_names);
 
-          if (dassl_fcn)
+          if (dassl_fcn.is_defined ())
             {
-              if (c(1).is_function_handle () || c(1).is_inline_function ())
-                dassl_jac = c(1).function_value ();
-              else
-                {
-                  jac_name = unique_symbol_name ("__dassl_jac__");
-                  jname = "function jac = ";
-                  jname.append (jac_name);
-                  jname.append (" (x, xdot, t, cj) jac = ");
-                  dassl_jac = extract_function (c(1), "dassl", jac_name,
-                                                jname, "; endfunction");
+              dassl_jac = octave::get_function_handle (interp, c(1),
+                                                       jac_param_names);
 
-                  if (! dassl_jac)
-                    {
-                      if (fcn_name.length ())
-                        symtab.clear_function (fcn_name);
-                      dassl_fcn = nullptr;
-                    }
-                }
+              if (dassl_jac.is_undefined ())
+                dassl_fcn = octave_value ();
             }
         }
       else
         error ("dassl: incorrect number of elements in cell array");
     }
 
-  if (! dassl_fcn && ! f_arg.iscell ())
+  if (dassl_fcn.is_undefined () && ! f_arg.iscell ())
     {
       if (f_arg.is_function_handle () || f_arg.is_inline_function ())
-        dassl_fcn = f_arg.function_value ();
+        dassl_fcn = f_arg;
       else
         {
           switch (f_arg.rows ())
             {
             case 1:
-              do
-                {
-                  fcn_name = unique_symbol_name ("__dassl_fcn__");
-                  fname = "function y = ";
-                  fname.append (fcn_name);
-                  fname.append (" (x, xdot, t) y = ");
-                  dassl_fcn = extract_function (f_arg, "dassl", fcn_name,
-                                                fname, "; endfunction");
-                }
-              while (0);
+              dassl_fcn = octave::get_function_handle (interp, f_arg,
+                                                       fcn_param_names);
               break;
 
             case 2:
               {
                 string_vector tmp = f_arg.string_vector_value ();
 
-                fcn_name = unique_symbol_name ("__dassl_fcn__");
-                fname = "function y = ";
-                fname.append (fcn_name);
-                fname.append (" (x, xdot, t) y = ");
-                dassl_fcn = extract_function (tmp(0), "dassl", fcn_name,
-                                              fname, "; endfunction");
+                dassl_fcn = octave::get_function_handle (interp, tmp(0),
+                                                         fcn_param_names);
 
-                if (dassl_fcn)
+                if (dassl_fcn.is_defined ())
                   {
-                    jac_name = unique_symbol_name ("__dassl_jac__");
-                    jname = "function jac = ";
-                    jname.append (jac_name);
-                    jname.append (" (x, xdot, t, cj) jac = ");
-                    dassl_jac = extract_function (tmp(1), "dassl",
-                                                  jac_name, jname,
-                                                  "; endfunction");
+                    dassl_jac = octave::get_function_handle (interp, tmp(1),
+                                                             jac_param_names);
 
-                    if (! dassl_jac)
-                      {
-                        if (fcn_name.length ())
-                          symtab.clear_function (fcn_name);
-                        dassl_fcn = nullptr;
-                      }
+                    if (dassl_jac.is_undefined ())
+                      dassl_fcn = octave_value ();
                   }
               }
+              break;
+
+            default:
+              error ("dassl: first arg should be a string or 2-element string array");
             }
         }
     }
 
-  if (! dassl_fcn)
-    return retval;
+  if (dassl_fcn.is_undefined ())
+    error ("dassl: FCN argument is not a valid function name or handle");
 
   ColumnVector state = args(1).xvector_value ("dassl: initial state X_0 must be a vector");
 
   ColumnVector deriv = args(2).xvector_value ("dassl: initial derivatives XDOT_0 must be a vector");
 
   ColumnVector out_times = args(3).xvector_value ("dassl: output time variable T must be a vector");
 
   ColumnVector crit_times;
@@ -399,36 +363,31 @@ parameters for @code{dassl}.
     }
 
   if (state.numel () != deriv.numel ())
     error ("dassl: X and XDOT_0 must have the same size");
 
   double tzero = out_times (0);
 
   DAEFunc func (dassl_user_function);
-  if (dassl_jac)
+  if (dassl_jac.is_defined ())
     func.set_jacobian_function (dassl_user_jacobian);
 
   DASSL dae (state, deriv, tzero, func);
 
   dae.set_options (dassl_opts);
 
   Matrix output;
   Matrix deriv_output;
 
   if (crit_times_set)
     output = dae.integrate (out_times, deriv_output, crit_times);
   else
     output = dae.integrate (out_times, deriv_output);
 
-  if (fcn_name.length ())
-    symtab.clear_function (fcn_name);
-  if (jac_name.length ())
-    symtab.clear_function (jac_name);
-
   std::string msg = dae.error_message ();
 
   if (dae.integration_ok ())
     {
       retval(0) = output;
       retval(1) = deriv_output;
     }
   else
diff --git a/libinterp/corefcn/interpreter-private.cc b/libinterp/corefcn/interpreter-private.cc
--- a/libinterp/corefcn/interpreter-private.cc
+++ b/libinterp/corefcn/interpreter-private.cc
@@ -208,18 +208,17 @@ namespace octave
 
         octave_value fcn = symtab.find_function (fstr);
 
         if (fcn.is_defined ())
           return fcn;
 
         fcn = octave_value (new octave_fcn_inline (fstr, parameter_names));
 
-        if (fcn.is_defined ())
-          warning_with_id ("Octave:function-from-text",
-                           "get_function_handle: passing function body as text is discouraged; use an anonymous function instead");
+        // Possibly warn here that passing the function body in a
+        // character string is discouraged.
 
         return fcn;
       }
 
     return octave_value ();
   }
 }
diff --git a/libinterp/corefcn/interpreter-private.h b/libinterp/corefcn/interpreter-private.h
--- a/libinterp/corefcn/interpreter-private.h
+++ b/libinterp/corefcn/interpreter-private.h
@@ -86,17 +86,17 @@ namespace octave
 
 
   // Functions that could be methods in the interpreter class but maybe
   // shouldn't be exposed as part of the public interface.
 
   // Convert octave_value object ARG to be a function handle object.  It
   // may be a function handle, inline function, the name of a function,
   // or the text of an inline function that has the given argument names
-  // PARAMETER_NAMES.  The latter form is deprecated.
+  // PARAMETER_NAMES.  Use of the latter form is discouraged.
 
   octave_value
   get_function_handle (octave::interpreter& interp, const octave_value& arg,
                        const std::string& parameter_name);
 
   octave_value
   get_function_handle (octave::interpreter& interp, const octave_value& arg,
                        const std::list<std::string>& parameter_names
diff --git a/libinterp/corefcn/lsode.cc b/libinterp/corefcn/lsode.cc
--- a/libinterp/corefcn/lsode.cc
+++ b/libinterp/corefcn/lsode.cc
@@ -19,41 +19,43 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
+#include <list>
 #include <string>
 
 #include "LSODE.h"
 #include "lo-mappers.h"
 
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
+#include "interpreter-private.h"
 #include "ovl.h"
 #include "ov-fcn.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "parse.h"
 #include "pr-output.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 #include "LSODE-opts.cc"
 
 // Global pointer for user defined function required by lsode.
-static octave_function *lsode_fcn;
+static octave_value lsode_fcn;
 
 // Global pointer for optional user defined jacobian function used by lsode.
-static octave_function *lsode_jac;
+static octave_value lsode_jac;
 
 // Have we warned about imaginary values returned from user function?
 static bool warned_fcn_imaginary = false;
 static bool warned_jac_imaginary = false;
 
 // Is this a recursive call?
 static int call_depth = 0;
 
@@ -61,17 +63,17 @@ ColumnVector
 lsode_user_function (const ColumnVector& x, double t)
 {
   ColumnVector retval;
 
   octave_value_list args;
   args(1) = t;
   args(0) = x;
 
-  if (lsode_fcn)
+  if (lsode_fcn.is_defined ())
     {
       octave_value_list tmp;
 
       try
         {
           tmp = octave::feval (lsode_fcn, args, 1);
         }
       catch (octave::execution_exception& e)
@@ -101,17 +103,17 @@ Matrix
 lsode_user_jacobian (const ColumnVector& x, double t)
 {
   Matrix retval;
 
   octave_value_list args;
   args(1) = t;
   args(0) = x;
 
-  if (lsode_jac)
+  if (lsode_jac.is_defined ())
     {
       octave_value_list tmp;
 
       try
         {
           tmp = octave::feval (lsode_jac, args, 1);
         }
       catch (octave::execution_exception& e)
@@ -270,125 +272,85 @@ parameters for @code{lsode}.
   call_depth++;
 
   if (call_depth > 1)
     error ("lsode: invalid recursive call");
 
   octave::symbol_table& symtab = interp.get_symbol_table ();
 
   std::string fcn_name, fname, jac_name, jname;
-  lsode_fcn = nullptr;
-  lsode_jac = nullptr;
+
+  lsode_fcn = octave_value ();
+  lsode_jac = octave_value ();
 
   octave_value f_arg = args(0);
 
+  std::list<std::string> parameter_names ({"x", "t"});
+
   if (f_arg.iscell ())
     {
       Cell c = f_arg.cell_value ();
       if (c.numel () == 1)
         f_arg = c(0);
       else if (c.numel () == 2)
         {
-          if (c(0).is_function_handle () || c(0).is_inline_function ())
-            lsode_fcn = c(0).function_value ();
-          else
-            {
-              fcn_name = unique_symbol_name ("__lsode_fcn__");
-              fname = "function y = ";
-              fname.append (fcn_name);
-              fname.append (" (x, t) y = ");
-              lsode_fcn = extract_function (c(0), "lsode", fcn_name, fname,
-                                            "; endfunction");
-            }
+          lsode_fcn = octave::get_function_handle (interp, c(0),
+                                                   parameter_names);
 
-          if (lsode_fcn)
+          if (lsode_fcn.is_defined ())
             {
-              if (c(1).is_function_handle () || c(1).is_inline_function ())
-                lsode_jac = c(1).function_value ();
-              else
-                {
-                  jac_name = unique_symbol_name ("__lsode_jac__");
-                  jname = "function jac = ";
-                  jname.append (jac_name);
-                  jname.append (" (x, t) jac = ");
-                  lsode_jac = extract_function (c(1), "lsode", jac_name,
-                                                jname, "; endfunction");
+              lsode_jac = octave::get_function_handle (interp, c(1),
+                                                       parameter_names);
 
-                  if (! lsode_jac)
-                    {
-                      if (fcn_name.length ())
-                        symtab.clear_function (fcn_name);
-                      lsode_fcn = nullptr;
-                    }
-                }
+              if (lsode_jac.is_undefined ())
+                lsode_fcn = octave_value ();
             }
         }
       else
         error ("lsode: incorrect number of elements in cell array");
     }
 
-  if (! lsode_fcn && ! f_arg.iscell ())
+  if (lsode_fcn.is_undefined () && ! f_arg.iscell ())
     {
       if (f_arg.is_function_handle () || f_arg.is_inline_function ())
-        lsode_fcn = f_arg.function_value ();
+        lsode_fcn = f_arg;
       else
         {
           switch (f_arg.rows ())
             {
             case 1:
-              do
-                {
-                  fcn_name = unique_symbol_name ("__lsode_fcn__");
-                  fname = "function y = ";
-                  fname.append (fcn_name);
-                  fname.append (" (x, t) y = ");
-                  lsode_fcn = extract_function (f_arg, "lsode", fcn_name,
-                                                fname, "; endfunction");
-                }
-              while (0);
+              lsode_fcn = octave::get_function_handle (interp, f_arg,
+                                                       parameter_names);
               break;
 
             case 2:
               {
                 string_vector tmp = f_arg.string_vector_value ();
 
-                fcn_name = unique_symbol_name ("__lsode_fcn__");
-                fname = "function y = ";
-                fname.append (fcn_name);
-                fname.append (" (x, t) y = ");
-                lsode_fcn = extract_function (tmp(0), "lsode", fcn_name,
-                                              fname, "; endfunction");
+                lsode_fcn = octave::get_function_handle (interp, tmp(0),
+                                                         parameter_names);
 
-                if (lsode_fcn)
+                if (lsode_fcn.is_defined ())
                   {
-                    jac_name = unique_symbol_name ("__lsode_jac__");
-                    jname = "function jac = ";
-                    jname.append (jac_name);
-                    jname.append (" (x, t) jac = ");
-                    lsode_jac = extract_function (tmp(1), "lsode",
-                                                  jac_name, jname,
-                                                  "; endfunction");
+                    lsode_jac = octave::get_function_handle (interp, tmp(1),
+                                                             parameter_names);
 
-                    if (! lsode_jac)
-                      {
-                        if (fcn_name.length ())
-                          symtab.clear_function (fcn_name);
-                        lsode_fcn = nullptr;
-                      }
+                    if (lsode_jac.is_undefined ())
+                      lsode_fcn = octave_value ();
                   }
               }
               break;
 
             default:
               error ("lsode: first arg should be a string or 2-element string array");
             }
         }
     }
 
-  if (! lsode_fcn)
+  if (lsode_fcn.is_undefined ())
     error ("lsode: FCN argument is not a valid function name or handle");
 
   ColumnVector state = args(1).xvector_value ("lsode: initial state X_0 must be a vector");
   ColumnVector out_times = args(2).xvector_value ("lsode: output time variable T must be a vector");
 
   ColumnVector crit_times;
 
   int crit_times_set = 0;
@@ -397,17 +359,18 @@ parameters for @code{lsode}.
       crit_times = args(3).xvector_value ("lsode: list of critical times T_CRIT must be a vector");
 
       crit_times_set = 1;
     }
 
   double tzero = out_times (0);
 
   ODEFunc func (lsode_user_function);
-  if (lsode_jac)
+
+  if (lsode_jac.is_defined ())
     func.set_jacobian_function (lsode_user_jacobian);
 
   LSODE ode (state, tzero, func);
 
   ode.set_options (lsode_opts);
 
   Matrix output;
   if (crit_times_set)
diff --git a/libinterp/corefcn/quad.cc b/libinterp/corefcn/quad.cc
--- a/libinterp/corefcn/quad.cc
+++ b/libinterp/corefcn/quad.cc
@@ -27,44 +27,45 @@ along with Octave; see the file COPYING.
 #include <string>
 
 #include "Quad.h"
 #include "lo-mappers.h"
 
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
+#include "interpreter-private.h"
 #include "pager.h"
 #include "parse.h"
+#include "ov.h"
 #include "ovl.h"
-#include "ov-fcn.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 #include "Quad-opts.cc"
 
 // Global pointer for user defined function required by quadrature functions.
-static octave_function *quad_fcn;
+static octave_value quad_fcn;
 
 // Have we warned about imaginary values returned from user function?
 static bool warned_imaginary = false;
 
 // Is this a recursive call?
 static int call_depth = 0;
 
 double
 quad_user_function (double x)
 {
   double retval = 0.0;
 
   octave_value_list args;
   args(0) = x;
 
-  if (quad_fcn)
+  if (quad_fcn.is_defined ())
     {
       octave_value_list tmp;
 
       try
         {
           tmp = octave::feval (quad_fcn, args, 1);
         }
       catch (octave::execution_exception& e)
@@ -90,17 +91,17 @@ quad_user_function (double x)
 float
 quad_float_user_function (float x)
 {
   float retval = 0.0;
 
   octave_value_list args;
   args(0) = x;
 
-  if (quad_fcn)
+  if (quad_fcn.is_defined ())
     {
       octave_value_list tmp;
 
       try
         {
           tmp = octave::feval (quad_fcn, args, 1);
         }
       catch (octave::execution_exception& e)
@@ -179,34 +180,17 @@ variable by routines @code{dblquad} and 
   octave::unwind_protect frame;
 
   frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     error ("quad: invalid recursive call");
 
-  std::string fcn_name;
-
-  if (args(0).is_function_handle () || args(0).is_inline_function ())
-    quad_fcn = args(0).function_value ();
-  else
-    {
-      fcn_name = unique_symbol_name ("__quad_fcn__");
-      std::string fname = "function y = ";
-      fname.append (fcn_name);
-      fname.append ("(x) y = ");
-      quad_fcn = extract_function (args(0), "quad", fcn_name, fname,
-                                   "; endfunction");
-      octave::symbol_table& symtab = interp.get_symbol_table ();
-      frame.add_method (symtab, &octave::symbol_table::clear_function, fcn_name);
-    }
-
-  if (! quad_fcn)
-    error ("quad: FCN argument is not a valid function name or handle");
+  quad_fcn = octave::get_function_handle (interp, args(0), "x");
 
   octave_value_list retval;
 
   if (args(1).is_single_type () || args(2).is_single_type ())
     {
       float a = args(1).xfloat_value ("quad: lower limit of integration A must be a scalar");
       float b = args(2).xfloat_value ("quad: upper limit of integration B must be a scalar");
 
@@ -425,16 +409,43 @@ variable by routines @code{dblquad} and 
 
 %!test
 %!  [v, ier, nfun, err] = quad ("__f", 0.001, 3);
 %! assert (ier == 0 || ier == 1);
 %! assert (v, 1.98194120273598, sqrt (eps));
 %! assert (nfun > 0);
 
 %!test
+%!  [v, ier, nfun, err] = quad (@__f, 0.001, 3);
+%! assert (ier == 0 || ier == 1);
+%! assert (v, 1.98194120273598, sqrt (eps));
+%! assert (nfun > 0);
+
+%!test
+%!  fstr = "x .* sin (1 ./ x) .* sqrt (abs (1 - x))";
+%!  [v, ier, nfun, err] = quad (fstr, 0.001, 3);
+%! assert (ier == 0 || ier == 1);
+%! assert (v, 1.98194120273598, sqrt (eps));
+%! assert (nfun > 0);
+
+%!test
+%!  anon_fcn = @(x) x .* sin (1 ./ x) .* sqrt (abs (1 - x));
+%!  [v, ier, nfun, err] = quad (anon_fcn, 0.001, 3);
+%! assert (ier == 0 || ier == 1);
+%! assert (v, 1.98194120273598, sqrt (eps));
+%! assert (nfun > 0);
+
+%!test
+%!  inline_fcn = inline ("x .* sin (1 ./ x) .* sqrt (abs (1 - x))", "x");
+%!  [v, ier, nfun, err] = quad (inline_fcn, 0.001, 3);
+%! assert (ier == 0 || ier == 1);
+%! assert (v, 1.98194120273598, sqrt (eps));
+%! assert (nfun > 0);
+
+%!test
 %!  [v, ier, nfun, err] = quad ("__f", single (0.001), single (3));
 %! assert (ier == 0 || ier == 1);
 %! assert (v, 1.98194120273598, sqrt (eps ("single")));
 %! assert (nfun > 0);
 
 %!error quad ()
 %!error quad ("__f", 1, 2, 3, 4, 5)
 
diff --git a/libinterp/corefcn/quadcc.cc b/libinterp/corefcn/quadcc.cc
--- a/libinterp/corefcn/quadcc.cc
+++ b/libinterp/corefcn/quadcc.cc
@@ -28,16 +28,17 @@ along with Octave; see the file COPYING.
 
 #include <algorithm>
 
 #include "lo-ieee.h"
 #include "oct-locbuf.h"
 
 #include "defun.h"
 #include "error.h"
+#include "interpreter-private.h"
 #include "ovl.h"
 #include "parse.h"
 #include "utils.h"
 #include "variables.h"
 
 // Extended debugging.
 #define DEBUG_QUADCC 0
 
@@ -1478,18 +1479,18 @@ downdate (double *c, int n, int d, int *
         c[j] -= alpha * b_new[j];
       c[n] = 0;
       n--;
     }
 }
 
 // The actual integration routine.
 
-DEFUN (quadcc, args, ,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (quadcc, interp, args, ,
+           doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{q} =} quadcc (@var{f}, @var{a}, @var{b})
 @deftypefnx {} {@var{q} =} quadcc (@var{f}, @var{a}, @var{b}, @var{tol})
 @deftypefnx {} {@var{q} =} quadcc (@var{f}, @var{a}, @var{b}, @var{tol}, @var{sing})
 @deftypefnx {} {[@var{q}, @var{err}, @var{nr_points}] =} quadcc (@dots{})
 Numerically evaluate the integral of @var{f} from @var{a} to @var{b} using
 doubly-adaptive @nospell{Clenshaw-Curtis} quadrature.
 
 @var{f} is a function handle, inline function, or string containing the name
@@ -1570,17 +1571,17 @@ Mathematical Software, Vol. 37, Issue 3,
   static const int n[4] = { 4, 8, 16, 32 };
   static const int skip[4] = { 8, 4, 2, 1 };
   static const int idx[4] = { 0, 5, 14, 31 };
   static const double w = M_SQRT2 / 2;
   static const int ndiv_max = 20;
 
   // Arguments left and right.
   int nargin = args.length ();
-  octave_function *fcn;
+  octave_value fcn;
   double a, b, abstol, reltol, *sing;
   bool issingle;
 
   // Variables needed for transforming the integrand.
   bool wrap = false;
   double xw;
 
   // Stuff we will need to call the integrand.
@@ -1595,27 +1596,17 @@ Mathematical Software, Vol. 37, Issue 3,
   int nnans, nans[33];
   cquad_ival *iv, *ivl, *ivr;
   double nc, ncdiff;
 
   // Parse the input arguments.
   if (nargin < 3)
     print_usage ();
 
-  if (args(0).is_function_handle () || args(0).is_inline_function ())
-    fcn = args(0).function_value ();
-  else
-    {
-      std::string fcn_name = unique_symbol_name ("__quadcc_fcn__");
-      std::string fname = "function y = ";
-      fname.append (fcn_name);
-      fname.append ("(x) y = ");
-      fcn = extract_function (args(0), "quadcc", fcn_name, fname,
-                              "; endfunction");
-    }
+  fcn = octave::get_function_handle (interp, args(0), "x");
 
   if (! args(1).is_real_scalar ())
     error ("quadcc: lower limit of integration (A) must be a real scalar");
   a = args(1).double_value ();
   issingle = args(1).is_single_type ();
 
   if (! args(2).is_real_scalar ())
     error ("quadcc: upper limit of integration (B) must be a real scalar");
diff --git a/libinterp/corefcn/variables.h b/libinterp/corefcn/variables.h
--- a/libinterp/corefcn/variables.h
+++ b/libinterp/corefcn/variables.h
@@ -48,16 +48,17 @@ namespace octave
 extern OCTINTERP_API octave_function *
 is_valid_function (const octave_value&, const std::string& = "",
                    bool warn = false);
 
 extern OCTINTERP_API octave_function *
 is_valid_function (const std::string&, const std::string& = "",
                    bool warn = false);
 
+OCTAVE_DEPRECATED (6, "use 'octave::get_function_handle' instead")
 extern OCTINTERP_API octave_function *
 extract_function (const octave_value& arg, const std::string& warn_for,
                   const std::string& fname, const std::string& header,
                   const std::string& trailer);
 
 extern OCTINTERP_API int
 symbol_exist (const std::string& name, const std::string& type = "any");
 
diff --git a/libinterp/dldfcn/__eigs__.cc b/libinterp/dldfcn/__eigs__.cc
--- a/libinterp/dldfcn/__eigs__.cc
+++ b/libinterp/dldfcn/__eigs__.cc
@@ -29,42 +29,43 @@ along with Octave; see the file COPYING.
 
 #include "Matrix.h"
 #include "eigs-base.h"
 #include "unwind-prot.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "errwarn.h"
+#include "interpreter-private.h"
 #include "oct-map.h"
 #include "ov.h"
 #include "ovl.h"
 #include "pager.h"
 #include "parse.h"
 #include "variables.h"
 
 #if defined (HAVE_ARPACK)
 
 // Global pointer for user defined function.
-static octave_function *eigs_fcn = nullptr;
+static octave_value eigs_fcn;
 
 // Have we warned about imaginary values returned from user function?
 static bool warned_imaginary = false;
 
 // Is this a recursive call?
 static int call_depth = 0;
 
 ColumnVector
 eigs_func (const ColumnVector& x, int& eigs_error)
 {
   ColumnVector retval;
   octave_value_list args;
   args(0) = x;
 
-  if (eigs_fcn)
+  if (eigs_fcn.is_defined ())
     {
       octave_value_list tmp;
 
       try
         {
           tmp = octave::feval (eigs_fcn, args, 1);
         }
       catch (octave::execution_exception& e)
@@ -94,17 +95,17 @@ eigs_func (const ColumnVector& x, int& e
 
 ComplexColumnVector
 eigs_complex_func (const ComplexColumnVector& x, int& eigs_error)
 {
   ComplexColumnVector retval;
   octave_value_list args;
   args(0) = x;
 
-  if (eigs_fcn)
+  if (eigs_fcn.is_defined ())
     {
       octave_value_list tmp;
 
       try
         {
           tmp = octave::feval (eigs_fcn, args, 1);
         }
       catch (octave::execution_exception& e)
@@ -201,30 +202,19 @@ Undocumented internal function.
   call_depth++;
 
   if (call_depth > 1)
     error ("eigs: invalid recursive call");
 
   if (args(0).is_function_handle () || args(0).is_inline_function ()
       || args(0).is_string ())
     {
-      if (args(0).is_string ())
-        {
-          std::string name = args(0).string_value ();
-          std::string fname = "function y = ";
-          fcn_name = unique_symbol_name ("__eigs_fcn__");
-          fname.append (fcn_name);
-          fname.append ("(x) y = ");
-          eigs_fcn = extract_function (args(0), "eigs", fcn_name, fname,
-                                       "; endfunction");
-        }
-      else
-        eigs_fcn = args(0).function_value ();
+      eigs_fcn = octave::get_function_handle (interp, args(0), "x");
 
-      if (! eigs_fcn)
+      if (eigs_fcn.is_undefined ())
         error ("eigs: unknown function");
 
       if (nargin < 2)
         error ("eigs: incorrect number of arguments");
 
       n = args(1).nint_value ();
       arg_offset = 1;
       have_a_fun = true;
