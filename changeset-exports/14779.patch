# HG changeset patch
# User Jacob Dawid <jacob.dawid@googlemail.com>
# Date 1340027490 -7200
#      Mon Jun 18 15:51:30 2012 +0200
# Branch gui
# Node ID 8e9f2cfa114d97b7f45df17c514f39a6d09b3f48
# Parent  f43916137064a96de072f1bc80a5c876ff436f34
# Parent  1230d5d58d2d1796be72d127f306449e4488b913
maint: periodic merge from default to gui

diff --git a/.hgsubstate b/.hgsubstate
--- a/.hgsubstate
+++ b/.hgsubstate
@@ -1,2 +1,2 @@
-f9813bce2c06a6130a68db4478d1b16ddadaf276 gnulib
+33f823397dbb0edb57503f2f6dad2362456bc6a9 gnulib
 9d13275430aae701805095845a857e3f528c7aad gui/qterminal
diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -65,23 +65,29 @@ Summary of important user-visible change
     Octave:array-as-vector => Octave:array-to-vector
 
  ** The colormap function now provides new options--"list", "register",
     and "unregister"--to list all available colormap functions, and to
     add or remove a function name from the list of known colormap
     functions.  Packages that implement extra colormaps should use these
     commands with PKG_ADD and PKG_DEL statements.
 
+ ** The datevec function has been extended for better Matlab compatibility.
+    It now accepts string inputs in the following numerical formats: 12, 21,
+    22, 26, 29, 31.  This is undocumented, but verifiable, Matlab behavior.
+    In addition, the default for formats which do not specify a date is
+    January 1st of the current year.  The previous default was the current day,
+    month, and year.  This may produce changes in existing scripts.
+
  ** Other new functions added in 3.8.0:
 
-      colorcube   splinefit
-      lines       tetramesh
-      rgbplot     shrinkfaces
-      findfigs
-
+      colorcube   lines         splinefit
+      erfcinv     rgbplot       tetramesh
+      findfigs    shrinkfaces
+      
  ** Deprecated functions.
 
     The following functions were deprecated in Octave 3.4 and have been
     removed from Octave 3.8.
                                            
       autocor    dispatch              is_global    strerror
       autocov    fstat                 krylovb      values  
       betai      gammai                perror               
diff --git a/build-aux/bootstrap.conf b/build-aux/bootstrap.conf
--- a/build-aux/bootstrap.conf
+++ b/build-aux/bootstrap.conf
@@ -35,34 +35,32 @@ gnulib_modules="
   gethostname
   getopt-gnu
   gettimeofday
   glob
   isatty
   link
   lstat
   mkdir
-  mkdir-p
   mkfifo
   mkostemp
   mkstemp
   mktime
   nanosleep
   nproc
   opendir
   pathmax
   progname
   readdir
   readlink
   rename
   rewinddir
   rmdir
   round
   roundf
-  savewd
   sigaction
   signal
   sigprocmask
   sleep
   sleep
   stat
   stdint
   stdio
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -645,19 +645,22 @@ AC_SUBST(FC)
 OCTAVE_F77_FLAG(-ffloat-store, [
 AC_MSG_RESULT([setting F77_FLOAT_STORE_FLAG to -ffloat-store])
 F77_FLOAT_STORE_FLAG=-ffloat-store
 AC_SUBST(F77_FLOAT_STORE_FLAG)
 ])
 
 OCTAVE_IEEE754_DATA_FORMAT
 
+OCTAVE_CXX_BITWISE_OP_TEMPLATES
 OCTAVE_CXX_COMPLEX_SETTERS
 OCTAVE_CXX_COMPLEX_REFERENCE_ACCESSORS
 
+OCTAVE_CARBON_CGDISPLAYBITSPERPIXEL
+
 ### Check for the QHull library
 
 OCTAVE_CHECK_LIBRARY(qhull, QHull,
   [Qhull library not found -- this will result in loss of functionality of some geometry functions.],
   [libqhull/libqhull.h qhull/libqhull.h libqhull.h qhull/qhull.h qhull.h], [qh_qhull], [], [],
   [warn_qhull=
    OCTAVE_CHECK_QHULL_VERSION
    OCTAVE_CHECK_QHULL_OK([TEXINFO_QHULL="@set HAVE_QHULL"
diff --git a/doc/interpreter/arith.txi b/doc/interpreter/arith.txi
--- a/doc/interpreter/arith.txi
+++ b/doc/interpreter/arith.txi
@@ -266,16 +266,18 @@ cos (pi/2)
 @DOCSTRING(erf)
 
 @DOCSTRING(erfc)
 
 @DOCSTRING(erfcx)
 
 @DOCSTRING(erfinv)
 
+@DOCSTRING(erfcinv)
+
 @DOCSTRING(gamma)
 
 @DOCSTRING(gammainc)
 
 @DOCSTRING(legendre)
 
 @anchor{doc-gammaln}
 @DOCSTRING(lgamma)
diff --git a/doc/interpreter/container.txi b/doc/interpreter/container.txi
--- a/doc/interpreter/container.txi
+++ b/doc/interpreter/container.txi
@@ -685,24 +685,24 @@ is possible to convert numerical arrays 
 As shown in @pxref{Basic Usage of Cell Arrays} elements can be
 extracted from cell arrays using the @samp{@{} and @samp{@}}
 operators.  If you want to extract or access subarrays which are still 
 cell arrays, you need to use the @samp{(} and @samp{)} operators.  The
 following example illustrates the difference:
 
 @example
 @group
-c = @{"1", "2", "3"; "a", "b", "c"; "4", "5", "6"@};
+c = @{"1", "2", "3"; "x", "y", "z"; "4", "5", "6"@};
 c@{2,3@}
-     @result{} ans = c
+     @result{} ans = z
 
 c(2,3)
      @result{} ans = 
         @{
-          [1,1] = c
+          [1,1] = z
         @}
 @end group
 @end example
 
 @noindent So with @samp{@{@}} you access elements of a cell
 array, while with @samp{()} you access a sub array of a cell
 array.
 
diff --git a/doc/interpreter/contributors.in b/doc/interpreter/contributors.in
--- a/doc/interpreter/contributors.in
+++ b/doc/interpreter/contributors.in
@@ -97,16 +97,17 @@ Ryan Hinton
 Roman Hodek
 A. Scottedward Hodel
 Richard Allan Holcombe
 Tom Holroyd
 David Hoover
 Kurt Hornik
 Christopher Hulbert
 Cyril Humbert
+John Hunt
 Teemu Ikonen
 Alan W. Irwin
 Geoff Jacobsen
 Mats Jansson
 Cai Jianming
 Steven G. Johnson
 Heikki Junes
 Matthias Jüschke
@@ -152,16 +153,17 @@ Massimo Lorenzin
 Emil Lucretiu
 Hoxide Ma
 James Macnicol
 Jens-Uwe Mager
 Colin Macdonald
 Rob Mahurin
 Ricardo Marranita
 Orestes Mas
+Axel Mathéi
 Makoto Matsumoto
 Tatsuro Matsuoka
 Laurent Mazet
 G. D. McBain
 Alexander Mamonov
 Christoph Mayer
 Júlio Hoffimann Mendes
 Thorsten Meyer
@@ -212,16 +214,17 @@ Joshua Redstone
 Lukas Reichlin
 Michael Reifenberger
 Anthony Richardson
 Jason Riedy
 E. Joshua Rigler
 Petter Risholm
 Matthew W. Roberts
 Andrew Ross
+Fabio Rossi
 Mark van Rossum
 Joe Rothweiler
 Kevin Ruland
 Kristian Rumberg
 Ryan Rusaw
 Olli Saarela
 Toni Saarela
 Juhani Saastamoinen
diff --git a/doc/interpreter/munge-texi.pl b/doc/interpreter/munge-texi.pl
--- a/doc/interpreter/munge-texi.pl
+++ b/doc/interpreter/munge-texi.pl
@@ -11,114 +11,114 @@ die "usage: munge-texi TOP-SRCDIR DOCSTR
 $comment_line = qr/^\s*(?:$|#)/;
 # Pre-declare hash size for efficiency
 keys(%help_text) = 1800;
 
 ################################################################################
 # Load DOCSTRINGS into memory while expanding @seealso references
 foreach $DOCSTRING_file (@ARGV)
 {
-   open (DOCFH, $DOCSTRING_file) or die "Unable to open $DOCSTRING_file\n";
+  open (DOCFH, $DOCSTRING_file) or die "Unable to open $DOCSTRING_file\n";
 
-   # Skip comments
-   while (defined ($_ = <DOCFH>) and /$comment_line/o) {;}
+  # Skip comments
+  while (defined ($_ = <DOCFH>) and /$comment_line/o) {;}
 
-   # Validate DOCSTRING file format
-   die "invalid doc file format\n" if (! /$doc_delim/o);
-   
-   do 
-   {
-     chomp;
-     $symbol = substr ($_,1);
-     $docstring = extract_docstring ();
-     if ($help_text{$symbol})
-     {
-        warn "ignoring duplicate entry for $symbol\n";
-     }
-     else
-     {
-       $help_text{$symbol} = $docstring;
-     }
+  # Validate DOCSTRING file format
+  die "invalid doc file format\n" if (! /$doc_delim/o);
+  
+  do 
+  {
+    chomp;
+    $symbol = substr ($_,1);
+    $docstring = extract_docstring ();
+    if ($help_text{$symbol})
+    {
+      warn "ignoring duplicate entry for $symbol\n";
+    }
+    else
+    {
+      $help_text{$symbol} = $docstring;
+    }
 
-   } while (! eof);
+  } while (! eof);
 
 }
 
 ################################################################################
 # Process .txi to .texi by expanding @DOCSTRING, @EXAMPLEFILE macros
 
 # Add warning header
 print '@c DO NOT EDIT!  Generated automatically by munge-texi.',"\n\n";
 
 TXI_LINE: while (<STDIN>)
 {
-   if (/^\s*\@DOCSTRING\((\S+)\)/)
-   {
-      $func = $1;
-      $docstring = $help_text{$func};
-      if (! $docstring)
-      {
-        warn "no docstring entry for $func\n";
-        next TXI_LINE;
-      }
-
-      $func =~ s/^@/@@/;   # Texinfo uses @@ to produce '@'
-      $docstring =~ s/^$tex_delim$/\@anchor{doc-$func}/m;
-      print $docstring,"\n";
-
+  if (/^\s*\@DOCSTRING\((\S+)\)/)
+  {
+    $func = $1;
+    $docstring = $help_text{$func};
+    if (! $docstring)
+    {
+      warn "no docstring entry for $func\n";
       next TXI_LINE;
-   }
-   if (/^\s*\@EXAMPLEFILE\((\S+)\)/)
-   {
-      $fname = "$top_srcdir/examples/$1";
-      print '@verbatim',"\n";
-      open (EXAMPFH, $fname) or die "unable to open example file $fname\n";
-      while (<EXAMPFH>) 
-      { 
-         print $_;
-         print "\n" if (eof and substr ($_, -1) ne "\n");
-      }
-      close (EXAMPFH);
-      print '@end verbatim',"\n\n";
+    }
+
+    $func =~ s/^@/@@/;   # Texinfo uses @@ to produce '@'
+    $docstring =~ s/^$tex_delim$/\@anchor{doc-$func}/m;
+    print $docstring,"\n";
 
-      next TXI_LINE;
-   }
+    next TXI_LINE;
+  }
+  if (/^\s*\@EXAMPLEFILE\((\S+)\)/)
+  {
+    $fname = "$top_srcdir/examples/$1";
+    print '@verbatim',"\n";
+    open (EXAMPFH, $fname) or die "unable to open example file $fname\n";
+    while (<EXAMPFH>) 
+    { 
+      print $_;
+      print "\n" if (eof and substr ($_, -1) ne "\n");
+    }
+    close (EXAMPFH);
+    print '@end verbatim',"\n\n";
 
-   # pass ordinary lines straight through to output
-   print $_;
+    next TXI_LINE;
+  }
+
+  # pass ordinary lines straight through to output
+  print $_;
 }
 
 
 ################################################################################
 # Subroutines 
 ################################################################################
 sub extract_docstring
 {
-   my ($docstring, $arg_list, $func_list, $repl, $rest_of_line);
-   
-   while (defined ($_ = <DOCFH>) and ! /$doc_delim/o)
-   {
-      # expand any @seealso references
-      if (m'^@seealso{')
-      {
-         # Join multiple lines until full macro body found
-         while (! /}/m) { $_ .= <DOCFH>; }
+  my ($docstring, $arg_list, $func_list, $repl, $rest_of_line);
+  
+  while (defined ($_ = <DOCFH>) and ! /$doc_delim/o)
+  {
+    # expand any @seealso references
+    if (m'^@seealso{')
+    {
+      # Join multiple lines until full macro body found
+      while (! /}/m) { $_ .= <DOCFH>; }
 
-         ($arg_list, $rest_of_line) = m'^@seealso{(.*)}(.*)?'s;
-        
-         $func_list = $arg_list;
-         $func_list =~ s/\s+//gs;
-         $repl = "";
-         foreach $func (split (/,/, $func_list))
-         {
-            $func =~ s/^@/@@/;   # Texinfo uses @@ to produce '@'
-            $repl .= "\@ref{doc-$func,,$func}, ";
-         }
-         substr($repl,-2) = "";   # Remove last ', ' 
-         $_ = "\@seealso{$repl}$rest_of_line";
+      ($arg_list, $rest_of_line) = m'^@seealso{(.*)}(.*)?'s;
+     
+      $func_list = $arg_list;
+      $func_list =~ s/\s+//gs;
+      $repl = "";
+      foreach $func (split (/,/, $func_list))
+      {
+        $func =~ s/^@/@@/;   # Texinfo uses @@ to produce '@'
+        $repl .= "\@ref{doc-$func,,$func}, ";
       }
+      substr($repl,-2) = "";   # Remove last ', ' 
+      $_ = "\@seealso{$repl}$rest_of_line";
+    }
 
-      $docstring .= $_;
-   }
+    $docstring .= $_;
+  }
 
-   return $docstring;
+  return $docstring;
 }
 
diff --git a/libcruft/misc/lo-error.c b/libcruft/misc/lo-error.c
--- a/libcruft/misc/lo-error.c
+++ b/libcruft/misc/lo-error.c
@@ -105,18 +105,18 @@ liboctave_fatal (const char *fmt, ...)
   va_end (args);
 
   exit (1);
 }
 
 void
 liboctave_fatal_with_id (const char *id, const char *fmt, ...)
 {
+  va_list args;
   (void) id; /*unused*/
-  va_list args;
   va_start (args, fmt);
   verror ("fatal", fmt, args);
   va_end (args);
 
   exit (1);
 }
 
 void
@@ -126,14 +126,14 @@ liboctave_warning (const char *fmt, ...)
   va_start (args, fmt);
   verror ("warning", fmt, args);
   va_end (args);
 }
 
 void
 liboctave_warning_with_id (const char *id, const char *fmt, ...)
 {
+  va_list args;
   (void) id; /*unused*/
-  va_list args;
   va_start (args, fmt);
   verror ("warning", fmt, args);
   va_end (args);
 }
diff --git a/libcruft/slatec-fn/derf.f b/libcruft/slatec-fn/derf.f
--- a/libcruft/slatec-fn/derf.f
+++ b/libcruft/slatec-fn/derf.f
@@ -64,17 +64,17 @@ C***FIRST EXECUTABLE STATEMENT  DERF
       ENDIF
       FIRST = .FALSE.
 C
       Y = ABS(X)
       IF (Y.GT.1.D0) GO TO 20
 C
 C ERF(X) = 1.0 - ERFC(X)  FOR  -1.0 .LE. X .LE. 1.0
 C
-      IF (Y.LE.SQEPS) DERF = 2.0D0*X*X/SQRTPI
+      IF (Y.LE.SQEPS) DERF = 2.0D0*X/SQRTPI
       IF (Y.GT.SQEPS) DERF = X*(1.0D0 + DCSEVL (2.D0*X*X-1.D0,
      1  ERFCS, NTERF))
       RETURN
 C
 C ERF(X) = 1.0 - ERFC(X) FOR ABS(X) .GT. 1.0
 C
  20   IF (Y.LE.XBIG) DERF = SIGN (1.0D0-DERFC(Y), X)
       IF (Y.GT.XBIG) DERF = SIGN (1.0D0, X)
diff --git a/liboctave/eigs-base.cc b/liboctave/eigs-base.cc
--- a/liboctave/eigs-base.cc
+++ b/liboctave/eigs-base.cc
@@ -3828,49 +3828,49 @@ EigsComplexNonSymmetricFunc (EigsComplex
                              octave_idx_type &info, ComplexMatrix &eig_vec,
                              ComplexColumnVector &eig_val,
                              ComplexColumnVector &resid, std::ostream& os,
                              double tol = DBL_EPSILON, bool rvec = false,
                              bool cholB = 0, int disp = 0, int maxit = 300);
 #endif
 
 #ifndef _MSC_VER
-template static octave_idx_type
+template octave_idx_type
 lusolve (const SparseMatrix&, const SparseMatrix&, Matrix&);
 
-template static octave_idx_type
+template octave_idx_type
 lusolve (const SparseComplexMatrix&, const SparseComplexMatrix&,
          ComplexMatrix&);
 
-template static octave_idx_type
+template octave_idx_type
 lusolve (const Matrix&, const Matrix&, Matrix&);
 
-template static octave_idx_type
+template octave_idx_type
 lusolve (const ComplexMatrix&, const ComplexMatrix&, ComplexMatrix&);
 
-template static ComplexMatrix
+template ComplexMatrix
 ltsolve (const SparseComplexMatrix&, const ColumnVector&,
          const ComplexMatrix&);
 
-template static Matrix
+template Matrix
 ltsolve (const SparseMatrix&, const ColumnVector&, const Matrix&);
 
-template static ComplexMatrix
+template ComplexMatrix
 ltsolve (const ComplexMatrix&, const ColumnVector&, const ComplexMatrix&);
 
-template static Matrix
+template Matrix
 ltsolve (const Matrix&, const ColumnVector&, const Matrix&);
 
-template static ComplexMatrix
+template ComplexMatrix
 utsolve (const SparseComplexMatrix&, const ColumnVector&,
          const ComplexMatrix&);
 
-template static Matrix
+template Matrix
 utsolve (const SparseMatrix&, const ColumnVector&, const Matrix&);
 
-template static ComplexMatrix
+template ComplexMatrix
 utsolve (const ComplexMatrix&, const ColumnVector&, const ComplexMatrix&);
 
-template static Matrix
+template Matrix
 utsolve (const Matrix&, const ColumnVector&, const Matrix&);
 #endif
 
 #endif
diff --git a/liboctave/file-ops.cc b/liboctave/file-ops.cc
--- a/liboctave/file-ops.cc
+++ b/liboctave/file-ops.cc
@@ -43,17 +43,16 @@ along with Octave; see the file COPYING.
 #include "file-stat.h"
 #include "oct-env.h"
 #include "oct-locbuf.h"
 #include "oct-passwd.h"
 #include "pathlen.h"
 #include "quit.h"
 #include "singleton-cleanup.h"
 #include "str-vec.h"
-#include "lo-cutils.h"
 
 file_ops *file_ops::instance = 0;
 
 bool
 file_ops::instance_ok (void)
 {
   bool retval = true;
 
@@ -357,42 +356,32 @@ file_ops::concat (const std::string& dir
 {
   return dir.empty ()
     ? file
     : (is_dir_sep (dir[dir.length()-1])
        ? dir + file
        : dir + dir_sep_char () + file);
 }
 
-static int 
-make_ancestor (const char *, const char *component, void *options)
-{
-  mode_t* mode = reinterpret_cast<mode_t *>(options);
-  return gnulib::mkdir (component, *mode);
-}
 
 int
 octave_mkdir (const std::string& nm, mode_t md)
 {
   std::string msg;
-  return octave_mkdir (nm, md, msg, false);
+  return octave_mkdir (nm, md, msg);
 }
 
 int
-octave_mkdir (const std::string& name, mode_t mode, std::string& msg, 
-              bool make_parents)
+octave_mkdir (const std::string& name, mode_t mode, std::string& msg)
 {
   msg = std::string ();
 
   int status = -1;
 
-  if (make_parents)
-    status = octave_mkdir_parents (name.c_str (), mode, make_ancestor);
-  else
-    status = gnulib::mkdir (name.c_str (), mode);
+  status = gnulib::mkdir (name.c_str (), mode);
 
   if (status < 0)
     msg = gnulib::strerror (errno);
 
   return status;
 }
 
 int
diff --git a/liboctave/file-ops.h b/liboctave/file-ops.h
--- a/liboctave/file-ops.h
+++ b/liboctave/file-ops.h
@@ -117,18 +117,17 @@ private:
 // We don't have these in the file_ops class with their simple names
 // (i.e., mkdir instead of octave_mdir) because function names in
 // standard headers may be #defined.
 
 extern OCTAVE_API int
 octave_mkdir (const std::string& nm, mode_t md);
 
 extern OCTAVE_API int
-octave_mkdir (const std::string& nm, mode_t md, std::string& msg,
-              bool make_parents = false);
+octave_mkdir (const std::string& nm, mode_t md, std::string& msg);
 
 extern OCTAVE_API int
 octave_mkfifo (const std::string& nm, mode_t md);
 
 extern OCTAVE_API int
 octave_mkfifo (const std::string& nm, mode_t md, std::string& msg);
 
 extern OCTAVE_API int
diff --git a/liboctave/lo-cutils.c b/liboctave/lo-cutils.c
--- a/liboctave/lo-cutils.c
+++ b/liboctave/lo-cutils.c
@@ -27,29 +27,25 @@ along with Octave; see the file COPYING.
 /* This gives us a better chance of finding a prototype for strptime
    on some systems.  */
 
 #if ! defined (_XOPEN_SOURCE)
 #define _XOPEN_SOURCE
 #endif
 
 #include <sys/types.h>
-#include <sys/stat.h>
 #include <unistd.h>
 
 #include <stdlib.h>
 #include <string.h>
 #include <time.h>
 
 #include "lo-cutils.h"
 #include "syswait.h"
 
-#include "savewd.h"
-#include "mkdir-p.h"
-
 OCTAVE_API void
 octave_qsort (void *base, size_t n, size_t size,
               int (*cmp) (const void *, const void *))
 {
   qsort (base, n, size, cmp);
 }
 
 OCTAVE_API int
@@ -75,51 +71,8 @@ octave_w32_library_search (HINSTANCE han
 }
 #endif
 
 OCTAVE_API pid_t
 octave_waitpid (pid_t pid, int *status, int options)
 {
   return WAITPID (pid, status, options);
 }
-
-struct mkdir_options
-{
-  int (*make_ancestor_function) (const char *, const char *, void *);
-  mode_t ancestor_mode;
-  mode_t mode;
-  mode_t mode_bits;
-};
-
-static void
-announce_mkdir (const char *dir, void *options)
-{
-  /* Do nothing */
-}
-
-static int
-process_dir (char *dir, struct savewd *wd, void *options)
-{
-  struct mkdir_options const *o = options;
-  mode_t ancestor_mode = o->ancestor_mode;
-  return (make_dir_parents (dir, wd, o->make_ancestor_function, &ancestor_mode,
-                            o->mode, announce_mkdir, o->mode_bits, 
-                            (uid_t) -1, (gid_t) -1, false) ? 0 : -1);
-}
-
-OCTAVE_API int
-octave_mkdir_parents (const char *dir, mode_t mode,
-                      int (*make_ancestor) (const char *, const char *, void *))
-{
-  char *argv[1];
-  int retval;
-  char *dir2 = malloc (strlen (dir) + 1);
-  strcpy (dir2, dir); /* Make a copy to avoid passing a const char* as char* */
-  argv[0] = dir2;
-  struct mkdir_options o;
-  o.make_ancestor_function = make_ancestor;
-  o.ancestor_mode = mode | S_IWUSR | S_IXUSR; 
-  o.mode = mode | umask(0);
-  o.mode_bits = ~(mode & umask(0));
-  retval = (savewd_process_files (1, argv, process_dir, &o));
-  free (dir2);
-  return retval;
-}
diff --git a/liboctave/lo-cutils.h b/liboctave/lo-cutils.h
--- a/liboctave/lo-cutils.h
+++ b/liboctave/lo-cutils.h
@@ -45,17 +45,13 @@ octave_strncasecmp (const char *s1, cons
 #ifdef HAVE_LOADLIBRARY_API
 OCTAVE_API void *
 octave_w32_library_search (HINSTANCE handle, const char *name);
 #endif
 
 OCTAVE_API pid_t
 octave_waitpid (pid_t pid, int *status, int options);
 
-OCTAVE_API int
-octave_mkdir_parents (const char *dir, mode_t mode,
-                      int (*make_ancestor) (char const *, char const *, void *));
-
 #ifdef __cplusplus
 }
 #endif
 
 #endif
diff --git a/liboctave/lo-specfun.cc b/liboctave/lo-specfun.cc
--- a/liboctave/lo-specfun.cc
+++ b/liboctave/lo-specfun.cc
@@ -3216,16 +3216,86 @@ double erfinv (double x)
   return do_erfinv (x, true);
 }
 
 float erfinv (float x)
 {
   return do_erfinv (x, false);
 }
 
+static double do_erfcinv (double x, bool refine)
+{
+  // Coefficients of rational approximation.
+  static const double a[] =
+    { -2.806989788730439e+01,  1.562324844726888e+02,
+      -1.951109208597547e+02,  9.783370457507161e+01,
+      -2.168328665628878e+01,  1.772453852905383e+00 };
+  static const double b[] =
+    { -5.447609879822406e+01,  1.615858368580409e+02,
+      -1.556989798598866e+02,  6.680131188771972e+01,
+      -1.328068155288572e+01 };
+  static const double c[] =
+    { -5.504751339936943e-03, -2.279687217114118e-01,
+      -1.697592457770869e+00, -1.802933168781950e+00,
+       3.093354679843505e+00,  2.077595676404383e+00 };
+  static const double d[] =
+    {  7.784695709041462e-03,  3.224671290700398e-01,
+       2.445134137142996e+00,  3.754408661907416e+00 };
+
+  static const double spi2 = 8.862269254527579e-01; // sqrt(pi)/2.
+  static const double pi = 3.14159265358979323846;
+  static const double pbreak = 0.95150;
+  double y;
+
+  // Select case.
+  if (x <= 1+pbreak && x >= 1-pbreak)
+    {
+      // Middle region.
+      const double q = 0.5*(1-x), r = q*q;
+      const double yn = (((((a[0]*r + a[1])*r + a[2])*r + a[3])*r + a[4])*r + a[5])*q;
+      const double yd = ((((b[0]*r + b[1])*r + b[2])*r + b[3])*r + b[4])*r + 1.0;
+      y = yn / yd;
+    }
+  else if (x < 2.0 && x > 0.0)
+    {
+      // Tail region.
+      const double q = x < 1 ? sqrt (-2*log (0.5*x)) : sqrt (-2*log (0.5*(2-x)));
+      const double yn = ((((c[0]*q + c[1])*q + c[2])*q + c[3])*q + c[4])*q + c[5];
+      const double yd = (((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1.0;
+      y = yn / yd;
+      if (x < 1-pbreak)
+        y *= -1;
+    }
+  else if (x == 0.0)
+    return octave_Inf;
+  else if (x == 2.0)
+    return -octave_Inf;
+  else
+    return octave_NaN;
+
+  if (refine)
+    {
+      // One iteration of Halley's method gives full precision.
+      double u = (erf (y) - (1-x)) * spi2 * exp (y*y);
+      y -= u / (1 + y*u);
+    }
+
+  return y;
+}
+
+double erfcinv (double x)
+{
+  return do_erfcinv (x, true);
+}
+
+float erfcinv (float x)
+{
+  return do_erfcinv (x, false);
+}
+
 // Implementation based on the Fortran code by W.J.Cody
 // see http://www.netlib.org/specfun/erf.
 // Templatized and simplified workflow.
 
 // FIXME: Maybe this should be globally visible.
 static inline float erfc (float x) { return erfcf (x); }
 
 template <class T>
diff --git a/liboctave/lo-specfun.h b/liboctave/lo-specfun.h
--- a/liboctave/lo-specfun.h
+++ b/liboctave/lo-specfun.h
@@ -588,12 +588,15 @@ inline float gammainc (float x, float a)
 }
 
 extern OCTAVE_API Complex rc_log1p (double);
 extern OCTAVE_API FloatComplex rc_log1p (float);
 
 extern OCTAVE_API double erfinv (double x);
 extern OCTAVE_API float erfinv (float x);
 
+extern OCTAVE_API double erfcinv (double x);
+extern OCTAVE_API float erfcinv (float x);
+
 extern OCTAVE_API double erfcx (double x);
 extern OCTAVE_API float erfcx (float x);
 
 #endif
diff --git a/m4/acinclude.m4 b/m4/acinclude.m4
--- a/m4/acinclude.m4
+++ b/m4/acinclude.m4
@@ -100,16 +100,37 @@ AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]],
 [[void test(char *); int length(); char x[length()]; test(x);]])],
 octave_cv_dynamic_auto_arrays=yes, octave_cv_dynamic_auto_arrays=no)])
 if test $octave_cv_dynamic_auto_arrays = yes; then
 AC_DEFINE(HAVE_DYNAMIC_AUTO_ARRAYS,1,[Define if C++ supports dynamic auto arrays])
 fi
 AC_LANG_POP(C++)
 ])
 dnl
+dnl See if the C++ library has the bit_and, bit_or and bit_xor
+dnl templates defined.
+dnl
+AC_DEFUN([OCTAVE_CXX_BITWISE_OP_TEMPLATES],
+[AC_CACHE_CHECK([whether bit_and, bit_or and bit_xor are defined in the c++ library],
+octave_cv_cxx_bitwise_op_templates,
+[AC_LANG_PUSH(C++)
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <functional>]],
+[[int x = 0;
+int y = 1;
+int z1 = std::bit_and<int>() (x, y);
+int z2 = std::bit_or<int>() (x, y);
+int z3 = std::bit_xor<int>() (x, y);]])],
+octave_cv_cxx_bitwise_op_templates=yes, octave_cv_cxx_bitwise_op_templates=no)])
+if test $octave_cv_cxx_bitwise_op_templates = yes; then
+AC_DEFINE(HAVE_CXX_BITWISE_OP_TEMPLATES,1,[Define if C++ library has templated bitwise operators])
+fi
+AC_LANG_POP(C++)
+])
+
+dnl
 dnl See if the C++ library has functions to set real and imaginary
 dnl parts of complex numbers independently.
 dnl
 AC_DEFUN([OCTAVE_CXX_COMPLEX_SETTERS],
 [AC_CACHE_CHECK([whether complex class can set components independently],
 octave_cv_cxx_complex_setters,
 [AC_LANG_PUSH(C++)
 AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <complex>]],
@@ -132,16 +153,35 @@ AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#in
 [[std::complex<double> x; x.real () = 1.0; x.imag () = 1.0;]])],
 octave_cv_cxx_complex_reference_accessors=yes, octave_cv_cxx_complex_reference_accessors=no)])
 if test $octave_cv_cxx_complex_reference_accessors = yes; then
 AC_DEFINE(HAVE_CXX_COMPLEX_REFERENCE_ACCESSORS,1,[Define if C++ complex class has T& real (void) and T& imag (void) methods])
 fi
 AC_LANG_POP(C++)
 ])
 dnl
+dnl See if the Carbon Framework defines CGDisplayBitsPerPixel.
+dnl
+AC_DEFUN([OCTAVE_CARBON_CGDISPLAYBITSPERPIXEL],
+[AC_CACHE_CHECK([whether CGDisplayBitsPerPixel is defined in the Carbon Framework],
+octave_cv_carbon_cgdisplaybitsperpixel,
+[AC_LANG_PUSH(C++)
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#include <Carbon/Carbon.h>
+]], [[
+CGDirectDisplayID display = CGMainDisplayID ();
+size_t depth = CGDisplayBitsPerPixel (display);
+]])],
+octave_cv_carbon_cgdisplaybitsperpixel=yes, octave_cv_carbon_cgdisplaybitsperpixel=no)])
+if test $octave_cv_carbon_cgdisplaybitsperpixel = yes; then
+AC_DEFINE(HAVE_CARBON_CGDISPLAYBITSPERPIXEL,1,[Define if Carbon Framework has CGDisplayBitsPerPixel])
+fi
+AC_LANG_POP(C++)
+])
+dnl
 dnl The following test is from Karl Berry's Kpathseach library.  I'm
 dnl including it here in case we someday want to make the use of
 dnl kpathsea optional.
 dnl
 dnl Some BSD putenv's, e.g., FreeBSD, do malloc/free's on the environment.
 dnl This test program is due to Mike Hibler <mike@cs.utah.edu>.
 dnl We don't actually need to run this if we don't have putenv, but it
 dnl doesn't hurt.
diff --git a/scripts/help/get_first_help_sentence.m b/scripts/help/get_first_help_sentence.m
--- a/scripts/help/get_first_help_sentence.m
+++ b/scripts/help/get_first_help_sentence.m
@@ -45,17 +45,17 @@ function [text, status] = get_first_help
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (!ischar (name))
     error ("get_first_help_sentence: NAME must be a string");
   endif
 
-  if (!isnumeric (max_len) || max_len <= 0 || max_len != fix (max_len))
+  if (! isnumeric (max_len) || max_len <= 0 || max_len != fix (max_len))
     error ("get_first_help_sentence: MAX_LEN must be positive integer");
   endif
 
   ## First, we get the raw help text
   [help_text, format] = get_help_text (name);
 
   ## Then, we take action depending on the format
   switch (lower (format))
@@ -75,70 +75,73 @@ function [text, status] = get_first_help
 
   if (nargout <= 1 && status != 0)
     warning ("get_first_help_sentence: couldn't run makeinfo on '%s'", name);
   endif
 endfunction
 
 ## This function extracts the first sentence from a plain text help text
 function [text, status] = first_sentence_plain_text (help_text, max_len)
-  ## Extract first line by searching for a period or a double line-end.
-  period_idx = find (help_text == '.', 1);
-  line_end_idx = strfind (help_text, "\n\n");
-  text = help_text (1:min ([period_idx(:); line_end_idx(:); max_len; length(help_text)]));
+  ## Extract first line by searching for a period followed by a space class
+  ## character (to support periods in numbers or words) ...
+  period_idx = regexp (help_text, '\.\s', "once");
+  ## ... or a double end-of-line (we subtract 1 because we are not interested
+  ## in capturing the first newline).
+  line_end_idx = regexp (help_text, "\n\n", "once") - 1;
+  text = help_text (1:min ([period_idx; line_end_idx; max_len; length(help_text)]));
   status = 0;
 endfunction
 
 ## This function extracts the first sentence from a Texinfo help text.
 ## The function works by removing @def* from the texinfo text. After this, we
 ## render the text to plain text using makeinfo, and then extract the first line.
 function [text, status] = first_sentence_texinfo (help_text, max_len)
-  ## Lines ending with "@\n" are continuation lines, so they should be concatenated
-  ## with the following line.
+  ## Lines ending with "@\n" are continuation lines, so they should be
+  ## concatenated with the following line.
   help_text = strrep (help_text, "@\n", " ");
 
   ## Find, and remove, lines that start with @def. This should remove things
   ## such as @deftypefn, @deftypefnx, @defvar, etc.
   keep = true (size (help_text));
   def_idx = strfind (help_text, "@def");
-  if (!isempty (def_idx))
+  if (! isempty (def_idx))
     endl_idx = find (help_text == "\n");
     for k = 1:length (def_idx)
-      endl = endl_idx (find (endl_idx > def_idx (k), 1));
+      endl = endl_idx (find (endl_idx > def_idx(k), 1));
       if (isempty (endl))
-        keep (def_idx (k):end) = false;
+        keep (def_idx(k) : end) = false;
       else
-        keep (def_idx (k):endl) = false;
+        keep (def_idx(k) : endl) = false;
       endif
     endfor
 
     ## Remove the @end ... that corresponds to the @def we removed above
-    def1 = def_idx (1);
+    def1 = def_idx(1);
     space_idx = find (help_text == " ");
     space_idx = space_idx (find (space_idx > def1, 1));
     bracket_idx = find (help_text == "{" | help_text == "}");
     bracket_idx = bracket_idx (find (bracket_idx > def1, 1));
     if (isempty (space_idx) && isempty (bracket_idx))
       error ("get_first_help_sentence: couldn't parse texinfo");
     endif
     sep_idx = min (space_idx, bracket_idx);
-    def_type = help_text (def1+1:sep_idx-1);
+    def_type = help_text(def1+1:sep_idx-1);
 
     end_idx = strfind (help_text, sprintf ("@end %s", def_type));
     if (isempty (end_idx))
       error ("get_first_help_sentence: couldn't parse texinfo");
     endif
-    endl = endl_idx (find (endl_idx > end_idx, 1));
+    endl = endl_idx(find (endl_idx > end_idx, 1));
     if (isempty (endl))
-      keep (end_idx:end) = false;
+      keep(end_idx:end) = false;
     else
-      keep (end_idx:endl) = false;
+      keep(end_idx:endl) = false;
     endif
 
-    help_text = help_text (keep);
+    help_text = help_text(keep);
   endif
 
   ## Run makeinfo to generate plain text
   [help_text, status] = __makeinfo__ (help_text, "plain text");
 
   ## Extract first line with plain text method.
   text = first_sentence_plain_text (help_text, max_len);
 endfunction
@@ -154,13 +157,13 @@ function [text, status] = first_sentence
 endfunction
 
 
 %!assert (get_first_help_sentence ('get_first_help_sentence'), "Return the first sentence of a function's help text.")
 
 %% Test input validation
 %!error get_first_help_sentence ()
 %!error get_first_help_sentence (1, 2, 3)
-%!error get_first_help_sentence (1)
-%!error get_first_help_sentence ('ls', 'a')
-%!error get_first_help_sentence ('ls', 0)
-%!error get_first_help_sentence ('ls', 80.1)
+%!error <NAME must be a string> get_first_help_sentence (1)
+%!error <MAX_LEN must be positive integer> get_first_help_sentence ("ls", "a")
+%!error <MAX_LEN must be positive integer> get_first_help_sentence ("ls", 0)
+%!error <MAX_LEN must be positive integer> get_first_help_sentence ("ls", 80.1)
 
diff --git a/scripts/help/unimplemented.m b/scripts/help/unimplemented.m
--- a/scripts/help/unimplemented.m
+++ b/scripts/help/unimplemented.m
@@ -164,17 +164,16 @@ function list = missing_functions ()
   "dither",
   "docopt",
   "docsearch",
   "dragrect",
   "dynamicprops",
   "echodemo",
   "ellipj",
   "ellipke",
-  "erfcinv",
   "errordlg",
   "evalc",
   "exifread",
   "expint",
   "export2wsdlg",
   "figurepalette",
   "filebrowser",
   "fill3",
diff --git a/scripts/mkdoc.pl b/scripts/mkdoc.pl
--- a/scripts/mkdoc.pl
+++ b/scripts/mkdoc.pl
@@ -39,21 +39,20 @@ MFILE: foreach $m_fname (@ARGV)
   if ($m_fname eq "--")
   {
     $srcdir = "./";
     next MFILE;
   }
 
   $full_fname = $srcdir . $m_fname;
   next MFILE unless ( $full_fname =~ m{(.*)/(@|)([^/]*)/(.*)\.m} );
-  if ($2) {
-    $fcn = "$2$3/$4";
-  } else {
-    $fcn = $4;
-  }
+  if ($2)
+    { $fcn = "$2$3/$4"; }
+  else
+    { $fcn = $4; }
 
   @help_txt = gethelp ($fcn, $full_fname);
   next MFILE if ($help_txt[0] eq "");
 
   print "$fcn\n";
   print "\@c $fcn scripts/$m_fname\n";
 
   foreach $_ (@help_txt)
diff --git a/scripts/plot/colorbar.m b/scripts/plot/colorbar.m
--- a/scripts/plot/colorbar.m
+++ b/scripts/plot/colorbar.m
@@ -157,17 +157,17 @@ function h = colorbar (varargin)
       endif
     endif
 
     ctext = text (0, 0, "", "tag", "colorbar","visible", "off",
                   "handlevisibility", "off", "xliminclude", "off",
                   "yliminclude", "off", "zliminclude", "off",
                   "deletefcn", {@deletecolorbar, cax, obj});
 
-    set (cax, "deletefcn", {@resetaxis, obj});
+    set (cax, "deletefcn", {@resetaxis, ax, obj});
 
     addlistener (ax, "clim", {@update_colorbar_clim, hi, vertical});
     addlistener (ax, "plotboxaspectratio", {@update_colorbar_axis, cax, obj});
     addlistener (ax, "plotboxaspectratiomode", {@update_colorbar_axis, cax, obj});
     addlistener (ax, "dataaspectratio", {@update_colorbar_axis, cax, obj});
     addlistener (ax, "dataaspectratiomode", {@update_colorbar_axis, cax, obj});
     addlistener (ax, "position", {@update_colorbar_axis, cax, obj});
 
@@ -190,23 +190,25 @@ function deletecolorbar (h, d, hc, orig_
         && strcmp (get (ancestor (h, "axes"), "beingdeleted"), "off"))
       set (ancestor (h, "axes"), "position", orig_props.position, ...
                             "outerposition", orig_props.outerposition, ...
                     "activepositionproperty", orig_props.activepositionproperty);
     endif
   endif
 endfunction
 
-function resetaxis (h, d, orig_props)
-  if (ishandle (h) && strcmp (get (h, "type"), "axes")
-      && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off"))
-      && ishandle (get (h, "axes")))
-     set (get (h, "axes"), "position", orig_props.position, ...
-                           "outerposition", orig_props.outerposition, ...
-                   "activepositionproperty", orig_props.activepositionproperty);
+function resetaxis (cax, d, ax, orig_props)
+  if (ishandle (ax) && strcmp (get (ax, "type"), "axes"))
+    dellistener (ax, "position")
+    units = get (ax, "units");
+    set (ax, "units", orig_props.units)
+    set (ax, "position", orig_props.position, ...
+             "outerposition", orig_props.outerposition, ...
+             "activepositionproperty", orig_props.activepositionproperty);
+    set (ax, "units", units)
   endif
 endfunction
 
 function update_colorbar_clim (h, d, hi, vert)
   if (ishandle (h) && strcmp (get (h, "type"), "image")
       && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")))
     clen = rows (get (get (h, "parent"), "colormap"));
     cext = get (h, "clim");
diff --git a/scripts/plot/graphics_toolkit.m b/scripts/plot/graphics_toolkit.m
--- a/scripts/plot/graphics_toolkit.m
+++ b/scripts/plot/graphics_toolkit.m
@@ -13,41 +13,48 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{name} =} graphics_toolkit ()
-## @deftypefnx {Function File} {@var{old_name} =} graphics_toolkit (@var{name})
+## Returns the default graphics toolkit. The default graphics toolkit value
+## is assigned to new figures.
+## @deftypefnx {Function File} {@var{name} =} graphics_toolkit (@var{hlist})
+## Returns the graphics toolkits for the figures with handles @var{hlist}.
+## @deftypefnx {Function File} {} graphics_toolkit (@var{name})
+## Sets the default graphics toolkit to @var{name}.  If the toolkit is not
+## already loaded, it is initialized by calling the function
+## @code{__init_@var{name}__}.
 ## @deftypefnx {Function File} {} graphics_toolkit (@var{hlist}, @var{name})
-## Query or set the default graphics toolkit to @var{name}.  If the
-## toolkit is not already loaded, it is first initialized by calling the
-## function @code{__init_@var{name}__}.
-##
-## When called with a list of figure handles, @var{hlist}, the graphics
-## toolkit is changed only for the listed figures.
+## Sets the graphics toolkit for the figues with handles @var{hlist} to
+## @var{name}.
 ## @seealso{available_graphics_toolkits}
 ## @end deftypefn
 
 function retval = graphics_toolkit (name, hlist = [])
 
   if (nargin > 2)
     print_usage ();
   endif
 
   if (nargout > 0 || nargin == 0)
     retval = get (0, "defaultfigure__graphics_toolkit__");
   endif
 
   if (nargin == 0)
     return;
   elseif (nargin == 1)
-    if (! ischar (name))
+    if (all (isfigure (name)))
+      hlist = name;
+      retval = get (hlist, "__graphics_toolkit__");
+      return
+    elseif (! ischar (name))
       error ("graphics_toolkit: invalid graphics toolkit NAME");
     endif
   elseif (nargin == 2)
     ## Swap input arguments
     [hlist, name] = deal (name, hlist);
     if (! all (isfigure (hlist)))
       error ("graphics_toolkit: invalid figure handle list HLIST");
     elseif (! ischar (name))
@@ -72,17 +79,17 @@ endfunction
 
 
 %!testif HAVE_FLTK
 %! unwind_protect
 %!   hf = figure ("visible", "off"); 
 %!   toolkit = graphics_toolkit ();
 %!   assert (get (0, "defaultfigure__graphics_toolkit__"), toolkit);
 %!   graphics_toolkit (hf, "fltk"); 
-%!   assert (get (hf, "__graphics_toolkit__"), "fltk");
+%!   assert (graphics_toolkit (hf), "fltk");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!testif HAVE_FLTK
 %! old_toolkit = graphics_toolkit ();
 %! switch old_toolkit
 %!   case {"gnuplot"}
diff --git a/scripts/plot/legend.m b/scripts/plot/legend.m
--- a/scripts/plot/legend.m
+++ b/scripts/plot/legend.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} legend (@var{str1}, @var{str2}, @dots{})
 ## @deftypefnx {Function File} {} legend (@var{matstr})
-## @deftypefnx {Function File} {} legend (@var{cell})
+## @deftypefnx {Function File} {} legend (@var{cellstr})
 ## @deftypefnx {Function File} {} legend (@dots{}, "location", @var{pos})
 ## @deftypefnx {Function File} {} legend (@dots{}, "orientation", @var{orient})
 ## @deftypefnx {Function File} {} legend (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {} legend (@var{hobjs}, @dots{})
 ## @deftypefnx {Function File} {} legend (@var{hax}, @var{hobjs}, @dots{})
 ## @deftypefnx {Function File} {} legend ("@var{option}")
 ##
 ## Display a legend for the axes with handle @var{hax}, or the current axes,
@@ -505,36 +505,39 @@ function [hlegend2, hobjects2, hplot2, t
         if (isempty (hlegend))
           addprops = true;
           hlegend = axes ("tag", "legend", "userdata", struct ("handle", ud),
                           "box", box,
                           "xtick", [], "ytick", [],
                           "xticklabel", "", "yticklabel", "", "zticklabel", "",
                           "xlim", [0, 1], "ylim", [0, 1],
                           "visible", ifelse (strcmp (box, "on"), "on", "off"),
-                          "activepositionproperty", "position");
+                          "activepositionproperty", "position",
+                          "fontsize", ca_fontsize);
         else
           addprops = false;
           axes (hlegend);
           delete (get (hlegend, "children"));
         endif
         ## Add text label to the axis first, checking their extents
         nentries = numel (hplots);
         texthandle = [];
         maxwidth = 0;
         maxheight = 0;
         for k = 1 : nentries
           if (strcmp (textpos, "right"))
             texthandle = [texthandle, text(0, 0, text_strings {k},
                                            "horizontalalignment", "left",
-                                           "userdata", hplots(k))];
+                                           "userdata", hplots(k),
+                                           "fontsize", ca_fontsize)];
           else
             texthandle = [texthandle, text(0, 0, text_strings {k},
                                            "horizontalalignment", "right",
-                                           "userdata", hplots(k))];
+                                           "userdata", hplots(k),
+                                           "fontsize", ca_fontsize)];
           endif
           units = get (texthandle (end), "units");
           unwind_protect
             set (texthandle (end), "units", "points");
             extents = get (texthandle (end), "extent");
             maxwidth = max (maxwidth, extents (3));
             maxheight = max (maxheight, extents (4));
           unwind_protect_cleanup
@@ -707,16 +710,28 @@ function [hlegend2, hobjects2, hplot2, t
             addlistener(hplots(k), "color", {@updateline, hlegend, linelength});
             addlistener(hplots(k), "linestyle", {@updateline, hlegend, linelength});
             addlistener(hplots(k), "marker", {@updateline, hlegend, linelength});
             addlistener(hplots(k), "markeredgecolor", {@updateline, hlegend, linelength});
             addlistener(hplots(k), "markerfacecolor", {@updateline, hlegend, linelength});
             addlistener(hplots(k), "markersize", {@updateline, hlegend, linelength});
             addlistener(hplots(k), "displayname", {@updateline, hlegend, linelength});
           case "patch"
+            facecolor = get (hplots(k), "facecolor");
+            edgecolor = get (hplots(k), "edgecolor");
+            cdata = get (hplots(k), "cdata");
+            if (! strcmp (facecolor, "none") || ! strcmp (edgecolor, "none"))
+              p1 = patch ("xdata", ([0, linelength, linelength, 0] +
+                                   xoffset + xk * xstep) / lpos(3),
+                         "ydata", (lpos(4) - yoffset -
+                                   [yk-0.3, yk-0.3, yk+0.3, yk+0.3] .* ystep) / lpos(4),
+                         "facecolor", facecolor, "edgecolor", edgecolor, "cdata", cdata,
+                         "userdata", hplots (k));
+              hobjects = [hobjects, p1];
+            endif
           case "surface"
           endswitch
           set (texthandle (k), "position", [(txoffset + xk * xstep) / lpos(3), ...
                                             (lpos(4) - yoffset - yk * ystep) / lpos(4)]);
           if (strcmp (orientation, "vertical"))
             yk++;
             if (yk > num1)
               yk = 0;
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -69,18 +69,28 @@
 ## @item -portrait
 ## @itemx -landscape
 ##   Specify the orientation of the plot for printed output.  For
 ## non-printed output the aspect ratio of the output corresponds to
 ## the plot area defined by the "paperposition" property in the
 ## orientation specified.  This options is equivalent to changing
 ## the figure's "paperorientation" property.
 ##
+## @item -TextAlphaBits=@var{n}
+## @itemx -GraphicsAlphaBits=@var{n}
+##   Octave is able to produce output for various printers, bitmaps, and
+## vector formats by using ghostscript.
+## For bitmap and printer output antialiasing is applied using
+## ghostscript's TextAlphaBits and GraphicsAlphaBits options.
+## The default number of bits for each is 4.
+## Allowed values, for @var{N}, are 1, 2, or 4.
+##
 ## @item -d@var{device}
-##   Output device, where @var{device} is one of:
+##   The available output format is specified by the option @var{device},
+##   and is one of:
 ##
 ##   @table @code
 ##   @item ps
 ##   @itemx ps2
 ##   @itemx psc
 ##   @itemx psc2
 ##     Postscript (level 1 and 2, mono and color).  The FLTK graphics
 ##     toolkit generates Postscript level 3.0.
diff --git a/scripts/plot/private/__ghostscript__.m b/scripts/plot/private/__ghostscript__.m
--- a/scripts/plot/private/__ghostscript__.m
+++ b/scripts/plot/private/__ghostscript__.m
@@ -27,16 +27,18 @@
 function [gs_cmd, cleanup_cmd] = __ghostscript__ (varargin);
 
   opts.binary = "";
   opts.source = "-";
   opts.output = "-";
   opts.device = "";
   opts.epscrop = false;
   opts.antialiasing  = false;
+  opts.antialiasing_textalphabits = 4;,
+  opts.antialiasing_graphicsalphabits = 4;
   opts.resolution = 150;
   opts.papersize = "";
   opts.pageoffset = [0 0];
   opts.debug = false;
   opts.level = [];
   opts.prepend = "";
 
   offsetfile = "";
@@ -65,17 +67,19 @@ function [gs_cmd, cleanup_cmd] = __ghost
   gs_opts = sprintf ("-dQUIET -dNOPAUSE -dBATCH -dSAFER -sDEVICE=%s", opts.device);
 
   if (! isempty (opts.level) && ismember (opts.level, [1, 2, 3]))
     gs_opts = sprintf ("%s -dLanguageLevel=%d", gs_opts, round (opts.level));
   endif
 
   if (opts.antialiasing && isempty (strfind (opts.device, "write")))
     ## Apply anti-aliasing to all bitmap formats/devices
-    gs_opts = sprintf ("%s -dTextAlphaBits=4 -dGraphicsAlphaBits=4", gs_opts);
+    gs_opts = sprintf ("%s -dTextAlphaBits=%d -dGraphicsAlphaBits=%d",
+                       gs_opts, opts.antialiasing_textalphabits,
+                       opts.antialiasing_graphicsalphabits);
     gs_opts = sprintf ("%s -r%dx%d", gs_opts, [1, 1] * opts.resolution);
   elseif (any (strcmp (opts.device, {"pswrite", "ps2write", "pdfwrite"})))
     gs_opts = sprintf ("%s -dEmbedAllFonts=true", gs_opts);
     if (strcmp (opts.device, "pdfwrite"))
       ## Optimize for loading
       gs_opts = sprintf ("%s -dOptimize=true", gs_opts);
     endif
   endif
@@ -130,17 +134,17 @@ function [gs_cmd, cleanup_cmd] = __ghost
     endif
   endif
 
   if (isempty (opts.binary))
     error ("print:no_ghostscript", "__ghostscript__.m: ghostscript is required.");
   elseif (isempty (opts.output))
     cmd = sprintf ("%s %s", opts.binary, gs_opts);
   else
-    cmd = sprintf ("%s %s -sOutputFile=%s", opts.binary, gs_opts, opts.output);
+    cmd = sprintf ("%s %s -sOutputFile=\"%s\"", opts.binary, gs_opts, opts.output);
   endif
   if (! isempty (opts.prepend)
       && any (strcmpi (opts.device, {"pswrite", "ps2write", "pdfwrite"})))
     ## FIXME - Fonts get may be mangled when appending ps/ps2.
     ##         See "How to concatenate several PS files" at the link,
     ##         http://en.wikibooks.org/wiki/PostScript_FAQ
     cmd = sprintf ("%s %s", cmd, opts.prepend);
     if (isempty (cleanup_cmd))
diff --git a/scripts/plot/private/__print_parse_opts__.m b/scripts/plot/private/__print_parse_opts__.m
--- a/scripts/plot/private/__print_parse_opts__.m
+++ b/scripts/plot/private/__print_parse_opts__.m
@@ -44,16 +44,18 @@ function arg_st = __print_parse_opts__ (
   arg_st.ghostscript.device = "";
   arg_st.ghostscript.epscrop = true;
   arg_st.ghostscript.level = [];
   arg_st.ghostscript.output = "";
   arg_st.ghostscript.papersize = "";
   arg_st.ghostscript.pageoffset = [];
   arg_st.ghostscript.resolution = 150;
   arg_st.ghostscript.antialiasing = false;
+  arg_st.ghostscript.antialiasing_textalphabits = 4;
+  arg_st.ghostscript.antialiasing_graphicsalphabits = 4;
   arg_st.loose = false;
   arg_st.lpr_binary = __quote_path__ (__find_binary__ ("lpr"));
   arg_st.name = "";
   arg_st.orientation = "";
   arg_st.pstoedit_binary = __quote_path__ (__find_binary__ ("pstoedit"));
   arg_st.preview = "";
   arg_st.printer = "";
   arg_st.send_to_printer = false;
@@ -113,16 +115,30 @@ function arg_st = __print_parse_opts__ (
       elseif (length (arg) > 2 && arg(1:2) == "-P")
         arg_st.printer = arg;
       elseif (strncmp (arg, "-EPSTOOL:", 9))
         arg_st.epstool_binary = arg{10:end};
       elseif (strncmp (arg, "-FIG2DEV:", 9))
         arg_st.fig2dev_binary = arg{10:end};
       elseif (strncmp (arg, "-PSTOEDIT:", 9))
         arg_st.pstoedit_binary = arg{10:end};
+      elseif (strncmpi (arg, "-textalphabits=", 15))
+        n = find (arg == "=");
+        if (! isempty (n) && n == numel (arg) - 1 && ismember (arg(end), "124"))
+          arg_st.ghostscript.antialiasing_textalphabits = str2num (arg(end));
+        else
+          error ("print: improper syntax, or value, for TextAlphaBits")
+        endif
+      elseif (strncmpi (arg, "-graphicsalphabits=", 19))
+        n = find (arg == "=");
+        if (! isempty (n) && n == numel (arg) - 1 && ismember (arg(end), "124"))
+          arg_st.ghostscript.antialiasing_graphicsalphabits = str2num (arg(end));
+        else
+          error ("print: improper syntax, or value, for GraphicsAlphaBits")
+        endif
       elseif ((length (arg) > 2) && arg(1:2) == "-G")
         arg_st.ghostscript.binary = file_in_path (getenv ("PATH"), arg(3:end));
         if (isempty (arg_st.ghostscript.binary))
           error ("print: Ghostscript binary ""%s"" could not be located",
                  arg(3:end));
         else
           arg_st.ghostscript_binary = __quote_path__ (arg_st.ghostscript_binary);
         endif
diff --git a/scripts/sparse/gmres.m b/scripts/sparse/gmres.m
--- a/scripts/sparse/gmres.m
+++ b/scripts/sparse/gmres.m
@@ -27,17 +27,17 @@
 ## @item @var{rtol} is the relative tolerance,
 ## if not given or set to [] the default value 1e-6 is used.
 ##
 ## @item @var{maxit} is the maximum number of outer iterations,
 ## if not given or set to [] the default value
 ## @code{min (10, numel (b) / restart)} is used.
 ##
 ## @item @var{x0} is the initial guess,
-## if not given or set to [] the default value @code{zeros(size (b))} is used.
+## if not given or set to [] the default value @code{zeros (size (b))} is used.
 ##
 ## @item @var{m} is the restart parameter,
 ## if not given or set to [] the default value @code{numel (b)} is used.
 ## @end itemize
 ##
 ## Argument @var{A} can be passed as a matrix, function handle, or
 ## inline function @code{f} such that @code{f(x) = A*x}.
 ##
@@ -52,32 +52,32 @@
 ##
 ## @table @asis
 ## @item 0 : iteration converged to within the specified tolerance
 ##
 ## @item 1 : maximum number of iterations exceeded
 ##
 ## @item 2 : unused, but skipped for compatibility
 ##
-## @item 3 : algorithm reached stagnation
+## @item 3 : algorithm reached stagnation (no change between iterations)
 ## @end table
 ##
 ## @item @var{relres} is the final value of the relative residual.
 ##
 ## @item @var{iter} is a vector containing the number of outer iterations and
 ## total iterations performed.
 ##
 ## @item @var{resvec} is a vector containing the relative residual at each
 ## iteration.
 ## @end itemize
 ##
 ## @seealso{bicg, bicgstab, cgs, pcg}
 ## @end deftypefn
 
-function [x, flag, presn, it, resids] = gmres (A, b, restart, rtol, maxit, M1, M2, x0)
+function [x, flag, relres, it, resvec] = gmres (A, b, restart, rtol, maxit, M1, M2, x0)
 
   if (nargin < 2 || nargin > 8)
     print_usage ();
   endif
 
   if (ischar (A))
     Ax = str2func (A);
   elseif (ismatrix (A))
@@ -137,20 +137,20 @@ function [x, flag, presn, it, resids] = 
 
   B = zeros (restart + 1, 1);
   V = zeros (rows (x), restart);
   H = zeros (restart + 1, restart);
 
   ## begin loop
   iter = 1;
   restart_it  = restart + 1;
-  resids      = zeros (maxit, 1);
-  resids(1)   = presn;
+  resvec      = zeros (maxit, 1);
+  resvec(1)   = presn;
   prec_b_norm = norm (Pm1x (b), 2);
-  flag        = 1;
+  flag        = 1;  # Default flag is maximum # of iterations exceeded
 
   while (iter <= maxit * restart && presn > rtol * prec_b_norm)
 
     ## restart
     if (restart_it > restart)
       restart_it = 1;
       x_old = x;
       prec_res = Pm1x (b - Ax (x_old));
@@ -169,52 +169,69 @@ function [x, flag, presn, it, resids] = 
 
     little_res = B(1:restart_it+1) - ...
         H(1:restart_it+1, 1:restart_it) * Y(1:restart_it);
 
     presn = norm (little_res, 2);
 
     x = x_old + V(:, 1:restart_it) * Y(1:restart_it);
 
-    resids(iter) = presn;
+    resvec(iter) = presn;
     if (norm (x - x_old, inf) <= eps)
-      flag = 3;
-      break
+      flag = 3;  # Stagnation: no change between iterations
+      break;
     endif
 
     restart_it++ ;
     iter++;
   endwhile
 
-  if (presn > rtol * prec_b_norm)
-    flag = 0;
+  if (nargout > 1)
+    ## Calculate extra outputs as requested
+    relres = presn / prec_b_norm;
+    if (relres <= rtol)
+      flag = 0;  # Converged to solution within tolerance
+    endif
+
+    resvec = resvec(1:iter-1);
+    it = [ceil(iter / restart), rem(iter, restart)];
   endif
 
-  resids = resids(1:iter-1);
-  it = [ceil(iter / restart), rem(iter, restart)];
-
 endfunction
 
 
+%!demo
+%! dim = 20;
+%! A = spdiags ([-ones(dim,1) 2*ones(dim,1) ones(dim,1)], [-1:1], dim, dim);
+%! b = ones (dim, 1);
+%! [x, flag, relres, iter, resvec] = gmres (A, b, 10, 1e-10, dim, @(x) x ./ diag (A), [], b)
+
 %!shared A, b, dim
 %! dim = 100;
 %!test
 %! A = spdiags ([-ones(dim,1) 2*ones(dim,1) ones(dim,1)], [-1:1], dim, dim);
 %! b = ones (dim, 1);
 %! x = gmres (A, b, 10, 1e-10, dim, @(x) x ./ diag (A), [], b);
 %! assert (x, A\b, 1e-9*norm (x, Inf));
 %!
 %!test
 %! x = gmres (A, b, dim, 1e-10, 1e4, @(x) diag (diag (A)) \ x, [], b);
 %! assert(x, A\b, 1e-7*norm (x, Inf));
 %!
 %!test
 %! A = spdiags ([[1./(2:2:2*(dim-1)) 0]; 1./(1:2:2*dim-1); [0 1./(2:2:2*(dim-1))]]', -1:1, dim, dim);
 %! A = A'*A;
 %! b = rand (dim, 1);
-%! [x, resids] = gmres (@(x) A*x, b, dim, 1e-10, dim, @(x) x./diag (A), [], []);
+%! [x, resvec] = gmres (@(x) A*x, b, dim, 1e-10, dim, @(x) x./diag (A), [], []);
 %! assert (x, A\b, 1e-9*norm (x, Inf));
 %! x = gmres (@(x) A*x, b, dim, 1e-10, 1e6, @(x) diag (diag (A)) \ x, [], []);
 %! assert (x, A\b, 1e-9*norm (x, Inf));
 %!test
 %! x = gmres (@(x) A*x, b, dim, 1e-10, 1e6, @(x) x./diag(A), [], []);
 %! assert (x, A\b, 1e-7*norm (x, Inf));
 
+
+%!error gmres (1)
+%!error gmres (1,2,3,4,5,6,7,8,9)
+%!error <A must be> gmres ({1},2)
+%!error <A must be a function or matrix> gmres ({1},2)
+%!error <M1 must be a function or matrix> gmres (1,2,3,4,5,{6})
+%!error <M2 must be a function or matrix> gmres (1,2,3,4,5,6,{7})
diff --git a/scripts/statistics/base/prctile.m b/scripts/statistics/base/prctile.m
--- a/scripts/statistics/base/prctile.m
+++ b/scripts/statistics/base/prctile.m
@@ -54,17 +54,17 @@ function q = prctile (x, p = [], dim)
     p = [0, 25, 50, 75, 100];
   endif
 
   if (! (isnumeric (p) && isvector (p)))
     error ("prctile: P must be a numeric vector");
   endif
 
   nd = ndims (x);
-  if (nargin == 2)
+  if (nargin < 3)
     if (nd == 2)
       ## If a matrix or vector, always use 1st dimension.
       dim = 1;
     else
       ## If an N-d array, find the first non-singleton dimension.
       (dim = find (sz > 1, 1)) || (dim = 1);
     endif
   else
diff --git a/scripts/statistics/base/quantile.m b/scripts/statistics/base/quantile.m
--- a/scripts/statistics/base/quantile.m
+++ b/scripts/statistics/base/quantile.m
@@ -12,27 +12,30 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{q} =} quantile (@var{x}, @var{p})
+## @deftypefn  {Function File} {@var{q} =} quantile (@var{x})
+## @deftypefnx {Function File} {@var{q} =} quantile (@var{x}, @var{p})
 ## @deftypefnx {Function File} {@var{q} =} quantile (@var{x}, @var{p}, @var{dim})
 ## @deftypefnx {Function File} {@var{q} =} quantile (@var{x}, @var{p}, @var{dim}, @var{method})
 ## For a sample, @var{x}, calculate the quantiles, @var{q}, corresponding to
 ## the cumulative probability values in @var{p}.  All non-numeric values (NaNs)
 ## of @var{x} are ignored.
 ##
 ## If @var{x} is a matrix, compute the quantiles for each column and
 ## return them in a matrix, such that the i-th row of @var{q} contains
 ## the @var{p}(i)th quantiles of each column of @var{x}.
 ##
+## If @var{p} is unspecified, return the quantiles for
+## @code{[0.00 0.25 0.50 0.75 1.00]}.
 ## The optional argument @var{dim} determines the dimension along which
 ## the quantiles are calculated.  If @var{dim} is omitted, and @var{x} is
 ## a vector or matrix, it defaults to 1 (column-wise quantiles).  If
 ## @var{x} is an N-D array, @var{dim} defaults to the first non-singleton
 ## dimension.
 ##
 ## The methods available to calculate sample quantiles are the nine methods
 ## used by R (http://www.r-project.org/).  The default value is METHOD = 5.
diff --git a/scripts/statistics/distributions/logncdf.m b/scripts/statistics/distributions/logncdf.m
--- a/scripts/statistics/distributions/logncdf.m
+++ b/scripts/statistics/distributions/logncdf.m
@@ -69,25 +69,25 @@ function cdf = logncdf (x, mu = 0, sigma
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 1 e Inf];
 %! y = [0, 0, 0.5, 1/2+1/2*erf(1/2), 1];
-%!assert (logncdf (x, zeros (1,5), sqrt(2)*ones (1,5)), y)
-%!assert (logncdf (x, 0, sqrt(2)*ones (1,5)), y)
-%!assert (logncdf (x, zeros (1,5), sqrt(2)), y)
-%!assert (logncdf (x, [0 1 NaN 0 1], sqrt(2)), [0 0 NaN y(4:5)])
-%!assert (logncdf (x, 0, sqrt(2)*[0 NaN Inf 1 1]), [NaN NaN NaN y(4:5)])
-%!assert (logncdf ([x(1:3) NaN x(5)], 0, sqrt(2)), [y(1:3) NaN y(5)])
+%!assert (logncdf (x, zeros (1,5), sqrt(2)*ones (1,5)), y, eps)
+%!assert (logncdf (x, 0, sqrt(2)*ones (1,5)), y, eps)
+%!assert (logncdf (x, zeros (1,5), sqrt(2)), y, eps)
+%!assert (logncdf (x, [0 1 NaN 0 1], sqrt(2)), [0 0 NaN y(4:5)], eps)
+%!assert (logncdf (x, 0, sqrt(2)*[0 NaN Inf 1 1]), [NaN NaN NaN y(4:5)], eps)
+%!assert (logncdf ([x(1:3) NaN x(5)], 0, sqrt(2)), [y(1:3) NaN y(5)], eps)
 
 %% Test class of input preserved
-%!assert (logncdf ([x, NaN], 0, sqrt(2)), [y, NaN])
+%!assert (logncdf ([x, NaN], 0, sqrt(2)), [y, NaN], eps)
 %!assert (logncdf (single ([x, NaN]), 0, sqrt(2)), single ([y, NaN]), eps ("single"))
 %!assert (logncdf ([x, NaN], single (0), sqrt(2)), single ([y, NaN]), eps ("single"))
 %!assert (logncdf ([x, NaN], 0, single (sqrt(2))), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error logncdf ()
 %!error logncdf (1,2)
 %!error logncdf (1,2,3,4)
diff --git a/scripts/statistics/distributions/stdnormal_inv.m b/scripts/statistics/distributions/stdnormal_inv.m
--- a/scripts/statistics/distributions/stdnormal_inv.m
+++ b/scripts/statistics/distributions/stdnormal_inv.m
@@ -32,17 +32,17 @@ function inv = stdnormal_inv (x)
   if (nargin != 1)
     print_usage ();
   endif
 
   if (iscomplex (x))
     error ("stdnormal_inv: X must not be complex");
   endif
 
-  inv = sqrt (2) * erfinv (2 * x - 1);
+  inv = - sqrt (2) * erfcinv (2 * x);
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
 %!assert (stdnormal_inv (x), [NaN -Inf 0 Inf NaN])
 
diff --git a/scripts/time/datenum.m b/scripts/time/datenum.m
--- a/scripts/time/datenum.m
+++ b/scripts/time/datenum.m
@@ -62,17 +62,17 @@
 ## @item
 ## Days before the beginning of the month go to the previous month.
 ##
 ## @item
 ## Days can be fractional.
 ## @end itemize
 ##
 ## @strong{Caution:} this function does not attempt to handle Julian
-## calendars so dates before Octave 15, 1582 are wrong by as much
+## calendars so dates before October 15, 1582 are wrong by as much
 ## as eleven days.  Also, be aware that only Roman Catholic countries
 ## adopted the calendar in 1582.  It took until 1924 for it to be
 ## adopted everywhere.  See the Wikipedia entry on the Gregorian
 ## calendar for more details.
 ##
 ## @strong{Warning:} leap seconds are ignored.  A table of leap seconds
 ## is available on the Wikipedia entry for leap seconds.
 ## @seealso{datestr, datevec, now, clock, date}
@@ -104,17 +104,22 @@ function [days, secs] = datenum (year, m
       if (nc >= 5) minute = year(:,5); endif
       if (nc >= 4) hour   = year(:,4); endif
       day   = year(:,3);
       month = year(:,2);
       year  = year(:,1);
     endif
   endif
 
-  month(month<1) = 1; ## For compatibility.  Otherwise allow negative months.
+  if (! (isa (year, "double") && isa (month, "double") && isa (day, "double") &&
+         isa (hour, "double") && isa (minute, "double") && isa (second, "double")))
+    error ("datenum: all inputs must be of class double");
+  endif
+
+  month(month<1) = 1;  # For compatibility.  Otherwise allow negative months.
 
   ## Treat fractional months, by converting the fraction to days
   if (floor (month) != month)
     fracmonth = month - floor (month);
     month = floor (month);
     if ((mod (month-1,12) + 1) == 2 && 
         (floor (year/4) - floor (year/100) + floor (year/400)) != 0)
       ## leap year
@@ -190,10 +195,11 @@ endfunction
 %!assert (datenum ("5/19/2001"), 730990)
 %!assert (datenum ({"5/19/2001"}), 730990)
 %!assert (datenum (char ("5/19/2001", "6/6/1944")), [730990; 710189])
 %!assert (datenum ({"5/19/2001", "6/6/1944"}), [730990; 710189])
 
 %% Test input validation
 %!error datenum ()
 %!error datenum (1,2,3,4,5,6,7)
-%!error datenum ([1, 2])
-%!error datenum ([1,2,3,4,5,6,7])
+%!error <expected date vector containing> datenum ([1, 2])
+%!error <expected date vector containing> datenum ([1,2,3,4,5,6,7])
+%!error <all inputs must be of class double> datenum (int32 (2000), int32 (1), int32 (1))
diff --git a/scripts/time/datestr.m b/scripts/time/datestr.m
--- a/scripts/time/datestr.m
+++ b/scripts/time/datestr.m
@@ -51,37 +51,37 @@
 ## @item 11 @tab yy                     @tab 00
 ## @item 12 @tab mmmyy                  @tab Sep00
 ## @item 13 @tab HH:MM:SS               @tab 15:38:09
 ## @item 14 @tab HH:MM:SS PM            @tab 03:38:09 PM
 ## @item 15 @tab HH:MM                  @tab 15:38
 ## @item 16 @tab HH:MM PM               @tab 03:38 PM
 ## @item 17 @tab QQ-YY                  @tab Q3-00
 ## @item 18 @tab QQ                     @tab Q3
-## @item 19 @tab dd/mm                  @tab 13/03
-## @item 20 @tab dd/mm/yy               @tab 13/03/95
-## @item 21 @tab mmm.dd.yyyy HH:MM:SS   @tab Mar.03.1962 13:53:06
-## @item 22 @tab mmm.dd.yyyy            @tab Mar.03.1962
-## @item 23 @tab mm/dd/yyyy             @tab 03/13/1962
-## @item 24 @tab dd/mm/yyyy             @tab 12/03/1962
-## @item 25 @tab yy/mm/dd               @tab 95/03/13
-## @item 26 @tab yyyy/mm/dd             @tab 1995/03/13
-## @item 27 @tab QQ-YYYY                @tab Q4-2132
-## @item 28 @tab mmmyyyy                @tab Mar2047
-## @item 29 @tab yyyymmdd               @tab 20470313
-## @item 30 @tab yyyymmddTHHMMSS        @tab 20470313T132603
-## @item 31 @tab yyyy-mm-dd HH:MM:SS    @tab 1047-03-13 13:26:03
+## @item 19 @tab dd/mm                  @tab 07/09
+## @item 20 @tab dd/mm/yy               @tab 07/09/00
+## @item 21 @tab mmm.dd,yyyy HH:MM:SS   @tab Sep.07,2000 15:38:08
+## @item 22 @tab mmm.dd,yyyy            @tab Sep.07,2000
+## @item 23 @tab mm/dd/yyyy             @tab 09/07/2000
+## @item 24 @tab dd/mm/yyyy             @tab 07/09/2000
+## @item 25 @tab yy/mm/dd               @tab 00/09/07
+## @item 26 @tab yyyy/mm/dd             @tab 2000/09/07
+## @item 27 @tab QQ-YYYY                @tab Q3-2000
+## @item 28 @tab mmmyyyy                @tab Sep2000
+## @item 29 @tab yyyy-mm-dd             @tab 2000-09-07
+## @item 30 @tab yyyymmddTHHMMSS        @tab 20000907T153808
+## @item 31 @tab yyyy-mm-dd HH:MM:SS    @tab 2000-09-07 15:38:08
 ## @end multitable
 ##
 ## If @var{f} is a format string, the following symbols are recognized:
 ##
 ## @multitable @columnfractions 0.1 0.7 0.2
 ## @headitem Symbol @tab Meaning @tab Example
 ## @item yyyy @tab Full year                                    @tab 2005
-## @item yy   @tab Two-digit year                               @tab 2005
+## @item yy   @tab Two-digit year                               @tab 05
 ## @item mmmm @tab Full month name                              @tab December
 ## @item mmm  @tab Abbreviated month name                       @tab Dec
 ## @item mm   @tab Numeric month number (padded with zeros)     @tab 01, 08, 12
 ## @item m    @tab First letter of month name (capitalized)     @tab D
 ## @item dddd @tab Full weekday name                            @tab Sunday
 ## @item ddd  @tab Abbreviated weekday name                     @tab Sun
 ## @item dd   @tab Numeric day of month (padded with zeros)     @tab 11
 ## @item d    @tab First letter of weekday name (capitalized)   @tab S
diff --git a/scripts/time/datevec.m b/scripts/time/datevec.m
--- a/scripts/time/datevec.m
+++ b/scripts/time/datevec.m
@@ -24,17 +24,22 @@
 ## @deftypefnx {Function File} {[@var{y}, @var{m}, @var{d}, @var{h}, @var{mi}, @var{s}] =} datevec (@dots{})
 ## Convert a serial date number (see @code{datenum}) or date string (see
 ## @code{datestr}) into a date vector.
 ##
 ## A date vector is a row vector with six members, representing the year,
 ## month, day, hour, minute, and seconds respectively.
 ##
 ## @var{f} is the format string used to interpret date strings
-## (see @code{datestr}).
+## (see @code{datestr}).  If @var{date} is a string, but no format is
+## specified, then a relatively slow search is performed through various
+## formats.  It is always preferable to specifiy the format string @var{f}
+## if it is known.  Formats which do not specify a particular time component
+## will have the value set to zero.  Formats which do not specify a date will
+## default to January 1st of the current year.
 ##
 ## @var{p} is the year at the start of the century to which two-digit years
 ## will be referenced.  If not specified, it defaults to the current year
 ## minus 50.
 ## @seealso{datenum, datestr, clock, now, date}
 ## @end deftypefn
 
 ## Algorithm: Peter Baum (http://vsg.cape.com/~pbaum/date/date0.htm)
@@ -48,40 +53,47 @@
 
 function [y, m, d, h, mi, s] = datevec (date, f = [], p = [])
 
   persistent std_formats nfmt;
 
   if (isempty (std_formats))
     std_formats = cell ();
     nfmt = 0;
-    ## These formats are specified by Matlab to be parsed
+    ## These formats are specified by Matlab documentation to be parsed
     ## The '# XX' refers to the datestr numerical format code
     std_formats{++nfmt} = "dd-mmm-yyyy HH:MM:SS";   # 0
     std_formats{++nfmt} = "dd-mmm-yyyy";            # 1
     std_formats{++nfmt} = "mm/dd/yy";               # 2
     std_formats{++nfmt} = "mm/dd";                  # 6
     std_formats{++nfmt} = "HH:MM:SS";               # 13
     std_formats{++nfmt} = "HH:MM:SS PM";            # 14
     std_formats{++nfmt} = "HH:MM";                  # 15
     std_formats{++nfmt} = "HH:MM PM";               # 16
     std_formats{++nfmt} = "mm/dd/yyyy";             # 23
 
+    ## These formats are undocumented but parsed by Matlab
+    std_formats{++nfmt} = "mmmyy";                  # 12
+    std_formats{++nfmt} = "mmm.dd,yyyy HH:MM:SS";   # 21
+    std_formats{++nfmt} = "mmm.dd,yyyy";            # 22
+    std_formats{++nfmt} = "yyyy/mm/dd";             # 26
+    std_formats{++nfmt} = "yyyy-mm-dd";             # 29
+    std_formats{++nfmt} = "yyyy-mm-dd HH:MM:SS";    # 31
+
     ## These are other formats that Octave tries
     std_formats{++nfmt} = "mmm-dd-yyyy HH:MM:SS";
     std_formats{++nfmt} = "mmm-dd-yyyy";
     std_formats{++nfmt} = "dd mmm yyyy HH:MM:SS";
     std_formats{++nfmt} = "dd mmm yyyy";
     std_formats{++nfmt} = "mmm dd yyyy HH:MM:SS";
     std_formats{++nfmt} = "mmm dd yyyy";
     std_formats{++nfmt} = "dd.mmm.yyyy HH:MM:SS";
     std_formats{++nfmt} = "dd.mmm.yyyy";
     std_formats{++nfmt} = "mmm.dd.yyyy HH:MM:SS";
     std_formats{++nfmt} = "mmm.dd.yyyy";
-    std_formats{++nfmt} = "mmmyy";                  # 12
     std_formats{++nfmt} = "mm/dd/yyyy HH:MM";
   endif
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
   if (ischar (date))
@@ -249,19 +261,20 @@ function [found, y, m, d, h, mi, s] = __
       endif
       y += p - mod (p, 100);
       if (y < p)
         y += 100;
       endif
     endif
     if (! fy && ! fm && ! fd)
       tmp = localtime (time ());
+      ## default is January 1st of current year
       y = tmp.year + 1900;
-      m = tmp.mon + 1;
-      d = tmp.mday;
+      m = 1;
+      d = 1;
     elseif (! fy && fm && fd)
       tmp = localtime (time ());
       y = tmp.year + 1900;
     elseif (fy && fm && ! fd)
       d = 1;
     endif
     if (! fh && ! fmi && ! fs)
       h = mi = s = 0;
@@ -275,30 +288,30 @@ function [found, y, m, d, h, mi, s] = __
 
 endfunction
 
 
 %!demo
 %! ## Current date and time
 %! datevec (now ())
 
-%!shared nowvec
-%! nowvec = datevec (now); # Some tests could fail around midnight!
-%!# tests for standard formats: 0, 1, 2, 6, 13, 14, 15, 16, 23
+%!shared yr
+%! yr = datevec (now)(1);  # Some tests could fail around midnight!
+## tests for standard formats: 0, 1, 2, 6, 13, 14, 15, 16, 23
 %!assert (datevec ("07-Sep-2000 15:38:09"), [2000,9,7,15,38,9])
 %!assert (datevec ("07-Sep-2000"), [2000,9,7,0,0,0])
 %!assert (datevec ("09/07/00"), [2000,9,7,0,0,0])
-%!assert (datevec ("09/13"), [nowvec(1),9,13,0,0,0])
-%!assert (datevec ("15:38:09"), [nowvec(1:3),15,38,9])
-%!assert (datevec ("3:38:09 PM"), [nowvec(1:3),15,38,9])
-%!assert (datevec ("15:38"), [nowvec(1:3),15,38,0])
-%!assert (datevec ("03:38 PM"), [nowvec(1:3),15,38,0])
+%!assert (datevec ("09/13"), [yr,9,13,0,0,0])
+%!assert (datevec ("15:38:09"), [yr,1,1,15,38,9])
+%!assert (datevec ("3:38:09 PM"), [yr,1,1,15,38,9])
+%!assert (datevec ("15:38"), [yr,1,1,15,38,0])
+%!assert (datevec ("03:38 PM"), [yr,1,1,15,38,0])
 %!assert (datevec ("03/13/1962"), [1962,3,13,0,0,0])
 
 %% Test millisecond format FFF
-%!assert (datevec ("15:38:21.25", "HH:MM:SS.FFF"), [nowvec(1:3),15,38,21.025])
+%!assert (datevec ("15:38:21.25", "HH:MM:SS.FFF"), [yr,1,1,15,38,21.025])
 
 # Other tests
 %!assert (datenum (datevec ([-1e4:1e4])), [-1e4:1e4]');
 %!test
 %! t = linspace (-2e5, 2e5, 10993);
 %! assert (all (abs (datenum (datevec (t)) - t') < 1e-5));
 
diff --git a/src/bitfcns.cc b/src/bitfcns.cc
--- a/src/bitfcns.cc
+++ b/src/bitfcns.cc
@@ -39,16 +39,42 @@ along with Octave; see the file COPYING.
 #include "ov-int16.h"
 #include "ov-int8.h"
 #include "ov-scalar.h"
 #include "ov-re-mat.h"
 #include "ov-bool.h"
 
 #include <functional>
 
+#if !defined (HAVE_CXX_BITWISE_OP_TEMPLATES)
+namespace std 
+{
+  template <typename T>
+  struct bit_and 
+  {
+  public: 
+    T operator() (const T & op1, const T & op2) const { return (op1 & op2); }
+  };
+
+  template <typename T>
+  struct bit_or 
+  {
+  public: 
+    T operator() (const T & op1, const T & op2) const { return (op1 | op2); }
+  };
+
+  template <typename T>
+  struct bit_xor 
+  {
+  public: 
+    T operator() (const T & op1, const T & op2) const { return (op1 ^ op2); }
+  };
+}
+#endif
+
 template <typename OP, typename T>
 octave_value
 bitopxx(const OP& op, const std::string& fname,
         const Array<T>& x, const Array<T>& y)
 {
   int nelx = x.numel ();
   int nely = y.numel ();
 
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -266,17 +266,17 @@ message identifier.\n\
           // directory already exists.
 
           retval(2) = "mkdir";
           retval(1) = "directory exists";
           retval(0) = true;
         }
       else
         {
-          int status = octave_mkdir (dirname, 0777, msg, true);
+          int status = octave_mkdir (dirname, 0777, msg);
 
           if (status < 0)
             {
               retval(2) = "mkdir";
               retval(1) = msg;
             }
           else
             retval(0) = true;
diff --git a/src/display.cc b/src/display.cc
--- a/src/display.cc
+++ b/src/display.cc
@@ -36,16 +36,33 @@ along with Octave; see the file COPYING.
 
 #include "singleton-cleanup.h"
 
 #include "display.h"
 #include "error.h"
 
 display_info *display_info::instance = 0;
 
+#if defined (HAVE_FRAMEWORK_CARBON) && ! defined (HAVE_CARBON_CGDISPLAYBITSPERPIXEL)
+// FIXME - This will only work for MacOS > 10.5. For earlier versions
+// this code is not needed (use CGDisplayBitsPerPixel instead).
+size_t DisplayBitsPerPixel (CGDirectDisplayID display)
+{
+  CGDisplayModeRef mode = CGDisplayCopyDisplayMode (display);
+  CFStringRef pixelEncoding = CGDisplayModeCopyPixelEncoding (mode);
+
+  if (CFStringCompare (pixelEncoding, CFSTR (IO32BitDirectPixels), 0) == 0)
+    return 32;
+  else if (CFStringCompare (pixelEncoding, CFSTR (IO16BitDirectPixels), 0) == 0)
+    return 16;
+  else 
+    return 8;
+}
+#endif
+
 void
 display_info::init (bool query)
 {
   if (query)
     {
 #if defined (OCTAVE_USE_WINDOWS_API)
 
       HDC hdc = GetDC (0);
@@ -67,26 +84,31 @@ display_info::init (bool query)
         warning ("no graphical display found");
 
 #elif defined (HAVE_FRAMEWORK_CARBON)
 
       CGDirectDisplayID display = CGMainDisplayID ();
 
       if (display)
         {
+#  if defined (HAVE_CARBON_CGDISPLAYBITSPERPIXEL)
+          // For MacOS < 10.7 use the line below
           dp = CGDisplayBitsPerPixel (display);
+#  else
+          // For MacOS > 10.5 use the line below
+          dp = DisplayBitsPerPixel (display);
+#  endif
 
           ht = CGDisplayPixelsHigh (display);
           wd = CGDisplayPixelsWide (display);
 
           CGSize sz_mm = CGDisplayScreenSize (display);
-
-          // On modern Mac systems (>= 10.5) CGSize is a struct keeping 2
-          // CGFloat values, but the CGFloat typedef is not present on
-          // older systems, so use double instead.
+          // For MacOS >= 10.6, CGSize is a struct keeping 2 CGFloat values,
+          // but the CGFloat typedef is not present on older systems,
+          // so use double instead.
           double ht_mm = sz_mm.height;
           double wd_mm = sz_mm.width;
 
           rx = wd * 25.4 / wd_mm;
           ry = ht * 25.4 / ht_mm;
         }
       else
         warning ("no graphical display found");
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -139,60 +139,60 @@ Logical 'not equals' operator.\n\
 @deftypefn {Operator} {} \"\n\
 String delimiter.\n\
 @end deftypefn"),
 
   pair_type ("#",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} #\n\
 Begin comment character.\n\
-@seealso{%, #@{}\n\
+@seealso{%, #@\\{}\n\
 @end deftypefn"),
 
   pair_type ("%",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} %\n\
 Begin comment character.\n\
-@seealso{#, %@{}\n\
+@seealso{#, %@\\{}\n\
 @end deftypefn"),
 
   pair_type ("#{",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} #@{\n\
 Begin block comment.  There must be nothing else, other than\n\
 whitespace, in the line both before and after @code{#@{}.\n\
 It is possible to nest block comments.\n\
-@seealso{%@{, #@}, #}\n\
+@seealso{%@\\{, #@\\}, #}\n\
 @end deftypefn"),
 
   pair_type ("%{",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} %@{\n\
 Begin block comment.  There must be nothing else, other than\n\
 whitespace, in the line both before and after @code{%@{}.\n\
 It is possible to nest block comments.\n\
-@seealso{#@{, %@}, %}\n\
+@seealso{#@\\{, %@\\}, %}\n\
 @end deftypefn"),
 
   pair_type ("#}",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} #@}\n\
 Close block comment.  There must be nothing else, other than\n\
 whitespace, in the line both before and after @code{#@}}.\n\
 It is possible to nest block comments.\n\
-@seealso{%@}, #@{, #}\n\
+@seealso{%@\\}, #@\\{, #}\n\
 @end deftypefn"),
 
   pair_type ("%}",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} %@}\n\
 Close block comment.  There must be nothing else, other than\n\
 whitespace, in the line both before and after @code{%@}}.\n\
 It is possible to nest block comments.\n\
-@seealso{#@}, %@{, %}\n\
+@seealso{#@\\}, %@\\{, %}\n\
 @end deftypefn"),
 
   pair_type ("...",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} ...\n\
 Continuation marker.  Joins current line with following line.\n\
 @end deftypefn"),
 
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -542,17 +542,17 @@ Compute the error function,\n\
               2        /\n\
 erf (z) = --------- *  | e^(-t^2) dt\n\
           sqrt (pi)    /\n\
                     t=0\n\
 @end group\n\
 @end example\n\
 \n\
 @end ifnottex\n\
-@seealso{erfc, erfcx, erfinv}\n\
+@seealso{erfc, erfcx, erfinv, erfcinv}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).erf ();
   else
     print_usage ();
 
@@ -591,57 +591,95 @@ erf (z) = --------- *  | e^(-t^2) dt\n\
 DEFUN (erfinv, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erfinv (@var{x})\n\
 Compute the inverse error function, i.e., @var{y} such that\n\
 \n\
 @example\n\
 erf (@var{y}) == @var{x}\n\
 @end example\n\
-@seealso{erf, erfc, erfcx}\n\
+@seealso{erf, erfc, erfcx, erfcinv}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).erfinv ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 ## middle region
 %!assert (erf (erfinv ([-0.9 -0.3 0 0.4 0.8])), [-0.9 -0.3 0 0.4 0.8], eps)
-%!assert (erf (erfinv (single ([-0.9 -0.3 0 0.4 0.8]))), single ([-0.9 -0.3 0 0.4 0.8]), 1e-8)
+%!assert (erf (erfinv (single ([-0.9 -0.3 0 0.4 0.8]))), single ([-0.9 -0.3 0 0.4 0.8]), eps ("single"))
 ## tail region
 %!assert (erf (erfinv ([-0.999 -0.99 0.9999 0.99999])), [-0.999 -0.99 0.9999 0.99999], eps)
-%!assert (erf (erfinv (single ([-0.999 -0.99 0.9999 0.99999]))), single ([-0.999 -0.99 0.9999 0.99999]), 1e-8)
+%!assert (erf (erfinv (single ([-0.999 -0.99 0.9999 0.99999]))), single ([-0.999 -0.99 0.9999 0.99999]), eps ("single"))
 ## backward - loss of accuracy
 %!assert (erfinv (erf ([-3 -1 -0.4 0.7 1.3 2.8])), [-3 -1 -0.4 0.7 1.3 2.8], -1e-12)
 %!assert (erfinv (erf (single ([-3 -1 -0.4 0.7 1.3 2.8]))), single ([-3 -1 -0.4 0.7 1.3 2.8]), -1e-4)
 ## exceptional
 %!assert (erfinv ([-1, 1, 1.1, -2.1]), [-Inf, Inf, NaN, NaN])
 %!error erfinv (1+2i)
 
 %!error erfinv ()
 %!error erfinv (1, 2)
 */
 
+DEFUN (erfcinv, args, ,
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} erfcinv (@var{x})\n\
+Compute the inverse complementary error function, i.e., @var{y} such that\n\
+\n\
+@example\n\
+erfc (@var{y}) == @var{x}\n\
+@end example\n\
+@seealso{erfc, erf, erfcx, erfinv}\n\
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).erfcinv ();
+  else
+    print_usage ();
+
+  return retval;
+}
+
+/*
+## middle region
+%!assert (erfc (erfcinv ([1.9 1.3 1 0.6 0.2])), [1.9 1.3 1 0.6 0.2], eps)
+%!assert (erfc (erfcinv (single ([1.9 1.3 1 0.6 0.2]))), single ([1.9 1.3 1 0.6 0.2]), eps ("single"))
+## tail region
+%!assert (erfc (erfcinv ([0.001 0.01 1.9999 1.99999])), [0.001 0.01 1.9999 1.99999], eps)
+%!assert (erfc (erfcinv (single ([0.001 0.01 1.9999 1.99999]))), single ([0.001 0.01 1.9999 1.99999]), eps ("single"))
+## backward - loss of accuracy
+%!assert (erfcinv (erfc ([-3 -1 -0.4 0.7 1.3 2.8])), [-3 -1 -0.4 0.7 1.3 2.8], -1e-12)
+%!assert (erfcinv (erfc (single ([-3 -1 -0.4 0.7 1.3 2.8]))), single ([-3 -1 -0.4 0.7 1.3 2.8]), -1e-4)
+## exceptional
+%!assert (erfcinv ([2, 0, -0.1, 2.1]), [-Inf, Inf, NaN, NaN])
+%!error erfcinv (1+2i)
+
+%!error erfcinv ()
+%!error erfcinv (1, 2)
+*/
+
 DEFUN (erfc, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erfc (@var{z})\n\
 Compute the complementary error function,\n\
 @tex\n\
 $1 - {\\rm erf} (z)$.\n\
 @end tex\n\
 @ifnottex\n\
 @w{@code{1 - erf (@var{z})}}.\n\
 @end ifnottex\n\
-@seealso{erfcx, erf, erfinv}\n\
+@seealso{erfcinv, erfcx, erf, erfinv}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).erfc ();
   else
     print_usage ();
 
@@ -668,17 +706,17 @@ Compute the scaled complementary error f
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 exp (z^2) * erfc (x)\n\
 @end example\n\
 \n\
 @end ifnottex\n\
-@seealso{erfc, erf, erfinv}\n\
+@seealso{erfc, erf, erfinv, erfcinv}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).erfcx ();
   else
     print_usage ();
 
diff --git a/src/ops.h b/src/ops.h
--- a/src/ops.h
+++ b/src/ops.h
@@ -336,22 +336,16 @@ extern void install_ops (void);
 
 #define DEFNDCMPLXCMPOP_FN(name, t1, t2, e1, e2, f) \
   BINOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (const CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
     return octave_value (f (v1.CONCAT2(e1, _value) (), v2.CONCAT2(e2, _value) ())); \
   }
 
-#define BINOP_NONCONFORMANT(msg) \
-  gripe_nonconformant (msg, \
-                       a1.rows (), a1.columns (), \
-                       a2.rows (), a2.columns ()); \
-  return octave_value ()
-
 #define CATOPDECL(name, a1, a2) \
   static octave_value \
   CONCAT2(oct_catop_, name) (octave_base_value& a1, const octave_base_value& a2, \
                       const Array<octave_idx_type>& ra_idx)
 
 #define DEFCATOPX(name, t1, t2) \
   CATOPDECL (name, , )
 
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -1186,16 +1186,17 @@ octave_base_value::get_umap_name (unary_
       "atanh",
       "cbrt",
       "ceil",
       "conj",
       "cos",
       "cosh",
       "erf",
       "erfinv",
+      "erfcinv",
       "erfc",
       "exp",
       "expm1",
       "finite",
       "fix",
       "floor",
       "gamma",
       "imag",
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -683,16 +683,17 @@ public:
       umap_atanh,
       umap_cbrt,
       umap_ceil,
       umap_conj,
       umap_cos,
       umap_cosh,
       umap_erf,
       umap_erfinv,
+      umap_erfcinv,
       umap_erfc,
       umap_erfcx,
       umap_exp,
       umap_expm1,
       umap_finite,
       umap_fix,
       umap_floor,
       umap_gamma,
diff --git a/src/ov-float.cc b/src/ov-float.cc
--- a/src/ov-float.cc
+++ b/src/ov-float.cc
@@ -286,16 +286,17 @@ octave_float_scalar::map (unary_mapper_t
       SCALAR_MAPPER (angle, ::arg);
       SCALAR_MAPPER (arg, ::arg);
       SCALAR_MAPPER (asin, rc_asin);
       SCALAR_MAPPER (asinh, ::asinhf);
       SCALAR_MAPPER (atan, ::atanf);
       SCALAR_MAPPER (atanh, rc_atanh);
       SCALAR_MAPPER (erf, ::erff);
       SCALAR_MAPPER (erfinv, ::erfinv);
+      SCALAR_MAPPER (erfcinv, ::erfcinv);
       SCALAR_MAPPER (erfc, ::erfcf);
       SCALAR_MAPPER (erfcx, ::erfcx);
       SCALAR_MAPPER (gamma, xgamma);
       SCALAR_MAPPER (lgamma, rc_lgamma);
       SCALAR_MAPPER (cbrt, ::cbrtf);
       SCALAR_MAPPER (ceil, ::ceilf);
       SCALAR_MAPPER (cos, ::cosf);
       SCALAR_MAPPER (cosh, ::coshf);
diff --git a/src/ov-flt-re-mat.cc b/src/ov-flt-re-mat.cc
--- a/src/ov-flt-re-mat.cc
+++ b/src/ov-flt-re-mat.cc
@@ -779,16 +779,17 @@ octave_float_matrix::map (unary_mapper_t
       ARRAY_MAPPER (angle, float, ::arg);
       ARRAY_MAPPER (arg, float, ::arg);
       RC_ARRAY_MAPPER (asin, FloatComplex, rc_asin);
       ARRAY_MAPPER (asinh, float, ::asinhf);
       ARRAY_MAPPER (atan, float, ::atanf);
       RC_ARRAY_MAPPER (atanh, FloatComplex, rc_atanh);
       ARRAY_MAPPER (erf, float, ::erff);
       ARRAY_MAPPER (erfinv, float, ::erfinv);
+      ARRAY_MAPPER (erfcinv, float, ::erfcinv);
       ARRAY_MAPPER (erfc, float, ::erfcf);
       ARRAY_MAPPER (erfcx, float, ::erfcx);
       ARRAY_MAPPER (gamma, float, xgamma);
       RC_ARRAY_MAPPER (lgamma, FloatComplex, rc_lgamma);
       ARRAY_MAPPER (cbrt, float, ::cbrtf);
       ARRAY_MAPPER (ceil, float, ::ceilf);
       ARRAY_MAPPER (cos, float, ::cosf);
       ARRAY_MAPPER (cosh, float, ::coshf);
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -902,16 +902,17 @@ octave_matrix::map (unary_mapper_t umap)
       ARRAY_MAPPER (angle, double, ::arg);
       ARRAY_MAPPER (arg, double, ::arg);
       RC_ARRAY_MAPPER (asin, Complex, rc_asin);
       ARRAY_MAPPER (asinh, double, ::asinh);
       ARRAY_MAPPER (atan, double, ::atan);
       RC_ARRAY_MAPPER (atanh, Complex, rc_atanh);
       ARRAY_MAPPER (erf, double, ::erf);
       ARRAY_MAPPER (erfinv, double, ::erfinv);
+      ARRAY_MAPPER (erfcinv, double, ::erfcinv);
       ARRAY_MAPPER (erfc, double, ::erfc);
       ARRAY_MAPPER (erfcx, double, ::erfcx);
       ARRAY_MAPPER (gamma, double, xgamma);
       RC_ARRAY_MAPPER (lgamma, Complex, rc_lgamma);
       ARRAY_MAPPER (cbrt, double, ::cbrt);
       ARRAY_MAPPER (ceil, double, ::ceil);
       ARRAY_MAPPER (cos, double, ::cos);
       ARRAY_MAPPER (cosh, double, ::cosh);
diff --git a/src/ov-re-sparse.cc b/src/ov-re-sparse.cc
--- a/src/ov-re-sparse.cc
+++ b/src/ov-re-sparse.cc
@@ -905,16 +905,17 @@ octave_sparse_matrix::map (unary_mapper_
       ARRAY_MAPPER (angle, double, ::arg);
       ARRAY_MAPPER (arg, double, ::arg);
       ARRAY_MAPPER (asin, Complex, rc_asin);
       ARRAY_MAPPER (asinh, double, ::asinh);
       ARRAY_MAPPER (atan, double, ::atan);
       ARRAY_MAPPER (atanh, Complex, rc_atanh);
       ARRAY_MAPPER (erf, double, ::erf);
       ARRAY_MAPPER (erfinv, double, ::erfinv);
+      ARRAY_MAPPER (erfcinv, double, ::erfcinv);
       ARRAY_MAPPER (erfc, double, ::erfc);
       ARRAY_MAPPER (gamma, double, xgamma);
       ARRAY_MAPPER (lgamma, Complex, rc_lgamma);
       ARRAY_MAPPER (cbrt, double, ::cbrt);
       ARRAY_MAPPER (ceil, double, ::ceil);
       ARRAY_MAPPER (cos, double, ::cos);
       ARRAY_MAPPER (cosh, double, ::cosh);
       ARRAY_MAPPER (exp, double, ::exp);
diff --git a/src/ov-scalar.cc b/src/ov-scalar.cc
--- a/src/ov-scalar.cc
+++ b/src/ov-scalar.cc
@@ -302,16 +302,17 @@ octave_scalar::map (unary_mapper_t umap)
       SCALAR_MAPPER (angle, ::arg);
       SCALAR_MAPPER (arg, ::arg);
       SCALAR_MAPPER (asin, rc_asin);
       SCALAR_MAPPER (asinh, ::asinh);
       SCALAR_MAPPER (atan, ::atan);
       SCALAR_MAPPER (atanh, rc_atanh);
       SCALAR_MAPPER (erf, ::erf);
       SCALAR_MAPPER (erfinv, ::erfinv);
+      SCALAR_MAPPER (erfcinv, ::erfcinv);
       SCALAR_MAPPER (erfc, ::erfc);
       SCALAR_MAPPER (erfcx, ::erfcx);
       SCALAR_MAPPER (gamma, xgamma);
       SCALAR_MAPPER (lgamma, rc_lgamma);
       SCALAR_MAPPER (cbrt, ::cbrt);
       SCALAR_MAPPER (ceil, ::ceil);
       SCALAR_MAPPER (cos, ::cos);
       SCALAR_MAPPER (cosh, ::cosh);
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -1115,16 +1115,17 @@ public:
   MAPPER_FORWARD (atanh)
   MAPPER_FORWARD (cbrt)
   MAPPER_FORWARD (ceil)
   MAPPER_FORWARD (conj)
   MAPPER_FORWARD (cos)
   MAPPER_FORWARD (cosh)
   MAPPER_FORWARD (erf)
   MAPPER_FORWARD (erfinv)
+  MAPPER_FORWARD (erfcinv)
   MAPPER_FORWARD (erfc)
   MAPPER_FORWARD (erfcx)
   MAPPER_FORWARD (exp)
   MAPPER_FORWARD (expm1)
   MAPPER_FORWARD (finite)
   MAPPER_FORWARD (fix)
   MAPPER_FORWARD (floor)
   MAPPER_FORWARD (gamma)
diff --git a/src/pt-except.h b/src/pt-except.h
--- a/src/pt-except.h
+++ b/src/pt-except.h
@@ -132,23 +132,23 @@ private:
 
   // The first body of code to attempt to execute.
   tree_statement_list *unwind_protect_code;
 
   // The body of code to execute no matter what happens in the first
   // body of code.
   tree_statement_list *cleanup_code;
 
-  // Comment preceding TRY token.
+  // Comment preceding UNWIND_PROTECT token.
   octave_comment_list *lead_comm;
 
-  // Comment preceding CATCH token.
+  // Comment preceding UNWIND_PROTECT_CLEANUP token.
   octave_comment_list *mid_comm;
 
-  // Comment preceding END_TRY_CATCH token.
+  // Comment preceding END_UNWIND_PROTECT token.
   octave_comment_list *trail_comm;
 
   // No copying!
 
   tree_unwind_protect_command (const tree_unwind_protect_command&);
 
   tree_unwind_protect_command& operator = (const tree_unwind_protect_command&);
 };
diff --git a/test/test_system.m b/test/test_system.m
--- a/test/test_system.m
+++ b/test/test_system.m
@@ -119,29 +119,21 @@
 %% test/octave.test/system/readdir-2.m
 %!error <Invalid call to readdir> readdir ()
 
 %% test/octave.test/system/readdir-3.m
 %!error <Invalid call to readdir> readdir ("foo", 1)
 
 %% test/octave.test/system/mk-rm-dir-1.m
 %!test
-%! ## FIXME: saving and restoring of pwd in olldir is a hack
-%! ##        'mkdir' should not change pwd but it does since
-%! ##        changeset 14679:a543ed02e673
-%! ##        which created 'mkdir -p' capabilities.  
-%! ##        When 'mkdir' has been corrected, delete this FIXME
-%! ##        and any lines with 'HACK'.
-%! olddir = pwd;   # HACK Line #1
 %! nm = tmpnam ();
 %! e1 = mkdir (nm);
 %! [s2, e2] = stat (nm);
 %! e3 = rmdir (nm);
 %! [s4, e4] = stat (nm);
-%! cd (olddir);    # HACK Line #2
 %! assert ((e1 && strcmp (s2.modestr(1), "d") && e3 && e4 < 0));
 
 %% test/octave.test/system/mkdir-1.m
 %!error <Invalid call to mkdir> mkdir ()
 
 %% test/octave.test/system/mkdir-2.m
 %!error <Invalid call to mkdir> mkdir ("foo", 1, 2)
 
