# HG changeset patch
# User jwe
# Date 797618123 0
#      Tue Apr 11 16:35:23 1995 +0000
# Node ID bb67a902760b4262712827ef796f3d0047a5914d
# Parent  ccb22498f2890d3f8361367d4341a0e0a88ca3c6
[project @ 1995-04-11 16:35:23 by jwe]

diff --git a/liboctave/CColVector.cc b/liboctave/CColVector.cc
--- a/liboctave/CColVector.cc
+++ b/liboctave/CColVector.cc
@@ -33,20 +33,21 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "mx-inlines.cc"
 #include "f77-uscore.h"
 #include "lo-error.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
-  int F77_FCN (zgemv) (const char*, const int&, const int&,
-		       const Complex&, const Complex*, const int&,
-		       const Complex*, const int&, const Complex&,
-		       Complex*, const int&, long);
+  int F77_FCN (zgemv, ZGEMV) (const char*, const int&, const int&,
+			      const Complex&, const Complex*,
+			      const int&, const Complex*, const int&,
+			      const Complex&, Complex*, const int&,
+			      long);
 }
 
 /*
  * Complex Column Vector class
  */
 
 ComplexColumnVector::ComplexColumnVector (const ColumnVector& a)
    : MArray<Complex> (a.length ())
@@ -445,18 +446,18 @@ operator * (const ComplexMatrix& m, cons
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
 
   int ld = nr;
 
   Complex *y = new Complex [nr];
 
-  F77_FCN (zgemv) ("N", nr, nc, 1.0, m.data (), ld, a.data (), 1, 0.0,
-		   y, 1, 1L);
+  F77_FCN (zgemv, ZGEMV) ("N", nr, nc, 1.0, m.data (), ld, a.data (),
+			  1, 0.0, y, 1, 1L);
 
   return ComplexColumnVector (y, nr);
 }
 
 // column vector by column vector -> column vector operations
 
 ComplexColumnVector
 operator + (const ComplexColumnVector& v, const ColumnVector& a)
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -37,46 +37,47 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
-  int F77_FCN (zgemm) (const char*, const char*, const int&,
-		       const int&, const int&, const Complex&,
-		       const Complex*, const int&, const Complex*,
-		       const int&, const Complex&, Complex*, const int&,
-		       long, long);
-
-  int F77_FCN (zgeco) (Complex*, const int&, const int&, int*,
-		       double&, Complex*);
-
-  int F77_FCN (zgedi) (Complex*, const int&, const int&, int*,
-		       Complex*, Complex*, const int&);
-
-  int F77_FCN (zgesl) (Complex*, const int&, const int&, int*,
-		       Complex*, const int&);
-
-  int F77_FCN (zgelss) (const int&, const int&, const int&, Complex*,
-			const int&, Complex*, const int&, double*,
-			double&, int&, Complex*, const int&,
-			double*, int&);
+  int F77_FCN (zgemm, ZGEMM) (const char*, const char*, const int&,
+			      const int&, const int&, const Complex&,
+			      const Complex*, const int&,
+			      const Complex*, const int&,
+			      const Complex&, Complex*, const int&, 
+			      long, long);
+
+  int F77_FCN (zgeco, ZGECO) (Complex*, const int&, const int&, int*,
+			      double&, Complex*);
+
+  int F77_FCN (zgedi, ZGEDI) (Complex*, const int&, const int&, int*,
+			      Complex*, Complex*, const int&);
+
+  int F77_FCN (zgesl, ZGESL) (Complex*, const int&, const int&, int*,
+			      Complex*, const int&);
+
+  int F77_FCN (zgelss, ZGELSS) (const int&, const int&, const int&,
+				Complex*, const int&, Complex*,
+				const int&, double*, double&, int&,
+				Complex*, const int&, double*, int&);
 
 // Note that the original complex fft routines were not written for
 // double complex arguments.  They have been modified by adding an
 // implicit double precision (a-h,o-z) statement at the beginning of
 // each subroutine.
 
-  int F77_FCN (cffti) (const int&, Complex*);
-
-  int F77_FCN (cfftf) (const int&, Complex*, Complex*);
-
-  int F77_FCN (cfftb) (const int&, Complex*, Complex*);
+  int F77_FCN (cffti, CFFTI) (const int&, Complex*);
+
+  int F77_FCN (cfftf, CFFTF) (const int&, Complex*, Complex*);
+
+  int F77_FCN (cfftb, CFFTB) (const int&, Complex*, Complex*);
 }
 
 /*
  * Complex Matrix class
  */
 
 ComplexMatrix::ComplexMatrix (const Matrix& a)
   : MArray2<Complex> (a.rows (), a.cols ())
@@ -783,29 +784,29 @@ ComplexMatrix::inverse (int& info, doubl
     }
 
   info = 0;
 
   int *ipvt = new int [nr];
   Complex *z = new Complex [nr];
   Complex *tmp_data = dup (data (), len);
 
-  F77_FCN (zgeco) (tmp_data, nr, nc, ipvt, rcond, z);
+  F77_FCN (zgeco, ZGECO) (tmp_data, nr, nc, ipvt, rcond, z);
 
   volatile double rcond_plus_one = rcond + 1.0;
   if (rcond_plus_one == 1.0)
     {
       info = -1;
       copy (tmp_data, data (), len);  // Restore contents.
     }
   else
     {
       Complex *dummy;
 
-      F77_FCN (zgedi) (tmp_data, nr, nc, ipvt, dummy, z, 1);
+      F77_FCN (zgedi, ZGEDI) (tmp_data, nr, nc, ipvt, dummy, z, 1);
     }
 
   delete [] ipvt;
   delete [] z;
 
   return ComplexMatrix (tmp_data, nr, nc);
 }
 
@@ -862,20 +863,20 @@ ComplexMatrix::fourier (void) const
       npts = nr;
       nsamples = nc;
     }
 
   int nn = 4*npts+15;
   Complex *wsave = new Complex [nn];
   Complex *tmp_data = dup (data (), length ());
 
-  F77_FCN (cffti) (npts, wsave);
+  F77_FCN (cffti, CFFTI) (npts, wsave);
 
   for (int j = 0; j < nsamples; j++)
-    F77_FCN (cfftf) (npts, &tmp_data[npts*j], wsave);
+    F77_FCN (cfftf, CFFTF) (npts, &tmp_data[npts*j], wsave);
 
   delete [] wsave;
 
   return ComplexMatrix (tmp_data, nr, nc);
 }
 
 ComplexMatrix
 ComplexMatrix::ifourier (void) const
@@ -893,20 +894,20 @@ ComplexMatrix::ifourier (void) const
       npts = nr;
       nsamples = nc;
     }
 
   int nn = 4*npts+15;
   Complex *wsave = new Complex [nn];
   Complex *tmp_data = dup (data (), length ());
 
-  F77_FCN (cffti) (npts, wsave);
+  F77_FCN (cffti, CFFTI) (npts, wsave);
 
   for (int j = 0; j < nsamples; j++)
-    F77_FCN (cfftb) (npts, &tmp_data[npts*j], wsave);
+    F77_FCN (cfftb, CFFTB) (npts, &tmp_data[npts*j], wsave);
 
   for (j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / (double) npts;
 
   delete [] wsave;
 
   return ComplexMatrix (tmp_data, nr, nc);
 }
@@ -927,37 +928,37 @@ ComplexMatrix::fourier2d (void) const
       npts = nr;
       nsamples = nc;
     }
 
   int nn = 4*npts+15;
   Complex *wsave = new Complex [nn];
   Complex *tmp_data = dup (data (), length ());
 
-  F77_FCN (cffti) (npts, wsave);
+  F77_FCN (cffti, CFFTI) (npts, wsave);
 
   for (int j = 0; j < nsamples; j++)
-    F77_FCN (cfftf) (npts, &tmp_data[npts*j], wsave);
+    F77_FCN (cfftf, CFFTF) (npts, &tmp_data[npts*j], wsave);
 
   delete [] wsave;
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
   wsave = new Complex [nn];
   Complex *row = new Complex[npts];
 
-  F77_FCN (cffti) (npts, wsave);
+  F77_FCN (cffti, CFFTI) (npts, wsave);
 
   for (j = 0; j < nsamples; j++)
     {
       for (int i = 0; i < npts; i++)
 	row[i] = tmp_data[i*nr + j];
 
-      F77_FCN (cfftf) (npts, row, wsave);
+      F77_FCN (cfftf, CFFTF) (npts, row, wsave);
 
       for (i = 0; i < npts; i++)
 	tmp_data[i*nr + j] = row[i];
     }
 
   delete [] wsave;
   delete [] row;
 
@@ -980,40 +981,40 @@ ComplexMatrix::ifourier2d (void) const
       npts = nr;
       nsamples = nc;
     }
 
   int nn = 4*npts+15;
   Complex *wsave = new Complex [nn];
   Complex *tmp_data = dup (data (), length ());
 
-  F77_FCN (cffti) (npts, wsave);
+  F77_FCN (cffti, CFFTI) (npts, wsave);
 
   for (int j = 0; j < nsamples; j++)
-    F77_FCN (cfftb) (npts, &tmp_data[npts*j], wsave);
+    F77_FCN (cfftb, CFFTB) (npts, &tmp_data[npts*j], wsave);
 
   delete [] wsave;
 
   for (j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / (double) npts;
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
   wsave = new Complex [nn];
   Complex *row = new Complex[npts];
 
-  F77_FCN (cffti) (npts, wsave);
+  F77_FCN (cffti, CFFTI) (npts, wsave);
 
   for (j = 0; j < nsamples; j++)
     {
       for (int i = 0; i < npts; i++)
 	row[i] = tmp_data[i*nr + j];
 
-      F77_FCN (cfftb) (npts, row, wsave);
+      F77_FCN (cfftb, CFFTB) (npts, row, wsave);
 
       for (i = 0; i < npts; i++)
 	tmp_data[i*nr + j] = row[i] / (double) npts;
     }
 
   delete [] wsave;
   delete [] row;
 
@@ -1053,28 +1054,28 @@ ComplexMatrix::determinant (int& info, d
   else
     {
       info = 0;
       int *ipvt = new int [nr];
 
       Complex *z = new Complex [nr];
       Complex *tmp_data = dup (data (), length ());
 
-      F77_FCN (zgeco) (tmp_data, nr, nr, ipvt, rcond, z);
+      F77_FCN (zgeco, ZGECO) (tmp_data, nr, nr, ipvt, rcond, z);
 
       volatile double rcond_plus_one = rcond + 1.0;
       if (rcond_plus_one == 1.0)
 	{
 	  info = -1;
 	  retval = ComplexDET ();
 	}
       else
 	{
 	  Complex d[2];
-	  F77_FCN (zgedi) (tmp_data, nr, nr, ipvt, d, z, 10);
+	  F77_FCN (zgedi, ZGEDI) (tmp_data, nr, nr, ipvt, d, z, 10);
 	  retval = ComplexDET (d);
 	}
 
       delete [] tmp_data;
       delete [] ipvt;
       delete [] z;
     }
 
@@ -1134,29 +1135,29 @@ ComplexMatrix::solve (const ComplexMatri
     }
 
   info = 0;
   int *ipvt = new int [nr];
 
   Complex *z = new Complex [nr];
   Complex *tmp_data = dup (data (), length ());
 
-  F77_FCN (zgeco) (tmp_data, nr, nr, ipvt, rcond, z);
+  F77_FCN (zgeco, ZGECO) (tmp_data, nr, nr, ipvt, rcond, z);
 
   volatile double rcond_plus_one = rcond + 1.0;
   if (rcond_plus_one == 1.0)
     {
       info = -2;
     }
   else
     {
       Complex *result = dup (b.data (), b.length ());
 
       for (int j = 0; j < b_nc; j++)
-	F77_FCN (zgesl) (tmp_data, nr, nr, ipvt, &result[nr*j], 0);
+	F77_FCN (zgesl, ZGESL) (tmp_data, nr, nr, ipvt, &result[nr*j], 0);
 
       retval = ComplexMatrix (result, b_nr, b_nc);
     }
 
   delete [] tmp_data;
   delete [] ipvt;
   delete [] z;
 
@@ -1195,28 +1196,28 @@ ComplexMatrix::solve (const ComplexColum
     }
 
   info = 0;
   int *ipvt = new int [nr];
 
   Complex *z = new Complex [nr];
   Complex *tmp_data = dup (data (), length ());
 
-  F77_FCN (zgeco) (tmp_data, nr, nr, ipvt, rcond, z);
+  F77_FCN (zgeco, ZGECO) (tmp_data, nr, nr, ipvt, rcond, z);
 
   volatile double rcond_plus_one = rcond + 1.0;
   if (rcond_plus_one == 1.0)
     {
       info = -2;
     }
   else
     {
       Complex *result = dup (b.data (), b_len);
 
-      F77_FCN (zgesl) (tmp_data, nr, nr, ipvt, result, 0);
+      F77_FCN (zgesl, ZGESL) (tmp_data, nr, nr, ipvt, result, 0);
 
       retval = ComplexColumnVector (result, b_len);
     }
 
   delete [] tmp_data;
   delete [] ipvt;
   delete [] z;
 
@@ -1275,18 +1276,18 @@ ComplexMatrix::lssolve (const ComplexMat
     lwork = 2*n + (nrhs > m ? nrhs : m);
 
   Complex *work = new Complex [lwork];
 
   int lrwork = (5 * (m < n ? m : n)) - 4;
   lrwork = lrwork > 1 ? lrwork : 1;
   double *rwork = new double [lrwork];
 
-  F77_FCN (zgelss) (m, n, nrhs, tmp_data, m, presult, nrr, s,
-		    rcond, rank, work, lwork, rwork, info);
+  F77_FCN (zgelss, ZGELSS) (m, n, nrhs, tmp_data, m, presult, nrr, s,
+			    rcond, rank, work, lwork, rwork, info);
 
   ComplexMatrix retval (n, nrhs);
   for (j = 0; j < nrhs; j++)
     for (i = 0; i < n; i++)
       retval.elem (i, j) = result.elem (i, j);
 
   delete [] tmp_data;
   delete [] s;
@@ -1348,18 +1349,18 @@ ComplexMatrix::lssolve (const ComplexCol
     lwork = 2*n + (nrhs > m ? nrhs : m);
 
   Complex *work = new Complex [lwork];
 
   int lrwork = (5 * (m < n ? m : n)) - 4;
   lrwork = lrwork > 1 ? lrwork : 1;
   double *rwork = new double [lrwork];
 
-  F77_FCN (zgelss) (m, n, nrhs, tmp_data, m, presult, nrr, s,
-		    rcond, rank, work, lwork, rwork, info);
+  F77_FCN (zgelss, ZGELSS) (m, n, nrhs, tmp_data, m, presult, nrr, s,
+			    rcond, rank, work, lwork, rwork, info);
 
   ComplexColumnVector retval (n);
   for (i = 0; i < n; i++)
     retval.elem (i) = result.elem (i);
 
   delete [] tmp_data;
   delete [] s;
   delete [] work;
@@ -1396,18 +1397,18 @@ operator * (const ComplexColumnVector& v
       return ComplexMatrix ();
     }
 
   if (len == 0)
     return ComplexMatrix (len, len, 0.0);
 
   Complex *c = new Complex [len * a_len];
 
-  F77_FCN (zgemm) ("N", "N", len, a_len, 1, 1.0, v.data (), len,
-		   a.data (), 1, 0.0, c, len, 1L, 1L);
+  F77_FCN (zgemm, ZGEMM) ("N", "N", len, a_len, 1, 1.0, v.data (),
+			  len, a.data (), 1, 0.0, c, len, 1L, 1L);
 
   return ComplexMatrix (c, len, a_len);
 }
 
 // diagonal matrix by scalar -> matrix operations
 
 ComplexMatrix
 operator + (const DiagMatrix& a, const Complex& s)
@@ -2440,18 +2441,18 @@ operator * (const ComplexMatrix& m, cons
   if (nr == 0 || nc == 0 || a_nc == 0)
     return ComplexMatrix (nr, nc, 0.0);
 
   int ld  = nr;
   int lda = a.rows ();
 
   Complex *c = new Complex [nr*a_nc];
 
-  F77_FCN (zgemm) ("N", "N", nr, a_nc, nc, 1.0, m.data (),
-		   ld, a.data (), lda, 0.0, c, nr, 1L, 1L);
+  F77_FCN (zgemm, ZGEMM) ("N", "N", nr, a_nc, nc, 1.0, m.data (), ld,
+			  a.data (), lda, 0.0, c, nr, 1L, 1L);
 
   return ComplexMatrix (c, nr, a_nc);
 }
 
 ComplexMatrix
 product (const ComplexMatrix& m, const Matrix& a)
 {
   int nr = m.rows ();
diff --git a/liboctave/CRowVector.cc b/liboctave/CRowVector.cc
--- a/liboctave/CRowVector.cc
+++ b/liboctave/CRowVector.cc
@@ -33,20 +33,21 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
-  int F77_FCN (zgemv) (const char*, const int&, const int&,
-		       const Complex&, const Complex*, const int&,
-		       const Complex*, const int&, const Complex&,
-		       Complex*, const int&, long);
+  int F77_FCN (zgemv, ZGEMV) (const char*, const int&, const int&,
+			      const Complex&, const Complex*,
+			      const int&, const Complex*, const int&,
+			      const Complex&, Complex*, const int&,
+			      long);
 }
 
 /*
  * Complex Row Vector class
  */
 
 ComplexRowVector::ComplexRowVector (const RowVector& a)
   : MArray<Complex> (a.length ())
@@ -437,18 +438,18 @@ operator * (const ComplexRowVector& v, c
 
   int a_nr = a.rows ();
   int a_nc = a.cols ();
 
   int ld = a_nr;
 
   Complex *y = new Complex [len];
 
-  F77_FCN (zgemv) ("T", a_nc, a_nr, 1.0, a.data (), ld, v.data (), 1,
-		   0.0, y, 1, 1L); 
+  F77_FCN (zgemv, ZGEMV) ("T", a_nc, a_nr, 1.0, a.data (), ld,
+			  v.data (), 1, 0.0, y, 1, 1L); 
 
   return ComplexRowVector (y, len);
 }
 
 ComplexRowVector
 operator * (const RowVector& v, const ComplexMatrix& a)
 {
   ComplexRowVector tmp (v);
diff --git a/liboctave/CmplxAEPBAL.cc b/liboctave/CmplxAEPBAL.cc
--- a/liboctave/CmplxAEPBAL.cc
+++ b/liboctave/CmplxAEPBAL.cc
@@ -26,22 +26,24 @@ Software Foundation, 675 Mass Ave, Cambr
 #endif
 
 #include "CmplxAEPBAL.h"
 #include "dMatrix.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (zgebal) (const char*, const int&, Complex*, const int&,
-                        int&, int&, double*, int&, long, long);
+  int F77_FCN (zgebal, ZGEBAL) (const char*, const int&, Complex*,
+				const int&, int&, int&, double*, int&,
+				long, long);
  
-  int F77_FCN (zgebak) (const char*, const char*, const int&, const int&,
-			const int&, double*, const int&, Complex*, 
-			const int&, int&, long, long);
+  int F77_FCN (zgebak, ZGEBAK) (const char*, const char*, const int&,
+				const int&, const int&, double*, const
+				int&, Complex*, const int&, int&,
+				long, long);
 }
 
 int
 ComplexAEPBALANCE::init (const ComplexMatrix& a, const char *balance_job)
 {
 
   int n = a.cols ();
 
@@ -51,27 +53,29 @@ ComplexAEPBALANCE::init (const ComplexMa
   int ilo;
   int ihi;
   double *scale = new double [n];
 
 // Copy matrix into local structure.
 
   balanced_mat = a;
 
-  F77_FCN (zgebal) (balance_job, n, balanced_mat.fortran_vec (),
-		    n, ilo, ihi, scale, info, 1L, 1L);
+  F77_FCN (zgebal, ZGEBAL) (balance_job, n,
+			    balanced_mat.fortran_vec (), n, ilo, ihi,
+			    scale, info, 1L, 1L);
 
 // Initialize balancing matrix to identity.
 
   balancing_mat = Matrix (n, n, 0.0);
   for (int i = 0; i < n; i++)
     balancing_mat (i, i) = 1.0;
 
-  F77_FCN (zgebak) (balance_job, "R", n, ilo, ihi, scale, n, 
-		    balancing_mat.fortran_vec (), n, info, 1L, 1L);
+  F77_FCN (zgebak, ZGEBAK) (balance_job, "R", n, ilo, ihi, scale, n, 
+			    balancing_mat.fortran_vec (), n, info, 1L,
+			    1L);
 
   delete [] scale;
 
   return info;
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/liboctave/CmplxCHOL.cc b/liboctave/CmplxCHOL.cc
--- a/liboctave/CmplxCHOL.cc
+++ b/liboctave/CmplxCHOL.cc
@@ -27,18 +27,18 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "CmplxCHOL.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (zpotrf) (const char*, const int&, Complex*, const int&,
-			int&, long);
+  int F77_FCN (zpotrf, ZPOTRF) (const char*, const int&, Complex*,
+				const int&, int&, long);
 }
 
 int
 ComplexCHOL::init (const ComplexMatrix& a)
 {
   int a_nr = a.rows ();
   int a_nc = a.cols ();
    if (a_nr != a_nc)
@@ -48,17 +48,17 @@ ComplexCHOL::init (const ComplexMatrix& 
        return -1;
      }
 
    int n = a_nc;
    int info;
 
    Complex *h = dup (a.data (), a.length ());
 
-   F77_FCN (zpotrf) ("U", n, h, n, info, 1L);
+   F77_FCN (zpotrf, ZPOTRF) ("U", n, h, n, info, 1L);
 
    chol_mat = ComplexMatrix (h, n, n);
 
 // If someone thinks of a more graceful way of doing this (or faster for
 // that matter :-)), please let me know!
 
   if (n > 1)
     for (int j = 0; j < a_nc; j++)
diff --git a/liboctave/CmplxHESS.cc b/liboctave/CmplxHESS.cc
--- a/liboctave/CmplxHESS.cc
+++ b/liboctave/CmplxHESS.cc
@@ -27,30 +27,33 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "CmplxHESS.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (zgebal) (const char*, const int&, Complex*, const int&,
-                        int&, int&, double*, int&, long, long);
+  int F77_FCN (zgebal, ZGEBAL) (const char*, const int&, Complex*,
+				const int&, int&, int&, double*, int&,
+				long, long);
  
-  int F77_FCN (zgehrd) (const int&, const int&, const int&, Complex*,
-                        const int&, Complex*, Complex*, const int&,
-                        int&, long, long);
+  int F77_FCN (zgehrd, ZGEHRD) (const int&, const int&, const int&,
+				Complex*, const int&, Complex*,
+				Complex*, const int&, int&, long,
+				long);
  
-  int F77_FCN (zunghr) (const int&, const int&, const int&, Complex*,
-                        const int&, Complex*, Complex*, const int&,
-                        int&, long, long);
+  int F77_FCN (zunghr, ZUNGHR) (const int&, const int&, const int&,
+				Complex*, const int&, Complex*,
+				Complex*, const int&, int&, long, long);
 
-  int F77_FCN (zgebak) (const char*, const char*, const int&, const int&,
-			const int&, double*, const int&, Complex*,
-			const int&, int&, long, long);
+  int F77_FCN (zgebak, ZGEBAK) (const char*, const char*, const int&,
+				const int&, const int&, double*,
+				const int&, Complex*, const int&,
+				int&, long, long);
 }
 
 int
 ComplexHESS::init (const ComplexMatrix& a)
 {
   int a_nr = a.rows ();
   int a_nc = a.cols ();
    if (a_nr != a_nc)
@@ -71,25 +74,29 @@ ComplexHESS::init (const ComplexMatrix& 
 
    Complex *h = dup (a.data (), a.length ());
 
    double *scale = new double [n];
    Complex *tau = new Complex [n-1];
    Complex *work = new Complex [lwork];
    Complex *z = new Complex [n*n];
 
-   F77_FCN (zgebal) (job, n, h, n, ilo, ihi, scale, info, 1L, 1L);
+   F77_FCN (zgebal, ZGEBAL) (job, n, h, n, ilo, ihi, scale, info, 1L,
+			     1L);
 
-   F77_FCN (zgehrd) (n, ilo, ihi, h, n, tau, work, lwork, info, 1L, 1L);
+   F77_FCN (zgehrd, ZGEHRD) (n, ilo, ihi, h, n, tau, work, lwork,
+			     info, 1L, 1L);
 
    copy (z, h, n*n);
 
-   F77_FCN (zunghr) (n, ilo, ihi, z, n, tau, work, lwork, info, 1L, 1L);
+   F77_FCN (zunghr, ZUNGHR) (n, ilo, ihi, z, n, tau, work, lwork,
+			     info, 1L, 1L);
 
-   F77_FCN (zgebak) (job, side, n, ilo, ihi, scale, n, z, n, info, 1L, 1L); 
+   F77_FCN (zgebak, ZGEBAK) (job, side, n, ilo, ihi, scale, n, z, n,
+			     info, 1L, 1L);
 
    hess_mat = ComplexMatrix (h, n, n);
    unitary_hess_mat = ComplexMatrix (z, n, n);
 
 // If someone thinks of a more graceful way of doing this (or faster for
 // that matter :-)), please let me know!
 
    if (n > 2)
diff --git a/liboctave/CmplxLU.cc b/liboctave/CmplxLU.cc
--- a/liboctave/CmplxLU.cc
+++ b/liboctave/CmplxLU.cc
@@ -27,18 +27,19 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "CmplxLU.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (zgesv) (const int&, const int&, Complex*, const int&,
-		       int*, Complex*, const int&, int&);
+  int F77_FCN (zgesv, ZGESV) (const int&, const int&, Complex*,
+			      const int&, int*, Complex*, const int&,
+			      int&);
 }
 
 ComplexLU::ComplexLU (const ComplexMatrix& a)
 {
   int a_nr = a.rows ();
   int a_nc = a.cols ();
   if (a_nr == 0 || a_nc == 0 || a_nr != a_nc)
     {
@@ -49,17 +50,17 @@ ComplexLU::ComplexLU (const ComplexMatri
   int n = a_nr;
 
   int *ipvt = new int [n];
   int *pvt = new int [n];
   Complex *tmp_data = dup (a.data (), a.length ());
   int info = 0;
   Complex *b;
 
-  F77_FCN (zgesv) (n, 0, tmp_data, n, ipvt, b, n, info);
+  F77_FCN (zgesv, ZGESV) (n, 0, tmp_data, n, ipvt, b, n, info);
 
   ComplexMatrix A_fact (tmp_data, n, n);
 
   int i;
 
   for (i = 0; i < n; i++)
     {
       ipvt[i] -= 1;
diff --git a/liboctave/CmplxQR.cc b/liboctave/CmplxQR.cc
--- a/liboctave/CmplxQR.cc
+++ b/liboctave/CmplxQR.cc
@@ -27,21 +27,23 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "CmplxQR.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (zgeqrf) (const int&, const int&, Complex*, const int&,
-			Complex*, Complex*, const int&, int&);
+  int F77_FCN (zgeqrf, ZGEQRF) (const int&, const int&, Complex*,
+				const int&, Complex*, Complex*,
+				const int&, int&); 
 
-  int F77_FCN (zungqr) (const int&, const int&, const int&, Complex*,
-			const int&, Complex*, Complex*, const int&, int&);
+  int F77_FCN (zungqr, ZUNGQR) (const int&, const int&, const int&,
+				Complex*, const int&, Complex*,
+				Complex*, const int&, int&);
 }
 
 ComplexQR::ComplexQR (const ComplexMatrix& a, QR::type qr_type)
 {
   int m = a.rows ();
   int n = a.cols ();
 
   if (m == 0 || n == 0)
@@ -61,17 +63,18 @@ ComplexQR::ComplexQR (const ComplexMatri
   if (m > n)
     {
       tmp_data = new Complex [m*m];
       copy (tmp_data, a.data (), a.length ());
     }
   else
     tmp_data = dup (a.data (), a.length ());
 
-  F77_FCN (zgeqrf) (m, n, tmp_data, m, tau, work, lwork, info);
+  F77_FCN (zgeqrf, ZGEQRF) (m, n, tmp_data, m, tau, work, lwork,
+			    info);
 
   delete [] work;
 
   if (qr_type == QR::raw)
     {
       for (int j = 0; j < min_mn; j++)
 	{
 	  int limit = j < min_mn - 1 ? j : min_mn - 1;
@@ -98,17 +101,18 @@ ComplexQR::ComplexQR (const ComplexMatri
 	  int limit = j < min_mn-1 ? j : min_mn-1;
 	  for (int i = 0; i <= limit; i++)
 	    r.elem (i, j) = tmp_data[m*j+i];
 	}
 
       lwork = 32*m;
       work = new Complex[lwork];
 
-      F77_FCN (zungqr) (m, m, min_mn, tmp_data, m, tau, work, lwork, info);
+      F77_FCN (zungqr, ZUNGQR) (m, m, min_mn, tmp_data, m, tau, work,
+				lwork, info);
 
       q = ComplexMatrix (tmp_data, m, m);
       q.resize (m, n2);
 
       delete [] tau;
       delete [] work;
     }
 }
diff --git a/liboctave/CmplxQRP.cc b/liboctave/CmplxQRP.cc
--- a/liboctave/CmplxQRP.cc
+++ b/liboctave/CmplxQRP.cc
@@ -29,21 +29,23 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "CmplxQRP.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (zgeqpf) (const int&, const int&, Complex*, const int&,
-			int*, Complex*, Complex*, double*, int&);
+  int F77_FCN (zgeqpf, ZGEQPF) (const int&, const int&, Complex*,
+				const int&, int*, Complex*, Complex*,
+				double*, int&);
 
-  int F77_FCN (zungqr) (const int&, const int&, const int&, Complex*,
-			const int&, Complex*, Complex*, const int&, int&);
+  int F77_FCN (zungqr, ZUNGQR) (const int&, const int&, const int&,
+				Complex*, const int&, Complex*,
+				Complex*, const int&, int&);
 }
 
 // It would be best to share some of this code with ComplexQR class...
 
 ComplexQRP::ComplexQRP (const ComplexMatrix& a, QR::type qr_type)
 {
   assert (qr_type != QR::raw);
 
@@ -78,17 +80,18 @@ ComplexQRP::ComplexQRP (const ComplexMat
   int *jpvt = new int[n];
 
 // Clear Pivot vector (code to enforce a certain permutation would go
 // here...)
 
   for (int i = 0; i < n; i++)
     jpvt[i] = 0;      
 
-  F77_FCN (zgeqpf) (m, n, tmp_data, m, jpvt, tau, work, rwork, info);
+  F77_FCN (zgeqpf, ZGEQPF) (m, n, tmp_data, m, jpvt, tau, work, rwork,
+			    info);
 
 // Form Permutation matrix (if economy is requested, return the
 // indices only!)
 
   if (qr_type == QR::economy && m > n)
     {
       p.resize (1, n, 0.0);
       for (int j = 0; j < n; j++)
@@ -121,17 +124,18 @@ ComplexQRP::ComplexQRP (const ComplexMat
       int limit = j < min_mn-1 ? j : min_mn-1;
       for (int i = 0; i <= limit; i++)
 	r.elem (i, j) = tmp_data[m*j+i];
     }
 
   lwork = 32*m;
   work = new Complex[lwork];
 
-  F77_FCN (zungqr) (m, m, min_mn, tmp_data, m, tau, work, lwork, info);
+  F77_FCN (zungqr, ZUNGQR) (m, m, min_mn, tmp_data, m, tau, work,
+			    lwork, info);
 
   q = ComplexMatrix (tmp_data, m, m);
   q.resize (m, n2);
 
   delete [] tau;
   delete [] work;
 }
 
diff --git a/liboctave/CmplxSCHUR.cc b/liboctave/CmplxSCHUR.cc
--- a/liboctave/CmplxSCHUR.cc
+++ b/liboctave/CmplxSCHUR.cc
@@ -27,21 +27,23 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "CmplxSCHUR.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (zgeesx) (const char*, const char*, int (*)(const Complex&),
-			const char*, const int&, Complex*, const int&,
-			int&, Complex*, Complex*, const int&, double&,
-			double&, Complex*, const int&, double*, int*,
-			int&, long, long);
+  int F77_FCN (zgeesx, ZGEESX) (const char*, const char*,
+				int (*)(const Complex&), 
+				const char*, const int&, Complex*,
+				const int&, int&, Complex*, Complex*,
+				const int&, double&, double&,
+				Complex*, const int&, double*, int*,
+				int&, long, long);
 }
 
 static int
 complex_select_ana (const Complex& a)
 {
   return a.real () < 0.0;
 }
 
@@ -90,31 +92,34 @@ ComplexSCHUR::init (const ComplexMatrix&
   Complex *s = dup (a.data (), a.length ());
 
   Complex *work = new Complex [lwork];
   Complex *q = new Complex [n*n];
   Complex *w = new Complex [n];
 
   if (*ord == 'A' || *ord == 'a')
     {
-      F77_FCN (zgeesx) (jobvs, sort, complex_select_ana, sense,
-			n, s, n, sdim, w, q, n, rconde, rcondv,
-			work, lwork, rwork, bwork, info, 1L, 1L);
+      F77_FCN (zgeesx, ZGEESX) (jobvs, sort, complex_select_ana,
+				sense, n, s, n, sdim, w, q, n, rconde,
+				rcondv, work, lwork, rwork, bwork,
+				info, 1L, 1L);
     }
   else if (*ord == 'D' || *ord == 'd')
     {
-      F77_FCN (zgeesx) (jobvs, sort, complex_select_dig, sense,
-			n, s, n, sdim, w, q, n, rconde, rcondv,
-			work, lwork, rwork, bwork, info, 1L, 1L);
+      F77_FCN (zgeesx, ZGEESX) (jobvs, sort, complex_select_dig,
+				sense, n, s, n, sdim, w, q, n, rconde,
+				rcondv, work, lwork, rwork, bwork,
+				info, 1L, 1L);
     }
   else
     {
-      F77_FCN (zgeesx) (jobvs, sort, (void *) 0, sense, n, s,
-			n, sdim, w, q, n, rconde, rcondv, work,
-			lwork, rwork, bwork, info, 1L, 1L);
+      F77_FCN (zgeesx, ZGEESX) (jobvs, sort, (void *) 0, sense, n, s,
+				n, sdim, w, q, n, rconde, rcondv,
+				work, lwork, rwork, bwork, info, 1L,
+				1L);
     }
 
   schur_mat = ComplexMatrix (s, n, n);
   unitary_mat = ComplexMatrix (q, n, n);
 
   delete [] w;
   delete [] work;
   delete [] rwork;
diff --git a/liboctave/CmplxSVD.cc b/liboctave/CmplxSVD.cc
--- a/liboctave/CmplxSVD.cc
+++ b/liboctave/CmplxSVD.cc
@@ -26,20 +26,22 @@ Software Foundation, 675 Mass Ave, Cambr
 #endif
 
 #include "CmplxSVD.h"
 #include "mx-inlines.cc"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (zgesvd) (const char*, const char*, const int&,
-			const int&, Complex*, const int&, double*,
-			Complex*, const int&, Complex*, const int&,
-			Complex*, const int&, double*, int&, long, long);
+  int F77_FCN (zgesvd, ZGESVD) (const char*, const char*, const int&,
+				const int&, Complex*, const int&,
+				double*, Complex*, const int&,
+				Complex*, const int&, Complex*,
+				const int&, double*, int&, long,
+				long);
 }
 
 int
 ComplexSVD::init (const ComplexMatrix& a, SVD::type svd_type)
 {
   int info;
 
   int m = a.rows ();
@@ -69,18 +71,19 @@ ComplexSVD::init (const ComplexMatrix& a
   Complex *vt = new Complex[nrow_vt * n];
 
   int lwork = 2*min_mn + max_mn;
   Complex *work = new Complex[lwork];
 
   int lrwork = 5*max_mn;
   double *rwork = new double[lrwork];
 
-  F77_FCN (zgesvd) (jobu, jobv, m, n, tmp_data, m, s_vec, u, m,
-		    vt, nrow_vt, work, lwork, rwork, info, 1L, 1L);
+  F77_FCN (zgesvd, ZGESVD) (jobu, jobv, m, n, tmp_data, m, s_vec, u,
+			    m, vt, nrow_vt, work, lwork, rwork, info,
+			    1L, 1L);
 
   left_sm = ComplexMatrix (u, m, ncol_u);
   sigma = DiagMatrix (s_vec, nrow_s, ncol_s);
   ComplexMatrix vt_m (vt, nrow_vt, n);
   right_sm = vt_m.hermitian ();
 
   delete [] tmp_data;
   delete [] work;
diff --git a/liboctave/CollocWt.cc b/liboctave/CollocWt.cc
--- a/liboctave/CollocWt.cc
+++ b/liboctave/CollocWt.cc
@@ -28,21 +28,23 @@ Software Foundation, 675 Mass Ave, Cambr
 #include <iostream.h>
 
 #include "CollocWt.h"
 #include "f77-uscore.h"
 #include "lo-error.h"
 
 extern "C"
 {
-  int F77_FCN (jcobi) (int&, int&, int&, int&, double&, double&,
-		       double*, double*, double*, double*); 
+  int F77_FCN (jcobi, JCOBI) (int&, int&, int&, int&, double&,
+			      double&, double*, double*, double*,
+			      double*);
 
-  int F77_FCN (dfopr) (int&, int&, int&, int&, int&, int&,
-		       double*, double*, double*, double*, double*);
+  int F77_FCN (dfopr, DFOPR) (int&, int&, int&, int&, int&, int&,
+			      double*, double*, double*, double*,
+			      double*);
 }
 
 // Error handling.
 
 void
 CollocWt::error (const char* msg)
 {
   (*current_liboctave_error_handler) ("fatal CollocWt error: %s", msg);
@@ -270,52 +272,52 @@ CollocWt::init (void)
   q.resize (nt);
   A.resize (nt, nt);
   B.resize (nt, nt);
 
   double *pr = r.fortran_vec ();
 
 // Compute roots.
 
-  F77_FCN (jcobi) (nt, n, inc_left, inc_right, Alpha, Beta,
-		   dif1, dif2, dif3, pr);
+  F77_FCN (jcobi, JCOBI) (nt, n, inc_left, inc_right, Alpha, Beta,
+			  dif1, dif2, dif3, pr);
 
   int id;
   int i, j;
 
 // First derivative weights.
 
   id = 1;
   for (i = 1; i <= nt; i++)
     {
-      F77_FCN (dfopr) (nt, n, inc_left, inc_right, i, id, dif1,
-		       dif2, dif3, pr, vect); 
+      F77_FCN (dfopr, DFOPR) (nt, n, inc_left, inc_right, i, id, dif1,
+			      dif2, dif3, pr, vect); 
 
       for (j = 0; j < nt; j++)
 	A (i-1, j) = vect[j];
     }
 
 // Second derivative weights.
 
   id = 2;
   for (i = 1; i <= nt; i++)
     {
-      F77_FCN (dfopr) (nt, n, inc_left, inc_right, i, id, dif1,
-		       dif2, dif3, pr, vect); 
+      F77_FCN (dfopr, DFOPR) (nt, n, inc_left, inc_right, i, id, dif1,
+			      dif2, dif3, pr, vect); 
 
       for (j = 0; j < nt; j++)
 	B (i-1, j) = vect[j];
     }
 
 // Gaussian quadrature weights.
 
   id = 3;
   double *pq = q.fortran_vec ();
-  F77_FCN (dfopr) (nt, n, inc_left, inc_right, i, id, dif1,
-		   dif2, dif3, pr, pq);
+  F77_FCN (dfopr, DFOPR) (nt, n, inc_left, inc_right, i, id, dif1,
+			  dif2, dif3, pr, pq);
 
   delete [] dif1;
   delete [] dif2;
   delete [] dif3;
   delete [] vect;
 
   initialized = 1;
 }
diff --git a/liboctave/DASSL.cc b/liboctave/DASSL.cc
--- a/liboctave/DASSL.cc
+++ b/liboctave/DASSL.cc
@@ -26,24 +26,27 @@ Software Foundation, 675 Mass Ave, Cambr
 #endif
 
 #include "DAE.h"
 #include "f77-uscore.h"
 #include "lo-error.h"
 
 extern "C"
 {
-  int F77_FCN (ddassl) (int (*)(const double&, double*, double*,
-				double*, int&, double*, int*),
-			const int&, double&, double*, double*,
-			double&, const int*, const double&,
-			const double&, int&, double*, const int&, 
-			int*, const int&, const double*, const int*,
-			int (*)(const double&, double*, double*,
-				double*, const double&, double*, int*));
+  int F77_FCN (ddassl, DDASSL) (int (*)(const double&, double*,
+					double*, double*, int&,
+					double*, int*),
+				const int&, double&, double*, double*,
+				double&, const int*, const double&,
+				const double&, int&, double*,
+				const int&, int*, const int&,
+				const double*, const int*, 
+				int (*)(const double&, double*,
+					double*, double*, const
+					double&, double*, int*));
 }
 
 static DAEFunc::DAERHSFunc user_fun;
 static DAEFunc::DAEJacFunc user_jac;
 static int nn;
 
 DAE::DAE (void)
 {
@@ -295,19 +298,19 @@ DAE::integrate (double tout)
   if (restart)
     {
       restart = 0;
       info[0] = 0;
     }
 
 // again:
 
-  F77_FCN (ddassl) (ddassl_f, n, t, px, pxdot, tout, info,
-		    rel_tol, abs_tol, idid, rwork, lrw, iwork,
-		    liw, dummy, idummy, ddassl_j);
+  F77_FCN (ddassl, DDASSL) (ddassl_f, n, t, px, pxdot, tout, info,
+			    rel_tol, abs_tol, idid, rwork, lrw, iwork,
+			    liw, dummy, idummy, ddassl_j);
 
   switch (idid)
     {
     case 1: // A step was successfully taken in the
 	    // intermediate-output mode. The code has not yet reached
 	    // TOUT.
       break;
     case 2: // The integration to TSTOP was successfully completed
diff --git a/liboctave/EIG.cc b/liboctave/EIG.cc
--- a/liboctave/EIG.cc
+++ b/liboctave/EIG.cc
@@ -27,25 +27,27 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "EIG.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (dgeev) (const char*, const char*, const int&, double*,
-		       const int&, double*, double*, double*,
-		       const int&, double*, const int&, double*,
-		       const int&, int&, long, long);
+  int F77_FCN (dgeev, DGEEV) (const char*, const char*, const int&,
+			      double*, const int&, double*, double*,
+			      double*, const int&, double*,
+			      const int&, double*, const int&, int&,
+			      long, long);
 
-  int F77_FCN (zgeev) (const char*, const char*, const int&, Complex*,
-		       const int&, Complex*, Complex*, const int&,
-		       Complex*, const int&, Complex*, const int&,
-		       double*, int&, long, long);
+  int F77_FCN (zgeev, ZGEEV) (const char*, const char*, const int&,
+			      Complex*, const int&, Complex*,
+			      Complex*, const int&, Complex*,
+			      const int&, Complex*, const int&,
+			      double*, int&, long, long);
 }
 
 int
 EIG::init (const Matrix& a)
 {
   int a_nr = a.rows ();
   if (a_nr != a.cols ())
     {
@@ -63,18 +65,18 @@ EIG::init (const Matrix& a)
   Matrix vr (n, n);
   double *pvr = vr.fortran_vec ();
   int lwork = 8*n;
   double *work = new double[lwork];
 
   double *dummy;
   int idummy = 1;
 
-  F77_FCN (dgeev) ("N", "V", n, tmp_data, n, wr, wi, dummy,
-		   idummy, pvr, n, work, lwork, info, 1L, 1L);
+  F77_FCN (dgeev, DGEEV) ("N", "V", n, tmp_data, n, wr, wi, dummy,
+			  idummy, pvr, n, work, lwork, info, 1L, 1L);
 
   lambda.resize (n);
   v.resize (n, n);
 
   for (int j = 0; j < n; j++)
     {
       if (wi[j] == 0.0)
 	{
@@ -135,18 +137,18 @@ EIG::init (const ComplexMatrix& a)
 
   int lwork = 8*n;
   Complex *work = new Complex[lwork];
   double *rwork = new double[4*n];
 
   Complex *dummy;
   int idummy = 1;
 
-  F77_FCN (zgeev) ("N", "V", n, tmp_data, n, pw, dummy, idummy, pvr,
-		   n, work, lwork, rwork, info, 1L, 1L);
+  F77_FCN (zgeev, ZGEEV) ("N", "V", n, tmp_data, n, pw, dummy, idummy,
+			  pvr, n, work, lwork, rwork, info, 1L, 1L);
 
   delete [] tmp_data;
   delete [] work;
   delete [] rwork;
 
   return info;
 }
 
diff --git a/liboctave/LSODE.cc b/liboctave/LSODE.cc
--- a/liboctave/LSODE.cc
+++ b/liboctave/LSODE.cc
@@ -30,24 +30,25 @@ Software Foundation, 675 Mass Ave, Cambr
 #include <iostream.h>
 
 #include "ODE.h"
 #include "f77-uscore.h"
 #include "lo-error.h"
 
 extern "C"
 {
-  int F77_FCN (lsode) (int (*)(const int&, const double&, double*,
-			       double*, int&),
-		       int&, double*, double&, double&, int&,
-		       double&, double&, int&, int&, int&,
-		       double*, int&, int*, int&,
-		       int (*)(const int&, const double&, double*,
-			       const int&, const int&, double*,
-			       const int&), int&);
+  int F77_FCN (lsode, LSODE) (int (*)(const int&, const double&,
+				      double*, double*, int&),
+			      int&, double*, double&, double&, int&,
+			      double&, double&, int&, int&, int&,
+			      double*, int&, int*, int&,
+			      int (*)(const int&, const double&,
+				      double*, const int&, const int&,
+				      double*, const int&),
+			      int&);
 }
 
 static ODEFunc::ODERHSFunc user_fun;
 static ODEFunc::ODEJacFunc user_jac;
 static ColumnVector *tmp_x;
 
 ODE::ODE (void)
 {
@@ -238,17 +239,17 @@ ODE::integrate (double tout)
   if (restart)
     {
       restart = 0;
       istate = 1;
     }
 
  again:
 
-  (void) F77_FCN (lsode) (lsode_f, n, xp, t, tout, itol, rel_tol,
+  F77_FCN (lsode, LSODE) (lsode_f, n, xp, t, tout, itol, rel_tol,
 			  abs_tol, itask, istate, iopt, rwork, lrw,
 			  iwork, liw, lsode_j, method_flag);
 
   switch (istate)
     {
     case -13: // Return requested in user-supplied function.
     case -6: // error weight became zero during problem. (solution
 	     // component i vanished, and atol or atol(i) = 0.)
diff --git a/liboctave/NLEqn.cc b/liboctave/NLEqn.cc
--- a/liboctave/NLEqn.cc
+++ b/liboctave/NLEqn.cc
@@ -30,23 +30,26 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "NLEqn.h"
 #include "dMatrix.h"
 #include "f77-uscore.h"
 #include "lo-error.h"
 
 extern "C"
 {
-  int F77_FCN (hybrd1) (int (*)(int*, double*, double*, int*),
-			const int&, double*, double*, const double&,
-			int&, double*, const int&);
+  int F77_FCN (hybrd1, HYBRD1) (int (*)(int*, double*, double*, int*),
+				const int&, double*, double*,
+				const double&, int&, double*,
+				const int&);
 
-  int F77_FCN (hybrj1) (int (*)(int*, double*, double*, double*, int*, int*),
-			const int&, double*, double*, double*, const int&,
-			const double&, int&, double*, const int&);
+  int F77_FCN (hybrj1) (int (*)(int*, double*, double*, double*, int*,
+				int*),
+			const int&, double*, double*, double*,
+			const int&, const double&, int&, double*,
+			const int&);
 }
 
 static nonlinear_fcn user_fun;
 static jacobian_fcn user_jac;
 
 // error handling
 
 void
@@ -222,28 +225,29 @@ NLEqn::solve (int& info)
   user_jac = jac;
 
   if (jac)
     {
       int lwa = (n*(n+13))/2;
       double *wa = new double [lwa];
       double *fjac = new double [n*n];
 
-      F77_FCN (hybrj1) (hybrj1_fcn, n, px, fvec, fjac, n, tol, info,
-			wa, lwa);
+      F77_FCN (hybrj1, HYBRJ1) (hybrj1_fcn, n, px, fvec, fjac, n, tol,
+				info, wa, lwa);
 
       delete [] wa;
       delete [] fjac;
     }
   else
     {
       int lwa = (n*(3*n+13))/2;
       double *wa = new double [lwa];
 
-      F77_FCN (hybrd1) (hybrd1_fcn, n, px, fvec, tol, info, wa, lwa);
+      F77_FCN (hybrd1, HYBRD1) (hybrd1_fcn, n, px, fvec, tol, info,
+				wa, lwa);
 
       delete [] wa;
     }
 
   Vector retval;
 
   if (info >= 0)
     {
diff --git a/liboctave/NPSOL.cc b/liboctave/NPSOL.cc
--- a/liboctave/NPSOL.cc
+++ b/liboctave/NPSOL.cc
@@ -35,28 +35,28 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "dMatrix.h"
 
 #include "NPSOL.h"
 #include "f77-uscore.h"
 #include "sun-utils.h"
 
 extern "C"
 {
-  int F77_FCN (npoptn) (const char*, long);
+  int F77_FCN (npoptn, NPOPTN) (const char*, long);
 
-  int F77_FCN (npsol) (int&, int&, int&, int&, int&, int&, double*,
-		       double*, double*,
-		       int (*)(int&, const int&, const int&, const
-			       int&, int*, double*, double*, double*,
-			       int*),
-		       int (*)(int&, const int&, double*, double*,
-			       double*, int*),
-		       int&, int&, int*, double*, double*, double*,
-		       double&, double*, double*, double*, int*, int&,
-		       double*, int&);
+  int F77_FCN (npsol, NPSOL) (int&, int&, int&, int&, int&, int&,
+			      double*, double*, double*,
+			      int (*)(int&, const int&, const int&,
+				      const int&, int*, double*,
+				      double*, double*, int*),
+			      int (*)(int&, const int&, double*,
+				      double*, double*, int*),
+			      int&, int&, int*, double*, double*,
+			      double*, double&, double*, double*,
+			      double*, int*, int&, double*, int&);
 }
 
 // XXX FIXME XXX -- would be nice to not have to have this global
 // variable.
 // Nonzero means an error occurred in the calculation of the objective
 // function, and the user wants us to quit.
 int npsol_objective_error = 0;
 
@@ -283,32 +283,33 @@ NPSOL::minimize (double& objf, int& info
   user_phi  = phi.objective_function ();
   user_grad = phi.gradient_function ();
   user_g    = nlc.function ();
   user_jac  = nlc.jacobian_function ();
 
   pass_options_to_npsol ();
 
   if (! user_jac && ! user_grad)
-    F77_FCN (npoptn) ("Derivative Level 0", 18L);
+    F77_FCN (npoptn, NPOPTN) ("Derivative Level 0", 18L);
   else if (! user_jac && user_grad)
-    F77_FCN (npoptn) ("Derivative Level 1", 18L);
+    F77_FCN (npoptn, NPOPTN) ("Derivative Level 1", 18L);
   else if (user_jac && ! user_grad)
-    F77_FCN (npoptn) ("Derivative Level 2", 18L);
+    F77_FCN (npoptn, NPOPTN) ("Derivative Level 2", 18L);
   else if (user_jac && user_grad)
-    F77_FCN (npoptn) ("Derivative Level 3", 18L);
+    F77_FCN (npoptn, NPOPTN) ("Derivative Level 3", 18L);
 
   int attempt = 0;
   while (attempt++ < 5)
     {
 
-      F77_FCN (npsol) (n, nclin, ncnln, nrowa, nrowj, nrowr, pclin,
-		       clow, cup, npsol_confun, npsol_objfun, inform,
-		       iter, istate, c, cjac, pclambda, objf, objgrd, r,
-		       px, iw, leniw, w, lenw);
+      F77_FCN (npsol, NPSOL) (n, nclin, ncnln, nrowa, nrowj, nrowr,
+			      pclin, clow, cup, npsol_confun,
+			      npsol_objfun, inform, iter, istate, c,
+			      cjac, pclambda, objf, objgrd, r, px, iw,
+			      leniw, w, lenw);
 
       if (inform == 6 || inform == 1)
 	continue;
       else
 	break;
     }
 
 // Clean up.
@@ -687,18 +688,18 @@ int
 NPSOL_options::verify_level (void) const
 {
   return x_verify_level;
 }
 
 void
 NPSOL_options::pass_options_to_npsol (void)
 {
-  F77_FCN (npoptn) ("Nolist", 6L);
-  F77_FCN (npoptn) ("Defaults", 8L);
+  F77_FCN (npoptn, NPOPTN) ("Nolist", 6L);
+  F77_FCN (npoptn, NPOPTN) ("Defaults", 8L);
 
   if (x_central_difference_interval > 0.0)
     set_option ("Central Difference", x_central_difference_interval);
 
   set_option ("Crash Tolerance", x_crash_tolerance);
 
   if (x_difference_interval > 0.0)
     set_option ("Difference Interval", x_difference_interval);
@@ -744,28 +745,28 @@ NPSOL_options::pass_options_to_npsol (vo
 
 void
 NPSOL_options::set_option (const char *key, int opt)
 {
   ostrstream buf;
   buf << key << " " << opt << ends;
   char *command = buf.str ();
   size_t len = strlen (command);
-  F77_FCN (npoptn) (command, (long) len);
+  F77_FCN (npoptn, NPOPTN) (command, (long) len);
   delete [] command;
 }
 
 void
 NPSOL_options::set_option (const char *key, double opt)
 {
   ostrstream buf;
   buf << key << " " << opt << ends;
   char *command = buf.str ();
   size_t len = strlen (command);
-  F77_FCN (npoptn) (command, (long) len);
+  F77_FCN (npoptn, NPOPTN) (command, (long) len);
   delete [] command;
 }
 
 #endif /* NPSOL_MISSING */
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/QLD.cc b/liboctave/QLD.cc
--- a/liboctave/QLD.cc
+++ b/liboctave/QLD.cc
@@ -31,20 +31,20 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "dMatrix.h"
 #include "dColVector.h"
 #include "dRowVector.h"
 #include "QLD.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (qld) (int&, int&, int&, int&, int&, double*, double*,
-		     double*, double*, double*, double*, double*,
-		     double*, int&, int&, int&, double*, int&, int*,
-		     int&);
+  int F77_FCN (qld, QLD) (int&, int&, int&, int&, int&, double*,
+			  double*, double*, double*, double*, double*,
+			  double*, double*, int&, int&, int&, double*,
+			  int&, int*, int&);
 }
 
 Vector
 QLD::minimize (double& objf, int& inform)
 {
   int n = x.capacity ();
 
   Matrix A1 = lc.eq_constraint_matrix ();
@@ -102,18 +102,19 @@ QLD::minimize (double& objf, int& inform
       xub.resize (n, 1.0e30);
     }
   double *pxl = xlb.fortran_vec ();
   double *pxu = xub.fortran_vec ();
 
   int mmax = m > 0 ? m : 1;
 
   iprint = 1;
-  F77_FCN (qld) (m, me, mmax, n, n, ph, pc, pa, pb, pxl, pxu, px,
-		 u, iout, inform, iprint, war, lwar, iwar, liwar);
+  F77_FCN (qld, QLD) (m, me, mmax, n, n, ph, pc, pa, pb, pxl, pxu, px,
+		      u, iout, inform, iprint, war, lwar, iwar,
+		      liwar);
 
   delete [] war;
   delete [] iwar;
   delete [] u;
 
   objf = (x.transpose () * H * x) / 2.0;
   if (c.capacity () > 0)
     objf += c.transpose () * x;
diff --git a/liboctave/QPSOL.cc b/liboctave/QPSOL.cc
--- a/liboctave/QPSOL.cc
+++ b/liboctave/QPSOL.cc
@@ -30,43 +30,47 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #ifndef QPSOL_MISSING
 
 #include "QPSOL.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (qpsol) (int&, int&, int&, int&, int&, int&, int&, int&,
-		       double&, double*, double*, double*, double*,
-		       double*, double*,
-		       int (*)(const int&, const int&, const int&,
-			       const int&, double*, double*, double*),
-		       int&, int&, int&, int*, double*, int&, int&,
-		       double&, double*, int*, int&, double*, int&);
+  int F77_FCN (qpsol, QPSOL) (int&, int&, int&, int&, int&, int&,
+			      int&, int&, double&, double*, double*,
+			      double*, double*, double*, double*,
+			      int (*)(const int&, const int&,
+				      const int&, const int&, double*,
+				      double*, double*),
+			      int&, int&, int&, int*, double*, int&,
+			      int&, double&, double*, int*, int&,
+			      double*, int&);
 
-  int F77_FCN (dgemv) (const char*, const int&, const int&,
-		       const double&, const double*, const int&,
-		       const double*, const int&, const double&,
-		       double*, const int&, long);
+  int F77_FCN (dgemv, DGEMV) (const char*, const int&, const int&,
+			      const double&, const double*,
+			      const int&, const double*, const int&,
+			      const double&, double*, const int&,
+			      long);
 }
 
 int
 qphess (const int& n, const int& nrowh, const int& ncolh,
 	const int& jthcol, double *hess, double *x, double *hx)
 {
   if (jthcol > 0)
     {
       int hp = (jthcol - 1) * nrowh;
       for (int i = 0; i < n; i++)
 	hx[i] = hess[hp+i];
     }
   else
     {
-      F77_FCN (dgemv) ("N", n, n, 1.0, hess, n, x, 1, 0.0, hx, 1, 1L);
+      F77_FCN (dgemv, DGEMV) ("N", n, n, 1.0, hess, n, x, 1, 0.0, hx,
+			      1, 1L);
     }
 
   return 0;
 }
 
 Vector
 QPSOL::minimize (double& objf, int& inform, Vector& lambda)
 {
@@ -144,20 +148,21 @@ QPSOL::minimize (double& objf, int& info
   if (lp == 0 || nclin >= n)
     lenw = 2*n*(n + 2) + nclin + 2*ncon;
   else
     lenw = 2*ncon*(1 + ncon) + 4*n + nclin;
 
   int *iw = new int [leniw];
   double *w = new double [lenw];
 
-  F77_FCN (qpsol) (itmax, msglvl, n, nclin, nctotl, ncon, n,
-		   n, bigbnd, pa, pbl, pbu, pc, featol, ph, qphess,
-		   cold, lp, orthog, istate, px, inform, iter,
-		   objf, pclambda, iw, leniw, w, lenw);
+  F77_FCN (qpsol, QPSOL) (itmax, msglvl, n, nclin, nctotl, ncon, n,
+			  n, bigbnd, pa, pbl, pbu, pc, featol, ph,
+			  qphess, cold, lp, orthog, istate, px,
+			  inform, iter, objf, pclambda, iw, leniw, w,
+			  lenw);
 
   delete [] pbl;
   delete [] pbu;
   delete [] featol;
   delete [] istate;
   delete [] iw;
   delete [] w;
 
diff --git a/liboctave/Quad.cc b/liboctave/Quad.cc
--- a/liboctave/Quad.cc
+++ b/liboctave/Quad.cc
@@ -37,26 +37,28 @@ static integrand_fcn user_fcn;
 // XXX FIXME XXX -- would be nice to not have to have this global
 // variable.
 // Nonzero means an error occurred in the calculation of the integrand
 // function, and the user wants us to quit.
 int quad_integration_error = 0;
 
 extern "C"
 {
-  int F77_FCN (dqagp) (const double (*)(double*, int&),
-		       const double&, const double&, const int&,
-		       const double*, const double&, const double&,
-		       double&, double&, int&, int&, const int&,
-		       const int&, int&, int*, double*);
+  int F77_FCN (dqagp, DQAGP) (const double (*)(double*, int&),
+			      const double&, const double&,
+			      const int&, const double*,
+			      const double&, const double&, double&,
+			      double&, int&, int&, const int&,
+			      const int&, int&, int*, double*);
 
-  int F77_FCN (dqagi) (const double (*)(double*, int&), const double&,
-		       const int&, const double&, const double&,
-		       double&, double&, int&, int&, const int&,
-		       const int&, int&, int*, double*); 
+  int F77_FCN (dqagi, DQAGI) (const double (*)(double*, int&),
+			      const double&, const int&,
+			      const double&, const double&, double&,
+			      double&, int&, int&, const int&,
+			      const int&, int&, int*, double*); 
 }
 
 Quad::Quad (integrand_fcn fcn)
 {
   f = fcn;
 }
 
 Quad::Quad (integrand_fcn fcn, double abs, double rel)
@@ -170,19 +172,20 @@ DefQuad::integrate (int& ier, int& neval
   int *iwork = new int [leniw];
   double *work = new double [lenw];
   user_fcn = f;
   int last;
 
   double abs_tol = absolute_tolerance ();
   double rel_tol = relative_tolerance ();
 
-  F77_FCN (dqagp) (user_function, lower_limit, upper_limit, npts,
-		   points, abs_tol, rel_tol, result, abserr,
-		   neval, ier, leniw, lenw, last, iwork, work);
+  F77_FCN (dqagp, DQAGP) (user_function, lower_limit, upper_limit,
+			  npts, points, abs_tol, rel_tol, result,
+			  abserr, neval, ier, leniw, lenw, last,
+			  iwork, work);
 
   delete [] iwork;
   delete [] work;
 
   return result;
 }
 
 IndefQuad::IndefQuad (integrand_fcn fcn) : Quad (fcn)
@@ -238,19 +241,19 @@ IndefQuad::integrate (int& ier, int& nev
     default:
       assert (0);
       break;
     }
 
   double abs_tol = absolute_tolerance ();
   double rel_tol = relative_tolerance ();
 
-  F77_FCN (dqagi) (user_function, bound, inf, abs_tol, rel_tol,
-		   result, abserr, neval, ier, leniw, lenw,
-		   last, iwork, work);
+  F77_FCN (dqagi, DQAGI) (user_function, bound, inf, abs_tol, rel_tol,
+			  result, abserr, neval, ier, leniw, lenw,
+			  last, iwork, work);
 
   delete [] iwork;
   delete [] work;
 
   return result;
 }
 
 Quad_options::Quad_options (void)
diff --git a/liboctave/dColVector.cc b/liboctave/dColVector.cc
--- a/liboctave/dColVector.cc
+++ b/liboctave/dColVector.cc
@@ -33,20 +33,21 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "mx-inlines.cc"
 #include "f77-uscore.h"
 #include "lo-error.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
-  int F77_FCN (dgemv) (const char*, const int&, const int&,
-		       const double&, const double*, const int&,
-		       const double*, const int&, const double&,
-		       double*, const int&, long);
+  int F77_FCN (dgemv, DGEMV) (const char*, const int&, const int&,
+			      const double&, const double*,
+			      const int&, const double*, const int&,
+			      const double&, double*, const int&,
+			      long);
 }
 
 /*
  * Column Vector class.
  */
 
 int
 ColumnVector::operator == (const ColumnVector& a) const
@@ -220,18 +221,18 @@ operator * (const Matrix& m, const Colum
 
   if (nr == 0 || nc == 0)
     return ColumnVector (0);
 
   int ld = nr;
 
   double *y = new double [nr];
 
-  F77_FCN (dgemv) ("N", nr, nc, 1.0, m.data (), ld, a.data (), 1, 0.0,
-		   y, 1, 1L);
+  F77_FCN (dgemv, DGEMV) ("N", nr, nc, 1.0, m.data (), ld, a.data (),
+			  1, 0.0, y, 1, 1L);
 
   return ColumnVector (y, nr);
 }
 
 // diagonal matrix by column vector -> column vector operations
 
 ColumnVector
 operator * (const DiagMatrix& m, const ColumnVector& a)
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -38,45 +38,48 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
-  int F77_FCN (dgemm) (const char*, const char*, const int&,
-		       const int&, const int&, const double&,
-		       const double*, const int&, const double*,
-		       const int&, const double&, double*, const int&,
-		       long, long);
+  int F77_FCN (dgemm, DGEMM) (const char*, const char*, const int&,
+			      const int&, const int&, const double&,
+			      const double*, const int&,
+			      const double*, const int&,
+			      const double&, double*, const int&,
+			      long, long);
 
-  int F77_FCN (dgeco) (double*, const int&, const int&, int*, double&,
-		       double*);
+  int F77_FCN (dgeco, DGECO) (double*, const int&, const int&, int*,
+			      double&, double*);
 
-  int F77_FCN (dgesl) (const double*, const int&, const int&,
-		       const int*, double*, const int&); 
+  int F77_FCN (dgesl, DGESL) (const double*, const int&, const int&,
+			      const int*, double*, const int&);
 
-  int F77_FCN (dgedi) (double*, const int&, const int&, const int*,
-		       double*, double*, const int&);
+  int F77_FCN (dgedi, DGEDI) (double*, const int&, const int&,
+			      const int*, double*, double*,
+			      const int&);
 
-  int F77_FCN (dgelss) (const int&, const int&, const int&, double*,
-			const int&, double*, const int&, double*,
-			double&, int&, double*, const int&, int&);
+  int F77_FCN (dgelss, DGELSS) (const int&, const int&, const int&,
+				double*, const int&, double*,
+				const int&, double*, double&, int&,
+				double*, const int&, int&);
 
 // Note that the original complex fft routines were not written for
 // double complex arguments.  They have been modified by adding an
 // implicit double precision (a-h,o-z) statement at the beginning of
 // each subroutine.
 
-  int F77_FCN (cffti) (const int&, Complex*);
+  int F77_FCN (cffti, CFFTI) (const int&, Complex*);
 
-  int F77_FCN (cfftf) (const int&, Complex*, Complex*);
+  int F77_FCN (cfftf, CFFTF) (const int&, Complex*, Complex*);
 
-  int F77_FCN (cfftb) (const int&, Complex*, Complex*);
+  int F77_FCN (cfftb, CFFTB) (const int&, Complex*, Complex*);
 }
 
 /*
  * Matrix class.
  */
 
 Matrix::Matrix (const DiagMatrix& a)
   : MArray2<double> (a.rows (), a.cols (), 0.0)
@@ -509,29 +512,29 @@ Matrix::inverse (int& info, double& rcon
     }
 
   info = 0;
 
   int *ipvt = new int [nr];
   double *z = new double [nr];
   double *tmp_data = dup (data (), len);
 
-  F77_FCN (dgeco) (tmp_data, nr, nc, ipvt, rcond, z);
+  F77_FCN (dgeco, DGECO) (tmp_data, nr, nc, ipvt, rcond, z);
 
   volatile double rcond_plus_one = rcond + 1.0;
   if (rcond_plus_one == 1.0)
     {
       info = -1;
       copy (tmp_data, data (), len);  // Restore matrix contents.
     }
   else
     {
       double *dummy;
 
-      F77_FCN (dgedi) (tmp_data, nr, nc, ipvt, dummy, z, 1);
+      F77_FCN (dgedi, DGEDI) (tmp_data, nr, nc, ipvt, dummy, z, 1);
     }
 
   delete [] ipvt;
   delete [] z;
 
   return Matrix (tmp_data, nr, nc);
 }
 
@@ -588,20 +591,20 @@ Matrix::fourier (void) const
       npts = nr;
       nsamples = nc;
     }
 
   int nn = 4*npts+15;
   Complex *wsave = new Complex [nn];
   Complex *tmp_data = make_complex (data (), length ());
 
-  F77_FCN (cffti) (npts, wsave);
+  F77_FCN (cffti, CFFTI) (npts, wsave);
 
   for (int j = 0; j < nsamples; j++)
-    F77_FCN (cfftf) (npts, &tmp_data[npts*j], wsave);
+    F77_FCN (cfftf, CFFTF) (npts, &tmp_data[npts*j], wsave);
 
   delete [] wsave;
 
   return ComplexMatrix (tmp_data, nr, nc);
 }
 
 ComplexMatrix
 Matrix::ifourier (void) const
@@ -619,20 +622,20 @@ Matrix::ifourier (void) const
       npts = nr;
       nsamples = nc;
     }
 
   int nn = 4*npts+15;
   Complex *wsave = new Complex [nn];
   Complex *tmp_data = make_complex (data (), length ());
 
-  F77_FCN (cffti) (npts, wsave);
+  F77_FCN (cffti, CFFTI) (npts, wsave);
 
   for (int j = 0; j < nsamples; j++)
-    F77_FCN (cfftb) (npts, &tmp_data[npts*j], wsave);
+    F77_FCN (cfftb, CFFTB) (npts, &tmp_data[npts*j], wsave);
 
   for (j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / (double) npts;
 
   delete [] wsave;
 
   return ComplexMatrix (tmp_data, nr, nc);
 }
@@ -653,37 +656,37 @@ Matrix::fourier2d (void) const
       npts = nr;
       nsamples = nc;
     }
 
   int nn = 4*npts+15;
   Complex *wsave = new Complex [nn];
   Complex *tmp_data = make_complex (data (), length ());
 
-  F77_FCN (cffti) (npts, wsave);
+  F77_FCN (cffti, CFFTI) (npts, wsave);
 
   for (int j = 0; j < nsamples; j++)
-    F77_FCN (cfftf) (npts, &tmp_data[npts*j], wsave);
+    F77_FCN (cfftf, CFFTF) (npts, &tmp_data[npts*j], wsave);
 
   delete [] wsave;
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
   wsave = new Complex [nn];
   Complex *row = new Complex[npts];
 
-  F77_FCN (cffti) (npts, wsave);
+  F77_FCN (cffti, CFFTI) (npts, wsave);
 
   for (j = 0; j < nsamples; j++)
     {
       for (int i = 0; i < npts; i++)
 	row[i] = tmp_data[i*nr + j];
 
-      F77_FCN (cfftf) (npts, row, wsave);
+      F77_FCN (cfftf, CFFTF) (npts, row, wsave);
 
       for (i = 0; i < npts; i++)
 	tmp_data[i*nr + j] = row[i];
     }
 
   delete [] wsave;
   delete [] row;
 
@@ -706,40 +709,40 @@ Matrix::ifourier2d (void) const
       npts = nr;
       nsamples = nc;
     }
 
   int nn = 4*npts+15;
   Complex *wsave = new Complex [nn];
   Complex *tmp_data = make_complex (data (), length ());
 
-  F77_FCN (cffti) (npts, wsave);
+  F77_FCN (cffti, CFFTI) (npts, wsave);
 
   for (int j = 0; j < nsamples; j++)
-    F77_FCN (cfftb) (npts, &tmp_data[npts*j], wsave);
+    F77_FCN (cfftb, CFFTB) (npts, &tmp_data[npts*j], wsave);
 
   delete [] wsave;
 
   for (j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / (double) npts;
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
   wsave = new Complex [nn];
   Complex *row = new Complex[npts];
 
-  F77_FCN (cffti) (npts, wsave);
+  F77_FCN (cffti, CFFTI) (npts, wsave);
 
   for (j = 0; j < nsamples; j++)
     {
       for (int i = 0; i < npts; i++)
 	row[i] = tmp_data[i*nr + j];
 
-      F77_FCN (cfftb) (npts, row, wsave);
+      F77_FCN (cfftb, CFFTB) (npts, row, wsave);
 
       for (i = 0; i < npts; i++)
 	tmp_data[i*nr + j] = row[i] / (double) npts;
     }
 
   delete [] wsave;
   delete [] row;
 
@@ -779,28 +782,28 @@ Matrix::determinant (int& info, double& 
   else
     {
       info = 0;
       int *ipvt = new int [nr];
 
       double *z = new double [nr];
       double *tmp_data = dup (data (), length ());
 
-      F77_FCN (dgeco) (tmp_data, nr, nr, ipvt, rcond, z);
+      F77_FCN (dgeco, DGECO) (tmp_data, nr, nr, ipvt, rcond, z);
 
       volatile double rcond_plus_one = rcond + 1.0;
       if (rcond_plus_one == 1.0)
 	{
 	  info = -1;
 	  retval = DET ();
 	}
       else
 	{
 	  double d[2];
-	  F77_FCN (dgedi) (tmp_data, nr, nr, ipvt, d, z, 10);
+	  F77_FCN (dgedi, DGEDI) (tmp_data, nr, nr, ipvt, d, z, 10);
 	  retval = DET (d);
 	}
 
       delete [] tmp_data;
       delete [] ipvt;
       delete [] z;
     }
 
@@ -837,30 +840,30 @@ Matrix::solve (const Matrix& b, int& inf
     }
 
   info = 0;
   int *ipvt = new int [nr];
 
   double *z = new double [nr];
   double *tmp_data = dup (data (), length ());
 
-  F77_FCN (dgeco) (tmp_data, nr, nr, ipvt, rcond, z);
+  F77_FCN (dgeco, DGECO) (tmp_data, nr, nr, ipvt, rcond, z);
 
   volatile double rcond_plus_one = rcond + 1.0;
   if (rcond_plus_one == 1.0)
     {
       info = -2;
     }
   else
     {
       double *result = dup (b.data (), b.length ());
 
       int b_nc = b.cols ();
       for (int j = 0; j < b_nc; j++)
-	F77_FCN (dgesl) (tmp_data, nr, nr, ipvt, &result[nr*j], 0);
+	F77_FCN (dgesl, DGESL) (tmp_data, nr, nr, ipvt, &result[nr*j], 0);
 
       retval = Matrix (result, b.rows (), b_nc);
     }
 
   delete [] tmp_data;
   delete [] ipvt;
   delete [] z;
 
@@ -917,30 +920,30 @@ Matrix::solve (const ColumnVector& b, in
     }
 
   info = 0;
   int *ipvt = new int [nr];
 
   double *z = new double [nr];
   double *tmp_data = dup (data (), length ());
 
-  F77_FCN (dgeco) (tmp_data, nr, nr, ipvt, rcond, z);
+  F77_FCN (dgeco, DGECO) (tmp_data, nr, nr, ipvt, rcond, z);
 
   volatile double rcond_plus_one = rcond + 1.0;
   if (rcond_plus_one == 1.0)
     {
       info = -2;
     }
   else
     {
       int b_len = b.length ();
 
       double *result = dup (b.data (), b_len);
 
-      F77_FCN (dgesl) (tmp_data, nr, nr, ipvt, result, 0);
+      F77_FCN (dgesl, DGESL) (tmp_data, nr, nr, ipvt, result, 0);
 
       retval = ColumnVector (result, b_len);
     }
 
   delete [] tmp_data;
   delete [] ipvt;
   delete [] z;
 
@@ -1016,18 +1019,18 @@ Matrix::lssolve (const Matrix& b, int& i
   int lwork;
   if (m < n)
     lwork = 3*m + (2*m > nrhs ? (2*m > n ? 2*m : n) : (nrhs > n ? nrhs : n));
   else
     lwork = 3*n + (2*n > nrhs ? (2*n > m ? 2*n : m) : (nrhs > m ? nrhs : m));
 
   double *work = new double [lwork];
 
-  F77_FCN (dgelss) (m, n, nrhs, tmp_data, m, presult, nrr, s, rcond,
-		    rank, work, lwork, info);
+  F77_FCN (dgelss, DGELSS) (m, n, nrhs, tmp_data, m, presult, nrr, s,
+			    rcond, rank, work, lwork, info);
 
   Matrix retval (n, nrhs);
   for (j = 0; j < nrhs; j++)
     for (i = 0; i < n; i++)
       retval.elem (i, j) = result.elem (i, j);
 
   delete [] tmp_data;
   delete [] s;
@@ -1103,18 +1106,18 @@ Matrix::lssolve (const ColumnVector& b, 
   int lwork;
   if (m < n)
     lwork = 3*m + (2*m > nrhs ? (2*m > n ? 2*m : n) : (nrhs > n ? nrhs : n));
   else
     lwork = 3*n + (2*n > nrhs ? (2*n > m ? 2*n : m) : (nrhs > m ? nrhs : m));
 
   double *work = new double [lwork];
 
-  F77_FCN (dgelss) (m, n, nrhs, tmp_data, m, presult, nrr, s, rcond,
-		    rank, work, lwork, info);
+  F77_FCN (dgelss, DGELSS) (m, n, nrhs, tmp_data, m, presult, nrr, s,
+			    rcond, rank, work, lwork, info);
 
   ColumnVector retval (n);
   for (i = 0; i < n; i++)
     retval.elem (i) = result.elem (i);
 
   delete [] tmp_data;
   delete [] s;
   delete [] work;
@@ -1250,18 +1253,18 @@ operator * (const ColumnVector& v, const
       return Matrix ();
     }
 
   if (len == 0)
     return Matrix (len, len, 0.0);
 
   double *c = new double [len * a_len];
 
-  F77_FCN (dgemm) ("N", "N", len, a_len, 1, 1.0, v.data (),
-		   len, a.data (), 1, 0.0, c, len, 1L, 1L);
+  F77_FCN (dgemm, DGEMM) ("N", "N", len, a_len, 1, 1.0, v.data (),
+			  len, a.data (), 1, 0.0, c, len, 1L, 1L);
 
   return Matrix (c, len, a_len);
 }
 
 // diagonal matrix by scalar -> matrix operations
 
 Matrix
 operator + (const DiagMatrix& a, double s)
@@ -1505,18 +1508,18 @@ operator * (const Matrix& m, const Matri
   if (nr == 0 || nc == 0 || a_nc == 0)
     return Matrix (nr, a_nc, 0.0);
 
   int ld  = nr;
   int lda = a_nr;
 
   double *c = new double [nr*a_nc];
 
-  F77_FCN (dgemm) ("N", "N", nr, a_nc, nc, 1.0, m.data (),
-		   ld, a.data (), lda, 0.0, c, nr, 1L, 1L);
+  F77_FCN (dgemm, DGEMM) ("N", "N", nr, a_nc, nc, 1.0, m.data (),
+			  ld, a.data (), lda, 0.0, c, nr, 1L, 1L);
 
   return Matrix (c, nr, a_nc);
 }
 
 // other operations.
 
 Matrix
 map (d_d_Mapper f, const Matrix& a)
diff --git a/liboctave/dRowVector.cc b/liboctave/dRowVector.cc
--- a/liboctave/dRowVector.cc
+++ b/liboctave/dRowVector.cc
@@ -33,23 +33,24 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
-  int F77_FCN (dgemv) (const char*, const int&, const int&,
-		       const double&, const double*, const int&,
-		       const double*, const int&, const double&,
-		       double*, const int&, long);
+  int F77_FCN (dgemv, DGEMV) (const char*, const int&, const int&,
+			      const double&, const double*,
+			      const int&, const double*, const int&,
+			      const double&, double*, const int&,
+			      long);
 
-  double F77_FCN (ddot) (const int&, const double*, const int&,
-			 const double*, const int&);
+  double F77_FCN (ddot, DDOT) (const int&, const double*, const int&,
+			       const double*, const int&);
 }
 
 /*
  * Row Vector class.
  */
 
 int
 RowVector::operator == (const RowVector& a) const
@@ -225,18 +226,18 @@ operator * (const RowVector& v, const Ma
 
   int a_nr = a.rows ();
   int a_nc = a.cols ();
 
   int ld = a_nr;
 
   double *y = new double [len];
 
-  F77_FCN (dgemv) ("T", a_nc, a_nr, 1.0, a.data (), ld, v.data (),
-		   1, 0.0, y, 1, 1L);
+  F77_FCN (dgemv, DGEMV) ("T", a_nc, a_nr, 1.0, a.data (), ld,
+			  v.data (), 1, 0.0, y, 1, 1L);
 
   return RowVector (y, len);
 }
 
 // other operations
 
 RowVector
 map (d_d_Mapper f, const RowVector& a)
@@ -354,17 +355,17 @@ operator * (const RowVector& v, const Co
   int len = v.length ();
   if (len != a.length ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant vector multiplication attempted");
       return 0.0;
     }
 
-  return F77_FCN (ddot) (len, v.data (), 1, a.data (), 1);
+  return F77_FCN (ddot, DDOT) (len, v.data (), 1, a.data (), 1);
 }
 
 Complex
 operator * (const RowVector& v, const ComplexColumnVector& a)
 {
   ComplexRowVector tmp (v);
   return tmp * a;
 }
diff --git a/liboctave/dbleAEPBAL.cc b/liboctave/dbleAEPBAL.cc
--- a/liboctave/dbleAEPBAL.cc
+++ b/liboctave/dbleAEPBAL.cc
@@ -25,23 +25,24 @@ Software Foundation, 675 Mass Ave, Cambr
 #include <config.h>
 #endif
 
 #include "dbleAEPBAL.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (dgebal) (const char*, const int&, double*,
-                        const int&, int&, int&, double*,
-                        int&, long, long);
+  int F77_FCN (dgebal, DGEBAL) (const char*, const int&, double*,
+				const int&, int&, int&, double*,
+				int&, long, long);
 
-  int F77_FCN (dgebak) (const char*, const char*, const int&, const int&,
-			const int&, double*, const int&, double*, const int&,
-			int&, long, long);
+  int F77_FCN (dgebak, DGEBAK) (const char*, const char*, const int&,
+				const int&, const int&, double*,
+				const int&, double*, const int&,
+				int&, long, long);
 }
 
 int
 AEPBALANCE::init (const Matrix& a, const char *balance_job)
 {
   int a_nc = a.cols ();
   if (a.rows () != a_nc)
     {
@@ -57,27 +58,29 @@ AEPBALANCE::init (const Matrix& a, const
   int ilo;
   int ihi;
   double *scale = new double [n];
 
 // Copy matrix into local structure.
 
   balanced_mat = a;
 
-  F77_FCN (dgebal) (balance_job, n, balanced_mat.fortran_vec (), 
-		    n, ilo, ihi, scale, info, 1L, 1L);
+  F77_FCN (dgebal, DGEBAL) (balance_job, n,
+			    balanced_mat.fortran_vec (), n, ilo, ihi,
+			    scale, info, 1L, 1L);
 
 // Initialize balancing matrix to identity.
 
   balancing_mat = Matrix (n, n, 0.0);
   for (int i = 0; i < n; i++)
     balancing_mat.elem (i ,i) = 1.0;
 
-  F77_FCN (dgebak) (balance_job, "R", n, ilo, ihi, scale, n, 
-		    balancing_mat.fortran_vec (), n, info, 1L, 1L);
+  F77_FCN (dgebak, DGEBAK) (balance_job, "R", n, ilo, ihi, scale, n,
+			    balancing_mat.fortran_vec (), n, info, 1L,
+			    1L);
 
   delete [] scale;
 
   return info;
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/liboctave/dbleCHOL.cc b/liboctave/dbleCHOL.cc
--- a/liboctave/dbleCHOL.cc
+++ b/liboctave/dbleCHOL.cc
@@ -27,18 +27,18 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "dbleCHOL.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (dpotrf) (const char*, const int&, double*, const int&,
-			int&, long);
+  int F77_FCN (dpotrf, DPOTRF) (const char*, const int&, double*,
+				const int&, int&, long);
 }
 
 int
 CHOL::init (const Matrix& a)
 {
   int a_nr = a.rows ();
   int a_nc = a.cols ();
   if (a_nr != a_nc)
@@ -47,17 +47,17 @@ CHOL::init (const Matrix& a)
       return -1;
     }
 
   int n = a_nc;
   int info;
 
   double *h = dup (a.data (), a.length ());
 
-  F77_FCN (dpotrf) ("U", n, h, n, info, 1L);
+  F77_FCN (dpotrf, DPOTRF) ("U", n, h, n, info, 1L);
 
   chol_mat = Matrix (h, n, n);
 
 // If someone thinks of a more graceful way of doing this (or faster for
 // that matter :-)), please let me know!
 
   if (n > 1)
     for (int j = 0; j < a_nc; j++)
diff --git a/liboctave/dbleGEPBAL.cc b/liboctave/dbleGEPBAL.cc
--- a/liboctave/dbleGEPBAL.cc
+++ b/liboctave/dbleGEPBAL.cc
@@ -27,31 +27,33 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include <math.h>
 
 #include "dbleGEPBAL.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (dgebak) (const char*, const char*, const int&, const int&,
-			const int&, double*, const int&, double*, const int&,
-			int&, long, long);
+  int F77_FCN (dgebak, DGEBAK) (const char*, const char*, const int&,
+				const int&, const int&, double*,
+				const int&, double*, const int&, int&,
+				long, long);
 
-  int F77_FCN (reduce) (const int&, const int&, double*,
-	   	        const int&, double*,
-			int&, int&, double*, double*);
+  int F77_FCN (reduce, REDUCE) (const int&, const int&, double*,
+				const int&, double*, int&, int&,
+				double*, double*);
 
-  int F77_FCN (scaleg) (const int&, const int&, double*,
-	   	        const int&, double*,
-			const int&, const int&, double*, double*, double*);
+  int F77_FCN (scaleg, SCALEG) (const int&, const int&, double*,
+				const int&, double*, const int&,
+				const int&, double*, double*,
+				double*);
 
-  int F77_FCN (gradeq) (const int&, const int&, double*,
-	   	        const int&, double*,
-			int&, int&, double*, double*);
+  int F77_FCN (gradeq, GRADEQ) (const int&, const int&, double*,
+				const int&, double*, int&, int&,
+				double*, double*);
 }
 
 int
 GEPBALANCE::init (const Matrix& a, const Matrix& b, const char *balance_job)
 {
   int a_nr = a.rows ();
   int a_nc = a.cols ();
   int b_nr = b.rows ();
@@ -100,36 +102,36 @@ GEPBALANCE::init (const Matrix& a, const
     left_balancing_mat (i, i) = 1.0;
 
   right_balancing_mat = left_balancing_mat;
 
 // Check for permutation option.
 
   if (*balance_job == 'P' || *balance_job == 'B')
     {
-      F77_FCN (reduce) (n, n, balanced_a_mat.fortran_vec (),
-			n, balanced_b_mat.fortran_vec (), ilo, ihi,
-			cscale, wk.fortran_vec ());
+      F77_FCN (reduce, REDUCE) (n, n, balanced_a_mat.fortran_vec (),
+				n, balanced_b_mat.fortran_vec (), ilo,
+				ihi, cscale, wk.fortran_vec ());
     }
   else
     {
 
 // Set up for scaling later.
 
       ilo = 1;
       ihi = n;
     }
 
 // Check for scaling option.
 
   if ((*balance_job == 'S' || *balance_job == 'B') && ilo != ihi)
     {
-      F77_FCN (scaleg) (n, n, balanced_a_mat.fortran_vec (), 
-			n, balanced_b_mat.fortran_vec (), ilo, ihi,
-			cscale, cperm, wk.fortran_vec ());
+      F77_FCN (scaleg, SCALEG) (n, n, balanced_a_mat.fortran_vec (), 
+				n, balanced_b_mat.fortran_vec (), ilo,
+				ihi, cscale, cperm, wk.fortran_vec ());
     }
   else
     {
 
 // Set scaling data to 0's.
 
       for (int tmp = ilo-1; tmp < ihi; tmp++)
 	{
@@ -143,34 +145,36 @@ GEPBALANCE::init (const Matrix& a, const
   for (int tmp = ilo-1; tmp < ihi; tmp++)
     {
       cscale[tmp] = pow (2.0, cscale[tmp]);
       wk.elem (tmp, 0) = pow (2.0, -wk.elem (tmp, 0));
     }
 
 // Column permutations/scaling.
 
-  F77_FCN (dgebak) (balance_job, "R", n, ilo, ihi, cscale, n, 
-		    right_balancing_mat.fortran_vec (), n, info,
-		    1L, 1L);
+  F77_FCN (dgebak, DGEBAK) (balance_job, "R", n, ilo, ihi, cscale, n, 
+			    right_balancing_mat.fortran_vec (), n,
+			    info, 1L, 1L);
     
 // Row permutations/scaling.
 
-  F77_FCN (dgebak) (balance_job, "L", n, ilo, ihi, wk.fortran_vec (), n,
-		    left_balancing_mat.fortran_vec (), n, info, 1L, 1L);
+  F77_FCN (dgebak, DGEBAK) (balance_job, "L", n, ilo, ihi,
+			    wk.fortran_vec (), n,
+			    left_balancing_mat.fortran_vec (), n,
+			    info, 1L, 1L);
 
 // XXX FIXME XXX --- these four lines need to be added and debugged.
 // GEPBALANCE::init will work without them, though, so here they are.
 
 #if 0
   if ((*balance_job == 'P' || *balance_job == 'B') && ilo != ihi)
     {
-      F77_FCN (gradeq) (n, n, balanced_a_mat.fortran_vec (),
-			n, balanced_b_mat.fortran_vec (), ilo, ihi,
-			cperm, wk.fortran_vec ());
+      F77_FCN (gradeq, GRADEQ) (n, n, balanced_a_mat.fortran_vec (),
+				n, balanced_b_mat.fortran_vec (), ilo,
+				ihi, cperm, wk.fortran_vec ());
     }
 #endif
 
 // Transpose for aa = cc*a*dd convention...
   left_balancing_mat = left_balancing_mat.transpose ();
 
   delete [] cscale;
   delete [] cperm;
diff --git a/liboctave/dbleHESS.cc b/liboctave/dbleHESS.cc
--- a/liboctave/dbleHESS.cc
+++ b/liboctave/dbleHESS.cc
@@ -27,31 +27,32 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "dbleHESS.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (dgebal) (const char*, const int&, double*,
-                        const int&, int&, int&, double*,
-                        int&, long, long);
+  int F77_FCN (dgebal, DGEBAL) (const char*, const int&, double*,
+				const int&, int&, int&, double*,
+				int&, long, long);
 
-  int F77_FCN (dgehrd) (const int&, const int&, const int&,
-                        double*, const int&, double*, double*,
-                        const int&, int&, long, long);
+  int F77_FCN (dgehrd, DGEHRD) (const int&, const int&, const int&,
+				double*, const int&, double*, double*,
+				const int&, int&, long, long);
 
-  int F77_FCN (dorghr) (const int&, const int&, const int&,
-                        double*, const int&, double*, double*,
-                        const int&, int&, long, long);
+  int F77_FCN (dorghr, DORGHR) (const int&, const int&, const int&,
+				double*, const int&, double*, double*,
+				const int&, int&, long, long);
 
-  int F77_FCN (dgebak) (const char*, const char*, const int&, const int&,
-			const int&, double*, const int&, double*, const int&,
-			int&, long, long);
+  int F77_FCN (dgebak, DGEBAK) (const char*, const char*, const int&,
+				const int&, const int&, double*,
+				const int&, double*, const int&, int&,
+				long, long);
 }
 
 int
 HESS::init (const Matrix& a)
 {
   int a_nr = a.rows ();
   int a_nc = a.cols ();
   if (a_nr != a_nc)
@@ -71,25 +72,29 @@ HESS::init (const Matrix& a)
 
   double *h = dup (a.data (), a.length ());
 
   double *tau = new double [n+1];
   double *scale = new double [n];
   double *z = new double [n*n];
   double *work = new double [lwork];
 
-  F77_FCN (dgebal) (jobbal, n, h, n, ilo, ihi, scale, info, 1L, 1L);
+  F77_FCN (dgebal, DGEBAL) (jobbal, n, h, n, ilo, ihi, scale, info,
+			    1L, 1L);
 
-  F77_FCN (dgehrd) (n, ilo, ihi, h, n, tau, work, lwork, info, 1L, 1L);
+  F77_FCN (dgehrd, DGEHRD) (n, ilo, ihi, h, n, tau, work, lwork, info,
+			    1L, 1L);
 
   copy (z, h, n*n);
 
-  F77_FCN (dorghr) (n, ilo, ihi, z, n, tau, work, lwork, info, 1L, 1L);
+  F77_FCN (dorghr, DORGHR) (n, ilo, ihi, z, n, tau, work, lwork, info,
+			    1L, 1L);
 
-  F77_FCN (dgebak) (jobbal, side, n, ilo, ihi, scale, n, z, n, info, 1L, 1L);
+  F77_FCN (dgebak, DGEBAK) (jobbal, side, n, ilo, ihi, scale, n, z, n,
+			    info, 1L, 1L);
 
 // We need to clear out all of the area below the sub-diagonal which was used
 // to store the unitary matrix.
 
   hess_mat = Matrix (h, n, n);
   unitary_hess_mat = Matrix (z, n, n);
 
 // If someone thinks of a more graceful way of doing this (or faster for 
diff --git a/liboctave/dbleLU.cc b/liboctave/dbleLU.cc
--- a/liboctave/dbleLU.cc
+++ b/liboctave/dbleLU.cc
@@ -27,18 +27,19 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "dbleLU.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (dgesv) (const int&, const int&, double*, const int&,
-		       int*, double&, const int&, int&);
+  int F77_FCN (dgesv, DGESV) (const int&, const int&, double*,
+			      const int&, int*, double&, const int&,
+			      int&);
 }
 
 LU::LU (const Matrix& a)
 {
   int a_nr = a.rows ();
   int a_nc = a.cols ();
   if (a_nr == 0 || a_nc == 0 || a_nr != a_nc)
     {
@@ -49,17 +50,17 @@ LU::LU (const Matrix& a)
   int n = a_nr;
 
   int *ipvt = new int [n];
   int *pvt = new int [n];
   double *tmp_data = dup (a.data (), a.length ());
   int info = 0;
   double b;
 
-  F77_FCN (dgesv) (n, 0, tmp_data, n, ipvt, b, n, info);
+  F77_FCN (dgesv, DGESV) (n, 0, tmp_data, n, ipvt, b, n, info);
 
   Matrix A_fact (tmp_data, n, n);
 
   int i;
 
   for (i = 0; i < n; i++)
     {
       ipvt[i] -= 1;
diff --git a/liboctave/dbleQR.cc b/liboctave/dbleQR.cc
--- a/liboctave/dbleQR.cc
+++ b/liboctave/dbleQR.cc
@@ -27,21 +27,23 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "dbleQR.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (dgeqrf) (const int&, const int&, double*, const int&,
-			double*, double*, const int&, int&);
+  int F77_FCN (dgeqrf, DGEQRF) (const int&, const int&, double*,
+				const int&, double*, double*,
+				const int&, int&); 
 
-  int F77_FCN (dorgqr) (const int&, const int&, const int&, double*,
-			const int&, double*, double*, const int&, int&);
+  int F77_FCN (dorgqr, DORGQR) (const int&, const int&, const int&,
+				double*, const int&, double*, double*,
+				const int&, int&);
 }
 
 QR::QR (const Matrix& a, QR::type qr_type)
 {
   int m = a.rows ();
   int n = a.cols ();
 
   if (m == 0 || n == 0)
@@ -60,17 +62,17 @@ QR::QR (const Matrix& a, QR::type qr_typ
   if (m > n)
     {
       tmp_data = new double [m*m];
       copy (tmp_data, a.data (), a.length ());
     }
   else
     tmp_data = dup (a.data (), a.length ());
 
-  F77_FCN (dgeqrf) (m, n, tmp_data, m, tau, work, lwork, info);
+  F77_FCN (dgeqrf, DGEQRF) (m, n, tmp_data, m, tau, work, lwork, info);
 
   delete [] work;
 
   if (qr_type == QR::raw)
     {
       for (int j = 0; j < min_mn; j++)
 	{
 	  int limit = j < min_mn - 1 ? j : min_mn - 1;
@@ -97,17 +99,18 @@ QR::QR (const Matrix& a, QR::type qr_typ
 	  int limit = j < min_mn-1 ? j : min_mn-1;
 	  for (int i = 0; i <= limit; i++)
 	    r.elem (i, j) = tmp_data[m*j+i];
 	}
 
       lwork = 32*m;
       work = new double[lwork];
 
-      F77_FCN (dorgqr) (m, m, min_mn, tmp_data, m, tau, work, lwork, info);
+      F77_FCN (dorgqr, DORGQR) (m, m, min_mn, tmp_data, m, tau, work,
+				lwork, info);
 
       q = Matrix (tmp_data, m, m);
       q.resize (m, n2);
 
       delete [] tau;
       delete [] work;
     }
 }
diff --git a/liboctave/dbleQRP.cc b/liboctave/dbleQRP.cc
--- a/liboctave/dbleQRP.cc
+++ b/liboctave/dbleQRP.cc
@@ -29,21 +29,23 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "dbleQRP.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (dgeqpf) (const int&, const int&, double*, const int&,
-			int*, double*, double*, int&);
+  int F77_FCN (dgeqpf, DGEQPF) (const int&, const int&, double*,
+				const int&, int*, double*, double*,
+				int&);
 
-  int F77_FCN (dorgqr) (const int&, const int&, const int&, double*,
-			const int&, double*, double*, const int&, int&);
+  int F77_FCN (dorgqr, DORGQR) (const int&, const int&, const int&,
+				double*, const int&, double*, double*,
+				const int&, int&); 
 }
 
 // It would be best to share some of this code with QR class...
 
 QRP::QRP (const Matrix& a, QR::type qr_type)
 {
   assert (qr_type != QR::raw);
 
@@ -74,17 +76,17 @@ QRP::QRP (const Matrix& a, QR::type qr_t
   int *jpvt = new int[n];
 
 // Clear Pivot vector (code to enforce a certain permutation would go
 // here...)
 
   for (int i = 0; i < n; i++)
     jpvt[i] = 0;
 
-  F77_FCN (dgeqpf) (m, n, tmp_data, m, jpvt, tau, work, info);
+  F77_FCN (dgeqpf, DGEQPF) (m, n, tmp_data, m, jpvt, tau, work, info);
 
 // Form Permutation matrix (if economy is requested, return the
 // indices only!)
 
   if (qr_type == QR::economy && m > n)
     {
       p.resize (1, n, 0.0);
       for (int j = 0; j < n; j++)
@@ -117,17 +119,18 @@ QRP::QRP (const Matrix& a, QR::type qr_t
       int limit = j < min_mn-1 ? j : min_mn-1;
       for (int i = 0; i <= limit; i++)
 	r.elem (i, j) = tmp_data[m*j+i];
     }
 
   lwork = 32*m;
   work = new double[lwork];
 
-  F77_FCN (dorgqr) (m, m, min_mn, tmp_data, m, tau, work, lwork, info);
+  F77_FCN (dorgqr, DORGQR) (m, m, min_mn, tmp_data, m, tau, work,
+			    lwork, info);
 
   q = Matrix (tmp_data, m, m);
   q.resize (m, n2);
 
   delete [] tau;
   delete [] work;
 }
 
diff --git a/liboctave/dbleSCHUR.cc b/liboctave/dbleSCHUR.cc
--- a/liboctave/dbleSCHUR.cc
+++ b/liboctave/dbleSCHUR.cc
@@ -27,22 +27,23 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "dbleSCHUR.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (dgeesx) (const char*, const char*,
-			int (*)(const double&, const double&),
-			const char*, const int&, double*, const int&,
-			int&, double*, double*, double*, const int&,
-			double&, double&, double*, const int&, int*,
-			const int&, int*, int&, long, long);
+  int F77_FCN (dgeesx, DGEESX) (const char*, const char*,
+				int (*)(const double&, const double&),
+				const char*, const int&, double*,
+				const int&, int&, double*, double*,
+				double*, const int&, double&, double&,
+				double*, const int&, int*, const int&,
+				int*, int&, long, long);
 }
 
 static int
 select_ana (const double& a, const double& b)
 {
    return (a < 0.0);
 }
 
@@ -95,33 +96,35 @@ SCHUR::init (const Matrix& a, const char
   if (*ord == 'A' || *ord == 'D' || *ord == 'a' || *ord == 'd')
     {
       iwork = new int [liwork];
       bwork = new int [n];
     }
 
   if (*ord == 'A' || *ord == 'a')
     {
-      F77_FCN (dgeesx) (jobvs, sort, select_ana, sense, n, s, n,
-			sdim, wr, wi, q, n, rconde, rcondv, work,
-			lwork, iwork, liwork, bwork, info, 1L, 1L);
+      F77_FCN (dgeesx, DGEESX) (jobvs, sort, select_ana, sense, n, s,
+				n, sdim, wr, wi, q, n, rconde, rcondv,
+				work, lwork, iwork, liwork, bwork,
+				info, 1L, 1L);
     }
   else if (*ord == 'D' || *ord == 'd')
     {
-      F77_FCN (dgeesx) (jobvs, sort, select_dig, sense, n, s, n,
-			sdim, wr, wi, q, n, rconde, rcondv, work,
-			lwork, iwork, liwork, bwork, info, 1L, 1L);
+      F77_FCN (dgeesx, DGEESX) (jobvs, sort, select_dig, sense, n, s,
+				n, sdim, wr, wi, q, n, rconde, rcondv,
+				work, lwork, iwork, liwork, bwork,
+				info, 1L, 1L);
       
     }
   else
     {
-      F77_FCN (dgeesx) (jobvs, sort, (void *) 0, sense, n, s,
-			n, sdim, wr, wi, q, n, rconde, rcondv,
-			work, lwork, iwork, liwork, bwork, info,
-			1L, 1L);
+      F77_FCN (dgeesx, DGEESX) (jobvs, sort, (void *) 0, sense, n, s,
+				n, sdim, wr, wi, q, n, rconde, rcondv,
+				work, lwork, iwork, liwork, bwork,
+				info, 1L, 1L);
     }
 
   schur_mat = Matrix (s, n, n);
   unitary_mat = Matrix (q, n, n);
 
   delete [] wr;
   delete [] wi;
   delete [] work;
diff --git a/liboctave/dbleSVD.cc b/liboctave/dbleSVD.cc
--- a/liboctave/dbleSVD.cc
+++ b/liboctave/dbleSVD.cc
@@ -26,20 +26,21 @@ Software Foundation, 675 Mass Ave, Cambr
 #endif
 
 #include "dbleSVD.h"
 #include "mx-inlines.cc"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (dgesvd) (const char*, const char*, const int&,
-			const int&, double*, const int&, double*,
-			double*, const int&, double*, const int&,
-			double*, const int&, int&, long, long);
+  int F77_FCN (dgesvd, DGESVD) (const char*, const char*, const int&,
+				const int&, double*, const int&,
+				double*, double*, const int&, double*,
+				const int&, double*, const int&, int&,
+				long, long);
 }
 
 int
 SVD::init (const Matrix& a, SVD::type svd_type)
 {
   int info;
 
   int m = a.rows ();
@@ -68,18 +69,19 @@ SVD::init (const Matrix& a, SVD::type sv
   double *s_vec  = new double[min_mn];
   double *vt = new double[nrow_vt * n];
 
   int tmp1 = 3*min_mn + max_mn;
   int tmp2 = 5*min_mn - 4;
   int lwork = tmp1 > tmp2 ? tmp1 : tmp2;
   double *work = new double[lwork];
 
-  F77_FCN (dgesvd) (jobu, jobv, m, n, tmp_data, m, s_vec, u, m,
-		    vt, nrow_vt, work, lwork, info, 1L, 1L);
+  F77_FCN (dgesvd, DGESVD) (jobu, jobv, m, n, tmp_data, m, s_vec, u,
+			    m, vt, nrow_vt, work, lwork, info, 1L,
+			    1L);
 
   left_sm = Matrix (u, m, ncol_u);
   sigma = DiagMatrix (s_vec, nrow_s, ncol_s);
   Matrix vt_m (vt, nrow_vt, n);
   right_sm = vt_m.transpose ();
 
   delete [] tmp_data;
   delete [] work;
