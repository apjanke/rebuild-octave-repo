# HG changeset patch
# User Rik <rik@octave.org>
# Date 1447872026 28800
#      Wed Nov 18 10:40:26 2015 -0800
# Node ID 7b608fadc6639bf8329b492e0a0acfdc5518c551
# Parent  73800f39da6f988df851ca89986fea84a964a6ad
Make error messages more specific about the variable and problem encountered.

* besselj.cc, bitfcns.cc, colloc.cc, daspk.cc, dasrt.cc, dassl.cc, data.cc,
dirfns.cc, ellipj.cc, error.cc, gl-render.cc, graphics.cc, graphics.in.h,
load-path.cc, lsode.cc, lu.cc, luinc.cc, oct-hist.cc, oct-obj.cc,
octave-link.cc, quad.cc, rand.cc, symtab.cc, sysdep.cc, toplev.cc, utils.cc,
variables.cc, __init_fltk__.cc, chol.cc, fftw.cc, ov-cell.cc, ov-ch-mat.cc,
ov-class.cc, ov-classdef.cc, ov-cx-mat.cc, ov-fcn-inline.cc, ov-struct.cc,
ov-usr-fcn.cc, CMatrix.cc, dMatrix.cc, fCMatrix.cc, fMatrix.cc, lo-specfun.cc,
curl.m, divergence.m, __fltk_file_filter__.m, __uiobject_split_args__.m,
uigetfile.m, doc.m, imshow.m, rref.m, subspace.m, edit.m, fileattrib.m, open.m,
substruct.m, annotation.m, axis.m, caxis.m, datetick.m, hidden.m, legend.m,
whitebg.m, colorbar.m, __add_datasource__.m, __ezplot__.m, __pie__.m,
__plt_get_axis_arg__.m, pan.m, __print_parse_opts__.m, rotate3d.m, subplot.m,
zoom.m, compan.m, addpref.m, getpref.m, setpref.m, powerset.m, bicg.m,
bicgstab.m, cgs.m, qmr.m, spaugment.m, pascal.m, moment.m, cstrcat.m,
system.tst:
Make error messages more specific about the variable and problem encountered.

diff --git a/libinterp/corefcn/besselj.cc b/libinterp/corefcn/besselj.cc
--- a/libinterp/corefcn/besselj.cc
+++ b/libinterp/corefcn/besselj.cc
@@ -76,17 +76,17 @@ enum bessel_type
             break; \
         } \
     } \
   while (0)
 
 static void
 gripe_bessel_arg (const char *fn, const char *arg)
 {
-  error ("%s: expecting scalar or matrix as %s argument", fn, arg);
+  error ("%s: %s argument must be a scalar or matrix", fn, arg);
 }
 
 octave_value_list
 do_bessel (enum bessel_type type, const char *fn,
            const octave_value_list& args, int nargout)
 {
   octave_value_list retval;
 
@@ -121,36 +121,36 @@ do_bessel (enum bessel_type type, const 
 
       octave_value alpha_arg = args(0);
       octave_value x_arg = args(1);
 
       if (alpha_arg.is_single_type () || x_arg.is_single_type ())
         {
           if (alpha_arg.is_scalar_type ())
             {
-              float alpha = args(0).xfloat_value ("%s: expecting scalar or matrix as first argument", fn);
+              float alpha = args(0).xfloat_value ("%s: ALPHA must be a scalar or matrix", fn);
 
               if (x_arg.is_scalar_type ())
                 {
-                  FloatComplex x = x_arg.xfloat_complex_value ("%s: expecting scalar or matrix as second argument", fn);
+                  FloatComplex x = x_arg.xfloat_complex_value ("%s: X must be a scalar or matrix", fn);
 
                   octave_idx_type ierr;
                   octave_value result;
 
                   DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
                   if (nargout > 1)
                     retval(1) = static_cast<float> (ierr);
 
                   retval(0) = result;
                 }
               else
                 {
                   FloatComplexNDArray x
-                    = x_arg.xfloat_complex_array_value ("%s: expecting scalar or matrix as second argument", fn);
+                    = x_arg.xfloat_complex_array_value ("%s: X must be a scalar or matrix", fn);
 
                   Array<octave_idx_type> ierr;
                   octave_value result;
 
                   DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
                   if (nargout > 1)
                     retval(1) = NDArray (ierr);
@@ -163,53 +163,53 @@ do_bessel (enum bessel_type type, const 
               dim_vector dv0 = args(0).dims ();
               dim_vector dv1 = args(1).dims ();
 
               bool args0_is_row_vector = (dv0(1) == dv0.numel ());
               bool args1_is_col_vector = (dv1(0) == dv1.numel ());
 
               if (args0_is_row_vector && args1_is_col_vector)
                 {
-                  FloatRowVector ralpha = args(0).xfloat_row_vector_value ("%s: expecting scalar or matrix as first argument", fn);
+                  FloatRowVector ralpha = args(0).xfloat_row_vector_value ("%s: ALPHA must be a scalar or matrix", fn);
 
                   FloatComplexColumnVector cx =
-                    x_arg.xfloat_complex_column_vector_value ("%s: expecting scalar or matrix as second argument", fn);
+                    x_arg.xfloat_complex_column_vector_value ("%s: X must be a scalar or matrix", fn);
 
                   Array<octave_idx_type> ierr;
                   octave_value result;
 
                   DO_BESSEL (type, ralpha, cx, scaled, ierr, result);
 
                   if (nargout > 1)
                     retval(1) = NDArray (ierr);
 
                   retval(0) = result;
                 }
               else
                 {
-                  FloatNDArray alpha = args(0).xfloat_array_value ("%s: expecting scalar or matrix as first argument", fn);
+                  FloatNDArray alpha = args(0).xfloat_array_value ("%s: ALPHA must be a scalar or matrix", fn);
 
                   if (x_arg.is_scalar_type ())
                     {
-                      FloatComplex x = x_arg.xfloat_complex_value ("%s: expecting scalar or matrix as second argument", fn);
+                      FloatComplex x = x_arg.xfloat_complex_value ("%s: X must be a scalar or matrix", fn);
 
                       Array<octave_idx_type> ierr;
                       octave_value result;
 
                       DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
                       if (nargout > 1)
                         retval(1) = NDArray (ierr);
 
                       retval(0) = result;
                     }
                   else
                     {
                       FloatComplexNDArray x
-                        = x_arg.xfloat_complex_array_value ("%s: expecting scalar or matrix as second argument", fn);
+                        = x_arg.xfloat_complex_array_value ("%s: X must be a scalar or matrix", fn);
 
                       Array<octave_idx_type> ierr;
                       octave_value result;
 
                       DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
                       if (nargout > 1)
                         retval(1) = NDArray (ierr);
@@ -218,35 +218,35 @@ do_bessel (enum bessel_type type, const 
                     }
                 }
             }
         }
       else
         {
           if (alpha_arg.is_scalar_type ())
             {
-              double alpha = args(0).xdouble_value ("%s: expecting scalar or matrix as first argument", fn);
+              double alpha = args(0).xdouble_value ("%s: ALPHA must be a scalar or matrix", fn);
 
               if (x_arg.is_scalar_type ())
                 {
-                  Complex x = x_arg.xcomplex_value ("%s: expecting scalar or matrix as second argument", fn);
+                  Complex x = x_arg.xcomplex_value ("%s: X must be a scalar or matrix", fn);
 
                   octave_idx_type ierr;
                   octave_value result;
 
                   DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
                   if (nargout > 1)
                     retval(1) = static_cast<double> (ierr);
 
                   retval(0) = result;
                 }
               else
                 {
-                  ComplexNDArray x = x_arg.xcomplex_array_value ("%s: expecting scalar or matrix as second argument", fn);
+                  ComplexNDArray x = x_arg.xcomplex_array_value ("%s: X must be a scalar or matrix", fn);
 
                   Array<octave_idx_type> ierr;
                   octave_value result;
 
                   DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
                   if (nargout > 1)
                     retval(1) = NDArray (ierr);
@@ -259,52 +259,52 @@ do_bessel (enum bessel_type type, const 
               dim_vector dv0 = args(0).dims ();
               dim_vector dv1 = args(1).dims ();
 
               bool args0_is_row_vector = (dv0(1) == dv0.numel ());
               bool args1_is_col_vector = (dv1(0) == dv1.numel ());
 
               if (args0_is_row_vector && args1_is_col_vector)
                 {
-                  RowVector ralpha = args(0).xrow_vector_value ("%s: expecting scalar or matrix as first argument", fn);
+                  RowVector ralpha = args(0).xrow_vector_value ("%s: ALPHA must be a scalar or matrix", fn);
 
                   ComplexColumnVector cx =
-                    x_arg.xcomplex_column_vector_value ("%s: expecting scalar or matrix as second argument", fn);
+                    x_arg.xcomplex_column_vector_value ("%s: X must be a scalar or matrix", fn);
 
                   Array<octave_idx_type> ierr;
                   octave_value result;
 
                   DO_BESSEL (type, ralpha, cx, scaled, ierr, result);
 
                   if (nargout > 1)
                     retval(1) = NDArray (ierr);
 
                   retval(0) = result;
                 }
               else
                 {
-                  NDArray alpha = args(0).xarray_value ("%s: expecting scalar or matrix as first argument", fn);
+                  NDArray alpha = args(0).xarray_value ("%s: ALPHA must be a scalar or matrix", fn);
 
                   if (x_arg.is_scalar_type ())
                     {
-                      Complex x = x_arg.xcomplex_value ("%s: expecting scalar or matrix as second argument", fn);
+                      Complex x = x_arg.xcomplex_value ("%s: X must be a scalar or matrix", fn);
 
                       Array<octave_idx_type> ierr;
                       octave_value result;
 
                       DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
                       if (nargout > 1)
                         retval(1) = NDArray (ierr);
 
                       retval(0) = result;
                     }
                   else
                     {
-                      ComplexNDArray x = x_arg.xcomplex_array_value ("%s: expecting scalar or matrix as second argument", fn);
+                      ComplexNDArray x = x_arg.xcomplex_array_value ("%s: X must be a scalar or matrix", fn);
 
                       Array<octave_idx_type> ierr;
                       octave_value result;
 
                       DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
                       if (nargout > 1)
                         retval(1) = NDArray (ierr);
@@ -448,17 +448,17 @@ See besselj.\n\
       tmp_args(1) = args(2);
       tmp_args(0) = args(0);
 
       if (kind == 1)
         retval = do_bessel (BESSEL_H1, "besselh", tmp_args, nargout);
       else if (kind == 2)
         retval = do_bessel (BESSEL_H2, "besselh", tmp_args, nargout);
       else
-        error ("besselh: expecting K = 1 or 2");
+        error ("besselh: K must be 1 or 2");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (airy, args, nargout,
@@ -518,17 +518,17 @@ return @code{NaN}.\n\
 
       int kind = 0;
 
       if (nargin > 1)
         {
           kind = args(0).xint_value ("airy: K must be an integer value");
 
           if (kind < 0 || kind > 3)
-            error ("airy: expecting K = 0, 1, 2, or 3");
+            error ("airy: K must be 0, 1, 2, or 3");
         }
 
       int idx = nargin == 1 ? 0 : 1;
 
       if (args(idx).is_single_type ())
         {
           FloatComplexNDArray z = args(idx).xfloat_complex_array_value ("airy: Z must be a complex matrix");
 
diff --git a/libinterp/corefcn/bitfcns.cc b/libinterp/corefcn/bitfcns.cc
--- a/libinterp/corefcn/bitfcns.cc
+++ b/libinterp/corefcn/bitfcns.cc
@@ -497,17 +497,17 @@ bitshift (float a, int n, int64_t mask)
                 result(i) = bitshift (m(i), static_cast<int> (n(i)), mask); \
  \
           retval = result; \
         } \
       else \
         error ("bitshift: size of A and N must match, or one operand must be a scalar"); \
     } \
   else \
-    error ("bitshift: expecting integer as second argument"); \
+    error ("bitshift: K must be a scalar or array of integers"); \
 
 #define DO_UBITSHIFT(T, N) \
   do \
     { \
       int bits_in_type = octave_ ## T :: nbits (); \
       T ## NDArray m = m_arg.T ## _array_value (); \
         octave_ ## T mask = octave_ ## T::max (); \
       if ((N) < bits_in_type) \
@@ -569,17 +569,17 @@ bitshift (10, [-2, -1, 0, 1, 2])\n\
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2 || nargin == 3)
     {
       int nbits = 64;
 
-      NDArray n = args(1).xarray_value ("bitshift: expecting integer as second argument");
+      NDArray n = args(1).xarray_value ("bitshift: K must be a scalar or array of integers");
 
       if (nargin == 3)
         {
           // FIXME: for compatibility, we should accept an array
           // or a scalar as the third argument.
           if (args(2).numel () > 1)
             error ("bitshift: N must be a scalar integer");
           else
@@ -652,17 +652,17 @@ bitshift (10, [-2, -1, 0, 1, 2])\n\
 
 /*
 %!assert (bitshift (uint8  (16), 1),  uint8 ( 32))
 %!assert (bitshift (uint16 (16), 2), uint16 ( 64))
 %!assert (bitshift (uint32 (16), 3), uint32 (128))
 %!assert (bitshift (uint64 (16), 4), uint64 (256))
 %!assert (bitshift (uint8 (255), 1), uint8 (254))
 
-%!error <expecting integer as second argument> bitshift (16, 1.5)
+%!error <K must be a scalar or array of integers> bitshift (16, 1.5)
 %!error bitshift (16, {1})
 %!error <N must be a scalar integer> bitshift (10, [-2 -1 0 1 2], [1 1 1 1 1])
 %!error <N must be positive> bitshift (10, [-2 -1 0 1 2], -1)
 */
 
 DEFUN (flintmax, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} flintmax ()\n\
diff --git a/libinterp/corefcn/colloc.cc b/libinterp/corefcn/colloc.cc
--- a/libinterp/corefcn/colloc.cc
+++ b/libinterp/corefcn/colloc.cc
@@ -75,31 +75,31 @@ Reference: @nospell{J. Villadsen}, @nosp
     }
 
   octave_idx_type ntot = ncol;
   octave_idx_type left = 0;
   octave_idx_type right = 0;
 
   for (int i = 1; i < nargin; i++)
     {
-      std::string s = args(i).xstring_value ("colloc: expecting string argument \"left\" or \"right\"");
+      std::string s = args(i).xstring_value ("colloc: optional arguments must be strings");
 
       if ((s.length () == 1 && (s[0] == 'R' || s[0] == 'r'))
           || s == "right")
         {
           right = 1;
         }
       else if ((s.length () == 1 && (s[0] == 'L' || s[0] == 'l'))
                || s == "left")
         {
           left = 1;
         }
       else
         {
-          error ("colloc: unrecognized argument");
+          error ("colloc: string argument must be \"left\" or \"right\"");
           return retval;
         }
     }
 
   ntot += left + right;
   if (ntot < 1)
     {
       error ("colloc: the total number of roots must be positive");
diff --git a/libinterp/corefcn/daspk.cc b/libinterp/corefcn/daspk.cc
--- a/libinterp/corefcn/daspk.cc
+++ b/libinterp/corefcn/daspk.cc
@@ -379,33 +379,33 @@ parameters for @code{daspk}.\n\
                   }
                 }
             }
         }
 
       if (! daspk_fcn)
         DASPK_ABORT ();
 
-      ColumnVector state = args(1).xvector_value ("expecting state vector as second argument");
+      ColumnVector state = args(1).xvector_value ("daspk: initial state X_0 must be a vector");
 
-      ColumnVector deriv = args(2).xvector_value ("expecting derivative vector as third argument");
+      ColumnVector deriv = args(2).xvector_value ("daspk: initial derivatives XDOT_0 must be a vector");
 
-      ColumnVector out_times = args(3).xvector_value ("expecting output time vector as fourth argument");
+      ColumnVector out_times = args(3).xvector_value ("daspk: output time variable T must be a vector");
 
       ColumnVector crit_times;
       int crit_times_set = 0;
       if (nargin > 4)
         {
-          crit_times = args(4).xvector_value ("expecting critical time vector as fifth argument");
+          crit_times = args(4).xvector_value ("daspk: list of critical times T_CRIT must be a vector");
 
           crit_times_set = 1;
         }
 
       if (state.numel () != deriv.numel ())
-        DASPK_ABORT1 ("x and xdot must have the same size");
+        DASPK_ABORT1 ("X_0 and XDOT_0 must have the same size");
 
       double tzero = out_times (0);
 
       DAEFunc func (daspk_user_function);
       if (daspk_jac)
         func.set_jacobian_function (daspk_user_jacobian);
 
       DASPK dae (state, deriv, tzero, func);
diff --git a/libinterp/corefcn/dasrt.cc b/libinterp/corefcn/dasrt.cc
--- a/libinterp/corefcn/dasrt.cc
+++ b/libinterp/corefcn/dasrt.cc
@@ -466,50 +466,50 @@ parameters for @code{dasrt}.\n\
 
   argp++;
 
   if (args(1).is_function_handle () || args(1).is_inline_function ())
     {
       dasrt_cf = args(1).function_value ();
 
       if (! dasrt_cf)
-        DASRT_ABORT1 ("expecting function name as argument 2");
+        DASRT_ABORT1 ("invalid constraint function G");
 
       argp++;
 
       func.set_constraint_function (dasrt_user_cf);
     }
   else if (args(1).is_string ())
     {
       dasrt_cf = is_valid_function (args(1), "dasrt", true);
       if (! dasrt_cf)
-        DASRT_ABORT1 ("expecting function name as argument 2");
+        DASRT_ABORT1 ("invalid constraint function G");
 
       argp++;
 
       func.set_constraint_function (dasrt_user_cf);
     }
 
-  ColumnVector state = args(argp).xvector_value ("expecting state vector as argument %d", ++argp);
+  ColumnVector state = args(argp).xvector_value ("dasrt: initial state X_0 must be a vector");
 
-  ColumnVector stateprime = args(argp).xvector_value ("expecting time derivative of state vector as argument %d", argp);
+  ColumnVector stateprime = args(argp).xvector_value ("dasrt: initial derivatives XDOT_0 must be a vector");
   argp++;
 
-  ColumnVector out_times = args(argp).xvector_value ("expecting output time vector as %s argument %d", argp);
+  ColumnVector out_times = args(argp).xvector_value ("dasrt: output time variable T must be a vector");
   argp++;
 
   double tzero = out_times (0);
 
   ColumnVector crit_times;
 
   bool crit_times_set = false;
 
   if (argp < nargin)
     {
-      crit_times = args(argp).xvector_value ("expecting critical time vector as argument %d", argp);
+      crit_times = args(argp).xvector_value ("dasrt: list of critical times T_CRIT must be a vector");
       argp++;
 
       crit_times_set = true;
     }
 
   if (dasrt_j)
     func.set_jacobian_function (dasrt_user_j);
 
diff --git a/libinterp/corefcn/dassl.cc b/libinterp/corefcn/dassl.cc
--- a/libinterp/corefcn/dassl.cc
+++ b/libinterp/corefcn/dassl.cc
@@ -380,33 +380,33 @@ parameters for @code{dassl}.\n\
                   }
                 }
             }
         }
 
       if (! dassl_fcn)
         DASSL_ABORT ();
 
-      ColumnVector state = args(1).xvector_value ("expecting state vector as second argument");
+      ColumnVector state = args(1).xvector_value ("dassl: initial state X_0 must be a vector");
 
-      ColumnVector deriv = args(2).xvector_value ("expecting derivative vector as third argument");
+      ColumnVector deriv = args(2).xvector_value ("dassl: initial derivatives XDOT_0 must be a vector");
 
-      ColumnVector out_times = args(3).xvector_value ("expecting output time vector as fourth argument");
+      ColumnVector out_times = args(3).xvector_value ("dassl: output time variable T must be a vector");
 
       ColumnVector crit_times;
       int crit_times_set = 0;
       if (nargin > 4)
         {
-          crit_times = args(4).xvector_value ("expecting critical time vector as fifth argument");
+          crit_times = args(4).xvector_value ("dassl: list of critical times T_CRIT must be a vector");
 
           crit_times_set = 1;
         }
 
       if (state.numel () != deriv.numel ())
-        DASSL_ABORT1 ("x and xdot must have the same size");
+        DASSL_ABORT1 ("X and XDOT_0 must have the same size");
 
       double tzero = out_times (0);
 
       DAEFunc func (dassl_user_function);
       if (dassl_jac)
         func.set_jacobian_function (dassl_user_jacobian);
 
       DASSL dae (state, deriv, tzero, func);
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -91,17 +91,17 @@ index_error (const char *fmt, const std:
 #define ANY_ALL(FCN) \
  \
   octave_value retval; \
  \
   int nargin = args.length (); \
  \
   if (nargin == 1 || nargin == 2) \
     { \
-      int dim = (nargin == 1 ? -1 : args(1).int_value (#FCN ": expecting dimension argument to be an integer") - 1); \
+      int dim = (nargin == 1 ? -1 : args(1).int_value (#FCN ": DIM must be an integer") - 1); \
  \
       if (dim >= -1) \
         retval = args(0).FCN (dim); \
       else \
         error (#FCN ": invalid dimension argument = %d", dim + 1); \
     } \
   else \
     print_usage (); \
@@ -3934,17 +3934,17 @@ fill_matrix (const octave_value_list& ar
       break;
 
     default:
       {
         dims.resize (nargin);
 
         for (int i = 0; i < nargin; i++)
           dims(i) = (args(i).is_empty ()
-                     ? 0 : args(i).xidx_type_value ("%s: expecting scalar integer arguments", fcn));
+                     ? 0 : args(i).xidx_type_value ("%s: dimension arguments must be scalar integers", fcn));
       }
       break;
     }
 
   dims.chop_trailing_singletons ();
 
   check_dimensions (dims, fcn);
 
@@ -4044,17 +4044,17 @@ fill_matrix (const octave_value_list& ar
       break;
 
     default:
       {
         dims.resize (nargin);
 
         for (int i = 0; i < nargin; i++)
           dims(i) = (args(i).is_empty ()
-                     ? 0 : args(i).xidx_type_value ("%s: expecting scalar integer arguments", fcn));
+                     ? 0 : args(i).xidx_type_value ("%s: dimension arguments must be scalar integers", fcn));
       }
       break;
     }
 
   dims.chop_trailing_singletons ();
 
   check_dimensions (dims, fcn);
 
@@ -4108,17 +4108,17 @@ fill_matrix (const octave_value_list& ar
       break;
 
     default:
       {
         dims.resize (nargin);
 
         for (int i = 0; i < nargin; i++)
           dims(i) = (args(i).is_empty ()
-                     ? 0 : args(i).xidx_type_value ("%s: expecting scalar integer arguments", fcn));
+                     ? 0 : args(i).xidx_type_value ("%s: dimension arguments must be scalar integers", fcn));
       }
       break;
     }
 
   dims.chop_trailing_singletons ();
 
   check_dimensions (dims, fcn);
 
@@ -4173,17 +4173,17 @@ fill_matrix (const octave_value_list& ar
       break;
 
     default:
       {
         dims.resize (nargin);
 
         for (int i = 0; i < nargin; i++)
           dims(i) = (args(i).is_empty ()
-                     ? 0 : args(i).xidx_type_value ("%s: expecting scalar integer arguments", fcn));
+                     ? 0 : args(i).xidx_type_value ("%s: dimension arguments must be scalar integers", fcn));
       }
       break;
     }
 
   dims.chop_trailing_singletons ();
 
   check_dimensions (dims, fcn);
 
@@ -4228,17 +4228,17 @@ fill_matrix (const octave_value_list& ar
       break;
 
     default:
       {
         dims.resize (nargin);
 
         for (int i = 0; i < nargin; i++)
           dims(i) = (args(i).is_empty ()
-                     ? 0 : args(i).xidx_type_value ("%s: expecting scalar integer arguments", fcn));
+                     ? 0 : args(i).xidx_type_value ("%s: dimension arguments must be scalar integers", fcn));
       }
       break;
     }
 
   dims.chop_trailing_singletons ();
 
   check_dimensions (dims, fcn);
 
@@ -6868,17 +6868,17 @@ Undocumented internal function.\n\
 static sortmode
 get_sort_mode_option (const octave_value& arg, const char *argn)
 {
   // FIXME: we initialize to UNSORTED here to avoid a GCC warning
   // about possibly using sortmode uninitialized.
   // FIXME: shouldn't these modes be scoped inside a class?
   sortmode smode = UNSORTED;
 
-  std::string mode = arg.xstring_value ("issorted: expecting %s argument to be a string", argn);
+  std::string mode = arg.xstring_value ("issorted: MODE must be a string");
 
   if (mode == "ascending")
     smode = ASCENDING;
   else if (mode == "descending")
     smode = DESCENDING;
   else if (mode == "either")
     smode = UNSORTED;
   else
diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -332,17 +332,17 @@ identifier.\n\
 
                   doit = octave_yes_or_no (prompt);
                 }
 
               if (doit)
                 status = octave_recursive_rmdir (fulldir, msg);
             }
           else
-            error ("rmdir: expecting second argument to be \"s\"");
+            error ("rmdir: second argument must be \"s\" for recursive removal");
         }
       else
         status = octave_rmdir (fulldir, msg);
 
       if (status < 0)
         {
           retval(2) = "rmdir";
           retval(1) = msg;
diff --git a/libinterp/corefcn/ellipj.cc b/libinterp/corefcn/ellipj.cc
--- a/libinterp/corefcn/ellipj.cc
+++ b/libinterp/corefcn/ellipj.cc
@@ -78,57 +78,57 @@ and 16.15), Dover, 1965.\n\
       return retval;
     }
 
   octave_value u_arg = args(0);
   octave_value m_arg = args(1);
 
   if (m_arg.is_scalar_type ())
     {
-      double m = args(1).xdouble_value ("ellipj: expecting scalar or matrix as second argument");
+      double m = args(1).xdouble_value ("ellipj: M must be a scalar or matrix");
 
       if (u_arg.is_scalar_type ())
         {
           if (u_arg.is_real_type ())
             {
               // u real, m scalar
-              double u = args(0).xdouble_value ("ellipj: expecting scalar or matrix as first argument");
+              double u = args(0).xdouble_value ("ellipj: U must be a scalar or matrix");
 
               double sn, cn, dn;
               double err = 0;
 
               ellipj (u, m, sn, cn, dn, err);
 
               if (nargout > 3)
                 retval(3) = err;
               retval(2) = dn;
               retval(1) = cn;
               retval(0) = sn;
             }
           else
             {
               // u complex, m scalar
-              Complex u = u_arg.xcomplex_value ("ellipj: expecting scalar or matrix as first argument");
+              Complex u = u_arg.xcomplex_value ("ellipj: U must be a scalar or matrix");
 
               Complex sn, cn, dn;
               double err = 0;
 
               ellipj (u, m, sn, cn, dn, err);
 
               if (nargout > 3)
                 retval(3) = err;
               retval(2) = dn;
               retval(1) = cn;
               retval(0) = sn;
             }
         }
       else
         {
           // u is matrix, m is scalar
-          ComplexNDArray u = u_arg.xcomplex_array_value ("ellipj: expecting scalar or matrix as first argument");
+          ComplexNDArray u = u_arg.xcomplex_array_value ("ellipj: U must be a scalar or matrix");
 
           dim_vector sz_u = u.dims ();
 
           ComplexNDArray sn (sz_u), cn (sz_u), dn (sz_u);
           NDArray err (sz_u);
 
           const Complex *pu = u.data ();
           Complex *psn = sn.fortran_vec ();
@@ -144,27 +144,27 @@ and 16.15), Dover, 1965.\n\
             retval(3) = err;
           retval(2) = dn;
           retval(1) = cn;
           retval(0) = sn;
         }
     }
   else
     {
-      NDArray m = args(1).xarray_value ("ellipj: expecting scalar or matrix as second argument");
+      NDArray m = args(1).xarray_value ("ellipj: M must be a scalar or matrix");
 
       dim_vector sz_m = m.dims ();
 
       if (u_arg.is_scalar_type ())
         {
           // u is scalar, m is array
           if (u_arg.is_real_type ())
             {
               // u is real scalar, m is array
-              double u = u_arg.xdouble_value ("ellipj: expecting scalar or matrix as first argument");
+              double u = u_arg.xdouble_value ("ellipj: U must be a scalar or matrix");
 
               NDArray sn (sz_m), cn (sz_m), dn (sz_m);
               NDArray err (sz_m);
 
               const double *pm = m.data ();
               double *psn = sn.fortran_vec ();
               double *pcn = cn.fortran_vec ();
               double *pdn = dn.fortran_vec ();
@@ -178,17 +178,17 @@ and 16.15), Dover, 1965.\n\
                 retval(3) = err;
               retval(2) = dn;
               retval(1) = cn;
               retval(0) = sn;
             }
           else
             {
               // u is complex scalar, m is array
-              Complex u = u_arg.xcomplex_value ("ellipj: expecting scalar or matrix as first argument");
+              Complex u = u_arg.xcomplex_value ("ellipj: U must be a scalar or matrix");
 
               ComplexNDArray sn (sz_m), cn (sz_m), dn (sz_m);
               NDArray err (sz_m);
 
               const double *pm = m.data ();
               Complex *psn = sn.fortran_vec ();
               Complex *pcn = cn.fortran_vec ();
               Complex *pdn = dn.fortran_vec ();
@@ -206,17 +206,17 @@ and 16.15), Dover, 1965.\n\
             }
         }
       else
         {
           // u is array, m is array
           if (u_arg.is_real_type ())
             {
               // u is real array, m is array
-              NDArray u = u_arg.xarray_value ("ellipj: expecting scalar or matrix as first argument");
+              NDArray u = u_arg.xarray_value ("ellipj: U must be a scalar or matrix");
 
               dim_vector sz_u = u.dims ();
 
               if (sz_u.length () == 2 && sz_m.length () == 2
                   && sz_u(1) == 1 && sz_m(0) == 1)
                 {
                   // u is real column vector, m is row vector
                   octave_idx_type ur = sz_u(0);
@@ -263,17 +263,17 @@ and 16.15), Dover, 1965.\n\
                   retval(0) = sn;
                 }
               else
                 error ("ellipj: Invalid size combination for U and M");
             }
           else
             {
               // u is complex array, m is array
-              ComplexNDArray u = u_arg.xcomplex_array_value ("ellipj: expecting scalar or matrix as second argument");
+              ComplexNDArray u = u_arg.xcomplex_array_value ("ellipj: U must be a scalar or matrix");
 
               dim_vector sz_u = u.dims ();
 
               if (sz_u.length () == 2 && sz_m.length () == 2
                   && sz_u(1) == 1 && sz_m(0) == 1)
                 {
                   // u is complex column vector, m is row vector
                   octave_idx_type ur = sz_u(0);
@@ -866,25 +866,25 @@ and 16.15), Dover, 1965.\n\
 %! x = [-1e-3, -1e-12, 0, 1e-12, 1e-3];
 %! [~, ~, dn] = ellipj (u + x, m);
 %! D = 1/sqrt (2) * ones (size (x));
 %! assert (dn, D, 1e-6);
 
 %!error ellipj ()
 %!error ellipj (1)
 %!error ellipj (1,2,3,4)
-%!warning <expecting 0 <= M <= 1> ellipj (1,2);
+%!warning <required value 0 <= M <= 1> ellipj (1,2);
 ## FIXME: errors commented out untill lasterr() truly returns the last error.
-%!#error <expecting scalar or matrix as second argument> ellipj (1, "1")
-%!#error <expecting scalar or matrix as first argument> ellipj ("1", 1)
-%!#error <expecting scalar or matrix as first argument> ellipj ({1}, 1)
-%!#error <expecting scalar or matrix as first argument> ellipj ({1, 2}, 1)
-%!#error <expecting scalar or matrix as second argument> ellipj (1, {1, 2})
-%!#error <expecting scalar or matrix as first argument> ellipj ("1", [1, 2])
-%!#error <expecting scalar or matrix as first argument> ellipj ({1}, [1, 2])
-%!#error <expecting scalar or matrix as first argument> ellipj ({1}, [1, 2])
-%!#error <expecting scalar or matrix as first argument> ellipj ("1,2", [1, 2])
-%!#error <expecting scalar or matrix as first argument> ellipj ({1, 2}, [1, 2])
+%!#error <M must be a scalar or matrix> ellipj (1, "1")
+%!#error <U must be a scalar or matrix> ellipj ("1", 1)
+%!#error <U must be a scalar or matrix> ellipj ({1}, 1)
+%!#error <U must be a scalar or matrix> ellipj ({1, 2}, 1)
+%!#error <M must be a scalar or matrix> ellipj (1, {1, 2})
+%!#error <U must be a scalar or matrix> ellipj ("1", [1, 2])
+%!#error <U must be a scalar or matrix> ellipj ({1}, [1, 2])
+%!#error <U must be a scalar or matrix> ellipj ({1}, [1, 2])
+%!#error <U must be a scalar or matrix> ellipj ("1,2", [1, 2])
+%!#error <U must be a scalar or matrix> ellipj ({1, 2}, [1, 2])
 %!error <Invalid size combination for U and M> ellipj ([1:4], [1:3])
 %!error <Invalid size combination for U and M> ellipj (complex (1:4,1:4), [1:3])
 
 */
 
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -1663,17 +1663,17 @@ disable escape sequence expansion use a 
                 {
                   std::string tst = state(i).string_value ();
                   std::string tid = ident(i).string_value ();
 
                   set_warning_option (tst, tid);
                 }
             }
           else
-            error ("warning: expecting structure with fields 'identifier' and 'state'");
+            error ("warning: STATE structure must have fields 'identifier' and 'state'");
 
           done = true;
 
           if (nargout > 0)
             retval = old_warning_options;
         }
     }
 
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -218,17 +218,17 @@ opengl_texture::create (const octave_val
             }
 
           glTexImage2D (GL_TEXTURE_2D, 0, 3, tw, th, 0,
                         GL_RGB, GL_UNSIGNED_BYTE, a);
         }
       else
         {
           ok = false;
-          warning ("opengl_texture::create: invalid texture data type (expected double or uint8)");
+          warning ("opengl_texture::create: invalid texture data type (double or uint8 required)");
         }
 
       if (ok)
         {
           glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
           glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
 
           if (glGetError () != GL_NO_ERROR)
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -1663,17 +1663,17 @@ property::create (const std::string& nam
       retval = property (new any_property (name, h, ov));
     }
   else if (type.compare ("radio"))
     {
       if (args.length () < 1)
         error ("addproperty: missing possible values for radio property");
       else
         {
-          std::string sv = args(0).xstring_value ("addproperty: invalid argument for radio property, expected a string value");
+          std::string sv = args(0).xstring_value ("addproperty: argument for radio property must be a string");
 
           retval = property (new radio_property (name, h, sv));
 
           if (args.length () > 1)
             retval.set (args(1));
         }
     }
   else if (type.compare ("double"))
@@ -2141,17 +2141,17 @@ graphics_object::set (const octave_value
   if (nargin == 0)
     error ("graphics_object::set: Nothing to set");
   else if (nargin % 2 != 0)
     error ("set: invalid number of arguments");
   else
     {
       for (int i = 0; i < nargin; i += 2)
         {
-          caseless_str pname = args(i).xstring_value ("set: expecting argument %d to be a property name", i);
+          caseless_str pname = args(i).xstring_value ("set: argument %d must be a property name", i);
 
           octave_value val = args(i+1);
 
           set_value_or_default (pname, val);
         }
     }
 }
 
@@ -2547,17 +2547,17 @@ xget (const graphics_handle& h, const ca
 
 static graphics_handle
 reparent (const octave_value& ov, const std::string& who,
           const std::string& pname, const graphics_handle& new_parent,
           bool adopt = true)
 {
   graphics_handle h = octave_NaN;
 
-  double hv = ov.xdouble_value ("%s: expecting %s to be a graphics handle",
+  double hv = ov.xdouble_value ("%s: %s must be a graphics handle",
                                who.c_str (), pname.c_str ());
 
   h = gh_manager::lookup (hv);
 
   if (h.ok ())
     {
       graphics_object go = gh_manager::get_object (h);
 
@@ -2960,17 +2960,17 @@ base_properties::get_property_dynamic (c
     }
   else
     return it->second;
 }
 
 void
 base_properties::set_parent (const octave_value& val)
 {
-  double hp = val.xdouble_value ("set: expecting parent to be a graphics handle");
+  double hp = val.xdouble_value ("set: parent must be a graphics handle");
 
   graphics_handle new_parent = octave_NaN;
 
   if (hp == __myhandle__)
     error ("set: can not set object parent to be object itself");
   else
     {
       new_parent = gh_manager::lookup (hp);
@@ -9619,17 +9619,17 @@ each individual object will be reset.\n\
 {
   int nargin = args.length ();
 
   if (nargin != 1)
     print_usage ();
   else
     {
       // get vector of graphics handles
-      ColumnVector hcv = args(0).xvector_value ("reset: expecting graphics handle as first argument");
+      ColumnVector hcv = args(0).xvector_value ("reset: H must be a graphics handle");
 
       // loop over graphics objects
       for (octave_idx_type n = 0; n < hcv.numel (); n++)
         gh_manager::get_object (hcv(n)).reset_default_properties ();
 
       Fdrawnow ();
     }
 
@@ -9828,17 +9828,17 @@ being @qcode{\"portrait\"}.\n\
 
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin > 0)
     {
       // get vector of graphics handles
-      ColumnVector hcv = args(0).xvector_value ("set: expecting graphics handle as first argument");
+      ColumnVector hcv = args(0).xvector_value ("set: H must be a graphics handle");
 
       bool request_drawnow = false;
 
       // loop over graphics objects
       for (octave_idx_type n = 0; n < hcv.numel (); n++)
         {
           graphics_object go = gh_manager::get_object (hcv(n));
 
@@ -9975,39 +9975,39 @@ lists respectively.\n\
   if (nargin == 1 || nargin == 2)
     {
       if (args(0).is_empty ())
         {
           retval = Matrix ();
           return retval;
         }
 
-      ColumnVector hcv = args(0).xvector_value ("get: expecting graphics handle as first argument");
+      ColumnVector hcv = args(0).xvector_value ("get: H must be a graphics handle");
 
       octave_idx_type len = hcv.numel ();
 
       if (nargin == 1 && len > 1)
         {
           std::string typ0 = get_graphics_object_type (hcv(0));
 
           for (octave_idx_type n = 1; n < len; n++)
             {
               std::string typ = get_graphics_object_type (hcv(n));
 
               if (typ != typ0)
                 {
-                  error ("get: vector of handles must all have same type");
+                  error ("get: vector of handles must all have the same type");
                   break;
                 }
             }
         }
 
       if (nargin > 1 && args(1).is_cellstr ())
         {
-          Array<std::string> plist = args(1).xcellstr_value ("get: expecting property name or cell array of property names as second argument");
+          Array<std::string> plist = args(1).cellstr_value ();
 
           octave_idx_type plen = plist.numel ();
 
           use_cell_format = true;
 
           vals.resize (dim_vector (len, plen));
 
           for (octave_idx_type n = 0; n < len; n++)
@@ -10030,17 +10030,17 @@ lists respectively.\n\
                 }
             }
         }
       else
         {
           caseless_str property;
 
           if (nargin > 1)
-            property = args(1).xstring_value ("get: expecting property name or cell array of property names as second argument");
+            property = args(1).xstring_value ("get: second argument must be property name or cell array of property names");
 
           vals.resize (dim_vector (len, 1));
 
           for (octave_idx_type n = 0; n < len; n++)
             {
               graphics_object go = gh_manager::get_object (hcv(n));
 
               if (go)
@@ -10106,17 +10106,17 @@ Undocumented internal function.\n\
   octave_value retval;
 
   Cell vals;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      ColumnVector hcv = args(0).xvector_value ("get: expecting graphics handle as first argument");
+      ColumnVector hcv = args(0).xvector_value ("get: H must be a graphics handle");
 
       octave_idx_type len = hcv.numel ();
 
       vals.resize (dim_vector (len, 1));
 
       for (octave_idx_type n = 0; n < len; n++)
         {
           graphics_object go = gh_manager::get_object (hcv(n));
@@ -10214,17 +10214,17 @@ Undocumented internal function.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
   if (args.length () > 0)
     {
-      double val = args(0).xdouble_value ("__go_figure__: expecting figure number to be double value");
+      double val = args(0).xdouble_value ("__go_figure__: figure number must be a double value");
 
       if (is_figure (val))
         {
           graphics_handle h = gh_manager::lookup (val);
 
           xset (h, args.splice (0, 1));
 
           retval = h.value ();
@@ -10355,17 +10355,17 @@ Determine the number of dimensions in a 
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      double h = args(0).xdouble_value ("__calc_dimensions__: expecting graphics handle as only argument");
+      double h = args(0).xdouble_value ("__calc_dimensions__: first argument must be a graphics handle");
 
       retval = calc_dimensions (gh_manager::get_object (h));
     }
   else
     print_usage ();
 
   return retval;
 }
@@ -10876,23 +10876,23 @@ undocumented.\n\
                     }
                 }
             }
 
           bool do_events = true;
 
           if (args.length () == 1)
             {
-              caseless_str val (args(0).xstring_value ("drawnow: expecting argument to be a string"));
+              caseless_str val (args(0).xstring_value ("drawnow: first argument must be a string"));
 
               if (val.compare ("expose"))
                 do_events = false;
               else
                 {
-                  error ("drawnow: invalid argument, expected 'expose' as argument");
+                  error ("drawnow: invalid argument, 'expose' is only valid option");
 
                   gh_manager::unlock ();
 
                   return retval;
                 }
             }
 
           if (do_events)
@@ -10904,19 +10904,19 @@ undocumented.\n\
               gh_manager::lock ();
             }
         }
       else if (args.length () >= 2 && args.length () <= 4)
         {
           std::string term, file, debug_file;
           bool mono;
 
-          term = args(0).xstring_value ("drawnow: invalid terminal TERM, expected a string value");
-
-          file = args(1).xstring_value ("drawnow: invalid FILE, expected a string value");
+          term = args(0).xstring_value ("drawnow: TERM must be a string");
+
+          file = args(1).xstring_value ("drawnow: FILE must be a string");
 
           size_t pos_p = file.find_first_of ("|");
           size_t pos_c = file.find_first_not_of ("| ");
 
           if (pos_p == std::string::npos &&
               pos_c == std::string::npos)
             {
               error ("drawnow: empty output ''");
@@ -10955,19 +10955,19 @@ undocumented.\n\
 
                       gh_manager::unlock ();
 
                       return retval;
                     }
                 }
             }
 
-          mono = (args.length () >= 3 ? args(2).xbool_value ("drawnow: invalid colormode MONO, expected a boolean value") : false);
-
-          debug_file = (args.length () > 3 ? args(3).xstring_value ("drawnow: invalid DEBUG_FILE, expected a string value") : "");
+          mono = (args.length () >= 3 ? args(2).xbool_value ("drawnow: MONO colormode must be a boolean value") : false);
+
+          debug_file = (args.length () > 3 ? args(3).xstring_value ("drawnow: DEBUG_FILE must be a string") : "");
 
           graphics_handle h = gcf ();
 
           if (h.ok ())
             {
               graphics_object go = gh_manager::get_object (h);
 
               gh_manager::unlock ();
@@ -11025,19 +11025,19 @@ addlistener (gcf, \"position\", @{@@my_l
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
   if (args.length () >= 3 && args.length () <= 4)
     {
-      double h = args(0).xdouble_value ("addlistener: invalid handle");
-
-      std::string pname = args(1).xstring_value ("addlistener: invalid property name, expected a string value");
+      double h = args(0).xdouble_value ("addlistener: invalid handle H");
+
+      std::string pname = args(1).xstring_value ("addlistener: PROP must be a string");
 
       graphics_handle gh = gh_manager::lookup (h);
 
       if (gh.ok ())
         {
           graphics_object go = gh_manager::get_object (gh);
 
           go.add_property_listener (pname, args(2), POSTSET);
@@ -11089,17 +11089,17 @@ dellistener (gcf, \"position\", c);\n\
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
   if (args.length () == 3 || args.length () == 2)
     {
       double h = args(0).xdouble_value ("dellistener: invalid handle");
 
-      std::string pname = args(1).xstring_value ("dellistener: invalid property name, expected a string value");
+      std::string pname = args(1).xstring_value ("dellistener: PROP must be a string");
 
       graphics_handle gh = gh_manager::lookup (h);
 
       if (gh.ok ())
         {
           graphics_object go = gh_manager::get_object (gh);
 
           if (args.length () == 2)
@@ -11200,27 +11200,27 @@ addproperty (\"my_style\", gcf, \"lineli
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
   if (args.length () >= 3)
     {
-      std::string name = args(0).xstring_value ("addproperty: invalid property NAME, expected a string value");
-
-      double h = args(1).xdouble_value ("addproperty: invalid handle value");
+      std::string name = args(0).xstring_value ("addproperty: NAME must be a string");
+
+      double h = args(1).xdouble_value ("addproperty: invalid handle H");
 
       graphics_handle gh = gh_manager::lookup (h);
 
       if (gh.ok ())
         {
           graphics_object go = gh_manager::get_object (gh);
 
-          std::string type = args(2).xstring_value ("addproperty: invalid property TYPE, expected a string value");
+          std::string type = args(2).xstring_value ("addproperty: TYPE must be a string");
 
           if (! go.get_properties ().has_property (name))
             {
               property p = property::create (name, gh, type,
                                              args.splice (0, 3));
 
               go.get_properties ().insert_property (name, p);
             }
@@ -11538,17 +11538,17 @@ In all cases, typing CTRL-C stops progra
                                          ov_del_listener);
                           go.add_property_listener (pname, ov_del_listener,
                                                     PREDELETE);
                         }
                     }
                 }
             }
           else if (error_state || pname.empty ())
-            error ("waitfor: invalid property name, expected a non-empty string value");
+            error ("waitfor: PROP must be a non-empty string");
         }
 
       if (timeout_index < 0 && args.length () > (max_arg_index + 1))
         {
           caseless_str s = args(max_arg_index + 1).string_value ();
 
           if (! error_state)
             {
@@ -11561,26 +11561,26 @@ In all cases, typing CTRL-C stops progra
             error ("waitfor: invalid parameter, expected 'timeout'");
         }
 
       if (timeout_index >= 0)
         {
           if (args.length () > (timeout_index + 1))
             {
               timeout = static_cast<int>
-                (args(timeout_index + 1).xscalar_value ("waitfor: invalid timeout value, expected a value >= 1"));
+                (args(timeout_index + 1).xscalar_value ("waitfor: TIMEOUT must be a scalar >= 1"));
 
               if (timeout < 1)
                 {
-                  warning ("waitfor: the timeout value must be >= 1, using 1 instead");
+                  warning ("waitfor: TIMEOUT value must be >= 1, using 1 instead");
                   timeout = 1;
                 }
             }
           else
-            error ("waitfor: missing timeout value");
+            error ("waitfor: missing TIMEOUT value");
         }
 
       // FIXME: There is still a "hole" in the following loop. The code
       //        assumes that an object handle is unique, which is a fair
       //        assumption, except for figures.  If a figure is destroyed
       //        then recreated with the same figure ID, within the same
       //        run of event hooks, then the figure destruction won't be
       //        caught and the loop will not stop.  This is an unlikely
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -1700,17 +1700,17 @@ protected:
     Matrix new_kids;
 
     try
       {
         new_kids = val.matrix_value ();
       }
     catch (const octave_execution_exception&)
       {
-        error ("set: expecting children to be array of graphics handles");
+        error ("set: children must be an array of graphics handles");
       }
 
     octave_idx_type nel = new_kids.numel ();
 
     const Matrix new_kids_column = new_kids.reshape (dim_vector (nel, 1));
 
     bool is_ok = true;
     bool add_hidden = true;
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -2422,28 +2422,28 @@ addpath (\"dir1:/dir2:~/dir3\")\n\
               append = true;
               nargin--;
             }
           else if (option == "-begin")
             nargin--;
         }
       else if (option_arg.is_numeric_type ())
         {
-          int val = option_arg.xint_value ("addpath: expecting final argument to be 1 or 0");
+          int val = option_arg.xint_value ("addpath: OPTION must be '-begin'/0 or '-end'/1");
 
           if (val == 0)
             nargin--;
           else if (val == 1)
             {
               append = true;
               nargin--;
             }
           else
             {
-              error ("addpath: expecting final argument to be 1 or 0");
+              error ("addpath: OPTION must be '-begin'/0 or '-end'/1");
               return retval;
             }
         }
 
       bool need_to_update = false;
 
       for (int i = 0; i < nargin; i++)
         {
diff --git a/libinterp/corefcn/lsode.cc b/libinterp/corefcn/lsode.cc
--- a/libinterp/corefcn/lsode.cc
+++ b/libinterp/corefcn/lsode.cc
@@ -379,25 +379,25 @@ parameters for @code{lsode}.\n\
                   error ("lsode: first arg should be a string or 2-element string array");
                 }
             }
         }
 
       if (! lsode_fcn)
         error ("lsode: FCN argument is not a valid function name or handle");
 
-      ColumnVector state = args(1).xvector_value ("lsode: expecting state vector as second argument");
-      ColumnVector out_times = args(2).xvector_value ("lsode: expecting output time vector as third argument");
+      ColumnVector state = args(1).xvector_value ("lsode: initial state X_0 must be a vector");
+      ColumnVector out_times = args(2).xvector_value ("lsode: output time variable T must be a vector");
 
       ColumnVector crit_times;
 
       int crit_times_set = 0;
       if (nargin > 3)
         {
-          crit_times = args(3).xvector_value ("lsode: expecting critical time vector as fourth argument");
+          crit_times = args(3).xvector_value ("lsode: list of critical times T_CRIT must be a vector");
 
           crit_times_set = 1;
         }
 
       double tzero = out_times (0);
 
       ODEFunc func (lsode_user_function);
       if (lsode_jac)
diff --git a/libinterp/corefcn/lu.cc b/libinterp/corefcn/lu.cc
--- a/libinterp/corefcn/lu.cc
+++ b/libinterp/corefcn/lu.cc
@@ -179,17 +179,17 @@ information.\n\
             {
               thres.resize (1,2);
               thres(0) = tmp(0);
               thres(1) = tmp(0);
             }
           else if (tmp.numel () == 2)
             thres = tmp;
           else
-            error ("lu: expecting 2-element vector for THRES");
+            error ("lu: THRES must be a 1 or 2-element vector");
         }
     }
 
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
diff --git a/libinterp/corefcn/luinc.cc b/libinterp/corefcn/luinc.cc
--- a/libinterp/corefcn/luinc.cc
+++ b/libinterp/corefcn/luinc.cc
@@ -154,17 +154,17 @@ values of @var{p} @var{q} as vector valu
 
               if (thresh.numel () == 1)
                 {
                   thresh.resize (1,2);
                   thresh(1) = thresh(0);
                 }
               else if (thresh.numel () != 2)
                 {
-                  error ("luinc: expecting 2-element vector for thresh");
+                  error ("luinc: THRESH must be a 1 or 2-element vector");
                   return retval;
                 }
             }
         }
       else
         droptol = args(1).double_value ();
 
       if (nargin == 3)
diff --git a/libinterp/corefcn/oct-hist.cc b/libinterp/corefcn/oct-hist.cc
--- a/libinterp/corefcn/oct-hist.cc
+++ b/libinterp/corefcn/oct-hist.cc
@@ -167,18 +167,18 @@ do_history (const octave_value_list& arg
         }
 
       if (option == "-r" || option == "-w" || option == "-a"
           || option == "-n")
         {
           if (i < nargin - 1)
             {
               std::string fname
-                = args(++i).xstring_value ("history: expecting file name for %s option",
-                                          option.c_str ());
+                = args(++i).xstring_value ("history: filename must be a string for %s option",
+                                           option.c_str ());
 
               command_history::set_file (fname);
             }
           else
             command_history::set_file (default_history_file ());
 
           if (option == "-a")
             // Append 'new' lines to file.
diff --git a/libinterp/corefcn/oct-obj.cc b/libinterp/corefcn/oct-obj.cc
--- a/libinterp/corefcn/oct-obj.cc
+++ b/libinterp/corefcn/oct-obj.cc
@@ -258,17 +258,17 @@ octave_value_list::make_argv (const std:
               string_vector tmp = elem(i).all_strings ();
 
               for (octave_idx_type j = 0; j < nr; j++)
                 argv[k++] = tmp[j];
             }
         }
     }
   else
-    error ("%s: expecting all arguments to be strings", fcn_name.c_str ());
+    error ("%s: all arguments must be strings", fcn_name.c_str ());
 
   return argv;
 }
 
 void
 octave_value_list::make_storable_values (void)
 {
   octave_idx_type len = length ();
diff --git a/libinterp/corefcn/octave-link.cc b/libinterp/corefcn/octave-link.cc
--- a/libinterp/corefcn/octave-link.cc
+++ b/libinterp/corefcn/octave-link.cc
@@ -117,25 +117,25 @@ DEFUN (__octave_link_edit_file__, args, 
 @deftypefn {Built-in Function} {} __octave_link_edit_file__ (@var{file})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
-      std::string file = args(0).xstring_value ("expecting file name as argument");
+      std::string file = args(0).xstring_value ("first argument must be filename");
 
       flush_octave_stdout ();
 
       retval = octave_link::edit_file (file);
     }
   else if (args.length () == 2)
     {
-      std::string file = args(0).xstring_value ("expecting file name as first argument");
+      std::string file = args(0).xstring_value ("first argument must be filename");
 
       flush_octave_stdout ();
 
       retval = octave_link::prompt_new_edit_file (file);
     }
 
   return retval;
 }
diff --git a/libinterp/corefcn/quad.cc b/libinterp/corefcn/quad.cc
--- a/libinterp/corefcn/quad.cc
+++ b/libinterp/corefcn/quad.cc
@@ -224,18 +224,18 @@ variable by routines @code{dblquad} and 
           frame.add_fcn (clear_function, fcn_name);
         }
 
       if (! quad_fcn)
         error ("quad: FCN argument is not a valid function name or handle");
 
       if (args(1).is_single_type () || args(2).is_single_type ())
         {
-          float a = args(1).xfloat_value ("quad: expecting second argument to be a scalar");
-          float b = args(2).xfloat_value ("quad: expecting third argument to be a scalar");
+          float a = args(1).xfloat_value ("quad: lower limit of integration A must be a scalar");
+          float b = args(2).xfloat_value ("quad: upper limit of integration B must be a scalar");
 
           int indefinite = 0;
           FloatIndefQuad::IntegralType indef_type
             = FloatIndefQuad::doubly_infinite;
           float bound = 0.0;
           if (xisinf (a) && xisinf (b))
             {
               indefinite = 1;
@@ -265,32 +265,32 @@ variable by routines @code{dblquad} and 
           switch (nargin)
             {
             case 5:
               if (indefinite)
                 error ("quad: singularities not allowed on infinite intervals");
 
               have_sing = true;
 
-              sing = args(4).xfloat_vector_value ("quad: expecting vector of singularities as fourth argument");
+              sing = args(4).xfloat_vector_value ("quad: fifth argument SING must be a vector vector of singularities");
 
             case 4:
-              tol = args(3).xfloat_vector_value ("quad: expecting vector of tolerances as fifth argument");
+              tol = args(3).xfloat_vector_value ("quad: TOL must be a 1 or 2-element vector");
 
               switch (tol.numel ())
                 {
                 case 2:
                   quad_opts.set_single_precision_relative_tolerance (tol (1));
 
                 case 1:
                   quad_opts.set_single_precision_absolute_tolerance (tol (0));
                   break;
 
                 default:
-                  error ("quad: expecting tol to contain no more than two values");
+                  error ("quad: TOL must be a 1 or 2-element vector");
                 }
 
             case 3:
               if (indefinite)
                 {
                   FloatIndefQuad iq (quad_float_user_function, bound,
                                      indef_type);
                   iq.set_options (quad_opts);
@@ -321,18 +321,18 @@ variable by routines @code{dblquad} and 
           retval(3) = abserr;
           retval(2) = nfun;
           retval(1) = ier;
           retval(0) = val;
 
         }
       else
         {
-          double a = args(1).xdouble_value ("quad: expecting second argument to be a scalar");
-          double b = args(2).xdouble_value ("quad: expecting third argument to be a scalar");
+          double a = args(1).xdouble_value ("quad: lower limit of integration A must be a scalar");
+          double b = args(2).xdouble_value ("quad: upper limit of integration B must be a scalar");
 
           int indefinite = 0;
           IndefQuad::IntegralType indef_type = IndefQuad::doubly_infinite;
           double bound = 0.0;
           if (xisinf (a) && xisinf (b))
             {
               indefinite = 1;
               indef_type = IndefQuad::doubly_infinite;
@@ -361,32 +361,32 @@ variable by routines @code{dblquad} and 
           switch (nargin)
             {
             case 5:
               if (indefinite)
                 error ("quad: singularities not allowed on infinite intervals");
 
               have_sing = true;
 
-              sing = args(4).vector_value ("quad: expecting vector of singularities as fourth argument");
+              sing = args(4).vector_value ("quad: fifth argument SING must be a vector vector of singularities");
 
             case 4:
-              tol = args(3).xvector_value ("quad: expecting vector of tolerances as fifth argument");
+              tol = args(3).xvector_value ("quad: TOL must be a 1 or 2-element vector");
 
               switch (tol.numel ())
                 {
                 case 2:
                   quad_opts.set_relative_tolerance (tol (1));
 
                 case 1:
                   quad_opts.set_absolute_tolerance (tol (0));
                   break;
 
                 default:
-                  error ("quad: expecting tol to contain no more than two values");
+                  error ("quad: TOL must be a 1 or 2-element vector");
                 }
 
             case 3:
               if (indefinite)
                 {
                   IndefQuad iq (quad_user_function, bound, indef_type);
                   iq.set_options (quad_opts);
                   val = iq.integrate (ier, nfun, abserr);
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -82,24 +82,24 @@ do_rand (const octave_value_list& args, 
       else if (s_arg == "double")
         nargin--;
     }
 
   if (additional_arg)
     {
       if (nargin == 0)
         {
-          error ("%s: expecting at least one argument", fcn);
+          error ("%s: at least one argument is required", fcn);
           goto done;
         }
       else if (args(0).is_string ())
         additional_arg = false;
       else
         {
-          a = args(0).xarray_value ("%s: expecting scalar or matrix arguments", fcn);
+          a = args(0).xarray_value ("%s: dimension must be a scalar integer", fcn);
 
           idx++;
           nargin--;
         }
     }
 
   switch (nargin)
     {
@@ -189,51 +189,50 @@ do_rand (const octave_value_list& args, 
 
                 dims.resize (n);
 
                 octave_idx_type base = NINTbig (r.base ());
                 octave_idx_type incr = NINTbig (r.inc ());
 
                 for (octave_idx_type i = 0; i < n; i++)
                   {
-                    //Negative dimensions are treated as zero for Matlab
-                    //compatibility
+                    // Negative dimensions are treated as zero for Matlab
+                    // compatibility
                     dims(i) = base >= 0 ? base : 0;
                     base += incr;
                   }
 
                 goto gen_matrix;
 
               }
             else
-              error ("%s: all elements of range must be integers",
-                     fcn);
+              error ("%s: all elements of range must be integers", fcn);
           }
         else if (tmp.is_matrix_type ())
           {
             Array<int> iv = tmp.int_vector_value (true);
 
             if (! error_state)
               {
                 octave_idx_type len = iv.numel ();
 
                 dims.resize (len);
 
                 for (octave_idx_type i = 0; i < len; i++)
                   {
-                    //Negative dimensions are treated as zero for Matlab
-                    //compatibility
+                    // Negative dimensions are treated as zero for Matlab
+                    // compatibility
                     octave_idx_type elt = iv(i);
                     dims(i) = elt >=0 ? elt : 0;
                   }
 
                 goto gen_matrix;
               }
             else
-              error ("%s: expecting integer vector", fcn);
+              error ("%s: dimensions must be a scalar or array of integers", fcn);
           }
         else
           {
             gripe_wrong_type_arg ("rand", tmp);
             return retval;
           }
       }
       break;
@@ -277,19 +276,19 @@ do_rand (const octave_value_list& args, 
               error ("%s: unrecognized string argument", fcn);
           }
         else
           {
             dims.resize (nargin);
 
             for (int i = 0; i < nargin; i++)
               {
-                octave_idx_type elt = args(idx+i).xint_value ("%s: expecting integer arguments", fcn);
+                octave_idx_type elt = args(idx+i).xint_value ("%s: dimension must be a scalar or array of integers", fcn);
 
-                //Negative is zero for Matlab compatibility
+                // Negative is zero for Matlab compatibility
                 dims(i) = elt >= 0 ? elt : 0;
               }
 
             goto gen_matrix;
           }
       }
       break;
     }
@@ -1188,18 +1187,18 @@ using std::unordered_map;
 
           // Perform the Knuth shuffle only keeping track of moved
           // entries in the map
           for (octave_idx_type i = 0; i < m; i++)
             {
               octave_idx_type k = i +
                 gnulib::floor (rvec[i] * (n - i));
 
-              //For shuffling first m entries, no need to use extra
-              //storage
+              // For shuffling first m entries, no need to use extra
+              // storage
               if (k < m)
                 {
                   std::swap (ivec[i], ivec[k]);
                 }
               else
                 {
                   if (map.find (k) == map.end ())
                     map[k] = k;
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -1683,26 +1683,26 @@ determine whether functions defined in f
         default:
           retval = "none";
           break;
         }
     }
 
   if (nargin == 1)
     {
-      std::string sval = args(0).xstring_value ("ignore_function_time_stamp: expecting argument to be a string");
+      std::string sval = args(0).xstring_value ("ignore_function_time_stamp: first argument must be a string");
 
       if (sval == "all")
         Vignore_function_time_stamp = 2;
       else if (sval == "system")
         Vignore_function_time_stamp = 1;
       else if (sval == "none")
         Vignore_function_time_stamp = 0;
       else
-        error ("ignore_function_time_stamp: argument must be \"all\", \"system\", or \"none\"");
+        error ("ignore_function_time_stamp: argument must be one of \"all\", \"system\", or \"none\"");
     }
   else if (nargin > 1)
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -1786,21 +1786,21 @@ Undocumented internal function.\n\
 
               retval = v;
             }
           else if (s_arg == "functions")
             {
               symbol_table::dump_functions (octave_stdout);
             }
           else
-            error ("__dump_symtab_info__: expecting \"functions\" or \"scopes\"");
+            error ("__dump_symtab_info__: string argument must be \"functions\" or \"scopes\"");
         }
       else
         {
-          int s = arg.xint_value ("__dump_symtab_info__: expecting string or scope id");
+          int s = arg.xint_value ("__dump_symtab_info__: first argument must be string or scope id");
 
           symbol_table::dump (octave_stdout, s);
         }
     }
   else
     print_usage ();
 
   return retval;
@@ -1811,17 +1811,17 @@ DEFUN (__get_cmdline_fcn_txt__, args, ,
 @deftypefn  {Built-in Function} {} __get_cmdline_fcn_txt__ (@var{name})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
-      std::string name = args(0).xstring_value ("__get_cmd_line_function_text__: expecting function name");
+      std::string name = args(0).xstring_value ("__get_cmd_line_function_text__: first argument must be function name");
 
       octave_value ov = symbol_table::find_cmdline_function (name);
 
       octave_user_function *f = ov.user_function_value ();
 
       if (f)
         {
           std::ostringstream buf;
@@ -1844,33 +1844,33 @@ Undocumented internal function.\n\
 // FIXME: should we have functions like this in Octave?
 
 DEFUN (set_variable, args, , "set_variable (NAME, VALUE)")
 {
   octave_value retval;
 
   if (args.length () == 2)
     {
-      std::string name = args(0).xstring_value ("set_variable: expecting variable name as first argument");
+      std::string name = args(0).xstring_value ("set_variable: variable NAME must be a string");
 
       symbol_table::assign (name, args(1));
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (variable_value, args, , "VALUE = variable_value (NAME)")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
-      std::string name = args(0).xstring_value ("variable_value: expecting variable name as first argument");
+      std::string name = args(0).xstring_value ("variable_value: variable NAME must be a string");
 
       retval = symbol_table::varval (name);
 
       if (retval.is_undefined ())
         error ("variable_value: '%s' is not a variable in the current scope",
                name.c_str ());
     }
   else
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -933,27 +933,31 @@ Return the native floating point format 
 }
 
 /*
 %!assert (ischar (native_float_format ()))
 */
 
 DEFUN (tilde_expand, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} tilde_expand (@var{string})\n\
+@deftypefn  {Built-in Function} {} tilde_expand (@var{string})\n\
+@deftypefnx {Built-in Function} {} tilde_expand (@var{cellstr})\n\
 Perform tilde expansion on @var{string}.\n\
 \n\
 If @var{string} begins with a tilde character, (@samp{~}), all of the\n\
 characters preceding the first slash (or all characters, if there is no\n\
 slash) are treated as a possible user name, and the tilde and the following\n\
 characters up to the slash are replaced by the home directory of the named\n\
 user.  If the tilde is followed immediately by a slash, the tilde is\n\
 replaced by the home directory of the user running Octave.\n\
 \n\
-For example:\n\
+If the input is a cell array of strings @var{cellstr} then tilde expansion\n\
+is performed on each string element.\n\
+\n\
+Examples:\n\
 \n\
 @example\n\
 @group\n\
 tilde_expand (\"~joeuser/bin\")\n\
      @result{} \"/home/joeuser/bin\"\n\
 tilde_expand (\"~/bin\")\n\
      @result{} \"/home/jwe/bin\"\n\
 @end group\n\
@@ -963,17 +967,17 @@ tilde_expand (\"~/bin\")\n\
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       octave_value arg = args(0);
 
-      string_vector sv = arg.all_strings ("tilde_expand: expecting argument to be char or cellstr object");
+      string_vector sv = arg.all_strings ("tilde_expand: argument must be char or cellstr object");
 
       sv = file_ops::tilde_expand (sv);
 
       if (arg.is_cellstr ())
         retval = Cell (arg.dims (), sv);
       else
         retval = sv;
     }
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -1063,17 +1063,17 @@ command shell that is started to run the
         }
 
       if (return_output && type == et_async)
         {
           error ("system: can't return output from commands run asynchronously");
           return retval;
         }
 
-      std::string cmd_str = args(0).xstring_value ("system: expecting string as first argument");
+      std::string cmd_str = args(0).xstring_value ("system: first argument must be a string");
 
 #if defined (__WIN32__) && ! defined (__CYGWIN__)
       // Work around weird double-quote handling on Windows systems.
       if (type == et_sync)
         cmd_str = "\"" + cmd_str + "\"";
 #endif
 
       if (type == et_async)
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -318,23 +318,23 @@ If no files are found, return an empty c
 
       if (names.numel () > 0)
         {
           if (nargin == 1)
             retval =
               octave_env::make_absolute (load_path::find_first_of (names));
           else if (nargin == 2)
             {
-              std::string opt = args(1).xstring_value ("file_in_loadpath: expecting option to be a string");
+              std::string opt = args(1).xstring_value ("file_in_loadpath: optional second argument must be a string");
 
               if (opt == "all")
                 retval = Cell (make_absolute
                                (load_path::find_all_first_of (names)));
               else
-                error ("file_in_loadpath: invalid option `%s'", opt.c_str ());
+                error ("file_in_loadpath: \"all\" is only valid second argument");
             }
         }
       else
         error ("file_in_loadpath: FILE argument must not be empty");
     }
   else
     print_usage ();
 
@@ -398,23 +398,23 @@ If no files are found, return an empty c
       string_vector names = args(1).xall_strings ("file_in_path: FILE argument must be a string");
 
       if (names.numel () > 0)
         {
           if (nargin == 2)
             retval = search_path_for_file (path, names);
           else if (nargin == 3)
             {
-              std::string opt = args(2).xstring_value ("file_in_path: expecting option to be a string");
+              std::string opt = args(2).xstring_value ("file_in_path: optional third argument must be a string");
 
               if (opt == "all")
                 retval = Cell (make_absolute
                                (search_path_for_all_files (path, names)));
               else
-                error ("file_in_path: invalid option `%s'", opt.c_str ());
+                error ("file_in_path: \"all\" is only valid third argument");
             }
         }
       else
         error ("file_in_path: FILE argument must not be empty");
     }
   else
     print_usage ();
 
@@ -1237,18 +1237,20 @@ get_dimensions (const octave_value& a, c
 
   check_dimensions (nr, nc, warn_for);
 }
 
 void
 get_dimensions (const octave_value& a, const octave_value& b,
                 const char *warn_for, octave_idx_type& nr, octave_idx_type& nc)
 {
-  nr = a.is_empty () ? 0 : a.int_value ("%s: expecting two scalar arguments", warn_for);
-  nc = b.is_empty () ? 0 : b.int_value ("%s: expecting two scalar arguments", warn_for);
+  nr = a.is_empty ()
+       ? 0 : a.int_value ("%s: row dimension must be a scalar", warn_for);
+  nc = b.is_empty ()
+       ? 0 : b.int_value ("%s: column dimension must be a scalar", warn_for);
 
   check_dimensions (nr, nc, warn_for);
 }
 
 octave_idx_type
 dims_to_numel (const dim_vector& dims, const octave_value_list& idx_arg)
 {
   octave_idx_type retval;
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -126,34 +126,34 @@ is_valid_function (const octave_value& a
 
   if (arg.is_string ())
     {
       fcn_name = arg.string_value ();
 
       ans = is_valid_function (fcn_name, warn_for, warn);
     }
   else if (warn)
-    error ("%s: expecting function name as argument", warn_for.c_str ());
+    error ("%s: argument must be a string containing function name", warn_for.c_str ());
 
   return ans;
 }
 
 octave_function *
 extract_function (const octave_value& arg, const std::string& warn_for,
                   const std::string& fname, const std::string& header,
                   const std::string& trailer)
 {
   octave_function *retval = 0;
 
   retval = is_valid_function (arg, warn_for, 0);
 
   if (! retval)
     {
-      std::string s = arg.xstring_value ("%s: expecting first argument to be a string",
-                                        warn_for.c_str ());
+      std::string s = arg.xstring_value ("%s: first argument must be a string",
+                                         warn_for.c_str ());
 
       std::string cmd = header;
       cmd.append (s);
       cmd.append (trailer);
 
       int parse_status;
 
       eval_string (cmd, true, parse_status, 0);
@@ -733,17 +733,17 @@ wants_local_change (const octave_value_l
     {
       if (args(1).is_string () && args(1).string_value () == "local")
         {
           nargin = 1;
           retval = true;
         }
       else
         {
-          error_with_cfn ("expecting second argument to be \"local\"");
+          error_with_cfn ("second argument must be \"local\"");
           nargin = 0;
         }
     }
 
   return retval;
 }
 
 template <class T>
@@ -774,17 +774,17 @@ set_internal_variable (bool& var, const 
   if (wants_local_change (args, nargin))
     {
       if (! try_local_protect (var))
         warning ("\"local\" has no effect outside a function");
     }
 
   if (nargin == 1)
     {
-      bool bval = args(0).xbool_value ("%s: expecting arg to be a logical value", nm);
+      bool bval = args(0).xbool_value ("%s: argument must be a logical value", nm);
 
       var = bval;
     }
   else if (nargin > 1)
     print_usage ();
 
   return retval;
 }
@@ -846,22 +846,22 @@ set_internal_variable (int& var, const o
   if (wants_local_change (args, nargin))
     {
       if (! try_local_protect (var))
         warning ("\"local\" has no effect outside a function");
     }
 
   if (nargin == 1)
     {
-      int ival = args(0).xint_value ("%s: expecting arg to be an integer value", nm);
+      int ival = args(0).xint_value ("%s: argument must be an integer value", nm);
 
       if (ival < minval)
-        error ("%s: expecting arg to be greater than %d", nm, minval);
+        error ("%s: arg must be greater than %d", nm, minval);
       else if (ival > maxval)
-        error ("%s: expecting arg to be less than or equal to %d",
+        error ("%s: arg must be less than or equal to %d",
                nm, maxval);
       else
         var = ival;
     }
   else if (nargin > 1)
     print_usage ();
 
   return retval;
@@ -882,22 +882,22 @@ set_internal_variable (double& var, cons
   if (wants_local_change (args, nargin))
     {
       if (! try_local_protect (var))
         warning ("\"local\" has no effect outside a function");
     }
 
   if (nargin == 1)
     {
-      double dval = args(0).xscalar_value ("%s: expecting arg to be a scalar value", nm);
+      double dval = args(0).xscalar_value ("%s: argument must be a scalar value", nm);
 
       if (dval < minval)
-        error ("%s: expecting arg to be greater than %g", minval);
+        error ("%s: argument must be greater than %g", minval);
       else if (dval > maxval)
-        error ("%s: expecting arg to be less than or equal to %g", maxval);
+        error ("%s: argument must be less than or equal to %g", maxval);
       else
         var = dval;
     }
   else if (nargin > 1)
     print_usage ();
 
   return retval;
 }
@@ -2656,17 +2656,17 @@ DEFUN (__varval__, args, ,
 @deftypefn {Built-in Function} {} __varval__ (@var{name})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
-      std::string name = args(0).xstring_value ("__varval__: expecting argument to be variable name");
+      std::string name = args(0).xstring_value ("__varval__: first argument must be a variable name");
 
       retval = symbol_table::varval (args(0).string_value ());
     }
   else
     print_usage ();
 
   return retval;
 }
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -2184,17 +2184,17 @@ public:
         if (go.isa ("uimenu"))
           fltk_label = dynamic_cast<const uimenu::properties&>
                        (go.get_properties ()).get_fltk_label ()
                        + "/"
                        + fltk_label;
         else if (go.isa ("figure") || go.isa ("uicontextmenu"))
           ;
         else
-          error ("unexpected parent object\n");
+          error ("invalid parent object\n");
 
         uimenup.set_fltk_label (fltk_label);
       }
   }
 
   void update (const graphics_object& go, int id)
   {
     if (go.isa ("figure"))
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -157,26 +157,26 @@ sparse matrices.\n\
     {
       print_usage ();
       return retval;
     }
 
   int n = 1;
   while (n < nargin)
     {
-      std::string tmp = args(n++).xstring_value ("chol: expecting trailing string arguments");
+      std::string tmp = args(n++).xstring_value ("chol: optional arguments must be strings");
 
-      if (tmp.compare ("vector") == 0)
+      if (tmp == "vector")
         vecout = true;
-      else if (tmp.compare ("lower") == 0)
+      else if (tmp == "lower")
         LLt = true;
-      else if (tmp.compare ("upper") == 0)
+      else if (tmp == "upper")
         LLt = false;
       else
-        error ("chol: unexpected second or third input");
+        error ("chol: optional argument must be one of \"vector\", \"lower\", or \"upper\"");
     }
 
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("chol", nr, nc);
@@ -334,18 +334,18 @@ sparse matrices.\n\
 %! ## Bug #42587
 %! A = sparse ([1 0 8;0 1 8;8 8 1]);
 %! [Q, p] = chol (A);
 %! assert (p != 0);
 
 %!error chol ()
 %!error <matrix must be positive definite> chol ([1, 2; 3, 4])
 %!error <requires square matrix> chol ([1, 2; 3, 4; 5, 6])
-%!error <expecting trailing string arguments> chol (1, 2)
-%!error <unexpected second or third input> chol (1, "foobar")
+%!error <optional arguments must be strings> chol (1, 2)
+%!error <optional argument must be one of "vector", "lower"> chol (1, "foobar")
 */
 
 DEFUN_DLD (cholinv, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} cholinv (@var{A})\n\
 Compute the inverse of the symmetric positive definite matrix @var{A} using\n\
 the Cholesky@tie{}factorization.\n\
 @seealso{chol, chol2inv, inv}\n\
diff --git a/libinterp/dldfcn/fftw.cc b/libinterp/dldfcn/fftw.cc
--- a/libinterp/dldfcn/fftw.cc
+++ b/libinterp/dldfcn/fftw.cc
@@ -145,23 +145,21 @@ used per default.\n\
 #if defined (HAVE_FFTW)
   std::string arg0 = args(0).xstring_value ("fftw: first argument must be a string");
 
   if (arg0 == "planner")
     {
       if (nargin == 2)  //planner setter
         {
           // Use STL function to convert to lower case
-          std::transform (arg0.begin (), arg0.end (), arg0.begin (),
-                          tolower);
+          std::transform (arg0.begin (), arg0.end (), arg0.begin (), tolower);
 
-          std::string arg1 = args(1).xstring_value ("fftw: planner expects a string value as METHOD");
+          std::string arg1 = args(1).xstring_value ("fftw: METHOD must be a string");
 
-          std::transform (arg1.begin (), arg1.end (),
-                          arg1.begin (), tolower);
+          std::transform (arg1.begin (), arg1.end (), arg1.begin (), tolower);
           octave_fftw_planner::FftwMethod meth
             = octave_fftw_planner::UNKNOWN;
           octave_float_fftw_planner::FftwMethod methf
             = octave_float_fftw_planner::UNKNOWN;
 
           if (arg1 == "estimate")
             {
               meth = octave_fftw_planner::ESTIMATE;
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -1295,17 +1295,17 @@ dimensions.\n\
       break;
 
     default:
       {
         dims.resize (nargin);
 
         for (int i = 0; i < nargin; i++)
           dims(i) = (args(i).is_empty ()
-                     ? 0 : args(i).xnint_value ("cell: expecting scalar arguments"));
+                     ? 0 : args(i).xnint_value ("cell: dimension must be a scalar integer"));
       }
       break;
     }
 
   dims.chop_trailing_singletons ();
 
   check_dimensions (dims, "cell");
 
diff --git a/libinterp/octave-value/ov-ch-mat.cc b/libinterp/octave-value/ov-ch-mat.cc
--- a/libinterp/octave-value/ov-ch-mat.cc
+++ b/libinterp/octave-value/ov-ch-mat.cc
@@ -233,31 +233,31 @@ octave_char_matrix::map (unary_mapper_t 
     STRING_MAPPER (xispunct, std::ispunct, bool);
     STRING_MAPPER (xisspace, std::isspace, bool);
     STRING_MAPPER (xisupper, std::isupper, bool);
     STRING_MAPPER (xisxdigit, std::isxdigit, bool);
     STRING_MAPPER (xtoascii, xtoascii, double);
     STRING_MAPPER (xtolower, std::tolower, char);
     STRING_MAPPER (xtoupper, std::toupper, char);
 
-      // For Matlab compatibility, these should work on ASCII values
-      // without error or warning.
+    // For Matlab compatibility, these should work on ASCII values
+    // without error or warning.
     case umap_abs:
     case umap_ceil:
     case umap_fix:
     case umap_floor:
     case umap_imag:
     case umap_isinf:
     case umap_isnan:
     case umap_real:
     case umap_round:
       {
         octave_matrix m (array_value (true));
         return m.map (umap);
       }
 
     default:
-      error ("%s: expecting numeric argument", get_umap_name (umap));
+      error ("%s: argument must be numeric", get_umap_name (umap));
       break;
     }
 
   return retval;
 }
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -581,21 +581,21 @@ octave_class::subsasgn_common (const oct
               frame.protect_var (obsolete_copies);
               obsolete_copies = 2;
 
               tmp = feval (meth.function_value (), args);
             }
           else
             tmp = feval (meth.function_value (), args);
 
-          // FIXME: should the subsasgn method be able to return
-          // more than one value?
+          // FIXME: Should the subsasgn method be able to return
+          //        more than one value?
 
           if (tmp.length () > 1)
-            error ("expecting single return value from @%s/subsasgn",
+            error ("@%s/subsasgn returned more than one value",
                    class_name ().c_str ());
 
           else
             retval = tmp(0);
 
           return retval;
         }
     }
@@ -1851,17 +1851,17 @@ is derived.\n\
                   if (it == octave_class::exemplar_map.end ())
                     octave_class::exemplar_map[id]
                       = octave_class::exemplar_info (retval);
                   else if (! it->second.compare (retval))
                     error ("class: object of class '%s' does not match previously constructed objects",
                            id.c_str ());
                 }
               else
-                error ("class: expecting structure S as first argument");
+                error ("class: S must be a valid structure");
             }
           else
             error ("class: '%s' is invalid as a class name in this context",
                    id.c_str ());
         }
       else
         error ("class: invalid call from outside class constructor or method");
     }
@@ -2028,36 +2028,37 @@ Return true if @var{x} is a class object
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (ismethod, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} ismethod (@var{obj}, @var{method})\n\
-Return true if @var{obj} is a class object and the string @var{method}\n\
-is a method of this class.\n\
+@deftypefn  {Built-in Function} {} ismethod (@var{obj}, @var{method})\n\
+@deftypefnx {Built-in Function} {} ismethod (@var{clsname}, @var{method})\n\
+Return true if the string @var{method} is a valid method of the object\n\
+@var{obj} or of the class @var{clsname}.\n\
 @seealso{isprop, isobject}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 2)
     {
       octave_value arg = args(0);
 
       std::string class_name;
 
       if (arg.is_object ())
         class_name = arg.class_name ();
       else if (arg.is_string ())
         class_name = arg.string_value ();
       else
-        error ("ismethod: expecting object or class name as first argument");
+        error ("ismethod: first argument must be object or class name");
 
       std::string method = args(1).string_value ();
 
       if (load_path::find_method (class_name, method) != std::string ())
         retval = true;
       else
         retval = false;
     }
@@ -2139,17 +2140,17 @@ This function may only be called from a 
   if ((! fcn) || (! fcn->is_class_constructor ()))
     {
       error ("superiorto: invalid call from outside class constructor");
       return retval;
     }
 
   for (int i = 0; i < args.length (); i++)
     {
-      std::string inf_class = args(i).xstring_value ("superiorto: expecting argument to be class name");
+      std::string inf_class = args(i).xstring_value ("superiorto: CLASS_NAME must be a string");
 
       // User defined classes always have higher precedence
       // than built-in classes
       if (is_built_in_class (inf_class))
         break;
 
       std::string sup_class = fcn->name ();
       if (! symbol_table::set_class_relationship (sup_class, inf_class))
@@ -2180,17 +2181,17 @@ This function may only be called from a 
   if ((! fcn) || (! fcn->is_class_constructor ()))
     {
       error ("inferiorto: invalid call from outside class constructor");
       return retval;
     }
 
   for (int i = 0; i < args.length (); i++)
     {
-      std::string sup_class = args(i).xstring_value ("inferiorto: expecting argument to be class name");
+      std::string sup_class = args(i).xstring_value ("inferiorto: CLASS_NAME must be a string");
 
       if (is_built_in_class (sup_class))
         {
           error ("inferiorto: cannot give user-defined class lower "
                  "precedence than built-in class");
           break;
         }
 
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -517,17 +517,17 @@ class_get_inferiorclasses (const octave_
 
 static octave_value_list
 class_fromName (const octave_value_list& args, int /* nargout */)
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
-      std::string name = args(0).xstring_value ("fromName: invalid class name, expected a string value");
+      std::string name = args(0).xstring_value ("fromName: CLASS_NAME must be a string");
 
       retval(0) = to_ov (lookup_class (name));
     }
   else
     error ("fromName: invalid number of parameters");
 
   return retval;
 }
@@ -538,34 +538,34 @@ class_fevalStatic (const octave_value_li
   octave_value_list retval;
 
   if (args.length () > 1 && args(0).type_name () == "object")
     {
       cdef_class cls (to_cdef (args(0)));
 
       if (! error_state)
         {
-          std::string meth_name = args(1).xstring_value ("fevalStatic: invalid method name, expected a string value");
+          std::string meth_name = args(1).xstring_value ("fevalStatic: method name must be a string");
 
           cdef_method meth = cls.find_method (meth_name);
 
           if (meth.ok ())
             {
               if (meth.is_static ())
                 retval = meth.execute (args.splice (0, 2), nargout,
                                        true, "fevalStatic");
               else
                 error ("fevalStatic: method `%s' is not static",
                        meth_name.c_str ());
             }
           else
             error ("fevalStatic: method not found: %s", meth_name.c_str ());
         }
       else
-        error ("fevalStatic: invalid object, expected a meta.class object");
+        error ("fevalStatic: first argument must be a meta.class object");
     }
   else
     error ("fevalStatic: invalid arguments");
 
   return retval;
 }
 
 static octave_value_list
@@ -575,34 +575,34 @@ class_getConstant (const octave_value_li
 
   if (args.length () == 2 && args(0).type_name () == "object"
       && args(0).class_name () == "meta.class")
     {
       cdef_class cls = to_cdef (args(0));
 
       if (! error_state)
         {
-          std::string prop_name = args(1).xstring_value ("getConstant: invalid property name, expected a string value");
+          std::string prop_name = args(1).xstring_value ("getConstant: property name must be a string");
 
           cdef_property prop = cls.find_property (prop_name);
 
           if (prop.ok ())
             {
               if (prop.is_constant ())
                 retval(0) = prop.get_value (true, "getConstant");
               else
                 error ("getConstant: property `%s' is not constant",
                        prop_name.c_str ());
             }
           else
             error ("getConstant: property not found: %s",
                    prop_name.c_str ());
         }
       else
-        error ("getConstant: invalid object, expected a meta.class object");
+        error ("getConstant: first argument must be a meta.class object");
     }
   else
     error ("getConstant: invalid arguments");
 
   return retval;
 }
 
 #define META_CLASS_CMP(OP, CLSA, CLSB, FUN) \
@@ -619,17 +619,17 @@ class_ ## OP (const octave_value_list& a
     { \
       cdef_class clsa = to_cdef (args(0)); \
 \
       cdef_class clsb = to_cdef (args(1)); \
 \
       if (! error_state) \
         retval(0) = FUN (CLSA, CLSB); \
       else \
-        error (#OP ": invalid objects, expected meta.class objects"); \
+        error (#OP ": arguments must be meta.class objects"); \
     } \
   else \
     error (#OP ": invalid arguments"); \
 \
   return retval; \
 }
 
 META_CLASS_CMP (lt, clsb, clsa, is_strict_superclass)
@@ -3276,17 +3276,17 @@ lookup_package (const std::string& name)
 
 static octave_value_list
 package_fromName (const octave_value_list& args, int /* nargout */)
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
-      std::string name = args(0).xstring_value ("fromName: invalid package name, expected a string value");
+      std::string name = args(0).xstring_value ("fromName: PACKAGE_NAME must be a string");
 
       retval(0) = to_ov (lookup_package (name));
     }
   else
     error ("fromName: invalid number of parameters");
 
   return retval;
 }
@@ -3818,17 +3818,17 @@ cdef_manager::do_find_package_symbol (co
 //----------------------------------------------------------------------------
 
 DEFUN (__meta_get_package__, args, , "")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
-      std::string cname = args(0).xstring_value ("invalid package name, expected a string value");
+      std::string cname = args(0).xstring_value ("PACKAGE_NAME must be a string");
 
       retval = to_ov (lookup_package (cname));
     }
   else
     print_usage ();
 
   return retval;
 }
@@ -3853,17 +3853,17 @@ Undocumented internal function.\n\
 #if DEBUG_TRACE
   std::cerr << "__meta_class_query__ ("
             << args(0).string_value () << ")"
             << std::endl;
 #endif
 
   if (args.length () == 1)
     {
-      std::string cls = args(0).xstring_value ("invalid class name, expected a string value");
+      std::string cls = args(0).xstring_value ("CLASS_NAME must be a string");
 
       retval = to_ov (lookup_class (cls));
     }
   else
     print_usage ();
 
   return retval;
 }
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -315,17 +315,17 @@ octave_complex_matrix::diag (octave_idx_
 
   if (matrix.ndims () == 2
       && (matrix.rows () == 1 || matrix.columns () == 1))
     {
       ComplexMatrix mat (matrix);
 
       retval = mat.diag (m, n);
     }
-  else
+  else  // FIXME: Is this ever reachable?
     error ("diag: expecting vector argument");
 
   return retval;
 }
 
 bool
 octave_complex_matrix::save_ascii (std::ostream& os)
 {
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -806,17 +806,17 @@ functions from strings is through the us
             }
         }
       else
         {
           fargs.resize (nargin - 1);
 
           for (int i = 1; i < nargin; i++)
             {
-              std::string s = args(i).xstring_value ("inline: expecting string arguments");
+              std::string s = args(i).xstring_value ("inline: additional arguments must be strings");
               fargs(i-1) = s;
             }
         }
 
       retval = octave_value (new octave_fcn_inline (fun, fargs));
     }
   else
     print_usage ();
@@ -833,17 +833,17 @@ functions from strings is through the us
 %!assert (feval (inline ("sqrt (x^2 + y^2)", "x", "y"), 3, 4), 5)
 %!assert (feval (inline ("exp (P1*x) + P2", 3), 3, 4, 5), exp(3*4) + 5)
 
 ## Test input validation
 %!error inline ()
 %!error <STR argument must be a string> inline (1)
 %!error <N must be an integer> inline ("2", ones (2,2))
 %!error <N must be a positive integer> inline ("2", -1)
-%!error <expecting string arguments> inline ("2", "x", -1, "y")
+%!error <additional arguments must be strings> inline ("2", "x", -1, "y")
 */
 
 DEFUN (formula, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} formula (@var{fun})\n\
 Return a character string representing the inline function @var{fun}.\n\
 \n\
 Note that @code{char (@var{fun})} is equivalent to\n\
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -1804,33 +1804,33 @@ produces a struct @strong{array}.\n\
 
   if ((nargin == 1 || nargin == 2)
       && args(0).is_empty () && args(0).is_real_matrix ())
     {
       Cell fields;
 
       if (nargin == 2)
         {
-          Array<std::string> cstr = args(1).xcellstr_value ("struct: expecting cell array of field names as second argument");
+          Array<std::string> cstr = args(1).xcellstr_value ("struct: second argument should be a cell array of field names");
 
           retval = octave_map (args(0).dims (), cstr);
         }
       else
         retval = octave_map (args(0).dims ());
 
       return retval;
     }
 
   // Check for "field", VALUE pairs.
 
   for (int i = 0; i < nargin; i += 2)
     {
       if (! args(i).is_string () || i + 1 >= nargin)
         {
-          error ("struct: expecting alternating \"field\", VALUE pairs");
+          error ("struct: additional arguments must occur as \"field\", VALUE pairs");
           return retval;
         }
     }
 
   // Check that the dimensions of the values correspond.
 
   dim_vector dims (1, 1);
 
@@ -1904,18 +1904,18 @@ produces a struct @strong{array}.\n\
 %!assert (struct ("a",{1,2}, "b",{3}), x)
 %!assert (struct ("b",3, "a",{1,2}), x)
 %!assert (struct ("b",{3}, "a",{1,2}), x)
 %!test x = struct ([]);
 %!assert (size (x), [0,0])
 %!assert (isstruct (x))
 %!assert (isempty (fieldnames (x)))
 %!fail ('struct ("a",{1,2},"b",{1,2,3})', 'dimensions of parameter 2 do not match those of parameter 4')
-%!fail ('struct (1,2,3,4)', 'struct: expecting alternating "field", VALUE pairs')
-%!fail ('struct ("1",2,"3")', 'struct: expecting alternating "field", VALUE pairs')
+%!error <arguments must occur as "field", VALUE pairs> struct (1,2,3,4)
+%!fail ('struct ("1",2,"3")', 'struct: additional arguments must occur as "field", VALUE pairs')
 */
 
 DEFUN (isstruct, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isstruct (@var{x})\n\
 Return true if @var{x} is a structure or a structure array.\n\
 @seealso{ismatrix, iscell, isa}\n\
 @end deftypefn")
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -630,17 +630,17 @@ octave_user_function::do_multi_index_op 
 
       Cell varargout;
 
       if (ret_list->takes_varargs ())
         {
           octave_value varargout_varval = symbol_table::varval ("varargout");
 
           if (varargout_varval.is_defined ())
-            varargout = varargout_varval.xcell_value ("expecting varargout to be a cell array object");
+            varargout = varargout_varval.xcell_value ("varargout must be a cell array object");
         }
 
       retval = ret_list->convert_to_const_vector (nargout, varargout);
     }
 
   return retval;
 }
 
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -3875,17 +3875,17 @@ ComplexMatrix
 min (const ComplexMatrix& a, const ComplexMatrix& b)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
     {
       (*current_liboctave_error_handler)
-        ("two-arg min expecting args of same size");
+        ("two-arg min requires same size arguments");
       return ComplexMatrix ();
     }
 
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
@@ -3963,17 +3963,17 @@ ComplexMatrix
 max (const ComplexMatrix& a, const ComplexMatrix& b)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
     {
       (*current_liboctave_error_handler)
-        ("two-arg max expecting args of same size");
+        ("two-arg max requires same size arguments");
       return ComplexMatrix ();
     }
 
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -3235,17 +3235,17 @@ Matrix
 min (const Matrix& a, const Matrix& b)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
     {
       (*current_liboctave_error_handler)
-        ("two-arg min expecting args of same size");
+        ("two-arg min requires same size arguments");
       return Matrix ();
     }
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
@@ -3302,17 +3302,17 @@ Matrix
 max (const Matrix& a, const Matrix& b)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
     {
       (*current_liboctave_error_handler)
-        ("two-arg max expecting args of same size");
+        ("two-arg max requires same size arguments");
       return Matrix ();
     }
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -3879,17 +3879,17 @@ FloatComplexMatrix
 min (const FloatComplexMatrix& a, const FloatComplexMatrix& b)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
     {
       (*current_liboctave_error_handler)
-        ("two-arg min expecting args of same size");
+        ("two-arg min requires same size arguments");
       return FloatComplexMatrix ();
     }
 
   EMPTY_RETURN_CHECK (FloatComplexMatrix);
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
@@ -3967,17 +3967,17 @@ FloatComplexMatrix
 max (const FloatComplexMatrix& a, const FloatComplexMatrix& b)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
     {
       (*current_liboctave_error_handler)
-        ("two-arg max expecting args of same size");
+        ("two-arg max requires same size arguments");
       return FloatComplexMatrix ();
     }
 
   EMPTY_RETURN_CHECK (FloatComplexMatrix);
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -3240,17 +3240,17 @@ FloatMatrix
 min (const FloatMatrix& a, const FloatMatrix& b)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
     {
       (*current_liboctave_error_handler)
-        ("two-arg min expecting args of same size");
+        ("two-arg min requires same size arguments");
       return FloatMatrix ();
     }
 
   EMPTY_RETURN_CHECK (FloatMatrix);
 
   FloatMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
@@ -3307,17 +3307,17 @@ FloatMatrix
 max (const FloatMatrix& a, const FloatMatrix& b)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
     {
       (*current_liboctave_error_handler)
-        ("two-arg max expecting args of same size");
+        ("two-arg max requires same size arguments");
       return FloatMatrix ();
     }
 
   EMPTY_RETURN_CHECK (FloatMatrix);
 
   FloatMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
diff --git a/liboctave/numeric/lo-specfun.cc b/liboctave/numeric/lo-specfun.cc
--- a/liboctave/numeric/lo-specfun.cc
+++ b/liboctave/numeric/lo-specfun.cc
@@ -3647,17 +3647,17 @@ ellipj (double u, double m, double& sn, 
 {
   static const int Nmax = 16;
   double m1, t=0, si_u, co_u, se_u, ta_u, b, c[Nmax], a[Nmax], phi;
   int n, Nn, ii;
 
   if (m < 0 || m > 1)
     {
       (*current_liboctave_warning_with_id_handler)
-        ("Octave:ellipj-invalid-m", "ellipj: expecting 0 <= M <= 1");
+        ("Octave:ellipj-invalid-m", "ellipj: invalid M value, required value 0 <= M <= 1");
 
       sn = cn = dn = lo_ieee_nan_value ();
 
       return;
     }
 
   double sqrt_eps = sqrt (std::numeric_limits<double>::epsilon ());
   if (m < sqrt_eps)
diff --git a/scripts/general/curl.m b/scripts/general/curl.m
--- a/scripts/general/curl.m
+++ b/scripts/general/curl.m
@@ -73,17 +73,17 @@ function varargout = curl (varargin)
   else
     print_usage ();
   endif
 
   if (nargin == 4 || nargin == 2)
     if (! size_equal (varargin{fidx}, varargin{fidx + 1}))
       error ("curl: size of X and Y must match");
     elseif (ndims (varargin{fidx}) != 2)
-      error ("curl: expected two-dimensional matrices X and Y");
+      error ("curl: X and Y must be 2-D matrices");
     elseif ((length (dx) != columns (varargin{fidx}))
          || (length (dy) != rows (varargin{fidx})))
       error ("curl: size of dx and dy must match the respective dimension of X and Y");
     endif
 
     dFx_dy = gradient (varargin{fidx}.', dy, dx).';
     dFy_dx = gradient (varargin{fidx + 1}, dx, dy);
     rot_z = dFy_dx - dFx_dy;
@@ -94,17 +94,17 @@ function varargout = curl (varargin)
       varargout{1} = rot_z;
       varargout{2} = av;
     endif
 
   elseif (nargin == 6 || nargin == 3)
     if (! size_equal (varargin{fidx}, varargin{fidx + 1}, varargin{fidx + 2}))
       error ("curl: size of X, Y, and Z must match");
     elseif (ndims (varargin{fidx}) != 3)
-      error ("curl: expected two-dimensional matrices X, Y, and Z");
+      error ("curl: X, Y, and Z must be 2-D matrices");
     elseif ((length (dx) != size (varargin{fidx}, 2))
          || (length (dy) != size (varargin{fidx}, 1))
          || (length (dz) != size (varargin{fidx}, 3)))
       error ("curl: size of dx, dy, and dz must match the respective dimesion of X, Y, and Z");
     endif
 
     [~, dFx_dy, dFx_dz] = gradient (varargin{fidx}, dx, dy, dz);
     [dFy_dx, ~, dFy_dz] = gradient (varargin{fidx + 1}, dx, dy, dz);
diff --git a/scripts/general/divergence.m b/scripts/general/divergence.m
--- a/scripts/general/divergence.m
+++ b/scripts/general/divergence.m
@@ -72,30 +72,30 @@ function retval = divergence (varargin)
   else
     print_usage ();
   endif
 
   if (nargin == 4 || nargin == 2)
     if (! size_equal (varargin{fidx},varargin{fidx + 1}))
       error ("divergence: size of X and Y must match");
     elseif (ndims (varargin{fidx}) != 2)
-      error ("divergence: expected two-dimensional matrices X and Y");
+      error ("divergence: X and Y must be 2-D matrices");
     elseif (length (dx) != columns (varargin{fidx})
             || length (dy) != rows (varargin{fidx}))
       error ("divergence: size of dx and dy must match the respective dimension of X and Y");
     endif
 
     retval = gradient (varargin{fidx}, dx, dy);
     retval += gradient (varargin{fidx + 1}.', dy, dx).';
 
   elseif (nargin == 6 || nargin == 3)
     if (! size_equal (varargin{fidx},varargin{fidx + 1},varargin{fidx + 2}))
       error ("divergence: size of X, Y, and Z must match");
     elseif (ndims (varargin{fidx}) != 3)
-      error ("divergence: expected two-dimensional matrices X, Y, and Z");
+      error ("divergence: X, Y, and Z must be 2-D matrices");
     elseif ((length (dx) != size (varargin{fidx}, 2))
          || (length (dy) != size (varargin{fidx}, 1))
          || (length (dz) != size (varargin{fidx}, 3)))
       error ("divergence: size of dx, dy, and dz must match the respective dimesion of X, Y, and Z");
     endif
 
     ## x-direction
     retval = gradient (varargin{fidx}, dx, dy, dz);
diff --git a/scripts/gui/private/__fltk_file_filter__.m b/scripts/gui/private/__fltk_file_filter__.m
--- a/scripts/gui/private/__fltk_file_filter__.m
+++ b/scripts/gui/private/__fltk_file_filter__.m
@@ -23,17 +23,17 @@
 
 ## Author: Michael Goffioul
 
 function retval = __fltk_file_filter__ (file_filter)
 
   retval = "";
   [r, c] = size (file_filter);
   if ((c == 0) || (c > 2))
-    error ("expecting 1 or to 2 columns for file filter cell");
+    error ("file filter cell must have 1 or 2 columns");
   endif
   fltk_str = "";
   for idx = 1 : r
 
     curr_ext = file_filter{idx, 1};
     curr_ext = ostrsplit (curr_ext, ";");
 
     if (length (curr_ext) > 1)
diff --git a/scripts/gui/private/__uiobject_split_args__.m b/scripts/gui/private/__uiobject_split_args__.m
--- a/scripts/gui/private/__uiobject_split_args__.m
+++ b/scripts/gui/private/__uiobject_split_args__.m
@@ -36,17 +36,17 @@ function [parent, args] = __uiobject_spl
     elseif (! ischar (in_args{1}))
       error ("%s: invalid parent handle.", who);
     endif
 
     args = in_args(offset:end);
   endif
 
   if (rem (length (args), 2))
-    error ("%s: expecting PROPERTY/VALUE pairs", who);
+    error ("%s: PROPERTY/VALUE arguments must occur in pairs", who);
   endif
 
   if (! isempty (args))
     i = find (strcmpi (args(1:2:end), "parent"), 1, "first");
     if (! isempty (i) && length (args) >= 2*i)
       parent = args{2*i};
       if (! ishandle (parent))
         error ("%s: invalid parent handle.", who);
diff --git a/scripts/gui/uigetfile.m b/scripts/gui/uigetfile.m
--- a/scripts/gui/uigetfile.m
+++ b/scripts/gui/uigetfile.m
@@ -145,33 +145,33 @@ function [retfile, retpath, retindex] = 
     endif
   endif
 
   if (stridx)
     ## string arguments ("position" or "multiselect")
 
     ## check for even number of remaining arguments, prop/value pair(s)
     if (rem (nargin - stridx + 1, 2))
-      error ("uigetfile: expecting property/value pairs");
+      error ("uigetfile: PROPERTY/VALUE arguments must occur in pairs");
     endif
 
     for i = stridx : 2 : nargin
       prop = varargin{i};
       val = varargin{i + 1};
       if (strcmpi (prop, "position"))
         if (ismatrix (val) && length (val) == 2)
           outargs{4} = val;
         else
-          error ("uigetfile: expecting 2-element vector for position argument");
+          error ('uigetfile: "Position" must be a 2-element vector');
         endif
       elseif (strcmpi (prop, "multiselect"))
         if (ischar (val))
           outargs{5} = tolower (val);
         else
-          error ("uigetfile: expecting string argument (on/off) for multiselect");
+          error ('uigetfile: MultiSelect value must be a string ("on"/"off")');
         endif
       else
         error ("uigetfile: unknown argument");
       endif
     endfor
   endif
 
   if (__octave_link_enabled__ ())
diff --git a/scripts/help/doc.m b/scripts/help/doc.m
--- a/scripts/help/doc.m
+++ b/scripts/help/doc.m
@@ -30,42 +30,42 @@
 ## Once the GNU Info browser is running, help for using it is available using
 ## the command @kbd{C-h}.
 ## @seealso{help}
 ## @end deftypefn
 
 ## Author: Soren Hauberg <soren@hauberg.org>
 ## Adapted-by: jwe
 
-function retval = doc (fname)
+function retval = doc (function_name)
 
   if (nargin == 0 || nargin == 1)
 
     ftype = 0;
 
     if (nargin == 1)
       ## Get the directory where the function lives.
       ## FIXME: Maybe we should have a better way of doing this?
 
-      if (ischar (fname))
-        ftype = exist (fname);
+      if (ischar (function_name))
+        ftype = exist (function_name);
       else
-        error ("doc: expecting argument to be a character string");
+        error ("doc: FUNCTION_NAME must be a string");
       endif
     else
-      fname = "";
+      function_name = "";
     endif
 
     ## if GUI is running, let it display the function
     if (isguirunning ())
-      __octave_link_show_doc__ (fname);
+      __octave_link_show_doc__ (function_name);
     else
 
       if (ftype == 2 || ftype == 3)
-        ffile = which (fname);
+        ffile = which (function_name);
       else
         ffile = "";
       endif
 
       if (isempty (ffile))
         info_dir = octave_config_info ("infodir");
       else
         info_dir = fileparts (ffile);
@@ -90,20 +90,20 @@ function retval = doc (fname)
 
       ## FIXME: Don't change the order of the arguments below because
       ## the info-emacs-info script currently expects --directory DIR as
       ## the third and fourth arguments.  Someone should fix that.
 
       cmd = sprintf ("\"%s\" --file \"%s\" --directory \"%s\"",
                      info_program (), info_file_name, info_dir);
 
-      have_fname = ! isempty (fname);
+      have_fname = ! isempty (function_name);
 
       if (have_fname)
-        status = system (sprintf ("%s --index-search \"%s\"", cmd, fname));
+        status = system (sprintf ("%s --index-search \"%s\"", cmd, function_name));
       endif
 
 
       if (! (have_fname && status == 0))
         status = system (cmd);
         if (status == 127)
           warning ("unable to find info program '%s'", info_program ());
         endif
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -98,17 +98,17 @@ function h = imshow (im, varargin)
     endif
   elseif (size (im, 3) == 3)
     if (ismember (class (im), {"uint8", "uint16", "double", "single"}))
       truecolor = true;
     else
       error ("imshow: TrueColor image must be uint8, uint16, double, or single");
     endif
   else
-    error ("imshow: expecting MxN or MxNx3 matrix for image");
+    error ("imshow: image must be MxN or MxNx3 matrix");
   endif
 
   narg = 1;
   while (narg <= numel (varargin))
     arg = varargin{narg++};
     if (isnumeric (arg))
       if (numel (arg) == 2 || isempty (arg))
         display_range = arg;
@@ -252,17 +252,17 @@ endfunction
 %! imshow (rand (100, 100));
 %! colormap (jet (64));
 
 ## Test input validation
 %!error imshow ()
 %!error <IM must be an image> imshow ({"cell"})
 %!error <TrueColor image must be uint8> imshow (ones (3,3,3, "uint32"))
 %!error <TrueColor image must be uint8> imshow (ones (3,3,3, "int16"))
-%!error <expecting MxN or MxNx3 matrix> imshow (ones (4,4,4))
+%!error <image must be MxN or MxNx3 matrix> imshow (ones (4,4,4))
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   fail ("imshow ([1,1], [2 0 0])", "all MAP values must be in the range");
 %!   fail ("imshow ([1,1], [1 0 0 0])", "argument number 2 is invalid");
 %!   fail ('imshow ([1,1], "colormap", [2 0 0])', "all MAP values must be in the range");
 %!   fail ('imshow ([1,1], "parent", -1)', "must be an axes handle");
diff --git a/scripts/linear-algebra/rref.m b/scripts/linear-algebra/rref.m
--- a/scripts/linear-algebra/rref.m
+++ b/scripts/linear-algebra/rref.m
@@ -36,17 +36,17 @@
 
 function [A, k] = rref (A, tol)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (ndims (A) > 2)
-    error ("rref: expecting matrix argument");
+    error ("rref: A must be a 2-dimensional matrix");
   endif
 
   [rows, cols] = size (A);
 
   if (nargin < 2)
     if (isa (A, "single"))
       tol = eps ("single") * max (rows, cols) * norm (A, inf ("single"));
     else
diff --git a/scripts/linear-algebra/subspace.m b/scripts/linear-algebra/subspace.m
--- a/scripts/linear-algebra/subspace.m
+++ b/scripts/linear-algebra/subspace.m
@@ -32,17 +32,17 @@
 ##
 ## other texts are also around...
 
 function ang = subspace (A, B)
 
   if (nargin != 2)
     print_usage ();
   elseif (ndims (A) != 2 || ndims (B) != 2)
-    error ("subspace: expecting A and B to be 2-dimensional arrays");
+    error ("subspace: A and B must be 2-dimensional arrays");
   elseif (rows (A) != rows (B))
     error ("subspace: column dimensions of A and B must match");
   endif
 
   A = orth (A);
   B = orth (B);
   c = A'*B;
   scos = min (svd (c));
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -145,17 +145,17 @@ function ret = edit (varargin)
       ## If first arg is a cell array of strings,
       ## it becomes the list of files to be edited
       editfilelist = varargin{1};
     elseif (ischar (varargin{1}))
       ## If first arg is a string, create a cell array of strings
       ## of length 1 (by copying the input cell array)
       editfilelist = varargin(1);
     else
-      error ("edit: expected file to be a string or cell array of strings");
+      error ("edit: file NAME must be a string or cell array of strings");
     endif
   elseif (nargin == 2)
     ## User has supplied two arguments, these could be two file names,
     ## or a combination of editor state name and new value for that state,
     ## so first check for the various states
     statevar = varargin{1};
     stateval = varargin{2};
     switch (toupper (statevar))
@@ -177,17 +177,17 @@ function ret = edit (varargin)
         return;
       case "LICENSE"
         FUNCTION.LICENSE = stateval;
         return;
       case "MODE"
         if (strcmp (stateval, "sync") || strcmp (stateval, "async"))
           FUNCTION.MODE = stateval;
         else
-          error ('edit: expected "edit MODE sync|async"');
+          error ("edit: MODE must be sync or async");
         endif
         return;
       case "EDITINPLACE"
         if (ischar (stateval))
           if (strcmpi (stateval, "true"))
             stateval = true;
           elseif (strcmpi (stateval, "false"))
             stateval = false;
diff --git a/scripts/miscellaneous/fileattrib.m b/scripts/miscellaneous/fileattrib.m
--- a/scripts/miscellaneous/fileattrib.m
+++ b/scripts/miscellaneous/fileattrib.m
@@ -79,17 +79,17 @@ function [status, msg, msgid] = fileattr
     files = glob (file);
     if (isempty (files))
       files = {file};
       nfiles = 1;
     else
       nfiles = length (files);
     endif
   else
-    error ("fileattrib: expecting first argument to be a character string");
+    error ("fileattrib: FILE must be a string");
   endif
 
   if (nargin == 0 || nargin == 1)
 
     r_n = r_a = r_s = r_h = r_d ...
         = r_u_r = r_u_w = r_u_x ...
         = r_g_r = r_g_w = r_g_x ...
         = r_o_r = r_o_w = r_o_x = cell (nfiles, 1);
diff --git a/scripts/miscellaneous/open.m b/scripts/miscellaneous/open.m
--- a/scripts/miscellaneous/open.m
+++ b/scripts/miscellaneous/open.m
@@ -40,17 +40,17 @@
 
 function output = open (file)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   if (! ischar (file))
-    error ("expecting argument to be a file name");
+    error ("open: FILE must be a string");
   endif
 
   [~, ~, ext] = fileparts (file);
 
   if (strcmpi (ext, ".m"))
     edit (file);
   elseif (strcmpi (ext, ".mat"))
     if (nargout > 0)
diff --git a/scripts/miscellaneous/substruct.m b/scripts/miscellaneous/substruct.m
--- a/scripts/miscellaneous/substruct.m
+++ b/scripts/miscellaneous/substruct.m
@@ -62,17 +62,17 @@ function retval = substruct (varargin)
     cells = cellfun ("isclass", sub, "cell");
     chars = cellfun ("isclass", sub, "char");
     if (any (braces & !cells))
       error ("substruct: for TYPE == () or {}, SUBS must be a cell array");
     elseif (any (dots & !chars))
       error ("substruct: for TYPE == ., SUBS must be a character string");
     endif
   else
-    error ('substruct: expecting TYPE to be one of "()", "{}", or "."');
+    error ('substruct: TYPE must be one of "()", "{}", or "."');
   endif
 
   retval = struct ("type", typ, "subs", sub);
 
 endfunction
 
 
 %!test
diff --git a/scripts/plot/appearance/annotation.m b/scripts/plot/appearance/annotation.m
--- a/scripts/plot/appearance/annotation.m
+++ b/scripts/plot/appearance/annotation.m
@@ -184,34 +184,34 @@ function varargout = annotation (varargi
         x = varargin{1};
         y = varargin{2};
         varargin(1:2) = [];
 
         if (isnumeric (x) && isnumeric (y)
             && length (x) == 2 && length (y) == 2)
           lims = [x(1) y(1) diff(x) diff(y)];
         else
-          error ("annotation: expect 2 elements vectors for X and Y");
+          error ("annotation: X and Y must be 2-element vectors");
         endif
       else
         print_usage ();
       endif
     case types(5:end)
       if (nargin == 0)
         lims = [];
       else
         lims = varargin{1};
         varargin(1) = [];
 
         if (! isvector (lims) || length (lims) != 4)
-          error ("annotation: expect 4 elements vector for POS")
+          error ("annotation: POS must be a 4-element vector");
         endif
       endif
     otherwise
-      error ("annotation: unknown annotation type %s", objtype)
+      error ("annotation: unknown annotation type %s", objtype);
   endswitch
 
   ## options
   opts = varargin;
   nopts = numel (opts);
   if (! isempty (opts))
     if (fix (nopts/2) != nopts/2
         || ! all (cellfun (@ischar, opts(1:2:end))))
@@ -933,17 +933,17 @@ function [x, y] = arrowcoordinates (h, n
     pos = pos(1:2);
     ang += pi;
   elseif (nar == 2)
     ln = get (h, "head2length"); # in points
     wd = get (h, "head2width");
     headstyle = get (h, "head2style");
     pos = pos(1:2) .+ pos(3:4);
   else
-    error ("annotation: %d, no such arrow number")
+    error ("annotation: %d, no such arrow number");
   endif
 
   switch (headstyle)
     case "diamond"
       x = [0 -ln/2 -ln -ln/2 0];
       y = [0 -wd/2 0 wd/2 0];
     case "ellipse"
       pts = linspace (0, 2*pi, 12);
@@ -963,17 +963,17 @@ function [x, y] = arrowcoordinates (h, n
       y = [0 wd/2 0 -wd/2 0];
     case "plain"
       x = [0 -ln -ln -ln 0];
       y = [0 wd/2 0 -wd/2 0];
     case "none"
       x = [0 0 0];
       y = [0 0 0];
     otherwise
-      error ("annotation: \"%s\" headstyle not implemented", headstyle)
+      error ("annotation: \"%s\" headstyle not implemented", headstyle);
   endswitch
 
   R = [cos(ang) -sin(ang);
        sin(ang) cos(ang)];
   XY = R * [x; y];
   XY = pts2norm (h, XY);
   XY = pos(1:2).' .+ XY;
 
@@ -1484,10 +1484,11 @@ endfunction
 %!   close (hf2)
 %! end_unwind_protect
 
 ## Test input validation
 %!error <unknown annotation type foo> annotation ("foo")
 %!error annotation ([], "foo")
 %!error annotation ({})
 %!error annotation ("line", [.5 .6])
-%!error <expect 2 elements vectors for X and Y> annotation ("line", 1:3, 1:3)
-%!error <expect 4 elements vector for POS> annotation ("textbox", 1:3)
+%!error <X and Y must be 2-element vectors> annotation ("line", 1:3, 1:3)
+%!error <POS must be a 4-element vector> annotation ("textbox", 1:3)
+
diff --git a/scripts/plot/appearance/axis.m b/scripts/plot/appearance/axis.m
--- a/scripts/plot/appearance/axis.m
+++ b/scripts/plot/appearance/axis.m
@@ -282,22 +282,22 @@ function limits = __axis__ (ca, ax, vara
       warning ("unknown axis option '%s'", ax);
     endif
 
   elseif (isvector (ax))
 
     len = length (ax);
 
     if (len != 2 && len != 4 && len != 6)
-      error ("axis: expecting vector with 2, 4, or 6 elements");
+      error ("axis: LIMITS vector must have 2, 4, or 6 elements");
     endif
 
     for i = 1:2:len
       if (ax(i) >= ax(i+1))
-        error ("axis: limits(%d) must be less than limits(%d)", i, i+1);
+        error ("axis: LIMITS(%d) must be less than LIMITS(%d)", i, i+1);
       endif
     endfor
 
     if (len > 1)
       xlim (ca, ax(1:2));
     endif
 
     if (len > 3)
diff --git a/scripts/plot/appearance/caxis.m b/scripts/plot/appearance/caxis.m
--- a/scripts/plot/appearance/caxis.m
+++ b/scripts/plot/appearance/caxis.m
@@ -75,17 +75,17 @@ function limits = __caxis__ (ca, ax, var
     if (strcmpi (ax, "auto"))
       set (ca, "climmode", "auto");
     elseif (strcmpi (ax, "manual"))
       set (ca, "climmode", "manual");
     endif
   elseif (isvector (ax))
     len = length (ax);
     if (len != 2)
-      error ("caxis: expecting vector with 2 elements");
+      error ("caxis: LIMITS must be a 2-element vector");
     endif
 
     set (ca, "clim", [ax(1), ax(2)]);
   else
     error ("caxis: expecting no args, a string, or a 2 element vector");
   endif
 
   ## FIXME: Why should it be possible to call __caxis__ recursively?
diff --git a/scripts/plot/appearance/datetick.m b/scripts/plot/appearance/datetick.m
--- a/scripts/plot/appearance/datetick.m
+++ b/scripts/plot/appearance/datetick.m
@@ -127,20 +127,20 @@ function __datetick__ (varargin)
     startdate = varargin{1};
   else
     startdate = [];
   endif
 
   if (! isempty (form))
     if (isnumeric (form))
       if (! isscalar (form) || form < 0 || form != fix (form))
-        error ("datetick: expecting FORM argument to be a positive integer");
+        error ("datetick: FORM argument must be a positive integer");
       endif
     elseif (! ischar (form))
-      error ("datetick: expecting valid date format string");
+      error ("datetick: FORM argument must be a valid date format string");
     endif
   endif
 
   if (keepticks)
     ticks = get (gca (), [ax "tick"]);
   else
     ## Need to do our own axis tick position calculation as
     ## year, etc, don't fallback on nice datenum values.
diff --git a/scripts/plot/appearance/hidden.m b/scripts/plot/appearance/hidden.m
--- a/scripts/plot/appearance/hidden.m
+++ b/scripts/plot/appearance/hidden.m
@@ -40,17 +40,17 @@
 ## @end deftypefn
 
 function state = hidden (mode = "toggle")
 
   if (nargin > 2)
     print_usage ();
   elseif (nargin == 1)
     if (! ischar (mode))
-      error ("hidden: expecting MODE to be a string");
+      error ("hidden: MODE must be a string");
     elseif (! any (strcmpi (mode, {"on", "off"})))
       error ('hidden: MODE must be "on" or "off"');
     endif
   endif
 
   for h = (get (gca (), "children")).';
     htype = get (h, "type");
     htag = get (h, "tag");
diff --git a/scripts/plot/appearance/legend.m b/scripts/plot/appearance/legend.m
--- a/scripts/plot/appearance/legend.m
+++ b/scripts/plot/appearance/legend.m
@@ -292,17 +292,17 @@ function [hleg, hleg_obj, hplot, labels]
         varargin = cellstr (arg);
         nargs = numel (varargin);
       endif
     elseif (iscellstr (arg))
       ## Cell array of labels
       varargin = arg;
       nargs = numel (varargin);
     else
-      error ("legend: expecting argument to be a character string");
+      error ("legend: single argument must be a string or cellstr");
     endif
   elseif (nargs > 1 && iscellstr (varargin{1}))
     ## Cell array of labels followed by property/value pairs
     varargin = {varargin{1}{:}, varargin{2:end}};
     nargs = numel (varargin);
   endif
 
   have_labels = (nargs > 0);
@@ -446,17 +446,17 @@ function [hleg, hleg_obj, hplot, labels]
 
             if (--k == 0)
               break;
             endif
           else
             break;  # k = 0, no further handles to process
           endif
         else
-          error ("legend: expecting argument to be a character string");
+          error ("legend: expecting argument to be a string");
         endif
       endfor
       if (have_labels && i < nargs)
         warning ("legend: ignoring extra labels");
       endif
     else
       ## No labels specified but objects have DisplayName property set.
       k = nkids;
diff --git a/scripts/plot/appearance/whitebg.m b/scripts/plot/appearance/whitebg.m
--- a/scripts/plot/appearance/whitebg.m
+++ b/scripts/plot/appearance/whitebg.m
@@ -60,17 +60,17 @@ function whitebg (varargin)
 
   if (strcmp (typ, "root"))
     isroot = true;
     fig = gcf ();
   elseif (strcmp (typ, "figure"))
     isroot = false;
     fig = h;
   else
-    error ("expecting a figure handle");
+    error ("whitebg: HFIF must be a valid figure handle");
   endif
 
   axes = findall (fig, "type", "axes");
   if (isnan (color))
     ## Root figure. Set the default axes and figure properties so that
     ## subsequent plots have the new color scheme
     if (isroot)
       fac = get (0, "factory");
diff --git a/scripts/plot/draw/colorbar.m b/scripts/plot/draw/colorbar.m
--- a/scripts/plot/draw/colorbar.m
+++ b/scripts/plot/draw/colorbar.m
@@ -104,17 +104,17 @@ function h = colorbar (varargin)
     if (ischar (arg))
       switch (tolower (arg))
         case "peer"
           if (i > nargin)
             error ('colorbar: missing axes handle after "peer"');
           else
             ax = varargin{i++};
             if (! isscalar (ax) && ! isaxes (ax))
-              error ('colorbar: expecting an axes handle following "peer"');
+              error ('colorbar: invalid axes handle following "peer"');
             endif
           endif
         case {"north", "south", "east", "west",
               "northoutside", "southoutside", "eastoutside", "westoutside"}
           loc = tolower (arg);
         case "location"
           if (i > nargin)
             error ('colorbar: missing value after "location"');
diff --git a/scripts/plot/draw/private/__add_datasource__.m b/scripts/plot/draw/private/__add_datasource__.m
--- a/scripts/plot/draw/private/__add_datasource__.m
+++ b/scripts/plot/draw/private/__add_datasource__.m
@@ -37,16 +37,17 @@ function newargs = __add_datasource__ (f
     arg = varargin{++i};
     if (i != numel (varargin) && ischar (arg)
         && length (arg) > 9 && strcmpi (arg(end-9:end), "datasource"))
       arg = tolower (arg);
       val = varargin{++i};
       if (ischar (val))
         set (h, arg, val);
       else
-        error ("%s: expecting data source to be a string", fcn);
+        error ("%s: datasource must be a string", fcn);
       endif
     else
       newargs{end + 1} = arg;
     endif
   endwhile
+
 endfunction
 
diff --git a/scripts/plot/draw/private/__ezplot__.m b/scripts/plot/draw/private/__ezplot__.m
--- a/scripts/plot/draw/private/__ezplot__.m
+++ b/scripts/plot/draw/private/__ezplot__.m
@@ -135,17 +135,17 @@ function [h, needusage] = __ezplot__ (pl
     elseif (ispolar)
       xarg = "";
       yarg = "";
     else
       xarg = args{1};
       yarg = args{2};
     endif
   else
-    error ("%s: expecting string, inline function, or function handle", ezfunc);
+    error ("%s: F must be string, inline function, or function handle", ezfunc);
   endif
 
   if (nargin > 2 || (nargin == 2 && isplot))
     funx = fun;
     fstrx = fstr;
     funy = varargin{2};
     if (ischar (funy) && ! strcmp (funy, "circ") && ! strcmp (funy, "animate"))
       parametric = true;
@@ -217,17 +217,17 @@ function [h, needusage] = __ezplot__ (pl
           fstrz = fstrz(idx+2:end);  # remove '@(x) ' from string name
         else
           args = {"z"};
         endif
         if (numel (args) != nargs)
           error ("%s: expecting a function of %d arguments", ezfunc, nargs);
         endif
       else
-        error ("%s: parametric plots expect 3 functions", ezfunc);
+        error ("%s: parametric plots require 3 functions", ezfunc);
       endif
     endif
   endif
 
   if ((isplot && nargs != 2) || isplot3 || ispolar)
     n = 500;   # default for point-style functions like plot
   else
     n = 60;    # default for meshgrid style functions like contour, surf
@@ -252,17 +252,17 @@ function [h, needusage] = __ezplot__ (pl
       animate = true;
     elseif (isscalar (arg))
       n = arg;
     elseif (numel (arg) == 2)
       domain = [arg(1) arg(2) arg(1) arg(2)];
     elseif (numel (arg) == 4)
       domain = arg(:).';
     else
-      error ("%s: expecting scalar, 2-, or 4-element vector", ezfunc);
+      error ("%s: expecting scalar N or 2-, 4-element vector DOM", ezfunc);
     endif
   endwhile
 
   if (circ && (iscontour || isplot3 || isplot))
     needusage = true;
     return;
   elseif (circ && parametric)
     error ("%s: can not have both circular domain and parametric function",
diff --git a/scripts/plot/draw/private/__pie__.m b/scripts/plot/draw/private/__pie__.m
--- a/scripts/plot/draw/private/__pie__.m
+++ b/scripts/plot/draw/private/__pie__.m
@@ -24,17 +24,17 @@
 
 function hlist = __pie__ (caller, varargin)
 
   h = varargin{1};
   x = abs (varargin{2});
   iarg = 3;
 
   if (! isvector (x))
-    error ("%s: expecting vector argument", caller);
+    error ("%s: X must be a vector", caller);
   endif
 
   len = length (x);
 
   have_explode = false;
   have_labels = false;
 
   while (iarg <= nargin - 1)
diff --git a/scripts/plot/util/__plt_get_axis_arg__.m b/scripts/plot/util/__plt_get_axis_arg__.m
--- a/scripts/plot/util/__plt_get_axis_arg__.m
+++ b/scripts/plot/util/__plt_get_axis_arg__.m
@@ -29,17 +29,17 @@ function [h, varargin, narg] = __plt_get
   parent = find (strcmpi (varargin, "parent"), 1);
 
   ## Look for a scalar which is a graphics handle but not the
   ## Root Figure (0) or an ordinary figure (integer).
   if (numel (varargin) > 0 && numel (varargin{1}) == 1
       && ishandle (varargin{1}) && varargin{1} != 0 && ! isfigure (varargin{1}))
     htmp = varargin{1};
     if (! isaxes (htmp))
-      error ("%s: expecting first argument to be axes handle", caller);
+      error ("%s: first argument must be axes handle", caller);
     endif
     if (! strcmp (get (htmp, "tag"), "legend"))
       h = htmp;
       varargin(1) = [];
     endif
   ## Look for "parent"/axis prop/value pair
   elseif (numel (varargin) > 1 && ! isempty (parent))
     if (parent < numel (varargin) && ishandle (varargin{parent+1}))
@@ -47,17 +47,17 @@ function [h, varargin, narg] = __plt_get
       if (isaxes (htmp) && ! strcmp (get (htmp, "tag"), "legend"))
         h = htmp;
         varargin(parent:parent+1) = [];
       else
         ## 'parent' property for some other type like hggroup
         h = [ancestor(htmp, "axes"), htmp];
       endif
     else
-      error ("%s: expecting parent value to be axes handle", caller);
+      error ("%s: parent value must be an axes handle", caller);
     endif
   endif
 
   narg = length (varargin);
 
 endfunction
 
 
diff --git a/scripts/plot/util/pan.m b/scripts/plot/util/pan.m
--- a/scripts/plot/util/pan.m
+++ b/scripts/plot/util/pan.m
@@ -54,17 +54,17 @@ function pan (varargin)
   endif
 
   if (nargs == 2)
     hfig = varargin{1};
     if (isfigure (hfig))
       varargin(1) = [];
       nargs--;
     else
-      error ("pan: expecting figure handle as first argument");
+      error ("pan: invalid figure handle HFIG");
     endif
   endif
 
   if (isnan (hfig))
     hfig = gcf ();
   endif
 
   if (nargs == 0)
diff --git a/scripts/plot/util/private/__print_parse_opts__.m b/scripts/plot/util/private/__print_parse_opts__.m
--- a/scripts/plot/util/private/__print_parse_opts__.m
+++ b/scripts/plot/util/private/__print_parse_opts__.m
@@ -163,17 +163,17 @@ function arg_st = __print_parse_opts__ (
       elseif (length (arg) >= 1 && arg(1) == "-")
         error ("print: unknown option '%s'", arg);
       elseif (length (arg) > 0)
         arg_st.name = tilde_expand (arg);
       endif
     elseif (isfigure (arg))
       arg_st.figure = arg;
     else
-      error ("print: expecting inputs to be character string options or a figure handle");
+      error ("print: first argument must be string or figure handle");
     endif
   endfor
 
   if (arg_st.ghostscript.resolution == 0)
     ## Do as Matlab does.
     arg_st.ghostscript.resolution = get (0, "screenpixelsperinch");
   endif
 
diff --git a/scripts/plot/util/rotate3d.m b/scripts/plot/util/rotate3d.m
--- a/scripts/plot/util/rotate3d.m
+++ b/scripts/plot/util/rotate3d.m
@@ -49,17 +49,17 @@ function rotate3d (varargin)
   endif
 
   if (nargs == 2)
     hfig = varargin{1};
     if (isfigure (hfig))
       varargin(1) = [];
       nargs--;
     else
-      error ("rotate3d: expecting figure handle as first argument");
+      error ("rotate3d: invalid figure handle HFIG");
     endif
   endif
 
   if (isnan (hfig))
     hfig = gcf ();
   endif
 
   if (nargs == 0)
diff --git a/scripts/plot/util/subplot.m b/scripts/plot/util/subplot.m
--- a/scripts/plot/util/subplot.m
+++ b/scripts/plot/util/subplot.m
@@ -143,17 +143,17 @@ function h = subplot (varargin)
       index = rem (arg, 10);
       arg = (arg - index) / 10;
       cols = rem (arg, 10);
       arg = (arg - cols) / 10;
       rows = rem (arg, 10);
       varargin(1) = [];
       initial_args_decoded = true;
     else
-      error ("subplot: expecting axes handle or RCN argument");
+      error ("subplot: invalid axes handle or RCN argument");
     endif
   endif
 
   if (! initial_args_decoded)
     print_usage ();
   endif
 
   if (! have_position)
diff --git a/scripts/plot/util/zoom.m b/scripts/plot/util/zoom.m
--- a/scripts/plot/util/zoom.m
+++ b/scripts/plot/util/zoom.m
@@ -70,17 +70,17 @@ function zoom (varargin)
 
   hfig = NaN;
   if (nargs == 2)
     hfig = varargin{1};
     if (isfigure (hfig))
       varargin(1) = [];
       nargs--;
     else
-      error ("zoom: expecting figure handle as first argument");
+      error ("zoom: invalid figure handle HFIG");
     endif
   endif
 
   if (isnan (hfig))
     hfig = gcf ();
   endif
 
   if (nargs == 0)
diff --git a/scripts/polynomial/compan.m b/scripts/polynomial/compan.m
--- a/scripts/polynomial/compan.m
+++ b/scripts/polynomial/compan.m
@@ -60,17 +60,17 @@
 
 function A = compan (c)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   if (! isvector (c))
-    error ("compan: expecting a vector argument");
+    error ("compan: C must be a vector");
   endif
 
   n = length (c);
 
   if (n == 1)
     A = [];
   else
     A = diag (ones (n-2, 1), -1);
diff --git a/scripts/prefs/addpref.m b/scripts/prefs/addpref.m
--- a/scripts/prefs/addpref.m
+++ b/scripts/prefs/addpref.m
@@ -36,39 +36,39 @@
 
 function addpref (group, pref, val)
 
   if (nargin == 3)
     if (ischar (group))
       prefs = loadprefs ();
       if (ischar (pref))
         if (isfield (group, pref))
-          error ("preference %s already exists in group %s", pref, group);
+          error ("addpref: preference %s already exists in group %s", pref, group);
         else
           prefs.(group).(pref) = val;
         endif
       elseif (iscellstr (pref))
         if (size_equal (pref, val))
           for i = 1:numel (pref)
             if (isfield (group, pref{i}))
-              error ("preference %s already exists in group %s",
+              error ("addpref: preference %s already exists in group %s",
                      pref{i}, group);
             else
               prefs.(group).(pref{i}) = val;
             endif
           endfor
         else
-          error ("size mismatch for pref and val");
+          error ("addpref: size mismatch for PREF and VAL");
         endif
       else
-        error ("expecting pref to be a character string or cellstr");
+        error ("addpref: PREF must be a character string or cellstr");
       endif
       saveprefs (prefs);
     else
-      error ("expecting group to be a character string");
+      error ("addpref: GROUP must be a string");
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
 
diff --git a/scripts/prefs/getpref.m b/scripts/prefs/getpref.m
--- a/scripts/prefs/getpref.m
+++ b/scripts/prefs/getpref.m
@@ -53,44 +53,44 @@ function retval = getpref (group, pref, 
     if (ischar (group))
       prefs = loadprefs ();
       if (isfield (prefs, group))
         retval = prefs.(group);
       else
         retval = [];
       endif
     else
-      error ("expecting group to be a character string");
+      error ("getpref: GROUP must be a character string");
     endif
   elseif (nargin == 2 || nargin == 3)
     grp = getpref (group);
     if (ischar (pref))
       if (isfield (grp, pref))
         retval = grp.(pref);
       elseif (nargin == 3)
         retval = default;
       else
-        error ("preference %s does not exist in group %s", pref, group);
+        error ("getpref: preference %s does not exist in group %s", pref, group);
       endif
     elseif (iscellstr (pref))
       if (nargin == 2 || size_equal (pref, default))
         for i = 1:numel (pref)
           if (isfield (grp, pref{i}))
             retval.(pref) = grp.(pref{i});
           elseif (nargin == 3)
             retval.(pref) = default{i};
           else
-            error ("preference %s does not exist in group %s", pref{i}, group);
+            error ("getpref: preference %s does not exist in group %s", pref{i}, group);
           endif
         endfor
       else
-        error ("size mismatch for pref and default");
+        error ("getpref: size mismatch for PREF and DEFAULT");
       endif
     else
-      error ("expecting pref to be a character string or cellstr");
+      error ("getpref: PREF must be a character string or cellstr");
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
 
diff --git a/scripts/prefs/setpref.m b/scripts/prefs/setpref.m
--- a/scripts/prefs/setpref.m
+++ b/scripts/prefs/setpref.m
@@ -44,24 +44,24 @@ function setpref (group, pref, val)
       if (ischar (pref))
         prefs.(group).(pref) = val;
       elseif (iscellstr (pref))
         if (size_equal (pref, val))
           for i = 1:numel (pref)
             prefs.(group).(pref{i}) = val;
           endfor
         else
-          error ("size mismatch for pref and val");
+          error ("setpref: size mismatch for PREF and VAL");
         endif
       else
-        error ("expecting pref to be a character string or cellstr");
+        error ("setpref: PREF must be a character string or cellstr");
       endif
       saveprefs (prefs);
     else
-      error ("expecting group to be a character string");
+      error ("setpref: GROUP must be a string");
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
 
diff --git a/scripts/set/powerset.m b/scripts/set/powerset.m
--- a/scripts/set/powerset.m
+++ b/scripts/set/powerset.m
@@ -35,17 +35,17 @@ function p = powerset (a, byrows_arg)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   byrows = false;
   if (nargin == 2)
     if (! strcmpi (byrows_arg, "rows"))
-      error ('powerset: expecting second argument to be "rows"');
+      error ('powerset: optional second argument must be "rows"');
     elseif (iscell (a))
       error ('powerset: "rows" not valid for cell arrays');
     else
       byrows = true;
     endif
   endif
 
   if (iscell (a) && ! iscellstr (a))
@@ -98,13 +98,13 @@ endfunction
 %! p = sort (cellstr (powerset ([1:3;2:4;3:5], "rows")));
 %! assert (p,c);
 
 %!assert (powerset([]), {});  # always return a cell array
 
 ## Test input validation
 %!error powerset ()
 %!error powerset (1,2,3)
-%!error <expecting second argument to be "rows"> powerset (1, "cols")
+%!error <second argument must be "rows"> powerset (1, "cols")
 %!error <"rows" not valid for cell arrays> powerset ({1}, "rows")
 %!error <cell arrays can only be used for character> powerset ({1})
 %!error <not implemented for more than 32 elements> powerset (1:33)
 
diff --git a/scripts/sparse/bicg.m b/scripts/sparse/bicg.m
--- a/scripts/sparse/bicg.m
+++ b/scripts/sparse/bicg.m
@@ -83,18 +83,17 @@ function [x, flag, res1, k, resvec] = bi
       Atx = @(x) feval (fun, x, "transp");
     elseif (isnumeric (A) && ismatrix (A))
       Ax  = @(x) A  * x;
       Atx = @(x) A' * x;
     elseif (isa (A, "function_handle"))
       Ax  = @(x) feval (A, x, "notransp");
       Atx = @(x) feval (A, x, "transp");
     else
-      error (["bicg: first argument is expected to " ...
-              "be a function or a square matrix"]);
+      error ("bicg: A must be a square matrix or function");
     endif
 
     if (nargin < 3 || isempty (tol))
       tol = 1e-6;
     endif
 
     if (nargin < 4 || isempty (maxit))
       maxit = min (rows (b), 20);
@@ -111,36 +110,34 @@ function [x, flag, res1, k, resvec] = bi
       M1tm1x = @(x) feval (fun, x, "transp");
     elseif (isnumeric (M1) && ismatrix (M1))
       M1m1x  = @(x) M1  \ x;
       M1tm1x = @(x) M1' \ x;
     elseif (isa (M1, "function_handle"))
       M1m1x  = @(x) feval (M1, x, "notransp");
       M1tm1x = @(x) feval (M1, x, "transp");
     else
-      error (["bicg: preconditioner is expected to " ...
-              "be a function or matrix"]);
+      error ("bicg: preconditioner must be a function or matrix");
     endif
 
     if (nargin < 6 || isempty (M2))
       M2m1x = @(x, ignore) x;
       M2tm1x = M2m1x;
     elseif (ischar (M2))
       fun = str2func (M2);
       M2m1x  = @(x) feval (fun, x, "notransp");
       M2tm1x = @(x) feval (fun, x, "transp");
     elseif (isnumeric (M2) && ismatrix (M2))
       M2m1x  = @(x) M2  \ x;
       M2tm1x = @(x) M2' \ x;
     elseif (isa (M2, "function_handle"))
       M2m1x  = @(x) feval (M2, x, "notransp");
       M2tm1x = @(x) feval (M2, x, "transp");
     else
-      error (["bicg: preconditioner is expected to " ...
-              "be a function or matrix"]);
+      error ("bicg: preconditioner must be a function or matrix");
     endif
 
     Pm1x  = @(x) M2m1x  (M1m1x (x));
     Ptm1x = @(x) M1tm1x (M2tm1x (x));
 
     if (nargin < 7 || isempty (x0))
       x0 = zeros (size (b));
     endif
diff --git a/scripts/sparse/bicgstab.m b/scripts/sparse/bicgstab.m
--- a/scripts/sparse/bicgstab.m
+++ b/scripts/sparse/bicgstab.m
@@ -76,18 +76,17 @@ function [x, flag, relres, iter, resvec]
 
     if (ischar (A))
       A = str2func (A);
     elseif (isnumeric(A) && ismatrix (A))
       Ax  = @(x) A  * x;
     elseif (isa (A, "function_handle"))
       Ax  = @(x) feval (A, x);
     else
-      error (["bicgstab: first argument is expected " ...
-              "to be a function or a square matrix"]);
+      error ("bicgstab: A must be a square matrix or function");
     endif
 
     if (nargin < 3 || isempty (tol))
       tol = 1e-6;
     endif
 
     if (nargin < 4 || isempty (maxit))
       maxit = min (rows (b), 20);
@@ -97,31 +96,29 @@ function [x, flag, relres, iter, resvec]
       M1m1x = @(x) x;
     elseif (ischar (M1))
       M1m1x = str2func (M1);
     elseif (isnumeric(M1) && ismatrix (M1))
       M1m1x = @(x) M1  \ x;
     elseif (isa (M1, "function_handle"))
       M1m1x = @(x) feval (M1, x);
     else
-      error (["bicgstab: preconditioner is " ...
-              "expected to be a function or matrix"]);
+      error ("bicgstab: preconditioner must be a function or matrix");
     endif
 
     if (nargin < 6 || isempty (M2))
       M2m1x = @(x) x;
     elseif (ischar (M2))
       M2m1x = str2func (M2);
     elseif (isnumeric(M2) && ismatrix (M2))
       M2m1x = @(x) M2  \ x;
     elseif (isa (M2, "function_handle"))
       M2m1x = @(x) feval (M2, x);
     else
-      error (["bicgstab: preconditioner is "...
-              "expected to be a function or matrix"]);
+      error ("bicgstab: preconditioner must be a function or matrix");
     endif
 
     precon = @(x) M2m1x (M1m1x (x));
 
     if (nargin < 7 || isempty (x0))
       x0 = zeros (size (b));
     endif
 
diff --git a/scripts/sparse/cgs.m b/scripts/sparse/cgs.m
--- a/scripts/sparse/cgs.m
+++ b/scripts/sparse/cgs.m
@@ -74,18 +74,17 @@ function [x, flag, relres, iter, resvec]
 
     if (ischar (A))
       A = str2func (A);
     elseif (isnumeric (A) && ismatrix (A))
       Ax = @(x) A * x;
     elseif (isa (A, "function_handle"))
       Ax = @(x) feval (A, x);
     else
-      error (["cgs: first argument is expected to "...
-              "be a function or a square matrix"]);
+      error ("cgs: A must be a square matrix or function");
     endif
 
     if (nargin < 3 || isempty (tol))
       tol = 1e-6;
     endif
 
     if (nargin < 4 || isempty (maxit))
       maxit = min (rows (b), 20);
@@ -95,29 +94,29 @@ function [x, flag, relres, iter, resvec]
       M1m1x = @(x) x;
     elseif (ischar (M1))
       M1m1x = str2func (M1);
     elseif (isnumeric (M1) && ismatrix (M1))
       M1m1x = @(x) M1 \ x;
     elseif (isa (M1, "function_handle"))
       M1m1x = @(x) feval (M1, x);
     else
-      error ("cgs: preconditioner is expected to be a function or matrix");
+      error ("cgs: preconditioner must be a function or matrix");
     endif
 
     if (nargin < 6 || isempty (M2))
       M2m1x = @(x) x;
     elseif (ischar (M2))
       M2m1x = str2func (M2);
     elseif (isnumeric (M2) && ismatrix (M2))
       M2m1x = @(x) M2 \ x;
     elseif (isa (M2, "function_handle"))
       M2m1x = @(x) feval (M2, x);
     else
-      error ("cgs: preconditioner is expected to be a function or matrix");
+      error ("cgs: preconditioner must be a function or matrix");
     endif
 
     precon = @(x) M2m1x (M1m1x (x));
 
     if (nargin < 7 || isempty (x0))
       x0 = zeros (size (b));
     endif
 
diff --git a/scripts/sparse/qmr.m b/scripts/sparse/qmr.m
--- a/scripts/sparse/qmr.m
+++ b/scripts/sparse/qmr.m
@@ -96,18 +96,17 @@ function [x, flag, relres, iter, resvec]
       Atx = @(x) feval (fun, x, "transp");
     elseif (isa (A, "function_handle"))
       Ax  = @(x) feval (A, x, "notransp");
       Atx = @(x) feval (A, x, "transp");
     elseif (isnumeric (A) && ismatrix (A))
       Ax  = @(x) A  * x;
       Atx = @(x) A' * x;
     else
-      error (["qmr: first argument is expected to " ...
-                "be a function or a square matrix"]);
+      error ("qmr: A must be a square matrix or function");
     endif
 
     if (nargin < 3 || isempty (tol))
       tol = 1e-6;
     endif
 
     if (nargin < 4 || isempty (maxit))
       maxit = min (rows (b), 20);
@@ -124,36 +123,34 @@ function [x, flag, relres, iter, resvec]
       M1tm1x = @(x) feval (fun, x, "transp");
     elseif (isa (M1, "function_handle"))
       M1m1x  = @(x) feval (M1, x, "notransp");
       M1tm1x = @(x) feval (M1, x, "transp");
     elseif (isnumeric (M1) && ismatrix (M1))
       M1m1x  = @(x) M1  \ x;
       M1tm1x = @(x) M1' \ x;
     else
-      error (["qmr: preconditioner is expected to " ...
-                "be a function or matrix"]);
+      error ("qmr: preconditioner must be a function or matrix");
     endif
 
     if (nargin < 6 || isempty (M2))
       M2m1x = @(x, ignore) x;
       M2tm1x = M2m1x;
     elseif (ischar (M2))
       fun = str2func (M2);
       M2m1x  = @(x) feval (fun, x, "notransp");
       M2tm1x = @(x) feval (fun, x, "transp");
     elseif (isa (M2, "function_handle"))
       M2m1x  = @(x) feval (M2, x, "notransp");
       M2tm1x = @(x) feval (M2, x, "transp");
     elseif (isnumeric (M2) && ismatrix (M2))
       M2m1x  = @(x) M2  \ x;
       M2tm1x = @(x) M2' \ x;
     else
-      error (["qmr: preconditioner is expected to " ...
-                "be a function or matrix"]);
+      error ("qmr: preconditioner must be a function or matrix");
     endif
 
 
     if (nargin < 7 || isempty (x0))
       x = zeros (size (b));
     else
       x = x0;
     endif
diff --git a/scripts/sparse/spaugment.m b/scripts/sparse/spaugment.m
--- a/scripts/sparse/spaugment.m
+++ b/scripts/sparse/spaugment.m
@@ -75,17 +75,17 @@
 ## @end deftypefn
 
 function s = spaugment (A, c)
   if (nargin < 2)
     if (issparse (A))
       c = max (max (abs (A))) / 1000;
     else
       if (ndims (A) != 2)
-        error ("spaugment: expecting 2-dimenisional matrix");
+        error ("spaugment: A must be a 2-D matrix");
       else
         c = max (abs (A(:))) / 1000;
       endif
     endif
   elseif (! isscalar (c))
     error ("spaugment: C must be a scalar");
   endif
 
diff --git a/scripts/special-matrix/pascal.m b/scripts/special-matrix/pascal.m
--- a/scripts/special-matrix/pascal.m
+++ b/scripts/special-matrix/pascal.m
@@ -44,17 +44,17 @@
 
 function retval = pascal (n, t = 0)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   elseif (! (isscalar (n) && isscalar (t)))
     error ("pascal: N and T must be scalars");
   elseif (! any (t == [-1, 0, 1, 2]))
-    error ("pascal: expecting T to be -1, 0, 1, or 2, found %d", t);
+    error ("pascal: T must be -1, 0, 1, or 2, found %d", t);
   endif
 
   retval = zeros (n);
   if (n > 0)
     retval(:,1) = 1;
   endif
 
   if (t == -1)
@@ -86,11 +86,11 @@ endfunction
 %!assert (pascal (3,2), [1,1,1;-2,-1,0;1,0,0])
 %!assert (pascal (0,2), [])
 
 ## Test input validation
 %!error pascal ()
 %!error pascal (1,2,3)
 %!error <N and T must be scalars> pascal ([1 2])
 %!error <N and T must be scalars> pascal (1, [1 2])
-%!error <expecting T to be> pascal (3,-2)
-%!error <expecting T to be> pascal (3,4)
+%!error <T must be -1> pascal (3,-2)
+%!error <T must be .* or 2> pascal (3,4)
 
diff --git a/scripts/statistics/base/moment.m b/scripts/statistics/base/moment.m
--- a/scripts/statistics/base/moment.m
+++ b/scripts/statistics/base/moment.m
@@ -146,17 +146,17 @@ function m = moment (x, p, opt1, opt2)
   elseif (nargin == 4)
     if (ischar (opt1))
       type = opt1;
       dim = opt2;
     elseif (ischar (opt2))
       type = opt2;
       dim = opt1;
     else
-      error ("moment: expecting TYPE to be a string");
+      error ("moment: TYPE must be a string");
     endif
   endif
 
   nd = ndims (x);
   sz = size (x);
   if (need_dim)
     ## Find the first non-singleton dimension.
     (dim = find (sz > 1, 1)) || (dim = 1);
@@ -194,13 +194,13 @@ endfunction
 ## Test input validation
 %!error moment ()
 %!error moment (1)
 %!error moment (1, 2, 3, 4, 5)
 %!error <X must be a non-empty numeric matrix> moment (['A'; 'B'], 2)
 %!error <X must be a non-empty numeric matrix> moment (ones (2,0,3), 2)
 %!error <P must be a numeric scalar> moment (1, true)
 %!error <P must be a numeric scalar> moment (1, ones (2,2))
-%!error <expecting TYPE to be a string> moment (1, 2, 3, 4)
+%!error <TYPE must be a string> moment (1, 2, 3, 4)
 %!error <DIM must be an integer and a valid dimension> moment (1, 2, ones (2,2))
 %!error <DIM must be an integer and a valid dimension> moment (1, 2, 1.5)
 %!error <DIM must be an integer and a valid dimension> moment (1, 2, 4)
 
diff --git a/scripts/strings/cstrcat.m b/scripts/strings/cstrcat.m
--- a/scripts/strings/cstrcat.m
+++ b/scripts/strings/cstrcat.m
@@ -47,17 +47,17 @@ function st = cstrcat (varargin)
 
   if (nargin == 0)
     ## Special because if varargin is empty, iscellstr still returns
     ## true but then "[varargin{:}]" would be of class double.
     st = "";
   elseif (iscellstr (varargin))
     st = [varargin{:}];
   else
-    error ("cstrcat: expecting arguments to character strings");
+    error ("cstrcat: arguments must be character strings");
   endif
 
 endfunction
 
 
 ## Test the dimensionality
 ## 1d
 %!assert (cstrcat ("ab ", "ab "), "ab ab ")
diff --git a/test/system.tst b/test/system.tst
--- a/test/system.tst
+++ b/test/system.tst
@@ -220,17 +220,17 @@
 
 %!assert (iscell (glob ([filesep "*"])))
 
 %!error <Invalid call to glob> glob ()
 %!error <Invalid call to glob> glob ("foo", 1)
 
 %!assert (ischar (file_in_path (path (), "date.m")))
 
-%!error <file_in_path: expecting option to be a string> file_in_path ("foo", "bar", 1)
+%!error <file_in_path: optional third argument must be a string> file_in_path ("foo", "bar", 1)
 %!error <Invalid call to file_in_path> file_in_path ()
 %!error <Invalid call to file_in_path> file_in_path ("foo", "bar", "baz", "ooka")
 
 %!testif HAVE_GETPWUID
 %! x = getpwuid (getuid ());
 %! assert (x.dir, tilde_expand ("~"));
 %! assert (x.dir, tilde_expand (sprintf ("~%s", x.name)));
 %! assert ("foobar", tilde_expand ("foobar"));
