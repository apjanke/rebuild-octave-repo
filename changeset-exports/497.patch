# HG changeset patch
# User jwe
# Date 773633317 0
#      Fri Jul 08 02:08:37 1994 +0000
# Node ID 88614b380d6e3930afb81235982902047a64de7c
# Parent  e7c5b23b34d3fca8e793cf3624d62165c3537e3c
[project @ 1994-07-08 02:00:57 by jwe]

diff --git a/src/balance.cc b/src/balance.cc
--- a/src/balance.cc
+++ b/src/balance.cc
@@ -37,58 +37,58 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
 #include "f-balance.h"
 
 #ifdef WITH_DLD
-tree_constant *
-builtin_balance_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_balance_2 (const Octave_object& args, int nargin, int nargout)
 {
   return balance (args, nargin, nargout);
 }
 #endif
 
-tree_constant *
-balance (const tree_constant *args, int nargin, int nargout)
+Octave_object
+balance (const Octave_object& args, int nargin, int nargout)
 {
   char *bal_job;
   int my_nargin;		// # args w/o optional string arg
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
   // determine if balancing option is listed
   // set my_nargin to the number of matrix inputs
-  if (args[nargin-1].const_type () == tree_constant_rep::string_constant ){
-    bal_job = args[nargin-1].string_value ();
+  if (args(nargin-1).const_type () == tree_constant_rep::string_constant ){
+    bal_job = args(nargin-1).string_value ();
     my_nargin = nargin-2;
   }
   else
   {
     bal_job = "B";
     my_nargin = nargin-1;
   }
 
-  tree_constant arg = args[1].make_numeric ();
+  tree_constant arg = args(1).make_numeric ();
   int a_nr = arg.rows ();
   int a_nc = arg.columns ();
 
 // Check argument 1 dimensions.
 
   if (a_nr == 0 || a_nc == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
 	  if (flag < 0) warning ("balance: argument is empty matrix");
 	  Matrix m;
-	  retval = new tree_constant [3];
-	  retval[0] = tree_constant (m);
-	  retval[1] = tree_constant (m);
+	  retval.resize (2);
+	  retval(0) = tree_constant (m);
+	  retval(1) = tree_constant (m);
 	}
       else
 	error ("balance: empty matrix is invalid as argument");
 
       return retval;
     }
 
   if (a_nr != a_nc)
@@ -126,52 +126,52 @@ balance (const tree_constant *args, int 
 // Treat AEP/ GEP cases.
 
   switch (my_nargin)
     {
     case 1:
 
 // Algebraic eigenvalue problem.
 
-      retval = new tree_constant[nargout+1];
+      retval.resize (nargout ? nargout : 1);
       if (arg.is_complex_type ())
 	{
 	  ComplexAEPBALANCE result (caa, bal_job);
 
-	  if (nargout == 1)
-	    retval[0] = tree_constant(result.balanced_matrix ());
+	  if (nargout == 0 || nargout == 1)
+	    retval(0) = tree_constant(result.balanced_matrix ());
 	  else
 	    {
-	      retval[0] = tree_constant (result.balancing_matrix ());
-	      retval[1] = tree_constant (result.balanced_matrix ());
+	      retval(0) = tree_constant (result.balancing_matrix ());
+	      retval(1) = tree_constant (result.balanced_matrix ());
 	    }
 	}
       else
 	{
 	  AEPBALANCE result (aa, bal_job);
 
-	  if (nargout == 1)
-	    retval[0] = tree_constant (result.balanced_matrix ());
+	  if (nargout == 0 || nargout == 1)
+	    retval(0) = tree_constant (result.balanced_matrix ());
 	  else
 	    {
-	      retval[0] = tree_constant (result.balancing_matrix ());
-	      retval[1] = tree_constant (result.balanced_matrix ());
+	      retval(0) = tree_constant (result.balancing_matrix ());
+	      retval(1) = tree_constant (result.balanced_matrix ());
 	    }
 	}
       break;
     case 2:
 
 // Generalized eigenvalue problem.
 
       {
-	retval = new tree_constant[nargout+1];
+	retval.resize (nargout ? nargout : 1);
       
 // 1st we have to check argument 2 dimensions and type...
 
-	tree_constant brg = args[2].make_numeric ();
+	tree_constant brg = args(2).make_numeric ();
 	int b_nr = brg.rows ();
 	int b_nc = brg.columns ();
       
 // Check argument 2 dimensions -- must match arg 1.
 
 	if ((b_nr != b_nc) || (b_nr != a_nr))
 	  {
 	    gripe_nonconformant ();
@@ -233,46 +233,46 @@ balance (const tree_constant *args, int 
 
 	    cbb = result.left_balancing_matrix () * cbb
 	      * result.right_balancing_matrix ();
 
 	    switch (nargout)
 	      {
 	      case 1:
 		warning ("balance: should use two output arguments");
-		retval[0] = tree_constant (caa);
+		retval(0) = tree_constant (caa);
 		break;
 	      case 2:
-		retval[0] = tree_constant (caa);
-		retval[1] = tree_constant (cbb);
+		retval(0) = tree_constant (caa);
+		retval(1) = tree_constant (cbb);
 		break;
 	      case 4:
-		retval[0] = tree_constant (result.left_balancing_matrix ());
-		retval[1] = tree_constant (result.right_balancing_matrix ());
-		retval[2] = tree_constant (caa);
-		retval[3] = tree_constant (cbb);
+		retval(0) = tree_constant (result.left_balancing_matrix ());
+		retval(1) = tree_constant (result.right_balancing_matrix ());
+		retval(2) = tree_constant (caa);
+		retval(3) = tree_constant (cbb);
 		break;
 	      default:
 		error ("balance: illegal number of output arguments");
 		break;
 	      }
 	  }
 	else
 	  {
 	    switch (nargout)
 	      {
 	      case 2:
-		retval[0] = tree_constant (result.balanced_a_matrix ());
-		retval[1] = tree_constant (result.balanced_b_matrix ());
+		retval(0) = tree_constant (result.balanced_a_matrix ());
+		retval(1) = tree_constant (result.balanced_b_matrix ());
 		break;
 	      case 4:
-		retval[0] = tree_constant (result.left_balancing_matrix ());
-		retval[1] = tree_constant (result.right_balancing_matrix ());
-		retval[2] = tree_constant (result.balanced_a_matrix ());
-		retval[3] = tree_constant (result.balanced_b_matrix ());
+		retval(0) = tree_constant (result.left_balancing_matrix ());
+		retval(1) = tree_constant (result.right_balancing_matrix ());
+		retval(2) = tree_constant (result.balanced_a_matrix ());
+		retval(3) = tree_constant (result.balanced_b_matrix ());
 		break;
 	      default:
 		error ("balance: illegal number of output arguments");
 		break;
 	      }
 	  }
       }
       break;
diff --git a/src/chol.cc b/src/chol.cc
--- a/src/chol.cc
+++ b/src/chol.cc
@@ -30,44 +30,44 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
 #include "f-chol.h"
 
 #ifdef WITH_DLD
-tree_constant *
-builtin_chol_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object*
+builtin_chol_2 (const Octave_object& args, int nargin, int nargout)
 {
-  return chol (args, nargin, nargout);
+  Octave_object retval (1);
+  retval(0) = chol (args(1));
+  return retval;
 }
 #endif
 
-tree_constant *
-chol (const tree_constant *a, int nargin, int nargout)
+tree_constant
+chol (const tree_constant& a)
 {
-  tree_constant *retval = new tree_constant [2];
+  tree_constant retval;
 
-  tree_constant tmp = a[1].make_numeric ();;
+  tree_constant tmp = a.make_numeric ();;
     
   int nr = tmp.rows ();
   int nc = tmp.columns ();
 
   if (nr == 0 || nc == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
 	  if (flag < 0)
 	    gripe_empty_arg ("chol", 0);
 	  Matrix m;
-	  retval = new tree_constant [3];
-	  retval[0] = tree_constant (m);
-	  retval[1] = tree_constant (m);
+	  retval = tree_constant (m);
 	}
       else
 	gripe_empty_arg ("chol", 1);
 
       return retval;
     }
 
   switch (tmp.const_type ())
@@ -75,40 +75,40 @@ chol (const tree_constant *a, int nargin
     case tree_constant_rep::matrix_constant:
       {
 	Matrix m = tmp.matrix_value ();
         int info;
 	CHOL fact (m, info);
         if (info != 0)
           error ("chol: matrix not positive definite");
         else
-  	  retval[0] = tree_constant (fact.chol_matrix ());
+  	  retval = tree_constant (fact.chol_matrix ());
       }
       break;
     case tree_constant_rep::complex_matrix_constant:
       {
 	ComplexMatrix m = tmp.complex_matrix_value ();
         int info;
 	ComplexCHOL fact (m, info);
         if (info != 0)
           error ("chol: matrix not positive definite");
         else
-	  retval[0] = tree_constant (fact.chol_matrix ());
+	  retval = tree_constant (fact.chol_matrix ());
       }
       break;
     case tree_constant_rep::scalar_constant:
       {
 	double d = tmp.double_value ();
-	retval[0] = tree_constant (d);
+	retval = tree_constant (d);
       }
       break;
     case tree_constant_rep::complex_scalar_constant:
       {
 	Complex c = tmp.complex_value ();
-	retval[0] = tree_constant (c);
+	retval = tree_constant (c);
       }
       break;
     default:
       break;
     }
   return retval;
 }
 
diff --git a/src/colloc.cc b/src/colloc.cc
--- a/src/colloc.cc
+++ b/src/colloc.cc
@@ -1,12 +1,12 @@
 // f-colloc.cc                                           -*- C++ -*-
 /*
 
-Copyright (C) 1993 John W. Eaton
+Copyright (C) 1993, 1994 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -28,57 +28,57 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "CollocWt.h"
 
 #include "tree-const.h"
 #include "error.h"
 #include "utils.h"
 #include "f-colloc.h"
 
 #ifdef WITH_DLD
-tree_constant *
-builtin_colloc_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_colloc_2 (const Octave_object& args, int nargin, int nargout)
 {
   return collocation_weights (args, nargin);
 }
 #endif
 
-tree_constant *
-collocation_weights (const tree_constant *args, int nargin)
+Octave_object
+collocation_weights (const Octave_object& args, int nargin)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
-  if (args[1].const_type () != tree_constant_rep::complex_scalar_constant
-      && args[1].const_type () != tree_constant_rep::scalar_constant)
+  if (args(1).const_type () != tree_constant_rep::complex_scalar_constant
+      && args(1).const_type () != tree_constant_rep::scalar_constant)
     {
       error ("colloc: first argument must be a scalar");
       return retval;
     }
 
-  int ncol = NINT (args[1].double_value ());
+  int ncol = NINT (args(1).double_value ());
   if (ncol < 0)
     {
       error ("colloc: first argument must be non-negative");
       return retval;
     }
 
   int ntot = ncol;
   int left = 0;
   int right = 0;
 
   for (int i = 2; i < nargin; i++)
     {
-      if (args[i].is_defined ())
+      if (args(i).is_defined ())
 	{
-	  if (! args[i].is_string_type ())
+	  if (! args(i).is_string_type ())
 	    {
 	      error ("colloc: expecting string argument");
 	      return retval;
 	    }
 
-	  char *s = args[i].string_value ();
+	  char *s = args(i).string_value ();
 	  if (s != (char *) NULL
 	      && (((*s == 'R' || *s == 'r') && strlen (s) == 1)
 		  || strcmp (s, "right") == 0))
 	    {
 	      right = 1;
 	    }
 	  else if (s != (char *) NULL
 		   && (((*s == 'L' || *s == 'l') && strlen (s) == 1)
@@ -108,23 +108,22 @@ collocation_weights (const tree_constant
   
   CollocWt wts (ncol, left, right);
 
   ColumnVector r = wts.roots ();
   Matrix A = wts.first ();
   Matrix B = wts.second ();
   ColumnVector q = wts.quad_weights ();
 
-  retval = new tree_constant [5];
+  retval.resize (4);
 
-  retval[0] = tree_constant (r);
-  retval[1] = tree_constant (A);
-  retval[2] = tree_constant (B);
-  retval[3] = tree_constant (q);
-  retval[4] = tree_constant ();
+  retval(0) = tree_constant (r);
+  retval(1) = tree_constant (A);
+  retval(2) = tree_constant (B);
+  retval(3) = tree_constant (q);
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/src/dassl.cc b/src/dassl.cc
--- a/src/dassl.cc
+++ b/src/dassl.cc
@@ -36,24 +36,24 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "utils.h"
 #include "pager.h"
 #include "f-dassl.h"
 
 // Global pointer for user defined function required by dassl.
 static tree_fvc *dassl_fcn;
 
 #ifdef WITH_DLD
-tree_constant *
-builtin_dassl_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_dassl_2 (const Octave_object& args, int nargin, int nargout)
 {
   return dassl (args, nargin, nargout);
 }
 
-tree_constant *
-builtin_dassl_options_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_dassl_options_2 (const Octave_object& args, int nargin, int nargout)
 {
   return dassl_options (args, nargin, nargout);
 }
 #endif
 
 static ODE_options dassl_opts;
 
 ColumnVector
@@ -61,95 +61,88 @@ dassl_user_function (const ColumnVector&
 {
   ColumnVector retval;
 
   int nstates = x.capacity ();
 
   assert (nstates == xdot.capacity ());
 
 //  tree_constant name (dassl_fcn->name ());
-  tree_constant *args = new tree_constant [4];
-//  args[0] = name;
-  args[3] = tree_constant (t);
+  Octave_object args (4);
+//  args(0) = name;
+  args(3) = tree_constant (t);
 
   if (nstates > 1)
     {
       Matrix m1 (nstates, 1);
       Matrix m2 (nstates, 1);
       for (int i = 0; i < nstates; i++)
 	{
 	  m1 (i, 0) = x.elem (i);
 	  m2 (i, 0) = xdot.elem (i);
 	}
       tree_constant state (m1);
       tree_constant deriv (m2);
-      args[1] = state;
-      args[2] = deriv;
+      args(1) = state;
+      args(2) = deriv;
     }
   else
     {
       double d1 = x.elem (0);
       double d2 = xdot.elem (0);
       tree_constant state (d1);
       tree_constant deriv (d2);
-      args[1] = state;
-      args[2] = deriv;
+      args(1) = state;
+      args(2) = deriv;
     }
 
   if (dassl_fcn != (tree_fvc *) NULL)
     {
-      tree_constant *tmp = dassl_fcn->eval (0, 1, args, 4);
-
-      delete [] args;
+      Octave_object tmp = dassl_fcn->eval (0, 1, args, 4);
 
       if (error_state)
 	{
 	  gripe_user_supplied_eval ("dassl");
 	  return retval;
 	}
 
-      if (tmp != NULL_TREE_CONST && tmp[0].is_defined ())
+      if (tmp.length () > 0 && tmp(0).is_defined ())
 	{
-	  retval = tmp[0].to_vector ();
-
-	  delete [] tmp;
+	  retval = tmp(0).to_vector ();
 
 	  if (retval.length () == 0)
 	    gripe_user_supplied_eval ("dassl");
 	}
       else
-	{
-	  delete [] tmp;
-	  gripe_user_supplied_eval ("dassl");
-	}
+	gripe_user_supplied_eval ("dassl");
     }
 
   return retval;
 }
 
-tree_constant *
-dassl (const tree_constant *args, int nargin, int nargout)
+Octave_object
+dassl (const Octave_object& args, int nargin, int nargout)
 {
 // Assumes that we have been given the correct number of arguments.
 
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
-  dassl_fcn = is_valid_function (args[1], "dassl", 1);
+  dassl_fcn = is_valid_function (args(1), "dassl", 1);
   if (dassl_fcn == (tree_fvc *) NULL
       || takes_correct_nargs (dassl_fcn, 4, "dassl", 1) != 1)
     return retval;
 
-  ColumnVector state = args[2].to_vector ();
-  ColumnVector deriv = args[3].to_vector ();
-  ColumnVector out_times = args[4].to_vector ();
+  ColumnVector state = args(2).to_vector ();
+  ColumnVector deriv = args(3).to_vector ();
+  ColumnVector out_times = args(4).to_vector ();
   ColumnVector crit_times;
   int crit_times_set = 0;
   if (nargin > 5)
     {
-      crit_times = args[5].to_vector ();
+      crit_times = args(5).to_vector ();
       crit_times_set = 1;
     }
 
   if (state.capacity () != deriv.capacity ())
     {
       error ("dassl: x and xdot must have the same size");
       return retval;
     }
@@ -163,38 +156,38 @@ dassl (const tree_constant *args, int na
   Matrix output;
   Matrix deriv_output;
 
   if (crit_times_set)
     output = dae.integrate (out_times, deriv_output, crit_times);
   else
     output = dae.integrate (out_times, deriv_output);
 
-  retval = new tree_constant [3];
-  retval[0] = tree_constant (output);
-  retval[1] = tree_constant (deriv_output);
+  retval.resize (2);
+  retval(0) = tree_constant (output);
+  retval(1) = tree_constant (deriv_output);
   return retval;
 }
 
 typedef void (ODE_options::*d_set_opt_mf) (double);
 typedef double (ODE_options::*d_get_opt_mf) (void);
 
 #define MAX_TOKENS 3
 
-struct ODE_OPTIONS
+struct DAE_OPTIONS
 {
   char *keyword;
   char *kw_tok[MAX_TOKENS + 1];
   int min_len[MAX_TOKENS + 1];
   int min_toks_to_match;
   d_set_opt_mf d_set_fcn;
   d_get_opt_mf d_get_fcn;
 };
 
-static ODE_OPTIONS dassl_option_table[] =
+static DAE_OPTIONS dassl_option_table [] =
 {
   { "absolute tolerance",
     { "absolute", "tolerance", NULL, NULL, },
     { 1, 0, 0, 0, }, 1,
     ODE_options::set_absolute_tolerance,
     ODE_options::absolute_tolerance, },
 
   { "initial step size",
@@ -228,17 +221,17 @@ print_dassl_option_list (void)
 
   print_usage ("dassl_options", 1);
 
   output_buf << "\n"
 	     << "Options for dassl include:\n\n"
 	     << "  keyword                                  value\n"
 	     << "  -------                                  -----\n\n";
 
-  ODE_OPTIONS *list = dassl_option_table;
+  DAE_OPTIONS *list = dassl_option_table;
 
   char *keyword;
   while ((keyword = list->keyword) != (char *) NULL)
     {
       output_buf.form ("  %-40s ", keyword);
 
       double val = (dassl_opts.*list->d_get_fcn) ();
       if (val < 0.0)
@@ -252,57 +245,53 @@ print_dassl_option_list (void)
 
   output_buf << "\n" << ends;
   maybe_page_output (output_buf);
 }
 
 static void
 do_dassl_option (char *keyword, double val)
 {
-  ODE_OPTIONS *list = dassl_option_table;
+  DAE_OPTIONS *list = dassl_option_table;
 
   while (list->keyword != (char *) NULL)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
 				list->min_toks_to_match, MAX_TOKENS))
 	{
 	  (dassl_opts.*list->d_set_fcn) (val);
 
 	  return;
 	}
       list++;
     }
 
   warning ("dassl_options: no match for `%s'", keyword);
 }
 
-tree_constant *
-dassl_options (const tree_constant *args, int nargin, int nargout)
+Octave_object
+dassl_options (const Octave_object& args, int nargin, int nargout)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
   if (nargin == 1)
-    {
-      print_dassl_option_list ();
-    }
+    print_dassl_option_list ();
   else if (nargin == 3)
     {
-      if (args[1].is_string_type ())
+      if (args(1).is_string_type ())
 	{
-	  char *keyword = args[1].string_value ();
-	  double val = args[2].double_value ();
+	  char *keyword = args(1).string_value ();
+	  double val = args(2).double_value ();
 	  do_dassl_option (keyword, val);
 	}
       else
 	print_usage ("dassl_options");
     }
   else
-    {
-      print_usage ("dassl_options");
-    }
+    print_usage ("dassl_options");
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/src/det.cc b/src/det.cc
--- a/src/det.cc
+++ b/src/det.cc
@@ -30,21 +30,21 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
 #include "f-det.h"
 
 #ifdef WITH_DLD
-tree_constant *
-builtin_det_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_det_2 (const Octave_object& args, int nargin, int nargout)
 {
-  tree_constant *retval = new tree_constant [2];
-  retval[0] = determinant (args[1]);
+  Octave_object retval (1);
+  retval(0) = determinant (args(1));
   return retval;
 }
 #endif
 
 tree_constant
 determinant (const tree_constant& a)
 {
   tree_constant retval;
diff --git a/src/dynamic-ld.h b/src/dynamic-ld.h
--- a/src/dynamic-ld.h
+++ b/src/dynamic-ld.h
@@ -19,33 +19,33 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (octave_dynamic_ld_h)
 #define octave_dynamic_ld_h 1
 
-class tree_constant;
+#include "oct-obj.h"
 
-typedef tree_constant* (*builtin_fcn_ptr) (tree_constant*, int, int);
+typedef Octave_object (*builtin_fcn_ptr) (const Octave_object&, int, int);
 
 extern void octave_dld_tc2_unlink_by_symbol (const char *name, int hard = 1);
 
 extern void octave_dld_tc2_unlink_by_file (const char *name, int hard = 1);
 
 extern builtin_fcn_ptr octave_dld_tc2 (const char *name,
 				       const char *fcn,
 				       const char *object);
 
-extern tree_constant *octave_dld_tc2_and_go (tree_constant *args,
-					     int nargin, int nargout,
-					     const char *name,
-					     const char *fcn,
-					     const char *object);
+extern Octave_object octave_dld_tc2_and_go (const Octave_object&,
+					    int nargin, int nargout,
+					    const char *name,
+					    const char *fcn,
+					    const char *object);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/eig.cc b/src/eig.cc
--- a/src/eig.cc
+++ b/src/eig.cc
@@ -29,44 +29,44 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
 #include "f-eig.h"
 
 #ifdef WITH_DLD
-tree_constant *
-builtin_eig_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_eig_2 (const Octave_object& args, int nargin, int nargout)
 {
   return eig (args, nargin, nargout);
 }
 #endif
 
-tree_constant *
-eig (const tree_constant *args, int nargin, int nargout)
+Octave_object
+eig (const Octave_object& args, int nargin, int nargout)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
-  tree_constant arg = args[1].make_numeric ();
+  tree_constant arg = args(1).make_numeric ();
 
   int a_nr = arg.rows ();
   int a_nc = arg.columns ();
 
   if (a_nr == 0 || a_nc == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
 	  if (flag < 0)
 	    gripe_empty_arg ("eig", 0);
 	  Matrix m;
-	  retval = new tree_constant [3];
-	  retval[0] = tree_constant (m);
-	  retval[1] = tree_constant (m);
+	  retval.resize (2);
+	  retval(0) = tree_constant (m);
+	  retval(1) = tree_constant (m);
 	}
       else
 	gripe_empty_arg ("eig", 1);
 
       return retval;
     }
 
   if (a_nr != a_nc)
@@ -98,30 +98,30 @@ eig (const tree_constant *args, int narg
       ctmp = arg.complex_matrix_value ();
       result = EIG (ctmp);
       break;
     default:
       panic_impossible ();
       break;
     }
 
-  if (nargout == 1)
+  if (nargout == 0 || nargout == 1)
     {
-      retval = new tree_constant [2];
-      retval[0] = tree_constant (result.eigenvalues (), 1);
+      retval.resize (1);
+      retval(0) = tree_constant (result.eigenvalues (), 1);
     }
   else
     {
 // Blame it on Matlab.
 
       ComplexDiagMatrix d (result.eigenvalues ());
 
-      retval = new tree_constant [3];
-      retval[0] = tree_constant (result.eigenvectors ());
-      retval[1] = tree_constant (d);
+      retval.resize (2);
+      retval(0) = tree_constant (result.eigenvectors ());
+      retval(1) = tree_constant (d);
     }
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/expm.cc b/src/expm.cc
--- a/src/expm.cc
+++ b/src/expm.cc
@@ -38,21 +38,21 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
 #include "f-expm.h"
 
 #ifdef WITH_DLD
-tree_constant *
-builtin_matrix_exp_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_matrix_exp_2 (const Octave_object& args, int nargin, int nargout)
 {
-  tree_constant *retval = new tree_constant [2];
-  retval[0] = matrix_exp (args[1]);
+  Octave_object retval (1);
+  retval(0) = matrix_exp (args(1));
   return retval;
 }
 #endif
 
 extern "C"
 {
   double F77_FCN (dlange) (const char*, const int*, const int*,
 			   const double*, const int*, double*);
@@ -64,17 +64,17 @@ extern "C"
 tree_constant
 matrix_exp (const tree_constant& a)
 {
   tree_constant retval;
   tree_constant tmp = a.make_numeric ();
 
 // Constants for matrix exponential calculation.
 
-  static double padec[] =
+  static double padec [] =
     {
       5.0000000000000000e-1,
       1.1666666666666667e-1,
       1.6666666666666667e-2,
       1.6025641025641026e-3,
       1.0683760683760684e-4,
       4.8562548562548563e-6,
       1.3875013875013875e-7,
diff --git a/src/fft.cc b/src/fft.cc
--- a/src/fft.cc
+++ b/src/fft.cc
@@ -30,21 +30,21 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
 #include "f-fft.h"
 
 #ifdef WITH_DLD
-tree_constant *
-builtin_fft_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_fft_2 (const Octave_object& args, int nargin, int nargout)
 {
-  tree_constant *retval = new tree_constant [2];
-  retval[0] = fft (args[1]);
+  Octave_object retval (1);
+  retval(0) = fft (args(1));
   return retval;
 }
 #endif
 
 tree_constant
 fft (const tree_constant& a)
 {
   tree_constant retval;
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -270,56 +270,56 @@ file_io_get_file (const tree_constant ar
 	}
       else
 	error ("%s: invalid file specifier", warn_for);
     }
 
   return p;
 }
 
-tree_constant *
-fclose_internal (const tree_constant *args)
+Octave_object
+fclose_internal (const Octave_object& args)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
-  Pix p = return_valid_file (args[1]);
+  Pix p = return_valid_file (args(1));
 
   if (p == (Pix) NULL)
     return retval;
 
   file_info file = file_list (p);
 
   if (file.number () < 3)
     {
       warning ("fclose: can't close stdin, stdout, or stderr!");
       return retval;
     }
 
   int success = fclose (file.fptr ());
   file_list.del (p);
   file_count--;
 
-  retval = new tree_constant[2];
+  retval.resize (1);
   if (success == 0)
-    retval[0] = tree_constant (1.0); // succeeded
+    retval(0) = tree_constant (1.0); // succeeded
   else
     {
       error ("fclose: error on closing file");
-      retval[0] = tree_constant (0.0); // failed
+      retval(0) = tree_constant (0.0); // failed
     }
 
   return retval;
 }
 
-tree_constant *
-fflush_internal (const tree_constant *args)
+Octave_object
+fflush_internal (const Octave_object& args)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
-  Pix p = return_valid_file (args[1]);
+  Pix p = return_valid_file (args(1));
 
   if (p == (Pix) NULL)
     return retval;
 
   file_info file = file_list (p);
 
   if (strcmp (file.mode (), "r") == 0)
     {
@@ -329,23 +329,23 @@ fflush_internal (const tree_constant *ar
 
   int success = 0;
 
   if (file.number () == 1)
     flush_output_to_pager ();
   else
     success = fflush (file.fptr ());
 
-  retval = new tree_constant[2];
+  retval.resize (1);
   if (success == 0)
-    retval[0] = tree_constant (1.0); // succeeded
+    retval(0) = tree_constant (1.0); // succeeded
   else
     {
       error ("fflush: write error");
-      retval[0] = tree_constant (0.0); // failed
+      retval(0) = tree_constant (0.0); // failed
     }
 
   return retval;
 }
 
 static int
 valid_mode (const char *mode)
 {
@@ -356,94 +356,94 @@ valid_mode (const char *mode)
 	{
 	  m = mode[1];
 	  return (m == '\0' || (m == '+' && mode[2] == '\0'));
 	}
     }
   return 0;
 }
 
-tree_constant *
-fgets_internal (const tree_constant *args, int nargout)
+Octave_object
+fgets_internal (const Octave_object& args, int nargout)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
-  Pix p = file_io_get_file (args[1], "r", "fgets");
+  Pix p = file_io_get_file (args(1), "r", "fgets");
   
   if (p == (Pix) NULL)
     return retval;
 
   int length = 0;
-  if (args[2].is_scalar_type ())
+  if (args(2).is_scalar_type ())
     {
-      length = (int) args[2].double_value ();
+      length = (int) args(2).double_value ();
       if ((double) NINT (length) != length)
 	{
 	  error ("fgets: length not an integer value");
 	  return retval;
 	}
     }
 
   file_info file = file_list (p);
 
   char string[length+1];
   char *success = fgets (string, length+1, file.fptr ());
 
   if (success == (char *) NULL)
     {
-      retval = new tree_constant[2];
-      retval[0] = tree_constant (-1.0);
+      retval.resize (1);
+      retval(0) = tree_constant (-1.0);
       return retval;
     }
 
   if (nargout == 2)
     {
-      retval = new tree_constant[3];
-      retval[1] = tree_constant ((double) strlen (string));
+      retval.resize (2);
+      retval(1) = tree_constant ((double) strlen (string));
     }
   else
-    retval = new tree_constant[2];
+    retval.resize (1);
 
-  retval[0] = tree_constant (string);
+  retval(0) = tree_constant (string);
 
   return retval;
 }
 
-tree_constant *
-fopen_internal (const tree_constant *args)
+Octave_object
+fopen_internal (const Octave_object& args)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
   Pix p;
 
-  if (! args[1].is_string_type ())
+  if (! args(1).is_string_type ())
     {
       error ("fopen: file name must be a string");
       return retval;
     }
 
-  p = return_valid_file (args[1]);
+  p = return_valid_file (args(1));
 
   if (p != (Pix) NULL)
     {
       file_info file = file_list (p);
 
-      retval = new tree_constant[2];
-      retval[0] = tree_constant ((double) file.number ());
+      retval.resize (1);
+      retval(0) = tree_constant ((double) file.number ());
 
       return retval;
     }
 
-  if (! args[2].is_string_type ())
+  if (! args(2).is_string_type ())
     {
       error ("fopen: file mode must be a string");
       return retval;
     }
 
-  char *name = args[1].string_value ();
-  char *mode = args[2].string_value ();
+  char *name = args(1).string_value ();
+  char *mode = args(2).string_value ();
 
   if (! valid_mode (mode))
     {
       error ("fopen: invalid mode");
       return retval;
     }
 
   struct stat buffer;
@@ -461,26 +461,26 @@ fopen_internal (const tree_constant *arg
       return retval;
     }
 
   int number = file_count++;
 
   file_info file (number, name, file_ptr, mode);
   file_list.append (file);
 
-  retval = new tree_constant[2];
-  retval[0] = tree_constant ((double) number);
+  retval.resize (1);
+  retval(0) = tree_constant ((double) number);
 
   return retval;
 }
 
-tree_constant *
+Octave_object
 freport_internal (void)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
   Pix p = file_list.first ();
 
   ostrstream output_buf;
 
   output_buf << "\n number  mode  name\n\n";
   for (int i = 0; i < file_count; i++)
     {
       file_info file = file_list (p);
@@ -490,99 +490,99 @@ freport_internal (void)
     }
 
   output_buf << "\n" << ends;
   maybe_page_output (output_buf);
 
   return retval;
 }
 
-tree_constant *
-frewind_internal (const tree_constant *args)
+Octave_object
+frewind_internal (const Octave_object& args)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
-  Pix p = file_io_get_file (args[1], "a+", "frewind");
+  Pix p = file_io_get_file (args(1), "a+", "frewind");
 
   if (p != (Pix) NULL)
     {
       file_info file = file_list (p);
       rewind (file.fptr ());
     }
 
   return retval;
 }
 
-tree_constant *
-fseek_internal (const tree_constant *args, int nargin)
+Octave_object
+fseek_internal (const Octave_object& args, int nargin)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
-  Pix p = file_io_get_file (args[1], "a+", "fseek");
+  Pix p = file_io_get_file (args(1), "a+", "fseek");
 
   if (p == (Pix) NULL)
     return retval;
 
   long origin = SEEK_SET;
   long offset = 0;
-  if (args[2].is_scalar_type ())
+  if (args(2).is_scalar_type ())
     {
-      offset = (long) args[2].double_value ();
+      offset = (long) args(2).double_value ();
       if ((double) NINT (offset) != offset)
 	{
 	  error ("fseek: offset not an integer value");
 	  return retval;
 	}
     }
 
-  if (nargin == 4 && args[3].is_scalar_type ())
+  if (nargin == 4 && args(3).is_scalar_type ())
     {
-      origin = (long) args[3].double_value ();
+      origin = (long) args(3).double_value ();
       if (origin == -1)
 	origin = SEEK_CUR;
       else if (origin == -2)
 	origin = SEEK_END;
       else
 	{
 	  if ((double) NINT (origin) != origin)
 	    {
 	      error ("fseek: origin not an integer value");
 	      return retval;
 	    }
 	}
     }
 
   file_info file = file_list (p);
   int success = fseek (file.fptr (), offset, origin);
-  retval = new tree_constant[2];
+  retval.resize (1);
 
   if (success == 0)
-    retval[0] = tree_constant (1.0); // succeeded
+    retval(0) = tree_constant (1.0); // succeeded
   else
     {
       error ("fseek: file error");
-      retval[0] = tree_constant (0.0); // failed
+      retval(0) = tree_constant (0.0); // failed
     }
 
   return retval;
 }
 
-tree_constant *
-ftell_internal (const tree_constant *args)
+Octave_object
+ftell_internal (const Octave_object& args)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
-  Pix p = file_io_get_file (args[1], "a+", "ftell");
+  Pix p = file_io_get_file (args(1), "a+", "ftell");
 
   if (p != (Pix) NULL)
     {
       file_info file = file_list (p);
       long offset = ftell (file.fptr ());
-      retval = new tree_constant[2];
-      retval[0] = tree_constant ((double) offset);
+      retval.resize (1);
+      retval(0) = tree_constant ((double) offset);
 
       if (offset == -1L)
 	error ("ftell: write error");
     }
 
   return retval;
 }
 
@@ -600,17 +600,17 @@ close_files (void)
 	  if (success != 0)
 	    error ("closing %s", file.name ());
 	}
       file_list.del (p);
     }
 }
 
 static int
-process_printf_format (const char *s, const tree_constant *args,
+process_printf_format (const char *s, const Octave_object& args,
 		       ostrstream& sb, const char *type, int nargin)
 {
   ostrstream fmt;
 
   fmt << "%";  // do_printf() already blew past this one...
 
   tree_constant_rep::constant_type arg_type;
 
@@ -634,24 +634,24 @@ process_printf_format (const char *s, co
   if (*s == '*')
     {
       if (fmt_arg_count >= nargin)
 	{
 	  error ("%s: not enough arguments", type);
 	  return -1;
 	}
 
-      if (args[fmt_arg_count].const_type ()
+      if (args(fmt_arg_count).const_type ()
 	  != tree_constant_rep::scalar_constant)
 	{
 	  error ("%s: `*' must be replaced by an integer", type);
 	  return -1;
 	}
 
-      fmt << NINT (args[fmt_arg_count++].double_value ());
+      fmt << NINT (args(fmt_arg_count++).double_value ());
       s++;
       chars_from_fmt_str++;
     }
   else
     {
       while (*s != '\0' && isdigit (*s))
 	{
 	  chars_from_fmt_str++;
@@ -674,24 +674,24 @@ process_printf_format (const char *s, co
 	goto invalid_format;
 
       if (fmt_arg_count >= nargin)
 	{
 	  error ("%s: not enough arguments", type);
 	  return -1;
 	}
 
-      if (args[fmt_arg_count].const_type ()
+      if (args(fmt_arg_count).const_type ()
 	  != tree_constant_rep::scalar_constant)
 	{
 	  error ("%s: `*' must be replaced by an integer", type);
 	  return -1;
 	}
 
-      fmt << NINT (args[fmt_arg_count++].double_value ());
+      fmt << NINT (args(fmt_arg_count++).double_value ());
       s++;
       chars_from_fmt_str++;
     }
   else
     {
       while (*s != '\0' && isdigit (*s))
 	{
 	  chars_from_fmt_str++;
@@ -712,29 +712,29 @@ process_printf_format (const char *s, co
     goto invalid_format;
 
   if (fmt_arg_count >= nargin)
     {
       error ("%s: not enough arguments", type);
       return -1;
     }
 
-  arg_type = args[fmt_arg_count].const_type ();
+  arg_type = args(fmt_arg_count).const_type ();
 
   switch (*s)
     {
     case 'd': case 'i': case 'o': case 'u': case 'x': case 'X':
 
       if (arg_type != tree_constant_rep::scalar_constant)
 	goto invalid_conversion;
       else
 	{
 	  chars_from_fmt_str++;
 	  fmt << *s << ends;
-	  double d = args[fmt_arg_count++].double_value ();
+	  double d = args(fmt_arg_count++).double_value ();
 	  if ((int) d != d)
 	    goto invalid_conversion;
 	  else
 	    {
 	      char *s = fmt.str ();
 	      sb.form (s, (int) d);
 	      delete [] s;
 	      return chars_from_fmt_str;
@@ -745,44 +745,44 @@ process_printf_format (const char *s, co
 
       if (arg_type != tree_constant_rep::scalar_constant)
 	goto invalid_conversion;
       else
 	{
 	  chars_from_fmt_str++;
 	  fmt << *s << ends;
 	  char *s = fmt.str ();
-	  sb.form (s, args[fmt_arg_count++].double_value ());
+	  sb.form (s, args(fmt_arg_count++).double_value ());
 	  delete [] s;
 	  return chars_from_fmt_str;
 	}
 
     case 's':
 
       if (arg_type != tree_constant_rep::string_constant)
 	goto invalid_conversion;
       else
 	{
 	  chars_from_fmt_str++;
 	  fmt << *s << ends;
 	  char *s = fmt.str ();
-	  sb.form (s, args[fmt_arg_count++].string_value ());
+	  sb.form (s, args(fmt_arg_count++).string_value ());
 	  delete [] s;
 	  return chars_from_fmt_str;
 	}
 
     case 'c':
 
       if (arg_type != tree_constant_rep::string_constant)
 	goto invalid_conversion;
       else
 	{
 	  chars_from_fmt_str++;
 	  fmt << *s << ends;
-	  char *str = args[fmt_arg_count++].string_value ();
+	  char *str = args(fmt_arg_count++).string_value ();
 	  if (strlen (str) != 1)
 	    goto invalid_conversion;
 	  else
 	    {
 	      char *s = fmt.str ();
 	      sb.form (s, *str);
 	      delete [] s;
 	      return chars_from_fmt_str;
@@ -798,58 +798,58 @@ process_printf_format (const char *s, co
   return -1;
 
  invalid_format:
   error ("%s: invalid format", type);
   return -1;
 }
 
 
-tree_constant *
-do_printf (const char *type, const tree_constant *args, int nargin,
+Octave_object
+do_printf (const char *type, const Octave_object& args, int nargin,
 	   int nargout)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
   fmt_arg_count = 1;
   char *fmt;
   file_info file;
 
   if (strcmp (type, "fprintf") == 0)
     {
-      if (args[2].is_string_type ())
+      if (args(2).is_string_type ())
 	{
-	  fmt = args[2].string_value ();
+	  fmt = args(2).string_value ();
 	  fmt_arg_count++;
 	}
       else
 	{
 	  error ("%s: format must be a string", type);
 	  return retval;
 	}
 
-      Pix p = file_io_get_file (args[1], "a+", type);
+      Pix p = file_io_get_file (args(1), "a+", type);
 
       if (p == (Pix) NULL)
 	return retval;
 
       file = file_list (p);
 
       if (file.mode () == "r")
 	{
 	  error ("%s: file is read only", type);
 	  return retval;
 	}
 
-      fmt = args[2].string_value ();
+      fmt = args(2).string_value ();
 
       fmt_arg_count++;
     }
-  else if (args[1].is_string_type ())
+  else if (args(1).is_string_type ())
     {
-      fmt = args[1].string_value ();
+      fmt = args(1).string_value ();
       fmt_arg_count++;
     }
   else
     {
       error ("%s: invalid format string", type);
       return retval;
     }
 
@@ -898,29 +898,29 @@ do_printf (const char *type, const tree_
       char *msg = output_buf.str ();
       int success = fputs (msg, file.fptr ());
       if (success == EOF)
 	warning ("%s: unknown failure writing to file", type);
       delete [] msg;
     }
   else if (strcmp (type, "sprintf") == 0)
     {
-      retval = new tree_constant [2];
+      retval.resize (1);
       char *msg = output_buf.str ();
-      retval[0] = tree_constant (msg);
+      retval(0) = tree_constant (msg);
       delete [] msg;
     }
 
   return retval;
 }
 
 static int
 process_scanf_format (const char *s, ostrstream& fmt,
 		      const char *type, int nargout, FILE* fptr,
-		      tree_constant *values)
+		      Octave_object& values)
 {
   fmt << "%";
 
   int chars_from_fmt_str = 0;
   int store_value = 1;
   int string_width = -1;
   int success = 1;
 
@@ -956,43 +956,43 @@ process_scanf_format (const char *s, ost
     }
 
   if (*s == '\0')
     goto invalid_format;
 
 // Even if we don't have a place to store them, attempt to convert
 // everything specified by the format string.
 
-  if (fmt_arg_count >= nargout)
+  if (fmt_arg_count >= (nargout ? nargout : 1))
     store_value = 0;
 
   switch (*s)
     {
     case 'd': case 'i': case 'o': case 'u': case 'x': case 'X':
       {
 	chars_from_fmt_str++;
 	fmt << *s << ends;
 	int temp;
 	char *str = fmt.str ();
 	success = fscanf (fptr, str, &temp);
 	delete [] str;
 	if (success > 0 && store_value)
-	  values[fmt_arg_count++] = tree_constant ((double) temp);
+	  values(fmt_arg_count++) = tree_constant ((double) temp);
       }
       break;
     case 'e': case 'E': case 'f': case 'g': case 'G':
       {
 	chars_from_fmt_str++;
 	fmt << 'l' << *s << ends;
 	double temp;
 	char *str = fmt.str ();
 	success = fscanf (fptr, str, &temp);
 	delete [] str;
 	if (success > 0 && store_value)
-	  values[fmt_arg_count++] = tree_constant (temp);
+	  values(fmt_arg_count++) = tree_constant (temp);
       }
       break;
     case 's':
       {
 	if (string_width < 1)
 	  {
 	    string_width = 0;
 	    long original_position = ftell (fptr);
@@ -1018,33 +1018,33 @@ process_scanf_format (const char *s, ost
 	  }
 	chars_from_fmt_str++;
 	char temp[string_width+1];
 	fmt << *s << ends;
 	char *str = fmt.str ();
 	success = fscanf (fptr, str, temp);
 	delete [] str;
 	if (success && store_value)
-	  values[fmt_arg_count++] = tree_constant (temp);
+	  values(fmt_arg_count++) = tree_constant (temp);
       }
       break;
     case 'c':
       {
 	if (string_width < 1)
 	  string_width = 1;
 	chars_from_fmt_str++;
 	char temp[string_width+1];
 	memset (temp, '\0', string_width+1);
 	fmt << *s << ends;
 	char *str = fmt.str ();
 	success = fscanf (fptr, str, temp);
 	delete [] str;
 	temp[string_width] = '\0';
 	if (success > 0 && store_value)
-	  values[fmt_arg_count++] = tree_constant (temp);
+	  values(fmt_arg_count++) = tree_constant (temp);
       }
       break;
     default:
       goto invalid_format;
     }
 
   if (success > 0)
     return chars_from_fmt_str;
@@ -1063,76 +1063,76 @@ process_scanf_format (const char *s, ost
     {
     invalid_format:
       warning ("%s: invalid format", type);
     }
 
   return -1;
 }
 
-tree_constant *
-do_scanf (const char *type, const tree_constant *args, int nargin, int nargout)
+Octave_object
+do_scanf (const char *type, const Octave_object& args, int nargin, int nargout)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
   char *scanf_fmt = (char *) NULL;
   char *tmp_file = (char *) NULL;
   int tmp_file_open = 0;
   FILE *fptr = (FILE *) NULL;
   file_info file;
 
   fmt_arg_count = 0;
 
   if (strcmp (type, "scanf") != 0)
     {
-      if (args[2].is_string_type ())
-	scanf_fmt = args[2].string_value ();
+      if (args(2).is_string_type ())
+	scanf_fmt = args(2).string_value ();
       else
 	{
 	  error ("%s: format must be a string", type);
 	  return retval;
 	}
     }
 
   int doing_fscanf = (strcmp (type, "fscanf") == 0);
 
   if (doing_fscanf)
     {
-      Pix p = file_io_get_file (args[1], "r", type);
+      Pix p = file_io_get_file (args(1), "r", type);
 
       if (p == (Pix) NULL)
 	return retval;
 
       file = file_list (p);
 
       if (strcmp (file.mode (), "w") == 0 || strcmp (file.mode (), "a") == 0)
 	{
 	  error ("%s: this file is opened for writing only", type);
 	  return retval;
 	}
 
       fptr = file.fptr ();
     }
 
-  if ((fptr == (FILE *) NULL && args[1].is_string_type ())
+  if ((fptr == (FILE *) NULL && args(1).is_string_type ())
       || (doing_fscanf && file.number () == 0))
     {
       char *string;
 
       if (strcmp (type, "scanf") == 0)
-	scanf_fmt = args[1].string_value ();
+	scanf_fmt = args(1).string_value ();
 
       if (strcmp (type, "scanf") == 0
 	  || (doing_fscanf && file.number () == 0))
 	{
 	  string = gnu_readline ("");
 	  if (string && *string)
 	    maybe_save_history (string);
 	}
       else
-	string = args[1].string_value ();
+	string = args(1).string_value ();
 
       tmp_file = tmpnam ((char *) NULL);
 
       fptr = fopen (tmp_file, "w+");
       if (fptr == (FILE *) NULL)
 	{
 	  error ("%s: error opening temporary file", type);
 	  return retval;
@@ -1157,17 +1157,17 @@ do_scanf (const char *type, const tree_c
   else if (! doing_fscanf)
     {
       error ("%s: first argument must be a string", type);
       return retval;
     }
 
 // Scan scanf_fmt for % escapes and assign the arguments.
 
-  retval = new tree_constant[nargout+1];
+  retval.resize (nargout ? nargout : 1);
 
   char *ptr = scanf_fmt;
 
   for (;;)
     {
       ostrstream fmt;
       char c;
       while ((c = *ptr++) != '\0' && c != '%')
@@ -1186,20 +1186,17 @@ do_scanf (const char *type, const tree_c
 // We must be looking at a format specifier.  Extract it or fail.
 
       int status = process_scanf_format (ptr, fmt, type, nargout,
 					 fptr, retval);
 
       if (status < 0)
 	{
 	  if (fmt_arg_count == 0)
-	    {
-	      delete [] retval;
-	      retval = NULL_TREE_CONST;
-	    }
+	    retval.resize (0);
 	  break;
 	}
 
       ptr += status;
     }
 
   if (tmp_file_open)
     fclose (fptr);
@@ -1268,32 +1265,32 @@ num_items_remaining (FILE *fptr, char *t
  *                 char, uchar, schar, short, ushort, int, uint,
  *                 long, ulong, float, double
  *
  *                 Default  is uchar.
  *
  *     data	 : output data
  *     count	 : number of elements read
  */
-tree_constant *
-fread_internal (const tree_constant *args, int nargin, int nargout)
+Octave_object
+fread_internal (const Octave_object& args, int nargin, int nargout)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
-  Pix p = file_io_get_file (args[1], "r", "fread");
+  Pix p = file_io_get_file (args(1), "r", "fread");
 
   if (p == (Pix) NULL)
     return retval;
 
 // Get type and number of bytes per element to read.
   char *prec = "uchar";
   if (nargin > 3)
     {
-      if (args[3].is_string_type ())
-	prec = args[3].string_value ();
+      if (args(3).is_string_type ())
+	prec = args(3).string_value ();
       else
 	{
 	  error ("fread: precision must be a specified as a string");
 	  return retval;
 	}
     }
 
 // Get file info.
@@ -1307,25 +1304,25 @@ fread_internal (const tree_constant *arg
 
   double dnr = 0.0;
   double dnc = 0.0;
   int nr;
   int nc;
 
   if (nargin > 2)
     {
-      if (args[2].is_scalar_type ())
+      if (args(2).is_scalar_type ())
 	{
-	  tree_constant tmpa = args[2].make_numeric ();
+	  tree_constant tmpa = args(2).make_numeric ();
 	  dnr = tmpa.double_value ();
 	  dnc = 1.0;
 	}
-      else if (args[2].is_matrix_type ())
+      else if (args(2).is_matrix_type ())
 	{
-	  ColumnVector tmp = args[2].to_vector ();
+	  ColumnVector tmp = args(2).to_vector ();
 
 	  if (tmp.length () == 2)
 	    {
 	      dnr = tmp.elem (0);
 	      dnc = tmp.elem (1);
 	    }
 	  else
 	    {
@@ -1375,23 +1372,23 @@ fread_internal (const tree_constant *arg
   Matrix m (nr, nc, octave_NaN);
 
 // Read data.
 
   int count = m.read (fptr, prec);
 
   if (nargout > 1)
     {
-      retval = new tree_constant[3];
-      retval[1] = tree_constant ((double) count);
+      retval.resize (2);
+      retval(1) = tree_constant ((double) count);
     }
   else
-    retval = new tree_constant[2];
+    retval.resize (1);
 
-  retval[0] = tree_constant (m);
+  retval(0) = tree_constant (m);
 
   return retval;
 }
 
 /*
  * Write binary data to a file.
  *
  *   count = fwrite (fid, data, 'precision')
@@ -1402,111 +1399,111 @@ fread_internal (const tree_constant *arg
  *
  *                char, uchar, schar, short, ushort, int, uint,
  *                long, float, double
  *
  *                 Default is uchar.
  *
  *    count     : the number of elements written
  */
-tree_constant *
-fwrite_internal (const tree_constant *args, int nargin, int nargout)
+Octave_object
+fwrite_internal (const Octave_object& args, int nargin, int nargout)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
-  Pix p = file_io_get_file (args[1], "a+", "fwrite");
+  Pix p = file_io_get_file (args(1), "a+", "fwrite");
 
   if (p == (Pix) NULL)
     return retval;
 
 // Get type and number of bytes per element to read.
   char *prec = "uchar";
   if (nargin > 3)
     {
-      if (args[3].is_string_type ())
-	prec = args[3].string_value ();
+      if (args(3).is_string_type ())
+	prec = args(3).string_value ();
       else
 	{
 	  error ("fwrite: precision must be a specified as a string");
 	  return retval;
 	}
     }
 
   file_info file = file_list (p);
 
-  Matrix m = args[2].to_matrix ();
+  Matrix m = args(2).to_matrix ();
 
   int count = m.write (file.fptr (), prec);
 
-  retval = new tree_constant[2];
-  retval[0] = tree_constant ((double) count);
+  retval.resize (1);
+  retval(0) = tree_constant ((double) count);
 
   return retval;
 }
 
 /*
  * Check for an EOF condition on a file opened by fopen.
  *
  *   eof = feof (fid)
  *
  *     fid : file id from fopen
  *     eof : non zero for an end of file condition
  */
-tree_constant *
-feof_internal (const tree_constant *args, int nargin, int nargout)
+Octave_object
+feof_internal (const Octave_object& args, int nargin, int nargout)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
 // Get file info.
-  Pix p = return_valid_file (args[1]);
+  Pix p = return_valid_file (args(1));
 
   if (p == (Pix) NULL)
     return retval;
 
   file_info file = file_list (p);
 
-  retval = new tree_constant[2];
-  retval[0] = tree_constant (feof (file.fptr ()));
+  retval.resize (1);
+  retval(0) = tree_constant (feof (file.fptr ()));
 
   return retval;
 }
 
 /*
  * Check for an error condition on a file opened by fopen.
  *
  *   [message, errnum] = ferror (fid)
  *
  *     fid     : file id from fopen
  *     message : system error message
  *     errnum  : error number
  */
-tree_constant *
-ferror_internal (const tree_constant *args, int nargin, int nargout)
+Octave_object
+ferror_internal (const Octave_object& args, int nargin, int nargout)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
 // Get file info.
-  Pix p = return_valid_file (args[1]);
+  Pix p = return_valid_file (args(1));
 
   if (p == (Pix) NULL)
     return retval;
 
   file_info file = file_list (p);
 
   int ierr = ferror (file.fptr ());
 
   if (nargout > 1)
     {
-      retval = new tree_constant[3];
-      retval[1] = tree_constant ((double) ierr);
+      retval.resize (2);
+      retval(1) = tree_constant ((double) ierr);
     }
   else
-    retval = new tree_constant[2];
+    retval.resize (1);
 
-  retval[0] = tree_constant (strsave (strerror (ierr)));
+  retval(0) = tree_constant (strsave (strerror (ierr)));
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/src/file-io.h b/src/file-io.h
--- a/src/file-io.h
+++ b/src/file-io.h
@@ -23,46 +23,46 @@ Software Foundation, 675 Mass Ave, Cambr
 
 // Written by John C. Campbell <jcc@che.utexas.edu>.
 
 #if !defined (octave_files_h)
 #define octave_files_h 1
 
 #include <Pix.h>
 
-class tree_constant;
+#include "oct-obj.h"
 
 extern Pix return_valid_file (const tree_constant& arg);
 
-extern tree_constant *fclose_internal (const tree_constant *args);
-extern tree_constant *feof_internal (const tree_constant *args,
+extern Octave_object fclose_internal (const Octave_object& args);
+extern Octave_object feof_internal (const Octave_object& args,
+				    int nargin, int nargout);
+extern Octave_object ferror_internal (const Octave_object& args,
+				      int nargin, int nargout);
+extern Octave_object fflush_internal (const Octave_object& args);
+extern Octave_object fgets_internal (const Octave_object& args, int nargout);
+extern Octave_object fopen_internal (const Octave_object& args);
+extern Octave_object fread_internal (const Octave_object& args,
 				     int nargin, int nargout);
-extern tree_constant *ferror_internal (const tree_constant *args,
-                                       int nargin, int nargout);
-extern tree_constant *fflush_internal (const tree_constant *args);
-extern tree_constant *fgets_internal (const tree_constant *args, int nargout);
-extern tree_constant *fopen_internal (const tree_constant *args);
-extern tree_constant *fread_internal (const tree_constant *args,
+extern Octave_object freport_internal (void);
+extern Octave_object frewind_internal (const Octave_object& args);
+extern Octave_object fseek_internal (const Octave_object& args, int nargin);
+extern Octave_object ftell_internal (const Octave_object& args);
+extern Octave_object fwrite_internal (const Octave_object& args,
 				      int nargin, int nargout);
-extern tree_constant *freport_internal (void);
-extern tree_constant *frewind_internal (const tree_constant *args);
-extern tree_constant *fseek_internal (const tree_constant *args, int nargin);
-extern tree_constant *ftell_internal (const tree_constant *args);
-extern tree_constant *fwrite_internal (const tree_constant *args,
-				       int nargin, int nargout);
 
 extern void initialize_file_io (void);
 
 extern void close_files (void);
 
-extern tree_constant *do_printf (const char *type, const tree_constant *args,
-				 int nargin, int nargout);
+extern Octave_object do_printf (const char *type, const Octave_object& args,
+				int nargin, int nargout);
 
-extern tree_constant *do_scanf (const char *type, const tree_constant *args,
-				int nargin, int nargout);
+extern Octave_object do_scanf (const char *type, const Octave_object& args,
+			       int nargin, int nargout);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/fsolve.cc b/src/fsolve.cc
--- a/src/fsolve.cc
+++ b/src/fsolve.cc
@@ -36,24 +36,24 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "utils.h"
 #include "pager.h"
 #include "f-fsolve.h"
 
 // Global pointer for user defined function required by hybrd1.
 static tree_fvc *fsolve_fcn;
 
 #ifdef WITH_DLD
-tree_constant *
-builtin_fsolve_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_fsolve_2 (const Octave_object& args, int nargin, int nargout)
 {
   return fsolve (args, nargin, nargout);
 }
 
-tree_constant *
-builtin_fsolve_options (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_fsolve_options (const Octave_object& args, int nargin, int nargout)
 {
   return fsolve_options (args, nargin, nargout);
 }
 #endif
 
 static NLEqn_options fsolve_opts;
 
 int
@@ -87,94 +87,88 @@ hybrd_info_to_fsolve_info (int info)
 ColumnVector
 fsolve_user_function (const ColumnVector& x)
 {
   ColumnVector retval;
 
   int n = x.capacity ();
 
 //  tree_constant name = tree_constant (fsolve_fcn->name ());
-  tree_constant *args = new tree_constant [2];
-//  args[0] = name;
+  Octave_object args (2);
+//  args(0) = name;
 
   if (n > 1)
     {
       Matrix m (n, 1);
       for (int i = 0; i < n; i++)
 	m (i, 0) = x.elem (i);
       tree_constant vars (m);
-      args[1] = vars;
+      args(1) = vars;
     }
   else
     {
       double d = x.elem (0);
       tree_constant vars (d);
-      args[1] = vars;
+      args(1) = vars;
     }
 
   if (fsolve_fcn != (tree_fvc *) NULL)
     {
-      tree_constant *tmp = fsolve_fcn->eval (0, 1, args, 2);
-      delete [] args;
-      if (tmp != NULL_TREE_CONST && tmp[0].is_defined ())
+      Octave_object tmp = fsolve_fcn->eval (0, 1, args, 2);
+      if (tmp.length () > 0 && tmp(0).is_defined ())
 	{
-	  retval = tmp[0].to_vector ();
-
-	  delete [] tmp;
+	  retval = tmp(0).to_vector ();
 
 	  if (retval.length () <= 0)
 	    gripe_user_supplied_eval ("fsolve");
 	}
       else
-	{
-	  delete [] tmp;
-	  gripe_user_supplied_eval ("fsolve");
-	}
+	gripe_user_supplied_eval ("fsolve");
     }
 
   return retval;
 }
 
-tree_constant *
-fsolve (const tree_constant *args, int nargin, int nargout)
+Octave_object
+fsolve (const Octave_object& args, int nargin, int nargout)
 {
 // Assumes that we have been given the correct number of arguments.
 
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
-  fsolve_fcn = is_valid_function (args[1], "fsolve", 1);
+  fsolve_fcn = is_valid_function (args(1), "fsolve", 1);
   if (fsolve_fcn == (tree_fvc *) NULL
       || takes_correct_nargs (fsolve_fcn, 2, "fsolve", 1) != 1)
     return retval;
 
-  ColumnVector x = args[2].to_vector ();
+  ColumnVector x = args(2).to_vector ();
 
   if (nargin > 3)
     warning ("fsolve: ignoring extra arguments");
 
   if (nargout > 2)
     warning ("fsolve: can't compute path output yet");
 
   NLFunc foo_fcn (fsolve_user_function);
   NLEqn foo (x, foo_fcn);
   foo.copy (fsolve_opts);
 
   int info;
   ColumnVector soln = foo.solve (info);
 
   info = hybrd_info_to_fsolve_info (info);
 
-  retval = new tree_constant [nargout+1];
-  retval[0] = tree_constant (soln, 1);
+  retval.resize (nargout ? nargout : 1);
+  retval(0) = tree_constant (soln, 1);
 
   if (nargout > 1)
-    retval[1] = tree_constant ((double) info);
+    retval(1) = tree_constant ((double) info);
 
   if (nargout > 2)
-    retval[2] = tree_constant ();
+    retval(2) = tree_constant ();
 
   return retval;
 }
 
 typedef void (NLEqn_options::*d_set_opt_mf) (double);
 typedef double (NLEqn_options::*d_get_opt_mf) (void);
 
 #define MAX_TOKENS 1
@@ -184,17 +178,17 @@ struct NLEQN_OPTIONS
   char *keyword;
   char *kw_tok[MAX_TOKENS + 1];
   int min_len[MAX_TOKENS + 1];
   int min_toks_to_match;
   d_set_opt_mf d_set_fcn;
   d_get_opt_mf d_get_fcn;
 };
 
-static NLEQN_OPTIONS fsolve_option_table[] =
+static NLEQN_OPTIONS fsolve_option_table [] =
 {
   { "tolerance",
     { "tolerance", NULL, },
     { 1, 0, }, 1,
     NLEqn_options::set_tolerance,
     NLEqn_options::tolerance, },
 
   { NULL,
@@ -251,40 +245,36 @@ do_fsolve_option (char *keyword, double 
 	  return;
 	}
       list++;
     }
 
   warning ("fsolve_options: no match for `%s'", keyword);
 }
 
-tree_constant *
-fsolve_options (const tree_constant *args, int nargin, int nargout)
+Octave_object
+fsolve_options (const Octave_object& args, int nargin, int nargout)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
   if (nargin == 1)
-    {
-      print_fsolve_option_list ();
-    }
+    print_fsolve_option_list ();
   else if (nargin == 3)
     {
-      if (args[1].is_string_type ())
+      if (args(1).is_string_type ())
 	{
-	  char *keyword = args[1].string_value ();
-	  double val = args[2].double_value ();
+	  char *keyword = args(1).string_value ();
+	  double val = args(2).double_value ();
 	  do_fsolve_option (keyword, val);
 	}
       else
 	print_usage ("fsolve_options");
     }
   else
-    {
-      print_usage ("fsolve_options");
-    }
+    print_usage ("fsolve_options");
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/src/fsqp.cc b/src/fsqp.cc
--- a/src/fsqp.cc
+++ b/src/fsqp.cc
@@ -33,24 +33,24 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "error.h"
 #include "f-fsqp.h"
 
 // Global pointers for user defined functions required by fsqp.
 // static tree *fsqp_objective;
 // static tree *fsqp_constraints;
 
 #ifdef WITH_DLD
-tree_constant *
-builtin_fsqp_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_fsqp_2 (const Octave_object& args, int nargin, int nargout)
 {
   return fsqp (args, nargin, nargout);
 }
 
-tree_constant *
-builtin_fsqp_options_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_fsqp_options_2 (const Octave_object& args, int nargin, int nargout)
 {
   return fsqp_options (args, nargin, nargout);
 }
 #endif
 
 double
 fsqp_objective_function (const ColumnVector& x)
 {
@@ -59,18 +59,18 @@ fsqp_objective_function (const ColumnVec
 
 ColumnVector
 fsqp_constraint_function (const ColumnVector& x)
 {
   ColumnVector retval;
   return retval;
 }
 
-tree_constant *
-fsqp (const tree_constant *args, int nargin, int nargout)
+Octave_object
+fsqp (const Octave_object& args, int nargin, int nargout)
 {
 /*
 
 Handle all of the following:
 
   1. fsqp (x, phi)
   2. fsqp (x, phi, lb, ub)
   3. fsqp (x, phi, lb, ub, llb, c, lub)
@@ -79,27 +79,27 @@ Handle all of the following:
   6. fsqp (x, phi,         llb, c, lub, nllb, g, nlub)
   7. fsqp (x, phi,         llb, c, lub)
   8. fsqp (x, phi,                      nllb, g, nlub)
 
 */
 
 // Assumes that we have been given the correct number of arguments.
 
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
   error ("fsqp: not implemented yet");
   return retval;
 }
 
-tree_constant *
-fsqp_options (const tree_constant *args, int nargin, int nargout)
+Octave_object
+fsqp_options (const Octave_object& args, int nargin, int nargout)
 {
 // Assumes that we have been given the correct number of arguments.
 
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
   error ("fsqp_options: not implemented yet");
   return retval;
 }
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/src/givens.cc b/src/givens.cc
--- a/src/givens.cc
+++ b/src/givens.cc
@@ -52,40 +52,39 @@ int F77_FCN (dorgqr) (const int*, const 
 		      const int*, double*, double*, const int*, int*);
   
 int F77_FCN (zunghr) (const int*, const int*, const int*, Complex*,
 		      const int*, Complex*, Complex*, const int*,
 		      int*, long, long);
 #endif
 
 #ifdef WITH_DLD
-tree_constant *
-builtin_givens_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_givens_2 (const Octave_object& args, int nargin, int nargout)
 {
   return givens (args, nargin, nargout);
 }
 #endif
 
-tree_constant *
-givens (const tree_constant *args, int nargin, int nargout)
+Octave_object
+givens (const Octave_object& args, int nargin, int nargout)
 {
 
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
-  tree_constant arga = args[1].make_numeric ();
-  tree_constant argb = args[2].make_numeric ();
+  tree_constant arga = args(1).make_numeric ();
+  tree_constant argb = args(2).make_numeric ();
 
   if (! arga.is_scalar_type () && argb.is_scalar_type ())
     {
       error("givens: requires two scalar arguments"); 
     }
   else
     {
-
-      retval = new tree_constant [nargout+1];
+      retval.resize (nargout ? nargout : 1);
 
       Complex cx, cy;
       double x, y;
 
       if (arga.is_complex_type ())
 	cx = arga.complex_value ();
       else 
 	{
@@ -115,23 +114,23 @@ givens (const tree_constant *args, int n
 	    case 1:		// output a matrix
 	      {
 		ComplexMatrix g (2, 2);
 		g.elem (0, 0) = cc;
 		g.elem (1, 1) = cc;
 		g.elem (0, 1) = cs;
 		g.elem (1, 0) = -conj (cs);
 
-		retval[0] = tree_constant (g);
+		retval(0) = tree_constant (g);
 	      }
 	      break;
    
 	    case 2:		// output scalar values
-	      retval[0] = tree_constant(cc);
-	      retval[1] = tree_constant(cs);
+	      retval(0) = tree_constant(cc);
+	      retval(1) = tree_constant(cs);
 	      break;
 
 	    default:  
 	      error ("givens: illegal number of output arguments");
 	      break;
 	    }
 	}
       else
@@ -145,23 +144,23 @@ givens (const tree_constant *args, int n
 	    case 1:		// output a matrix
 	      {
 		Matrix g (2, 2);
 		g.elem (0, 0) = cc;
 		g.elem (1, 1) = cc;
 		g.elem (0, 1) = s;
 		g.elem (1, 0) = -s;
 
-		retval[0] = tree_constant (g);
+		retval(0) = tree_constant (g);
 	      }
 	      break;
    
 	    case 2:		// output scalar values
-	      retval[0] = tree_constant (cc);
-	      retval[1] = tree_constant (s);
+	      retval(0) = tree_constant (cc);
+	      retval(1) = tree_constant (s);
 	      break;
    
 	    default:
 	      error ("givens: illegal number of output arguments");
 	      break;
 	    }
 	}
     }
diff --git a/src/hess.cc b/src/hess.cc
--- a/src/hess.cc
+++ b/src/hess.cc
@@ -30,44 +30,44 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "error.h"
 #include "gripes.h"
 #include "f-hess.h"
 
 #ifdef WITH_DLD
-tree_constant *
-builtin_hess_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_hess_2 (const Octave_object& args, int nargin, int nargout)
 {
   return hess (args, nargin, nargout);
 }
 #endif
 
-tree_constant *
-hess (const tree_constant *args, int nargin, int nargout)
+Octave_object
+hess (const Octave_object& args, int nargin, int nargout)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
-  tree_constant arg = args[1].make_numeric ();
+  tree_constant arg = args(1).make_numeric ();
 
   int a_nr = arg.rows ();
   int a_nc = arg.columns ();
 
   if (a_nr == 0 || a_nc == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
 	  if (flag < 0)
 	    warning ("hess: argument is empty matrix");
 	  Matrix m;
-	  retval = new tree_constant [3];
-	  retval[0] = tree_constant (m);
-	  retval[1] = tree_constant (m);
+	  retval.resize (2);
+	  retval(0) = tree_constant (m);
+	  retval(1) = tree_constant (m);
         }
       else
 	error ("hess: empty matrix is invalid as argument");
 
       return retval;
     }
 
   if (a_nr != a_nc)
@@ -82,77 +82,77 @@ hess (const tree_constant *args, int nar
   switch (arg.const_type ())
     {
     case tree_constant_rep::matrix_constant:
       {
 	tmp = arg.matrix_value ();
 
 	HESS result (tmp);
 
-	if (nargout == 1)
+	if (nargout == 0 || nargout == 1)
 	  {
-	    retval = new tree_constant [2];
-	    retval[0] = tree_constant (result.hess_matrix ());
+	    retval.resize (1);
+	    retval(0) = tree_constant (result.hess_matrix ());
 	  }
         else
 	  {
-	    retval = new tree_constant [3];
-	    retval[0] = tree_constant (result.unitary_hess_matrix ());
-	    retval[1] = tree_constant (result.hess_matrix ());
+	    retval.resize (2);
+	    retval(0) = tree_constant (result.unitary_hess_matrix ());
+	    retval(1) = tree_constant (result.hess_matrix ());
           }
       }
       break;
     case tree_constant_rep::complex_matrix_constant:
       {
 	ctmp = arg.complex_matrix_value ();
 
 	ComplexHESS result (ctmp);
 
-	if (nargout == 1)
+	if (nargout == 0 || nargout == 1)
 	  {
-	    retval = new tree_constant [2];
-	    retval[0] = tree_constant (result.hess_matrix ());
+	    retval.resize (1);
+	    retval(0) = tree_constant (result.hess_matrix ());
 	  }
   	else
 	  {
-	    retval = new tree_constant [3];
-	    retval[0] = tree_constant (result.unitary_hess_matrix ());
-	    retval[1] = tree_constant (result.hess_matrix ());
+	    retval.resize (2);
+	    retval(0) = tree_constant (result.unitary_hess_matrix ());
+	    retval(1) = tree_constant (result.hess_matrix ());
 	  }
       }
       break;
     case tree_constant_rep::scalar_constant:
       {
 	double d = arg.double_value ();
-	if (nargout == 1)
+	if (nargout == 0 || nargout == 1)
 	  {
-	    retval = new tree_constant [2];
-	    retval[0] = tree_constant (d);
+	    retval.resize (1);
+	    retval(0) = tree_constant (d);
 	  }
 	else
 	  {
-	    retval = new tree_constant [3];
-	    retval[0] = tree_constant (1);
-	    retval[1] = tree_constant (d);
+	    retval.resize (2);
+	    retval(0) = tree_constant (1);
+	    retval(1) = tree_constant (d);
 	  }
       }
       break;
     case tree_constant_rep::complex_scalar_constant:
       {
 	Complex c = arg.complex_value ();
-	if (nargout == 1)
+	if (nargout == 0 || nargout == 1)
  	  {
-	    retval = new tree_constant [2];
-	    retval[0] = tree_constant (c);
+	    retval.resize (1);
+	    retval(0) = tree_constant (c);
 	  }
 	else
 	  {
-	    retval = new tree_constant [3];
-	    retval[0] = tree_constant (1);
-	    retval[1] = tree_constant (c);
+	    retval.resize (2);
+	    retval(0) = tree_constant (1);
+	    retval(1) = tree_constant (c);
 	  }
       }
       break;
     default:
       panic_impossible ();
       break;
     }
   return retval;
diff --git a/src/ifft.cc b/src/ifft.cc
--- a/src/ifft.cc
+++ b/src/ifft.cc
@@ -30,21 +30,21 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
 #include "f-ifft.h"
 
 #ifdef WITH_DLD
-tree_constant *
-builtin_ifft_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_ifft_2 (const Octave_object& args, int nargin, int nargout)
 {
-  tree_constant *retval = new tree_constant [2];
-  retval[0] = ifft (args[1]);
+  Octave_object retval (1);
+  retval(0) = ifft (args(1));
   return retval;
 }
 #endif
 
 tree_constant
 ifft (const tree_constant& a)
 {
   tree_constant retval;
diff --git a/src/inv.cc b/src/inv.cc
--- a/src/inv.cc
+++ b/src/inv.cc
@@ -30,21 +30,21 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
 #include "f-inv.h"
 
 #ifdef WITH_DLD
-tree_constant *
-builtin_inv_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_inv_2 (const Octave_object& args, int nargin, int nargout)
 {
-  tree_constant *retval = new tree_constant [2];
-  retval[0] = inverse (args[1]);
+  Octave_object retval (1);
+  retval(0) = inverse (args(1));
   return retval;
 }
 #endif
 
 tree_constant
 inverse (const tree_constant& a)
 {
   tree_constant retval;
diff --git a/src/lpsolve.cc b/src/lpsolve.cc
--- a/src/lpsolve.cc
+++ b/src/lpsolve.cc
@@ -1,12 +1,12 @@
 // f-lpsolve.cc                                          -*- C++ -*-
 /*
 
-Copyright (C) 1993 John W. Eaton
+Copyright (C) 1993, 1994 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -27,45 +27,45 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "LPsolve.h"
 
 #include "tree-const.h"
 #include "error.h"
 #include "f-lpsolve.h"
 
 #ifdef WITH_DLD
-tree_constant *
-builtin_lpsolve_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_lpsolve_2 (const Octave_object& args, int nargin, int nargout)
 {
   return lpsolve (args, nargin, nargout);
 }
 
-tree_constant *
-builtin_lpsolve_options_2 (const tree_constant *args, int nargin, int nargout) 
+Octave_object
+builtin_lpsolve_options_2 (const Octave_object& args, int nargin, int nargout) 
 {
   return lpsolve_options (args, nargin, nargout);
 }
 #endif
 
-tree_constant *
-lpsolve (const tree_constant *args, int nargin, int nargout)
+Octave_object
+lpsolve (const Octave_object& args, int nargin, int nargout)
 {
 // Assumes that we have been given the correct number of arguments.
 
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
   error ("lpsolve: not implemented yet");
   return retval;
 }
 
-tree_constant *
-lpsolve_options (const tree_constant *args, int nargin, int nargout)
+Octave_object
+lpsolve_options (const Octave_object& args, int nargin, int nargout)
 {
 // Assumes that we have been given the correct number of arguments.
 
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
   error ("lpsolve_options: not implemented yet");
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/src/lsode.cc b/src/lsode.cc
--- a/src/lsode.cc
+++ b/src/lsode.cc
@@ -36,108 +36,101 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "utils.h"
 #include "pager.h"
 #include "f-lsode.h"
 
 // Global pointer for user defined function required by lsode.
 static tree_fvc *lsode_fcn;
 
 #ifdef WITH_DLD
-tree_constant *
-builtin_lsode_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_lsode_2 (const Octave_object& args, int nargin, int nargout)
 {
   return lsode (args, nargin, nargout);
 }
 
-tree_constant *
-builtin_lsode_options_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_lsode_options_2 (const Octave_object& args, int nargin, int nargout)
 {
   return lsode_options (args, nargin, nargout);
 }
 #endif
 
 static ODE_options lsode_opts;
 
 ColumnVector
 lsode_user_function (const ColumnVector& x, double t)
 {
   ColumnVector retval;
 
   int nstates = x.capacity ();
 
 //  tree_constant name (lsode_fcn->name ());
-  tree_constant *args = new tree_constant [3];
-//  args[0] = name;
-  args[2] = tree_constant (t);
+  Octave_object args (3);
+//  args(0) = name;
+  args(2) = tree_constant (t);
 
   if (nstates > 1)
     {
       Matrix m (nstates, 1);
       for (int i = 0; i < nstates; i++)
 	m (i, 0) = x.elem (i);
       tree_constant state (m);
-      args[1] = state;
+      args(1) = state;
     }
   else
     {
       double d = x.elem (0);
       tree_constant state (d);
-      args[1] = state;
+      args(1) = state;
     }
 
   if (lsode_fcn != (tree_fvc *) NULL)
     {
-      tree_constant *tmp = lsode_fcn->eval (0, 1, args, 3);
-
-      delete [] args;
+      Octave_object tmp = lsode_fcn->eval (0, 1, args, 3);
 
       if (error_state)
 	{
 	  gripe_user_supplied_eval ("lsode");
 	  return retval;
 	}
 
-      if (tmp != NULL_TREE_CONST && tmp[0].is_defined ())
+      if (tmp.length () > 0 && tmp(0).is_defined ())
 	{
-	  retval = tmp[0].to_vector ();
-
-	  delete [] tmp;
+	  retval = tmp(0).to_vector ();
 
 	  if (retval.length () == 0)
 	    gripe_user_supplied_eval ("lsode");
 	}
       else
-	{
-	  delete [] tmp;
-	  gripe_user_supplied_eval ("lsode");
-	}
+	gripe_user_supplied_eval ("lsode");
     }
 
   return retval;
 }
 
-tree_constant *
-lsode (const tree_constant *args, int nargin, int nargout)
+Octave_object
+lsode (const Octave_object& args, int nargin, int nargout)
 {
 // Assumes that we have been given the correct number of arguments.
 
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
-  lsode_fcn = is_valid_function (args[1], "lsode", 1);
+  lsode_fcn = is_valid_function (args(1), "lsode", 1);
   if (lsode_fcn == (tree_fvc *) NULL
       || takes_correct_nargs (lsode_fcn, 3, "lsode", 1) != 1)
     return retval;
 
-  ColumnVector state = args[2].to_vector ();
-  ColumnVector out_times = args[3].to_vector ();
+  ColumnVector state = args(2).to_vector ();
+  ColumnVector out_times = args(3).to_vector ();
   ColumnVector crit_times;
   int crit_times_set = 0;
   if (nargin > 4)
     {
-      crit_times = args[4].to_vector ();
+      crit_times = args(4).to_vector ();
       crit_times_set = 1;
     }
 
   double tzero = out_times.elem (0);
   int nsteps = out_times.capacity ();
 
   ODEFunc func (lsode_user_function);
   ODE ode (state, tzero, func);
@@ -146,18 +139,18 @@ lsode (const tree_constant *args, int na
   int nstates = state.capacity ();
   Matrix output (nsteps, nstates + 1);
 
   if (crit_times_set)
     output = ode.integrate (out_times, crit_times);
   else
     output = ode.integrate (out_times);
 
-  retval = new tree_constant [2];
-  retval[0] = tree_constant (output);
+  retval.resize (1);
+  retval(0) = tree_constant (output);
   return retval;
 }
 
 typedef void (ODE_options::*d_set_opt_mf) (double);
 typedef double (ODE_options::*d_get_opt_mf) (void);
 
 #define MAX_TOKENS 3
 
@@ -166,17 +159,17 @@ struct ODE_OPTIONS
   char *keyword;
   char *kw_tok[MAX_TOKENS + 1];
   int min_len[MAX_TOKENS + 1];
   int min_toks_to_match;
   d_set_opt_mf d_set_fcn;
   d_get_opt_mf d_get_fcn;
 };
 
-static ODE_OPTIONS lsode_option_table[] =
+static ODE_OPTIONS lsode_option_table [] =
 {
   { "absolute tolerance",
     { "absolute", "tolerance", NULL, NULL, },
     { 1, 0, 0, 0, }, 1,
     ODE_options::set_absolute_tolerance,
     ODE_options::absolute_tolerance, },
 
   { "initial step size",
@@ -257,40 +250,36 @@ do_lsode_option (char *keyword, double v
 	  return;
 	}
       list++;
     }
 
   warning ("lsode_options: no match for `%s'", keyword);
 }
 
-tree_constant *
-lsode_options (const tree_constant *args, int nargin, int nargout)
+Octave_object
+lsode_options (const Octave_object& args, int nargin, int nargout)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
   if (nargin == 1)
-    {
-      print_lsode_option_list ();
-    }
+    print_lsode_option_list ();
   else if (nargin == 3)
     {
-      if (args[1].is_string_type ())
+      if (args(1).is_string_type ())
 	{
-	  char *keyword = args[1].string_value ();
-	  double val = args[2].double_value ();
+	  char *keyword = args(1).string_value ();
+	  double val = args(2).double_value ();
 	  do_lsode_option (keyword, val);
 	}
       else
 	print_usage ("lsode_options");
     }
   else
-    {
-      print_usage ("lsode_options");
-    }
+    print_usage ("lsode_options");
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/src/lu.cc b/src/lu.cc
--- a/src/lu.cc
+++ b/src/lu.cc
@@ -29,42 +29,41 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "CmplxLU.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "f-lu.h"
 
 #ifdef WITH_DLD
-tree_constant *
-builtin_lu_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_lu_2 (const Octave_object& args, int nargin, int nargout)
 {
-  return lu (args[1], nargout);
+  return lu (args(1), nargout);
 }
 #endif
 
-tree_constant *
+Octave_object
 lu (const tree_constant& a, int nargout)
 {
-  tree_constant *retval = new tree_constant [4];
+  Octave_object retval (3);
 
   tree_constant tmp = a.make_numeric ();;
     
   if (tmp.rows () == 0 || tmp.columns () == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
 	  if (flag < 0)
 	    gripe_empty_arg ("lu", 0);
 	  Matrix m;
-	  retval = new tree_constant [4];
-	  retval[0] = tree_constant (m);
-	  retval[1] = tree_constant (m);
-	  retval[2] = tree_constant (m);
+	  retval(0) = tree_constant (m);
+	  retval(1) = tree_constant (m);
+	  retval(2) = tree_constant (m);
 	  return retval;
 	}
       else
 	gripe_empty_arg ("lu", 1);
     }
 
   switch (tmp.const_type ())
     {
@@ -76,25 +75,25 @@ lu (const tree_constant& a, int nargout)
 	    LU fact (m);
 	    switch (nargout)
 	      {
 	      case 1:
 	      case 2:
 		{
 		  Matrix P = fact.P ();
 		  Matrix L = P.transpose () * fact.L ();
-		  retval[0] = tree_constant (L);
-		  retval[1] = tree_constant (fact.U ());
+		  retval(0) = tree_constant (L);
+		  retval(1) = tree_constant (fact.U ());
 		}
 		break;
 	      case 3:
 	      default:
-		retval[0] = tree_constant (fact.L ());
-		retval[1] = tree_constant (fact.U ());
-		retval[2] = tree_constant (fact.P ());
+		retval(0) = tree_constant (fact.L ());
+		retval(1) = tree_constant (fact.U ());
+		retval(2) = tree_constant (fact.P ());
 		break;
 	      }
 	  }
 	else
 	  gripe_square_matrix_required ("lu");
       }
       break;
     case tree_constant_rep::complex_matrix_constant:
@@ -105,46 +104,46 @@ lu (const tree_constant& a, int nargout)
 	    ComplexLU fact (m);
 	    switch (nargout)
 	      {
 	      case 1:
 	      case 2:
 		{
 		  ComplexMatrix P = fact.P ();
 		  ComplexMatrix L = P.transpose () * fact.L ();
-		  retval[0] = tree_constant (L);
-		  retval[1] = tree_constant (fact.U ());
+		  retval(0) = tree_constant (L);
+		  retval(1) = tree_constant (fact.U ());
 		}
 		break;
 	      case 3:
 	      default:
-		retval[0] = tree_constant (fact.L ());
-		retval[1] = tree_constant (fact.U ());
-		retval[2] = tree_constant (fact.P ());
+		retval(0) = tree_constant (fact.L ());
+		retval(1) = tree_constant (fact.U ());
+		retval(2) = tree_constant (fact.P ());
 		break;
 	      }
 	  }
 	else
 	  gripe_square_matrix_required ("lu");
       }
       break;
     case tree_constant_rep::scalar_constant:
       {
 	double d = tmp.double_value ();
-	retval[0] = tree_constant (1.0);
-	retval[1] = tree_constant (d);
-	retval[2] = tree_constant (1.0);
+	retval(0) = tree_constant (1.0);
+	retval(1) = tree_constant (d);
+	retval(2) = tree_constant (1.0);
       }
       break;
     case tree_constant_rep::complex_scalar_constant:
       {
 	Complex c = tmp.complex_value ();
-	retval[0] = tree_constant (1.0);
-	retval[1] = tree_constant (c);
-	retval[2] = tree_constant (1.0);
+	retval(0) = tree_constant (1.0);
+	retval(1) = tree_constant (c);
+	retval(2) = tree_constant (1.0);
       }
       break;
     default:
       break;
     }
   return retval;
 }
 
diff --git a/src/npsol.cc b/src/npsol.cc
--- a/src/npsol.cc
+++ b/src/npsol.cc
@@ -40,24 +40,24 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "utils.h"
 #include "f-npsol.h"
 
 // Global pointers for user defined functions required by npsol.
 static tree_fvc *npsol_objective;
 static tree_fvc *npsol_constraints;
 
 #ifdef WITH_DLD
-tree_constant *
-builtin_npsol_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_npsol_2 (const Octave_object& args, int nargin, int nargout)
 {
   return npsol (args, nargin, nargout);
 }
 
-tree_constant *
-builtin_npsol_options_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_npsol_options_2 (const Octave_object& args, int nargin, int nargout)
 {
   return npsol_options (args, nargin, nargout);
 }
 #endif
 
 static NPSOL_options npsol_opts;
 
 double
@@ -75,46 +75,39 @@ npsol_objective_function (const ColumnVe
     }
   else
     {
       double d = x.elem (0);
       decision_vars = tree_constant (d);
     }
 
 //  tree_constant name = tree_constant (npsol_objective->name ());
-  tree_constant *args = new tree_constant [2];
-//  args[0] = name;
-  args[1] = decision_vars;
+  Octave_object args (2);
+//  args(0) = name;
+  args(1) = decision_vars;
 
   static double retval;
   retval = 0.0;
 
   tree_constant objective_value;
   if (npsol_objective != (tree_fvc *) NULL)
     {
-      tree_constant *tmp = npsol_objective->eval (0, 1, args, 2);
-
-      delete [] args;
+      Octave_object tmp = npsol_objective->eval (0, 1, args, 2);
 
       if (error_state)
 	{
 	  error ("npsol: error evaluating objective function");
 	  npsol_objective_error = 1; // XXX FIXME XXX
-	  delete [] tmp;
 	  return retval;
 	}
 
-      if (tmp != NULL_TREE_CONST && tmp[0].is_defined ())
-	{
-	  objective_value = tmp[0];
-	  delete [] tmp;
-	}
+      if (tmp.length () > 0 && tmp(0).is_defined ())
+	objective_value = tmp(0);
       else
 	{
-	  delete [] tmp;
 	  error ("npsol: error evaluating objective function");
 	  npsol_objective_error = 1; // XXX FIXME XXX
 	  return retval;
 	}
     }
 
   switch (objective_value.const_type ())
     {
@@ -159,47 +152,39 @@ npsol_constraint_function (const ColumnV
     }
   else
     {
       double d = x.elem (0);
       decision_vars = tree_constant (d);
     }
 
 //  tree_constant name = tree_constant (npsol_constraints->name ());
-  tree_constant *args = new tree_constant [2];
-//  args[0] = name;
-  args[1] = decision_vars;
+  Octave_object args (2);
+//  args(0) = name;
+  args(1) = decision_vars;
 
   if (npsol_constraints != (tree_fvc *)NULL)
     {
-      tree_constant *tmp = npsol_constraints->eval (0, 1, args, 2);
-
-      delete [] args;
+      Octave_object tmp = npsol_constraints->eval (0, 1, args, 2);
 
       if (error_state)
 	{
-	  delete [] tmp;
 	  error ("npsol: error evaluating constraints");
 	  return retval;
 	}
 
-      if (tmp != NULL_TREE_CONST && tmp[0].is_defined ())
+      if (tmp.length () > 0 && tmp(0).is_defined ())
 	{
-	  retval = tmp[0].to_vector ();
-
-	  delete [] tmp;
+	  retval = tmp(0).to_vector ();
 
 	  if (retval.length () <= 0)
 	    error ("npsol: error evaluating constraints");
 	}
       else
-	{
-	  delete [] tmp;
-	  error ("npsol: error evaluating constraints");
-	}
+	error ("npsol: error evaluating constraints");
     }
 
   return retval;
 }
 
 int
 linear_constraints_ok (const ColumnVector& x, const ColumnVector& llb,
 		       const Matrix& c, const ColumnVector& lub,
@@ -255,18 +240,18 @@ nonlinear_constraints_ok (const ColumnVe
 	  ok = 0;
 	  error ("%s: nonlinear constraints have inconsistent dimensions",
 		 warn_for);
 	}
     }
   return ok;
 }
 
-tree_constant *
-npsol (const tree_constant *args, int nargin, int nargout)
+Octave_object
+npsol (const Octave_object& args, int nargin, int nargout)
 {
 /*
 
 Handle all of the following:
 
   1. npsol (x, phi)
   2. npsol (x, phi, lb, ub)
   3. npsol (x, phi, lb, ub, llb, c, lub)
@@ -275,40 +260,40 @@ Handle all of the following:
   6. npsol (x, phi,         llb, c, lub, nllb, g, nlub)
   7. npsol (x, phi,         llb, c, lub)
   8. npsol (x, phi,                      nllb, g, nlub)
 
 */
 
 // Assumes that we have been given the correct number of arguments.
 
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
-  ColumnVector x = args[1].to_vector ();
+  ColumnVector x = args(1).to_vector ();
 
   if (x.capacity () == 0)
     {
       error ("npsol: expecting vector as first argument");
       return retval;
     }
 
-  npsol_objective = is_valid_function (args[2], "npsol", 1);
+  npsol_objective = is_valid_function (args(2), "npsol", 1);
   if (npsol_objective == (tree_fvc *) NULL
       || takes_correct_nargs (npsol_objective, 2, "npsol", 1) != 1)
     return retval;
 
   Objective func (npsol_objective_function);
 
   ColumnVector soln;
 
   Bounds bounds;
   if (nargin == 5 || nargin == 8 || nargin == 11)
     {
-      ColumnVector lb = args[3].to_vector ();
-      ColumnVector ub = args[4].to_vector ();
+      ColumnVector lb = args(3).to_vector ();
+      ColumnVector ub = args(4).to_vector ();
 
       int lb_len = lb.capacity ();
       int ub_len = ub.capacity ();
       if (lb_len != ub_len || lb_len != x.capacity ())
 	{
 	  error ("npsol: lower and upper bounds and decision variable vector");
 	  error ("must all have the same number of elements");
 	  return retval;
@@ -342,25 +327,25 @@ Handle all of the following:
       nlp.copy (npsol_opts);
       soln = nlp.minimize (objf, inform, lambda);
 
       goto solved;
     }
 
   npsol_constraints = (tree_fvc *) NULL;
   if (nargin == 6 || nargin == 8 || nargin == 9 || nargin == 11)
-    npsol_constraints = is_valid_function (args[nargin-2], "npsol", 0);
+    npsol_constraints = is_valid_function (args(nargin-2), "npsol", 0);
 
   if (nargin == 8 || nargin == 6)
     {
       if (npsol_constraints == (tree_fvc *) NULL)
 	{
-	  ColumnVector lub = args[nargin-1].to_vector ();
-	  Matrix c = args[nargin-2].to_matrix ();
-	  ColumnVector llb = args[nargin-3].to_vector ();
+	  ColumnVector lub = args(nargin-1).to_vector ();
+	  Matrix c = args(nargin-2).to_matrix ();
+	  ColumnVector llb = args(nargin-3).to_vector ();
 
 	  if (llb.capacity () == 0 || lub.capacity () == 0)
 	    {
 	      error ("npsol: bounds for linear constraints must be vectors");
 	      return retval;
 	    }
 
 	  if (! linear_constraints_ok (x, llb, c, lub, "npsol", 1))
@@ -385,18 +370,18 @@ Handle all of the following:
 	      soln = nlp.minimize (objf, inform, lambda);
 	    }
 	  goto solved;
 	}
       else
 	{
 	  if (takes_correct_nargs (npsol_constraints, 2, "npsol", 1))
 	    {
-	      ColumnVector nlub = args[nargin-1].to_vector ();
-	      ColumnVector nllb = args[nargin-3].to_vector ();
+	      ColumnVector nlub = args(nargin-1).to_vector ();
+	      ColumnVector nllb = args(nargin-3).to_vector ();
 
 	      NLFunc const_func (npsol_constraint_function);
 
 	      if (! nonlinear_constraints_ok
 		  (x, nllb, npsol_constraint_function, nlub, "npsol", 1))
 		return retval;
 
 	      NLConst nonlinear_constraints (nllb, const_func, nlub);
@@ -422,36 +407,36 @@ Handle all of the following:
 	}
     }
 
   if (nargin == 9 || nargin == 11)
     {
       if (npsol_constraints == (tree_fvc *) NULL)
 	{
 	  // Produce error message.
-	  is_valid_function (args[nargin-2], "npsol", 1);
+	  is_valid_function (args(nargin-2), "npsol", 1);
 	}
       else
 	{
 	  if (takes_correct_nargs (npsol_constraints, 2, "npsol", 1))
 	    {
-	      ColumnVector nlub = args[nargin-1].to_vector ();
-	      ColumnVector nllb = args[nargin-3].to_vector ();
+	      ColumnVector nlub = args(nargin-1).to_vector ();
+	      ColumnVector nllb = args(nargin-3).to_vector ();
 
 	      NLFunc const_func (npsol_constraint_function);
 
 	      if (! nonlinear_constraints_ok
 		  (x, nllb, npsol_constraint_function, nlub, "npsol", 1))
 		return retval;
 
 	      NLConst nonlinear_constraints (nllb, const_func, nlub);
 
-	      ColumnVector lub = args[nargin-4].to_vector ();
-	      Matrix c = args[nargin-5].to_matrix ();
-	      ColumnVector llb = args[nargin-6].to_vector ();
+	      ColumnVector lub = args(nargin-4).to_vector ();
+	      Matrix c = args(nargin-5).to_matrix ();
+	      ColumnVector llb = args(nargin-6).to_vector ();
 
 	      if (llb.capacity () == 0 || lub.capacity () == 0)
 		{
 		  error ("npsol: bounds for linear constraints must be vectors");
 		  return retval;
 		}
 
 	      if (! linear_constraints_ok (x, llb, c, lub, "npsol", 1))
@@ -481,24 +466,24 @@ Handle all of the following:
 	    }
 	}
     }
 
   return retval;
 
  solved:
 
-  retval = new tree_constant [nargout+1];
-  retval[0] = tree_constant (soln, 1);
+  retval.resize (nargout ? nargout : 1);
+  retval(0) = tree_constant (soln, 1);
   if (nargout > 1)
-    retval[1] = tree_constant (objf);
+    retval(1) = tree_constant (objf);
   if (nargout > 2)
-    retval[2] = tree_constant ((double) inform);
+    retval(2) = tree_constant ((double) inform);
   if (nargout > 3)
-    retval[3] = tree_constant (lambda);
+    retval(3) = tree_constant (lambda);
 
   return retval;
 }
 
 typedef void (NPSOL_options::*d_set_opt_mf) (double);
 typedef void (NPSOL_options::*i_set_opt_mf) (int);
 typedef double (NPSOL_options::*d_get_opt_mf) (void);
 typedef int (NPSOL_options::*i_get_opt_mf) (void);
@@ -512,17 +497,17 @@ struct NPSOL_OPTIONS
   int min_len[MAX_TOKENS + 1];
   int min_toks_to_match;
   d_set_opt_mf d_set_fcn;
   i_set_opt_mf i_set_fcn;
   d_get_opt_mf d_get_fcn;
   i_get_opt_mf i_get_fcn;
 };
 
-static NPSOL_OPTIONS npsol_option_table[] =
+static NPSOL_OPTIONS npsol_option_table [] =
 {
   { "central difference interval",
     { "central", "difference", "interval", NULL, NULL, NULL, },
     { 2, 0, 0, 0, 0, 0, }, 1,
     NPSOL_options::set_central_difference_interval, NULL,
     NPSOL_options::central_difference_interval, NULL, },
 
   { "crash tolerance",
@@ -705,31 +690,31 @@ do_npsol_option (char *keyword, double v
 	  return;
 	}
       list++;
     }
 
   warning ("npsol_options: no match for `%s'", keyword);
 }
 
-tree_constant *
-npsol_options (const tree_constant *args, int nargin, int nargout)
+Octave_object
+npsol_options (const Octave_object& args, int nargin, int nargout)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
   if (nargin == 1)
     {
       print_npsol_option_list ();
     }
   else if (nargin == 3)
     {
-      if (args[1].is_string_type ())
+      if (args(1).is_string_type ())
 	{
-	  char *keyword = args[1].string_value ();
-	  double val = args[2].double_value ();
+	  char *keyword = args(1).string_value ();
+	  double val = args(2).double_value ();
 	  do_npsol_option (keyword, val);
 	}
       else
 	print_usage ("npsol_options");
     }
   else
     {
       print_usage ("npsol_options");
diff --git a/src/qpsol.cc b/src/qpsol.cc
--- a/src/qpsol.cc
+++ b/src/qpsol.cc
@@ -42,75 +42,75 @@ Software Foundation, 675 Mass Ave, Cambr
 // This should probably be defined in some shared file and declared in
 // a header file...
 extern int linear_constraints_ok (const ColumnVector& x,
 				  const ColumnVector& llb, const Matrix& c,
 				  const ColumnVector& lub, char *warn_for,
 				  int warn);
 
 #ifdef WITH_DLD
-tree_constant *
-builtin_qpsol_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_qpsol_2 (const Octave_object& args, int nargin, int nargout)
 {
   return qpsol (args, nargin, nargout);
 }
 
-tree_constant *
-builtin_qpsol_options_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_qpsol_options_2 (const Octave_object& args, int nargin, int nargout)
 {
   return qpsol_options (args, nargin, nargout);
 }
 #endif
 
 static QPSOL_options qpsol_opts;
 
-tree_constant *
-qpsol (const tree_constant *args, int nargin, int nargout)
+Octave_object
+qpsol (const Octave_object& args, int nargin, int nargout)
 {
 /*
 
 Handle all of the following:
 
   1. qpsol (x, H, c)
   2. qpsol (x, H, c, lb, ub)
   3. qpsol (x, H, c, lb, ub, llb, A, lub)
   4. qpsol (x, H, c,         llb, A, lub)
 
 */
 
 // Assumes that we have been given the correct number of arguments.
 
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
-  ColumnVector x = args[1].to_vector ();
+  ColumnVector x = args(1).to_vector ();
   if (x.capacity () == 0)
     {
       error ("qpsol: expecting vector as first argument");
       return retval;
     }
 
-  Matrix H = args[2].to_matrix ();
+  Matrix H = args(2).to_matrix ();
   if (H.rows () != H.columns () || H.rows () != x.capacity ())
     {
       error ("qpsol: H must be a square matrix consistent with the size of x");
       return retval;
     }
 
-  ColumnVector c = args[3].to_vector ();
+  ColumnVector c = args(3).to_vector ();
   if (c.capacity () != x.capacity ())
     {
       error ("qpsol: c must be a vector the same size as x");
       return retval;
     }
 
   Bounds bounds;
   if (nargin == 6 || nargin == 9)
     {
-      ColumnVector lb = args[4].to_vector ();
-      ColumnVector ub = args[5].to_vector ();
+      ColumnVector lb = args(4).to_vector ();
+      ColumnVector ub = args(5).to_vector ();
 
       int lb_len = lb.capacity ();
       int ub_len = ub.capacity ();
       if (lb_len != ub_len || lb_len != x.capacity ())
 	{
 	  error ("qpsol: lower and upper bounds and decision variable vector");
 	  error ("must all have the same number of elements");
 	  return retval;
@@ -145,19 +145,19 @@ Handle all of the following:
       qp.copy (qpsol_opts);
       soln = qp.minimize (objf, inform, lambda);
 
       goto solved;
     }
 
   if (nargin == 7 || nargin == 9)
     {
-      ColumnVector lub = args[nargin-1].to_vector ();
-      Matrix A = args[nargin-2].to_matrix ();
-      ColumnVector llb = args[nargin-3].to_vector ();
+      ColumnVector lub = args(nargin-1).to_vector ();
+      Matrix A = args(nargin-2).to_matrix ();
+      ColumnVector llb = args(nargin-3).to_vector ();
 
       if (llb.capacity () == 0 || lub.capacity () == 0)
 	{
 	  error ("qpsol: bounds for linear constraints must be vectors");
 	  return retval;
 	}
 
       if (! linear_constraints_ok (x, llb, A, lub, "qpsol", 1))
@@ -183,24 +183,24 @@ Handle all of the following:
        }
       goto solved;
     }
 
   return retval;
 
  solved:
 
-  retval = new tree_constant [nargout+1];
-  retval[0] = tree_constant (soln, 1);
+  retval.resize (nargout ? nargout : 1);
+  retval(0) = tree_constant (soln, 1);
   if (nargout > 1)
-    retval[1] = tree_constant (objf);
+    retval(1) = tree_constant (objf);
   if (nargout > 2)
-    retval[2] = tree_constant ((double) inform);
+    retval(2) = tree_constant ((double) inform);
   if (nargout > 3)
-    retval[3] = tree_constant (lambda);
+    retval(3) = tree_constant (lambda);
 
   return retval;
 }
 
 typedef void (QPSOL_options::*d_set_opt_mf) (double);
 typedef void (QPSOL_options::*i_set_opt_mf) (int);
 typedef double (QPSOL_options::*d_get_opt_mf) (void);
 typedef int (QPSOL_options::*i_get_opt_mf) (void);
@@ -214,17 +214,17 @@ struct QPSOL_OPTIONS
   int min_len[MAX_TOKENS + 1];
   int min_toks_to_match;
   d_set_opt_mf d_set_fcn;
   i_set_opt_mf i_set_fcn;
   d_get_opt_mf d_get_fcn;
   i_get_opt_mf i_get_fcn;
 };
 
-static QPSOL_OPTIONS qpsol_option_table[] =
+static QPSOL_OPTIONS qpsol_option_table [] =
 {
   { "feasibility tolerance",
     { "feasibility", "tolerance", NULL, },
     { 1, 0, 0, }, 1,
     QPSOL_options::set_feasibility_tolerance, NULL,
     QPSOL_options::feasibility_tolerance, NULL, },
 
   { "infinite bound",
@@ -311,31 +311,31 @@ do_qpsol_option (char *keyword, double v
 	  return;
 	}
       list++;
     }
 
   warning ("qpsol_options: no match for `%s'", keyword);
 }
 
-tree_constant *
-qpsol_options (const tree_constant *args, int nargin, int nargout)
+Octave_object
+qpsol_options (const Octave_object& args, int nargin, int nargout)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
   if (nargin == 1)
     {
       print_qpsol_option_list ();
     }
   else if (nargin == 3)
     {
-      if (args[1].is_string_type ())
+      if (args(1).is_string_type ())
 	{
-	  char *keyword = args[1].string_value ();
-	  double val = args[2].double_value ();
+	  char *keyword = args(1).string_value ();
+	  double val = args(2).double_value ();
 	  do_qpsol_option (keyword, val);
 	}
       else
 	print_usage ("qpsol_options");
     }
   else
     {
       print_usage ("qpsol_options");
diff --git a/src/qr.cc b/src/qr.cc
--- a/src/qr.cc
+++ b/src/qr.cc
@@ -29,81 +29,80 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "CmplxQR.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "f-qr.h"
 
 #ifdef WITH_DLD
-tree_constant *
-builtin_qr_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_qr_2 (const Octave_object& args, int nargin, int nargout)
 {
-  return qr (args[1], nargout);
+  return qr (args(1), nargout);
 }
 #endif
 
-tree_constant *
+Octave_object
 qr (const tree_constant& a, int nargout)
 {
-  tree_constant *retval = new tree_constant [3];
+  Octave_object retval (2);
 
   tree_constant tmp = a.make_numeric ();;
     
   int nr = tmp.rows ();
   int nc = tmp.columns ();
 
   if (nr == 0 || nc == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
 	  if (flag < 0)
 	    gripe_empty_arg ("qr", 0);
 	  Matrix m;
-	  retval = new tree_constant [3];
-	  retval[0] = tree_constant (m);
-	  retval[1] = tree_constant (m);
+	  retval(0) = tree_constant (m);
+	  retval(1) = tree_constant (m);
 	}
       else
 	gripe_empty_arg ("qr", 1);
 
       return retval;
     }
 
   switch (tmp.const_type ())
     {
     case tree_constant_rep::matrix_constant:
       {
 	Matrix m = tmp.matrix_value ();
 	QR fact (m);
-	retval[0] = tree_constant (fact.Q ());
-	retval[1] = tree_constant (fact.R ());
+	retval(0) = tree_constant (fact.Q ());
+	retval(1) = tree_constant (fact.R ());
       }
       break;
     case tree_constant_rep::complex_matrix_constant:
       {
 	ComplexMatrix m = tmp.complex_matrix_value ();
 	ComplexQR fact (m);
-	retval[0] = tree_constant (fact.Q ());
-	retval[1] = tree_constant (fact.R ());
+	retval(0) = tree_constant (fact.Q ());
+	retval(1) = tree_constant (fact.R ());
       }
       break;
     case tree_constant_rep::scalar_constant:
       {
 	double d = tmp.double_value ();
-	retval[0] = tree_constant (1.0);
-	retval[1] = tree_constant (d);
+	retval(0) = tree_constant (1.0);
+	retval(1) = tree_constant (d);
       }
       break;
     case tree_constant_rep::complex_scalar_constant:
       {
 	Complex c = tmp.complex_value ();
-	retval[0] = tree_constant (1.0);
-	retval[1] = tree_constant (c);
+	retval(0) = tree_constant (1.0);
+	retval(1) = tree_constant (c);
       }
       break;
     default:
       break;
     }
   return retval;
 }
 
diff --git a/src/quad.cc b/src/quad.cc
--- a/src/quad.cc
+++ b/src/quad.cc
@@ -37,85 +37,78 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "utils.h"
 #include "pager.h"
 #include "f-quad.h"
 
 // Global pointer for user defined function required by quadrature functions.
 static tree_fvc *quad_fcn;
 
 #ifdef WITH_DLD
-tree_constant *
-builtin_quad_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_quad_2 (const Octave_object& args, int nargin, int nargout)
 {
   return do_quad (args, nargin, nargout);
 }
 
-tree_constant *
-builtin_quad_options_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_quad_options_2 (const Octave_object& args, int nargin, int nargout)
 {
   return quad_options (args, nargin, nargout);
 }
 #endif
 
 static Quad_options quad_opts;
 
 double
 quad_user_function (double x)
 {
   double retval = 0.0;
 
 //  tree_constant name = tree_constant (quad_fcn->name ());
-  tree_constant *args = new tree_constant [2];
-//  args[0] = name;
-  args[1] = tree_constant (x);
+  Octave_object args (2);
+//  args(0) = name;
+  args(1) = tree_constant (x);
 
   if (quad_fcn != (tree_fvc *) NULL)
     {
-      tree_constant *tmp = quad_fcn->eval (0, 1, args, 2);
-
-      delete [] args;
+      Octave_object tmp = quad_fcn->eval (0, 1, args, 2);
 
       if (error_state)
 	{
-	  delete [] tmp;
 	  quad_integration_error = 1;  // XXX FIXME XXX
 	  gripe_user_supplied_eval ("quad");
 	  return retval;
 	}
 
-      if (tmp != NULL_TREE_CONST && tmp[0].is_defined ())
-	{
-	  retval = tmp[0].to_scalar ();
-	  delete [] tmp;
-	}
+      if (tmp.length () && tmp(0).is_defined ())
+	retval = tmp(0).to_scalar ();
       else
 	{
-	  delete [] tmp;
 	  quad_integration_error = 1;  // XXX FIXME XXX
 	  gripe_user_supplied_eval ("quad");
 	}
     }
 
   return retval;
 }
 
-tree_constant *
-do_quad (const tree_constant *args, int nargin, int nargout)
+Octave_object
+do_quad (const Octave_object& args, int nargin, int nargout)
 {
 // Assumes that we have been given the correct number of arguments.
 
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
-  quad_fcn = is_valid_function (args[1], "fsolve", 1);
+  quad_fcn = is_valid_function (args(1), "fsolve", 1);
   if (quad_fcn == (tree_fvc *) NULL
       || takes_correct_nargs (quad_fcn, 2, "fsolve", 1) != 1)
     return retval;
 
-  double a = args[2].to_scalar ();
-  double b = args[3].to_scalar ();
+  double a = args(2).to_scalar ();
+  double b = args(3).to_scalar ();
 
   int indefinite = 0;
   IndefQuad::IntegralType indef_type = IndefQuad::doubly_infinite;
   double bound = 0.0;
   if ((int) xisinf (a) && (int) xisinf (b))
     {
       indefinite = 1;
       indef_type = IndefQuad::doubly_infinite;
@@ -146,19 +139,19 @@ do_quad (const tree_constant *args, int 
     {
     case 6:
       if (indefinite)
 	{
 	  error("quad: singularities not allowed on infinite intervals");
 	  return retval;
 	}
       have_sing = 1;
-      sing = args[5].to_vector ();
+      sing = args(5).to_vector ();
     case 5:
-      tol = args[4].to_vector ();
+      tol = args(4).to_vector ();
       switch (tol.capacity ())
 	{
 	case 2:
 	  reltol = tol.elem (1);
 	case 1:
 	  abstol = tol.elem (0);
 	  break;
 	default:
@@ -188,22 +181,22 @@ do_quad (const tree_constant *args, int 
 	    }
 	}
       break;
     default:
       panic_impossible ();
       break;
     }
 
-  retval = new tree_constant [5];
+  retval.resize (4);
 
-  retval[0] = tree_constant (val);
-  retval[1] = tree_constant ((double) ier);
-  retval[2] = tree_constant ((double) nfun);
-  retval[3] = tree_constant (abserr);
+  retval(0) = tree_constant (val);
+  retval(1) = tree_constant ((double) ier);
+  retval(2) = tree_constant ((double) nfun);
+  retval(3) = tree_constant (abserr);
 
   return retval;
 }
 
 typedef void (Quad_options::*d_set_opt_mf) (double);
 typedef double (Quad_options::*d_get_opt_mf) (void);
 
 #define MAX_TOKENS 2
@@ -213,17 +206,17 @@ struct QUAD_OPTIONS
   char *keyword;
   char *kw_tok[MAX_TOKENS + 1];
   int min_len[MAX_TOKENS + 1];
   int min_toks_to_match;
   d_set_opt_mf d_set_fcn;
   d_get_opt_mf d_get_fcn;
 };
 
-static QUAD_OPTIONS quad_option_table[] =
+static QUAD_OPTIONS quad_option_table [] =
 {
   { "absolute tolerance",
     { "absolute", "tolerance", NULL, },
     { 1, 0, 0, }, 1,
     Quad_options::set_absolute_tolerance,
     Quad_options::absolute_tolerance, },
 
   { "relative tolerance",
@@ -286,40 +279,36 @@ do_quad_option (char *keyword, double va
 	  return;
 	}
       list++;
     }
 
   warning ("quad_options: no match for `%s'", keyword);
 }
 
-tree_constant *
-quad_options (const tree_constant *args, int nargin, int nargout)
+Octave_object
+quad_options (const Octave_object& args, int nargin, int nargout)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
   if (nargin == 1)
-    {
-      print_quad_option_list ();
-    }
+    print_quad_option_list ();
   else if (nargin == 3)
     {
-      if (args[1].is_string_type ())
+      if (args(1).is_string_type ())
 	{
-	  char *keyword = args[1].string_value ();
-	  double val = args[2].double_value ();
+	  char *keyword = args(1).string_value ();
+	  double val = args(2).double_value ();
 	  do_quad_option (keyword, val);
 	}
       else
 	print_usage ("quad_options");
     }
   else
-    {
-      print_usage ("quad_options");
-    }
+    print_usage ("quad_options");
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/src/qzval.cc b/src/qzval.cc
--- a/src/qzval.cc
+++ b/src/qzval.cc
@@ -48,30 +48,30 @@ extern "C"
   int F77_FCN (qzit) (const int*, const int*, double*, double*, const
 		      double*, const long*, double*, int*);
  
   int F77_FCN (qzval) (const int*, const int*, double*, double*,
 		       double*, double*, double*, const long*, double*);
 }
 
 #ifdef WITH_DLD
-tree_constant *
-builtin_qzvalue_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_qzvalue_2 (const Octave_object& args, int nargin, int nargout)
 {
   return qzvalue (args, nargin, nargout);
 }
 #endif
 
-tree_constant *
-qzvalue (const tree_constant *args, int nargin, int nargout)
+Octave_object
+qzvalue (const Octave_object& args, int nargin, int nargout)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
-  tree_constant arga = args[1].make_numeric ();
-  tree_constant argb = args[2].make_numeric();
+  tree_constant arga = args(1).make_numeric ();
+  tree_constant argb = args(2).make_numeric();
 
   if (arga.is_empty () || argb.is_empty ())
     retval = vector_of_empties (nargout, "qzvalue");
   else
     {
 
 // Arguments are not empty, so check for correct dimensions.
 
@@ -88,17 +88,17 @@ qzvalue (const tree_constant *args, int 
       else if (a_rows != b_rows)
 	{
 	  gripe_nonconformant ();
 	  return retval;
 	}
   
 // Dimensions look o.k., let's solve the problem.
 
-      retval = new tree_constant[nargout+1];
+      retval.resize (nargout ? nargout : 1);
 
       if (arga.is_complex_type () || argb.is_complex_type ())
 	error ("qzvalue: cannot yet do complex matrix arguments\n");
       else
 	{
 
 // Do everything in real arithmetic.
 
@@ -150,17 +150,17 @@ qzvalue (const tree_constant *args, int 
 		{
 
 // Finite generalized eigenvalue.
 
 		  cnt--;
 		  cx (cnt) = (alfr (i) + Im * alfi (i)) / beta (i);
 		}
 	    }
-	  retval[0] = tree_constant (cx);
+	  retval(0)                          = tree_constant (cx);
 	}
     }
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/rand.cc b/src/rand.cc
--- a/src/rand.cc
+++ b/src/rand.cc
@@ -1,12 +1,12 @@
 // f-rand.cc                                           -*- C++ -*-
 /*
 
-Copyright (C) 1993 John W. Eaton
+Copyright (C) 1993, 1994 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -41,18 +41,18 @@ extern "C"
 {
   int *F77_FCN (dgennor) (double*, double*, double*);
   int *F77_FCN (dgenunf) (double*, double*, double*);
   int *F77_FCN (setall) (int*, int*);
   int *F77_FCN (getsd) (int*, int*);
 }
 
 #ifdef WITH_DLD
-tree_constant *
-builtin_rand_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_rand_2 (const Octave_object& args, int nargin, int nargout)
 {
   return rand_internal (args, nargin, nargout);
 }
 #endif
 
 static double
 curr_rand_seed (void)
 {
@@ -97,22 +97,22 @@ curr_rand_dist (void)
     return "normal";
   else
     {
       panic_impossible ();
       return (char *) NULL;
     }
 }
 
-tree_constant *
-rand_internal (const tree_constant *args, int nargin, int nargout)
+Octave_object
+rand_internal (const Octave_object& args, int nargin, int nargout)
 {
 // Assumes that we have been given the correct number of arguments.
 
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
   static int initialized = 0;
   if (! initialized)
     {
 // Make the random number generator give us a different sequence every
 // time we start octave unless we specifically set the seed.
 #if 0
       int s0 = 1234567890;
@@ -139,94 +139,90 @@ rand_internal (const tree_constant *args
   if (nargin == 1)
     {
       n = 1;
       m = 1;
       goto gen_matrix;
     }
   else if (nargin == 2)
     {
-      switch (args[1].const_type ())
+      switch (args(1).const_type ())
 	{
 	case tree_constant_rep::string_constant:
-	  char *s_arg = args[1].string_value ();
+	  char *s_arg = args(1).string_value ();
 	  if (strcmp (s_arg, "dist") == 0)
 	    {
-	      retval = new tree_constant [2];
+	      retval.resize (1);
 	      char *s = curr_rand_dist ();
-	      retval[0] = tree_constant (s);
+	      retval(0) = tree_constant (s);
 	    }
 	  else if (strcmp (s_arg, "seed") == 0)
 	    {
-	      retval = new tree_constant [2];
+	      retval.resize (1);
 	      double d = curr_rand_seed ();
-	      retval[0] = tree_constant (d);
+	      retval(0) = tree_constant (d);
 	    }
 	  else if (strcmp (s_arg, "uniform") == 0)
 	    current_distribution = uniform;
 	  else if (strcmp (s_arg, "normal") == 0)
 	    current_distribution = normal;
 	  else
-	    {
-	      delete [] retval;
-	      retval = NULL_TREE_CONST;
-	      error ("rand: unrecognized string argument");
-	    }
+	    error ("rand: unrecognized string argument");
 	  break;
 	case tree_constant_rep::scalar_constant:
 	case tree_constant_rep::complex_scalar_constant:
-	  n = NINT (args[1].double_value ());
+	  n = NINT (args(1).double_value ());
 	  m = n;
 	  goto gen_matrix;
 	case tree_constant_rep::range_constant:
 	  {
-	    Range r = args[1].range_value ();
+	    Range r = args(1).range_value ();
 	    n = 1;
 	    m = NINT (r.nelem ());
 	  }
 	  goto gen_matrix;
 	case tree_constant_rep::matrix_constant:
 	case tree_constant_rep::complex_matrix_constant:
-	  n = NINT (args[1].rows ());
-	  m = NINT (args[1].columns ());
+	  n = NINT (args(1).rows ());
+	  m = NINT (args(1).columns ());
 	  goto gen_matrix;
 	default:
 	  panic_impossible ();
 	  break;
 	}
     }
   else if (nargin == 3)
     {
-      if (args[1].is_string_type ()
-	  && strcmp (args[1].string_value (), "seed") == 0)
+      if (args(1).is_string_type ()
+	  && strcmp (args(1).string_value (), "seed") == 0)
 	{
-	  double d = args[2].to_scalar ();
+	  double d = args(2).to_scalar ();
 	  set_rand_seed (d);
 	}
       else
 	{
-	  n = NINT (args[1].to_scalar ());
-	  m = NINT (args[2].to_scalar ());
+	  n = NINT (args(1).to_scalar ());
+	  m = NINT (args(2).to_scalar ());
 	  goto gen_matrix;
 	}
     }
 
   return retval;
 
  gen_matrix:
 
   if (n == 0 || m == 0)
     {
-      retval = new tree_constant [2];
+      retval.resize (1);
       Matrix m (0, 0);
-      retval[0] = tree_constant (m);
+      retval(0) = tree_constant (m);
     }
   else if (n > 0 && m > 0)
     {
-      retval = new tree_constant [2];
+      retval.resize (1);
       Matrix rand_mat (n, m);
       for (int j = 0; j < m; j++)
 	for (int i = 0; i < n; i++)
 	  {
 	    double d_zero = 0.0;
 	    double d_one = 1.0;
 	    double val;
 	    switch (current_distribution)
@@ -240,17 +236,17 @@ rand_internal (const tree_constant *args
 		rand_mat.elem (i, j) = val;
 		break;
 	      default:
 		panic_impossible ();
 		break;
 	      }
 	  }
 
-      retval[0] = tree_constant (rand_mat);
+      retval(0)   = tree_constant (rand_mat);
     }
   else
     error ("rand: invalid negative argument");
 
   return retval;
 }
 
 /*
diff --git a/src/schur.cc b/src/schur.cc
--- a/src/schur.cc
+++ b/src/schur.cc
@@ -30,60 +30,60 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "error.h"
 #include "gripes.h"
 #include "f-schur.h"
 
 #ifdef WITH_DLD
-tree_constant *
-builtin_schur_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_schur_2 (const Octave_object& args, int nargin, int nargout)
 {
   return schur (args, nargin, nargout);
 }
 #endif
 
-tree_constant *
-schur (const tree_constant *args, int nargin, int nargout)
+Octave_object
+schur (const Octave_object& args, int nargin, int nargout)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
-  tree_constant arg = args[1].make_numeric ();
+  tree_constant arg = args(1).make_numeric ();
 
   char *ord;
   if (nargin != 3)
     ord = "U";
   else
-    ord = args[2].string_value ();
+    ord = args(2).string_value ();
 
   if (*ord != 'U' && *ord != 'A' && *ord != 'D'
       && *ord != 'u' && *ord != 'a' && *ord != 'd')
     {
       warning ("schur: incorrect ordered schur argument `%c'", *ord);
       Matrix m;
-      retval = new tree_constant [3];
-      retval[0] = tree_constant (m);
-      retval[1] = tree_constant (m);
+      retval.resize (2);
+      retval(0) = tree_constant (m);
+      retval(1) = tree_constant (m);
       return retval;
     }
   int a_nr = arg.rows ();
   int a_nc = arg.columns ();
 
   if (a_nr == 0 || a_nc == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
         {
           if (flag < 0)
             warning ("schur: argument is empty matrix");
           Matrix m;
-          retval = new tree_constant [3];
-          retval[0] = tree_constant (m);
-          retval[1] = tree_constant (m);
+          retval.resize (2);
+          retval(0) = tree_constant (m);
+          retval(1) = tree_constant (m);
         }
       else
         error ("schur: empty matrix is invalid as argument");
 
       return retval;
     }
   if (a_nr != a_nc)
     {
@@ -97,77 +97,77 @@ schur (const tree_constant *args, int na
   switch (arg.const_type ())
     {
     case tree_constant_rep::matrix_constant:
       {
 	tmp = arg.matrix_value ();
 
 	SCHUR result (tmp,ord);
 
-        if (nargout == 1)
+        if (nargout == 0 || nargout == 1)
           {
-            retval = new tree_constant [2];
-            retval[0] = tree_constant (result.schur_matrix ());
+            retval.resize (1);
+            retval(0) = tree_constant (result.schur_matrix ());
           }
         else
           {
-            retval = new tree_constant [3];
-            retval[0] = tree_constant (result.unitary_matrix ());
-            retval[1] = tree_constant (result.schur_matrix ());
+            retval.resize (2);
+            retval(0) = tree_constant (result.unitary_matrix ());
+            retval(1) = tree_constant (result.schur_matrix ());
           }
       }
       break;
     case tree_constant_rep::complex_matrix_constant:
       {
 	ctmp = arg.complex_matrix_value ();
 
         ComplexSCHUR result (ctmp,ord);
  
-        if (nargout == 1)
+        if (nargout == 0 || nargout == 1)
           {
-            retval = new tree_constant [2];
-            retval[0] = tree_constant (result.schur_matrix ());
+            retval.resize (1);
+            retval(0) = tree_constant (result.schur_matrix ());
           }
         else
           {
-            retval = new tree_constant [3];
-            retval[0] = tree_constant (result.unitary_matrix ());
-            retval[1] = tree_constant (result.schur_matrix ());
+            retval.resize (2);
+            retval(0) = tree_constant (result.unitary_matrix ());
+            retval(1) = tree_constant (result.schur_matrix ());
           }
       }    
       break;
     case tree_constant_rep::scalar_constant:
       {
         double d = arg.double_value ();
-        if (nargout == 1)
+        if (nargout == 0 || nargout == 1)
   	  {
-	    retval = new tree_constant [2];
-            retval[0] = tree_constant (d);
+	    retval.resize (1);
+            retval(0) = tree_constant (d);
           }
         else
 	  {
-	    retval = new tree_constant [3];
-	    retval[0] = tree_constant (1);
-	    retval[1] = tree_constant (d);
+	    retval.resize (2);
+	    retval(0) = tree_constant (1);
+	    retval(1) = tree_constant (d);
   	  }
       }
       break;
     case tree_constant_rep::complex_scalar_constant:
       {
         Complex c = arg.complex_value ();
-	if (nargout == 1)
+	if (nargout == 0 || nargout == 1)
 	  {
-	    retval = new tree_constant [2];
-	    retval[0] = tree_constant (c);
+	    retval.resize (1);
+	    retval(0) = tree_constant (c);
 	  }
 	else
 	  {
-	    retval = new tree_constant [3];
-	    retval[0] = tree_constant (1);
-	    retval[1] = tree_constant (c);
+	    retval.resize (2);
+	    retval(0) = tree_constant (1);
+	    retval(1) = tree_constant (c);
 	  }
       }
       break;
     default:
       panic_impossible ();
       break;    
     }
  
diff --git a/src/svd.cc b/src/svd.cc
--- a/src/svd.cc
+++ b/src/svd.cc
@@ -30,42 +30,42 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
 #include "f-svd.h"
 
 #ifdef WITH_DLD
-tree_constant *
-builtin_svd_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_svd_2 (const Octave_object& args, int nargin, int nargout)
 {
   return svd (args, nargin, nargout);
 }
 #endif
 
-tree_constant *
-svd (const tree_constant *args, int nargin, int nargout)
+Octave_object
+svd (const Octave_object& args, int nargin, int nargout)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
-  tree_constant arg = args[1].make_numeric ();
+  tree_constant arg = args(1).make_numeric ();
 
   if (arg.rows () == 0 || arg.columns () == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
 	  if (flag < 0)
 	    gripe_empty_arg ("svd", 0);
 	  Matrix m;
-	  retval = new tree_constant [4];
-	  retval[0] = tree_constant (m);
-	  retval[1] = tree_constant (m);
-	  retval[2] = tree_constant (m);
+	  retval.resize (3);
+	  retval(0) = tree_constant (m);
+	  retval(1) = tree_constant (m);
+	  retval(2) = tree_constant (m);
 	}
       else
 	gripe_empty_arg ("svd", 1);
 
       return retval;
     }
 
   Matrix tmp;
@@ -95,48 +95,48 @@ svd (const tree_constant *args, int narg
     {
     case tree_constant_rep::scalar_constant:
     case tree_constant_rep::matrix_constant:
       {
 	SVD result (tmp);
 
 	DiagMatrix sigma = result.singular_values ();
 
-	if (nargout == 1)
+	if (nargout == 0 || nargout == 1)
 	  {
-	    retval = new tree_constant [2];
-	    retval[0] = tree_constant (sigma.diag (), 1);
+	    retval.resize (1);
+	    retval(0) = tree_constant (sigma.diag (), 1);
 	  }
 	else
 	  {
-	    retval = new tree_constant [4];
-	    retval[0] = tree_constant (result.left_singular_matrix ());
-	    retval[1] = tree_constant (sigma);
-	    retval[2] = tree_constant (result.right_singular_matrix ());
+	    retval.resize (3);
+	    retval(0) = tree_constant (result.left_singular_matrix ());
+	    retval(1) = tree_constant (sigma);
+	    retval(2) = tree_constant (result.right_singular_matrix ());
 	  }
       }
       break;
     case tree_constant_rep::complex_scalar_constant:
     case tree_constant_rep::complex_matrix_constant:
       {
 	ComplexSVD result (ctmp);
 
 	DiagMatrix sigma = result.singular_values ();
 
-	if (nargout == 1)
+	if (nargout == 0 || nargout == 1)
 	  {
-	    retval = new tree_constant [2];
-	    retval[0] = tree_constant (sigma.diag (), 1);
+	    retval.resize (1);
+	    retval(0) = tree_constant (sigma.diag (), 1);
 	  }
 	else
 	  {
-	    retval = new tree_constant [4];
-	    retval[0] = tree_constant (result.left_singular_matrix ());
-	    retval[1] = tree_constant (sigma);
-	    retval[2] = tree_constant (result.right_singular_matrix ());
+	    retval.resize (3);
+	    retval(0) = tree_constant (result.left_singular_matrix ());
+	    retval(1) = tree_constant (sigma);
+	    retval(2) = tree_constant (result.right_singular_matrix ());
 	  }
       }
       break;
     default:
       panic_impossible ();
       break;
     }
 
diff --git a/src/syl.cc b/src/syl.cc
--- a/src/syl.cc
+++ b/src/syl.cc
@@ -50,31 +50,31 @@ extern "C"
   int F77_FCN (ztrsyl) (const char*, const char*, const int*,
 			const int*, const int*, const Complex*,
 			const int*, const Complex*, const int*,
 			const Complex*, const int*, double*, int*,
 			long, long);
 }
 
 #ifdef WITH_DLD
-tree_constant *
-builtin_syl_2 (const tree_constant *args, int nargin, int nargout)
+Octave_object
+builtin_syl_2 (const Octave_object& args, int nargin, int nargout)
 {
   return syl (args, nargin, nargout);
 }
 #endif
 
-tree_constant *
-syl (const tree_constant *args, int nargin, int nargout)
+Octave_object
+syl (const Octave_object& args, int nargin, int nargout)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
-  tree_constant arga = args[1].make_numeric ();
-  tree_constant argb = args[2].make_numeric ();
-  tree_constant argc = args[3].make_numeric ();
+  tree_constant arga = args(1).make_numeric ();
+  tree_constant argb = args(2).make_numeric ();
+  tree_constant argc = args(3).make_numeric ();
 
   if (arga.is_empty () || argb.is_empty () || argc.is_empty ())
     retval = vector_of_empties (nargout, "syl");
   else
     {
 
 // Arguments are not empty, so check for correct dimensions.
 
@@ -93,17 +93,17 @@ syl (const tree_constant *args, int narg
       else if ((a_rows != c_rows) || (b_rows != c_cols))
 	{
 	  gripe_nonconformant ();
 	  return retval;
 	}
   
 // Dimensions look o.k., let's solve the problem.
 
-    retval = new tree_constant[nargout+1];
+    retval.resize (nargout ? nargout : 1);
 
     if (arga.is_complex_type () || argb.is_complex_type ()
 	|| argc.is_complex_type ())
       {
 
 // Do everything in complex arithmetic;
 
 	ComplexMatrix ca = arga.complex_matrix_value ();
@@ -133,17 +133,17 @@ syl (const tree_constant *args, int narg
 	F77_FCN (ztrsyl) ("N", "N", &one, &a_rows, &b_rows,
 			  sch_a.fortran_vec (), &a_rows,
 			  sch_b.fortran_vec (), &b_rows,
 			  cx.fortran_vec (), &a_rows, &scale, &info,
 			  1L, 1L);
 
 	cx = -ua * cx * ub.hermitian ();
   
-	retval[0] = tree_constant (cx);
+	retval(0) = tree_constant (cx);
       }
     else
       {
 
 // Do everything in real arithmetic;
 
 	Matrix ca = arga.to_matrix ();
 	Matrix cb = argb.to_matrix ();
@@ -175,17 +175,17 @@ syl (const tree_constant *args, int narg
 			  cx.fortran_vec (), &a_rows, &scale, &info,
 			  1L, 1L);
 
 	if (info)
 	  error ("syl: trouble in dtrsyl info = %d", info);
   
 	cx = -ua*cx*ub.transpose ();
   
-	retval[0] = tree_constant (cx);
+	retval(0) = tree_constant (cx);
       }
     }
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -30,22 +30,17 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include <stdlib.h>
 #include <string.h>
 #include <iostream.h>
 #include <assert.h>
 
 #include "SLStack.h"
 
-#ifndef SV_FUNCTION_TYPEDEFS
-#define SV_FUNCTION_TYPEDEFS 1
-
-typedef int (*sv_Function)(void);
-
-#endif
+#include "builtins.h"
 
 #define HASH_TABLE_SIZE 1024             /* Must be multiple of 2 */
 #define HASH_MASK (HASH_TABLE_SIZE - 1)
 
 class tree;
 class tree_fvc;
 class tree_builtin;
 class tree_constant;
diff --git a/src/variables.h b/src/variables.h
--- a/src/variables.h
+++ b/src/variables.h
@@ -31,22 +31,17 @@ class tree;
 class tree_fvc;
 class tree_constant;
 
 struct builtin_mapper_functions;
 struct builtin_text_functions;
 struct builtin_general_functions;
 struct builtin_string_variables;
 
-#ifndef SV_FUNCTION_TYPEDEFS
-#define SV_FUNCTION_TYPEDEFS 1
-
-typedef int (*sv_Function)(void);
-
-#endif
+#include "builtins.h"
 
 extern void initialize_symbol_tables (void);
 
 extern int symbol_out_of_date (symbol_record *sr);
 
 extern void document_symbol (const char *name, const char *help);
 
 extern void install_builtin_mapper_function (builtin_mapper_functions *mf);
