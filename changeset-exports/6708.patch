# HG changeset patch
# User jwe
# Date 1181716849 0
#      Wed Jun 13 06:40:49 2007 +0000
# Node ID 0ce71beb1cf3bbf9fc969a3bd09832a8106c892a
# Parent  b7e71f0fc805eab48e460589bcf7d368582928e5
[project @ 2007-06-13 06:40:48 by jwe]

diff --git a/liboctave/Array-C.cc b/liboctave/Array-C.cc
--- a/liboctave/Array-C.cc
+++ b/liboctave/Array-C.cc
@@ -27,22 +27,22 @@ 02110-1301, USA.
 
 // Instantiate Arrays of Complex values.
 
 #include "oct-cmplx.h"
 
 #include "Array.h"
 #include "Array.cc"
 
-INSTANTIATE_ARRAY_AND_ASSIGN (Complex);
+INSTANTIATE_ARRAY_AND_ASSIGN (Complex, OCTAVE_API);
 
-INSTANTIATE_ARRAY_ASSIGN (Complex, double);
-INSTANTIATE_ARRAY_ASSIGN (Complex, int);
-INSTANTIATE_ARRAY_ASSIGN (Complex, short);
-INSTANTIATE_ARRAY_ASSIGN (Complex, char);
+INSTANTIATE_ARRAY_ASSIGN (Complex, double, OCTAVE_API);
+INSTANTIATE_ARRAY_ASSIGN (Complex, int, OCTAVE_API);
+INSTANTIATE_ARRAY_ASSIGN (Complex, short, OCTAVE_API);
+INSTANTIATE_ARRAY_ASSIGN (Complex, char, OCTAVE_API);
 
 #include "Array2.h"
 
 template class OCTAVE_API Array2<Complex>;
 
 #include "ArrayN.h"
 #include "ArrayN.cc"
 
diff --git a/liboctave/Array-b.cc b/liboctave/Array-b.cc
--- a/liboctave/Array-b.cc
+++ b/liboctave/Array-b.cc
@@ -25,17 +25,17 @@ 02110-1301, USA.
 #include <config.h>
 #endif
 
 // Instantiate Arrays of bool values.
 
 #include "Array.h"
 #include "Array.cc"
 
-INSTANTIATE_ARRAY_AND_ASSIGN (bool);
+INSTANTIATE_ARRAY_AND_ASSIGN (bool, OCTAVE_API);
 
 #include "Array2.h"
 
 template class OCTAVE_API Array2<bool>;
 
 #include "ArrayN.h"
 #include "ArrayN.cc"
 
diff --git a/liboctave/Array-ch.cc b/liboctave/Array-ch.cc
--- a/liboctave/Array-ch.cc
+++ b/liboctave/Array-ch.cc
@@ -25,17 +25,17 @@ 02110-1301, USA.
 #include <config.h>
 #endif
 
 // Instantiate Arrays of char values.
 
 #include "Array.h"
 #include "Array.cc"
 
-INSTANTIATE_ARRAY_AND_ASSIGN (char);
+INSTANTIATE_ARRAY_AND_ASSIGN (char, OCTAVE_API);
 
 #include "Array2.h"
 
 template class OCTAVE_API Array2<char>;
 
 #include "ArrayN.h"
 #include "ArrayN.cc"
 
diff --git a/liboctave/Array-d.cc b/liboctave/Array-d.cc
--- a/liboctave/Array-d.cc
+++ b/liboctave/Array-d.cc
@@ -25,21 +25,21 @@ 02110-1301, USA.
 #include <config.h>
 #endif
 
 // Instantiate Arrays of double values.
 
 #include "Array.h"
 #include "Array.cc"
 
-INSTANTIATE_ARRAY_AND_ASSIGN (double);
+INSTANTIATE_ARRAY_AND_ASSIGN (double, OCTAVE_API);
 
-INSTANTIATE_ARRAY_ASSIGN (double, int);
-INSTANTIATE_ARRAY_ASSIGN (double, short);
-INSTANTIATE_ARRAY_ASSIGN (double, char);
+INSTANTIATE_ARRAY_ASSIGN (double, int, OCTAVE_API);
+INSTANTIATE_ARRAY_ASSIGN (double, short, OCTAVE_API);
+INSTANTIATE_ARRAY_ASSIGN (double, char, OCTAVE_API);
 
 #include "Array2.h"
 
 template class OCTAVE_API Array2<double>;
 
 #include "ArrayN.h"
 #include "ArrayN.cc"
 
diff --git a/liboctave/Array-i.cc b/liboctave/Array-i.cc
--- a/liboctave/Array-i.cc
+++ b/liboctave/Array-i.cc
@@ -27,31 +27,31 @@ 02110-1301, USA.
 
 #include "oct-inttypes.h"
 
 // Instantiate Arrays of integer values.
 
 #include "Array.h"
 #include "Array.cc"
 
-INSTANTIATE_ARRAY_AND_ASSIGN (int);
-INSTANTIATE_ARRAY_AND_ASSIGN (long);
+INSTANTIATE_ARRAY_AND_ASSIGN (int, OCTAVE_API);
+INSTANTIATE_ARRAY_AND_ASSIGN (long, OCTAVE_API);
 
-INSTANTIATE_ARRAY_ASSIGN (int, short);
-INSTANTIATE_ARRAY_ASSIGN (int, char);
+INSTANTIATE_ARRAY_ASSIGN (int, short, OCTAVE_API);
+INSTANTIATE_ARRAY_ASSIGN (int, char, OCTAVE_API);
 
-INSTANTIATE_ARRAY_AND_ASSIGN (octave_int8);
-INSTANTIATE_ARRAY_AND_ASSIGN (octave_int16);
-INSTANTIATE_ARRAY_AND_ASSIGN (octave_int32);
-INSTANTIATE_ARRAY_AND_ASSIGN (octave_int64);
+INSTANTIATE_ARRAY_AND_ASSIGN (octave_int8, OCTAVE_API);
+INSTANTIATE_ARRAY_AND_ASSIGN (octave_int16, OCTAVE_API);
+INSTANTIATE_ARRAY_AND_ASSIGN (octave_int32, OCTAVE_API);
+INSTANTIATE_ARRAY_AND_ASSIGN (octave_int64, OCTAVE_API);
 
-INSTANTIATE_ARRAY_AND_ASSIGN (octave_uint8);
-INSTANTIATE_ARRAY_AND_ASSIGN (octave_uint16);
-INSTANTIATE_ARRAY_AND_ASSIGN (octave_uint32);
-INSTANTIATE_ARRAY_AND_ASSIGN (octave_uint64);
+INSTANTIATE_ARRAY_AND_ASSIGN (octave_uint8, OCTAVE_API);
+INSTANTIATE_ARRAY_AND_ASSIGN (octave_uint16, OCTAVE_API);
+INSTANTIATE_ARRAY_AND_ASSIGN (octave_uint32, OCTAVE_API);
+INSTANTIATE_ARRAY_AND_ASSIGN (octave_uint64, OCTAVE_API);
 
 #include "Array2.h"
 
 template class OCTAVE_API Array2<int>;
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
diff --git a/liboctave/Array-idx-vec.cc b/liboctave/Array-idx-vec.cc
--- a/liboctave/Array-idx-vec.cc
+++ b/liboctave/Array-idx-vec.cc
@@ -27,15 +27,15 @@ 02110-1301, USA.
 
 // Instantiate Arrays of integer values.
 
 #include "idx-vector.h"
 
 #include "Array.h"
 #include "Array.cc"
 
-INSTANTIATE_ARRAY (idx_vector);
+INSTANTIATE_ARRAY (idx_vector, OCTAVE_API);
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/Array-s.cc b/liboctave/Array-s.cc
--- a/liboctave/Array-s.cc
+++ b/liboctave/Array-s.cc
@@ -25,19 +25,19 @@ 02110-1301, USA.
 #include <config.h>
 #endif
 
 // Instantiate Arrays of short int values.
 
 #include "Array.h"
 #include "Array.cc"
 
-INSTANTIATE_ARRAY_AND_ASSIGN (short);
+INSTANTIATE_ARRAY_AND_ASSIGN (short, OCTAVE_API);
 
-INSTANTIATE_ARRAY_ASSIGN (short, char);
+INSTANTIATE_ARRAY_ASSIGN (short, char, OCTAVE_API);
 
 #include "Array2.h"
 
 template class Array2<short>;
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
diff --git a/liboctave/Array-so.cc b/liboctave/Array-so.cc
--- a/liboctave/Array-so.cc
+++ b/liboctave/Array-so.cc
@@ -25,17 +25,17 @@ 02110-1301, USA.
 #include <config.h>
 #endif
 
 // Instantiate Arrays of std::streamoff values.
 
 #include "Array.h"
 #include "Array.cc"
 
-INSTANTIATE_ARRAY_AND_ASSIGN (std::streamoff);
+INSTANTIATE_ARRAY_AND_ASSIGN (std::streamoff, OCTAVE_API);
 
 #include "Array2.h"
 
 template class Array2<std::streamoff>;
 
 #include "ArrayN.h"
 #include "ArrayN.cc"
 
diff --git a/liboctave/Array-str.cc b/liboctave/Array-str.cc
--- a/liboctave/Array-str.cc
+++ b/liboctave/Array-str.cc
@@ -27,15 +27,15 @@ 02110-1301, USA.
 
 // Instantiate Arrays of strings.
 
 #include "Array.h"
 #include "Array.cc"
 
 #include <string>
 
-INSTANTIATE_ARRAY (std::string);
+INSTANTIATE_ARRAY (std::string, OCTAVE_API);
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -564,31 +564,31 @@ assignN (Array<LT>& lhs, const Array<RT>
 
 template <class LT, class RT>
 int
 assign (Array<LT>& lhs, const Array<RT>& rhs)
 {
   return assign (lhs, rhs, resize_fill_value (LT ()));
 }
 
-#define INSTANTIATE_ARRAY_ASSIGN(LT, RT) \
-  template OCTAVE_API int assign (Array<LT>&, const Array<RT>&, const LT&); \
-  template OCTAVE_API int assign1 (Array<LT>&, const Array<RT>&, const LT&); \
-  template OCTAVE_API int assign2 (Array<LT>&, const Array<RT>&, const LT&); \
-  template OCTAVE_API int assignN (Array<LT>&, const Array<RT>&, const LT&); \
-  template OCTAVE_API int assign (Array<LT>&, const Array<RT>&)
+#define INSTANTIATE_ARRAY_ASSIGN(LT, RT, API) \
+  template API int assign (Array<LT>&, const Array<RT>&, const LT&); \
+  template API int assign1 (Array<LT>&, const Array<RT>&, const LT&); \
+  template API int assign2 (Array<LT>&, const Array<RT>&, const LT&); \
+  template API int assignN (Array<LT>&, const Array<RT>&, const LT&); \
+  template API int assign (Array<LT>&, const Array<RT>&)
 
 
-#define INSTANTIATE_ARRAY(T) \
-  template class OCTAVE_API Array<T>; \
-  template OCTAVE_API T resize_fill_value (const T&); \
+#define INSTANTIATE_ARRAY(T, API) \
+  template class API Array<T>; \
+  template API T resize_fill_value (const T&); \
 
-#define INSTANTIATE_ARRAY_AND_ASSIGN(T) \
-  INSTANTIATE_ARRAY (T); \
-  INSTANTIATE_ARRAY_ASSIGN (T, T)
+#define INSTANTIATE_ARRAY_AND_ASSIGN(T, API) \
+  INSTANTIATE_ARRAY (T, API); \
+  INSTANTIATE_ARRAY_ASSIGN (T, T, API)
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -368,24 +368,24 @@ extern OCTAVE_API ComplexMatrix operator
 extern OCTAVE_API ComplexMatrix min (const Complex& c, const ComplexMatrix& m);
 extern OCTAVE_API ComplexMatrix min (const ComplexMatrix& m, const Complex& c);
 extern OCTAVE_API ComplexMatrix min (const ComplexMatrix& a, const ComplexMatrix& b);
 
 extern OCTAVE_API ComplexMatrix max (const Complex& c, const ComplexMatrix& m);
 extern OCTAVE_API ComplexMatrix max (const ComplexMatrix& m, const Complex& c);
 extern OCTAVE_API ComplexMatrix max (const ComplexMatrix& a, const ComplexMatrix& b);
 
-MS_CMP_OP_DECLS (ComplexMatrix, Complex)
-MS_BOOL_OP_DECLS (ComplexMatrix, Complex)
+MS_CMP_OP_DECLS (ComplexMatrix, Complex, OCTAVE_API)
+MS_BOOL_OP_DECLS (ComplexMatrix, Complex, OCTAVE_API)
 
-SM_CMP_OP_DECLS (Complex, ComplexMatrix)
-SM_BOOL_OP_DECLS (Complex, ComplexMatrix)
+SM_CMP_OP_DECLS (Complex, ComplexMatrix, OCTAVE_API)
+SM_BOOL_OP_DECLS (Complex, ComplexMatrix, OCTAVE_API)
 
-MM_CMP_OP_DECLS (ComplexMatrix, ComplexMatrix)
-MM_BOOL_OP_DECLS (ComplexMatrix, ComplexMatrix)
+MM_CMP_OP_DECLS (ComplexMatrix, ComplexMatrix, OCTAVE_API)
+MM_BOOL_OP_DECLS (ComplexMatrix, ComplexMatrix, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArray2, ComplexMatrix, Complex)
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/CNDArray.h b/liboctave/CNDArray.h
--- a/liboctave/CNDArray.h
+++ b/liboctave/CNDArray.h
@@ -126,24 +126,24 @@ private:
 extern OCTAVE_API ComplexNDArray min (const Complex& c, const ComplexNDArray& m);
 extern OCTAVE_API ComplexNDArray min (const ComplexNDArray& m, const Complex& c);
 extern OCTAVE_API ComplexNDArray min (const ComplexNDArray& a, const ComplexNDArray& b);
 
 extern OCTAVE_API ComplexNDArray max (const Complex& c, const ComplexNDArray& m);
 extern OCTAVE_API ComplexNDArray max (const ComplexNDArray& m, const Complex& c);
 extern OCTAVE_API ComplexNDArray max (const ComplexNDArray& a, const ComplexNDArray& b);
 
-NDS_CMP_OP_DECLS (ComplexNDArray, Complex)
-NDS_BOOL_OP_DECLS (ComplexNDArray, Complex)
+NDS_CMP_OP_DECLS (ComplexNDArray, Complex, OCTAVE_API)
+NDS_BOOL_OP_DECLS (ComplexNDArray, Complex, OCTAVE_API)
 
-SND_CMP_OP_DECLS (Complex, ComplexNDArray)
-SND_BOOL_OP_DECLS (Complex, ComplexNDArray)
+SND_CMP_OP_DECLS (Complex, ComplexNDArray, OCTAVE_API)
+SND_BOOL_OP_DECLS (Complex, ComplexNDArray, OCTAVE_API)
 
-NDND_CMP_OP_DECLS (ComplexNDArray, ComplexNDArray)
-NDND_BOOL_OP_DECLS (ComplexNDArray, ComplexNDArray)
+NDND_CMP_OP_DECLS (ComplexNDArray, ComplexNDArray, OCTAVE_API)
+NDND_BOOL_OP_DECLS (ComplexNDArray, ComplexNDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArrayN, ComplexNDArray, Complex)
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/CSparse.h b/liboctave/CSparse.h
--- a/liboctave/CSparse.h
+++ b/liboctave/CSparse.h
@@ -458,24 +458,24 @@ extern OCTAVE_API SparseComplexMatrix mi
 
 extern OCTAVE_API SparseComplexMatrix max (const Complex& c, 
 				const SparseComplexMatrix& m);
 extern OCTAVE_API SparseComplexMatrix max (const SparseComplexMatrix& m, 
 				const Complex& c);
 extern OCTAVE_API SparseComplexMatrix max (const SparseComplexMatrix& a, 
 				const SparseComplexMatrix& b);
 
-SPARSE_SMS_CMP_OP_DECLS (SparseComplexMatrix, Complex)
-SPARSE_SMS_BOOL_OP_DECLS (SparseComplexMatrix, Complex)
+SPARSE_SMS_CMP_OP_DECLS (SparseComplexMatrix, Complex, OCTAVE_API)
+SPARSE_SMS_BOOL_OP_DECLS (SparseComplexMatrix, Complex, OCTAVE_API)
 
-SPARSE_SSM_CMP_OP_DECLS (Complex, SparseComplexMatrix)
-SPARSE_SSM_BOOL_OP_DECLS (Complex, SparseComplexMatrix)
+SPARSE_SSM_CMP_OP_DECLS (Complex, SparseComplexMatrix, OCTAVE_API)
+SPARSE_SSM_BOOL_OP_DECLS (Complex, SparseComplexMatrix, OCTAVE_API)
 
-SPARSE_SMSM_CMP_OP_DECLS (SparseComplexMatrix, SparseComplexMatrix)
-SPARSE_SMSM_BOOL_OP_DECLS (SparseComplexMatrix, SparseComplexMatrix)
+SPARSE_SMSM_CMP_OP_DECLS (SparseComplexMatrix, SparseComplexMatrix, OCTAVE_API)
+SPARSE_SMSM_BOOL_OP_DECLS (SparseComplexMatrix, SparseComplexMatrix, OCTAVE_API)
 
 SPARSE_FORWARD_DEFS (MSparse, SparseComplexMatrix, ComplexMatrix, Complex)
 
 #ifdef IDX_TYPE_LONG
 #define UMFPACK_ZNAME(name) umfpack_zl_ ## name
 #else
 #define UMFPACK_ZNAME(name) umfpack_zi_ ## name
 #endif
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,68 @@
+2007-06-13  Michael Goffioul  <michael.goffioul@swing.be>
+
+	* MArray-ch.cc, MArray-d.cc, MArray-i.cc, MArray-s.cc:
+	Sprinkle class instantiations with OCTAVE_API as needed.
+
+	* Array.h (INSTANTIATE_ARRAY_ASSIGN, INSTANTIATE_ARRAY,
+	INSTANTIATE_ARRAY_AND_ASSIGN): New arg, API. Change all uses.
+	* MArray-defs.h (MARRAY_OP_ASSIGN_DECL, MARRAY_OP_ASSIGN_DECLS,
+	MARRAY_OP_ASSIGN_FWD_DECLS, MARRAY_OP_ASSIGN_FRIENDS,
+	MARRAY_OP_ASSIGN_DEFS, MARRAY_UNOP, MARRAY_UNOP_DECLS,
+	MARRAY_UNOP_FWD_DECLS, MARRAY_UNOP_FRIENDS, MARRAY_UNOP_DEFS,
+	MARRAY_BINOP_DECL, MARRAY_BINOP_DECLS, MARRAY_AA_BINOP_DECLS,
+	MDIAGARRAY2_DAS_BINOP_DECLS, MDIAGARRAY2_SDA_BINOP_DECLS,
+	MDIAGARRAY2_DADA_BINOP_DECLS, MARRAY_BINOP_FWD_DECLS,
+	MDIAGARRAY2_BINOP_FWD_DECLS, MARRAY_BINOP_FRIENDS,
+	MDIAGARRAY2_BINOP_FRIENDS, MARRAY_BINOP_DEFS,
+	MDIAGARRAY2_BINOP_DEFS, MARRAY_OPS_FORWARD_DECLS,
+	MDIAGARRAY2_OPS_FORWARD_DECLS, MARRAY_OPS_FRIEND_DECLS,
+	MDIAGARRAY2_OPS_FRIEND_DECLS, INSTANTIATE_MARRAY_FRIENDS,
+	INSTANTIATE_MARRAY2_FRIENDS, INSTANTIATE_MARRAYN_FRIENDS,
+	INSTANTIATE_MDIAGARRAY2_FRIENDS): Ditto.
+	* MSparse-defs.h (SPARSE_OP_ASSIGN_DECL, SPARSE_OP_ASSIGN_DECLS,
+	SPARSE_OP_ASSIGN_FWD_DECLS, SPARSE_OP_ASSIGN_FRIENDS,
+	SPARSE_OP_ASSIGN_DEFS, SPARSE_UNOP, SPARSE_UNOP_DECLS,
+	SPARSE_UNOP_FWD_DECLS, SPARSE_UNOP_FRIENDS, SPARSE_UNOP_DEFS,
+	SPARSE_BINOP_DECL, SPARSE_BINOP_DECLS, SPARSE_AA_BINOP_DECLS,
+	SPARSE_BINOP_FWD_DECLS, SPARSE_BINOP_FRIENDS, SPARSE_BINOP_DEFS,
+	SPARSE_OPS_FORWARD_DECLS, SPARSE_OPS_FRIEND_DECLS,
+	INSTANTIATE_SPARSE_FRIENDS): Ditto.
+	* Sparse-op-defs.h (SPARSE_BIN_OP_DECL, SPARSE_CMP_OP_DECL,
+	SPARSE_BOOL_OP_DECL, SPARSE_SMS_BIN_OP_DECLS,
+	SPARSE_SMS_CMP_OP_DECLS, SPARSE_SMS_EQNE_OP_DECLS,
+	SPARSE_SMS_BOOL_OP_DECLS, SPARSE_SSM_BIN_OP_DECLS,
+	SPARSE_SMS_OP_DECLS, SPARSE_SSM_BIN_OP_DECLS,
+	SPARSE_SSM_CMP_OP_DECLS, SPARSE_SSM_EQNE_OP_DECLS,
+	SPARSE_SSM_BOOL_OP_DECLS, SPARSE_SSM_OP_DECLS,
+	SPARSE_SMSM_BIN_OP_DECLS, SPARSE_SMSM_CMP_OP_DECLS,
+	SPARSE_SMSM_EQNE_OP_DECLS, SPARSE_SMSM_BOOL_OP_DECLS,
+	SPARSE_SMSM_OP_DECLS, SPARSE_MSM_BIN_OP_DECLS,
+	SPARSE_MSM_CMP_OP_DECLS, SPARSE_MSM_EQNE_OP_DECLS,
+	SPARSE_MSM_BOOL_OP_DECLS, SPARSE_MSM_OP_DECLS,
+	SPARSE_SMM_BIN_OP_DECLS, SPARSE_SMM_CMP_OP_DECLS,
+	SPARSE_SMM_EQNE_OP_DECLS, SPARSE_SMM_BOOL_OP_DECLS,
+	SPARSE_SMM_OP_DECLS): Ditto.
+	* Sparse.h (INSTANTIATE_SPARSE_ASSIGN, INSTANTIATE_SPARSE,
+	INSTANTIATE_SPARSE_AND_ASSIGN): Ditto.
+	* mx-op-defs.h (BIN_OP_DECL, CMP_OP_DECL, NDCMP_OP_DECL,
+	BOOL_OP_DECL, NDBOOL_OP_DECL, VS_BIN_OP_DECLS, VS_OP_DECLS,
+	SV_BIN_OP_DECLS, SV_OP_DECLS, VV_BIN_OP_DECLS, VV_OP_DECLS,
+	MS_BIN_OP_DECLS, MS_CMP_OP_DECLS, MS_BOOL_OP_DECLS, MS_OP_DECLS,
+	SM_BIN_OP_DECLS, SM_CMP_OP_DECLS, SM_BOOL_OP_DECLS, SM_OP_DECLS,
+	MM_BIN_OP_DECLS, MM_CMP_OP_DECLS, MM_BOOL_OP_DECLS, MM_OP_DECLS,
+	NDS_BIN_OP_DECLS, NDS_CMP_OP_DECLS, NDS_BOOL_OP_DECLS,
+	NDS_OP_DECLS, SND_BIN_OP_DECLS, SND_CMP_OP_DECLS,
+	SND_BOOL_OP_DECLS, SND_OP_DECLS, NDND_BIN_OP_DECLS,
+	NDND_CMP_OP_DECLS, NDND_BOOL_OP_DECLS, NDND_OP_DECLS,
+	SDM_BIN_OP_DECLS, SDM_OP_DECLS, DMS_BIN_OP_DECLS, DMS_OP_DECLS,
+	MDM_BIN_OP_DECLS, MDM_OP_DECLS, DMM_BIN_OP_DECLS, DMM_OP_DECLS,
+	DMDM_BIN_OP_DECLS, DMDM_OP_DECLS): Ditto.
+
 2007-06-12  John W. Eaton  <jwe@octave.org>
 
 	* dMatrix.cc (Matrix::expm): Special case for scalar arg.
 	* CMatrix.cc (ComplexMatrix::expm): Likewise.
 
 2007-06-06  Michael Goffioul  <michael.goffioul@swing.be>
 
 	* file-ops.cc: Include sys/stat.h, fcntl.h, and utime.h or
@@ -465,61 +525,39 @@ 2006-10-26  John W. Eaton  <jwe@octave.o
 	* strcasecmp.c: Move here from src/strcasecmp.c.
 	* strncase.c: Move here from src/strncase.c.
 	* Makefile.in (LIBOCTAVE_C_SOURCES): Add them to the list.
 
 2006-10-26  Michael Goffioul  <michael.goffioul@swing.be>
 
 	* kpse.cc [! MSVC]: Don't include win32lib.h.
 
-	* liboctave/Array-C.cc, liboctave/Array-b.cc,
-	liboctave/Array-ch.cc, liboctave/Array-i.cc,
-	liboctave/Array-util.h, liboctave/Array.h, liboctave/CColVector.h,
-	liboctave/CMatrix.h, liboctave/CNDArray.h, liboctave/CRowVector.h,
-	liboctave/CSparse.h, liboctave/CmplxAEPBAL.h,
-	liboctave/CmplxCHOL.h, liboctave/CmplxDET.h,
-	liboctave/CmplxHESS.h, liboctave/CmplxLU.h, liboctave/CmplxQR.h,
-	liboctave/CmplxQRP.h, liboctave/CmplxSCHUR.h,
-	liboctave/CmplxSVD.h, liboctave/CollocWt.h, liboctave/DAE.h,
-	liboctave/DASPK.h, liboctave/DASRT.h, liboctave/DASSL.h,
-	liboctave/EIG.h, liboctave/LSODE.h, liboctave/MArray-C.cc,
-	liboctave/MArray-defs.h, liboctave/MSparse-C.cc,
-	liboctave/MSparse-d.cc, liboctave/MSparse-defs.h,
-	liboctave/MatrixType.h, liboctave/NLEqn.h, liboctave/Quad.h,
-	liboctave/Range.h, liboctave/Sparse-op-defs.h, liboctave/Sparse.h,
-	liboctave/SparseCmplxCHOL.h, liboctave/SparseCmplxLU.h,
-	liboctave/SparseCmplxQR.h, liboctave/SparseQR.h,
-	liboctave/SparsedbleCHOL.h, liboctave/SparsedbleLU.h,
-	liboctave/boolMatrix.h, liboctave/boolNDArray.h,
-	liboctave/boolSparse.h, liboctave/chMatrix.h,
-	liboctave/chNDArray.h, liboctave/cmd-edit.h, liboctave/cmd-hist.h,
-	liboctave/dColVector.h, liboctave/dDiagMatrix.h,
-	liboctave/dMatrix.h, liboctave/dNDArray.h, liboctave/dRowVector.h,
-	liboctave/dSparse.h, liboctave/data-conv.h,
-	liboctave/dbleAEPBAL.h, liboctave/dbleCHOL.h, liboctave/dbleDET.h,
-	liboctave/dbleHESS.h, liboctave/dbleLU.h, liboctave/dbleQR.h,
-	liboctave/dbleQRP.h, liboctave/dbleSCHUR.h, liboctave/dbleSVD.h,
-	liboctave/dir-ops.h, liboctave/file-ops.h, liboctave/file-stat.h,
-	liboctave/glob-match.h, liboctave/idx-vector.h,
-	liboctave/int16NDArray.cc, liboctave/int32NDArray.cc,
-	liboctave/int64NDArray.cc, liboctave/int8NDArray.cc,
-	liboctave/lo-cutils.c, liboctave/lo-ieee.h,
-	liboctave/lo-mappers.h, liboctave/lo-specfun.h,
-	liboctave/lo-utils.h, liboctave/mach-info.h,
-	liboctave/mx-op-defs.h, liboctave/oct-alloc.h,
-	liboctave/oct-env.h, liboctave/oct-group.h,
-	liboctave/oct-inttypes.cc, liboctave/oct-inttypes.h,
-	liboctave/oct-passwd.h, liboctave/oct-rand.h,
-	liboctave/oct-shlib.h, liboctave/oct-spparms.h,
-	liboctave/oct-syscalls.h, liboctave/oct-time.h,
-	liboctave/oct-uname.h, liboctave/pathsearch.h,
-	liboctave/prog-args.h, liboctave/so-array.h, liboctave/str-vec.h,
-	liboctave/uint16NDArray.cc, liboctave/uint32NDArray.cc,
-	liboctave/uint64NDArray.cc, liboctave/uint8NDArray.cc:
-	Sprinkle with OCTAVE_API as needed.
+	* Array-C.cc, Array-b.cc, Array-ch.cc, Array-i.cc, Array-util.h,
+	Array.h, CColVector.h, CMatrix.h, CNDArray.h, CRowVector.h,
+	CSparse.h, CmplxAEPBAL.h, CmplxCHOL.h, CmplxDET.h, CmplxHESS.h,
+	CmplxLU.h, CmplxQR.h, CmplxQRP.h, CmplxSCHUR.h, CmplxSVD.h,
+	CollocWt.h, DAE.h, DASPK.h, DASRT.h, DASSL.h, EIG.h, LSODE.h,
+	MArray-C.cc, MArray-defs.h, MSparse-C.cc, MSparse-d.cc,
+	MSparse-defs.h, MatrixType.h, NLEqn.h, Quad.h, Range.h,
+	Sparse-op-defs.h, Sparse.h, SparseCmplxCHOL.h, SparseCmplxLU.h,
+	SparseCmplxQR.h, SparseQR.h, SparsedbleCHOL.h, SparsedbleLU.h,
+	boolMatrix.h, boolNDArray.h, boolSparse.h, chMatrix.h,
+	chNDArray.h, cmd-edit.h, cmd-hist.h, dColVector.h, dDiagMatrix.h,
+	dMatrix.h, dNDArray.h, dRowVector.h, dSparse.h, data-conv.h,
+	dbleAEPBAL.h, dbleCHOL.h, dbleDET.h, dbleHESS.h, dbleLU.h,
+	dbleQR.h, dbleQRP.h, dbleSCHUR.h, dbleSVD.h, dir-ops.h,
+	file-ops.h, file-stat.h, glob-match.h, idx-vector.h,
+	int16NDArray.cc, int32NDArray.cc, int64NDArray.cc, int8NDArray.cc,
+	lo-cutils.c, lo-ieee.h, lo-mappers.h, lo-specfun.h, lo-utils.h,
+	mach-info.h, mx-op-defs.h, oct-alloc.h, oct-env.h, oct-group.h,
+	oct-inttypes.cc, oct-inttypes.h, oct-passwd.h, oct-rand.h,
+	oct-shlib.h, oct-spparms.h, oct-syscalls.h, oct-time.h,
+	oct-uname.h, pathsearch.h, prog-args.h, so-array.h, str-vec.h,
+	uint16NDArray.cc, uint32NDArray.cc, uint64NDArray.cc,
+	uint8NDArray.cc: Sprinkle with OCTAVE_API as needed.
 
 2006-10-26  John W. Eaton  <jwe@octave.org>
 
 	* oct-inttypes.cc (INSTANTIATE_INTTYPE_BIN_OP): Provide explicit
 	type qualification for OP.
 
 2006-10-26  David Bateman  <dbateman@free.fr>
 
@@ -568,18 +606,18 @@ 2006-10-17  John W. Eaton  <jwe@octave.o
 	* lo-cieee.c: If isnan is not available but _isnan is, then define
 	isnan to be _isnan, and define HAVE_ISNAN.  Likewise for _finite
 	and _copysign.
 
 2006-10-17  Michael Goffioul  <michael.goffioul@swing.be>
 
 	* oct-syscalls.cc (syscalls::waitpid): Always declare and define retval.
 
-	* liboctave/CMatrix.cc (ComplexMatrix::solve): Avoid infinite recursion. 
-	* Index: liboctave/CSparse.cc (SparseComplexMatrix::insert): Likewise.
+	* CMatrix.cc (ComplexMatrix::solve): Avoid infinite recursion. 
+	* CSparse.cc (SparseComplexMatrix::insert): Likewise.
 
 	* oct-types.h.in: Include limits.h, for CHAR_BIT.
 
 2006-10-13  Michael Goffioul  <michael.goffioul@swing.be>
 
 	* Makefile.in: Adapt rules to use $(LIBPRE).
 
 2006-10-03  David Bateman <dbateman@free.fr>
diff --git a/liboctave/MArray-C.cc b/liboctave/MArray-C.cc
--- a/liboctave/MArray-C.cc
+++ b/liboctave/MArray-C.cc
@@ -44,36 +44,36 @@ template <>
 OCTAVE_API double
 MArray<Complex>::norm (double p) const
 {
   MARRAY_NORM_BODY (Complex, xdznrm2, XDZNRM2);
 }
 
 template class OCTAVE_API MArray<Complex>;
 
-INSTANTIATE_MARRAY_FRIENDS (Complex)
+INSTANTIATE_MARRAY_FRIENDS (Complex, OCTAVE_API)
 
 #include "MArray2.h"
 #include "MArray2.cc"
 
 template class OCTAVE_API MArray2<Complex>;
 
-INSTANTIATE_MARRAY2_FRIENDS (Complex)
+INSTANTIATE_MARRAY2_FRIENDS (Complex, OCTAVE_API)
 
 #include "MArrayN.h"
 #include "MArrayN.cc"
 
 template class OCTAVE_API MArrayN<Complex>;
 
-INSTANTIATE_MARRAYN_FRIENDS (Complex)
+INSTANTIATE_MARRAYN_FRIENDS (Complex, OCTAVE_API)
 
 #include "MDiagArray2.h"
 #include "MDiagArray2.cc"
 
 template class OCTAVE_API MDiagArray2<Complex>;
 
-INSTANTIATE_MDIAGARRAY2_FRIENDS (Complex)
+INSTANTIATE_MDIAGARRAY2_FRIENDS (Complex, OCTAVE_API)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/MArray-ch.cc b/liboctave/MArray-ch.cc
--- a/liboctave/MArray-ch.cc
+++ b/liboctave/MArray-ch.cc
@@ -25,31 +25,31 @@ 02110-1301, USA.
 #include <config.h>
 #endif
 
 // Instantiate MArrays of char values.
 
 #include "MArray.h"
 #include "MArray.cc"
 
-template class MArray<char>;
+template class OCTAVE_API MArray<char>;
 
-INSTANTIATE_MARRAY_FRIENDS (char)
+INSTANTIATE_MARRAY_FRIENDS (char, OCTAVE_API)
 
 #include "MArray2.h"
 #include "MArray2.cc"
 
-template class MArray2<char>;
+template class OCTAVE_API MArray2<char>;
 
-INSTANTIATE_MARRAY2_FRIENDS (char)
+INSTANTIATE_MARRAY2_FRIENDS (char, OCTAVE_API)
 
 #include "MDiagArray2.h"
 #include "MDiagArray2.cc"
 
-template class MDiagArray2<char>;
+template class OCTAVE_API MDiagArray2<char>;
 
-INSTANTIATE_MDIAGARRAY2_FRIENDS (char)
+INSTANTIATE_MDIAGARRAY2_FRIENDS (char, OCTAVE_API)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/MArray-d.cc b/liboctave/MArray-d.cc
--- a/liboctave/MArray-d.cc
+++ b/liboctave/MArray-d.cc
@@ -35,44 +35,44 @@ extern "C"
   F77_FUNC (xdnrm2, XDNRM2) (const octave_idx_type&, const double*,
 			     const octave_idx_type&, double&);
 }
 
 #include "MArray.h"
 #include "MArray.cc"
 
 template <>
-double
+OCTAVE_API double
 MArray<double>::norm (double p) const
 {
   MARRAY_NORM_BODY (double, xdnrm2, XDNRM2);
 }
 
-template class MArray<double>;
+template class OCTAVE_API MArray<double>;
 
-INSTANTIATE_MARRAY_FRIENDS (double)
+INSTANTIATE_MARRAY_FRIENDS (double, OCTAVE_API)
 
 #include "MArray2.h"
 #include "MArray2.cc"
 
-template class MArray2<double>;
+template class OCTAVE_API MArray2<double>;
 
-INSTANTIATE_MARRAY2_FRIENDS (double)
+INSTANTIATE_MARRAY2_FRIENDS (double, OCTAVE_API)
 
 #include "MArrayN.h"
 #include "MArrayN.cc"
 
-template class MArrayN<double>;
+template class OCTAVE_API MArrayN<double>;
 
-INSTANTIATE_MARRAYN_FRIENDS (double)
+INSTANTIATE_MARRAYN_FRIENDS (double, OCTAVE_API)
 
 #include "MDiagArray2.h"
 #include "MDiagArray2.cc"
 
-template class MDiagArray2<double>;
+template class OCTAVE_API MDiagArray2<double>;
 
-INSTANTIATE_MDIAGARRAY2_FRIENDS (double)
+INSTANTIATE_MDIAGARRAY2_FRIENDS (double, OCTAVE_API)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/MArray-defs.h b/liboctave/MArray-defs.h
--- a/liboctave/MArray-defs.h
+++ b/liboctave/MArray-defs.h
@@ -46,151 +46,151 @@
       T *a_tmp = a.fortran_vec (); \
       const T *b_tmp = b.data (); \
       for (octave_idx_type i = 0; i < l; i++) \
 	a_tmp[i] OP b_tmp[i]; \
     } \
   while (0)
 
 // A macro that can be used to declare and instantiate OP= operators.
-#define MARRAY_OP_ASSIGN_DECL(A_T, E_T, OP, PFX, LTGT, RHS_T) \
-  PFX A_T<E_T>& \
+#define MARRAY_OP_ASSIGN_DECL(A_T, E_T, OP, PFX, API, LTGT, RHS_T) \
+  PFX API A_T<E_T>& \
   operator OP LTGT (A_T<E_T>&, const RHS_T&)
 
 // All the OP= operators that we care about.
-#define MARRAY_OP_ASSIGN_DECLS(A_T, E_T, PFX, LTGT, RHS_T) \
-  MARRAY_OP_ASSIGN_DECL (A_T, E_T, +=, PFX, LTGT, RHS_T); \
-  MARRAY_OP_ASSIGN_DECL (A_T, E_T, -=, PFX, LTGT, RHS_T);
+#define MARRAY_OP_ASSIGN_DECLS(A_T, E_T, PFX, API, LTGT, RHS_T) \
+  MARRAY_OP_ASSIGN_DECL (A_T, E_T, +=, PFX, API, LTGT, RHS_T); \
+  MARRAY_OP_ASSIGN_DECL (A_T, E_T, -=, PFX, API, LTGT, RHS_T);
 
 // Generate forward declarations for OP= operators.
-#define MARRAY_OP_ASSIGN_FWD_DECLS(A_T, RHS_T) \
-  MARRAY_OP_ASSIGN_DECLS (A_T, T, template <typename T> OCTAVE_API, , RHS_T)
+#define MARRAY_OP_ASSIGN_FWD_DECLS(A_T, RHS_T, API) \
+  MARRAY_OP_ASSIGN_DECLS (A_T, T, template <typename T>, API, , RHS_T)
 
 // Generate friend declarations for the OP= operators.
-#define MARRAY_OP_ASSIGN_FRIENDS(A_T, RHS_T) \
-  MARRAY_OP_ASSIGN_DECLS (A_T, T, friend, <>, RHS_T)
+#define MARRAY_OP_ASSIGN_FRIENDS(A_T, RHS_T, API) \
+  MARRAY_OP_ASSIGN_DECLS (A_T, T, friend, API, <>, RHS_T)
 
 // Instantiate the OP= operators.
-#define MARRAY_OP_ASSIGN_DEFS(A_T, E_T, RHS_T) \
-  MARRAY_OP_ASSIGN_DECLS (A_T, E_T, template OCTAVE_API, , RHS_T)
+#define MARRAY_OP_ASSIGN_DEFS(A_T, E_T, RHS_T, API) \
+  MARRAY_OP_ASSIGN_DECLS (A_T, E_T, template, API, , RHS_T)
 
 // A function that can be used to forward OP= operations from derived
 // classes back to us.
 #define MARRAY_OP_ASSIGN_FWD_FCN(R, F, T, C_X, X_T, C_Y, Y_T) \
   inline R \
   F (X_T& x, const Y_T& y) \
   { \
     return R (F (C_X (x), C_Y (y))); \
   }
 
 // All the OP= operators that we care about forwarding.
 #define MARRAY_OP_ASSIGN_FWD_DEFS(R, T, C_X, X_T, C_Y, Y_T) \
   MARRAY_OP_ASSIGN_FWD_FCN (R, operator +=, T, C_X, X_T, C_Y, Y_T) \
   MARRAY_OP_ASSIGN_FWD_FCN (R, operator -=, T, C_X, X_T, C_Y, Y_T)
 
 // A macro that can be used to declare and instantiate unary operators.
-#define MARRAY_UNOP(A_T, E_T, F, PFX, LTGT) \
-  PFX A_T<E_T> \
+#define MARRAY_UNOP(A_T, E_T, F, PFX, API, LTGT) \
+  PFX API A_T<E_T> \
   F LTGT (const A_T<E_T>&)
 
 // All the unary operators that we care about.
-#define MARRAY_UNOP_DECLS(A_T, E_T, PFX, LTGT) \
-  MARRAY_UNOP (A_T, E_T, operator +, PFX, LTGT); \
-  MARRAY_UNOP (A_T, E_T, operator -, PFX, LTGT);
+#define MARRAY_UNOP_DECLS(A_T, E_T, PFX, API, LTGT) \
+  MARRAY_UNOP (A_T, E_T, operator +, PFX, API, LTGT); \
+  MARRAY_UNOP (A_T, E_T, operator -, PFX, API, LTGT);
 
 // Generate forward declarations for unary operators.
-#define MARRAY_UNOP_FWD_DECLS(A_T) \
-  MARRAY_UNOP_DECLS (A_T, T, template <typename T> OCTAVE_API, )
+#define MARRAY_UNOP_FWD_DECLS(A_T, API) \
+  MARRAY_UNOP_DECLS (A_T, T, template <typename T>, API, )
 
 // Generate friend declarations for the unary operators.
-#define MARRAY_UNOP_FRIENDS(A_T) \
-  MARRAY_UNOP_DECLS (A_T, T, friend, <>)
+#define MARRAY_UNOP_FRIENDS(A_T, API) \
+  MARRAY_UNOP_DECLS (A_T, T, friend, API, <>)
 
 // Instantiate the unary operators.
-#define MARRAY_UNOP_DEFS(A_T, E_T) \
-  MARRAY_UNOP_DECLS (A_T, E_T, template OCTAVE_API, )
+#define MARRAY_UNOP_DEFS(A_T, E_T, API) \
+  MARRAY_UNOP_DECLS (A_T, E_T, template, API, )
 
 // A function that can be used to forward unary operations from derived
 // classes back to us.
 #define MARRAY_UNOP_FWD_FCN(R, F, T, C_X, X_T) \
   inline R \
   F (const X_T& x) \
   { \
     return R (F (C_X (x))); \
   }
 
 // All the unary operators that we care about forwarding.
 #define MARRAY_UNOP_FWD_DEFS(R, T, C_X, X_T) \
   MARRAY_UNOP_FWD_FCN (R, operator +, T, C_X, X_T) \
   MARRAY_UNOP_FWD_FCN (R, operator -, T, C_X, X_T)
 
 // A macro that can be used to declare and instantiate binary operators.
-#define MARRAY_BINOP_DECL(A_T, E_T, F, PFX, LTGT, X_T, Y_T) \
-  PFX A_T<E_T> \
+#define MARRAY_BINOP_DECL(A_T, E_T, F, PFX, API, LTGT, X_T, Y_T) \
+  PFX API A_T<E_T> \
   F LTGT (const X_T&, const Y_T&)
 
 // All the binary operators that we care about.  We have two
 // sets of macros since the MArray OP MArray operations use functions
 // (product and quotient) instead of operators (*, /).
-#define MARRAY_BINOP_DECLS(A_T, E_T, PFX, LTGT, X_T, Y_T) \
-  MARRAY_BINOP_DECL (A_T, E_T, operator +, PFX, LTGT, X_T, Y_T); \
-  MARRAY_BINOP_DECL (A_T, E_T, operator -, PFX, LTGT, X_T, Y_T); \
-  MARRAY_BINOP_DECL (A_T, E_T, operator *, PFX, LTGT, X_T, Y_T); \
-  MARRAY_BINOP_DECL (A_T, E_T, operator /, PFX, LTGT, X_T, Y_T);
+#define MARRAY_BINOP_DECLS(A_T, E_T, PFX, API, LTGT, X_T, Y_T) \
+  MARRAY_BINOP_DECL (A_T, E_T, operator +, PFX, API, LTGT, X_T, Y_T); \
+  MARRAY_BINOP_DECL (A_T, E_T, operator -, PFX, API, LTGT, X_T, Y_T); \
+  MARRAY_BINOP_DECL (A_T, E_T, operator *, PFX, API, LTGT, X_T, Y_T); \
+  MARRAY_BINOP_DECL (A_T, E_T, operator /, PFX, API, LTGT, X_T, Y_T);
 
-#define MARRAY_AA_BINOP_DECLS(A_T, E_T, PFX, LTGT) \
-  MARRAY_BINOP_DECL (A_T, E_T, operator +, PFX, LTGT, A_T<E_T>, A_T<E_T>); \
-  MARRAY_BINOP_DECL (A_T, E_T, operator -, PFX, LTGT, A_T<E_T>, A_T<E_T>); \
-  MARRAY_BINOP_DECL (A_T, E_T, quotient,   PFX, LTGT, A_T<E_T>, A_T<E_T>); \
-  MARRAY_BINOP_DECL (A_T, E_T, product,    PFX, LTGT, A_T<E_T>, A_T<E_T>);
+#define MARRAY_AA_BINOP_DECLS(A_T, E_T, PFX, API, LTGT) \
+  MARRAY_BINOP_DECL (A_T, E_T, operator +, PFX, API, LTGT, A_T<E_T>, A_T<E_T>); \
+  MARRAY_BINOP_DECL (A_T, E_T, operator -, PFX, API, LTGT, A_T<E_T>, A_T<E_T>); \
+  MARRAY_BINOP_DECL (A_T, E_T, quotient,   PFX, API, LTGT, A_T<E_T>, A_T<E_T>); \
+  MARRAY_BINOP_DECL (A_T, E_T, product,    PFX, API, LTGT, A_T<E_T>, A_T<E_T>);
 
-#define MDIAGARRAY2_DAS_BINOP_DECLS(A_T, E_T, PFX, LTGT, X_T, Y_T) \
-  MARRAY_BINOP_DECL (A_T, E_T, operator *, PFX, LTGT, X_T, Y_T); \
-  MARRAY_BINOP_DECL (A_T, E_T, operator /, PFX, LTGT, X_T, Y_T);
+#define MDIAGARRAY2_DAS_BINOP_DECLS(A_T, E_T, PFX, API, LTGT, X_T, Y_T) \
+  MARRAY_BINOP_DECL (A_T, E_T, operator *, PFX, API, LTGT, X_T, Y_T); \
+  MARRAY_BINOP_DECL (A_T, E_T, operator /, PFX, API, LTGT, X_T, Y_T);
 
-#define MDIAGARRAY2_SDA_BINOP_DECLS(A_T, E_T, PFX, LTGT, X_T, Y_T) \
-  MARRAY_BINOP_DECL (A_T, E_T, operator *, PFX, LTGT, X_T, Y_T);
+#define MDIAGARRAY2_SDA_BINOP_DECLS(A_T, E_T, PFX, API, LTGT, X_T, Y_T) \
+  MARRAY_BINOP_DECL (A_T, E_T, operator *, PFX, API, LTGT, X_T, Y_T);
 
-#define MDIAGARRAY2_DADA_BINOP_DECLS(A_T, E_T, PFX, LTGT) \
-  MARRAY_BINOP_DECL (A_T, E_T, operator +, PFX, LTGT, A_T<E_T>, A_T<E_T>); \
-  MARRAY_BINOP_DECL (A_T, E_T, operator -, PFX, LTGT, A_T<E_T>, A_T<E_T>); \
-  MARRAY_BINOP_DECL (A_T, E_T, product,    PFX, LTGT, A_T<E_T>, A_T<E_T>);
+#define MDIAGARRAY2_DADA_BINOP_DECLS(A_T, E_T, PFX, API, LTGT) \
+  MARRAY_BINOP_DECL (A_T, E_T, operator +, PFX, API, LTGT, A_T<E_T>, A_T<E_T>); \
+  MARRAY_BINOP_DECL (A_T, E_T, operator -, PFX, API, LTGT, A_T<E_T>, A_T<E_T>); \
+  MARRAY_BINOP_DECL (A_T, E_T, product,    PFX, API, LTGT, A_T<E_T>, A_T<E_T>);
 
 // Generate forward declarations for binary operators.
-#define MARRAY_BINOP_FWD_DECLS(A_T) \
-  MARRAY_BINOP_DECLS (A_T, T, template <typename T> OCTAVE_API, , A_T<T>, T) \
-  MARRAY_BINOP_DECLS (A_T, T, template <typename T> OCTAVE_API, , T, A_T<T>) \
-  MARRAY_AA_BINOP_DECLS (A_T, T, template <typename T> OCTAVE_API, )
+#define MARRAY_BINOP_FWD_DECLS(A_T, API) \
+  MARRAY_BINOP_DECLS (A_T, T, template <typename T>, API, , A_T<T>, T) \
+  MARRAY_BINOP_DECLS (A_T, T, template <typename T>, API, , T, A_T<T>) \
+  MARRAY_AA_BINOP_DECLS (A_T, T, template <typename T>, API, )
 
-#define MDIAGARRAY2_BINOP_FWD_DECLS(A_T) \
-  MDIAGARRAY2_DAS_BINOP_DECLS (A_T, T, template <typename T>, , A_T<T>, T) \
-  MDIAGARRAY2_SDA_BINOP_DECLS (A_T, T, template <typename T>, , T, A_T<T>) \
-  MDIAGARRAY2_DADA_BINOP_DECLS (A_T, T, template <typename T>, )
+#define MDIAGARRAY2_BINOP_FWD_DECLS(A_T, API) \
+  MDIAGARRAY2_DAS_BINOP_DECLS (A_T, T, template <typename T>, API, , A_T<T>, T) \
+  MDIAGARRAY2_SDA_BINOP_DECLS (A_T, T, template <typename T>, API, , T, A_T<T>) \
+  MDIAGARRAY2_DADA_BINOP_DECLS (A_T, T, template <typename T>, API, )
 
 // Generate friend declarations for the binary operators.
-#define MARRAY_BINOP_FRIENDS(A_T) \
-  MARRAY_BINOP_DECLS (A_T, T, friend, <>, A_T<T>, T) \
-  MARRAY_BINOP_DECLS (A_T, T, friend, <>, T, A_T<T>) \
-  MARRAY_AA_BINOP_DECLS (A_T, T, friend, <>)
+#define MARRAY_BINOP_FRIENDS(A_T, API) \
+  MARRAY_BINOP_DECLS (A_T, T, friend, API, <>, A_T<T>, T) \
+  MARRAY_BINOP_DECLS (A_T, T, friend, API, <>, T, A_T<T>) \
+  MARRAY_AA_BINOP_DECLS (A_T, T, friend, API, <>)
 
-#define MDIAGARRAY2_BINOP_FRIENDS(A_T) \
-  MDIAGARRAY2_DAS_BINOP_DECLS (A_T, T, friend, <>, A_T<T>, T) \
-  MDIAGARRAY2_SDA_BINOP_DECLS (A_T, T, friend, <>, T, A_T<T>) \
-  MDIAGARRAY2_DADA_BINOP_DECLS (A_T, T, friend, <>)
+#define MDIAGARRAY2_BINOP_FRIENDS(A_T, API) \
+  MDIAGARRAY2_DAS_BINOP_DECLS (A_T, T, friend, API, <>, A_T<T>, T) \
+  MDIAGARRAY2_SDA_BINOP_DECLS (A_T, T, friend, API, <>, T, A_T<T>) \
+  MDIAGARRAY2_DADA_BINOP_DECLS (A_T, T, friend, API, <>)
 
 // Instantiate the binary operators.
-#define MARRAY_BINOP_DEFS(A_T, E_T) \
-  MARRAY_BINOP_DECLS (A_T, E_T, template OCTAVE_API, , A_T<E_T>, E_T) \
-  MARRAY_BINOP_DECLS (A_T, E_T, template OCTAVE_API, , E_T, A_T<E_T>) \
-  MARRAY_AA_BINOP_DECLS (A_T, E_T, template OCTAVE_API, )
+#define MARRAY_BINOP_DEFS(A_T, E_T, API) \
+  MARRAY_BINOP_DECLS (A_T, E_T, template, API, , A_T<E_T>, E_T) \
+  MARRAY_BINOP_DECLS (A_T, E_T, template, API, , E_T, A_T<E_T>) \
+  MARRAY_AA_BINOP_DECLS (A_T, E_T, template, API, )
 
-#define MDIAGARRAY2_BINOP_DEFS(A_T, E_T) \
-  MDIAGARRAY2_DAS_BINOP_DECLS (A_T, E_T, template OCTAVE_API, , A_T<E_T>, E_T) \
-  MDIAGARRAY2_SDA_BINOP_DECLS (A_T, E_T, template OCTAVE_API, , E_T, A_T<E_T>) \
-  MDIAGARRAY2_DADA_BINOP_DECLS (A_T, E_T, template OCTAVE_API, )
+#define MDIAGARRAY2_BINOP_DEFS(A_T, E_T, API) \
+  MDIAGARRAY2_DAS_BINOP_DECLS (A_T, E_T, template, API, , A_T<E_T>, E_T) \
+  MDIAGARRAY2_SDA_BINOP_DECLS (A_T, E_T, template, API, , E_T, A_T<E_T>) \
+  MDIAGARRAY2_DADA_BINOP_DECLS (A_T, E_T, template, API, )
 
 // A function that can be used to forward binary operations from derived
 // classes back to us.
 #define MARRAY_BINOP_FWD_FCN(R, F, T, C_X, X_T, C_Y, Y_T) \
   inline R \
   F (const X_T& x, const Y_T& y) \
   { \
     return R (F (C_X (x), C_Y (y))); \
@@ -219,73 +219,73 @@
   MARRAY_BINOP_FWD_FCN (R, operator *, T, C_X, X_T, C_Y, Y_T)
 
 #define MDIAGARRAY2_DADA_BINOP_FWD_DEFS(R, T, C_X, X_T, C_Y, Y_T) \
   MARRAY_BINOP_FWD_FCN (R, operator +, T, C_X, X_T, C_Y, Y_T) \
   MARRAY_BINOP_FWD_FCN (R, operator -, T, C_X, X_T, C_Y, Y_T) \
   MARRAY_BINOP_FWD_FCN (R, product,    T, C_X, X_T, C_Y, Y_T)
 
 // Forward declarations for the MArray operators.
-#define MARRAY_OPS_FORWARD_DECLS(A_T) \
+#define MARRAY_OPS_FORWARD_DECLS(A_T, API) \
   template <class T> \
   class A_T; \
  \
-  MARRAY_OP_ASSIGN_FWD_DECLS (A_T, T) \
-  MARRAY_OP_ASSIGN_FWD_DECLS (A_T, A_T<T>) \
-  MARRAY_UNOP_FWD_DECLS (A_T) \
-  MARRAY_BINOP_FWD_DECLS (A_T)
+  MARRAY_OP_ASSIGN_FWD_DECLS (A_T, T, API) \
+  MARRAY_OP_ASSIGN_FWD_DECLS (A_T, A_T<T>, API) \
+  MARRAY_UNOP_FWD_DECLS (A_T, API) \
+  MARRAY_BINOP_FWD_DECLS (A_T, API)
 
-#define MDIAGARRAY2_OPS_FORWARD_DECLS(A_T) \
+#define MDIAGARRAY2_OPS_FORWARD_DECLS(A_T, API) \
   template <class T> \
   class A_T; \
  \
-  MARRAY_OP_ASSIGN_FWD_DECLS (A_T, A_T<T>) \
-  MARRAY_UNOP_FWD_DECLS (A_T) \
-  MDIAGARRAY2_BINOP_FWD_DECLS (A_T)
+  MARRAY_OP_ASSIGN_FWD_DECLS (A_T, A_T<T>, API) \
+  MARRAY_UNOP_FWD_DECLS (A_T, API) \
+  MDIAGARRAY2_BINOP_FWD_DECLS (A_T, API)
 
 // Friend declarations for the MArray operators.
-#define MARRAY_OPS_FRIEND_DECLS(A_T) \
-  MARRAY_OP_ASSIGN_FRIENDS (A_T, T) \
-  MARRAY_OP_ASSIGN_FRIENDS (A_T, A_T<T>) \
-  MARRAY_UNOP_FRIENDS (A_T) \
-  MARRAY_BINOP_FRIENDS (A_T)
+#define MARRAY_OPS_FRIEND_DECLS(A_T, API) \
+  MARRAY_OP_ASSIGN_FRIENDS (A_T, T, API) \
+  MARRAY_OP_ASSIGN_FRIENDS (A_T, A_T<T>, API) \
+  MARRAY_UNOP_FRIENDS (A_T, API) \
+  MARRAY_BINOP_FRIENDS (A_T, API)
 
-#define MDIAGARRAY2_OPS_FRIEND_DECLS(A_T) \
-  MARRAY_OP_ASSIGN_FRIENDS (A_T, A_T<T>) \
-  MARRAY_UNOP_FRIENDS (A_T) \
-  MDIAGARRAY2_BINOP_FRIENDS (A_T)
+#define MDIAGARRAY2_OPS_FRIEND_DECLS(A_T, API) \
+  MARRAY_OP_ASSIGN_FRIENDS (A_T, A_T<T>, API) \
+  MARRAY_UNOP_FRIENDS (A_T, API) \
+  MDIAGARRAY2_BINOP_FRIENDS (A_T, API)
 
 // The following macros are for external use.
 
 // Instantiate all the MArray friends for MArray element type T.
-#define INSTANTIATE_MARRAY_FRIENDS(T) \
-  MARRAY_OP_ASSIGN_DEFS (MArray, T, T) \
-  MARRAY_OP_ASSIGN_DEFS (MArray, T, MArray<T>) \
-  MARRAY_UNOP_DEFS (MArray, T) \
-  MARRAY_BINOP_DEFS (MArray, T)
+#define INSTANTIATE_MARRAY_FRIENDS(T, API) \
+  MARRAY_OP_ASSIGN_DEFS (MArray, T, T, API) \
+  MARRAY_OP_ASSIGN_DEFS (MArray, T, MArray<T>, API) \
+  MARRAY_UNOP_DEFS (MArray, T, API) \
+  MARRAY_BINOP_DEFS (MArray, T, API)
 
 // Instantiate all the MArray2 friends for MArray2 element type T.
-#define INSTANTIATE_MARRAY2_FRIENDS(T) \
-  MARRAY_OP_ASSIGN_DEFS (MArray2, T, T) \
-  MARRAY_OP_ASSIGN_DEFS (MArray2, T, MArray2<T>) \
-  MARRAY_UNOP_DEFS (MArray2, T) \
-  MARRAY_BINOP_DEFS (MArray2, T)
+#define INSTANTIATE_MARRAY2_FRIENDS(T, API) \
+  MARRAY_OP_ASSIGN_DEFS (MArray2, T, T, API) \
+  MARRAY_OP_ASSIGN_DEFS (MArray2, T, MArray2<T>, API) \
+  MARRAY_UNOP_DEFS (MArray2, T, API) \
+  MARRAY_BINOP_DEFS (MArray2, T, API)
 
 // Instantiate all the MArrayN friends for MArrayN element type T.
-#define INSTANTIATE_MARRAYN_FRIENDS(T) \
-  MARRAY_OP_ASSIGN_DEFS (MArrayN, T, T) \
-  MARRAY_OP_ASSIGN_DEFS (MArrayN, T, MArrayN<T>) \
-  MARRAY_UNOP_DEFS (MArrayN, T) \
-  MARRAY_BINOP_DEFS (MArrayN, T)
+#define INSTANTIATE_MARRAYN_FRIENDS(T, API) \
+  MARRAY_OP_ASSIGN_DEFS (MArrayN, T, T, API) \
+  MARRAY_OP_ASSIGN_DEFS (MArrayN, T, MArrayN<T>, API) \
+  MARRAY_UNOP_DEFS (MArrayN, T, API) \
+  MARRAY_BINOP_DEFS (MArrayN, T, API)
 
 // Instantiate all the MDiagArray2 friends for MDiagArray2 element type T.
-#define INSTANTIATE_MDIAGARRAY2_FRIENDS(T) \
-  MARRAY_OP_ASSIGN_DEFS (MDiagArray2, T, MDiagArray2<T>) \
-  MARRAY_UNOP_DEFS (MDiagArray2, T) \
-  MDIAGARRAY2_BINOP_DEFS (MDiagArray2, T)
+#define INSTANTIATE_MDIAGARRAY2_FRIENDS(T, API) \
+  MARRAY_OP_ASSIGN_DEFS (MDiagArray2, T, MDiagArray2<T>, API) \
+  MARRAY_UNOP_DEFS (MDiagArray2, T, API) \
+  MDIAGARRAY2_BINOP_DEFS (MDiagArray2, T, API)
 
 // Define all the MArray forwarding functions for return type R and
 // MArray element type T
 #define MARRAY_FORWARD_DEFS(B, R, T) \
   MARRAY_OP_ASSIGN_FWD_DEFS \
     (R, T, dynamic_cast<B<T>&>, R, , T) \
  \
   MARRAY_OP_ASSIGN_FWD_DEFS \
diff --git a/liboctave/MArray-i.cc b/liboctave/MArray-i.cc
--- a/liboctave/MArray-i.cc
+++ b/liboctave/MArray-i.cc
@@ -27,80 +27,80 @@ 02110-1301, USA.
 
 #include "oct-inttypes.h"
 
 // Instantiate MArrays of int values.
 
 #include "MArray.h"
 #include "MArray.cc"
 
-template class MArray<int>;
-template class MArray<long>;
+template class OCTAVE_API MArray<int>;
+template class OCTAVE_API MArray<long>;
 
-INSTANTIATE_MARRAY_FRIENDS (int)
-INSTANTIATE_MARRAY_FRIENDS (long)
+INSTANTIATE_MARRAY_FRIENDS (int, OCTAVE_API)
+INSTANTIATE_MARRAY_FRIENDS (long, OCTAVE_API)
 
-template class MArray<octave_int8>;
-template class MArray<octave_int16>;
-template class MArray<octave_int32>;
-template class MArray<octave_int64>;
+template class OCTAVE_API MArray<octave_int8>;
+template class OCTAVE_API MArray<octave_int16>;
+template class OCTAVE_API MArray<octave_int32>;
+template class OCTAVE_API MArray<octave_int64>;
 
-INSTANTIATE_MARRAY_FRIENDS (octave_int8)
-INSTANTIATE_MARRAY_FRIENDS (octave_int16)
-INSTANTIATE_MARRAY_FRIENDS (octave_int32)
-INSTANTIATE_MARRAY_FRIENDS (octave_int64)
+INSTANTIATE_MARRAY_FRIENDS (octave_int8, OCTAVE_API)
+INSTANTIATE_MARRAY_FRIENDS (octave_int16, OCTAVE_API)
+INSTANTIATE_MARRAY_FRIENDS (octave_int32, OCTAVE_API)
+INSTANTIATE_MARRAY_FRIENDS (octave_int64, OCTAVE_API)
 
-template class MArray<octave_uint8>;
-template class MArray<octave_uint16>;
-template class MArray<octave_uint32>;
-template class MArray<octave_uint64>;
+template class OCTAVE_API MArray<octave_uint8>;
+template class OCTAVE_API MArray<octave_uint16>;
+template class OCTAVE_API MArray<octave_uint32>;
+template class OCTAVE_API MArray<octave_uint64>;
 
-INSTANTIATE_MARRAY_FRIENDS (octave_uint8)
-INSTANTIATE_MARRAY_FRIENDS (octave_uint16)
-INSTANTIATE_MARRAY_FRIENDS (octave_uint32)
-INSTANTIATE_MARRAY_FRIENDS (octave_uint64)
+INSTANTIATE_MARRAY_FRIENDS (octave_uint8, OCTAVE_API)
+INSTANTIATE_MARRAY_FRIENDS (octave_uint16, OCTAVE_API)
+INSTANTIATE_MARRAY_FRIENDS (octave_uint32, OCTAVE_API)
+INSTANTIATE_MARRAY_FRIENDS (octave_uint64, OCTAVE_API)
 
 #include "MArray2.h"
 #include "MArray2.cc"
 
-template class MArray2<int>;
+template class OCTAVE_API MArray2<int>;
 
-INSTANTIATE_MARRAY2_FRIENDS (int)
+INSTANTIATE_MARRAY2_FRIENDS (int, OCTAVE_API)
 
 #include "MArrayN.h"
 #include "MArrayN.cc"
 
-template class MArrayN<int>;
+template class OCTAVE_API MArrayN<int>;
 
-INSTANTIATE_MARRAYN_FRIENDS (int)
+INSTANTIATE_MARRAYN_FRIENDS (int, OCTAVE_API)
 
-template class MArrayN<octave_int8>;
-template class MArrayN<octave_int16>;
-template class MArrayN<octave_int32>;
-template class MArrayN<octave_int64>;
+template class OCTAVE_API MArrayN<octave_int8>;
+template class OCTAVE_API MArrayN<octave_int16>;
+template class OCTAVE_API MArrayN<octave_int32>;
+template class OCTAVE_API MArrayN<octave_int64>;
 
-INSTANTIATE_MARRAYN_FRIENDS (octave_int8)
-INSTANTIATE_MARRAYN_FRIENDS (octave_int16)
-INSTANTIATE_MARRAYN_FRIENDS (octave_int32)
-INSTANTIATE_MARRAYN_FRIENDS (octave_int64)
+INSTANTIATE_MARRAYN_FRIENDS (octave_int8, OCTAVE_API)
+INSTANTIATE_MARRAYN_FRIENDS (octave_int16, OCTAVE_API)
+INSTANTIATE_MARRAYN_FRIENDS (octave_int32, OCTAVE_API)
+INSTANTIATE_MARRAYN_FRIENDS (octave_int64, OCTAVE_API)
 
-template class MArrayN<octave_uint8>;
-template class MArrayN<octave_uint16>;
-template class MArrayN<octave_uint32>;
-template class MArrayN<octave_uint64>;
+template class OCTAVE_API MArrayN<octave_uint8>;
+template class OCTAVE_API MArrayN<octave_uint16>;
+template class OCTAVE_API MArrayN<octave_uint32>;
+template class OCTAVE_API MArrayN<octave_uint64>;
 
-INSTANTIATE_MARRAYN_FRIENDS (octave_uint8)
-INSTANTIATE_MARRAYN_FRIENDS (octave_uint16)
-INSTANTIATE_MARRAYN_FRIENDS (octave_uint32)
-INSTANTIATE_MARRAYN_FRIENDS (octave_uint64)
+INSTANTIATE_MARRAYN_FRIENDS (octave_uint8, OCTAVE_API)
+INSTANTIATE_MARRAYN_FRIENDS (octave_uint16, OCTAVE_API)
+INSTANTIATE_MARRAYN_FRIENDS (octave_uint32, OCTAVE_API)
+INSTANTIATE_MARRAYN_FRIENDS (octave_uint64, OCTAVE_API)
 
 #include "MDiagArray2.h"
 #include "MDiagArray2.cc"
 
-template class MDiagArray2<int>;
+template class OCTAVE_API MDiagArray2<int>;
 
-INSTANTIATE_MDIAGARRAY2_FRIENDS (int)
+INSTANTIATE_MDIAGARRAY2_FRIENDS (int, OCTAVE_API)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/MArray-s.cc b/liboctave/MArray-s.cc
--- a/liboctave/MArray-s.cc
+++ b/liboctave/MArray-s.cc
@@ -25,31 +25,31 @@ 02110-1301, USA.
 #include <config.h>
 #endif
 
 // Instantiate MArrays of short int values.
 
 #include "MArray.h"
 #include "MArray.cc"
 
-template class MArray<short>;
+template class OCTAVE_API MArray<short>;
 
-INSTANTIATE_MARRAY_FRIENDS (short)
+INSTANTIATE_MARRAY_FRIENDS (short, OCTAVE_API)
 
 #include "MArray2.h"
 #include "MArray2.cc"
 
-template class MArray2<short>;
+template class OCTAVE_API MArray2<short>;
 
-INSTANTIATE_MARRAY2_FRIENDS (short)
+INSTANTIATE_MARRAY2_FRIENDS (short, OCTAVE_API)
 
 #include "MDiagArray2.h"
 #include "MDiagArray2.cc"
 
-template class MDiagArray2<short>;
+template class OCTAVE_API MDiagArray2<short>;
 
-INSTANTIATE_MDIAGARRAY2_FRIENDS (short)
+INSTANTIATE_MDIAGARRAY2_FRIENDS (short, OCTAVE_API)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/MArray.h b/liboctave/MArray.h
--- a/liboctave/MArray.h
+++ b/liboctave/MArray.h
@@ -28,17 +28,17 @@ 02110-1301, USA.
 #include "Array.h"
 
 // One dimensional array with math ops.
 
 // But first, some preprocessor abuse...
 
 #include "MArray-defs.h"
 
-MARRAY_OPS_FORWARD_DECLS (MArray)
+MARRAY_OPS_FORWARD_DECLS (MArray, )
 
 template <class T>
 class
 MArray : public Array<T>
 {
 protected:
 
   MArray (T *d, octave_idx_type l) : Array<T> (d, l) { }
diff --git a/liboctave/MArray2.h b/liboctave/MArray2.h
--- a/liboctave/MArray2.h
+++ b/liboctave/MArray2.h
@@ -28,17 +28,17 @@ 02110-1301, USA.
 #include "Array2.h"
 
 // Two dimensional array with math ops.
 
 // But first, some preprocessor abuse...
 
 #include "MArray-defs.h"
 
-MARRAY_OPS_FORWARD_DECLS (MArray2)
+MARRAY_OPS_FORWARD_DECLS (MArray2, )
 
 template <class T>
 class
 MArray2 : public Array2<T>
 {
 protected:
 
   MArray2 (T *d, octave_idx_type n, octave_idx_type m) : Array2<T> (d, n, m) { }
diff --git a/liboctave/MArrayN.h b/liboctave/MArrayN.h
--- a/liboctave/MArrayN.h
+++ b/liboctave/MArrayN.h
@@ -30,17 +30,17 @@ 02110-1301, USA.
 #include "dim-vector.h"
 
 // N-dimensional array with math ops.
 
 // But first, some preprocessor abuse...
 
 #include "MArray-defs.h"
 
-MARRAY_OPS_FORWARD_DECLS (MArrayN)
+MARRAY_OPS_FORWARD_DECLS (MArrayN, )
 
 template <class T>
 class
 MArrayN : public ArrayN<T>
 {
 protected:
 
   MArrayN (T *d, const dim_vector& dv) : ArrayN<T> (d, dv) { }
diff --git a/liboctave/MDiagArray2.h b/liboctave/MDiagArray2.h
--- a/liboctave/MDiagArray2.h
+++ b/liboctave/MDiagArray2.h
@@ -29,17 +29,17 @@ 02110-1301, USA.
 #include "MArray2.h"
 
 // Two dimensional diagonal array with math ops.
 
 // But first, some preprocessor abuse...
 
 #include "MArray-defs.h"
 
-MDIAGARRAY2_OPS_FORWARD_DECLS (MDiagArray2)
+MDIAGARRAY2_OPS_FORWARD_DECLS (MDiagArray2, )
 
 template <class T>
 class
 MDiagArray2 : public DiagArray2<T>
 {
 protected:
 
   MDiagArray2 (T *d, octave_idx_type r, octave_idx_type c) : DiagArray2<T> (d, r, c) { }
diff --git a/liboctave/MSparse-C.cc b/liboctave/MSparse-C.cc
--- a/liboctave/MSparse-C.cc
+++ b/liboctave/MSparse-C.cc
@@ -26,15 +26,15 @@ Boston, MA 02110-1301, USA.
 
 #include "oct-cmplx.h"
 
 #include "MSparse.h"
 #include "MSparse.cc"
 
 template class OCTAVE_API MSparse<Complex>;
 
-INSTANTIATE_SPARSE_FRIENDS (Complex);
+INSTANTIATE_SPARSE_FRIENDS (Complex, OCTAVE_API);
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/MSparse-d.cc b/liboctave/MSparse-d.cc
--- a/liboctave/MSparse-d.cc
+++ b/liboctave/MSparse-d.cc
@@ -24,15 +24,15 @@ Boston, MA 02110-1301, USA.
 #include <config.h>
 #endif
 
 #include "MSparse.h"
 #include "MSparse.cc"
 
 template class OCTAVE_API MSparse<double>;
 
-INSTANTIATE_SPARSE_FRIENDS (double);
+INSTANTIATE_SPARSE_FRIENDS (double, OCTAVE_API);
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/MSparse-defs.h b/liboctave/MSparse-defs.h
--- a/liboctave/MSparse-defs.h
+++ b/liboctave/MSparse-defs.h
@@ -21,124 +21,124 @@ Boston, MA 02110-1301, USA.
 */
 
 #if !defined (octave_MSparse_defs_h)
 #define octave_MSparse_defs_h 1
 
 // Nothing like a little CPP abuse to brighten everyone's day.
 
 // A macro that can be used to declare and instantiate OP= operators.
-#define SPARSE_OP_ASSIGN_DECL(A_T, E_T, OP, PFX, LTGT, RHS_T) \
-  PFX A_T<E_T>& \
+#define SPARSE_OP_ASSIGN_DECL(A_T, E_T, OP, PFX, API, LTGT, RHS_T) \
+  PFX API A_T<E_T>& \
   operator OP LTGT (A_T<E_T>&, const RHS_T&)
 
 // All the OP= operators that we care about.
-#define SPARSE_OP_ASSIGN_DECLS(A_T, E_T, PFX, LTGT, RHS_T) \
-  SPARSE_OP_ASSIGN_DECL (A_T, E_T, +=, PFX, LTGT, RHS_T); \
-  SPARSE_OP_ASSIGN_DECL (A_T, E_T, -=, PFX, LTGT, RHS_T);
+#define SPARSE_OP_ASSIGN_DECLS(A_T, E_T, PFX, API, LTGT, RHS_T) \
+  SPARSE_OP_ASSIGN_DECL (A_T, E_T, +=, PFX, API, LTGT, RHS_T); \
+  SPARSE_OP_ASSIGN_DECL (A_T, E_T, -=, PFX, API, LTGT, RHS_T);
 
 // Generate forward declarations for OP= operators.
-#define SPARSE_OP_ASSIGN_FWD_DECLS(A_T, RHS_T) \
-  SPARSE_OP_ASSIGN_DECLS (A_T, T, template <typename T>, , RHS_T)
+#define SPARSE_OP_ASSIGN_FWD_DECLS(A_T, RHS_T, API) \
+  SPARSE_OP_ASSIGN_DECLS (A_T, T, template <typename T>, API, , RHS_T)
 
 // Generate friend declarations for the OP= operators.
-#define SPARSE_OP_ASSIGN_FRIENDS(A_T, RHS_T) \
-  SPARSE_OP_ASSIGN_DECLS (A_T, T, friend, <>, RHS_T)
+#define SPARSE_OP_ASSIGN_FRIENDS(A_T, RHS_T, API) \
+  SPARSE_OP_ASSIGN_DECLS (A_T, T, friend, API, <>, RHS_T)
 
 // Instantiate the OP= operators.
-#define SPARSE_OP_ASSIGN_DEFS(A_T, E_T, RHS_T) \
-  SPARSE_OP_ASSIGN_DECLS (A_T, E_T, template OCTAVE_API, , RHS_T)
+#define SPARSE_OP_ASSIGN_DEFS(A_T, E_T, RHS_T, API) \
+  SPARSE_OP_ASSIGN_DECLS (A_T, E_T, template, API, , RHS_T)
 
 // A function that can be used to forward OP= operations from derived
 // classes back to us.
 #define SPARSE_OP_ASSIGN_FWD_FCN(R, F, T, C_X, X_T, C_Y, Y_T) \
   inline R \
   F (X_T& x, const Y_T& y) \
   { \
     return R (F (C_X (x), C_Y (y))); \
   }
 
 // All the OP= operators that we care about forwarding.
 #define SPARSE_OP_ASSIGN_FWD_DEFS(R, T, C_X, X_T, C_Y, Y_T) \
   SPARSE_OP_ASSIGN_FWD_FCN (R, operator +=, T, C_X, X_T, C_Y, Y_T) \
   SPARSE_OP_ASSIGN_FWD_FCN (R, operator -=, T, C_X, X_T, C_Y, Y_T)
 
 // A macro that can be used to declare and instantiate unary operators.
-#define SPARSE_UNOP(A_T, E_T, F, PFX, LTGT) \
-  PFX A_T<E_T> \
+#define SPARSE_UNOP(A_T, E_T, F, PFX, API, LTGT) \
+  PFX API A_T<E_T> \
   F LTGT (const A_T<E_T>&)
 
 // All the unary operators that we care about.
-#define SPARSE_UNOP_DECLS(A_T, E_T, PFX, LTGT) \
-  SPARSE_UNOP (A_T, E_T, operator +, PFX, LTGT); \
-  SPARSE_UNOP (A_T, E_T, operator -, PFX, LTGT);
+#define SPARSE_UNOP_DECLS(A_T, E_T, PFX, API, LTGT) \
+  SPARSE_UNOP (A_T, E_T, operator +, PFX, API, LTGT); \
+  SPARSE_UNOP (A_T, E_T, operator -, PFX, API, LTGT);
 
 // Generate forward declarations for unary operators.
-#define SPARSE_UNOP_FWD_DECLS(A_T) \
-  SPARSE_UNOP_DECLS (A_T, T, template <typename T>, )
+#define SPARSE_UNOP_FWD_DECLS(A_T, API) \
+  SPARSE_UNOP_DECLS (A_T, T, template <typename T>, API, )
 
 // Generate friend declarations for the unary operators.
-#define SPARSE_UNOP_FRIENDS(A_T) \
-  SPARSE_UNOP_DECLS (A_T, T, friend, <>)
+#define SPARSE_UNOP_FRIENDS(A_T, API) \
+  SPARSE_UNOP_DECLS (A_T, T, friend, API, <>)
 
 // Instantiate the unary operators.
-#define SPARSE_UNOP_DEFS(A_T, E_T) \
-  SPARSE_UNOP_DECLS (A_T, E_T, template OCTAVE_API, )
+#define SPARSE_UNOP_DEFS(A_T, E_T, API) \
+  SPARSE_UNOP_DECLS (A_T, E_T, template, API, )
 
 // A function that can be used to forward unary operations from derived
 // classes back to us.
 #define SPARSE_UNOP_FWD_FCN(R, F, T, C_X, X_T) \
   inline R \
   F (const X_T& x) \
   { \
     return R (F (C_X (x))); \
   }
 
 // All the unary operators that we care about forwarding.
 #define SPARSE_UNOP_FWD_DEFS(R, T, C_X, X_T) \
   SPARSE_UNOP_FWD_FCN (R, operator +, T, C_X, X_T) \
   SPARSE_UNOP_FWD_FCN (R, operator -, T, C_X, X_T)
 
 // A macro that can be used to declare and instantiate binary operators.
-#define SPARSE_BINOP_DECL(A_T, E_T, F, PFX, LTGT, X_T, Y_T) \
-  PFX A_T<E_T> \
+#define SPARSE_BINOP_DECL(A_T, E_T, F, PFX, API, LTGT, X_T, Y_T) \
+  PFX API A_T<E_T> \
   F LTGT (const X_T&, const Y_T&)
 
 // All the binary operators that we care about.  We have two
 // sets of macros since the MArray OP MArray operations use functions
 // (product and quotient) instead of operators (*, /).
-#define SPARSE_BINOP_DECLS(A_T, F_T, E_T, PFX, LTGT, X_T, Y_T)	 \
-  SPARSE_BINOP_DECL (F_T, E_T, operator +, PFX, LTGT, X_T, Y_T); \
-  SPARSE_BINOP_DECL (F_T, E_T, operator -, PFX, LTGT, X_T, Y_T); \
-  SPARSE_BINOP_DECL (A_T, E_T, operator *, PFX, LTGT, X_T, Y_T); \
-  SPARSE_BINOP_DECL (A_T, E_T, operator /, PFX, LTGT, X_T, Y_T);
+#define SPARSE_BINOP_DECLS(A_T, F_T, E_T, PFX, API, LTGT, X_T, Y_T)	 \
+  SPARSE_BINOP_DECL (F_T, E_T, operator +, PFX, API, LTGT, X_T, Y_T); \
+  SPARSE_BINOP_DECL (F_T, E_T, operator -, PFX, API, LTGT, X_T, Y_T); \
+  SPARSE_BINOP_DECL (A_T, E_T, operator *, PFX, API, LTGT, X_T, Y_T); \
+  SPARSE_BINOP_DECL (A_T, E_T, operator /, PFX, API, LTGT, X_T, Y_T);
 
-#define SPARSE_AA_BINOP_DECLS(A_T, E_T, PFX, LTGT) \
-  SPARSE_BINOP_DECL (A_T, E_T, operator +, PFX, LTGT, A_T<E_T>, A_T<E_T>); \
-  SPARSE_BINOP_DECL (A_T, E_T, operator -, PFX, LTGT, A_T<E_T>, A_T<E_T>); \
-  SPARSE_BINOP_DECL (A_T, E_T, quotient,   PFX, LTGT, A_T<E_T>, A_T<E_T>); \
-  SPARSE_BINOP_DECL (A_T, E_T, product,    PFX, LTGT, A_T<E_T>, A_T<E_T>);
+#define SPARSE_AA_BINOP_DECLS(A_T, E_T, PFX, API, LTGT) \
+  SPARSE_BINOP_DECL (A_T, E_T, operator +, PFX, API, LTGT, A_T<E_T>, A_T<E_T>); \
+  SPARSE_BINOP_DECL (A_T, E_T, operator -, PFX, API, LTGT, A_T<E_T>, A_T<E_T>); \
+  SPARSE_BINOP_DECL (A_T, E_T, quotient,   PFX, API, LTGT, A_T<E_T>, A_T<E_T>); \
+  SPARSE_BINOP_DECL (A_T, E_T, product,    PFX, API, LTGT, A_T<E_T>, A_T<E_T>);
 
 // Generate forward declarations for binary operators.
-#define SPARSE_BINOP_FWD_DECLS(A_T, F_T) \
-  SPARSE_BINOP_DECLS (A_T, F_T, T, template <typename T>, , A_T<T>, T)	\
-  SPARSE_BINOP_DECLS (A_T, F_T, T, template <typename T>, , T, A_T<T>) \
-  SPARSE_AA_BINOP_DECLS (A_T, T, template <typename T>, )
+#define SPARSE_BINOP_FWD_DECLS(A_T, F_T, API) \
+  SPARSE_BINOP_DECLS (A_T, F_T, T, template <typename T>, API, , A_T<T>, T)	\
+  SPARSE_BINOP_DECLS (A_T, F_T, T, template <typename T>, API, , T, A_T<T>) \
+  SPARSE_AA_BINOP_DECLS (A_T, T, template <typename T>, API, )
 
 // Generate friend declarations for the binary operators.
-#define SPARSE_BINOP_FRIENDS(A_T, F_T)		     \
-  SPARSE_BINOP_DECLS (A_T, F_T, T, friend, <>, A_T<T>, T)	\
-  SPARSE_BINOP_DECLS (A_T, F_T, T, friend, <>, T, A_T<T>)	\
-  SPARSE_AA_BINOP_DECLS (A_T, T, friend, <>)
+#define SPARSE_BINOP_FRIENDS(A_T, F_T, API)		     \
+  SPARSE_BINOP_DECLS (A_T, F_T, T, friend, API, <>, A_T<T>, T)	\
+  SPARSE_BINOP_DECLS (A_T, F_T, T, friend, API, <>, T, A_T<T>)	\
+  SPARSE_AA_BINOP_DECLS (A_T, T, friend, API, <>)
 
 // Instantiate the binary operators.
-#define SPARSE_BINOP_DEFS(A_T, F_T, E_T) \
-  SPARSE_BINOP_DECLS (A_T, F_T, E_T, template OCTAVE_API, , A_T<E_T>, E_T)	\
-  SPARSE_BINOP_DECLS (A_T, F_T, E_T, template OCTAVE_API, , E_T, A_T<E_T>)	\
-  SPARSE_AA_BINOP_DECLS (A_T, E_T, template OCTAVE_API, )
+#define SPARSE_BINOP_DEFS(A_T, F_T, E_T, API) \
+  SPARSE_BINOP_DECLS (A_T, F_T, E_T, template, API, , A_T<E_T>, E_T)	\
+  SPARSE_BINOP_DECLS (A_T, F_T, E_T, template, API, , E_T, A_T<E_T>)	\
+  SPARSE_AA_BINOP_DECLS (A_T, E_T, template, API, )
 
 // A function that can be used to forward binary operations from derived
 // classes back to us.
 #define SPARSE_BINOP_FWD_FCN(R, F, T, C_X, X_T, C_Y, Y_T) \
   inline R \
   F (const X_T& x, const Y_T& y) \
   { \
     return R (F (C_X (x), C_Y (y))); \
@@ -155,40 +155,40 @@ Boston, MA 02110-1301, USA.
 
 #define SPARSE_AA_BINOP_FWD_DEFS(R, T, C_X, X_T, C_Y, Y_T) \
   SPARSE_BINOP_FWD_FCN (R, operator +, T, C_X, X_T, C_Y, Y_T) \
   SPARSE_BINOP_FWD_FCN (R, operator -, T, C_X, X_T, C_Y, Y_T) \
   SPARSE_BINOP_FWD_FCN (R, product,    T, C_X, X_T, C_Y, Y_T) \
   SPARSE_BINOP_FWD_FCN (R, quotient,   T, C_X, X_T, C_Y, Y_T)
 
 // Forward declarations for the MSparse operators.
-#define SPARSE_OPS_FORWARD_DECLS(A_T, F_T) \
+#define SPARSE_OPS_FORWARD_DECLS(A_T, F_T, API) \
   template <class T> \
   class A_T; \
  \
   /* SPARSE_OP_ASSIGN_FWD_DECLS (A_T, T) */ \
-  SPARSE_OP_ASSIGN_FWD_DECLS (A_T, A_T<T>) \
-  SPARSE_UNOP_FWD_DECLS (A_T) \
-  SPARSE_BINOP_FWD_DECLS (A_T, F_T)
+  SPARSE_OP_ASSIGN_FWD_DECLS (A_T, A_T<T>, API) \
+  SPARSE_UNOP_FWD_DECLS (A_T, API) \
+  SPARSE_BINOP_FWD_DECLS (A_T, F_T, API)
 
 // Friend declarations for the MSparse operators.
-#define SPARSE_OPS_FRIEND_DECLS(A_T, F_T)  \
+#define SPARSE_OPS_FRIEND_DECLS(A_T, F_T, API)  \
   /* SPARSE_OP_ASSIGN_FRIENDS (A_T, T) */ \
-  SPARSE_OP_ASSIGN_FRIENDS (A_T, A_T<T>) \
-  SPARSE_UNOP_FRIENDS (A_T) \
-    SPARSE_BINOP_FRIENDS (A_T, F_T)
+  SPARSE_OP_ASSIGN_FRIENDS (A_T, A_T<T>, API) \
+  SPARSE_UNOP_FRIENDS (A_T, API) \
+    SPARSE_BINOP_FRIENDS (A_T, F_T, API)
 
 // The following macros are for external use.
 
 // Instantiate all the MSparse friends for MSparse element type T.
-#define INSTANTIATE_SPARSE_FRIENDS(T) \
+#define INSTANTIATE_SPARSE_FRIENDS(T, API) \
   /* SPARSE_OP_ASSIGN_DEFS (MSparse, T, T) */ \
-  SPARSE_OP_ASSIGN_DEFS (MSparse, T, MSparse<T>) \
-  SPARSE_UNOP_DEFS (MSparse, T) \
-  SPARSE_BINOP_DEFS (MSparse, MArray2, T)
+  SPARSE_OP_ASSIGN_DEFS (MSparse, T, MSparse<T>, API) \
+  SPARSE_UNOP_DEFS (MSparse, T, API) \
+  SPARSE_BINOP_DEFS (MSparse, MArray2, T, API)
 
 // Define all the MSparse forwarding functions for return type R and
 // MSparse element type T
 #define SPARSE_FORWARD_DEFS(B, R, F, T) 	\
   /* SPARSE_OP_ASSIGN_FWD_DEFS	*/ \
   /* (R, T, dynamic_cast<B<T>&>, R, , T) */	\
  \
   SPARSE_OP_ASSIGN_FWD_DEFS \
diff --git a/liboctave/MSparse.h b/liboctave/MSparse.h
--- a/liboctave/MSparse.h
+++ b/liboctave/MSparse.h
@@ -28,17 +28,17 @@ Boston, MA 02110-1301, USA.
 #include "Sparse.h"
 
 // Two dimensional sparse array with math ops.
 
 // But first, some preprocessor abuse...
 
 #include "MSparse-defs.h"
 
-SPARSE_OPS_FORWARD_DECLS (MSparse, MArray2)
+SPARSE_OPS_FORWARD_DECLS (MSparse, MArray2, )
 
 template <class T>
 class
 MSparse : public Sparse<T>
 {
 public:
 
   MSparse (void) : Sparse<T> () { }
diff --git a/liboctave/Sparse-C.cc b/liboctave/Sparse-C.cc
--- a/liboctave/Sparse-C.cc
+++ b/liboctave/Sparse-C.cc
@@ -26,19 +26,19 @@ Boston, MA 02110-1301, USA.
 
 // Instantiate Sparse matrix of complex values.
 
 #include "oct-cmplx.h"
 
 #include "Sparse.h"
 #include "Sparse.cc"
 
-INSTANTIATE_SPARSE_AND_ASSIGN (Complex);
+INSTANTIATE_SPARSE_AND_ASSIGN (Complex, OCTAVE_API);
 
-INSTANTIATE_SPARSE_ASSIGN (Complex, double);
+INSTANTIATE_SPARSE_ASSIGN (Complex, double, OCTAVE_API);
 
 #if 0
 template std::ostream& operator << (std::ostream&, const Sparse<Complex>&);
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/Sparse-b.cc b/liboctave/Sparse-b.cc
--- a/liboctave/Sparse-b.cc
+++ b/liboctave/Sparse-b.cc
@@ -24,17 +24,17 @@ Boston, MA 02110-1301, USA.
 #include <config.h>
 #endif
 
 // Instantiate Sparse matrix of double values.
 
 #include "Sparse.h"
 #include "Sparse.cc"
 
-INSTANTIATE_SPARSE_AND_ASSIGN (bool);
+INSTANTIATE_SPARSE_AND_ASSIGN (bool, OCTAVE_API);
 
 #if 0
 template std::ostream& operator << (std::ostream&, const Sparse<bool>&);
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/Sparse-d.cc b/liboctave/Sparse-d.cc
--- a/liboctave/Sparse-d.cc
+++ b/liboctave/Sparse-d.cc
@@ -24,17 +24,17 @@ Boston, MA 02110-1301, USA.
 #include <config.h>
 #endif
 
 // Instantiate Sparse matrix of double values.
 
 #include "Sparse.h"
 #include "Sparse.cc"
 
-INSTANTIATE_SPARSE_AND_ASSIGN (double);
+INSTANTIATE_SPARSE_AND_ASSIGN (double, OCTAVE_API);
 
 #if 0
 template std::ostream& operator << (std::ostream&, const Sparse<double>&);
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/Sparse-op-defs.h b/liboctave/Sparse-op-defs.h
--- a/liboctave/Sparse-op-defs.h
+++ b/liboctave/Sparse-op-defs.h
@@ -21,32 +21,32 @@ Boston, MA 02110-1301, USA.
 */
 
 #if !defined (octave_sparse_op_defs_h)
 #define octave_sparse_op_defs_h 1
 
 #include "Array-util.h"
 #include "mx-ops.h"
 
-#define SPARSE_BIN_OP_DECL(R, OP, X, Y) \
-  extern OCTAVE_API R OP (const X&, const Y&)
+#define SPARSE_BIN_OP_DECL(R, OP, X, Y, API) \
+  extern API R OP (const X&, const Y&)
 
-#define SPARSE_CMP_OP_DECL(OP, X, Y) \
-  extern OCTAVE_API SparseBoolMatrix OP (const X&, const Y&)
+#define SPARSE_CMP_OP_DECL(OP, X, Y, API) \
+  extern API SparseBoolMatrix OP (const X&, const Y&)
 
-#define SPARSE_BOOL_OP_DECL(OP, X, Y) \
-  extern OCTAVE_API SparseBoolMatrix OP (const X&, const Y&)
+#define SPARSE_BOOL_OP_DECL(OP, X, Y, API) \
+  extern API SparseBoolMatrix OP (const X&, const Y&)
 
 // matrix by scalar operations.
 
-#define SPARSE_SMS_BIN_OP_DECLS(R1, R2, M, S)  \
-  SPARSE_BIN_OP_DECL (R1, operator +, M, S); \
-  SPARSE_BIN_OP_DECL (R1, operator -, M, S); \
-  SPARSE_BIN_OP_DECL (R2, operator *, M, S); \
-  SPARSE_BIN_OP_DECL (R2, operator /, M, S);
+#define SPARSE_SMS_BIN_OP_DECLS(R1, R2, M, S, API)  \
+  SPARSE_BIN_OP_DECL (R1, operator +, M, S, API); \
+  SPARSE_BIN_OP_DECL (R1, operator -, M, S, API); \
+  SPARSE_BIN_OP_DECL (R2, operator *, M, S, API); \
+  SPARSE_BIN_OP_DECL (R2, operator /, M, S, API);
 
 #define SPARSE_SMS_BIN_OP_1(R, F, OP, M, S)	\
   R \
   F (const M& m, const S& s) \
   { \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
  \
@@ -81,27 +81,27 @@ Boston, MA 02110-1301, USA.
   }
 
 #define SPARSE_SMS_BIN_OPS(R1, R2, M, S) \
   SPARSE_SMS_BIN_OP_1 (R1, operator +, +, M, S) \
   SPARSE_SMS_BIN_OP_1 (R1, operator -, -, M, S) \
   SPARSE_SMS_BIN_OP_2 (R2, operator *, *, M, S) \
   SPARSE_SMS_BIN_OP_2 (R2, operator /, /, M, S)
 
-#define SPARSE_SMS_CMP_OP_DECLS(M, S) \
-  SPARSE_CMP_OP_DECL (mx_el_lt, M, S); \
-  SPARSE_CMP_OP_DECL (mx_el_le, M, S); \
-  SPARSE_CMP_OP_DECL (mx_el_ge, M, S); \
-  SPARSE_CMP_OP_DECL (mx_el_gt, M, S); \
-  SPARSE_CMP_OP_DECL (mx_el_eq, M, S); \
-  SPARSE_CMP_OP_DECL (mx_el_ne, M, S);
+#define SPARSE_SMS_CMP_OP_DECLS(M, S, API) \
+  SPARSE_CMP_OP_DECL (mx_el_lt, M, S, API); \
+  SPARSE_CMP_OP_DECL (mx_el_le, M, S, API); \
+  SPARSE_CMP_OP_DECL (mx_el_ge, M, S, API); \
+  SPARSE_CMP_OP_DECL (mx_el_gt, M, S, API); \
+  SPARSE_CMP_OP_DECL (mx_el_eq, M, S, API); \
+  SPARSE_CMP_OP_DECL (mx_el_ne, M, S, API);
 
-#define SPARSE_SMS_EQNE_OP_DECLS(M, S) \
-  SPARSE_CMP_OP_DECL (mx_el_eq, M, S); \
-  SPARSE_CMP_OP_DECL (mx_el_ne, M, S);
+#define SPARSE_SMS_EQNE_OP_DECLS(M, S, API) \
+  SPARSE_CMP_OP_DECL (mx_el_eq, M, S, API); \
+  SPARSE_CMP_OP_DECL (mx_el_ne, M, S, API);
 
 #define SPARSE_SMS_CMP_OP(F, OP, M, MZ, MC, S, SZ, SC)	\
   SparseBoolMatrix \
   F (const M& m, const S& s) \
   { \
     /* Count num of non-zero elements */ \
     octave_idx_type nel = 0; \
     octave_idx_type nz = m.nnz (); \
@@ -164,19 +164,19 @@ Boston, MA 02110-1301, USA.
   SPARSE_SMS_CMP_OP (mx_el_gt, >,  M, MZ, CM, S, SZ, CS)	\
   SPARSE_SMS_CMP_OP (mx_el_eq, ==, M, MZ,   , S, SZ,   )	\
   SPARSE_SMS_CMP_OP (mx_el_ne, !=, M, MZ,   , S, SZ,   )
 
 #define SPARSE_SMS_EQNE_OPS(M, MZ, CM, S, SZ, CS)	\
   SPARSE_SMS_CMP_OP (mx_el_eq, ==, M, MZ,   , S, SZ,   )	\
   SPARSE_SMS_CMP_OP (mx_el_ne, !=, M, MZ,   , S, SZ,   )
 
-#define SPARSE_SMS_BOOL_OP_DECLS(M, S) \
-  SPARSE_BOOL_OP_DECL (mx_el_and, M, S); \
-  SPARSE_BOOL_OP_DECL (mx_el_or,  M, S);
+#define SPARSE_SMS_BOOL_OP_DECLS(M, S, API) \
+  SPARSE_BOOL_OP_DECL (mx_el_and, M, S, API); \
+  SPARSE_BOOL_OP_DECL (mx_el_or,  M, S, API);
 
 #define SPARSE_SMS_BOOL_OP(F, OP, M, S, LHS_ZERO, RHS_ZERO) \
   SparseBoolMatrix \
   F (const M& m, const S& s) \
   { \
     /* Count num of non-zero elements */ \
     octave_idx_type nel = 0; \
     octave_idx_type nz = m.nnz (); \
@@ -234,28 +234,28 @@ Boston, MA 02110-1301, USA.
 
 #define SPARSE_SMS_BOOL_OPS2(M, S, LHS_ZERO, RHS_ZERO) \
   SPARSE_SMS_BOOL_OP (mx_el_and, &&, M, S, LHS_ZERO, RHS_ZERO) \
   SPARSE_SMS_BOOL_OP (mx_el_or,  ||, M, S, LHS_ZERO, RHS_ZERO)
 
 #define SPARSE_SMS_BOOL_OPS(M, S, ZERO) \
   SPARSE_SMS_BOOL_OPS2(M, S, ZERO, ZERO)
 
-#define SPARSE_SMS_OP_DECLS(R1, R2, M, S) \
-  SPARSE_SMS_BIN_OP_DECLS (R1, R2, M, S)	 \
-  SPARSE_SMS_CMP_OP_DECLS (M, S) \
-  SPARSE_SMS_BOOL_OP_DECLS (M, S)
+#define SPARSE_SMS_OP_DECLS(R1, R2, M, S, API) \
+  SPARSE_SMS_BIN_OP_DECLS (R1, R2, M, S, API)	 \
+  SPARSE_SMS_CMP_OP_DECLS (M, S, API) \
+  SPARSE_SMS_BOOL_OP_DECLS (M, S, API)
 
 // scalar by matrix operations.
 
-#define SPARSE_SSM_BIN_OP_DECLS(R1, R2, S, M)    \
-  SPARSE_BIN_OP_DECL (R1, operator +, S, M); \
-  SPARSE_BIN_OP_DECL (R1, operator -, S, M); \
-  SPARSE_BIN_OP_DECL (R2, operator *, S, M); \
-  SPARSE_BIN_OP_DECL (R2, operator /, S, M);
+#define SPARSE_SSM_BIN_OP_DECLS(R1, R2, S, M, API)    \
+  SPARSE_BIN_OP_DECL (R1, operator +, S, M, API); \
+  SPARSE_BIN_OP_DECL (R1, operator -, S, M, API); \
+  SPARSE_BIN_OP_DECL (R2, operator *, S, M, API); \
+  SPARSE_BIN_OP_DECL (R2, operator /, S, M, API);
 
 #define SPARSE_SSM_BIN_OP_1(R, F, OP, S, M) \
   R \
   F (const S& s, const M& m) \
   { \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
  \
@@ -291,27 +291,27 @@ Boston, MA 02110-1301, USA.
   }
 
 #define SPARSE_SSM_BIN_OPS(R1, R2, S, M) \
   SPARSE_SSM_BIN_OP_1 (R1, operator +, +, S, M) \
   SPARSE_SSM_BIN_OP_1 (R1, operator -, -, S, M) \
   SPARSE_SSM_BIN_OP_2 (R2, operator *, *, S, M) \
   SPARSE_SSM_BIN_OP_2 (R2, operator /, /, S, M)
 
-#define SPARSE_SSM_CMP_OP_DECLS(S, M) \
-  SPARSE_CMP_OP_DECL (mx_el_lt, S, M); \
-  SPARSE_CMP_OP_DECL (mx_el_le, S, M); \
-  SPARSE_CMP_OP_DECL (mx_el_ge, S, M); \
-  SPARSE_CMP_OP_DECL (mx_el_gt, S, M); \
-  SPARSE_CMP_OP_DECL (mx_el_eq, S, M); \
-  SPARSE_CMP_OP_DECL (mx_el_ne, S, M);
+#define SPARSE_SSM_CMP_OP_DECLS(S, M, API) \
+  SPARSE_CMP_OP_DECL (mx_el_lt, S, M, API); \
+  SPARSE_CMP_OP_DECL (mx_el_le, S, M, API); \
+  SPARSE_CMP_OP_DECL (mx_el_ge, S, M, API); \
+  SPARSE_CMP_OP_DECL (mx_el_gt, S, M, API); \
+  SPARSE_CMP_OP_DECL (mx_el_eq, S, M, API); \
+  SPARSE_CMP_OP_DECL (mx_el_ne, S, M, API);
 
-#define SPARSE_SSM_EQNE_OP_DECLS(S, M) \
-  SPARSE_CMP_OP_DECL (mx_el_eq, S, M); \
-  SPARSE_CMP_OP_DECL (mx_el_ne, S, M);
+#define SPARSE_SSM_EQNE_OP_DECLS(S, M, API) \
+  SPARSE_CMP_OP_DECL (mx_el_eq, S, M, API); \
+  SPARSE_CMP_OP_DECL (mx_el_ne, S, M, API);
 
 #define SPARSE_SSM_CMP_OP(F, OP, S, SZ, SC, M, MZ, MC)	\
   SparseBoolMatrix \
   F (const S& s, const M& m) \
   { \
     /* Count num of non-zero elements */ \
     octave_idx_type nel = 0; \
     octave_idx_type nz = m.nnz (); \
@@ -374,19 +374,19 @@ Boston, MA 02110-1301, USA.
   SPARSE_SSM_CMP_OP (mx_el_gt, >,  S, SZ, SC, M, MZ, MC)	\
   SPARSE_SSM_CMP_OP (mx_el_eq, ==, S, SZ,   , M, MZ,   )	\
   SPARSE_SSM_CMP_OP (mx_el_ne, !=, S, SZ,   , M, MZ,   )
 
 #define SPARSE_SSM_EQNE_OPS(S, SZ, SC, M, MZ, MC)	\
   SPARSE_SSM_CMP_OP (mx_el_eq, ==, S, SZ,   , M, MZ,   )	\
   SPARSE_SSM_CMP_OP (mx_el_ne, !=, S, SZ,   , M, MZ,   )
 
-#define SPARSE_SSM_BOOL_OP_DECLS(S, M) \
-  SPARSE_BOOL_OP_DECL (mx_el_and, S, M); \
-  SPARSE_BOOL_OP_DECL (mx_el_or,  S, M); \
+#define SPARSE_SSM_BOOL_OP_DECLS(S, M, API) \
+  SPARSE_BOOL_OP_DECL (mx_el_and, S, M, API); \
+  SPARSE_BOOL_OP_DECL (mx_el_or,  S, M, API); \
 
 #define SPARSE_SSM_BOOL_OP(F, OP, S, M, LHS_ZERO, RHS_ZERO) \
   SparseBoolMatrix \
   F (const S& s, const M& m) \
   { \
     /* Count num of non-zero elements */ \
     octave_idx_type nel = 0; \
     octave_idx_type nz = m.nnz (); \
@@ -444,28 +444,28 @@ Boston, MA 02110-1301, USA.
 
 #define SPARSE_SSM_BOOL_OPS2(S, M, LHS_ZERO, RHS_ZERO) \
   SPARSE_SSM_BOOL_OP (mx_el_and, &&, S, M, LHS_ZERO, RHS_ZERO) \
   SPARSE_SSM_BOOL_OP (mx_el_or,  ||, S, M, LHS_ZERO, RHS_ZERO)
 
 #define SPARSE_SSM_BOOL_OPS(S, M, ZERO) \
   SPARSE_SSM_BOOL_OPS2(S, M, ZERO, ZERO)
 
-#define SPARSE_SSM_OP_DECLS(R1, R2, S, M) \
-  SPARSE_SSM_BIN_OP_DECLS (R1, R2, S, M)	 \
-  SPARSE_SSM_CMP_OP_DECLS (S, M) \
-  SPARSE_SSM_BOOL_OP_DECLS (S, M) \
+#define SPARSE_SSM_OP_DECLS(R1, R2, S, M, API) \
+  SPARSE_SSM_BIN_OP_DECLS (R1, R2, S, M, API)	 \
+  SPARSE_SSM_CMP_OP_DECLS (S, M, API) \
+  SPARSE_SSM_BOOL_OP_DECLS (S, M, API) \
 
 // matrix by matrix operations.
 
-#define SPARSE_SMSM_BIN_OP_DECLS(R1, R2, M1, M2)	\
-  SPARSE_BIN_OP_DECL (R1, operator +, M1, M2); \
-  SPARSE_BIN_OP_DECL (R1, operator -, M1, M2); \
-  SPARSE_BIN_OP_DECL (R2, product,    M1, M2); \
-  SPARSE_BIN_OP_DECL (R2, quotient,   M1, M2);
+#define SPARSE_SMSM_BIN_OP_DECLS(R1, R2, M1, M2, API)	\
+  SPARSE_BIN_OP_DECL (R1, operator +, M1, M2, API); \
+  SPARSE_BIN_OP_DECL (R1, operator -, M1, M2, API); \
+  SPARSE_BIN_OP_DECL (R2, product,    M1, M2, API); \
+  SPARSE_BIN_OP_DECL (R2, quotient,   M1, M2, API);
 
 #define SPARSE_SMSM_BIN_OP_1(R, F, OP, M1, M2)	\
   R \
   F (const M1& m1, const M2& m2) \
   { \
     R r; \
  \
     octave_idx_type m1_nr = m1.rows (); \
@@ -798,27 +798,27 @@ Boston, MA 02110-1301, USA.
 // FIXME Are the NaNs double(NaN) or Complex(NaN,Nan) in the complex
 // case?
 #define SPARSE_SMSM_BIN_OPS(R1, R2, M1, M2)  \
   SPARSE_SMSM_BIN_OP_1 (R1, operator +,  +, M1, M2) \
   SPARSE_SMSM_BIN_OP_1 (R1, operator -,  -, M1, M2) \
   SPARSE_SMSM_BIN_OP_2 (R2, product,     *, M1, M2) \
   SPARSE_SMSM_BIN_OP_3 (R2, quotient,    /, M1, M2)
 
-#define SPARSE_SMSM_CMP_OP_DECLS(M1, M2) \
-  SPARSE_CMP_OP_DECL (mx_el_lt, M1, M2); \
-  SPARSE_CMP_OP_DECL (mx_el_le, M1, M2); \
-  SPARSE_CMP_OP_DECL (mx_el_ge, M1, M2); \
-  SPARSE_CMP_OP_DECL (mx_el_gt, M1, M2); \
-  SPARSE_CMP_OP_DECL (mx_el_eq, M1, M2); \
-  SPARSE_CMP_OP_DECL (mx_el_ne, M1, M2);
+#define SPARSE_SMSM_CMP_OP_DECLS(M1, M2, API) \
+  SPARSE_CMP_OP_DECL (mx_el_lt, M1, M2, API); \
+  SPARSE_CMP_OP_DECL (mx_el_le, M1, M2, API); \
+  SPARSE_CMP_OP_DECL (mx_el_ge, M1, M2, API); \
+  SPARSE_CMP_OP_DECL (mx_el_gt, M1, M2, API); \
+  SPARSE_CMP_OP_DECL (mx_el_eq, M1, M2, API); \
+  SPARSE_CMP_OP_DECL (mx_el_ne, M1, M2, API);
 
-#define SPARSE_SMSM_EQNE_OP_DECLS(M1, M2) \
-  SPARSE_CMP_OP_DECL (mx_el_eq, M1, M2); \
-  SPARSE_CMP_OP_DECL (mx_el_ne, M1, M2);
+#define SPARSE_SMSM_EQNE_OP_DECLS(M1, M2, API) \
+  SPARSE_CMP_OP_DECL (mx_el_eq, M1, M2, API); \
+  SPARSE_CMP_OP_DECL (mx_el_ne, M1, M2, API);
 
 #define SPARSE_SMSM_CMP_OP(F, OP, M1, C1, M2, C2)	\
   SparseBoolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
     SparseBoolMatrix r; \
     \
     octave_idx_type m1_nr = m1.rows (); \
@@ -884,19 +884,19 @@ Boston, MA 02110-1301, USA.
   SPARSE_SMSM_CMP_OP (mx_el_gt, >,  M1, C1, M2, C2) \
   SPARSE_SMSM_CMP_OP (mx_el_eq, ==, M1,   , M2,   ) \
   SPARSE_SMSM_CMP_OP (mx_el_ne, !=, M1,   , M2,   )
 
 #define SPARSE_SMSM_EQNE_OPS(M1, Z1, C1, M2, Z2, C2)  \
   SPARSE_SMSM_CMP_OP (mx_el_eq, ==, M1,   , M2,   ) \
   SPARSE_SMSM_CMP_OP (mx_el_ne, !=, M1,   , M2,   )
 
-#define SPARSE_SMSM_BOOL_OP_DECLS(M1, M2) \
-  SPARSE_BOOL_OP_DECL (mx_el_and, M1, M2); \
-  SPARSE_BOOL_OP_DECL (mx_el_or,  M1, M2);
+#define SPARSE_SMSM_BOOL_OP_DECLS(M1, M2, API) \
+  SPARSE_BOOL_OP_DECL (mx_el_and, M1, M2, API); \
+  SPARSE_BOOL_OP_DECL (mx_el_or,  M1, M2, API);
 
 #define SPARSE_SMSM_BOOL_OP(F, OP, M1, M2, LHS_ZERO, RHS_ZERO) \
   SparseBoolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
     SparseBoolMatrix r; \
     \
     octave_idx_type m1_nr = m1.rows (); \
@@ -959,28 +959,28 @@ Boston, MA 02110-1301, USA.
 
 #define SPARSE_SMSM_BOOL_OPS2(M1, M2, LHS_ZERO, RHS_ZERO) \
   SPARSE_SMSM_BOOL_OP (mx_el_and, &&, M1, M2, LHS_ZERO, RHS_ZERO) \
   SPARSE_SMSM_BOOL_OP (mx_el_or,  ||, M1, M2, LHS_ZERO, RHS_ZERO) \
 
 #define SPARSE_SMSM_BOOL_OPS(M1, M2, ZERO) \
   SPARSE_SMSM_BOOL_OPS2(M1, M2, ZERO, ZERO)
 
-#define SPARSE_SMSM_OP_DECLS(R1, R2, M1, M2) \
-  SPARSE_SMSM_BIN_OP_DECLS (R1, R2, M1, M2) \
-  SPARSE_SMSM_CMP_OP_DECLS (M1, M2) \
-  SPARSE_SMSM_BOOL_OP_DECLS (M1, M2)
+#define SPARSE_SMSM_OP_DECLS(R1, R2, M1, M2, API) \
+  SPARSE_SMSM_BIN_OP_DECLS (R1, R2, M1, M2, API) \
+  SPARSE_SMSM_CMP_OP_DECLS (M1, M2, API) \
+  SPARSE_SMSM_BOOL_OP_DECLS (M1, M2, API)
 
 // matrix by matrix operations.
 
-#define SPARSE_MSM_BIN_OP_DECLS(R1, R2, M1, M2)	\
-  SPARSE_BIN_OP_DECL (R1, operator +, M1, M2); \
-  SPARSE_BIN_OP_DECL (R1, operator -, M1, M2); \
-  SPARSE_BIN_OP_DECL (R2, product,    M1, M2); \
-  SPARSE_BIN_OP_DECL (R2, quotient,   M1, M2);
+#define SPARSE_MSM_BIN_OP_DECLS(R1, R2, M1, M2, API)	\
+  SPARSE_BIN_OP_DECL (R1, operator +, M1, M2, API); \
+  SPARSE_BIN_OP_DECL (R1, operator -, M1, M2, API); \
+  SPARSE_BIN_OP_DECL (R2, product,    M1, M2, API); \
+  SPARSE_BIN_OP_DECL (R2, quotient,   M1, M2, API);
 
 #define SPARSE_MSM_BIN_OP_1(R, F, OP, M1, M2)	\
   R \
   F (const M1& m1, const M2& m2) \
   { \
     R r; \
  \
     octave_idx_type m1_nr = m1.rows (); \
@@ -1052,27 +1052,27 @@ Boston, MA 02110-1301, USA.
 
 // FIXME Pass a specific ZERO value
 #define SPARSE_MSM_BIN_OPS(R1, R2, M1, M2) \
   SPARSE_MSM_BIN_OP_1 (R1, operator +,  +, M1, M2) \
   SPARSE_MSM_BIN_OP_1 (R1, operator -,  -, M1, M2) \
   SPARSE_MSM_BIN_OP_2 (R2, product,     *, M1, M2, 0.0) \
   SPARSE_MSM_BIN_OP_2 (R2, quotient,    /, M1, M2, 0.0)
 
-#define SPARSE_MSM_CMP_OP_DECLS(M1, M2) \
-  SPARSE_CMP_OP_DECL (mx_el_lt, M1, M2); \
-  SPARSE_CMP_OP_DECL (mx_el_le, M1, M2); \
-  SPARSE_CMP_OP_DECL (mx_el_ge, M1, M2); \
-  SPARSE_CMP_OP_DECL (mx_el_gt, M1, M2); \
-  SPARSE_CMP_OP_DECL (mx_el_eq, M1, M2); \
-  SPARSE_CMP_OP_DECL (mx_el_ne, M1, M2);
+#define SPARSE_MSM_CMP_OP_DECLS(M1, M2, API) \
+  SPARSE_CMP_OP_DECL (mx_el_lt, M1, M2, API); \
+  SPARSE_CMP_OP_DECL (mx_el_le, M1, M2, API); \
+  SPARSE_CMP_OP_DECL (mx_el_ge, M1, M2, API); \
+  SPARSE_CMP_OP_DECL (mx_el_gt, M1, M2, API); \
+  SPARSE_CMP_OP_DECL (mx_el_eq, M1, M2, API); \
+  SPARSE_CMP_OP_DECL (mx_el_ne, M1, M2, API);
 
-#define SPARSE_MSM_EQNE_OP_DECLS(M1, M2) \
-  SPARSE_CMP_OP_DECL (mx_el_eq, M1, M2); \
-  SPARSE_CMP_OP_DECL (mx_el_ne, M1, M2);
+#define SPARSE_MSM_EQNE_OP_DECLS(M1, M2, API) \
+  SPARSE_CMP_OP_DECL (mx_el_eq, M1, M2, API); \
+  SPARSE_CMP_OP_DECL (mx_el_ne, M1, M2, API);
 
 #define SPARSE_MSM_CMP_OP(F, OP, M1, C1, M2, C2)	\
   SparseBoolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
     SparseBoolMatrix r; \
     \
     octave_idx_type m1_nr = m1.rows (); \
@@ -1128,19 +1128,19 @@ Boston, MA 02110-1301, USA.
   SPARSE_MSM_CMP_OP (mx_el_gt, >,  M1, C1, M2, C2) \
   SPARSE_MSM_CMP_OP (mx_el_eq, ==, M1,   , M2,   ) \
   SPARSE_MSM_CMP_OP (mx_el_ne, !=, M1,   , M2,   )
 
 #define SPARSE_MSM_EQNE_OPS(M1, Z1, C1, M2, Z2, C2)  \
   SPARSE_MSM_CMP_OP (mx_el_eq, ==, M1,   , M2,   ) \
   SPARSE_MSM_CMP_OP (mx_el_ne, !=, M1,   , M2,   )
 
-#define SPARSE_MSM_BOOL_OP_DECLS(M1, M2) \
-  SPARSE_BOOL_OP_DECL (mx_el_and, M1, M2); \
-  SPARSE_BOOL_OP_DECL (mx_el_or,  M1, M2);
+#define SPARSE_MSM_BOOL_OP_DECLS(M1, M2, API) \
+  SPARSE_BOOL_OP_DECL (mx_el_and, M1, M2, API); \
+  SPARSE_BOOL_OP_DECL (mx_el_or,  M1, M2, API);
 
 #define SPARSE_MSM_BOOL_OP(F, OP, M1, M2, LHS_ZERO, RHS_ZERO) \
   SparseBoolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
     SparseBoolMatrix r; \
     \
     octave_idx_type m1_nr = m1.rows (); \
@@ -1193,28 +1193,28 @@ Boston, MA 02110-1301, USA.
 
 #define SPARSE_MSM_BOOL_OPS2(M1, M2, LHS_ZERO, RHS_ZERO) \
   SPARSE_MSM_BOOL_OP (mx_el_and, &&, M1, M2, LHS_ZERO, RHS_ZERO) \
   SPARSE_MSM_BOOL_OP (mx_el_or,  ||, M1, M2, LHS_ZERO, RHS_ZERO) \
 
 #define SPARSE_MSM_BOOL_OPS(M1, M2, ZERO) \
   SPARSE_MSM_BOOL_OPS2(M1, M2, ZERO, ZERO)
 
-#define SPARSE_MSM_OP_DECLS(R1, R2, M1, M2) \
-  SPARSE_MSM_BIN_OP_DECLS (R1, R2, M1, M2) \
-  SPARSE_MSM_CMP_OP_DECLS (M1, M2) \
-  SPARSE_MSM_BOOL_OP_DECLS (M1, M2)
+#define SPARSE_MSM_OP_DECLS(R1, R2, M1, M2, API) \
+  SPARSE_MSM_BIN_OP_DECLS (R1, R2, M1, M2, API) \
+  SPARSE_MSM_CMP_OP_DECLS (M1, M2, API) \
+  SPARSE_MSM_BOOL_OP_DECLS (M1, M2, API)
 
 // matrix by matrix operations.
 
-#define SPARSE_SMM_BIN_OP_DECLS(R1, R2, M1, M2)	\
-  SPARSE_BIN_OP_DECL (R1, operator +, M1, M2); \
-  SPARSE_BIN_OP_DECL (R1, operator -, M1, M2); \
-  SPARSE_BIN_OP_DECL (R2, product,    M1, M2); \
-  SPARSE_BIN_OP_DECL (R2, quotient,   M1, M2);
+#define SPARSE_SMM_BIN_OP_DECLS(R1, R2, M1, M2, API)	\
+  SPARSE_BIN_OP_DECL (R1, operator +, M1, M2, API); \
+  SPARSE_BIN_OP_DECL (R1, operator -, M1, M2, API); \
+  SPARSE_BIN_OP_DECL (R2, product,    M1, M2, API); \
+  SPARSE_BIN_OP_DECL (R2, quotient,   M1, M2, API);
 
 #define SPARSE_SMM_BIN_OP_1(R, F, OP, M1, M2)	\
   R \
   F (const M1& m1, const M2& m2) \
   { \
     R r; \
  \
     octave_idx_type m1_nr = m1.rows (); \
@@ -1286,27 +1286,27 @@ Boston, MA 02110-1301, USA.
 
 // FIXME Pass a specific ZERO value
 #define SPARSE_SMM_BIN_OPS(R1, R2, M1, M2) \
   SPARSE_SMM_BIN_OP_1 (R1, operator +,  +, M1, M2) \
   SPARSE_SMM_BIN_OP_1 (R1, operator -,  -, M1, M2) \
   SPARSE_SMM_BIN_OP_2 (R2, product,     *, M1, M2, 0.0) \
   SPARSE_SMM_BIN_OP_2 (R2, quotient,    /, M1, M2, 0.0)
 
-#define SPARSE_SMM_CMP_OP_DECLS(M1, M2) \
-  SPARSE_CMP_OP_DECL (mx_el_lt, M1, M2); \
-  SPARSE_CMP_OP_DECL (mx_el_le, M1, M2); \
-  SPARSE_CMP_OP_DECL (mx_el_ge, M1, M2); \
-  SPARSE_CMP_OP_DECL (mx_el_gt, M1, M2); \
-  SPARSE_CMP_OP_DECL (mx_el_eq, M1, M2); \
-  SPARSE_CMP_OP_DECL (mx_el_ne, M1, M2);
+#define SPARSE_SMM_CMP_OP_DECLS(M1, M2, API) \
+  SPARSE_CMP_OP_DECL (mx_el_lt, M1, M2, API); \
+  SPARSE_CMP_OP_DECL (mx_el_le, M1, M2, API); \
+  SPARSE_CMP_OP_DECL (mx_el_ge, M1, M2, API); \
+  SPARSE_CMP_OP_DECL (mx_el_gt, M1, M2, API); \
+  SPARSE_CMP_OP_DECL (mx_el_eq, M1, M2, API); \
+  SPARSE_CMP_OP_DECL (mx_el_ne, M1, M2, API);
 
-#define SPARSE_SMM_EQNE_OP_DECLS(M1, M2) \
-  SPARSE_CMP_OP_DECL (mx_el_eq, M1, M2); \
-  SPARSE_CMP_OP_DECL (mx_el_ne, M1, M2);
+#define SPARSE_SMM_EQNE_OP_DECLS(M1, M2, API) \
+  SPARSE_CMP_OP_DECL (mx_el_eq, M1, M2, API); \
+  SPARSE_CMP_OP_DECL (mx_el_ne, M1, M2, API);
 
 #define SPARSE_SMM_CMP_OP(F, OP, M1, C1, M2, C2)	\
   SparseBoolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
     SparseBoolMatrix r; \
     \
     octave_idx_type m1_nr = m1.rows (); \
@@ -1362,19 +1362,19 @@ Boston, MA 02110-1301, USA.
   SPARSE_SMM_CMP_OP (mx_el_gt, >,  M1, C1, M2, C2) \
   SPARSE_SMM_CMP_OP (mx_el_eq, ==, M1,   , M2,   ) \
   SPARSE_SMM_CMP_OP (mx_el_ne, !=, M1,   , M2,   )
 
 #define SPARSE_SMM_EQNE_OPS(M1, Z1, C1, M2, Z2, C2)  \
   SPARSE_SMM_CMP_OP (mx_el_eq, ==, M1,   , M2,   ) \
   SPARSE_SMM_CMP_OP (mx_el_ne, !=, M1,   , M2,   )
 
-#define SPARSE_SMM_BOOL_OP_DECLS(M1, M2) \
-  SPARSE_BOOL_OP_DECL (mx_el_and, M1, M2); \
-  SPARSE_BOOL_OP_DECL (mx_el_or,  M1, M2);
+#define SPARSE_SMM_BOOL_OP_DECLS(M1, M2, API) \
+  SPARSE_BOOL_OP_DECL (mx_el_and, M1, M2, API); \
+  SPARSE_BOOL_OP_DECL (mx_el_or,  M1, M2, API);
 
 #define SPARSE_SMM_BOOL_OP(F, OP, M1, M2, LHS_ZERO, RHS_ZERO) \
   SparseBoolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
     SparseBoolMatrix r; \
     \
     octave_idx_type m1_nr = m1.rows (); \
@@ -1427,20 +1427,20 @@ Boston, MA 02110-1301, USA.
 
 #define SPARSE_SMM_BOOL_OPS2(M1, M2, LHS_ZERO, RHS_ZERO) \
   SPARSE_SMM_BOOL_OP (mx_el_and, &&, M1, M2, LHS_ZERO, RHS_ZERO) \
   SPARSE_SMM_BOOL_OP (mx_el_or,  ||, M1, M2, LHS_ZERO, RHS_ZERO) \
 
 #define SPARSE_SMM_BOOL_OPS(M1, M2, ZERO) \
   SPARSE_SMM_BOOL_OPS2(M1, M2, ZERO, ZERO)
 
-#define SPARSE_SMM_OP_DECLS(R1, R2, M1, M2) \
-  SPARSE_SMM_BIN_OP_DECLS (R1, R2, M1, M2) \
-  SPARSE_SMM_CMP_OP_DECLS (M1, M2) \
-  SPARSE_SMM_BOOL_OP_DECLS (M1, M2)
+#define SPARSE_SMM_OP_DECLS(R1, R2, M1, M2, API) \
+  SPARSE_SMM_BIN_OP_DECLS (R1, R2, M1, M2, API) \
+  SPARSE_SMM_CMP_OP_DECLS (M1, M2, API) \
+  SPARSE_SMM_BOOL_OP_DECLS (M1, M2, API)
 
 // Avoid some code duplication.  Maybe we should use templates.
 
 #define SPARSE_CUMSUM(RET_TYPE, ELT_TYPE, FCN)	\
  \
   octave_idx_type nr = rows (); \
   octave_idx_type nc = cols (); \
  \
diff --git a/liboctave/Sparse.h b/liboctave/Sparse.h
--- a/liboctave/Sparse.h
+++ b/liboctave/Sparse.h
@@ -523,26 +523,26 @@ public:
 template <class LT, class RT>
 /* friend */ int
 assign (Sparse<LT>& lhs, const Sparse<RT>& rhs);
 
 template <class LT, class RT>
 /* friend */ int
 assign1 (Sparse<LT>& lhs, const Sparse<RT>& rhs);
 
-#define INSTANTIATE_SPARSE_ASSIGN(LT, RT) \
-  template OCTAVE_API int assign (Sparse<LT>&, const Sparse<RT>&); \
-  template OCTAVE_API int assign1 (Sparse<LT>&, const Sparse<RT>&);
+#define INSTANTIATE_SPARSE_ASSIGN(LT, RT, API) \
+  template API int assign (Sparse<LT>&, const Sparse<RT>&); \
+  template API int assign1 (Sparse<LT>&, const Sparse<RT>&);
 
-#define INSTANTIATE_SPARSE(T) \
-  template class OCTAVE_API Sparse<T>;
+#define INSTANTIATE_SPARSE(T, API) \
+  template class API Sparse<T>;
 
-#define INSTANTIATE_SPARSE_AND_ASSIGN(T) \
-  INSTANTIATE_SPARSE (T); \
-  INSTANTIATE_SPARSE_ASSIGN (T, T)
+#define INSTANTIATE_SPARSE_AND_ASSIGN(T, API) \
+  INSTANTIATE_SPARSE (T, API); \
+  INSTANTIATE_SPARSE_ASSIGN (T, T, API)
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/boolMatrix.h b/liboctave/boolMatrix.h
--- a/liboctave/boolMatrix.h
+++ b/liboctave/boolMatrix.h
@@ -74,17 +74,17 @@ public:
 
   static bool resize_fill_value (void) { return false; }
 
 private:
 
   boolMatrix (bool *b, octave_idx_type r, octave_idx_type c) : Array2<bool> (b, r, c) { }
 };
 
-MM_CMP_OP_DECLS (boolMatrix, boolMatrix)
+MM_CMP_OP_DECLS (boolMatrix, boolMatrix, OCTAVE_API)
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/boolNDArray.h b/liboctave/boolNDArray.h
--- a/liboctave/boolNDArray.h
+++ b/liboctave/boolNDArray.h
@@ -110,24 +110,24 @@ public:
       return retval;
     }
 
 private:
 
   boolNDArray (bool *d, dim_vector& dv) : ArrayN<bool> (d, dv) { }
 };
 
-NDND_BOOL_OP_DECLS (boolNDArray, boolNDArray)
-NDND_CMP_OP_DECLS (boolNDArray, boolNDArray)
+NDND_BOOL_OP_DECLS (boolNDArray, boolNDArray, OCTAVE_API)
+NDND_CMP_OP_DECLS (boolNDArray, boolNDArray, OCTAVE_API)
 
-NDS_BOOL_OP_DECLS (boolNDArray, bool)
-NDS_CMP_OP_DECLS (boolNDArray, bool)
+NDS_BOOL_OP_DECLS (boolNDArray, bool, OCTAVE_API)
+NDS_CMP_OP_DECLS (boolNDArray, bool, OCTAVE_API)
 
-SND_BOOL_OP_DECLS (bool, boolNDArray)
-SND_CMP_OP_DECLS (bool, boolNDArray)
+SND_BOOL_OP_DECLS (bool, boolNDArray, OCTAVE_API)
+SND_CMP_OP_DECLS (bool, boolNDArray, OCTAVE_API)
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/boolSparse.h b/liboctave/boolSparse.h
--- a/liboctave/boolSparse.h
+++ b/liboctave/boolSparse.h
@@ -108,24 +108,24 @@ public:
   SparseBoolMatrix any (int dim = -1) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const SparseBoolMatrix& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, SparseBoolMatrix& a);
 };
 
-SPARSE_SMS_EQNE_OP_DECLS (SparseBoolMatrix, bool)
-SPARSE_SMS_BOOL_OP_DECLS (SparseBoolMatrix, bool)
+SPARSE_SMS_EQNE_OP_DECLS (SparseBoolMatrix, bool, OCTAVE_API)
+SPARSE_SMS_BOOL_OP_DECLS (SparseBoolMatrix, bool, OCTAVE_API)
 
-SPARSE_SSM_EQNE_OP_DECLS (bool, SparseBoolMatrix)
-SPARSE_SSM_BOOL_OP_DECLS (bool, SparseBoolMatrix)
+SPARSE_SSM_EQNE_OP_DECLS (bool, SparseBoolMatrix, OCTAVE_API)
+SPARSE_SSM_BOOL_OP_DECLS (bool, SparseBoolMatrix, OCTAVE_API)
 
-SPARSE_SMSM_EQNE_OP_DECLS (SparseBoolMatrix, SparseBoolMatrix)
-SPARSE_SMSM_BOOL_OP_DECLS (SparseBoolMatrix, SparseBoolMatrix)
+SPARSE_SMSM_EQNE_OP_DECLS (SparseBoolMatrix, SparseBoolMatrix, OCTAVE_API)
+SPARSE_SMSM_BOOL_OP_DECLS (SparseBoolMatrix, SparseBoolMatrix, OCTAVE_API)
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/chMatrix.h b/liboctave/chMatrix.h
--- a/liboctave/chMatrix.h
+++ b/liboctave/chMatrix.h
@@ -83,24 +83,24 @@ public:
 
   static char resize_fill_value (void) { return '\0'; }
 
 private:
 
   charMatrix (char *ch, octave_idx_type r, octave_idx_type c) : MArray2<char> (ch, r, c) { }
 };
 
-MS_CMP_OP_DECLS (charMatrix, char)
-MS_BOOL_OP_DECLS (charMatrix, char)
+MS_CMP_OP_DECLS (charMatrix, char, OCTAVE_API)
+MS_BOOL_OP_DECLS (charMatrix, char, OCTAVE_API)
 
-SM_CMP_OP_DECLS (char, charMatrix)
-SM_BOOL_OP_DECLS (char, charMatrix)
+SM_CMP_OP_DECLS (char, charMatrix, OCTAVE_API)
+SM_BOOL_OP_DECLS (char, charMatrix, OCTAVE_API)
 
-MM_CMP_OP_DECLS (charMatrix, charMatrix)
-MM_BOOL_OP_DECLS (charMatrix, charMatrix)
+MM_CMP_OP_DECLS (charMatrix, charMatrix, OCTAVE_API)
+MM_BOOL_OP_DECLS (charMatrix, charMatrix, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArray2, charMatrix, char)
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/chNDArray.h b/liboctave/chNDArray.h
--- a/liboctave/chNDArray.h
+++ b/liboctave/chNDArray.h
@@ -90,24 +90,24 @@ public:
 
   static char resize_fill_value (void) { return '\0'; }
 
 private:
 
   charNDArray (char *d, dim_vector& dv) : MArrayN<char> (d, dv) { }
 };
 
-NDS_CMP_OP_DECLS (charNDArray, char)
-NDS_BOOL_OP_DECLS (charNDArray, char)
+NDS_CMP_OP_DECLS (charNDArray, char, OCTAVE_API)
+NDS_BOOL_OP_DECLS (charNDArray, char, OCTAVE_API)
 
-SND_CMP_OP_DECLS (char, charNDArray)
-SND_BOOL_OP_DECLS (char, charNDArray)
+SND_CMP_OP_DECLS (char, charNDArray, OCTAVE_API)
+SND_BOOL_OP_DECLS (char, charNDArray, OCTAVE_API)
 
-NDND_CMP_OP_DECLS (charNDArray, charNDArray)
-NDND_BOOL_OP_DECLS (charNDArray, charNDArray)
+NDND_CMP_OP_DECLS (charNDArray, charNDArray, OCTAVE_API)
+NDND_BOOL_OP_DECLS (charNDArray, charNDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArrayN, charNDArray, char)
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -318,24 +318,24 @@ extern OCTAVE_API Matrix operator * (con
 extern OCTAVE_API Matrix min (double d, const Matrix& m);
 extern OCTAVE_API Matrix min (const Matrix& m, double d);
 extern OCTAVE_API Matrix min (const Matrix& a, const Matrix& b);
 
 extern OCTAVE_API Matrix max (double d, const Matrix& m);
 extern OCTAVE_API Matrix max (const Matrix& m, double d);
 extern OCTAVE_API Matrix max (const Matrix& a, const Matrix& b);
 
-MS_CMP_OP_DECLS (Matrix, double)
-MS_BOOL_OP_DECLS (Matrix, double)
+MS_CMP_OP_DECLS (Matrix, double, OCTAVE_API)
+MS_BOOL_OP_DECLS (Matrix, double, OCTAVE_API)
 
-SM_CMP_OP_DECLS (double, Matrix)
-SM_BOOL_OP_DECLS (double, Matrix)
+SM_CMP_OP_DECLS (double, Matrix, OCTAVE_API)
+SM_BOOL_OP_DECLS (double, Matrix, OCTAVE_API)
 
-MM_CMP_OP_DECLS (Matrix, Matrix)
-MM_BOOL_OP_DECLS (Matrix, Matrix)
+MM_CMP_OP_DECLS (Matrix, Matrix, OCTAVE_API)
+MM_BOOL_OP_DECLS (Matrix, Matrix, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArray2, Matrix, double)
 
 template <class T>
 void read_int (std::istream& is, bool swap_bytes, T& val);
 
 #endif
 
diff --git a/liboctave/dNDArray.h b/liboctave/dNDArray.h
--- a/liboctave/dNDArray.h
+++ b/liboctave/dNDArray.h
@@ -137,24 +137,24 @@ extern OCTAVE_API NDArray imag (const Co
 extern OCTAVE_API NDArray min (double d, const NDArray& m);
 extern OCTAVE_API NDArray min (const NDArray& m, double d);
 extern OCTAVE_API NDArray min (const NDArray& a, const NDArray& b);
 
 extern OCTAVE_API NDArray max (double d, const NDArray& m);
 extern OCTAVE_API NDArray max (const NDArray& m, double d);
 extern OCTAVE_API NDArray max (const NDArray& a, const NDArray& b);
 
-NDS_CMP_OP_DECLS (NDArray, double)
-NDS_BOOL_OP_DECLS (NDArray, double)
+NDS_CMP_OP_DECLS (NDArray, double, OCTAVE_API)
+NDS_BOOL_OP_DECLS (NDArray, double, OCTAVE_API)
 
-SND_CMP_OP_DECLS (double, NDArray)
-SND_BOOL_OP_DECLS (double, NDArray)
+SND_CMP_OP_DECLS (double, NDArray, OCTAVE_API)
+SND_BOOL_OP_DECLS (double, NDArray, OCTAVE_API)
 
-NDND_CMP_OP_DECLS (NDArray, NDArray)
-NDND_BOOL_OP_DECLS (NDArray, NDArray)
+NDND_CMP_OP_DECLS (NDArray, NDArray, OCTAVE_API)
+NDND_BOOL_OP_DECLS (NDArray, NDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArrayN, NDArray, double)
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/dSparse.h b/liboctave/dSparse.h
--- a/liboctave/dSparse.h
+++ b/liboctave/dSparse.h
@@ -428,24 +428,24 @@ extern OCTAVE_API Matrix operator * (con
 extern OCTAVE_API SparseMatrix min (double d, const SparseMatrix& m);
 extern OCTAVE_API SparseMatrix min (const SparseMatrix& m, double d);
 extern OCTAVE_API SparseMatrix min (const SparseMatrix& a, const SparseMatrix& b);
 
 extern OCTAVE_API SparseMatrix max (double d, const SparseMatrix& m);
 extern OCTAVE_API SparseMatrix max (const SparseMatrix& m, double d);
 extern OCTAVE_API SparseMatrix max (const SparseMatrix& a, const SparseMatrix& b);
 
-SPARSE_SMS_CMP_OP_DECLS (SparseMatrix, double)
-SPARSE_SMS_BOOL_OP_DECLS (SparseMatrix, double)
+SPARSE_SMS_CMP_OP_DECLS (SparseMatrix, double, OCTAVE_API)
+SPARSE_SMS_BOOL_OP_DECLS (SparseMatrix, double, OCTAVE_API)
 
-SPARSE_SSM_CMP_OP_DECLS (double, SparseMatrix)
-SPARSE_SSM_BOOL_OP_DECLS (double, SparseMatrix)
+SPARSE_SSM_CMP_OP_DECLS (double, SparseMatrix, OCTAVE_API)
+SPARSE_SSM_BOOL_OP_DECLS (double, SparseMatrix, OCTAVE_API)
 
-SPARSE_SMSM_CMP_OP_DECLS (SparseMatrix, SparseMatrix)
-SPARSE_SMSM_BOOL_OP_DECLS (SparseMatrix, SparseMatrix)
+SPARSE_SMSM_CMP_OP_DECLS (SparseMatrix, SparseMatrix, OCTAVE_API)
+SPARSE_SMSM_BOOL_OP_DECLS (SparseMatrix, SparseMatrix, OCTAVE_API)
 
 SPARSE_FORWARD_DEFS (MSparse, SparseMatrix, Matrix, double)
 
 #ifdef IDX_TYPE_LONG
 #define UMFPACK_DNAME(name) umfpack_dl_ ## name
 #else
 #define UMFPACK_DNAME(name) umfpack_di_ ## name
 #endif
diff --git a/liboctave/int16NDArray.h b/liboctave/int16NDArray.h
--- a/liboctave/int16NDArray.h
+++ b/liboctave/int16NDArray.h
@@ -25,24 +25,24 @@ 02110-1301, USA.
 #define octave_int16NDArray_h 1
 
 #include "intNDArray.h"
 #include "mx-op-defs.h"
 #include "oct-inttypes.h"
 
 typedef intNDArray<octave_int16> int16NDArray;
 
-NDS_CMP_OP_DECLS (int16NDArray, octave_int16)
-NDS_BOOL_OP_DECLS (int16NDArray, octave_int16)
+NDS_CMP_OP_DECLS (int16NDArray, octave_int16, OCTAVE_API)
+NDS_BOOL_OP_DECLS (int16NDArray, octave_int16, OCTAVE_API)
 
-SND_CMP_OP_DECLS (octave_int16, int16NDArray)
-SND_BOOL_OP_DECLS (octave_int16, int16NDArray)
+SND_CMP_OP_DECLS (octave_int16, int16NDArray, OCTAVE_API)
+SND_BOOL_OP_DECLS (octave_int16, int16NDArray, OCTAVE_API)
 
-NDND_CMP_OP_DECLS (int16NDArray, int16NDArray)
-NDND_BOOL_OP_DECLS (int16NDArray, int16NDArray)
+NDND_CMP_OP_DECLS (int16NDArray, int16NDArray, OCTAVE_API)
+NDND_BOOL_OP_DECLS (int16NDArray, int16NDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArrayN, int16NDArray, octave_int16)
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/int32NDArray.h b/liboctave/int32NDArray.h
--- a/liboctave/int32NDArray.h
+++ b/liboctave/int32NDArray.h
@@ -25,24 +25,24 @@ 02110-1301, USA.
 #define octave_int32NDArray_h 1
 
 #include "intNDArray.h"
 #include "mx-op-defs.h"
 #include "oct-inttypes.h"
 
 typedef intNDArray<octave_int32> int32NDArray;
 
-NDS_CMP_OP_DECLS (int32NDArray, octave_int32)
-NDS_BOOL_OP_DECLS (int32NDArray, octave_int32)
+NDS_CMP_OP_DECLS (int32NDArray, octave_int32, OCTAVE_API)
+NDS_BOOL_OP_DECLS (int32NDArray, octave_int32, OCTAVE_API)
 
-SND_CMP_OP_DECLS (octave_int32, int32NDArray)
-SND_BOOL_OP_DECLS (octave_int32, int32NDArray)
+SND_CMP_OP_DECLS (octave_int32, int32NDArray, OCTAVE_API)
+SND_BOOL_OP_DECLS (octave_int32, int32NDArray, OCTAVE_API)
 
-NDND_CMP_OP_DECLS (int32NDArray, int32NDArray)
-NDND_BOOL_OP_DECLS (int32NDArray, int32NDArray)
+NDND_CMP_OP_DECLS (int32NDArray, int32NDArray, OCTAVE_API)
+NDND_BOOL_OP_DECLS (int32NDArray, int32NDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArrayN, int32NDArray, octave_int32)
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/int64NDArray.h b/liboctave/int64NDArray.h
--- a/liboctave/int64NDArray.h
+++ b/liboctave/int64NDArray.h
@@ -25,24 +25,24 @@ 02110-1301, USA.
 #define octave_int64NDArray_h 1
 
 #include "intNDArray.h"
 #include "mx-op-defs.h"
 #include "oct-inttypes.h"
 
 typedef intNDArray<octave_int64> int64NDArray;
 
-NDS_CMP_OP_DECLS (int64NDArray, octave_int64)
-NDS_BOOL_OP_DECLS (int64NDArray, octave_int64)
+NDS_CMP_OP_DECLS (int64NDArray, octave_int64, OCTAVE_API)
+NDS_BOOL_OP_DECLS (int64NDArray, octave_int64, OCTAVE_API)
 
-SND_CMP_OP_DECLS (octave_int64, int64NDArray)
-SND_BOOL_OP_DECLS (octave_int64, int64NDArray)
+SND_CMP_OP_DECLS (octave_int64, int64NDArray, OCTAVE_API)
+SND_BOOL_OP_DECLS (octave_int64, int64NDArray, OCTAVE_API)
 
-NDND_CMP_OP_DECLS (int64NDArray, int64NDArray)
-NDND_BOOL_OP_DECLS (int64NDArray, int64NDArray)
+NDND_CMP_OP_DECLS (int64NDArray, int64NDArray, OCTAVE_API)
+NDND_BOOL_OP_DECLS (int64NDArray, int64NDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArrayN, int64NDArray, octave_int64)
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/int8NDArray.h b/liboctave/int8NDArray.h
--- a/liboctave/int8NDArray.h
+++ b/liboctave/int8NDArray.h
@@ -25,24 +25,24 @@ 02110-1301, USA.
 #define octave_int8NDArray_h 1
 
 #include "intNDArray.h"
 #include "mx-op-defs.h"
 #include "oct-inttypes.h"
 
 typedef intNDArray<octave_int8> int8NDArray;
 
-NDS_CMP_OP_DECLS (int8NDArray, octave_int8)
-NDS_BOOL_OP_DECLS (int8NDArray, octave_int8)
+NDS_CMP_OP_DECLS (int8NDArray, octave_int8, OCTAVE_API)
+NDS_BOOL_OP_DECLS (int8NDArray, octave_int8, OCTAVE_API)
 
-SND_CMP_OP_DECLS (octave_int8, int8NDArray)
-SND_BOOL_OP_DECLS (octave_int8, int8NDArray)
+SND_CMP_OP_DECLS (octave_int8, int8NDArray, OCTAVE_API)
+SND_BOOL_OP_DECLS (octave_int8, int8NDArray, OCTAVE_API)
 
-NDND_CMP_OP_DECLS (int8NDArray, int8NDArray)
-NDND_BOOL_OP_DECLS (int8NDArray, int8NDArray)
+NDND_CMP_OP_DECLS (int8NDArray, int8NDArray, OCTAVE_API)
+NDND_BOOL_OP_DECLS (int8NDArray, int8NDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArrayN, int8NDArray, octave_int8)
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/mk-ops.awk b/liboctave/mk-ops.awk
--- a/liboctave/mk-ops.awk
+++ b/liboctave/mk-ops.awk
@@ -142,25 +142,25 @@ BEGIN {
 	        printf ("class %s\n", rhs_type) >> h_file;
 	      else
 	        printf ("#include \"%s\"\n", rhs_header) >> h_file;
 	    }
 
           printf ("#include \"mx-op-defs.h\"\n") >> h_file;
 
           if (bin_ops)
-            printf ("%s%s_BIN_OP_DECLS (%s, %s, %s)\n", lhs_class,
+            printf ("%s%s_BIN_OP_DECLS (%s, %s, %s, OCTAVE_API)\n", lhs_class,
 		    rhs_class, result_type, lhs_type, rhs_type) >> h_file
 
           if (cmp_ops)
-            printf ("%s%s_CMP_OP_DECLS (%s, %s)\n", lhs_class,
+            printf ("%s%s_CMP_OP_DECLS (%s, %s, OCTAVE_API)\n", lhs_class,
 		    rhs_class, lhs_type, rhs_type) >> h_file
 
           if (bool_ops)
-            printf ("%s%s_BOOL_OP_DECLS (%s, %s)\n", lhs_class,
+            printf ("%s%s_BOOL_OP_DECLS (%s, %s, OCTAVE_API)\n", lhs_class,
 		    rhs_class, lhs_type, rhs_type) >> h_file
 
 
           print "#endif" >> h_file;
 
 	  close (h_file);
 
 
diff --git a/liboctave/mx-op-defs.h b/liboctave/mx-op-defs.h
--- a/liboctave/mx-op-defs.h
+++ b/liboctave/mx-op-defs.h
@@ -21,41 +21,41 @@ 02110-1301, USA.
 
 */
 
 #if !defined (octave_mx_op_defs_h)
 #define octave_mx_op_defs_h 1
 
 #include "mx-inlines.cc"
 
-#define BIN_OP_DECL(R, OP, X, Y) \
-  extern OCTAVE_API R OP (const X&, const Y&)
+#define BIN_OP_DECL(R, OP, X, Y, API) \
+  extern API R OP (const X&, const Y&)
 
 class boolMatrix;
 class boolNDArray;
 
-#define CMP_OP_DECL(OP, X, Y) \
-  extern OCTAVE_API boolMatrix OP (const X&, const Y&)
+#define CMP_OP_DECL(OP, X, Y, API) \
+  extern API boolMatrix OP (const X&, const Y&)
 
-#define NDCMP_OP_DECL(OP, X, Y) \
-  extern OCTAVE_API boolNDArray OP (const X&, const Y&)
+#define NDCMP_OP_DECL(OP, X, Y, API) \
+  extern API boolNDArray OP (const X&, const Y&)
 
-#define BOOL_OP_DECL(OP, X, Y) \
-  extern OCTAVE_API boolMatrix OP (const X&, const Y&)
+#define BOOL_OP_DECL(OP, X, Y, API) \
+  extern API boolMatrix OP (const X&, const Y&)
 
-#define NDBOOL_OP_DECL(OP, X, Y) \
-  extern OCTAVE_API boolNDArray OP (const X&, const Y&)
+#define NDBOOL_OP_DECL(OP, X, Y, API) \
+  extern API boolNDArray OP (const X&, const Y&)
 
 // vector by scalar operations.
 
-#define VS_BIN_OP_DECLS(R, V, S) \
-  BIN_OP_DECL (R, operator +, V, S); \
-  BIN_OP_DECL (R, operator -, V, S); \
-  BIN_OP_DECL (R, operator *, V, S); \
-  BIN_OP_DECL (R, operator /, V, S);
+#define VS_BIN_OP_DECLS(R, V, S, API) \
+  BIN_OP_DECL (R, operator +, V, S, API); \
+  BIN_OP_DECL (R, operator -, V, S, API); \
+  BIN_OP_DECL (R, operator *, V, S, API); \
+  BIN_OP_DECL (R, operator /, V, S, API);
 
 #define VS_BIN_OP(R, F, OP, V, S) \
   R \
   F (const V& v, const S& s) \
   { \
     int len = v.length (); \
  \
     R r (len); \
@@ -67,26 +67,26 @@ class boolNDArray;
   }
 
 #define VS_BIN_OPS(R, V, S) \
   VS_BIN_OP (R, operator +, +, V, S) \
   VS_BIN_OP (R, operator -, -, V, S) \
   VS_BIN_OP (R, operator *, *, V, S) \
   VS_BIN_OP (R, operator /, /, V, S)
 
-#define VS_OP_DECLS(R, V, S) \
-  VS_BIN_OP_DECLS(R, V, S)
+#define VS_OP_DECLS(R, V, S, API) \
+  VS_BIN_OP_DECLS(R, V, S, API)
 
 // scalar by vector by operations.
 
-#define SV_BIN_OP_DECLS(R, S, V) \
-  BIN_OP_DECL (R, operator +, S, V); \
-  BIN_OP_DECL (R, operator -, S, V); \
-  BIN_OP_DECL (R, operator *, S, V); \
-  BIN_OP_DECL (R, operator /, S, V);
+#define SV_BIN_OP_DECLS(R, S, V, API) \
+  BIN_OP_DECL (R, operator +, S, V, API); \
+  BIN_OP_DECL (R, operator -, S, V, API); \
+  BIN_OP_DECL (R, operator *, S, V, API); \
+  BIN_OP_DECL (R, operator /, S, V, API);
 
 #define SV_BIN_OP(R, F, OP, S, V) \
   R \
   F (const S& s, const V& v) \
   { \
     int len = v.length (); \
  \
     R r (len); \
@@ -98,26 +98,26 @@ class boolNDArray;
   }
 
 #define SV_BIN_OPS(R, S, V) \
   SV_BIN_OP (R, operator +, +, S, V) \
   SV_BIN_OP (R, operator -, -, S, V) \
   SV_BIN_OP (R, operator *, *, S, V) \
   SV_BIN_OP (R, operator /, /, S, V)
 
-#define SV_OP_DECLS(R, S, V) \
-  SV_BIN_OP_DECLS(R, S, V)
+#define SV_OP_DECLS(R, S, V, API) \
+  SV_BIN_OP_DECLS(R, S, V, API)
 
 // vector by vector operations.
 
-#define VV_BIN_OP_DECLS(R, V1, V2) \
-  BIN_OP_DECL (R, operator +, V1, V2); \
-  BIN_OP_DECL (R, operator -, V1, V2); \
-  BIN_OP_DECL (R, product,    V1, V2); \
-  BIN_OP_DECL (R, quotient,   V1, V2);
+#define VV_BIN_OP_DECLS(R, V1, V2, API) \
+  BIN_OP_DECL (R, operator +, V1, V2, API); \
+  BIN_OP_DECL (R, operator -, V1, V2, API); \
+  BIN_OP_DECL (R, product,    V1, V2, API); \
+  BIN_OP_DECL (R, quotient,   V1, V2, API);
 
 #define VV_BIN_OP(R, F, OP, V1, V2) \
   R \
   F (const V1& v1, const V2& v2) \
   { \
     R r; \
  \
     int v1_len = v1.length (); \
@@ -137,26 +137,26 @@ class boolNDArray;
   }
 
 #define VV_BIN_OPS(R, V1, V2) \
   VV_BIN_OP (R, operator +, +, V1, V2) \
   VV_BIN_OP (R, operator -, -, V1, V2) \
   VV_BIN_OP (R, product,    *, V1, V2) \
   VV_BIN_OP (R, quotient,   /, V1, V2)
 
-#define VV_OP_DECLS(R, V1, V2) \
-  VV_BIN_OP_DECLS(R, V1, V2)
+#define VV_OP_DECLS(R, V1, V2, API) \
+  VV_BIN_OP_DECLS(R, V1, V2, API)
 
 // matrix by scalar operations.
 
-#define MS_BIN_OP_DECLS(R, M, S) \
-  BIN_OP_DECL (R, operator +, M, S); \
-  BIN_OP_DECL (R, operator -, M, S); \
-  BIN_OP_DECL (R, operator *, M, S); \
-  BIN_OP_DECL (R, operator /, M, S);
+#define MS_BIN_OP_DECLS(R, M, S, API) \
+  BIN_OP_DECL (R, operator +, M, S, API); \
+  BIN_OP_DECL (R, operator -, M, S, API); \
+  BIN_OP_DECL (R, operator *, M, S, API); \
+  BIN_OP_DECL (R, operator /, M, S, API);
 
 #define MS_BIN_OP(R, OP, M, S, F) \
   R \
   OP (const M& m, const S& s) \
   { \
     int nr = m.rows (); \
     int nc = m.cols (); \
  \
@@ -169,23 +169,23 @@ class boolNDArray;
   }
 
 #define MS_BIN_OPS(R, M, S) \
   MS_BIN_OP (R, operator +, M, S, mx_inline_add) \
   MS_BIN_OP (R, operator -, M, S, mx_inline_subtract) \
   MS_BIN_OP (R, operator *, M, S, mx_inline_multiply) \
   MS_BIN_OP (R, operator /, M, S, mx_inline_divide)
 
-#define MS_CMP_OP_DECLS(M, S) \
-  CMP_OP_DECL (mx_el_lt, M, S); \
-  CMP_OP_DECL (mx_el_le, M, S); \
-  CMP_OP_DECL (mx_el_ge, M, S); \
-  CMP_OP_DECL (mx_el_gt, M, S); \
-  CMP_OP_DECL (mx_el_eq, M, S); \
-  CMP_OP_DECL (mx_el_ne, M, S);
+#define MS_CMP_OP_DECLS(M, S, API) \
+  CMP_OP_DECL (mx_el_lt, M, S, API); \
+  CMP_OP_DECL (mx_el_le, M, S, API); \
+  CMP_OP_DECL (mx_el_ge, M, S, API); \
+  CMP_OP_DECL (mx_el_gt, M, S, API); \
+  CMP_OP_DECL (mx_el_eq, M, S, API); \
+  CMP_OP_DECL (mx_el_ne, M, S, API);
 
 #define MS_CMP_OP(F, OP, M, MC, S, SC) \
   boolMatrix \
   F (const M& m, const S& s) \
   { \
     boolMatrix r; \
  \
     int nr = m.rows (); \
@@ -206,19 +206,19 @@ class boolNDArray;
 #define MS_CMP_OPS(M, CM, S, CS) \
   MS_CMP_OP (mx_el_lt, <,  M, CM, S, CS) \
   MS_CMP_OP (mx_el_le, <=, M, CM, S, CS) \
   MS_CMP_OP (mx_el_ge, >=, M, CM, S, CS) \
   MS_CMP_OP (mx_el_gt, >,  M, CM, S, CS) \
   MS_CMP_OP (mx_el_eq, ==, M,   , S,   ) \
   MS_CMP_OP (mx_el_ne, !=, M,   , S,   )
 
-#define MS_BOOL_OP_DECLS(M, S) \
-  BOOL_OP_DECL (mx_el_and, M, S); \
-  BOOL_OP_DECL (mx_el_or,  M, S); \
+#define MS_BOOL_OP_DECLS(M, S, API) \
+  BOOL_OP_DECL (mx_el_and, M, S, API); \
+  BOOL_OP_DECL (mx_el_or,  M, S, API); \
 
 #define MS_BOOL_OP(F, OP, M, S, LHS_ZERO, RHS_ZERO) \
   boolMatrix \
   F (const M& m, const S& s) \
   { \
     boolMatrix r; \
  \
     int nr = m.rows (); \
@@ -238,28 +238,28 @@ class boolNDArray;
 
 #define MS_BOOL_OPS2(M, S, LHS_ZERO, RHS_ZERO) \
   MS_BOOL_OP (mx_el_and, &&, M, S, LHS_ZERO, RHS_ZERO) \
   MS_BOOL_OP (mx_el_or,  ||, M, S, LHS_ZERO, RHS_ZERO)
 
 #define MS_BOOL_OPS(M, S, ZERO) \
   MS_BOOL_OPS2(M, S, ZERO, ZERO)
 
-#define MS_OP_DECLS(R, M, S) \
-  MS_BIN_OP_DECLS (R, M, S) \
-  MS_CMP_OP_DECLS (M, S) \
-  MS_BOOL_OP_DECLS (M, S) \
+#define MS_OP_DECLS(R, M, S, API) \
+  MS_BIN_OP_DECLS (R, M, S, API) \
+  MS_CMP_OP_DECLS (M, S, API) \
+  MS_BOOL_OP_DECLS (M, S, API) \
 
 // scalar by matrix operations.
 
-#define SM_BIN_OP_DECLS(R, S, M) \
-  BIN_OP_DECL (R, operator +, S, M); \
-  BIN_OP_DECL (R, operator -, S, M); \
-  BIN_OP_DECL (R, operator *, S, M); \
-  BIN_OP_DECL (R, operator /, S, M);
+#define SM_BIN_OP_DECLS(R, S, M, API) \
+  BIN_OP_DECL (R, operator +, S, M, API); \
+  BIN_OP_DECL (R, operator -, S, M, API); \
+  BIN_OP_DECL (R, operator *, S, M, API); \
+  BIN_OP_DECL (R, operator /, S, M, API);
 
 #define SM_BIN_OP(R, OP, S, M, F) \
   R \
   OP (const S& s, const M& m) \
   { \
     int nr = m.rows (); \
     int nc = m.cols (); \
  \
@@ -272,23 +272,23 @@ class boolNDArray;
   }
 
 #define SM_BIN_OPS(R, S, M) \
   SM_BIN_OP (R, operator +, S, M, mx_inline_add) \
   SM_BIN_OP (R, operator -, S, M, mx_inline_subtract) \
   SM_BIN_OP (R, operator *, S, M, mx_inline_multiply) \
   SM_BIN_OP (R, operator /, S, M, mx_inline_divide)
 
-#define SM_CMP_OP_DECLS(S, M) \
-  CMP_OP_DECL (mx_el_lt, S, M); \
-  CMP_OP_DECL (mx_el_le, S, M); \
-  CMP_OP_DECL (mx_el_ge, S, M); \
-  CMP_OP_DECL (mx_el_gt, S, M); \
-  CMP_OP_DECL (mx_el_eq, S, M); \
-  CMP_OP_DECL (mx_el_ne, S, M);
+#define SM_CMP_OP_DECLS(S, M, API) \
+  CMP_OP_DECL (mx_el_lt, S, M, API); \
+  CMP_OP_DECL (mx_el_le, S, M, API); \
+  CMP_OP_DECL (mx_el_ge, S, M, API); \
+  CMP_OP_DECL (mx_el_gt, S, M, API); \
+  CMP_OP_DECL (mx_el_eq, S, M, API); \
+  CMP_OP_DECL (mx_el_ne, S, M, API);
 
 #define SM_CMP_OP(F, OP, S, SC, M, MC) \
   boolMatrix \
   F (const S& s, const M& m) \
   { \
     boolMatrix r; \
  \
     int nr = m.rows (); \
@@ -309,19 +309,19 @@ class boolNDArray;
 #define SM_CMP_OPS(S, CS, M, CM) \
   SM_CMP_OP (mx_el_lt, <,  S, CS, M, CM) \
   SM_CMP_OP (mx_el_le, <=, S, CS, M, CM) \
   SM_CMP_OP (mx_el_ge, >=, S, CS, M, CM) \
   SM_CMP_OP (mx_el_gt, >,  S, CS, M, CM) \
   SM_CMP_OP (mx_el_eq, ==, S,   , M,   ) \
   SM_CMP_OP (mx_el_ne, !=, S,   , M,   )
 
-#define SM_BOOL_OP_DECLS(S, M) \
-  BOOL_OP_DECL (mx_el_and, S, M); \
-  BOOL_OP_DECL (mx_el_or,  S, M); \
+#define SM_BOOL_OP_DECLS(S, M, API) \
+  BOOL_OP_DECL (mx_el_and, S, M, API); \
+  BOOL_OP_DECL (mx_el_or,  S, M, API); \
 
 #define SM_BOOL_OP(F, OP, S, M, LHS_ZERO, RHS_ZERO) \
   boolMatrix \
   F (const S& s, const M& m) \
   { \
     boolMatrix r; \
  \
     int nr = m.rows (); \
@@ -341,28 +341,28 @@ class boolNDArray;
 
 #define SM_BOOL_OPS2(S, M, LHS_ZERO, RHS_ZERO) \
   SM_BOOL_OP (mx_el_and, &&, S, M, LHS_ZERO, RHS_ZERO) \
   SM_BOOL_OP (mx_el_or,  ||, S, M, LHS_ZERO, RHS_ZERO)
 
 #define SM_BOOL_OPS(S, M, ZERO) \
   SM_BOOL_OPS2(S, M, ZERO, ZERO)
 
-#define SM_OP_DECLS(R, S, M) \
-  SM_BIN_OP_DECLS (R, S, M) \
-  SM_CMP_OP_DECLS (S, M) \
-  SM_BOOL_OP_DECLS (S, M) \
+#define SM_OP_DECLS(R, S, M, API) \
+  SM_BIN_OP_DECLS (R, S, M, API) \
+  SM_CMP_OP_DECLS (S, M, API) \
+  SM_BOOL_OP_DECLS (S, M, API) \
 
 // matrix by matrix operations.
 
-#define MM_BIN_OP_DECLS(R, M1, M2) \
-  BIN_OP_DECL (R, operator +, M1, M2); \
-  BIN_OP_DECL (R, operator -, M1, M2); \
-  BIN_OP_DECL (R, product,    M1, M2); \
-  BIN_OP_DECL (R, quotient,   M1, M2);
+#define MM_BIN_OP_DECLS(R, M1, M2, API) \
+  BIN_OP_DECL (R, operator +, M1, M2, API); \
+  BIN_OP_DECL (R, operator -, M1, M2, API); \
+  BIN_OP_DECL (R, product,    M1, M2, API); \
+  BIN_OP_DECL (R, quotient,   M1, M2, API);
 
 #define MM_BIN_OP(R, OP, M1, M2, F) \
   R \
   OP (const M1& m1, const M2& m2) \
   { \
     R r; \
  \
     int m1_nr = m1.rows (); \
@@ -385,23 +385,23 @@ class boolNDArray;
   }
 
 #define MM_BIN_OPS(R, M1, M2) \
   MM_BIN_OP (R, operator +, M1, M2, mx_inline_add) \
   MM_BIN_OP (R, operator -, M1, M2, mx_inline_subtract) \
   MM_BIN_OP (R, product,    M1, M2, mx_inline_multiply) \
   MM_BIN_OP (R, quotient,   M1, M2, mx_inline_divide)
 
-#define MM_CMP_OP_DECLS(M1, M2) \
-  CMP_OP_DECL (mx_el_lt, M1, M2); \
-  CMP_OP_DECL (mx_el_le, M1, M2); \
-  CMP_OP_DECL (mx_el_ge, M1, M2); \
-  CMP_OP_DECL (mx_el_gt, M1, M2); \
-  CMP_OP_DECL (mx_el_eq, M1, M2); \
-  CMP_OP_DECL (mx_el_ne, M1, M2);
+#define MM_CMP_OP_DECLS(M1, M2, API) \
+  CMP_OP_DECL (mx_el_lt, M1, M2, API); \
+  CMP_OP_DECL (mx_el_le, M1, M2, API); \
+  CMP_OP_DECL (mx_el_ge, M1, M2, API); \
+  CMP_OP_DECL (mx_el_gt, M1, M2, API); \
+  CMP_OP_DECL (mx_el_eq, M1, M2, API); \
+  CMP_OP_DECL (mx_el_ne, M1, M2, API);
 
 #define MM_CMP_OP(F, OP, M1, C1, M2, C2) \
   boolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
     boolMatrix r; \
  \
     int m1_nr = m1.rows (); \
@@ -427,19 +427,19 @@ class boolNDArray;
 #define MM_CMP_OPS(M1, C1, M2, C2) \
   MM_CMP_OP (mx_el_lt, <,  M1, C1, M2, C2) \
   MM_CMP_OP (mx_el_le, <=, M1, C1, M2, C2) \
   MM_CMP_OP (mx_el_ge, >=, M1, C1, M2, C2) \
   MM_CMP_OP (mx_el_gt, >,  M1, C1, M2, C2) \
   MM_CMP_OP (mx_el_eq, ==, M1,   , M2,   ) \
   MM_CMP_OP (mx_el_ne, !=, M1,   , M2,   )
 
-#define MM_BOOL_OP_DECLS(M1, M2) \
-  BOOL_OP_DECL (mx_el_and, M1, M2); \
-  BOOL_OP_DECL (mx_el_or,  M1, M2);
+#define MM_BOOL_OP_DECLS(M1, M2, API) \
+  BOOL_OP_DECL (mx_el_and, M1, M2, API); \
+  BOOL_OP_DECL (mx_el_or,  M1, M2, API);
 
 #define MM_BOOL_OP(F, OP, M1, M2, LHS_ZERO, RHS_ZERO) \
   boolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
     boolMatrix r; \
  \
     int m1_nr = m1.rows (); \
@@ -471,28 +471,28 @@ class boolNDArray;
 
 #define MM_BOOL_OPS2(M1, M2, LHS_ZERO, RHS_ZERO) \
   MM_BOOL_OP (mx_el_and, &&, M1, M2, LHS_ZERO, RHS_ZERO) \
   MM_BOOL_OP (mx_el_or,  ||, M1, M2, LHS_ZERO, RHS_ZERO)
 
 #define MM_BOOL_OPS(M1, M2, ZERO) \
   MM_BOOL_OPS2(M1, M2, ZERO, ZERO)
 
-#define MM_OP_DECLS(R, M1, M2) \
-  MM_BIN_OP_DECLS (R, M1, M2) \
-  MM_CMP_OP_DECLS (M1, M2) \
-  MM_BOOL_OP_DECLS (M1, M2)
+#define MM_OP_DECLS(R, M1, M2, API) \
+  MM_BIN_OP_DECLS (R, M1, M2, API) \
+  MM_CMP_OP_DECLS (M1, M2, API) \
+  MM_BOOL_OP_DECLS (M1, M2, API)
 
 // N-d matrix by scalar operations.
 
-#define NDS_BIN_OP_DECLS(R, ND, S) \
-  BIN_OP_DECL (R, operator +, ND, S); \
-  BIN_OP_DECL (R, operator -, ND, S); \
-  BIN_OP_DECL (R, operator *, ND, S); \
-  BIN_OP_DECL (R, operator /, ND, S);
+#define NDS_BIN_OP_DECLS(R, ND, S, API) \
+  BIN_OP_DECL (R, operator +, ND, S, API); \
+  BIN_OP_DECL (R, operator -, ND, S, API); \
+  BIN_OP_DECL (R, operator *, ND, S, API); \
+  BIN_OP_DECL (R, operator /, ND, S, API);
 
 #define NDS_BIN_OP(R, OP, ND, S, F) \
   R \
   OP (const ND& m, const S& s) \
   { \
     R r (m.dims ()); \
  \
     int len = m.length (); \
@@ -504,23 +504,23 @@ class boolNDArray;
   }
 
 #define NDS_BIN_OPS(R, ND, S) \
   NDS_BIN_OP (R, operator +, ND, S, mx_inline_add) \
   NDS_BIN_OP (R, operator -, ND, S, mx_inline_subtract) \
   NDS_BIN_OP (R, operator *, ND, S, mx_inline_multiply) \
   NDS_BIN_OP (R, operator /, ND, S, mx_inline_divide)
 
-#define NDS_CMP_OP_DECLS(ND, S) \
-  NDCMP_OP_DECL (mx_el_lt, ND, S); \
-  NDCMP_OP_DECL (mx_el_le, ND, S); \
-  NDCMP_OP_DECL (mx_el_ge, ND, S); \
-  NDCMP_OP_DECL (mx_el_gt, ND, S); \
-  NDCMP_OP_DECL (mx_el_eq, ND, S); \
-  NDCMP_OP_DECL (mx_el_ne, ND, S);
+#define NDS_CMP_OP_DECLS(ND, S, API) \
+  NDCMP_OP_DECL (mx_el_lt, ND, S, API); \
+  NDCMP_OP_DECL (mx_el_le, ND, S, API); \
+  NDCMP_OP_DECL (mx_el_ge, ND, S, API); \
+  NDCMP_OP_DECL (mx_el_gt, ND, S, API); \
+  NDCMP_OP_DECL (mx_el_eq, ND, S, API); \
+  NDCMP_OP_DECL (mx_el_ne, ND, S, API);
 
 #define NDS_CMP_OP(F, OP, ND, NDC, S, SC) \
   boolNDArray \
   F (const ND& m, const S& s) \
   { \
     boolNDArray r; \
  \
     int len = m.length (); \
@@ -584,19 +584,19 @@ class boolNDArray;
 #define NDS_CMP_OPS2(ND, NDC, S, SC, SPEC1, SPEC2) \
   NDS_CMP_OP2 (mx_el_lt, <,  ND, NDC, S, SC, SPEC1, SPEC2) \
   NDS_CMP_OP2 (mx_el_le, <=, ND, NDC, S, SC, SPEC1, SPEC2) \
   NDS_CMP_OP2 (mx_el_ge, >=, ND, NDC, S, SC, SPEC1, SPEC2) \
   NDS_CMP_OP2 (mx_el_gt, >,  ND, NDC, S, SC, SPEC1, SPEC2) \
   NDS_CMP_OP2 (mx_el_eq, ==, ND,    , S,   , SPEC1, SPEC2) \
   NDS_CMP_OP2 (mx_el_ne, !=, ND,    , S,   , SPEC1, SPEC2)
 
-#define NDS_BOOL_OP_DECLS(ND, S) \
-  NDBOOL_OP_DECL (mx_el_and, ND, S); \
-  NDBOOL_OP_DECL (mx_el_or,  ND, S);
+#define NDS_BOOL_OP_DECLS(ND, S, API) \
+  NDBOOL_OP_DECL (mx_el_and, ND, S, API); \
+  NDBOOL_OP_DECL (mx_el_or,  ND, S, API);
 
 #define NDS_BOOL_OP(F, OP, ND, S, LHS_ZERO, RHS_ZERO) \
   boolNDArray \
   F (const ND& m, const S& s) \
   { \
     boolNDArray r; \
  \
     int len = m.length (); \
@@ -614,28 +614,28 @@ class boolNDArray;
 
 #define NDS_BOOL_OPS2(ND, S, LHS_ZERO, RHS_ZERO) \
   NDS_BOOL_OP (mx_el_and, &&, ND, S, LHS_ZERO, RHS_ZERO) \
   NDS_BOOL_OP (mx_el_or,  ||, ND, S, LHS_ZERO, RHS_ZERO)
 
 #define NDS_BOOL_OPS(ND, S, ZERO) \
   NDS_BOOL_OPS2(ND, S, ZERO, ZERO)
 
-#define NDS_OP_DECLS(R, ND, S) \
-  NDS_BIN_OP_DECLS (R, ND, S) \
-  NDS_CMP_OP_DECLS (ND, S) \
-  NDS_BOOL_OP_DECLS (ND, S)
+#define NDS_OP_DECLS(R, ND, S, API) \
+  NDS_BIN_OP_DECLS (R, ND, S, API) \
+  NDS_CMP_OP_DECLS (ND, S, API) \
+  NDS_BOOL_OP_DECLS (ND, S, API)
 
 // scalar by N-d matrix operations.
 
-#define SND_BIN_OP_DECLS(R, S, ND) \
-  BIN_OP_DECL (R, operator +, S, ND); \
-  BIN_OP_DECL (R, operator -, S, ND); \
-  BIN_OP_DECL (R, operator *, S, ND); \
-  BIN_OP_DECL (R, operator /, S, ND);
+#define SND_BIN_OP_DECLS(R, S, ND, API) \
+  BIN_OP_DECL (R, operator +, S, ND, API); \
+  BIN_OP_DECL (R, operator -, S, ND, API); \
+  BIN_OP_DECL (R, operator *, S, ND, API); \
+  BIN_OP_DECL (R, operator /, S, ND, API);
 
 #define SND_BIN_OP(R, OP, S, ND, F) \
   R \
   OP (const S& s, const ND& m) \
   { \
     R r (m.dims ()); \
  \
     int len = m.length (); \
@@ -647,23 +647,23 @@ class boolNDArray;
   }
 
 #define SND_BIN_OPS(R, S, ND) \
   SND_BIN_OP (R, operator +, S, ND, mx_inline_add) \
   SND_BIN_OP (R, operator -, S, ND, mx_inline_subtract) \
   SND_BIN_OP (R, operator *, S, ND, mx_inline_multiply) \
   SND_BIN_OP (R, operator /, S, ND, mx_inline_divide)
 
-#define SND_CMP_OP_DECLS(S, ND) \
-  NDCMP_OP_DECL (mx_el_lt, S, ND); \
-  NDCMP_OP_DECL (mx_el_le, S, ND); \
-  NDCMP_OP_DECL (mx_el_ge, S, ND); \
-  NDCMP_OP_DECL (mx_el_gt, S, ND); \
-  NDCMP_OP_DECL (mx_el_eq, S, ND); \
-  NDCMP_OP_DECL (mx_el_ne, S, ND);
+#define SND_CMP_OP_DECLS(S, ND, API) \
+  NDCMP_OP_DECL (mx_el_lt, S, ND, API); \
+  NDCMP_OP_DECL (mx_el_le, S, ND, API); \
+  NDCMP_OP_DECL (mx_el_ge, S, ND, API); \
+  NDCMP_OP_DECL (mx_el_gt, S, ND, API); \
+  NDCMP_OP_DECL (mx_el_eq, S, ND, API); \
+  NDCMP_OP_DECL (mx_el_ne, S, ND, API);
 
 #define SND_CMP_OP(F, OP, S, SC, ND, NDC) \
   boolNDArray \
   F (const S& s, const ND& m) \
   { \
     boolNDArray r; \
  \
     int len = m.length (); \
@@ -727,19 +727,19 @@ class boolNDArray;
 #define SND_CMP_OPS2(S, CS, ND, CND, SPEC1, SPEC2) \
   SND_CMP_OP2 (mx_el_lt, <,  S, CS, ND, CND, SPEC1, SPEC2) \
   SND_CMP_OP2 (mx_el_le, <=, S, CS, ND, CND, SPEC1, SPEC2) \
   SND_CMP_OP2 (mx_el_ge, >=, S, CS, ND, CND, SPEC1, SPEC2) \
   SND_CMP_OP2 (mx_el_gt, >,  S, CS, ND, CND, SPEC1, SPEC2) \
   SND_CMP_OP2 (mx_el_eq, ==, S,   , ND,    , SPEC1, SPEC2) \
   SND_CMP_OP2 (mx_el_ne, !=, S,   , ND,    , SPEC1, SPEC2)
 
-#define SND_BOOL_OP_DECLS(S, ND) \
-  NDBOOL_OP_DECL (mx_el_and, S, ND); \
-  NDBOOL_OP_DECL (mx_el_or,  S, ND);
+#define SND_BOOL_OP_DECLS(S, ND, API) \
+  NDBOOL_OP_DECL (mx_el_and, S, ND, API); \
+  NDBOOL_OP_DECL (mx_el_or,  S, ND, API);
 
 #define SND_BOOL_OP(F, OP, S, ND, LHS_ZERO, RHS_ZERO) \
   boolNDArray \
   F (const S& s, const ND& m) \
   { \
     boolNDArray r; \
  \
     int len = m.length (); \
@@ -757,28 +757,28 @@ class boolNDArray;
 
 #define SND_BOOL_OPS2(S, ND, LHS_ZERO, RHS_ZERO) \
   SND_BOOL_OP (mx_el_and, &&, S, ND, LHS_ZERO, RHS_ZERO) \
   SND_BOOL_OP (mx_el_or,  ||, S, ND, LHS_ZERO, RHS_ZERO)
 
 #define SND_BOOL_OPS(S, ND, ZERO) \
   SND_BOOL_OPS2(S, ND, ZERO, ZERO)
 
-#define SND_OP_DECLS(R, S, ND) \
-  SND_BIN_OP_DECLS (R, S, ND) \
-  SND_CMP_OP_DECLS (S, ND) \
-  SND_BOOL_OP_DECLS (S, ND)
+#define SND_OP_DECLS(R, S, ND, API) \
+  SND_BIN_OP_DECLS (R, S, ND, API) \
+  SND_CMP_OP_DECLS (S, ND, API) \
+  SND_BOOL_OP_DECLS (S, ND, API)
 
 // N-d matrix by N-d matrix operations.
 
-#define NDND_BIN_OP_DECLS(R, ND1, ND2) \
-  BIN_OP_DECL (R, operator +, ND1, ND2); \
-  BIN_OP_DECL (R, operator -, ND1, ND2); \
-  BIN_OP_DECL (R, product,    ND1, ND2); \
-  BIN_OP_DECL (R, quotient,   ND1, ND2);
+#define NDND_BIN_OP_DECLS(R, ND1, ND2, API) \
+  BIN_OP_DECL (R, operator +, ND1, ND2, API); \
+  BIN_OP_DECL (R, operator -, ND1, ND2, API); \
+  BIN_OP_DECL (R, product,    ND1, ND2, API); \
+  BIN_OP_DECL (R, quotient,   ND1, ND2, API);
 
 #define NDND_BIN_OP(R, OP, ND1, ND2, F) \
   R \
   OP (const ND1& m1, const ND2& m2) \
   { \
     R r; \
  \
     dim_vector m1_dims = m1.dims (); \
@@ -800,23 +800,23 @@ class boolNDArray;
   }
 
 #define NDND_BIN_OPS(R, ND1, ND2) \
   NDND_BIN_OP (R, operator +, ND1, ND2, mx_inline_add) \
   NDND_BIN_OP (R, operator -, ND1, ND2, mx_inline_subtract) \
   NDND_BIN_OP (R, product,    ND1, ND2, mx_inline_multiply) \
   NDND_BIN_OP (R, quotient,   ND1, ND2, mx_inline_divide)
 
-#define NDND_CMP_OP_DECLS(ND1, ND2) \
-  NDCMP_OP_DECL (mx_el_lt, ND1, ND2); \
-  NDCMP_OP_DECL (mx_el_le, ND1, ND2); \
-  NDCMP_OP_DECL (mx_el_ge, ND1, ND2); \
-  NDCMP_OP_DECL (mx_el_gt, ND1, ND2); \
-  NDCMP_OP_DECL (mx_el_eq, ND1, ND2); \
-  NDCMP_OP_DECL (mx_el_ne, ND1, ND2);
+#define NDND_CMP_OP_DECLS(ND1, ND2, API) \
+  NDCMP_OP_DECL (mx_el_lt, ND1, ND2, API); \
+  NDCMP_OP_DECL (mx_el_le, ND1, ND2, API); \
+  NDCMP_OP_DECL (mx_el_ge, ND1, ND2, API); \
+  NDCMP_OP_DECL (mx_el_gt, ND1, ND2, API); \
+  NDCMP_OP_DECL (mx_el_eq, ND1, ND2, API); \
+  NDCMP_OP_DECL (mx_el_ne, ND1, ND2, API);
 
 #define NDND_CMP_OP(F, OP, ND1, C1, ND2, C2) \
   boolNDArray \
   F (const ND1& m1, const ND2& m2) \
   { \
     boolNDArray r; \
  \
     dim_vector m1_dims = m1.dims (); \
@@ -838,19 +838,19 @@ class boolNDArray;
 #define NDND_CMP_OPS(ND1, C1, ND2, C2) \
   NDND_CMP_OP (mx_el_lt, <,  ND1, C1, ND2, C2) \
   NDND_CMP_OP (mx_el_le, <=, ND1, C1, ND2, C2) \
   NDND_CMP_OP (mx_el_ge, >=, ND1, C1, ND2, C2) \
   NDND_CMP_OP (mx_el_gt, >,  ND1, C1, ND2, C2) \
   NDND_CMP_OP (mx_el_eq, ==, ND1,   , ND2,   ) \
   NDND_CMP_OP (mx_el_ne, !=, ND1,   , ND2,   )
 
-#define NDND_BOOL_OP_DECLS(ND1, ND2) \
-  NDBOOL_OP_DECL (mx_el_and, ND1, ND2); \
-  NDBOOL_OP_DECL (mx_el_or,  ND1, ND2);
+#define NDND_BOOL_OP_DECLS(ND1, ND2, API) \
+  NDBOOL_OP_DECL (mx_el_and, ND1, ND2, API); \
+  NDBOOL_OP_DECL (mx_el_or,  ND1, ND2, API);
 
 #define NDND_BOOL_OP(F, OP, ND1, ND2, LHS_ZERO, RHS_ZERO) \
   boolNDArray \
   F (const ND1& m1, const ND2& m2) \
   { \
     boolNDArray r; \
  \
     dim_vector m1_dims = m1.dims (); \
@@ -874,26 +874,26 @@ class boolNDArray;
 
 #define NDND_BOOL_OPS2(ND1, ND2, LHS_ZERO, RHS_ZERO) \
   NDND_BOOL_OP (mx_el_and, &&, ND1, ND2, LHS_ZERO, RHS_ZERO) \
   NDND_BOOL_OP (mx_el_or,  ||, ND1, ND2, LHS_ZERO, RHS_ZERO)
 
 #define NDND_BOOL_OPS(ND1, ND2, ZERO) \
   NDND_BOOL_OPS2(ND1, ND2, ZERO, ZERO)
 
-#define NDND_OP_DECLS(R, ND1, ND2) \
-  NDND_BIN_OP_DECLS (R, ND1, ND2) \
-  NDND_CMP_OP_DECLS (ND1, ND2) \
-  NDND_BOOL_OP_DECLS (ND1, ND2)
+#define NDND_OP_DECLS(R, ND1, ND2, API) \
+  NDND_BIN_OP_DECLS (R, ND1, ND2, API) \
+  NDND_CMP_OP_DECLS (ND1, ND2, API) \
+  NDND_BOOL_OP_DECLS (ND1, ND2, API)
 
 // scalar by diagonal matrix operations.
 
-#define SDM_BIN_OP_DECLS(R, S, DM) \
-  BIN_OP_DECL (R, operator +, S, DM); \
-  BIN_OP_DECL (R, operator -, S, DM);
+#define SDM_BIN_OP_DECLS(R, S, DM, API) \
+  BIN_OP_DECL (R, operator +, S, DM, API); \
+  BIN_OP_DECL (R, operator -, S, DM, API);
 
 #define SDM_BIN_OP(R, OP, S, DM, OPEQ) \
   R \
   OP (const S& s, const DM& dm) \
   { \
     int nr = dm.rows (); \
     int nc = dm.cols (); \
  \
@@ -904,24 +904,24 @@ class boolNDArray;
  \
     return r; \
 }
 
 #define SDM_BIN_OPS(R, S, DM) \
   SDM_BIN_OP (R, operator +, S, DM, +=) \
   SDM_BIN_OP (R, operator -, S, DM, -=)
 
-#define SDM_OP_DECLS(R, S, DM) \
-  SDM_BIN_OP_DECLS(R, S, DM)
+#define SDM_OP_DECLS(R, S, DM, API) \
+  SDM_BIN_OP_DECLS(R, S, DM, API)
 
 // diagonal matrix by scalar operations.
 
-#define DMS_BIN_OP_DECLS(R, DM, S) \
-  BIN_OP_DECL (R, operator +, DM, S); \
-  BIN_OP_DECL (R, operator -, DM, S);
+#define DMS_BIN_OP_DECLS(R, DM, S, API) \
+  BIN_OP_DECL (R, operator +, DM, S, API); \
+  BIN_OP_DECL (R, operator -, DM, S, API);
 
 #define DMS_BIN_OP(R, OP, DM, S, SGN) \
   R \
   OP (const DM& dm, const S& s) \
   { \
     int nr = dm.rows (); \
     int nc = dm.cols (); \
  \
@@ -932,25 +932,25 @@ class boolNDArray;
  \
     return r; \
   }
 
 #define DMS_BIN_OPS(R, DM, S) \
   DMS_BIN_OP (R, operator +, DM, S, ) \
   DMS_BIN_OP (R, operator -, DM, S, -)
 
-#define DMS_OP_DECLS(R, DM, S) \
-  DMS_BIN_OP_DECLS(R, DM, S)
+#define DMS_OP_DECLS(R, DM, S, API) \
+  DMS_BIN_OP_DECLS(R, DM, S, API)
 
 // matrix by diagonal matrix operations.
 
-#define MDM_BIN_OP_DECLS(R, M, DM) \
-  BIN_OP_DECL (R, operator +, M, DM); \
-  BIN_OP_DECL (R, operator -, M, DM); \
-  BIN_OP_DECL (R, operator *, M, DM);
+#define MDM_BIN_OP_DECLS(R, M, DM, API) \
+  BIN_OP_DECL (R, operator +, M, DM, API); \
+  BIN_OP_DECL (R, operator -, M, DM, API); \
+  BIN_OP_DECL (R, operator *, M, DM, API);
 
 #define MDM_BIN_OP(R, OP, M, DM, OPEQ) \
 R \
 OP (const M& m, const DM& dm) \
 { \
   R r; \
  \
   int m_nr = m.rows (); \
@@ -1020,25 +1020,25 @@ operator * (const M& m, const DM& dm) \
   return r; \
 }
 
 #define MDM_BIN_OPS(R, M, DM, R_ZERO) \
   MDM_BIN_OP (R, operator +, M, DM, +=) \
   MDM_BIN_OP (R, operator -, M, DM, -=) \
   MDM_MULTIPLY_OP (R, M, DM, R_ZERO)
 
-#define MDM_OP_DECLS(R, M, DM) \
-  MDM_BIN_OP_DECLS(R, M, DM)
+#define MDM_OP_DECLS(R, M, DM, API) \
+  MDM_BIN_OP_DECLS(R, M, DM, API)
 
 // diagonal matrix by matrix operations.
 
-#define DMM_BIN_OP_DECLS(R, DM, M) \
-  BIN_OP_DECL (R, operator +, DM, M); \
-  BIN_OP_DECL (R, operator -, DM, M); \
-  BIN_OP_DECL (R, operator *, DM, M);
+#define DMM_BIN_OP_DECLS(R, DM, M, API) \
+  BIN_OP_DECL (R, operator +, DM, M, API); \
+  BIN_OP_DECL (R, operator -, DM, M, API); \
+  BIN_OP_DECL (R, operator *, DM, M, API);
 
 #define DMM_BIN_OP(R, OP, DM, M, OPEQ, PREOP) \
 R \
 OP (const DM& dm, const M& m) \
 { \
   R r; \
  \
   int dm_nr = dm.rows (); \
@@ -1108,25 +1108,25 @@ operator * (const DM& dm, const M& m) \
   return r; \
 }
 
 #define DMM_BIN_OPS(R, DM, M, R_ZERO) \
   DMM_BIN_OP (R, operator +, DM, M, +=, ) \
   DMM_BIN_OP (R, operator -, DM, M, +=, -) \
   DMM_MULTIPLY_OP (R, DM, M, R_ZERO)
 
-#define DMM_OP_DECLS(R, DM, M) \
-  DMM_BIN_OP_DECLS(R, DM, M)
+#define DMM_OP_DECLS(R, DM, M, API) \
+  DMM_BIN_OP_DECLS(R, DM, M, API)
 
 // diagonal matrix by diagonal matrix operations.
 
-#define DMDM_BIN_OP_DECLS(R, DM1, DM2) \
-  BIN_OP_DECL (R, operator +, DM1, DM2); \
-  BIN_OP_DECL (R, operator -, DM1, DM2); \
-  BIN_OP_DECL (R, product, DM1, DM2);
+#define DMDM_BIN_OP_DECLS(R, DM1, DM2, API) \
+  BIN_OP_DECL (R, operator +, DM1, DM2, API); \
+  BIN_OP_DECL (R, operator -, DM1, DM2, API); \
+  BIN_OP_DECL (R, product, DM1, DM2, API);
 
 #define DMDM_BIN_OP(R, OP, DM1, DM2, F) \
   R \
   OP (const DM1& dm1, const DM2& dm2) \
   { \
     R r; \
  \
     int dm1_nr = dm1.rows (); \
@@ -1149,18 +1149,18 @@ operator * (const DM& dm, const M& m) \
     return r; \
   }
 
 #define DMDM_BIN_OPS(R, DM1, DM2) \
   DMDM_BIN_OP (R, operator +, DM1, DM2, mx_inline_add) \
   DMDM_BIN_OP (R, operator -, DM1, DM2, mx_inline_subtract) \
   DMDM_BIN_OP (R, product,    DM1, DM2, mx_inline_multiply)
 
-#define DMDM_OP_DECLS(R, DM1, DM2) \
-  DMDM_BIN_OP_DECLS (R, DM1, DM2)
+#define DMDM_OP_DECLS(R, DM1, DM2, API) \
+  DMDM_BIN_OP_DECLS (R, DM1, DM2, API)
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/so-array.h b/liboctave/so-array.h
--- a/liboctave/so-array.h
+++ b/liboctave/so-array.h
@@ -89,33 +89,33 @@ public:
 };
 
 OCTAVE_API streamoff_array& operator += (streamoff_array& l, const std::streamoff& r);
 OCTAVE_API streamoff_array& operator -= (streamoff_array& l, const std::streamoff& r);
 
 OCTAVE_API streamoff_array& operator += (streamoff_array& l, const streamoff_array& r);
 OCTAVE_API streamoff_array& operator -= (streamoff_array& l, const streamoff_array& r);
 
-NDCMP_OP_DECL (mx_el_eq, std::streamoff, streamoff_array);
-NDCMP_OP_DECL (mx_el_ne, std::streamoff, streamoff_array);
+NDCMP_OP_DECL (mx_el_eq, std::streamoff, streamoff_array, OCTAVE_API);
+NDCMP_OP_DECL (mx_el_ne, std::streamoff, streamoff_array, OCTAVE_API);
 
-NDCMP_OP_DECL (mx_el_eq, streamoff_array, std::streamoff);
-NDCMP_OP_DECL (mx_el_ne, streamoff_array, std::streamoff);
+NDCMP_OP_DECL (mx_el_eq, streamoff_array, std::streamoff, OCTAVE_API);
+NDCMP_OP_DECL (mx_el_ne, streamoff_array, std::streamoff, OCTAVE_API);
 
-NDCMP_OP_DECL (mx_el_eq, streamoff_array, streamoff_array);
-NDCMP_OP_DECL (mx_el_ne, streamoff_array, streamoff_array);
+NDCMP_OP_DECL (mx_el_eq, streamoff_array, streamoff_array, OCTAVE_API);
+NDCMP_OP_DECL (mx_el_ne, streamoff_array, streamoff_array, OCTAVE_API);
 
-BIN_OP_DECL (streamoff_array, operator +, streamoff_array, streamoff_array);
-BIN_OP_DECL (streamoff_array, operator -, streamoff_array, streamoff_array);
+BIN_OP_DECL (streamoff_array, operator +, streamoff_array, streamoff_array, OCTAVE_API);
+BIN_OP_DECL (streamoff_array, operator -, streamoff_array, streamoff_array, OCTAVE_API);
 
-BIN_OP_DECL (streamoff_array, operator +, streamoff_array, std::streamoff);
-BIN_OP_DECL (streamoff_array, operator -, streamoff_array, std::streamoff);
+BIN_OP_DECL (streamoff_array, operator +, streamoff_array, std::streamoff, OCTAVE_API);
+BIN_OP_DECL (streamoff_array, operator -, streamoff_array, std::streamoff, OCTAVE_API);
 
-BIN_OP_DECL (streamoff_array, operator +, std::streamoff, streamoff_array);
-BIN_OP_DECL (streamoff_array, operator -, std::streamoff, streamoff_array);
+BIN_OP_DECL (streamoff_array, operator +, std::streamoff, streamoff_array, OCTAVE_API);
+BIN_OP_DECL (streamoff_array, operator -, std::streamoff, streamoff_array, OCTAVE_API);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/sparse-mk-ops.awk b/liboctave/sparse-mk-ops.awk
--- a/liboctave/sparse-mk-ops.awk
+++ b/liboctave/sparse-mk-ops.awk
@@ -150,30 +150,30 @@ BEGIN {
 	        printf ("class %s\n", rhs_type) >> h_file;
 	      else
 	        printf ("#include \"%s\"\n", rhs_header) >> h_file;
 	    }
 
           printf ("#include \"Sparse-op-defs.h\"\n") >> h_file;
 
           if (bin_ops)
-            printf ("SPARSE_%s%s_BIN_OP_DECLS (%s, %s, %s, %s)\n", lhs_class,
+            printf ("SPARSE_%s%s_BIN_OP_DECLS (%s, %s, %s, %s, OCTAVE_API)\n", lhs_class,
 		    rhs_class, result_type_1, result_type_2, lhs_type, 
 		    rhs_type) >> h_file
 
           if (cmp_ops)
-            printf ("SPARSE_%s%s_CMP_OP_DECLS (%s, %s)\n", lhs_class,
+            printf ("SPARSE_%s%s_CMP_OP_DECLS (%s, %s, OCTAVE_API)\n", lhs_class,
 		    rhs_class, lhs_type, rhs_type) >> h_file
 
           if (eqne_ops)
-            printf ("SPARSE_%s%s_EQNE_OP_DECLS (%s, %s)\n", lhs_class,
+            printf ("SPARSE_%s%s_EQNE_OP_DECLS (%s, %s, OCTAVE_API)\n", lhs_class,
 		    rhs_class, lhs_type, rhs_type) >> h_file
 
           if (bool_ops)
-            printf ("SPARSE_%s%s_BOOL_OP_DECLS (%s, %s)\n", lhs_class,
+            printf ("SPARSE_%s%s_BOOL_OP_DECLS (%s, %s, OCTAVE_API)\n", lhs_class,
 		    rhs_class, lhs_type, rhs_type) >> h_file
 
 
           print "#endif" >> h_file;
 
 	  close (h_file);
 
 
diff --git a/liboctave/uint16NDArray.h b/liboctave/uint16NDArray.h
--- a/liboctave/uint16NDArray.h
+++ b/liboctave/uint16NDArray.h
@@ -25,24 +25,24 @@ 02110-1301, USA.
 #define octave_uint16NDArray_h 1
 
 #include "intNDArray.h"
 #include "mx-op-defs.h"
 #include "oct-inttypes.h"
 
 typedef intNDArray<octave_uint16> uint16NDArray;
 
-NDS_CMP_OP_DECLS (uint16NDArray, octave_uint16)
-NDS_BOOL_OP_DECLS (uint16NDArray, octave_uint16)
+NDS_CMP_OP_DECLS (uint16NDArray, octave_uint16, OCTAVE_API)
+NDS_BOOL_OP_DECLS (uint16NDArray, octave_uint16, OCTAVE_API)
 
-SND_CMP_OP_DECLS (octave_uint16, uint16NDArray)
-SND_BOOL_OP_DECLS (octave_uint16, uint16NDArray)
+SND_CMP_OP_DECLS (octave_uint16, uint16NDArray, OCTAVE_API)
+SND_BOOL_OP_DECLS (octave_uint16, uint16NDArray, OCTAVE_API)
 
-NDND_CMP_OP_DECLS (uint16NDArray, uint16NDArray)
-NDND_BOOL_OP_DECLS (uint16NDArray, uint16NDArray)
+NDND_CMP_OP_DECLS (uint16NDArray, uint16NDArray, OCTAVE_API)
+NDND_BOOL_OP_DECLS (uint16NDArray, uint16NDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArrayN, uint16NDArray, octave_uint16)
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/uint32NDArray.h b/liboctave/uint32NDArray.h
--- a/liboctave/uint32NDArray.h
+++ b/liboctave/uint32NDArray.h
@@ -25,24 +25,24 @@ 02110-1301, USA.
 #define octave_uint32NDArray_h 1
 
 #include "intNDArray.h"
 #include "mx-op-defs.h"
 #include "oct-inttypes.h"
 
 typedef intNDArray<octave_uint32> uint32NDArray;
 
-NDS_CMP_OP_DECLS (uint32NDArray, octave_uint32)
-NDS_BOOL_OP_DECLS (uint32NDArray, octave_uint32)
+NDS_CMP_OP_DECLS (uint32NDArray, octave_uint32, OCTAVE_API)
+NDS_BOOL_OP_DECLS (uint32NDArray, octave_uint32, OCTAVE_API)
 
-SND_CMP_OP_DECLS (octave_uint32, uint32NDArray)
-SND_BOOL_OP_DECLS (octave_uint32, uint32NDArray)
+SND_CMP_OP_DECLS (octave_uint32, uint32NDArray, OCTAVE_API)
+SND_BOOL_OP_DECLS (octave_uint32, uint32NDArray, OCTAVE_API)
 
-NDND_CMP_OP_DECLS (uint32NDArray, uint32NDArray)
-NDND_BOOL_OP_DECLS (uint32NDArray, uint32NDArray)
+NDND_CMP_OP_DECLS (uint32NDArray, uint32NDArray, OCTAVE_API)
+NDND_BOOL_OP_DECLS (uint32NDArray, uint32NDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArrayN, uint32NDArray, octave_uint32)
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/uint64NDArray.h b/liboctave/uint64NDArray.h
--- a/liboctave/uint64NDArray.h
+++ b/liboctave/uint64NDArray.h
@@ -25,24 +25,24 @@ 02110-1301, USA.
 #define octave_uint64NDArray_h 1
 
 #include "intNDArray.h"
 #include "mx-op-defs.h"
 #include "oct-inttypes.h"
 
 typedef intNDArray<octave_uint64> uint64NDArray;
 
-NDS_CMP_OP_DECLS (uint64NDArray, octave_uint64)
-NDS_BOOL_OP_DECLS (uint64NDArray, octave_uint64)
+NDS_CMP_OP_DECLS (uint64NDArray, octave_uint64, OCTAVE_API)
+NDS_BOOL_OP_DECLS (uint64NDArray, octave_uint64, OCTAVE_API)
 
-SND_CMP_OP_DECLS (octave_uint64, uint64NDArray)
-SND_BOOL_OP_DECLS (octave_uint64, uint64NDArray)
+SND_CMP_OP_DECLS (octave_uint64, uint64NDArray, OCTAVE_API)
+SND_BOOL_OP_DECLS (octave_uint64, uint64NDArray, OCTAVE_API)
 
-NDND_CMP_OP_DECLS (uint64NDArray, uint64NDArray)
-NDND_BOOL_OP_DECLS (uint64NDArray, uint64NDArray)
+NDND_CMP_OP_DECLS (uint64NDArray, uint64NDArray, OCTAVE_API)
+NDND_BOOL_OP_DECLS (uint64NDArray, uint64NDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArrayN, uint64NDArray, octave_uint64)
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/uint8NDArray.h b/liboctave/uint8NDArray.h
--- a/liboctave/uint8NDArray.h
+++ b/liboctave/uint8NDArray.h
@@ -25,24 +25,24 @@ 02110-1301, USA.
 #define octave_uint8NDArray_h 1
 
 #include "intNDArray.h"
 #include "mx-op-defs.h"
 #include "oct-inttypes.h"
 
 typedef intNDArray<octave_uint8> uint8NDArray;
 
-NDS_CMP_OP_DECLS (uint8NDArray, octave_uint8)
-NDS_BOOL_OP_DECLS (uint8NDArray, octave_uint8)
+NDS_CMP_OP_DECLS (uint8NDArray, octave_uint8, OCTAVE_API)
+NDS_BOOL_OP_DECLS (uint8NDArray, octave_uint8, OCTAVE_API)
 
-SND_CMP_OP_DECLS (octave_uint8, uint8NDArray)
-SND_BOOL_OP_DECLS (octave_uint8, uint8NDArray)
+SND_CMP_OP_DECLS (octave_uint8, uint8NDArray, OCTAVE_API)
+SND_BOOL_OP_DECLS (octave_uint8, uint8NDArray, OCTAVE_API)
 
-NDND_CMP_OP_DECLS (uint8NDArray, uint8NDArray)
-NDND_BOOL_OP_DECLS (uint8NDArray, uint8NDArray)
+NDND_CMP_OP_DECLS (uint8NDArray, uint8NDArray, OCTAVE_API)
+NDND_BOOL_OP_DECLS (uint8NDArray, uint8NDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArrayN, uint8NDArray, octave_uint8)
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/TEMPLATE-INST/Array-os.cc b/src/TEMPLATE-INST/Array-os.cc
--- a/src/TEMPLATE-INST/Array-os.cc
+++ b/src/TEMPLATE-INST/Array-os.cc
@@ -30,22 +30,19 @@ 02110-1301, USA.
 #include "Array.h"
 #include "Array.cc"
 
 #include "oct-stream.h"
 
 typedef scanf_format_elt* scanf_format_elt_ptr;
 typedef printf_format_elt* printf_format_elt_ptr;
 
-#undef OCTAVE_API
-#define OCTAVE_API
+INSTANTIATE_ARRAY (scanf_format_elt_ptr, OCTINTERP_API);
 
-INSTANTIATE_ARRAY (scanf_format_elt_ptr);
+INSTANTIATE_ARRAY (printf_format_elt_ptr, OCTINTERP_API);
 
-INSTANTIATE_ARRAY (printf_format_elt_ptr);
-
-INSTANTIATE_ARRAY (octave_stream);
+INSTANTIATE_ARRAY (octave_stream, OCTINTERP_API);
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/TEMPLATE-INST/Array-sym.cc b/src/TEMPLATE-INST/Array-sym.cc
--- a/src/TEMPLATE-INST/Array-sym.cc
+++ b/src/TEMPLATE-INST/Array-sym.cc
@@ -30,18 +30,15 @@ 02110-1301, USA.
 #include "Array.h"
 #include "Array.cc"
 
 #include "oct-obj.h"
 #include "symtab.h"
 
 typedef symbol_record* symbol_record_ptr;
 
-#undef OCTAVE_API
-#define OCTAVE_API
-
-INSTANTIATE_ARRAY (symbol_record_ptr);
+INSTANTIATE_ARRAY (symbol_record_ptr, OCTINTERP_API);
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/TEMPLATE-INST/Array-tc.cc b/src/TEMPLATE-INST/Array-tc.cc
--- a/src/TEMPLATE-INST/Array-tc.cc
+++ b/src/TEMPLATE-INST/Array-tc.cc
@@ -45,20 +45,17 @@ octave_value
 resize_fill_value<octave_value> (const octave_value&)
 {
   static octave_value retval = octave_value (Matrix ());
   return retval;
 }
 
 template class OCTINTERP_API Array<octave_value>;
 
-#undef OCTAVE_API
-#define OCTAVE_API OCTINTERP_API
-
-INSTANTIATE_ARRAY_ASSIGN (octave_value, octave_value);
+INSTANTIATE_ARRAY_ASSIGN (octave_value, octave_value, OCTINTERP_API);
 
 template class OCTINTERP_API Array2<octave_value>;
 
 template class OCTINTERP_API ArrayN<octave_value>;
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -48,19 +48,16 @@ 02110-1301, USA.
 
 #include "error.h"
 #include "input.h"
 #include "oct-stdstrm.h"
 #include "oct-stream.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-#undef OCTAVE_API
-#define OCTAVE_API
-
 // Possible values for conv_err:
 //
 //   1 : not a real scalar
 //   2 : value is NaN
 //   3 : value is not an integer
 
 static int
 convert_to_valid_int (const octave_value& tc, int& conv_err)
@@ -3213,17 +3210,17 @@ INSTANTIATE_DO_READ (uint64NDArray);
 // INSTANTIATE_DO_READ (floatNDArray);
 INSTANTIATE_DO_READ (NDArray);
 INSTANTIATE_DO_READ (charNDArray);
 INSTANTIATE_DO_READ (boolNDArray);
 
 typedef octave_value (*read_fptr) (octave_stream&, octave_idx_type, octave_idx_type, octave_idx_type, octave_idx_type, bool,
 				   oct_mach_info::float_format ffmt, octave_idx_type&);
 
-INSTANTIATE_ARRAY (read_fptr);
+INSTANTIATE_ARRAY (read_fptr,);
 template class Array2<read_fptr>;
 
 #define FILL_TABLE_ROW(R, VAL_T) \
   read_fptr_table(R,oct_data_conv::dt_int8) = do_read<VAL_T, octave_int8>; \
   read_fptr_table(R,oct_data_conv::dt_uint8) = do_read<VAL_T, octave_uint8>; \
   read_fptr_table(R,oct_data_conv::dt_int16) = do_read<VAL_T, octave_int16>; \
   read_fptr_table(R,oct_data_conv::dt_uint16) = do_read<VAL_T, octave_uint16>; \
   read_fptr_table(R,oct_data_conv::dt_int32) = do_read<VAL_T, octave_int32>; \
diff --git a/src/ov-typeinfo.cc b/src/ov-typeinfo.cc
--- a/src/ov-typeinfo.cc
+++ b/src/ov-typeinfo.cc
@@ -38,40 +38,37 @@ octave_value_typeinfo *
 octave_value_typeinfo::instance (0);
 
 #include <Array.h>
 #include <Array2.h>
 #include <Array3.h>
 
 #include <Array.cc>
 
-#undef OCTAVE_API
-#define OCTAVE_API
-
-INSTANTIATE_ARRAY (octave_value_typeinfo::unary_op_fcn);
+INSTANTIATE_ARRAY (octave_value_typeinfo::unary_op_fcn, );
 template class Array2<octave_value_typeinfo::unary_op_fcn>;
 
-INSTANTIATE_ARRAY (octave_value_typeinfo::non_const_unary_op_fcn);
+INSTANTIATE_ARRAY (octave_value_typeinfo::non_const_unary_op_fcn, );
 template class Array2<octave_value_typeinfo::non_const_unary_op_fcn>;
 
-INSTANTIATE_ARRAY (octave_value_typeinfo::binary_op_fcn);
+INSTANTIATE_ARRAY (octave_value_typeinfo::binary_op_fcn, );
 template class Array2<octave_value_typeinfo::binary_op_fcn>;
 template class Array3<octave_value_typeinfo::binary_op_fcn>;
 
-INSTANTIATE_ARRAY (octave_value_typeinfo::cat_op_fcn);
+INSTANTIATE_ARRAY (octave_value_typeinfo::cat_op_fcn, );
 template class Array2<octave_value_typeinfo::cat_op_fcn>;
 
-INSTANTIATE_ARRAY (octave_value_typeinfo::assign_op_fcn);
+INSTANTIATE_ARRAY (octave_value_typeinfo::assign_op_fcn, );
 template class Array2<octave_value_typeinfo::assign_op_fcn>;
 template class Array3<octave_value_typeinfo::assign_op_fcn>;
 
-INSTANTIATE_ARRAY (octave_value_typeinfo::assignany_op_fcn);
+INSTANTIATE_ARRAY (octave_value_typeinfo::assignany_op_fcn, );
 template class Array2<octave_value_typeinfo::assignany_op_fcn>;
 
-INSTANTIATE_ARRAY (octave_base_value::type_conv_fcn);
+INSTANTIATE_ARRAY (octave_base_value::type_conv_fcn, );
 template class Array2<octave_base_value::type_conv_fcn>;
 
 bool
 octave_value_typeinfo::instance_ok (void)
 {
   bool retval = true;
   if (! instance)
     instance = new octave_value_typeinfo ();
