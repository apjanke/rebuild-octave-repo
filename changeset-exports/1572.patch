# HG changeset patch
# User jwe
# Date 814077090 0
#      Thu Oct 19 04:31:30 1995 +0000
# Node ID 0d9e10d10bd75d91aa890c29a3d8789bb811b0fb
# Parent  6ddabf91bc4e056fcb41fff84617f61aa2bd240e
[project @ 1995-10-19 04:31:30 by jwe]

diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -751,25 +751,39 @@ Return a list of the names of the elemen
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       if (args (0).is_map ())
 	{
 	  Octave_map m = args(0).map_value ();
 	  char **names = m.make_name_list ();
-	  Octave_str_obj list (m.length ());
+
 	  char **ptr = names;
+	  int max_len = 0;
+	  while (*ptr)
+	    {
+	      int len = strlen (*ptr);
+	      if (len > max_len)
+		max_len = len;
+	      ptr++;
+	    }
+
+	  charMatrix list (m.length (), max_len);
+
+	  ptr = names;
 	  int i = 0;
 	  while (*ptr)
 	    {
-	      list(i++) = *ptr;
+	      list.insert (*ptr, i++, 0);
 	      delete [] *ptr++;
 	    }
+
 	  delete [] names;
+
 	  retval(0) = list;
 	}
       else
 	gripe_wrong_type_arg ("struct_elements", args (0));
     }
   else
     print_usage ("struct_elements");
 
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -49,17 +49,16 @@ Free Software Foundation, Inc.
 #include <readline/tilde.h>
 
 #include "defun.h"
 #include "dirfns.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "oct-obj.h"
-#include "oct-str.h"
 #include "octave.h"
 #include "pager.h"
 #include "pathlen.h"
 #include "procstream.h"
 #include "statdefs.h"
 #include "sysdep.h"
 #include "sysdir.h"
 #include "tree-const.h"
@@ -488,17 +487,17 @@ DEFUN ("pwd", Fpwd, Spwd, 00,
 DEFUN ("readdir", Freaddir, Sreaddir, 10,
   "readdir (NAME)\n\
 \n\
 Return an array of strings containing the list of all files in the
 named directory.  If sucessful, returns 0; otherwise an error message
 is printed.")
 {
   Octave_object retval;
-  Octave_str_obj dirlist;
+  charMatrix dirlist;
   int status = 0;
 
   if (args.length () == 1)
     {
       const char *dirname = args(0).string_value ();
 
       if (error_state)
 	{
@@ -511,30 +510,38 @@ is printed.")
 
 	  DIR *dir = opendir (tmp);
 
 	  free (tmp);
 
 	  if (dir)
 	    {
 	      int count = 0;
-	      while (readdir (dir))
-		count++;
+	      int max_len = 0;
+
+	      struct dirent *dir_entry;
+
+	      while ((dir_entry = readdir (dir)))
+		{
+		  count++;
+		  int len = strlen (dir_entry->d_name);
+		  if (len > max_len)
+		    max_len = len;
+		}
 
 	      rewinddir (dir);
 
-	      dirlist.resize (count);
+	      dirlist.resize (count, max_len, 0);
 
-	      struct dirent *dir_entry;
 	      while ((dir_entry = readdir (dir)))
 		{
 		  if (--count < 0)
 		    break;
 
-		  dirlist (count) = dir_entry->d_name;
+		  dirlist.insert (dir_entry->d_name, count, 0);
 		}
 
 #if defined (CLOSEDIR_VOID)
 	      closedir (dir);
 #else
 	      if (closedir (dir) < 0)
 		{
 		  status = -1;
@@ -554,17 +561,17 @@ is printed.")
 	      error ("%s", strerror (errno));
 	    }
 	}
     }
   else
     print_usage ("readdir");
 
   if (status == 0)
-    retval(0) = dirlist;
+    retval(0) = tree_constant (dirlist, 1);
 
   return retval;
 }
 
 // XXX FIXME XXX -- should probably also allow second arg to specify
 // mode.
 
 DEFUN ("mkdir", Fmkdir, Smkdir, 10,
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -1360,38 +1360,49 @@ read_ascii_data (istream& is, const char
 	  else
 	    error ("load: failed to extract number of rows and columns");
 	}
       else if (strncmp (ptr, "string array", 12) == 0)
 	{
 	  int elements;
 	  if (extract_keyword (is, "elements", elements) && elements > 0)
 	    {
-	      Octave_str_obj s (elements);
+	      // XXX FIXME XXX -- need to be able to get max length
+	      // before doing anything.
+
+	      charMatrix chm (elements, 0);
+	      int max_len = 0;
 	      for (int i = 0; i < elements; i++)
 		{
 		  int len;
 		  if (extract_keyword (is, "length", len) && len > 0)
 		    {
 		      char *tmp = new char [len];
 		      if (! is.read (tmp, len))
 			{
 			  error ("load: failed to load string constant");
 			  break;
 			}
 		      else
-			s.elem (i).assign (tmp, len);
+			{
+			  if (len > max_len)
+			    {
+			      max_len = len;
+			      chm.resize (elements, max_len, 0);
+			    }
+			  chm.insert (tmp, i, 0);
+			}
 		      delete [] tmp;
 		    }
 		  else
 		    error ("load: failed to extract string length for element %d", i+1);
 		}
 
 	      if (! error_state)
-		tc = s;
+		tc = chm;
 	    }
 	  else
 	    error ("load: failed to extract number of string elements");
 	}
       else if (strncmp (ptr, "string", 6) == 0)
 	{
 	  int len;
 	  if (extract_keyword (is, "length", len) && len > 0)
@@ -1665,34 +1676,40 @@ read_binary_data (istream& is, int swap,
 
     case 7:
       {
 	FOUR_BYTE_INT elements;
 	if (! is.read (&elements, 4))
 	  goto data_read_error;
 	if (swap)
 	  swap_4_bytes ((char *) &elements);
-	Octave_str_obj s (elements);
+	charMatrix chm (elements, 0);
+	int max_len = 0;
 	for (int i = 0; i < elements; i++)
 	  {
 	    FOUR_BYTE_INT len;
 	    if (! is.read (&len, 4))
 	      goto data_read_error;
 	    if (swap)
 	      swap_4_bytes ((char *) &len);
 	    char *tmp = new char [len];
 	    if (! is.read (tmp, len))
 	      {
 		delete [] tmp;
 		goto data_read_error;
 	      }
-	    s.elem (i).assign (tmp, len);
+	    if (len > max_len)
+	      {
+		max_len = len;
+		chm.resize (elements, max_len, 0);
+	      }
+	    chm.insert (tmp, i, 0);
 	    delete [] tmp;
 	  }
-	tc = s;
+	tc = chm;
       }
       break;
 
     default:
     data_read_error:
       error ("load: trouble reading binary file `%s'", filename);
       delete [] name;
       name = 0;
@@ -2487,23 +2504,24 @@ save_binary_data (ostream& os, const tre
       write_doubles (os, (const double *) mtmp, st, 2*len);
     }
   else if (tc.is_string ())
     {
       tmp = 7;
       os.write (&tmp, 1);
       FOUR_BYTE_INT nr = tc.rows ();
       os.write (&nr, 4);
-      Octave_str_obj s = tc.all_strings ();
+      charMatrix chm = tc.all_strings ();
       for (int i = 0; i < nr; i++)
 	{
-	  FOUR_BYTE_INT len = s.elem (i).length ();
+	  FOUR_BYTE_INT len = chm.cols ();
 	  os.write (&len, 4);
-	  const char *tmp = s.elem (i).data ();
+	  const char *tmp = chm.row_as_string (i);
 	  os.write (tmp, len);
+	  delete [] tmp;
 	}
     }
   else if (tc.is_range ())
     {
       tmp = 6;
       os.write (&tmp, 1);
       tmp = (char) LS_DOUBLE;
       os.write (&tmp, 1);
@@ -2791,24 +2809,26 @@ save_ascii_data (ostream& os, const tree
       if (strip_nan_and_inf)
 	tmp = strip_infnan (tmp);
 
       os << tmp;
     }
   else if (tc.is_string ())
     {
       ascii_save_type (os, "string array", mark_as_global);
-      Octave_str_obj tmp = tc.all_strings ();
-      int elements = tmp.length ();
+      charMatrix chm = tc.all_strings ();
+      int elements = chm.rows ();
       os << "# elements: " << elements << "\n";
       for (int i = 0; i < elements; i++)
 	{
-	  int len = tmp.elem (i).length ();
+	  int len = chm.cols ();
 	  os << "# length: " << len << "\n";
-	  os.write (tmp.elem (i).data (), len);
+	  char *tmp = chm.row_as_string (i);
+	  os.write (tmp, len);
+	  delete [] tmp;
 	  os << "\n";
 	}
     }
   else if (tc.is_range ())
     {
       ascii_save_type (os, "range", mark_as_global);
       Range tmp = tc.range_value ();
       os << "# base, limit, increment\n"
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -53,17 +53,16 @@ Software Foundation, 59 Temple Place - S
 #include "defaults.h"
 #include "defun.h"
 #include "dynamic-ld.h"
 #include "error.h"
 #include "file-io.h"
 #include "help.h"
 #include "input.h"
 #include "lex.h"
-#include "oct-str.h"
 #include "octave-hist.h"
 #include "octave.h"
 #include "pager.h"
 #include "parse.h"
 #include "pathsearch.h"
 #include "procstream.h"
 #include "sighandlers.h"
 #include "statdefs.h"
@@ -128,17 +127,17 @@ tree_statement_list *global_command = 0;
 
 // Pointer to function that is currently being evaluated.
 tree_function *curr_function = 0;
 
 // Nonzero means input is coming from startup file.
 int input_from_startup_file = 0;
 
 // The command-line options.
-Octave_str_obj octave_argv;
+charMatrix octave_argv;
 
 // Nonzero means that input is coming from a file that was named on
 // the command line.
 int input_from_command_line_file = 1;
 
 // Top level context (?)
 jmp_buf toplevel;
 
@@ -206,19 +205,28 @@ static struct option long_opts[] =
 
 // Store the command-line options for later use.
 
 static void
 intern_argv (int argc, char **argv)
 {
   if (argc > 1)
     {
-      octave_argv.resize (argc-1);
+      int max_len = 0;
       for (int i = 1; i < argc; i++)
-	octave_argv.elem (i-1) = argv[i];
+	{
+	  int tmp_len = strlen (argv[i]);
+	  if (tmp_len > max_len)
+	    max_len = tmp_len;
+	}
+
+      octave_argv.resize (argc-1, max_len, 0);
+
+      for (int i = 1; i < argc; i++)
+	octave_argv.insert (argv[i], i-1, 0);
 
       bind_builtin_variable ("argv", octave_argv, 1, 1, 0);
     }
 }
 
 // Initialize some global variables for later use.
 
 static void
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -37,17 +37,16 @@ Software Foundation, 59 Temple Place - S
 #include "CMatrix.h"
 #include "Range.h"
 #include "dMatrix.h"
 
 #include "defun.h"
 #include "error.h"
 #include "help.h"
 #include "mappers.h"
-#include "oct-str.h"
 #include "pager.h"
 #include "pr-output.h"
 #include "sysdep.h"
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "utils.h"
 #include "variables.h"
 
@@ -1449,39 +1448,46 @@ octave_print_internal (ostream& os, cons
 
 	      col += inc;
 	    }
 	}
     }
 }
 
 void
-octave_print_internal (ostream& os, Octave_str_obj& s,
-		       int pr_as_read_syntax)
+octave_print_internal (ostream& os, const charMatrix& chm,
+		       int pr_as_read_syntax, int pr_as_string)
 {
-  int nstr = s.num_strings ();
+  if (pr_as_string)
+    {
+      int nstr = chm.rows ();
 
-  if (pr_as_read_syntax && nstr > 1)
-    os << "[ ";
+      if (pr_as_read_syntax && nstr > 1)
+	os << "[ ";
 
-  for (int i = 0; i < nstr; i++)
-    {
-      if (pr_as_read_syntax)
+      for (int i = 0; i < nstr; i++)
 	{
-	  os << "\"" << s.elem (i) << "\"";
+	  if (pr_as_read_syntax)
+	    {
+	      os << "\"" << chm.row_as_string (i) << "\"";
 
-	  if (i < nstr - 1)
-	    os << "; ";
+	      if (i < nstr - 1)
+		os << "; ";
+	    }
+	  else
+	    os << chm.row_as_string (i) << "\n";
 	}
-      else
-	os << s.elem (i) << "\n";
+
+      if (pr_as_read_syntax && nstr > 1)
+	os << " ]";
     }
-
-  if (pr_as_read_syntax && nstr > 1)
-    os << " ]";
+  else
+    {
+      os << "sorry, printing char matrices not implemented yet\n";
+    }
 }
 
 DEFUN ("disp", Fdisp, Sdisp, 10,
   "disp (X): display value without name tag")
 {
   Octave_object retval;
 
   int nargin = args.length ();
diff --git a/src/pr-output.h b/src/pr-output.h
--- a/src/pr-output.h
+++ b/src/pr-output.h
@@ -24,36 +24,37 @@ Software Foundation, 59 Temple Place - S
 #if !defined (octave_pr_output_h)
 #define octave_pr_output_h 1
 
 class ostream;
 
 class Matrix;
 class Complex;
 class ComplexMatrix;
+class charMatrix;
 class Range;
-class Octave_str_obj;
 
 extern void octave_print_internal (ostream& os, double d,
 				   int pr_as_read_syntax = 0);
 
 extern void octave_print_internal (ostream& os, const Matrix& m,
 				   int pr_as_read_syntax = 0);
 
 extern void octave_print_internal (ostream& os, const Complex& c,
 				   int pr_as_read_syntax = 0);
 
 extern void octave_print_internal (ostream& os, const ComplexMatrix& cm,
 				   int pr_as_read_syntax = 0);
 
 extern void octave_print_internal (ostream& os, const Range& r,
 				   int pr_as_read_syntax = 0);
 
-extern void octave_print_internal (ostream& os, Octave_str_obj& s,
-				   int pr_as_read_syntax = 0);
+extern void octave_print_internal (ostream& os, const charMatrix& chm,
+				   int pr_as_read_syntax = 0,
+				   int pr_as_string = 0);
 
 extern void set_format_style (int argc, char **argv);
 
 // XXX FIXME XXX -- these should probably be somewhere else.
 
 extern int any_element_is_inf_or_nan (const Matrix& a);
 
 extern int any_element_is_inf_or_nan (const ComplexMatrix& a);
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -39,17 +39,16 @@ Software Foundation, 59 Temple Place - S
 #include "mx-base.h"
 #include "Range.h"
 
 #include "arith-ops.h"
 #include "error.h"
 #include "gripes.h"
 #include "idx-vector.h"
 #include "oct-map.h"
-#include "oct-str.h"
 #include "pager.h"
 #include "pr-output.h"
 #include "sysdep.h"
 #include "tree-const.h"
 #include "unwind-prot.h"
 #include "user-prefs.h"
 #include "utils.h"
 #include "variables.h"
@@ -606,25 +605,25 @@ TC_REP::tree_constant_rep (const Complex
 	  type_tag = complex_matrix_constant;
 	}
     }
   orig_text = 0;
 }
 
 TC_REP::tree_constant_rep (const char *s)
 {
-  str_obj = new Octave_str_obj (s);
-  type_tag = string_constant;
+  char_matrix = new charMatrix (s);
+  type_tag = char_matrix_constant_str;
   orig_text = 0;
 }
 
-TC_REP::tree_constant_rep (const Octave_str_obj& s)
+TC_REP::tree_constant_rep (const charMatrix& chm, int is_str)
 {
-  str_obj = new Octave_str_obj (s);
-  type_tag = string_constant;
+  char_matrix = new charMatrix (chm);
+  type_tag = is_str ? char_matrix_constant_str : char_matrix_constant;
   orig_text = 0;
 }
 
 TC_REP::tree_constant_rep (double b, double l, double i)
 {
   range = new Range (b, l, i);
   int nel = range->nelem ();
   if (nel > 1)
@@ -710,18 +709,22 @@ TC_REP::tree_constant_rep (const tree_co
     case scalar_constant:
       scalar = t.scalar;
       break;
 
     case matrix_constant:
       matrix = new Matrix (*(t.matrix));
       break;
 
-    case string_constant:
-      str_obj = new Octave_str_obj (*(t.str_obj));
+    case char_matrix_constant:
+      char_matrix = new charMatrix (*(t.char_matrix));
+      break;
+
+    case char_matrix_constant_str:
+      char_matrix = new charMatrix (*(t.char_matrix));
       break;
 
     case complex_matrix_constant:
       complex_matrix = new ComplexMatrix (*(t.complex_matrix));
       break;
 
     case complex_scalar_constant:
       complex_scalar = new Complex (*(t.complex_scalar));
@@ -754,18 +757,19 @@ TC_REP::~tree_constant_rep (void)
     case complex_scalar_constant:
       delete complex_scalar;
       break;
 
     case complex_matrix_constant:
       delete complex_matrix;
       break;
 
-    case string_constant:
-      delete str_obj;
+    case char_matrix_constant:
+    case char_matrix_constant_str:
+      delete char_matrix;
       break;
 
     case range_constant:
       delete range;
       break;
 
     case map_constant:
       delete a_map;
@@ -819,18 +823,19 @@ TC_REP::rows (void) const
 
   switch (type_tag)
     {
     case scalar_constant:
     case complex_scalar_constant:
       retval = 1;
       break;
 
-    case string_constant:
-      retval = str_obj->num_strings ();
+    case char_matrix_constant:
+    case char_matrix_constant_str:
+      retval = char_matrix->rows ();
       break;
 
     case range_constant:
       retval = (columns () > 0);
       break;
 
     case matrix_constant:
       retval = matrix->rows ();
@@ -862,18 +867,19 @@ TC_REP::columns (void) const
     case matrix_constant:
       retval = matrix->columns ();
       break;
 
     case complex_matrix_constant:
       retval = complex_matrix->columns ();
       break;
 
-    case string_constant:
-      retval = str_obj->max_length ();
+    case char_matrix_constant:
+    case char_matrix_constant_str:
+      retval = char_matrix->columns ();
       break;
 
     case range_constant:
       retval = range->nelem ();
       break;
 
     default:
       break;
@@ -1054,17 +1060,17 @@ TC_REP::is_true (void) const
 
 static void
 warn_implicit_conversion (const char *from, const char *to)
 {
   warning ("implicit conversion from %s to %s", from, to);
 }
 
 double
-TC_REP::double_value (int force_string_conversion) const
+TC_REP::double_value (int force_str_conv) const
 {
   double retval = octave_NaN;
 
   switch (type_tag)
     {
     case scalar_constant:
       retval = scalar;
       break;
@@ -1101,30 +1107,41 @@ TC_REP::double_value (int force_string_c
 	    else
 	      panic_impossible ();
 	  }
 	else
 	  gripe_invalid_conversion ("complex scalar", "real scalar");
       }
       break;
 
-    case string_constant:
+    case char_matrix_constant:
       {
-	int flag = force_string_conversion;
+	int len = char_matrix->rows ();
+	if ((char_matrix->rows () == 1 && len == 1)
+	    || (len > 1 && user_pref.do_fortran_indexing))
+	  retval = toascii ((int) char_matrix->elem (0, 0));
+	else
+	  gripe_invalid_conversion ("char matrix", "real scalar");
+      }
+      break;
+
+    case char_matrix_constant_str:
+      {
+	int flag = force_str_conv;
 	if (! flag)
 	  flag = user_pref.implicit_str_to_num_ok;
 
 	if (flag < 0)
 	  warn_implicit_conversion ("string", "real scalar");
 
-	int len = str_obj->max_length ();
+	int len = char_matrix->rows ();
 	if (flag
-	    && ((str_obj->num_strings () == 1 && len == 1)
+	    && ((char_matrix->rows () == 1 && len == 1)
 		|| (len > 1 && user_pref.do_fortran_indexing)))
-	  retval = toascii ((int) str_obj->elem (0, 0));
+	  retval = toascii ((int) char_matrix->elem (0, 0));
 	else
 	  gripe_invalid_conversion ("string", "real scalar");
       }
       break;
 
     case range_constant:
       {
 	int nel = range->nelem ();
@@ -1139,17 +1156,17 @@ TC_REP::double_value (int force_string_c
       gripe_invalid_conversion (type_as_string (), "real scalar");
       break;
     }
 
   return retval;
 }
 
 Matrix
-TC_REP::matrix_value (int force_string_conversion) const
+TC_REP::matrix_value (int force_str_conv) const
 {
   Matrix retval;
 
   switch (type_tag)
     {
     case scalar_constant:
       retval = Matrix (1, 1, scalar);
       break;
@@ -1174,46 +1191,31 @@ TC_REP::matrix_value (int force_string_c
 	    else
 	      panic_impossible ();
 	  }
 	else
 	  gripe_invalid_conversion ("complex matrix", "real matrix");
       }
       break;
 
-    case string_constant:
+    case char_matrix_constant:
+      retval = Matrix (*char_matrix);
+      break;
+
+    case char_matrix_constant_str:
       {
-	int flag = force_string_conversion;
+	int flag = force_str_conv;
 	if (! flag)
 	  flag = user_pref.implicit_str_to_num_ok;
 
 	if (flag < 0)
 	  warn_implicit_conversion ("string", "real matrix");
 
 	if (flag)
-	  {
-	    int nr = str_obj->num_strings ();
-	    int nc = str_obj->max_length ();
-
-	    if (nr > 0 && nc > 0)
-	      {
-		retval.resize (nr, nc);
-
-		for (int i = 0; i < nr; i++)
-		  {
-		    for (int j = 0; j < nc; j++)
-		      {
-			int c = (int) str_obj->elem (i, j);
-			retval.elem (i, j) = toascii (c);
-		      }
-		  }
-	      }
-	    else
-	      retval = Matrix ();  // XXX FIXME XXX -- is this correct?
-	  }
+	  retval = Matrix (*char_matrix);
 	else
 	  gripe_invalid_conversion ("string", "real matrix");
       }
       break;
 
     case range_constant:
       retval = range->matrix_value ();
       break;
@@ -1222,17 +1224,17 @@ TC_REP::matrix_value (int force_string_c
       gripe_invalid_conversion (type_as_string (), "real matrix");
       break;
     }
 
   return retval;
 }
 
 Complex
-TC_REP::complex_value (int force_string_conversion) const
+TC_REP::complex_value (int force_str_conv) const
 {
   Complex retval (octave_NaN, octave_NaN);
 
   switch (type_tag)
     {
     case complex_scalar_constant:
       retval = *complex_scalar;
       break;
@@ -1251,30 +1253,41 @@ TC_REP::complex_value (int force_string_
 	    else
 	      retval = matrix->elem (0, 0);
 	  }
 	else
 	  gripe_invalid_conversion ("real matrix", "real scalar");
       }
       break;
 
-    case string_constant:
+    case char_matrix_constant:
       {
-	int flag = force_string_conversion;
+	int len = char_matrix->cols ();
+	if ((char_matrix->rows () == 1 && len == 1)
+	    || (len > 1 && user_pref.do_fortran_indexing))
+	  retval = toascii ((int) char_matrix->elem (0, 0));
+	else
+	  gripe_invalid_conversion ("char matrix", "complex scalar");
+      }
+      break;
+
+    case char_matrix_constant_str:
+      {
+	int flag = force_str_conv;
 	if (! flag)
 	  flag = user_pref.implicit_str_to_num_ok;
 
 	if (flag < 0)
 	  warn_implicit_conversion ("string", "complex scalar");
 
-	int len = str_obj->max_length ();
+	int len = char_matrix->cols ();
 	if (flag
-	    && ((str_obj->num_strings () == 1 && len == 1)
+	    && ((char_matrix->rows () == 1 && len == 1)
 		|| (len > 1 && user_pref.do_fortran_indexing)))
-	  retval = toascii ((int) str_obj->elem (0, 0));
+	  retval = toascii ((int) char_matrix->elem (0, 0));
 	else
 	  gripe_invalid_conversion ("string", "complex scalar");
       }
       break;
 
     case range_constant:
       {
 	int nel = range->nelem ();
@@ -1289,17 +1302,17 @@ TC_REP::complex_value (int force_string_
       gripe_invalid_conversion (type_as_string (), "complex scalar");
       break;
     }
 
   return retval;
 }
 
 ComplexMatrix
-TC_REP::complex_matrix_value (int force_string_conversion) const
+TC_REP::complex_matrix_value (int force_str_conv) const
 {
   ComplexMatrix retval;
 
   switch (type_tag)
     {
     case scalar_constant:
       retval = ComplexMatrix (1, 1, Complex (scalar));
       break;
@@ -1311,80 +1324,101 @@ TC_REP::complex_matrix_value (int force_
     case matrix_constant:
       retval = ComplexMatrix (*matrix);
       break;
 
     case complex_matrix_constant:
       retval = *complex_matrix;
       break;
 
-    case string_constant:
+    case char_matrix_constant:
+      retval = ComplexMatrix (*char_matrix);
+      break;
+
+    case char_matrix_constant_str:
       {
-	int flag = force_string_conversion;
+	int flag = force_str_conv;
 	if (! flag)
 	  flag = user_pref.implicit_str_to_num_ok;
 
 	if (flag < 0)
 	  warn_implicit_conversion ("string", "complex matrix");
 
 	if (flag)
-	  {
-	    int nr = str_obj->num_strings ();
-	    int nc = str_obj->max_length ();
-
-	    if (nr > 0 && nc > 0)
-	      {
-		retval.resize (nr, nc);
-
-		for (int i = 0; i < nr; i++)
-		  {
-		    for (int j = 0; j < nc; j++)
-		      {
-			int c = (int) str_obj->elem (i, j);
-			retval.elem (i, j) = toascii (c);
-		      }
-		  }
-	      }
-	    else
-	      panic_impossible ();
-	  }
+	  retval = ComplexMatrix (*char_matrix);
 	else
-	  gripe_invalid_conversion ("string", "real matrix");
+	  gripe_invalid_conversion ("complex", "real matrix");
       }
       break;
 
     case range_constant:
       retval = range->matrix_value ();
       break;
 
     default:
       gripe_invalid_conversion (type_as_string (), "complex matrix");
       break;
     }
 
   return retval;
 }
 
-Octave_str_obj
+// XXX FIXME XXX -- this needs to try to do some conversions...
+
+charMatrix
+TC_REP::char_matrix_value (int force_str_conv) const
+{
+  charMatrix retval;
+
+  int flag = force_str_conv;
+  if (! flag)
+    flag = user_pref.implicit_str_to_num_ok;
+#if 0
+
+  if (flag < 0)
+    warn_implicit_conversion ("string", "complex matrix");
+
+  if (flag)
+    retval = ComplexMatrix (*char_matrix);
+  else
+    gripe_invalid_conversion ("complex", "real matrix");
+#endif
+
+  switch (type_tag)
+    {
+    case char_matrix_constant:
+    case char_matrix_constant_str:
+      retval = *char_matrix;
+      break;
+
+    default:
+      gripe_invalid_conversion (type_as_string (), "string");
+      break;
+    }
+
+  return retval;
+}
+
+charMatrix
 TC_REP::all_strings (void) const
 {
-  if (type_tag == string_constant)
-    return *str_obj;
+  if (type_tag == char_matrix_constant_str)
+    return *char_matrix;
   else
     {
       gripe_invalid_conversion (type_as_string (), "string");
       return 0;
     }
 }
 
 const char *
 TC_REP::string_value (void) const
 {
-  if (type_tag == string_constant)
-    return str_obj->elem (0).c_str ();  // XXX FIXME??? XXX
+  if (type_tag == char_matrix_constant_str)
+    return char_matrix->row_as_string (0);  // XXX FIXME??? XXX
   else
     {
       gripe_invalid_conversion (type_as_string (), "string");
       return 0;
     }
 }
 
 Range
@@ -1422,22 +1456,22 @@ TC_REP::lookup_map_element (const char *
 
   return retval;
 }
 
 // This could be made more efficient by doing all the work here rather
 // than relying on matrix_value() to do any possible type conversions.
 
 ColumnVector
-TC_REP::vector_value (int force_string_conversion,
+TC_REP::vector_value (int force_str_conv,
 		      int force_vector_conversion) const
 {
   ColumnVector retval;
 
-  Matrix m = matrix_value (force_string_conversion);
+  Matrix m = matrix_value (force_str_conv);
 
   if (error_state)
     return retval;
 
   int nr = m.rows ();
   int nc = m.columns ();
   if (nr == 1)
     {
@@ -1466,22 +1500,22 @@ TC_REP::vector_value (int force_string_c
   return retval;
 }
 
 // This could be made more efficient by doing all the work here rather
 // than relying on complex_matrix_value() to do any possible type
 // conversions.
 
 ComplexColumnVector
-TC_REP::complex_vector_value (int force_string_conversion,
+TC_REP::complex_vector_value (int force_str_conv,
 			      int force_vector_conversion) const
 {
   ComplexColumnVector retval;
 
-  ComplexMatrix m = complex_matrix_value (force_string_conversion);
+  ComplexMatrix m = complex_matrix_value (force_str_conv);
 
   if (error_state)
     return retval;
 
   int nr = m.rows ();
   int nc = m.columns ();
   if (nr == 1)
     {
@@ -1530,73 +1564,68 @@ TC_REP::convert_to_str (void) const
 	else
 	  {
 	    // XXX FIXME XXX -- warn about out of range conversions?
 
 	    int i = NINT (d);
 	    char s[2];
 	    s[0] = (char) i;
 	    s[1] = '\0';
-	    retval = s;
+	    retval = tree_constant (s, 1);
 	  }
       }
       break;
 
     case complex_matrix_constant:
     case matrix_constant:
       {
 	if (rows () == 0 && columns () == 0)
 	  {
 	    char s = '\0';
-	    retval = &s;
+	    retval = tree_constant (&s, 1);
 	  }
 	else
 	  {
 	    Matrix m = matrix_value ();
 
 	    int nr = m.rows ();
 	    int nc = m.columns ();
 
 	    if (nr == 0 || nc == 0)
 	      {
 		char s = '\0';
-		retval = &s;
+		retval = tree_constant (&s, 1);
 	      }
 	    else
 	      {
-		Octave_str_obj s (nr);
-
-		for (int i = 0; i < nr; i++)
+		charMatrix chm (nr, nc);
+
+		for (int j = 0; j < nc; j++)
 		  {
-		    char buf[nc+1];
-		    buf[nc] = '\0';
-
-		    for (int j = 0; j < nc; j++)
+		    for (int i = 0; i < nr; i++)
 		      {
 			double d = m.elem (i, j);
 
 			if (xisnan (d))
 			  {
 			    ::error ("invalid conversion from NaN to character");
 			    return retval;
 			  }
 			else
 			  {
 			    // XXX FIXME XXX -- warn about out of
 			    // range conversions?
 
 			    int ival = NINT (d);
-			    buf[j] = (char) ival;
+			    chm.elem (i, j) = (char) ival;
 			  }
 		      }
-
-		    s.elem (i).assign (buf, nc);
 		  }
 
-		retval = s;
+		retval = tree_constant (chm, 1);
 	      }
 	  }
       }
       break;
 
     case range_constant:
       {
 	Range r = range_value ();
@@ -1619,23 +1648,27 @@ TC_REP::convert_to_str (void) const
 	      {
 		// XXX FIXME XXX -- warn about out of range
 		// conversions?
 
 		int ival = NINT (d);
 		s[i] = (char) ival;
 	      }
 	  }
-	retval = s;
+	retval = tree_constant (s, 1);
 	delete [] s;
       }
       break;
 
-    case string_constant:
-      retval = *str_obj;
+    case char_matrix_constant:
+      retval = tree_constant (*char_matrix, 1);
+      break;
+
+    case char_matrix_constant_str:
+      retval = tree_constant (*char_matrix, 1);
       break;
 
     default:
       gripe_invalid_conversion (type_as_string (), "string");
       break;
     }
 
   return retval;
@@ -1723,69 +1756,83 @@ TC_REP::convert_to_matrix_type (void)
 
     case unknown_constant:
       {
 	matrix = new Matrix (0, 0);
 	type_tag = matrix_constant;
       }
       break;
 
+    case range_constant:
+      {
+	Matrix *tmp = new Matrix (range->matrix_value ());
+	delete range;
+	matrix = tmp;
+	type_tag = matrix_constant;
+      }
+      break;
+
     default:
       panic_impossible ();
       break;
     }
 }
 
 void
 TC_REP::force_numeric (int force_str_conv)
 {
   switch (type_tag)
     {
     case scalar_constant:
     case matrix_constant:
     case complex_scalar_constant:
     case complex_matrix_constant:
+    case char_matrix_constant:
       break;
 
-    case string_constant:
+    case char_matrix_constant_str:
       {
 	if (! force_str_conv && ! user_pref.implicit_str_to_num_ok)
 	  {
 	    ::error ("string to numeric conversion failed --\
  default conversion turned off");
 	    return;
 	  }
 
-	int nr = str_obj->num_strings ();
-	int nc = str_obj->max_length ();
+	int nr = char_matrix->rows ();
+	int nc = char_matrix->cols ();
 
 	if (nr == 1 && nc == 1)
 	  {
 	    type_tag = scalar_constant;
-	    scalar = toascii ((int) str_obj->elem (0, 0));
+	    double tmp = toascii ((int) char_matrix->elem (0, 0));
+	    delete char_matrix;
+	    scalar = tmp;
 	  }
 	else if (nr == 0 || nc == 0)
 	  {
+	    delete char_matrix;
 	    type_tag = matrix_constant;
 	    matrix = new Matrix (0, 0);
 	  }
 	else if (nr > 0 && nc > 0)
 	  {
 	    type_tag = matrix_constant;
 
 	    Matrix *tm = new Matrix (nr, nc);
 
 	    for (int i = 0; i < nr; i++)
 	      {
 		for (int j = 0; j < nc; j++)
 		  {
-		    int c = (int) str_obj->elem (i, j);
+		    int c = (int) char_matrix->elem (i, j);
 		    tm->elem (i, j) = toascii (c);
 		  }
 	      }
+	    delete char_matrix;
 	    matrix = tm;
 	  }
 	else
 	  panic_impossible ();
       }
       break;
 
     case range_constant:
@@ -1794,16 +1841,17 @@ TC_REP::force_numeric (int force_str_con
 	if (len > 1)
 	  {
 	    type_tag = matrix_constant;
 	    Matrix *tm = new Matrix (1, len);
 	    double b = range->base ();
 	    double increment = range->inc ();
 	    for (int i = 0; i < len; i++)
 	      tm->elem (0, i) = b + i * increment;
+	    delete range;
 	    matrix = tm;
 	  }
 	else if (len == 1)
 	  {
 	    type_tag = scalar_constant;
 	    scalar = range->base ();
 	  }
       }
@@ -1833,19 +1881,37 @@ TC_REP::make_numeric (int force_str_conv
     case complex_scalar_constant:
       retval = *complex_scalar;
       break;
 
     case complex_matrix_constant:
       retval = *complex_matrix;
       break;
 
-    case string_constant:
-      retval = *str_obj;
-      retval.force_numeric (force_str_conv);
+    case char_matrix_constant:
+      retval = *char_matrix;
+      break;
+
+    case char_matrix_constant_str:
+      {
+	int flag = force_str_conv;
+	if (! flag)
+	  flag = user_pref.implicit_str_to_num_ok;
+
+	if (flag < 0)
+	  warn_implicit_conversion ("string", "char matrix");
+
+	if (flag)
+	  {
+	    retval = *char_matrix;
+	    retval.force_numeric (force_str_conv);
+	  }
+	else
+	  gripe_invalid_conversion ("string", "char matrix");
+      }
       break;
 
     case range_constant:
       retval = *range;
       retval.force_numeric (force_str_conv);
       break;
 
     default:
@@ -2060,18 +2126,22 @@ TC_REP::print (ostream& output_buf)
     case complex_scalar_constant:
       octave_print_internal (output_buf, *complex_scalar);
       break;
 
     case complex_matrix_constant:
       octave_print_internal (output_buf, *complex_matrix);
       break;
 
-    case string_constant:
-      octave_print_internal (output_buf, *str_obj);
+    case char_matrix_constant:
+      octave_print_internal (output_buf, *char_matrix);
+      break;
+
+    case char_matrix_constant_str:
+      octave_print_internal (output_buf, *char_matrix, 0, 1);
       break;
 
     case range_constant:
       octave_print_internal (output_buf, *range);
       break;
 
     case map_constant:
       {
@@ -2154,18 +2224,22 @@ TC_REP::print_code (ostream& os)
 	  octave_print_internal (os, *complex_scalar, 1);
       }
       break;
 
     case complex_matrix_constant:
       octave_print_internal (os, *complex_matrix, 1);
       break;
 
-    case string_constant:
-      octave_print_internal (os, *str_obj, 1);
+    case char_matrix_constant:
+      octave_print_internal (os, *char_matrix, 1);
+      break;
+
+    case char_matrix_constant_str:
+      octave_print_internal (os, *char_matrix, 1, 1);
       break;
 
     case range_constant:
       octave_print_internal (os, *range, 1);
       break;
 
     case magic_colon:
       os << ":";
@@ -2204,17 +2278,20 @@ TC_REP::type_as_string (void) const
       return "real matrix";
 
     case complex_scalar_constant:
       return "complex scalar";
 
     case complex_matrix_constant:
       return "complex matrix";
 
-    case string_constant:
+    case char_matrix_constant:
+      return "char matrix";
+
+    case char_matrix_constant_str:
       return "string";
 
     case range_constant:
       return "range";
 
     case map_constant:
       return "structure";
 
@@ -2270,16 +2347,17 @@ do_binary_op (tree_constant& a, tree_con
       switch (b_type)
 	{
 	case TC_REP::scalar_constant:
 	  d2 = tmp_b.double_value ();
 	  retval = do_binary_op (d1, d2, t);
 	  break;
 
 	case TC_REP::matrix_constant:
+	case TC_REP::char_matrix_constant:
 	  m2 = tmp_b.matrix_value ();
 	  retval = do_binary_op (d1, m2, t);
 	  break;
 
 	case TC_REP::complex_scalar_constant:
 	  c2 = tmp_b.complex_value ();
 	  retval = do_binary_op (d1, c2, t);
 	  break;
@@ -2291,27 +2369,29 @@ do_binary_op (tree_constant& a, tree_con
 
 	default:
 	  gripe_wrong_type_arg_for_binary_op (tmp_b);
 	  break;
 	}
       break;
 
     case TC_REP::matrix_constant:
+    case TC_REP::char_matrix_constant:
 
       m1 = tmp_a.matrix_value ();
 
       switch (b_type)
 	{
 	case TC_REP::scalar_constant:
 	  d2 = tmp_b.double_value ();
 	  retval = do_binary_op (m1, d2, t);
 	  break;
 
 	case TC_REP::matrix_constant:
+	case TC_REP::char_matrix_constant:
 	  m2 = tmp_b.matrix_value ();
 	  retval = do_binary_op (m1, m2, t);
 	  break;
 
 	case TC_REP::complex_scalar_constant:
 	  c2 = tmp_b.complex_value ();
 	  retval = do_binary_op (m1, c2, t);
 	  break;
@@ -2334,16 +2414,17 @@ do_binary_op (tree_constant& a, tree_con
       switch (b_type)
 	{
 	case TC_REP::scalar_constant:
 	  d2 = tmp_b.double_value ();
 	  retval = do_binary_op (c1, d2, t);
 	  break;
 
 	case TC_REP::matrix_constant:
+	case TC_REP::char_matrix_constant:
 	  m2 = tmp_b.matrix_value ();
 	  retval = do_binary_op (c1, m2, t);
 	  break;
 
 	case TC_REP::complex_scalar_constant:
 	  c2 = tmp_b.complex_value ();
 	  retval = do_binary_op (c1, c2, t);
 	  break;
@@ -2366,16 +2447,17 @@ do_binary_op (tree_constant& a, tree_con
       switch (b_type)
 	{
 	case TC_REP::scalar_constant:
 	  d2 = tmp_b.double_value ();
 	  retval = do_binary_op (cm1, d2, t);
 	  break;
 
 	case TC_REP::matrix_constant:
+	case TC_REP::char_matrix_constant:
 	  m2 = tmp_b.matrix_value ();
 	  retval = do_binary_op (cm1, m2, t);
 	  break;
 
 	case TC_REP::complex_scalar_constant:
 	  c2 = tmp_b.complex_value ();
 	  retval = do_binary_op (cm1, c2, t);
 	  break;
@@ -2463,16 +2545,21 @@ TC_REP::clear_index (void)
     case matrix_constant:
       matrix->clear_index ();
       break;
 
     case TC_REP::complex_matrix_constant:
       complex_matrix->clear_index ();
       break;
 
+    case char_matrix_constant:
+    case char_matrix_constant_str:
+      char_matrix->clear_index ();
+      break;
+
     default:
       panic_impossible ();
       break;
     }
 }
 
 #if 0
 void
@@ -2483,16 +2570,21 @@ TC_REP::set_index (double d)
     case matrix_constant:
       matrix->set_index (d);
       break;
 
     case TC_REP::complex_matrix_constant:
       complex_matrix->set_index (d);
       break;
 
+    case TC_REP::char_matrix_constant:
+    case TC_REP::char_matrix_constant_str:
+      char_matrix->set_index (d);
+      break;
+
     default:
       panic_impossible ();
       break;
     }
 }
 #endif
 
 void
@@ -2503,16 +2595,21 @@ TC_REP::set_index (const Range& r)
     case matrix_constant:
       matrix->set_index (r);
       break;
 
     case TC_REP::complex_matrix_constant:
       complex_matrix->set_index (r);
       break;
 
+    case TC_REP::char_matrix_constant:
+    case TC_REP::char_matrix_constant_str:
+      char_matrix->set_index (r);
+      break;
+
     default:
       panic_impossible ();
       break;
     }
 }
 
 void
 TC_REP::set_index (const ColumnVector& v)
@@ -2522,16 +2619,21 @@ TC_REP::set_index (const ColumnVector& v
     case matrix_constant:
       matrix->set_index (v);
       break;
 
     case TC_REP::complex_matrix_constant:
       complex_matrix->set_index (v);
       break;
 
+    case TC_REP::char_matrix_constant:
+    case TC_REP::char_matrix_constant_str:
+      char_matrix->set_index (v);
+      break;
+
     default:
       panic_impossible ();
       break;
     }
 }
 
 void
 TC_REP::set_index (const Matrix& m)
@@ -2547,16 +2649,21 @@ TC_REP::set_index (const Matrix& m)
 	case matrix_constant:
 	  matrix->set_index (m);
 	  break;
 
 	case TC_REP::complex_matrix_constant:
 	  complex_matrix->set_index (m);
 	  break;
 
+	case TC_REP::char_matrix_constant:
+	case TC_REP::char_matrix_constant_str:
+	  char_matrix->set_index (m);
+	  break;
+
 	default:
 	  panic_impossible ();
 	  break;
 	}
     }
   else
     ::error ("invalid matrix used as index");
 }
@@ -2571,16 +2678,21 @@ TC_REP::set_index (char c)
     case matrix_constant:
       matrix->set_index (c);
       break;
 
     case TC_REP::complex_matrix_constant:
       complex_matrix->set_index (c);
       break;
 
+    case TC_REP::char_matrix_constant:
+    case TC_REP::char_matrix_constant_str:
+      char_matrix->set_index (c);
+      break;
+
     default:
       panic_impossible ();
       break;
     }
 }
 
 void
 TC_REP::set_index (const Octave_object& args)
@@ -2681,16 +2793,24 @@ TC_REP::do_index (const Octave_object& a
 	    case matrix_constant:
 	      retval = Matrix (matrix->value ());
 	      break;
 
 	    case complex_matrix_constant:
 	      retval = ComplexMatrix (complex_matrix->value ());
 	      break;
 
+	    case char_matrix_constant:
+	      retval = charMatrix (char_matrix->value ());
+	      break;
+
+	    case char_matrix_constant_str:
+	      retval = tree_constant (charMatrix (char_matrix->value ()), 1);
+	      break;
+
 	    default:
 	      error ("can't index %s variables", type_as_string ());
 	      break;
 	    }
 	}
 
 // This is a fairly expensive operation.
 
@@ -2719,53 +2839,88 @@ TC_REP::maybe_widen (TC_REP::constant_ty
 	  }
 	  break;
 
 	default:
 	  break;
 	}
       break;
 
+    case char_matrix_constant:
+      switch (rhs_type)
+	{
+	case scalar_constant:
+	case matrix_constant:
+	  {
+	    Matrix *m = new Matrix (*char_matrix);
+	    delete matrix;
+	    matrix = m;
+	    type_tag = matrix_constant;
+	  }
+	  break;
+
+	case complex_scalar_constant:
+	case complex_matrix_constant:
+	  {
+	    ComplexMatrix *cm = new ComplexMatrix (*char_matrix);
+	    delete matrix;
+	    complex_matrix = cm;
+	    type_tag = complex_matrix_constant;
+	  }
+	  break;
+
+	default:
+	  break;
+	}
+      break;
+
     default:
       break;
     }
 }
 
 // Assignment operations for the tree-constant representation class.
 
 // Top-level tree-constant function that handles assignments.  Only
 // decide if the left-hand side is currently a scalar or a matrix and
 // hand off to other functions to do the real work.
 
+// XXX FIXME XXX -- need some other way to make these functions
+// visible here (they should be in some header file...)
+
 extern void assign (Array2<Complex>&, const Array2<Complex>&);
 extern void assign (Array2<Complex>&, const Array2<double>&);
+extern void assign (Array2<Complex>&, const Array2<char>&);
+
 extern void assign (Array2<double>&, const Array2<double>&);
+extern void assign (Array2<double>&, const Array2<char>&);
+
+extern void assign (Array2<char>&, const Array2<char>&);
 
 void
 TC_REP::assign (tree_constant& rhs, const Octave_object& args)
 {
   tree_constant rhs_tmp = rhs.make_numeric ();
 
   if (error_state)
     return;
 
-  // This is easier than actually handling assignments to strings.  An
-  // assignment to a range will normally require a conversion to a
-  // vector since it will normally destroy the equally-spaced property
-  // of the range elements.
-
-  if (is_defined () && ! is_numeric_type ())
+  // An assignment to a range will normally require a conversion to a
+  // vector in the end anyway, since it will normally destroy the
+  // equally-spaced property of the range elements.  This is not as
+  // memory efficient as possible, but it is much simpler than writing
+  // additional indexing and assignment functions especially for
+  // Ranges.
+
+  if (is_defined () && ! (is_numeric_type () || is_string ()))
     force_numeric ();
 
   if (error_state)
     return;
 
-// Do this before setting the index so that we don't have to copy
-// indices in the Array class.
-
   maybe_widen (rhs.const_type ());
 
   set_index (args);
 
   if (! error_state)
     {
       switch (type_tag)
 	{
@@ -2787,19 +2942,40 @@ TC_REP::assign (tree_constant& rhs, cons
 		panic_impossible ();;
 		break;
 	      }
 	  }
 	  break;
 
 	case scalar_constant:
 	case matrix_constant:
-	  ::assign (*matrix, rhs.matrix_value ());
+	  {
+	    switch (rhs.const_type ())
+	      {
+	      case scalar_constant:
+	      case matrix_constant:
+		::assign (*matrix, rhs.matrix_value ());
+		break;
+
+	      case char_matrix_constant:
+		::assign (*matrix, rhs.char_matrix_value ());
+		break;
+
+	      default:
+		panic_impossible ();
+		break;
+	      }
+	  }
 	  break;
 
+	case char_matrix_constant:
+	case char_matrix_constant_str:
+	  ::assign (*char_matrix, rhs.char_matrix_value ());
+      break;
+
 	default:
 	  panic_impossible ();
 	  break;
 	}
     }
 }
 
 /*
diff --git a/src/pt-const.h b/src/pt-const.h
--- a/src/pt-const.h
+++ b/src/pt-const.h
@@ -63,17 +63,18 @@ private:
 
 	enum constant_type
 	  {
 	    unknown_constant,
 	    scalar_constant,
 	    matrix_constant,
 	    complex_scalar_constant,
 	    complex_matrix_constant,
-	    string_constant,
+	    char_matrix_constant,
+	    char_matrix_constant_str,
 	    range_constant,
 	    map_constant,
 	    magic_colon,
 	    all_va_args,
 	  };
 
 	enum force_orient
 	  {
@@ -92,17 +93,17 @@ private:
 
 	tree_constant_rep (const Complex& c);
 	tree_constant_rep (const ComplexMatrix& m);
 	tree_constant_rep (const ComplexDiagMatrix& d);
 	tree_constant_rep (const ComplexRowVector& v, int pcv);
 	tree_constant_rep (const ComplexColumnVector& v, int pcv);
 
 	tree_constant_rep (const char *s);
-	tree_constant_rep (const Octave_str_obj& s);
+	tree_constant_rep (const charMatrix& chm, int is_string);
 
 	tree_constant_rep (double base, double limit, double inc);
 	tree_constant_rep (const Range& r);
 
 	tree_constant_rep (const Octave_map& m);
 
 	tree_constant_rep (tree_constant_rep::constant_type t);
 
@@ -112,60 +113,64 @@ private:
 
 	void *operator new (size_t size);
 	void operator delete (void *p, size_t size);
 
 	int rows (void) const;
 	int columns (void) const;
 
 	int is_defined (void) const
-	  { return type_tag != tree_constant_rep::unknown_constant; }
+	  { return type_tag != unknown_constant; }
 
 	int is_undefined (void) const
-	  { return type_tag == tree_constant_rep::unknown_constant; }
+	  { return type_tag == unknown_constant; }
 
 	int is_unknown (void) const
-	  { return type_tag == tree_constant_rep::unknown_constant; }
+	  { return type_tag == unknown_constant; }
 
 	int is_real_scalar (void) const
-	  { return type_tag == tree_constant_rep::scalar_constant; }
+	  { return type_tag == scalar_constant; }
 
 	int is_real_matrix (void) const
-	  { return type_tag == tree_constant_rep::matrix_constant; }
+	  { return type_tag == matrix_constant; }
 
 	int is_complex_scalar (void) const
-	  { return type_tag == tree_constant_rep::complex_scalar_constant; }
+	  { return type_tag == complex_scalar_constant; }
 
 	int is_complex_matrix (void) const
-	  { return type_tag == tree_constant_rep::complex_matrix_constant; }
+	  { return type_tag == complex_matrix_constant; }
+
+	int is_char_matrix (void) const
+	  { return type_tag == char_matrix_constant; }
 
 	int is_string (void) const
-	  { return type_tag == tree_constant_rep::string_constant; }
+	  { return type_tag == char_matrix_constant_str; }
 
 	int is_range (void) const
-	  { return type_tag == tree_constant_rep::range_constant; }
+	  { return type_tag == range_constant; }
 
 	int is_map (void) const
-	  { return type_tag == tree_constant_rep::map_constant; }
+	  { return type_tag == map_constant; }
 
 	int is_magic_colon (void) const
-	  { return type_tag == tree_constant_rep::magic_colon; }
+	  { return type_tag == magic_colon; }
 
 	int is_all_va_args (void) const
-	  { return type_tag == tree_constant_rep::all_va_args; }
+	  { return type_tag == all_va_args; }
 
 	tree_constant all (void) const;
 	tree_constant any (void) const;
 
 	int is_real_type (void) const
 	  {
 	    return (type_tag == scalar_constant
 		    || type_tag == matrix_constant
 		    || type_tag == range_constant
-		    || type_tag == string_constant);
+		    || type_tag == char_matrix_constant
+		    || type_tag == char_matrix_constant_str);
 	  }
 
 	int is_complex_type (void) const
 	  {
 	    return (type_tag == complex_matrix_constant
 		    || type_tag == complex_scalar_constant);
 	  }
 
@@ -204,17 +209,18 @@ private:
 		    && (rows () == 0
 			|| columns () == 0));
 	  }
 
 	double double_value (int frc_str_conv = 0) const;
 	Matrix matrix_value (int frc_str_conv = 0) const;
 	Complex complex_value (int frc_str_conv = 0) const;
 	ComplexMatrix complex_matrix_value (int frc_str_conv = 0) const;
-	Octave_str_obj all_strings (void) const;
+	charMatrix char_matrix_value (int frc_str_conv = 0) const;
+	charMatrix all_strings (void) const;
 	const char *string_value (void) const;
 	Range range_value (void) const;
 	Octave_map map_value (void) const;
 
 	tree_constant& lookup_map_element (const char *name, int insert = 0,
 					   int silent = 0);
 
 	ColumnVector vector_value (int frc_str_conv = 0,
@@ -288,17 +294,17 @@ private:
 	// Data.
 
 	union
 	  {
 	    double scalar;		    // A real scalar constant.
 	    Matrix *matrix;		    // A real matrix constant.
 	    Complex *complex_scalar;	    // A real scalar constant.
 	    ComplexMatrix *complex_matrix;  // A real matrix constant.
-	    Octave_str_obj *str_obj;	    // A character string constant.
+	    charMatrix *char_matrix;	    // A character string constant.
 	    Range *range;		    // A set of evenly spaced values.
 	    Octave_map *a_map;	      	    // An associative array.
 
 	    tree_constant_rep *freeptr;     // For custom memory management.
 	  };
 
 	constant_type type_tag;
 
@@ -329,18 +335,19 @@ public:
   //                  DiagMatrix
   //                  RowVector
   //                  ColumnVector
   // complex scalar   Complex
   // complex matrix   ComplexMatrix
   //                  ComplexDiagMatrix
   //                  ComplexRowVector
   //                  ComplexColumnVector
+  // char matrix      charMatrix
   // string           char* (null terminated)
-  //                  Octave_str_obj
+  //                  charMatrix
   // range            double, double, double
   //                  Range
   // map              Octave_map
   // magic colon      tree_constant::magic_colon
   // all_va_args      tree_constant::all_va_args
 
   tree_constant (void) : tree_fvc ()
     { rep = new tree_constant_rep (); rep->count = 1; }
@@ -365,26 +372,26 @@ public:
 
   tree_constant (const ComplexMatrix& m) : tree_fvc ()
     { rep = new tree_constant_rep (m); rep->count = 1; }
 
   tree_constant (const ComplexDiagMatrix& d) : tree_fvc ()
     { rep = new tree_constant_rep (d); rep->count = 1; }
 
   tree_constant (const ComplexRowVector& v, int pcv = -1) : tree_fvc ()
-      { rep = new tree_constant_rep (v, pcv); rep->count = 1; }
+    { rep = new tree_constant_rep (v, pcv); rep->count = 1; }
 
   tree_constant (const ComplexColumnVector& v, int pcv = -1) : tree_fvc () 
-      { rep = new tree_constant_rep (v, pcv); rep->count = 1; }
+    { rep = new tree_constant_rep (v, pcv); rep->count = 1; }
 
   tree_constant (const char *s) : tree_fvc ()
     { rep = new tree_constant_rep (s); rep->count = 1; }
 
-  tree_constant (const Octave_str_obj& s) : tree_fvc ()
-    { rep = new tree_constant_rep (s); rep->count = 1; }
+  tree_constant (const charMatrix& chm, int is_string = 0) : tree_fvc ()
+    { rep = new tree_constant_rep (chm, is_string); rep->count = 1; }
 
   tree_constant (double base, double limit, double inc) : tree_fvc ()
     { rep = new tree_constant_rep (base, limit, inc); rep->count = 1; }
 
   tree_constant (const Range& r) : tree_fvc ()
     { rep = new tree_constant_rep (r); rep->count = 1; }
 
   tree_constant (const Octave_map& m) : tree_fvc ()
@@ -529,17 +536,20 @@ public:
     { return rep->matrix_value (frc_str_conv); }
 
   Complex complex_value (int frc_str_conv = 0) const
     { return rep->complex_value (frc_str_conv); }
 
   ComplexMatrix complex_matrix_value (int frc_str_conv = 0) const
     { return rep->complex_matrix_value (frc_str_conv); }
 
-  Octave_str_obj all_strings (void) const
+  charMatrix char_matrix_value (int frc_str_conv = 0) const
+    { return rep->char_matrix_value (frc_str_conv); }
+
+  charMatrix all_strings (void) const
     { return rep->all_strings (); }
 
   const char *string_value (void) const
     { return rep->string_value (); }
 
   Range range_value (void) const
     { return rep->range_value (); }
 
diff --git a/src/pt-exp-base.cc b/src/pt-exp-base.cc
--- a/src/pt-exp-base.cc
+++ b/src/pt-exp-base.cc
@@ -387,18 +387,17 @@ tree_matrix::eval (int /* print */)
   int put_row = 0;
   int put_col = 0;
 
   int prev_nr = 0;
   int prev_nc = 0;
 
   Matrix m;
   ComplexMatrix cm;
-
-  Octave_str_obj string;
+  charMatrix chm;
 
   // Eliminate empties and gather stats.
 
   int found_new_row_in_empties = 0;
 
   int len = 0;
   for (int i = 0; i < total_len; i++)
     {
@@ -493,18 +492,21 @@ tree_matrix::eval (int /* print */)
 		if (nr != row_height)
 		  {
 		    ::error ("number of rows must match");
 		    goto done;
 		  }
 		else
 		  {
 		    cols_this_row += nc;
+
 		    if (first_row)
 		      col_total = cols_this_row;
+		    else if (all_strings && cols_this_row > col_total)
+		      col_total = cols_this_row;
 		  }
 	      }
 	      break;
 
 	    case md_down:
 	      {
 		if (cols_this_row != col_total && ! all_strings)
 		  {
@@ -522,27 +524,31 @@ tree_matrix::eval (int /* print */)
 	      panic_impossible ();
 	      break;
 	    }
 	}
     }
 
   // Don't forget to check to see if the last element will fit.
 
-  if (cols_this_row != col_total && ! all_strings)
+  if (all_strings && cols_this_row > col_total)
+    {
+      col_total = cols_this_row;
+    }
+  else if (cols_this_row != col_total)
     {
       ::error ("number of columns must match");
       goto done;
     }
 
   // Now, extract the values from the individual elements and insert
   // them in the result matrix.
 
   if (all_strings)
-    string.resize (row_total);
+    chm.resize (row_total, col_total, 0);
   else if (found_complex)
     cm.resize (row_total, col_total, 0.0);
   else
     m.resize (row_total, col_total, 0.0);
 
   for (int i = 0; i < len; i++)
     {
       tree_constant tmp = list[i].elem;
@@ -604,52 +610,40 @@ tree_matrix::eval (int /* print */)
       else
 	{
 	  if (tmp.is_real_scalar ())
 	    {
 	      m (put_row, put_col) = tmp.double_value ();
 	    }
 	  else if (tmp.is_string () && all_strings)
 	    {
-	      switch (list[i].direction)
-		{
-		case md_right:
-		  if (nr == 1)
-		    string.append_right (put_row, tmp.string_value ());
-		  else
-		    string.append_right (tmp.all_strings ());
-		  break;
-
-		case md_none:
-		case md_down:
-		  string.append_down (put_row, tmp.all_strings ());
-		  break;
-		  
-		default:
-		  panic_impossible ();
-		  break;
-		}
+	      charMatrix chm_tmp = tmp.all_strings ();
+
+	      if (error_state)
+		goto done;
+
+	      chm.insert (chm_tmp, put_row, put_col);
 	    }
 	  else
 	    {
 	      Matrix m_tmp = tmp.matrix_value ();
 
 	      if (error_state)
 		goto done;
 
 	      m.insert (m_tmp, put_row, put_col);
 	    }
 	}
 
       prev_nr = nr;
       prev_nc = nc;
     }
 
-  if (all_strings && string.num_strings () > 0)
-    retval = string;
+  if (all_strings && chm.rows () > 0 && chm.cols () > 0)
+    retval = tree_constant (chm, 1);
   else if (found_complex)
     retval = cm;
   else
     retval = m;
 
  done:
   delete [] list;
 
@@ -2527,17 +2521,21 @@ tree_builtin::eval (int /* print */, int
 //
 //      if (nargin > nargin_max)
 //	::error ("%s: too many arguments", my_name);
 //      else
       if (nargin > 0 && args(0).is_defined ())
 	{
 	  tree_constant tmp = apply_mapper_fcn (args(0), mapper_fcn, 0);
 	  retval(0) = tmp;
-	}	
+	}
+      else
+	{
+	  ::error ("%s: too few arguments", my_name);
+	}
     }
   else
     {
       fcn = load_octave_builtin (my_name);
 
       if (fcn)
 	goto eval_fcn;
       else
diff --git a/src/strfns.cc b/src/strfns.cc
--- a/src/strfns.cc
+++ b/src/strfns.cc
@@ -75,33 +75,19 @@ DEFUN ("toascii", Ftoascii, Stoascii, 10
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       tree_constant arg = args(0);
 
       if (arg.is_string ())
 	{
-	  Octave_str_obj str = args(0).all_strings ();
-
-	  int nr = str.num_strings ();
-	  int nc = str.max_length ();
-
-	  // XXX FIXME XXX -- should fill with user-specified value.
-
-	  Matrix m (nr, nc, 0);
+	  charMatrix chm = args(0).all_strings ();
 
-	  for (int i = 0; i < nr; i++)
-	    {
-	      nc = str.elem (i).length ();
-	      for (int j = 0; j < nc; j++)
-		m (i, j) = toascii (str.elem (i) [j]);
-	    }
-
-	  retval = m;
+	  retval = Matrix (chm);
 	}
       else
 	gripe_wrong_type_arg ("toascii", arg);
     }
   else
     print_usage ("toascii");
 
   return retval;
diff --git a/src/toplev.h b/src/toplev.h
--- a/src/toplev.h
+++ b/src/toplev.h
@@ -24,17 +24,17 @@ Software Foundation, 59 Temple Place - S
 #if !defined (octave_octave_h)
 #define octave_octave_h 1
 
 #include <cstdio>
 
 class tree_constant;
 class tree_function;
 class tree_statement_list;
-class Octave_str_obj;
+class charMatrix;
 
 extern void clean_up_and_exit (int) NORETURN;
 
 extern void parse_and_execute (FILE *f, int print = 0);
 extern void parse_and_execute (char *s, int print = 0, int verbose = 0);
 
 extern tree_constant eval_string (const char *string, int print,
 				  int& parse_status);
@@ -83,17 +83,17 @@ extern tree_statement_list *global_comma
 
 // Pointer to function that is currently being evaluated.
 extern tree_function *curr_function;
 
 // Nonzero means input is coming from startup file.
 extern int input_from_startup_file;
 
 // The command-line options.
-extern Octave_str_obj octave_argv;
+extern charMatrix octave_argv;
 
 // Nonzero means that input is coming from a file that was named on
 // the command line.
 extern int input_from_command_line_file;
 
 #endif
 
 /*
