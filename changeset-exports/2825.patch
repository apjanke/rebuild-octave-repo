# HG changeset patch
# User jwe
# Date 859332735 0
#      Tue Mar 25 23:32:15 1997 +0000
# Node ID 60ae49e1284f98d92b5e5ac936739c703bd306d8
# Parent  e56a90687a1e39b997e8a3da279009758577a0f6
[project @ 1997-03-25 23:17:36 by jwe]

diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,45 @@
+Tue Mar 25 17:17:17 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* ov.h, ov.cc, ov-base.h, ov-base.cc: Add constructors and
+	extractors for bool and boolMatrix types. 
+	
+	* ov.cc (install_types): Register octave_bool and
+	octave_bool_matrix types.
+
+	* op-cm-cm.cc, op-cm-cs.cc, op-cm-m.cc, op-cm-s.cc, op-cs-cm.cc,
+	op-cs-m.cc, op-m-cm.cc, op-m-cs.cc, op-m-m.cc, op-m-s.cc,
+	op-s-cm.cc, op-s-m.cc, op-s-s.cc, ov-re-mat.cc:
+	Return boolMatrix instead of Matrix object.
+	* ops.h (BOOL_OP3, MX_MX_BOOL_OP): Likewise.
+
+	* op-b-b.h, op-b-b.cc, op-bm-bm.h, op-bm-bm.cc: New files.
+	* Makefile.in: Add them to the lists.
+	* ops.cc: Include header files here.
+	(install_ops): Call install_b_b_ops() and install_bm_bm_ops() here.
+
+	* variables.cc (symbols_of_variables): Don't rely on default
+	conversion from int to double for value returned from
+	default_history_size().
+
+	* pr-output.cc: Include cstdio.
+
+	* parse.y (param_list_end): Fix typo in last change.
+
+	* quad.cc (quad): Cast integer return values to double.
+	* npsol.cc (show_npsol_option): Likewise.
+	* qpsol.cc (show_qpsol_option): Likewise.
+	* file-io.cc (Fsprintf, Ffwrite): Likewise.
+
+Mon Mar 24 13:11:47 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* ov-typeinfo.cc (typeinfo): If invoked with an argument, return
+	the type of the argument as a string.  Fix doc string.
+
 Thu Mar 20 14:47:49 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* mk-oct-links (links_dir): Don't use -h option for grep.  It's
 	not needed since we are working on one file at a time anyway.
 
 Mon Mar 17 10:53:29 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* lex.l (handle_identifier): When handling indirect_ref, set
diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -72,19 +72,19 @@ INCLUDES := builtins.h data.h defun.h de
 	pt-const.h pt-exp-base.h pt-exp.h pt-fcn.h pt-fvc-base.h \
 	pt-fvc.h pt-mat.h pt-misc.h pt-mvr-base.h pt-mvr.h \
 	pt-plot.h pt-pr-code.h pt-walk.h sighandlers.h symtab.h \
 	syscalls.h sysdep.h systime.h syswait.h token.h toplev.h \
 	unwind-prot.h utils.h variables.h version.h \
 	xdiv.h xpow.h BaseSLList.h Map.h SLList.h SLStack.h Stack.h \
 	ov-re-mat.h ov-cx-mat.h ov-ch-mat.h ov-struct.h ov-scalar.h \
 	ov-range.h ov-complex.h ov-va-args.h ov-colon.h ov-base.h \
-	ov-str-mat.h ov.h ov-typeinfo.h ops.h \
-	op-cm-cm.h op-cm-cs.h op-cm-m.h op-cm-s.h op-cs-cm.h \
-	op-cs-cs.h op-cs-m.h op-cs-s.h op-m-cm.h op-m-cs.h \
+	ov-str-mat.h ov-bool-mat.h ov-bool.h ov.h ov-typeinfo.h ops.h \
+	op-b-b.h op-bm-bm.h op-cm-cm.h op-cm-cs.h op-cm-m.h op-cm-s.h \
+	op-cs-cm.h op-cs-cs.h op-cs-m.h op-cs-s.h op-m-cm.h op-m-cs.h \
 	op-m-m.h op-m-s.h op-s-cm.h op-s-cs.h op-s-m.h op-s-s.h \
 	op-str-str.h
 
 TI_SRC := Array-oc.cc Array-os.cc Array-tc.cc Map-fnc.cc Map-tc.cc \
 	SLList-expr.cc SLList-misc.cc SLList-plot.cc SLList-tc.cc \
 	SLList-tm.cc SLStack-i.cc SLStack-pc.cc SLStack-str.cc \
 	SLStack-sym.cc SLStack-tok.cc SLStack-ue.cc SLStack-ui.cc
 
@@ -101,27 +101,27 @@ SOURCES := BaseSLList.cc Map.cc SLList.c
 	data.cc defaults.cc dirfns.cc dynamic-ld.cc error.cc \
 	file-io.cc fn-cache.cc gripes.cc help.cc input.cc lex.l \
 	load-save.cc mappers.cc oct-fstrm.cc oct-hist.cc \
 	oct-iostrm.cc oct-map.cc oct-obj.cc oct-prcstrm.cc \
 	oct-procbuf.cc oct-stdstrm.cc oct-stream.cc oct-strstrm.cc \
 	pager.cc parse.y pr-output.cc procstream.cc pt-base.cc \
 	pt-cmd.cc pt-const.cc pt-exp-base.cc pt-exp.cc pt-fcn.cc \
 	pt-fvc-base.cc pt-fvc.cc pt-mat.cc pt-misc.cc pt-mvr-base.cc \
-	pt-mvr.cc pt-plot.cc pt-pr-code.cc \
-	sighandlers.cc strcasecmp.c strncase.c strfns.cc strftime.c \
-	symtab.cc syscalls.cc sysdep.cc token.cc toplev.cc \
-	unwind-prot.cc utils.cc variables.cc xdiv.cc xpow.cc \
-	ov-base.cc ov-ch-mat.cc ov-re-mat.cc ov-cx-mat.cc ov-range.cc \
-	ov-scalar.cc ov-complex.cc ov-str-mat.cc ov-struct.cc \
-	ov-va-args.cc ov-colon.cc ov.cc ov-typeinfo.cc ops.cc \
-	op-cm-cm.cc op-cm-cs.cc op-cm-m.cc op-cm-s.cc op-cs-cm.cc \
-	op-cs-cs.cc op-cs-m.cc op-cs-s.cc op-m-cm.cc op-m-cs.cc \
-	op-m-m.cc op-m-s.cc op-s-cm.cc op-s-cs.cc op-s-m.cc op-s-s.cc \
-	op-str-str.cc
+	pt-mvr.cc pt-plot.cc pt-pr-code.cc sighandlers.cc \
+	strcasecmp.c strncase.c strfns.cc strftime.c symtab.cc \
+	syscalls.cc sysdep.cc token.cc toplev.cc unwind-prot.cc \
+	utils.cc variables.cc xdiv.cc xpow.cc ov-base.cc ov-ch-mat.cc \
+	ov-re-mat.cc ov-cx-mat.cc ov-range.cc ov-scalar.cc \
+	ov-complex.cc ov-str-mat.cc ov-struct.cc ov-va-args.cc \
+	ov-colon.cc ov-bool-mat.cc ov-bool.cc ov.cc ov-typeinfo.cc \
+	ops.cc op-b-b.cc op-bm-bm.cc op-cm-cm.cc op-cm-cs.cc \
+	op-cm-m.cc op-cm-s.cc op-cs-cm.cc op-cs-cs.cc op-cs-m.cc \
+	op-cs-s.cc op-m-cm.cc op-m-cs.cc op-m-m.cc op-m-s.cc \
+	op-s-cm.cc op-s-cs.cc op-s-m.cc op-s-s.cc op-str-str.cc
 
 OBJECTS_4 := $(SOURCES)
 OBJECTS_3 := $(patsubst %.l, %.o, $(OBJECTS_4))
 OBJECTS_2 := $(patsubst %.y, %.o, $(OBJECTS_3))
 OBJECTS_1 := $(patsubst %.c, %.o, $(OBJECTS_2))
 OBJECTS := $(patsubst %.cc, %.o, $(OBJECTS_1))
 
 ifeq ($(SHARED_LIBS), true)
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -609,17 +609,17 @@ DEFUN (sprintf, args, ,
 	      if (nargin > 1)
 		{
 		  tmp_args.resize (nargin-1, octave_value ());
 
 		  for (int i = 1; i < nargin; i++)
 		    tmp_args(i-1) = args(i);
 		}
 
-	      retval(2) = os.printf (fmt, tmp_args);
+	      retval(2) = static_cast<double> (os.printf (fmt, tmp_args));
 	      retval(1) = os.error ();
 	      char *tmp = ostr.str ();
 	      retval(0) = tmp;
 	      delete [] tmp;
 	    }
 	  else
 	    ::error ("sprintf: format must be a string");
 	}
@@ -1102,17 +1102,19 @@ DEFUN (fwrite, args, ,
 	    ? args(2) : octave_value ("uchar");
 
 	  octave_value skip = (nargin > 3)
 	    ? args(3) : octave_value (0.0);
 
 	  octave_value arch = (nargin > 4)
 	    ? args(4) : octave_value ("unknown");
 
-	  retval = do_fwrite (*os, data, prec, skip, arch);
+	  double status = do_fwrite (*os, data, prec, skip, arch);
+
+	  retval = status;
 	}
       else
 	gripe_invalid_file_id ("fwrite");
     }
   else
     print_usage ("fwrite");
 
   return retval;
diff --git a/src/npsol.cc b/src/npsol.cc
--- a/src/npsol.cc
+++ b/src/npsol.cc
@@ -770,17 +770,17 @@ show_npsol_option (const string& keyword
 		retval = val;
 	    }
 	  else
 	    {
 	      int val = (npsol_opts.*list->i_get_fcn) ();
 	      if (val < 0)
 		retval = "depends on problem size";
 	      else
-		retval = val;
+		retval = static_cast<double> (val);
 	    }
 
 	  return retval;
 	}
       list++;
     }
 
   warning ("npsol_options: no match for `%s'", keyword.c_str ());
diff --git a/src/op-b-b.cc b/src/op-b-b.cc
new file mode 100644
--- /dev/null
+++ b/src/op-b-b.cc
@@ -0,0 +1,69 @@
+/*
+
+Copyright (C) 1996 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "gripes.h"
+#include "ov.h"
+#include "ov-bool.h"
+#include "ov-typeinfo.h"
+#include "op-b-b.h"
+#include "ops.h"
+#include "xdiv.h"
+#include "xpow.h"
+
+// bool by bool ops.
+
+static octave_value
+eq (const octave_value& a1, const octave_value& a2)
+{
+  CAST_BINOP_ARGS (const octave_bool&, const octave_bool&);
+
+  return octave_value (v1.bool_value () == v2.bool_value ());
+}
+
+static octave_value
+ne (const octave_value& a1, const octave_value& a2)
+{
+  CAST_BINOP_ARGS (const octave_bool&, const octave_bool&);
+
+  return octave_value (v1.bool_value () != v2.bool_value ());
+}
+
+void
+install_b_b_ops (void)
+{
+  INSTALL_BINOP (eq, octave_bool, octave_bool, eq);
+  INSTALL_BINOP (ne, octave_bool, octave_bool, ne);
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/op-b-b.h b/src/op-b-b.h
new file mode 100644
--- /dev/null
+++ b/src/op-b-b.h
@@ -0,0 +1,34 @@
+/*
+
+Copyright (C) 1996 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if !defined (octave_op_b_b_h)
+#define octave_op_b_b_h 1
+
+extern void install_b_b_ops (void);
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/op-bm-bm.cc b/src/op-bm-bm.cc
new file mode 100644
--- /dev/null
+++ b/src/op-bm-bm.cc
@@ -0,0 +1,69 @@
+/*
+
+Copyright (C) 1996 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "gripes.h"
+#include "ov.h"
+#include "ov-bool-mat.h"
+#include "ov-typeinfo.h"
+#include "op-b-b.h"
+#include "ops.h"
+#include "xdiv.h"
+#include "xpow.h"
+
+// bool matrix by bool matrix ops.
+
+static octave_value
+eq (const octave_value& a1, const octave_value& a2)
+{
+  CAST_BINOP_ARGS (const octave_bool_matrix&, const octave_bool_matrix&);
+
+  return octave_value (v1.bool_matrix_value () == v2.bool_matrix_value ());
+}
+
+static octave_value
+ne (const octave_value& a1, const octave_value& a2)
+{
+  CAST_BINOP_ARGS (const octave_bool_matrix&, const octave_bool_matrix&);
+
+  return octave_value (v1.bool_matrix_value () != v2.bool_matrix_value ());
+}
+
+void
+install_bm_bm_ops (void)
+{
+  INSTALL_BINOP (eq, octave_bool_matrix, octave_bool_matrix, eq);
+  INSTALL_BINOP (ne, octave_bool_matrix, octave_bool_matrix, ne);
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/op-bm-bm.h b/src/op-bm-bm.h
new file mode 100644
--- /dev/null
+++ b/src/op-bm-bm.h
@@ -0,0 +1,34 @@
+/*
+
+Copyright (C) 1996 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if !defined (octave_op_bm_bm_h)
+#define octave_op_bm_bm_h 1
+
+extern void install_bm_bm_ops (void);
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/op-cm-cm.cc b/src/op-cm-cm.cc
--- a/src/op-cm-cm.cc
+++ b/src/op-cm-cm.cc
@@ -95,25 +95,25 @@ ldiv (const octave_value& a1, const octa
 		 real (m1 (i, j)) OP real (m2 (i, j)), #OP, \
 		 ONE_EMPTY_RESULT, TWO_EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (<, Matrix (), Matrix ());
+  BOOL_OP (<, boolMatrix (), boolMatrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (<=, Matrix (), Matrix ());
+  BOOL_OP (<=, boolMatrix (), boolMatrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
   MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (),
@@ -122,25 +122,25 @@ eq (const octave_value& a1, const octave
 		 0.0, 1.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (>=, Matrix (), Matrix ());
+  BOOL_OP (>=, boolMatrix (), boolMatrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (>, Matrix (), Matrix ());
+  BOOL_OP (>, boolMatrix (), boolMatrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
   MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (),
@@ -187,28 +187,28 @@ el_ldiv (const octave_value& a1, const o
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
   MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (),
 		 ComplexMatrix, m2, v2.complex_matrix_value (),
 		 m1 (i, j) != 0.0 && m2 (i, j) != 0.0, "&",
-		 Matrix (), Matrix ());
+		 boolMatrix (), boolMatrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
   MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (),
 		 ComplexMatrix, m2, v2.complex_matrix_value (),
 		 m1 (i, j) != 0.0 || m2 (i, j) != 0.0, "|",
-		 Matrix (), Matrix ());
+		 boolMatrix (), boolMatrix ());
 }
 
 static octave_value
 assign (octave_value& a1, const octave_value_list& idx,
 	const octave_value& a2)
 {
   CAST_BINOP_ARGS (octave_complex_matrix&, const octave_complex_matrix&);
 
diff --git a/src/op-cm-cs.cc b/src/op-cm-cs.cc
--- a/src/op-cm-cs.cc
+++ b/src/op-cm-cs.cc
@@ -97,25 +97,25 @@ ldiv (const octave_value& v1, const octa
 		 Complex, s, v2.complex_value (), \
 		 real (m (i, j)) OP real (s), EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
-  BOOL_OP (<, Matrix ());
+  BOOL_OP (<, boolMatrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
-  BOOL_OP (<=, Matrix ());
+  BOOL_OP (<=, boolMatrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
   MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (),
@@ -123,25 +123,25 @@ eq (const octave_value& a1, const octave
 		 m (i, j) == s, 0.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
-  BOOL_OP (>=, Matrix ());
+  BOOL_OP (>=, boolMatrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
-  BOOL_OP (>, Matrix ());
+  BOOL_OP (>, boolMatrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
   MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (),
@@ -188,27 +188,27 @@ el_ldiv (const octave_value& a1, const o
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
   MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (),
 		 Complex, s, v2.complex_value (),
-		 m (i, j) != 0.0 && s != 0.0, Matrix ());
+		 m (i, j) != 0.0 && s != 0.0, boolMatrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
   MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (),
 		 Complex, s, v2.complex_value (),
-		 m (i, j) != 0.0 || s != 0.0, Matrix ());
+		 m (i, j) != 0.0 || s != 0.0, boolMatrix ());
 }
 
 static octave_value
 assign (octave_value& a1, const octave_value_list& idx,
 	const octave_value& a2)
 {
   CAST_BINOP_ARGS (octave_complex_matrix&, const octave_complex&);
 
diff --git a/src/op-cm-m.cc b/src/op-cm-m.cc
--- a/src/op-cm-m.cc
+++ b/src/op-cm-m.cc
@@ -23,16 +23,19 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include "mx-cm-m.h"
+#include "mx-m-cm.h"
+
 #include "gripes.h"
 #include "ov.h"
 #include "ov-cx-mat.h"
 #include "ov-re-mat.h"
 #include "ov-typeinfo.h"
 #include "op-cm-m.h"
 #include "ops.h"
 #include "xdiv.h"
@@ -93,25 +96,25 @@ ldiv (const octave_value& a1, const octa
 		 real (m1 (i, j)) OP m2 (i, j), #OP, \
 		 ONE_EMPTY_RESULT, TWO_EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
-  BOOL_OP (<, Matrix (), Matrix ());
+  BOOL_OP (<, boolMatrix (), boolMatrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
-  BOOL_OP (<=, Matrix (), Matrix ());
+  BOOL_OP (<=, boolMatrix (), boolMatrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
   MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (),
@@ -120,25 +123,25 @@ eq (const octave_value& a1, const octave
 		 0.0, 1.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
-  BOOL_OP (>=, Matrix (), Matrix ());
+  BOOL_OP (>=, boolMatrix (), boolMatrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
-  BOOL_OP (>, Matrix (), Matrix ());
+  BOOL_OP (>, boolMatrix (), boolMatrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
   MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (),
@@ -182,28 +185,28 @@ el_ldiv (const octave_value& a1, const o
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
   MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (),
 		 Matrix, m2, v2.matrix_value (),
 		 m1 (i, j) != 0.0 && m2 (i, j), "&",
-		 Matrix (), Matrix ());
+		 boolMatrix (), boolMatrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
   MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (),
 		 Matrix, m2, v2.matrix_value (),
 		 m1 (i, j) != 0.0 || m2 (i, j), "|",
-		 Matrix (), Matrix ());
+		 boolMatrix (), boolMatrix ());
 }
 
 static octave_value
 assign (octave_value& a1, const octave_value_list& idx,
 	const octave_value& a2)
 {
   CAST_BINOP_ARGS (octave_complex_matrix&, const octave_matrix&);
 
diff --git a/src/op-cm-s.cc b/src/op-cm-s.cc
--- a/src/op-cm-s.cc
+++ b/src/op-cm-s.cc
@@ -23,16 +23,18 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include "mx-cm-s.h"
+
 #include "gripes.h"
 #include "ov.h"
 #include "ov-cx-mat.h"
 #include "ov-scalar.h"
 #include "ov-typeinfo.h"
 #include "op-cm-s.h"
 #include "ops.h"
 #include "xdiv.h"
@@ -97,25 +99,25 @@ ldiv (const octave_value& v1, const octa
 		 double, s, v2.double_value (), \
 		 real (m (i, j)) OP s, EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
-  BOOL_OP (<, Matrix ());
+  BOOL_OP (<, boolMatrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
-  BOOL_OP (<=, Matrix ());
+  BOOL_OP (<=, boolMatrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
   MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (),
@@ -123,25 +125,25 @@ eq (const octave_value& a1, const octave
 		 m (i, j) == s, 0.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
-  BOOL_OP (>=, Matrix ());
+  BOOL_OP (>=, boolMatrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
-  BOOL_OP (>, Matrix ());
+  BOOL_OP (>, boolMatrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
   MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (),
@@ -188,27 +190,27 @@ el_ldiv (const octave_value& a1, const o
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
   MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (),
 		 double, s, v2.double_value (),
-		 m (i, j) != 0.0 && s, Matrix ());
+		 m (i, j) != 0.0 && s, boolMatrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
   MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (),
 		 double, s, v2.double_value (),
-		 m (i, j) != 0.0 || s, Matrix ());
+		 m (i, j) != 0.0 || s, boolMatrix ());
 }
 
 static octave_value
 assign (octave_value& a1, const octave_value_list& idx,
 	const octave_value& a2)
 {
   CAST_BINOP_ARGS (octave_complex_matrix&, const octave_scalar&);
 
diff --git a/src/op-cs-cm.cc b/src/op-cs-cm.cc
--- a/src/op-cs-cm.cc
+++ b/src/op-cs-cm.cc
@@ -97,25 +97,25 @@ ldiv (const octave_value& a1, const octa
 		 ComplexMatrix, m, v2.complex_matrix_value (), \
 		 real (s) OP real (m (i, j)), EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
-  BOOL_OP (<, Matrix ());
+  BOOL_OP (<, boolMatrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
-  BOOL_OP (<=, Matrix ());
+  BOOL_OP (<=, boolMatrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
   SC_MX_BOOL_OP (Complex, s, v1.complex_value (),
@@ -123,25 +123,25 @@ eq (const octave_value& a1, const octave
 		 s == m (i, j), 0.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
-  BOOL_OP (>=, Matrix ());
+  BOOL_OP (>=, boolMatrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
-  BOOL_OP (>, Matrix ());
+  BOOL_OP (>, boolMatrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
   SC_MX_BOOL_OP (Complex, s, v1.complex_value (),
@@ -188,27 +188,27 @@ el_ldiv (const octave_value& a1, const o
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
   SC_MX_BOOL_OP (Complex, s, v1.complex_value (),
 		 ComplexMatrix, m, v2.complex_matrix_value (),
-		 s != 0.0 && m (i, j) != 0.0, Matrix ());
+		 s != 0.0 && m (i, j) != 0.0, boolMatrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
   SC_MX_BOOL_OP (Complex, s, v1.complex_value (),
 		 ComplexMatrix, m, v2.complex_matrix_value (),
-		 s != 0.0 || m (i, j) != 0.0, Matrix ());
+		 s != 0.0 || m (i, j) != 0.0, boolMatrix ());
 }
 
 static octave_value *
 complex_matrix_conv (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_complex&);
 
   return new octave_complex_matrix (v.complex_matrix_value ());
diff --git a/src/op-cs-m.cc b/src/op-cs-m.cc
--- a/src/op-cs-m.cc
+++ b/src/op-cs-m.cc
@@ -23,16 +23,19 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include "mx-cs-m.h"
+#include "mx-m-cs.h"
+
 #include "gripes.h"
 #include "ov.h"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-re-mat.h"
 #include "ov-typeinfo.h"
 #include "op-cs-m.h"
 #include "ops.h"
@@ -98,25 +101,25 @@ ldiv (const octave_value& a1, const octa
 		 Matrix, m, v2.matrix_value (), \
 		 real (s) OP m (i, j), EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
-  BOOL_OP (<, Matrix ());
+  BOOL_OP (<, boolMatrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
-  BOOL_OP (<=, Matrix ());
+  BOOL_OP (<=, boolMatrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
   SC_MX_BOOL_OP (Complex, s, v1.complex_value (),
@@ -124,25 +127,25 @@ eq (const octave_value& a1, const octave
 		 s == m (i, j), 0.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
-  BOOL_OP (>=, Matrix ());
+  BOOL_OP (>=, boolMatrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
-  BOOL_OP (>, Matrix ());
+  BOOL_OP (>, boolMatrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
   SC_MX_BOOL_OP (Complex, s, v1.complex_value (),
@@ -189,27 +192,27 @@ el_ldiv (const octave_value& a1, const o
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
   SC_MX_BOOL_OP (Complex, s, v1.complex_value (), \
 		 Matrix, m, v2.matrix_value (), \
-		 s != 0.0 && m (i, j), Matrix ());
+		 s != 0.0 && m (i, j), boolMatrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
   SC_MX_BOOL_OP (Complex, s, v1.complex_value (), \
 		 Matrix, m, v2.matrix_value (), \
-		 s != 0.0 || m (i, j), Matrix ());
+		 s != 0.0 || m (i, j), boolMatrix ());
 }
 
 static octave_value *
 complex_matrix_conv (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_complex&);
 
   return new octave_complex_matrix (v.complex_matrix_value ());
diff --git a/src/op-m-cm.cc b/src/op-m-cm.cc
--- a/src/op-m-cm.cc
+++ b/src/op-m-cm.cc
@@ -23,16 +23,19 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include "mx-m-cm.h"
+#include "mx-cm-m.h"
+
 #include "gripes.h"
 #include "ov.h"
 #include "ov-re-mat.h"
 #include "ov-cx-mat.h"
 #include "ov-typeinfo.h"
 #include "op-m-cm.h"
 #include "ops.h"
 #include "xdiv.h"
@@ -93,25 +96,25 @@ ldiv (const octave_value& a1, const octa
 		 m1 (i, j) OP real (m2 (i, j)), #OP, \
 		 ONE_EMPTY_RESULT, TWO_EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (<, Matrix (), Matrix ());
+  BOOL_OP (<, boolMatrix (), boolMatrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (<=, Matrix (), Matrix ());
+  BOOL_OP (<=, boolMatrix (), boolMatrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
   MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (),
@@ -120,25 +123,25 @@ eq (const octave_value& a1, const octave
 		 0.0, 1.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (>=, Matrix (), Matrix ());
+  BOOL_OP (>=, boolMatrix (), boolMatrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (>, Matrix (), Matrix ());
+  BOOL_OP (>, boolMatrix (), boolMatrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
   MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (),
@@ -182,28 +185,28 @@ el_ldiv (const octave_value& a1, const o
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
   MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (),
 		 ComplexMatrix, m2, v2.complex_matrix_value (),
 		 m1 (i, j) && m2 (i, j) != 0.0, "&",
-		 Matrix (), Matrix ());
+		 boolMatrix (), boolMatrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
   MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (),
 		 ComplexMatrix, m2, v2.complex_matrix_value (),
 		 m1 (i, j) || m2 (i, j) != 0.0, "|",
-		 Matrix (), Matrix ());
+		 boolMatrix (), boolMatrix ());
 }
 
 static octave_value *
 complex_matrix_conv (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_matrix&);
 
   return new octave_complex_matrix (ComplexMatrix (v.matrix_value ()));
diff --git a/src/op-m-cs.cc b/src/op-m-cs.cc
--- a/src/op-m-cs.cc
+++ b/src/op-m-cs.cc
@@ -23,16 +23,19 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include "mx-m-cs.h"
+#include "mx-cs-m.h"
+
 #include "gripes.h"
 #include "ov.h"
 #include "ov-re-mat.h"
 #include "ov-cx-mat.h"
 #include "ov-complex.h"
 #include "ov-typeinfo.h"
 #include "op-m-cs.h"
 #include "ops.h"
@@ -98,25 +101,25 @@ ldiv (const octave_value& v1, const octa
 		 Complex, s, v2.complex_value (), \
 		 m (i, j) OP real (s), EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
-  BOOL_OP (<, Matrix ());
+  BOOL_OP (<, boolMatrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
-  BOOL_OP (<=, Matrix ());
+  BOOL_OP (<=, boolMatrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
   MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (),
@@ -124,25 +127,25 @@ eq (const octave_value& a1, const octave
 		 m (i, j) == s, 0.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
-  BOOL_OP (>=, Matrix ());
+  BOOL_OP (>=, boolMatrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
-  BOOL_OP (>, Matrix ());
+  BOOL_OP (>, boolMatrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
   MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (),
@@ -189,27 +192,27 @@ el_ldiv (const octave_value& a1, const o
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
   MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (),
 		 Complex, s, v2.complex_value (),
-		 m (i, j) && s != 0.0, Matrix ());
+		 m (i, j) && s != 0.0, boolMatrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
   MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (),
 		 Complex, s, v2.complex_value (),
-		 m (i, j) || s != 0.0, Matrix ());
+		 m (i, j) || s != 0.0, boolMatrix ());
 }
 
 static octave_value *
 complex_matrix_conv (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_matrix&);
 
   return new octave_complex_matrix (ComplexMatrix (v.matrix_value ()));
diff --git a/src/op-m-m.cc b/src/op-m-m.cc
--- a/src/op-m-m.cc
+++ b/src/op-m-m.cc
@@ -92,49 +92,49 @@ ldiv (const octave_value& a1, const octa
 		 m1 (i, j) OP m2 (i, j), #OP, \
 		 ONE_EMPTY_RESULT, TWO_EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
-  BOOL_OP (<, Matrix (), Matrix ());
+  BOOL_OP (<, boolMatrix (), boolMatrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
-  BOOL_OP (<=, Matrix (), Matrix ());
+  BOOL_OP (<=, boolMatrix (), boolMatrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
   BOOL_OP (==, 0.0, 1.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
-  BOOL_OP (>=, Matrix (), Matrix ());
+  BOOL_OP (>=, boolMatrix (), boolMatrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
-  BOOL_OP (>, Matrix (), Matrix ());
+  BOOL_OP (>, boolMatrix (), boolMatrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
   BOOL_OP (!=, 1.0, 0.0);
@@ -175,28 +175,28 @@ el_ldiv (const octave_value& a1, const o
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
   MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (),
 		 Matrix, m2, v2.matrix_value (),
 		 m1 (i, j) && m2 (i, j), "&",
-		 Matrix (), Matrix ());
+		 boolMatrix (), boolMatrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
   MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (),
 		 Matrix, m2, v2.matrix_value (),
 		 m1 (i, j) || m2 (i, j), "|",
-		 Matrix (), Matrix ());
+		 boolMatrix (), boolMatrix ());
 }
 
 static octave_value
 assign (octave_value& a1, const octave_value_list& idx,
 	const octave_value& a2)
 {
   CAST_BINOP_ARGS (octave_matrix&, const octave_matrix&);
 
diff --git a/src/op-m-s.cc b/src/op-m-s.cc
--- a/src/op-m-s.cc
+++ b/src/op-m-s.cc
@@ -97,49 +97,49 @@ ldiv (const octave_value& v1, const octa
 		 double, s, v2.double_value (), \
 		 m (i, j) OP s, EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
-  BOOL_OP (<, Matrix ());
+  BOOL_OP (<, boolMatrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
-  BOOL_OP (<=, Matrix ());
+  BOOL_OP (<=, boolMatrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
   BOOL_OP (==, 0.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
-  BOOL_OP (>=, Matrix ());
+  BOOL_OP (>=, boolMatrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
-  BOOL_OP (>, Matrix ());
+  BOOL_OP (>, boolMatrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
   BOOL_OP (!=, 1.0);
@@ -184,27 +184,27 @@ el_ldiv (const octave_value& a1, const o
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
   MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (),
                  double, s, v2.double_value (),
-		 m (i, j) && s, Matrix ());
+		 m (i, j) && s, boolMatrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
   MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (),
                  double, s, v2.double_value (),
-		 m (i, j) || s, Matrix ());
+		 m (i, j) || s, boolMatrix ());
 }
 
 static octave_value
 assign (octave_value& a1, const octave_value_list& idx,
 	const octave_value& a2)
 {
   CAST_BINOP_ARGS (octave_matrix&, const octave_scalar&);
 
diff --git a/src/op-s-cm.cc b/src/op-s-cm.cc
--- a/src/op-s-cm.cc
+++ b/src/op-s-cm.cc
@@ -23,16 +23,18 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include "mx-s-cm.h"
+
 #include "gripes.h"
 #include "ov.h"
 #include "ov-scalar.h"
 #include "ov-cx-mat.h"
 #include "ov-typeinfo.h"
 #include "op-s-cm.h"
 #include "ops.h"
 #include "xdiv.h"
@@ -97,25 +99,25 @@ ldiv (const octave_value& a1, const octa
 		 ComplexMatrix, m, v2.complex_matrix_value (), \
 		 s OP real (m (i, j)), EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
-  BOOL_OP (<, Matrix ());
+  BOOL_OP (<, boolMatrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
-  BOOL_OP (<=, Matrix ());
+  BOOL_OP (<=, boolMatrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
   SC_MX_BOOL_OP (double, s, v1.double_value (),
@@ -123,25 +125,25 @@ eq (const octave_value& a1, const octave
 		 s == m (i, j), 0.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
-  BOOL_OP (>=, Matrix ());
+  BOOL_OP (>=, boolMatrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
-  BOOL_OP (>, Matrix ());
+  BOOL_OP (>, boolMatrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
   SC_MX_BOOL_OP (double, s, v1.double_value (),
@@ -188,27 +190,27 @@ el_ldiv (const octave_value& a1, const o
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
   SC_MX_BOOL_OP (double, s, v1.double_value (),
 		 ComplexMatrix, m, v2.complex_matrix_value (),
-		 s && m (i, j) != 0.0, Matrix ());
+		 s && m (i, j) != 0.0, boolMatrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
   SC_MX_BOOL_OP (double, s, v1.double_value (),
 		 ComplexMatrix, m, v2.complex_matrix_value (),
-		 s || m (i, j) != 0.0, Matrix ());
+		 s || m (i, j) != 0.0, boolMatrix ());
 }
 
 static octave_value *
 complex_matrix_conv (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_scalar&);
 
   return new octave_complex_matrix (v.complex_matrix_value ());
diff --git a/src/op-s-m.cc b/src/op-s-m.cc
--- a/src/op-s-m.cc
+++ b/src/op-s-m.cc
@@ -97,49 +97,49 @@ ldiv (const octave_value& a1, const octa
 		 Matrix, m, v2.matrix_value (), \
 		 s OP m (i, j), EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
-  BOOL_OP (<, Matrix ());
+  BOOL_OP (<, boolMatrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
-  BOOL_OP (<=, Matrix ());
+  BOOL_OP (<=, boolMatrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
   BOOL_OP (==, 0.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
-  BOOL_OP (>=, Matrix ());
+  BOOL_OP (>=, boolMatrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
-  BOOL_OP (>, Matrix ());
+  BOOL_OP (>, boolMatrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
   BOOL_OP (!=, 1.0);
@@ -184,27 +184,27 @@ el_ldiv (const octave_value& a1, const o
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
   SC_MX_BOOL_OP (double, s, v1.double_value (),
                  Matrix, m, v2.matrix_value (),
-		 s && m (i, j), Matrix ());
+		 s && m (i, j), boolMatrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
   SC_MX_BOOL_OP (double, s, v1.double_value (),
                  Matrix, m, v2.matrix_value (),
-		 s || m (i, j), Matrix ());
+		 s || m (i, j), boolMatrix ());
 }
 
 static octave_value *
 matrix_conv (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_scalar&);
 
   return new octave_matrix (v.matrix_value ());
diff --git a/src/op-s-s.cc b/src/op-s-s.cc
--- a/src/op-s-s.cc
+++ b/src/op-s-s.cc
@@ -188,25 +188,29 @@ el_ldiv (const octave_value& a1, const o
   return octave_value (v2.double_value () / d);
 }
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
 
-  return octave_value (v1.double_value () && v2.double_value ());
+  double result = v1.double_value () && v2.double_value ();
+
+  return octave_value (result);
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
 
-  return octave_value (v1.double_value () || v2.double_value ());
+  double result = v1.double_value () || v2.double_value ();
+
+  return octave_value (result);
 }
 
 static octave_value *
 matrix_conv (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_scalar&);
 
   return new octave_matrix (v.matrix_value ());
diff --git a/src/ops.cc b/src/ops.cc
--- a/src/ops.cc
+++ b/src/ops.cc
@@ -25,16 +25,18 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "ov-base.h"
 
+#include "op-b-b.h"
+#include "op-bm-bm.h"
 #include "op-cm-cm.h"
 #include "op-cm-cs.h"
 #include "op-cm-m.h"
 #include "op-cm-s.h"
 #include "op-cs-cm.h"
 #include "op-cs-cs.h"
 #include "op-cs-m.h"
 #include "op-cs-s.h"
@@ -48,16 +50,18 @@ Software Foundation, 59 Temple Place - S
 #include "op-s-s.h"
 #include "op-str-str.h"
 
 void
 install_ops (void)
 {
   install_base_type_conversions ();
 
+  install_b_b_ops ();
+  install_bm_bm_ops ();
   install_cm_cm_ops ();
   install_cm_cs_ops ();
   install_cm_m_ops ();
   install_cm_s_ops ();
   install_cs_cm_ops ();
   install_cs_cs_ops ();
   install_cs_m_ops ();
   install_cs_s_ops ();
diff --git a/src/ops.h b/src/ops.h
--- a/src/ops.h
+++ b/src/ops.h
@@ -49,17 +49,17 @@ extern void install_ops (void);
   xt xn = get_x; \
   yt yn = get_y;
 
 #define BOOL_OP2(x) \
   int nr = x.rows (); \
   int nc = x.columns ();
 
 #define BOOL_OP3(test) \
-  Matrix retval (nr, nc); \
+  boolMatrix retval (nr, nc); \
   for (int j = 0; j < nc; j++) \
     for (int i = 0; i < nr; i++) \
       retval (i, j) = test; \
   return retval;
 
 #define SC_MX_BOOL_OP(st, sn, get_s, mt, mn, get_m, test, empty_result) \
   do \
     { \
@@ -104,17 +104,17 @@ extern void install_ops (void);
       else \
 	{ \
 	  if ((m1_nr == 0 && m1_nc == 0) || (m2_nr == 0 && m2_nc == 0)) \
 	    return one_empty_result; \
 	  else \
 	    { \
 	      gripe_nonconformant ("operator " op, m1_nr, m1_nc, \
 				   m2_nr, m2_nc); \
-	      return Matrix (); \
+	      return boolMatrix (); \
 	    } \
 	} \
     } \
   while (0)
 
 #define CAST_BINOP_ARGS(t1, t2) \
   t1 v1 = DYNAMIC_CAST (t1, a1); \
   t2 v2 = DYNAMIC_CAST (t2, a2);
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -172,16 +172,33 @@ octave_base_value::range_value (void) co
 Octave_map
 octave_base_value::map_value (void) const
 {
   Octave_map retval;
   gripe_wrong_type_arg ("octave_base_value::map_value()", type_name ());
   return retval;
 }
 
+bool
+octave_base_value::bool_value (void) const
+{
+  bool retval = false;
+  gripe_wrong_type_arg ("octave_base_value::bool_value()", type_name ());
+  return retval;
+}
+
+boolMatrix
+octave_base_value::bool_matrix_value (void) const
+{
+  boolMatrix retval;
+  gripe_wrong_type_arg ("octave_base_value::bool_matrix_value()",
+			type_name ());
+  return retval;
+}
+
 octave_value
 octave_base_value::not (void) const
 {
   octave_value retval;
   gripe_wrong_type_arg ("octave_base_value::not()", type_name ());
   return retval;
 }
 
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -145,16 +145,20 @@ public:
   string_vector all_strings (void) const;
 
   string string_value (void) const;
 
   Range range_value (void) const;
 
   Octave_map map_value (void) const;
 
+  bool bool_value (void) const;
+
+  boolMatrix bool_matrix_value (void) const;
+
   octave_value not (void) const;
 
   octave_value uminus (void) const;
 
   octave_value transpose (void) const;
 
   octave_value hermitian (void) const;
 
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -54,18 +54,16 @@ octave_matrix::octave_matrix (const RowV
     matrix ((pcv < 0 && Vprefer_column_vectors) || pcv
 	    ? Matrix (v.transpose ()) : Matrix (v)) { }
 
 octave_matrix::octave_matrix (const ColumnVector& v, int pcv)
   : octave_base_value (),
     matrix ((pcv < 0 && Vprefer_column_vectors) || pcv
 	    ? Matrix (v) : Matrix (v.transpose ())) { }
 
-#include <iostream.h>
-
 octave_value *
 octave_matrix::try_narrowing_conversion (void)
 {
   octave_value *retval = 0;
 
   int nr = matrix.rows ();
   int nc = matrix.cols ();
 
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -27,16 +27,18 @@ Software Foundation, 59 Temple Place - S
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "Array-flags.h"
 
 #include "ov.h"
 #include "ov-base.h"
+#include "ov-bool.h"
+#include "ov-bool-mat.h"
 #include "ov-scalar.h"
 #include "ov-re-mat.h"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-ch-mat.h"
 #include "ov-str-mat.h"
 #include "ov-range.h"
 #include "ov-struct.h"
@@ -216,20 +218,26 @@ octave_value::binary_op_as_string (binar
     default:
       retval = "<unknown>";
     }
 
   return retval;
 }
 
 octave_value::octave_value (void)
-  : rep (new octave_base_value ()) { rep->count = 1; }
+  : rep (new octave_base_value ())
+{
+  rep->count = 1;
+}
 
 octave_value::octave_value (double d)
-  : rep (new octave_scalar (d)) { rep->count = 1; }
+  : rep (new octave_scalar (d))
+{
+  rep->count = 1;
+}
 
 octave_value::octave_value (const Matrix& m)
   : rep (new octave_matrix (m))
 {
   rep->count = 1;
   maybe_mutate ();
 }
 
@@ -284,16 +292,29 @@ octave_value::octave_value (const Comple
 
 octave_value::octave_value (const ComplexColumnVector& v, int pcv)
   : rep (new octave_complex_matrix (v, pcv))
 {
   rep->count = 1;
   maybe_mutate ();
 }
 
+octave_value::octave_value (bool b)
+  : rep (new octave_bool (b))
+{
+  rep->count = 1;
+}
+
+octave_value::octave_value (const boolMatrix& bm)
+  : rep (new octave_bool_matrix (bm))
+{
+  rep->count = 1;
+  maybe_mutate ();
+}
+
 octave_value::octave_value (const char *s)
   : rep (new octave_char_matrix_str (s))
 {
   rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const string& s)
@@ -332,26 +353,38 @@ octave_value::octave_value (double base,
 octave_value::octave_value (const Range& r)
   : rep (new octave_range (r))
 {
   rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const Octave_map& m)
-  : rep (new octave_struct (m)) { rep->count = 1; }
+  : rep (new octave_struct (m))
+{
+  rep->count = 1;
+ }
 
 octave_value::octave_value (octave_value::magic_colon)
-  : rep (new octave_magic_colon ()) { rep->count = 1; }
+  : rep (new octave_magic_colon ())
+{
+  rep->count = 1;
+}
 
 octave_value::octave_value (octave_value::all_va_args)
-  : rep (new octave_all_va_args ()) { rep->count = 1; }
+  : rep (new octave_all_va_args ())
+{
+  rep->count = 1;
+}
 
 octave_value::octave_value (octave_value *new_rep)
-  : rep (new_rep) { rep->count = 1; }
+  : rep (new_rep)
+{
+  rep->count = 1;
+}
 
 octave_value::~octave_value (void)
 {
 #if defined (MDEBUG)
   cerr << "~octave_value: rep: " << rep
        << " rep->count: " << rep->count << "\n";
 #endif
 
@@ -756,16 +789,18 @@ void
 install_types (void)
 {
   octave_base_value::register_type ();
   octave_scalar::register_type ();
   octave_complex::register_type ();
   octave_matrix::register_type ();
   octave_complex_matrix::register_type ();
   octave_range::register_type ();
+  octave_bool::register_type ();
+  octave_bool_matrix::register_type ();
   octave_char_matrix::register_type ();
   octave_char_matrix_str::register_type ();
   octave_struct::register_type ();
   octave_all_va_args::register_type ();
   octave_magic_colon::register_type ();
 }
 
 static int
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -113,16 +113,18 @@ public:
   octave_value (const DiagMatrix& d);
   octave_value (const RowVector& v, int pcv = -1);
   octave_value (const ColumnVector& v, int pcv = -1);
   octave_value (const Complex& C);
   octave_value (const ComplexMatrix& m);
   octave_value (const ComplexDiagMatrix& d);
   octave_value (const ComplexRowVector& v, int pcv = -1);
   octave_value (const ComplexColumnVector& v, int pcv = -1);
+  octave_value (bool b);
+  octave_value (const boolMatrix& bm);
   octave_value (const char *s);
   octave_value (const string& s);
   octave_value (const string_vector& s);
   octave_value (const charMatrix& chm, bool is_string = false);
   octave_value (double base, double limit, double inc);
   octave_value (const Range& r);
   octave_value (const Octave_map& m);
   octave_value (octave_value::magic_colon);
@@ -319,16 +321,22 @@ public:
   virtual string string_value (void) const
     { return rep->string_value (); }
 
   virtual Range range_value (void) const
     { return rep->range_value (); }
 
   virtual Octave_map map_value (void) const;
 
+  virtual bool bool_value (void) const
+    { return rep->bool_value (); }
+
+  virtual boolMatrix bool_matrix_value (void) const
+    { return rep->bool_matrix_value (); }
+
   // Unary ops.
 
   virtual octave_value not (void) const { return rep->not (); }
 
   virtual octave_value uminus (void) const { return rep->uminus (); }
 
   virtual octave_value transpose (void) const { return rep->transpose (); }
 
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -1048,17 +1048,17 @@ variable	: indirect_ref
 		  }
 		;
 
 param_list_beg	: '('
 		  { lexer_flags.looking_at_parameter_list = 1; }
 		;
 
 param_list_end	: ')'
-		  { lexer_flags.looking_at_parameter_list = 1; }
+		  { lexer_flags.looking_at_parameter_list = 0; }
 		;
 
 param_list	: param_list_beg param_list_end
 		  {
 		    lexer_flags.quote_is_transpose = 0;
 		    $$ = 0;
 		  }
 		| param_list_beg ELLIPSIS param_list_end
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -20,16 +20,17 @@ Software Foundation, 59 Temple Place - S
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cfloat>
+#include <cstdio>
 #include <cstring>
 
 #include <string>
 
 #include <iostream.h>
 #include <strstream.h>
 
 #include "CMatrix.h"
diff --git a/src/qpsol.cc b/src/qpsol.cc
--- a/src/qpsol.cc
+++ b/src/qpsol.cc
@@ -404,17 +404,17 @@ show_qpsol_option (const string& keyword
 		retval = val;
 	    }
 	  else
 	    {
 	      int val = (qpsol_opts.*list->i_get_fcn) ();
 	      if (val < 0)
 		retval = "depends on problem size";
 	      else
-		retval = val;
+		retval = static_cast<double> (val);
 	    }
 
 	  return retval;
 	}
       list++;
     }
 
   warning ("qpsol_options: no match for `%s'", keyword.c_str ());
diff --git a/src/quad.cc b/src/quad.cc
--- a/src/quad.cc
+++ b/src/quad.cc
@@ -239,18 +239,18 @@ integrand is singular.")
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
   retval(3) = abserr;
-  retval(2) = nfun;
-  retval(1) = ier;
+  retval(2) = static_cast<double> (nfun);
+  retval(1) = static_cast<double> (ier);
   retval(0) = val;
 
   return retval;
 }
 
 typedef void (Quad_options::*d_set_opt_mf) (double);
 typedef double (Quad_options::*d_get_opt_mf) (void);
 
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -1625,17 +1625,19 @@ symbols_of_variables (void)
 body of the most recent unwind_protect statement or the TRY part of\n\
 the most recent eval() command.  Outside of unwind_protect and\n\
 eval(), or if no error has ocurred within them, the value of\n\
 __error_text__ is guaranteed to be the empty string.");
 
   DEFVAR (history_file, default_history_file (), 0, history_file,
     "name of command history file");
 
-  DEFVAR (history_size, default_history_size (), 0, history_size,
+  double tmp_hist_size = default_history_size ();
+
+  DEFVAR (history_size, tmp_hist_size, 0, history_size,
     "number of commands to save in the history list");
 
   DEFVAR (ignore_function_time_stamp, "system", 0, ignore_function_time_stamp,
     "don't check to see if function files have changed since they were\n\
   last compiled.  Possible values are \"system\" and \"all\"");
 
   DEFCONST (program_invocation_name, Vprogram_invocation_name, 0, 0,
     "the full name of the current program or script, including the\n\
