# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1498478765 14400
#      Mon Jun 26 08:06:05 2017 -0400
# Node ID 4a62da62af0946f50650459bb97b9c42a158e806
# Parent  b9378eff6d13d1e194d8c427e6bef2b45198d834
use m_ prefix for member variables in parser

* parse.h, oct-parse.in.yy (class octave_base_parser): Rename all
  member variables with "m_" prefix.  Change all uses.

diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -709,19 +709,19 @@ get_debug_input (const std::string& prom
           curr_parser.reset ();
 
           int retval = curr_parser.run ();
 
           if (octave::command_editor::interrupt (false))
             break;
           else
             {
-              if (retval == 0 && curr_parser.stmt_list)
+              if (retval == 0 && curr_parser.m_stmt_list)
                 {
-                  curr_parser.stmt_list->accept (tw);
+                  curr_parser.m_stmt_list->accept (tw);
 
                   if (octave_completion_matches_called)
                     octave_completion_matches_called = false;
                 }
 
               octave_quit ();
             }
         }
diff --git a/libinterp/corefcn/interpreter.cc b/libinterp/corefcn/interpreter.cc
--- a/libinterp/corefcn/interpreter.cc
+++ b/libinterp/corefcn/interpreter.cc
@@ -960,19 +960,19 @@ namespace octave
 
             if (m_symbol_table.at_top_level ())
               octave::tree_evaluator::reset_debug_state ();
 
             retval = parser.run ();
 
             if (retval == 0)
               {
-                if (parser.stmt_list)
+                if (parser.m_stmt_list)
                   {
-                    parser.stmt_list->accept (m_evaluator);
+                    parser.m_stmt_list->accept (m_evaluator);
 
                     octave_quit ();
 
                     if (! octave::application::interactive ())
                       {
                         bool quit = (tree_return_command::returning
                                      || tree_break_command::breaking);
 
@@ -986,17 +986,17 @@ namespace octave
                           break;
                       }
 
                     if (octave_completion_matches_called)
                       octave_completion_matches_called = false;
                     else
                       octave::command_editor::increment_current_command_number ();
                   }
-                else if (parser.lexer.end_of_input)
+                else if (parser.m_lexer.end_of_input)
                   {
                     retval = EOF;
                     break;
                   }
               }
           }
         catch (const octave::interrupt_exception&)
           {
diff --git a/libinterp/parse-tree/bp-table.cc b/libinterp/parse-tree/bp-table.cc
--- a/libinterp/parse-tree/bp-table.cc
+++ b/libinterp/parse-tree/bp-table.cc
@@ -382,23 +382,23 @@ bp_table::condition_valid (const std::st
       octave::parser parser (cond + " ;"); // ; to reject partial expr like "y=="
       parser.reset ();
       int parse_status = parser.run ();
       if (parse_status)
         error ("dbstop: Cannot parse condition '%s'", cond.c_str ());
       else
         {
           octave::tree_statement *stmt = nullptr;
-          if (! parser.stmt_list)
+          if (! parser.m_stmt_list)
             error ("dbstop: "
                    "condition is not empty, but has nothing to evaluate");
           else
             {
-              if (parser.stmt_list->length () == 1
-                  && (stmt = parser.stmt_list->front ())
+              if (parser.m_stmt_list->length () == 1
+                  && (stmt = parser.m_stmt_list->front ())
                   && stmt->is_expression ())
                 {
                   octave::tree_expression *expr = stmt->expression ();
                   if (expr->is_assignment_expression ())
                     error ("dbstop: condition cannot be an assignment.  "
                            "Did you mean '=='?");
                 }
               else
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -91,17 +91,17 @@ extern int octave_lex (YYSTYPE *, void *
 // List of autoloads (function -> file mapping).
 static std::map<std::string, std::string> autoload_map;
 
 // Forward declarations for some functions defined at the bottom of
 // the file.
 
 static void yyerror (octave::base_parser& parser, const char *s);
 
-#define lexer parser.lexer
+#define lexer parser.m_lexer
 #define scanner lexer.scanner
 
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 // Disable this warning for code that is generated by Bison, including
 // grammar rules.  Push the current state so we can restore the warning
 // state prior to functions we define at the bottom of the file.
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wold-style-cast"
@@ -116,26 +116,26 @@ static void yyerror (octave::base_parser
 
 %expect 9
 
 %API_PREFIX_DECL%
 
 // We are using the pure parser interface and the reentrant lexer
 // interface but the Octave parser and lexer are NOT properly
 // reentrant because both still use many global variables.  It should be
-// safe to create a parser object and call it while anotehr parser
+// safe to create a parser object and call it while another parser
 // object is active (to parse a callback function while the main
 // interactive parser is waiting for input, for example) if you take
 // care to properly save and restore (typically with an unwind_protect
 // object) relevant global values before and after the nested call.
 
 %define api.pure
 %PUSH_PULL_DECL%
 %parse-param { octave::base_parser& parser }
-%lex-param { void *scanner }
+%lex-param { void *lexer.scanner }
 
 %union
 {
   int dummy_type;
 
   // The type of the basic tokens returned by the lexer.
   octave::token *tok_val;
 
@@ -379,24 +379,24 @@ static void yyerror (octave::base_parser
 
 // ==============================
 // Statements and statement lists
 // ==============================
 
 input           : simple_list '\n'
                   {
                     $$ = 0;
-                    parser.stmt_list = $1;
+                    parser.m_stmt_list = $1;
                     YYACCEPT;
                   }
                 | simple_list END_OF_INPUT
                   {
                     $$ = 0;
                     lexer.end_of_input = true;
-                    parser.stmt_list = $1;
+                    parser.m_stmt_list = $1;
                     YYACCEPT;
                   }
                 | parse_error
                   {
                     $$ = 0;
                     YYABORT;
                   }
                 ;
@@ -1265,33 +1265,33 @@ except_command  : UNWIND stash_comment o
 // ===========================================
 // Some 'subroutines' for function definitions
 // ===========================================
 
 push_fcn_symtab : // empty
                   {
                     $$ = 0;
 
-                    parser.curr_fcn_depth++;
-
-                    if (parser.max_fcn_depth < parser.curr_fcn_depth)
-                      parser.max_fcn_depth = parser.curr_fcn_depth;
+                    parser.m_curr_fcn_depth++;
+
+                    if (parser.m_max_fcn_depth < parser.m_curr_fcn_depth)
+                      parser.m_max_fcn_depth = parser.m_curr_fcn_depth;
 
                     lexer.symtab_context.push (new octave::symbol_table::scope ());
 
-                    parser.function_scopes.push (lexer.symtab_context.curr_scope ());
+                    parser.m_function_scopes.push (lexer.symtab_context.curr_scope ());
 
                     if (! lexer.reading_script_file
-                        && parser.curr_fcn_depth == 1
-                        && ! parser.parsing_subfunctions)
-                      parser.primary_fcn_scope
+                        && parser.m_curr_fcn_depth == 1
+                        && ! parser.m_parsing_subfunctions)
+                      parser.m_primary_fcn_scope
                         = lexer.symtab_context.curr_scope ();
 
                     if (lexer.reading_script_file
-                        && parser.curr_fcn_depth > 1)
+                        && parser.m_curr_fcn_depth > 1)
                       {
                         parser.bison_error ("nested functions not implemented in this context");
                         YYABORT;
                       }
                   }
                 ;
 
 // ===========================
@@ -1430,30 +1430,30 @@ return_list1    : identifier
                 ;
 
 // =======================
 // Script or function file
 // =======================
 
 parsing_local_fcns
                 : // empty
-                  { parser.parsing_local_functions = true; }
+                  { parser.m_parsing_local_functions = true; }
                 ;
 
 file            : INPUT_FILE opt_nl opt_list END_OF_INPUT
                   {
                     YYUSE ($2);
 
                     if (lexer.reading_fcn_file)
                       {
                         // Delete the dummy statement_list we created
                         // after parsing the function.  Any function
                         // definitions found in the file have already
                         // been stored in the symbol table or in
-                        // base_parser::primary_fcn_ptr.
+                        // base_parser::m_primary_fcn_ptr.
 
                         delete $3;
                       }
                     else
                       {
                         octave::tree_statement *end_of_script
                           = parser.make_end ("endscript", true,
                                              lexer.input_line_number,
@@ -1466,17 +1466,17 @@ file            : INPUT_FILE opt_nl opt_
                   }
                 | INPUT_FILE opt_nl classdef parsing_local_fcns opt_sep opt_fcn_list END_OF_INPUT
                   {
                     YYUSE ($2);
                     YYUSE ($5);
                     YYUSE ($6);
 
                     if (lexer.reading_classdef_file)
-                      parser.classdef_object = $3;
+                      parser.m_classdef_object = $3;
 
                     $$ = 0;
                   }
                 ;
 
 // ===================
 // Function definition
 // ===================
@@ -1489,17 +1489,17 @@ function_beg    : push_fcn_symtab FCN
                       lexer.maybe_classdef_get_set_method = true;
                   }
                 ;
 
 fcn_name        : identifier
                   {
                     std::string id = $1->name ();
 
-                    if (! parser.function_scopes.name_current_scope (id))
+                    if (! parser.m_function_scopes.name_current_scope (id))
                       {
                         parser.bison_error ("duplicate subfunction or nested function name",
                                             $1->line (), $1->column ());
 
                         delete $1;
 
                         YYABORT;
                       }
@@ -1530,17 +1530,17 @@ fcn_name        : identifier
                     lexer.maybe_classdef_get_set_method = false;
                     lexer.parsing_classdef_set_method = true;
                     $$ = $3;
                   }
                 ;
 
 function_end    : END
                   {
-                    parser.endfunction_found = true;
+                    parser.m_endfunction_found = true;
 
                     if (parser.end_token_ok ($1, octave::token::function_end))
                       $$ = parser.make_end ("endfunction", false,
                                             $1->line (), $1->column ());
                     else
                       {
                         parser.end_token_error ($1, octave::token::function_end);
                         YYABORT;
@@ -1550,17 +1550,17 @@ function_end    : END
                   {
 // A lot of tests are based on the assumption that this is OK
 //                  if (lexer.reading_script_file)
 //                    {
 //                      parser.bison_error ("function body open at end of script");
 //                      YYABORT;
 //                    }
 
-                    if (parser.endfunction_found)
+                    if (parser.m_endfunction_found)
                       {
                         parser.bison_error ("inconsistent function endings -- "
                                  "if one function is explicitly ended, "
                                  "so must all the others");
                         YYABORT;
                       }
 
                     if (! (lexer.reading_fcn_file || lexer.reading_script_file
@@ -2037,160 +2037,161 @@ opt_sep         : // empty
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 // Restore prevailing warning state for remainder of the file.
 #pragma GCC diagnostic pop
 #endif
 
 // Generic error messages.
 
 #undef lexer
+#undef scanner
 
 static void
 yyerror (octave::base_parser& parser, const char *s)
 {
   parser.bison_error (s);
 }
 
 namespace octave
 {
   size_t
   base_parser::parent_scope_info::size (void) const
   {
-    return info.size ();
+    return m_info.size ();
   }
 
   void
   base_parser::parent_scope_info::push (const value_type& elt)
   {
-    info.push_back (elt);
+    m_info.push_back (elt);
   }
 
   void
   base_parser::parent_scope_info::push (symbol_table::scope *scope)
   {
     push (value_type (scope, ""));
   }
 
   void
   base_parser::parent_scope_info::pop (void)
   {
-    info.pop_back ();
+    m_info.pop_back ();
   }
 
   bool
   base_parser::parent_scope_info::name_ok (const std::string& name)
   {
     // Name can't be the same as any parent function or any other
     // function we've already seen.  We could maintain a complex
     // tree structure of names, or we can just store the set of
     // full names of all the functions, which must be unique.
 
     std::string full_name;
 
     for (size_t i = 0; i < size()-1; i++)
       {
-        const value_type& elt = info[i];
+        const value_type& elt = m_info[i];
 
         if (name == elt.second)
           return false;
 
         full_name += elt.second + ">";
       }
 
     full_name += name;
 
-    if (all_names.find (full_name) != all_names.end ())
+    if (m_all_names.find (full_name) != m_all_names.end ())
       return false;
 
-    all_names.insert (full_name);
+    m_all_names.insert (full_name);
 
     return true;
   }
 
   bool
   base_parser::parent_scope_info::name_current_scope (const std::string& name)
   {
     if (! name_ok (name))
       return false;
 
     if (size () > 0)
-      info.back().second = name;
+      m_info.back().second = name;
 
     return true;
   }
 
   symbol_table::scope *
   base_parser::parent_scope_info::parent_scope (void) const
   {
-    return size () > 1 ? info[size()-2].first : 0;
+    return size () > 1 ? m_info[size()-2].first : 0;
   }
 
   std::string
   base_parser::parent_scope_info::parent_name (void) const
   {
-    return info[size()-2].second;
+    return m_info[size()-2].second;
   }
 
   void base_parser::parent_scope_info::clear (void)
   {
-    info.clear ();
-    all_names.clear ();
+    m_info.clear ();
+    m_all_names.clear ();
   }
 
   base_parser::base_parser (base_lexer& lxr)
-    : endfunction_found (false), autoloading (false),
-      fcn_file_from_relative_lookup (false),
-      parsing_subfunctions (false), parsing_local_functions (false),
-      max_fcn_depth (0), curr_fcn_depth (0), primary_fcn_scope (0),
-      curr_class_name (), curr_package_name (), function_scopes (),
-      primary_fcn_ptr (0), subfunction_names (), classdef_object (0),
-      stmt_list (0), lexer (lxr), parser_state (yypstate_new ())
+    : m_endfunction_found (false), m_autoloading (false),
+      m_fcn_file_from_relative_lookup (false),
+      m_parsing_subfunctions (false), m_parsing_local_functions (false),
+      m_max_fcn_depth (0), m_curr_fcn_depth (0), m_primary_fcn_scope (0),
+      m_curr_class_name (), m_curr_package_name (), m_function_scopes (),
+      m_primary_fcn_ptr (0), m_subfunction_names (), m_classdef_object (0),
+      m_stmt_list (0), m_lexer (lxr), m_parser_state (yypstate_new ())
   { }
 
   base_parser::~base_parser (void)
   {
-    delete stmt_list;
-
-    delete &lexer;
+    delete m_stmt_list;
+
+    delete &m_lexer;
 
     // FIXME: Deleting the internal Bison parser state structure does
     // not clean up any partial parse trees in the event of an interrupt or
     // error.  It's not clear how to safely do that with the C language
     // parser that Bison generates.  The C++ language parser that Bison
     // generates would do it for us automatically whenever an exception
     // is thrown while parsing input, but there is currently no C++
     // interface for a push parser.
 
-    yypstate_delete (static_cast<yypstate *> (parser_state));
+    yypstate_delete (static_cast<yypstate *> (m_parser_state));
   }
 
   void
   base_parser::reset (void)
   {
-    endfunction_found = false;
-    autoloading = false;
-    fcn_file_from_relative_lookup = false;
-    parsing_subfunctions = false;
-    parsing_local_functions = false;
-    max_fcn_depth = 0;
-    curr_fcn_depth = 0;
-    primary_fcn_scope = 0;
-    curr_class_name = "";
-    curr_package_name = "";
-    function_scopes.clear ();
-    primary_fcn_ptr  = 0;
-    subfunction_names.clear ();
-
-    delete stmt_list;
-    stmt_list = 0;
-
-    lexer.reset ();
-
-    yypstate_delete (static_cast<yypstate *> (parser_state));
-    parser_state = yypstate_new ();
+    m_endfunction_found = false;
+    m_autoloading = false;
+    m_fcn_file_from_relative_lookup = false;
+    m_parsing_subfunctions = false;
+    m_parsing_local_functions = false;
+    m_max_fcn_depth = 0;
+    m_curr_fcn_depth = 0;
+    m_primary_fcn_scope = 0;
+    m_curr_class_name = "";
+    m_curr_package_name = "";
+    m_function_scopes.clear ();
+    m_primary_fcn_ptr  = 0;
+    m_subfunction_names.clear ();
+
+    delete m_stmt_list;
+    m_stmt_list = 0;
+
+    m_lexer.reset ();
+
+    yypstate_delete (static_cast<yypstate *> (m_parser_state));
+    m_parser_state = yypstate_new ();
   }
 }
 
 // Error mesages for mismatched end tokens.
 
 static std::string
 end_token_as_string (octave::token::end_tok_type ettype)
 {
@@ -2288,43 +2289,43 @@ namespace octave
   // test in a logical expression.
 
   void
   base_parser::maybe_warn_assign_as_truth_value (tree_expression *expr)
   {
     if (expr->is_assignment_expression ()
         && expr->paren_count () < 2)
       {
-        if (lexer.fcn_file_full_name.empty ())
+        if (m_lexer.fcn_file_full_name.empty ())
           warning_with_id
             ("Octave:assign-as-truth-value",
              "suggest parenthesis around assignment used as truth value");
         else
           warning_with_id
             ("Octave:assign-as-truth-value",
              "suggest parenthesis around assignment used as truth value near line %d, column %d in file '%s'",
-             expr->line (), expr->column (), lexer.fcn_file_full_name.c_str ());
+             expr->line (), expr->column (), m_lexer.fcn_file_full_name.c_str ());
       }
   }
 
   // Maybe print a warning about switch labels that aren't constants.
 
   void
   base_parser::maybe_warn_variable_switch_label (tree_expression *expr)
   {
     if (! expr->is_constant ())
       {
-        if (lexer.fcn_file_full_name.empty ())
+        if (m_lexer.fcn_file_full_name.empty ())
           warning_with_id ("Octave:variable-switch-label",
                            "variable switch label");
         else
           warning_with_id
             ("Octave:variable-switch-label",
              "variable switch label near line %d, column %d in file '%s'",
-             expr->line (), expr->column (), lexer.fcn_file_full_name.c_str ());
+             expr->line (), expr->column (), m_lexer.fcn_file_full_name.c_str ());
       }
   }
 
   // Make a constant.
 
   tree_constant *
   base_parser::make_constant (int op, token *tok_val)
   {
@@ -2401,33 +2402,33 @@ namespace octave
 
   // Make an anonymous function handle.
 
   tree_anon_fcn_handle *
   base_parser::make_anon_fcn_handle (tree_parameter_list *param_list,
                                      tree_expression *expr)
   {
     // FIXME: need to get these from the location of the @ symbol.
-    int l = lexer.input_line_number;
-    int c = lexer.current_input_column;
-
-    symbol_table::scope *fcn_scope = lexer.symtab_context.curr_scope ();
-    symbol_table::scope *parent_scope = lexer.symtab_context.parent_scope ();
-
-    lexer.symtab_context.pop ();
+    int l = m_lexer.input_line_number;
+    int c = m_lexer.current_input_column;
+
+    symbol_table::scope *fcn_scope = m_lexer.symtab_context.curr_scope ();
+    symbol_table::scope *parent_scope = m_lexer.symtab_context.parent_scope ();
+
+    m_lexer.symtab_context.pop ();
 
     expr->set_print_flag (false);
 
     tree_anon_fcn_handle *retval
       = new tree_anon_fcn_handle (param_list, expr, fcn_scope,
                                   parent_scope, l, c);
 
 // FIXME: Stash the filename.  This does not work and produces
     // errors when executed.
-    //retval->stash_file_name (lexer.fcn_file_name);
+    //retval->stash_file_name (m_lexer.fcn_file_name);
 
     return retval;
   }
 
   // Build a colon expression.
 
   tree_expression *
   base_parser::make_colon_expression (tree_expression *base,
@@ -2702,17 +2703,17 @@ namespace octave
                                     token *end_tok,
                                     octave_comment_list *lc,
                                     octave_comment_list *mc)
   {
     tree_command *retval = 0;
 
     if (end_token_ok (end_tok, token::unwind_protect_end))
       {
-        octave_comment_list *tc = lexer.comment_buf.get_comment ();
+        octave_comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         int l = unwind_tok->line ();
         int c = unwind_tok->column ();
 
         retval = new tree_unwind_protect_command (body, cleanup_stmts,
                                                   lc, mc, tc, l, c);
       }
     else
@@ -2736,17 +2737,17 @@ namespace octave
                                  token *end_tok,
                                  octave_comment_list *lc,
                                  octave_comment_list *mc)
   {
     tree_command *retval = 0;
 
     if (end_token_ok (end_tok, token::try_catch_end))
       {
-        octave_comment_list *tc = lexer.comment_buf.get_comment ();
+        octave_comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         int l = try_tok->line ();
         int c = try_tok->column ();
 
         tree_identifier *id = 0;
 
         if (! catch_sep && cleanup_stmts && ! cleanup_stmts->empty ())
           {
@@ -2792,19 +2793,19 @@ namespace octave
                                    octave_comment_list *lc)
   {
     tree_command *retval = 0;
 
     maybe_warn_assign_as_truth_value (expr);
 
     if (end_token_ok (end_tok, token::while_end))
       {
-        octave_comment_list *tc = lexer.comment_buf.get_comment ();
-
-        lexer.looping--;
+        octave_comment_list *tc = m_lexer.comment_buf.get_comment ();
+
+        m_lexer.looping--;
 
         int l = while_tok->line ();
         int c = while_tok->column ();
 
         retval = new tree_while_command (expr, body, lc, tc, l, c);
       }
     else
       {
@@ -2822,19 +2823,19 @@ namespace octave
   tree_command *
   base_parser::make_do_until_command (token *until_tok,
                                       tree_statement_list *body,
                                       tree_expression *expr,
                                       octave_comment_list *lc)
   {
     maybe_warn_assign_as_truth_value (expr);
 
-    octave_comment_list *tc = lexer.comment_buf.get_comment ();
-
-    lexer.looping--;
+    octave_comment_list *tc = m_lexer.comment_buf.get_comment ();
+
+    m_lexer.looping--;
 
     int l = until_tok->line ();
     int c = until_tok->column ();
 
     return new tree_do_until_command (expr, body, lc, tc, l, c);
   }
 
   // Build a for command.
@@ -2851,19 +2852,19 @@ namespace octave
     tree_command *retval = 0;
 
     bool parfor = tok_id == PARFOR;
 
     if (end_token_ok (end_tok, parfor ? token::parfor_end : token::for_end))
       {
         expr->mark_as_for_cmd_expr ();
 
-        octave_comment_list *tc = lexer.comment_buf.get_comment ();
-
-        lexer.looping--;
+        octave_comment_list *tc = m_lexer.comment_buf.get_comment ();
+
+        m_lexer.looping--;
 
         int l = for_tok->line ();
         int c = for_tok->column ();
 
         if (lhs->length () == 1)
           {
             tree_expression *tmp = lhs->remove_front ();
 
@@ -2904,17 +2905,17 @@ namespace octave
   // Build a break command.
 
   tree_command *
   base_parser::make_break_command (token *break_tok)
   {
     int l = break_tok->line ();
     int c = break_tok->column ();
 
-    if (! lexer.looping)
+    if (! m_lexer.looping)
       {
         bison_error ("break must appear in a loop in the same file as loop command");
         return 0;
       }
     else
       return new tree_break_command (l, c);
   }
 
@@ -2960,17 +2961,17 @@ namespace octave
                                   tree_if_command_list *list,
                                   token *end_tok,
                                   octave_comment_list *lc)
   {
     tree_if_command *retval = 0;
 
     if (end_token_ok (end_tok, token::if_end))
       {
-        octave_comment_list *tc = lexer.comment_buf.get_comment ();
+        octave_comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         int l = if_tok->line ();
         int c = if_tok->column ();
 
         if (list && ! list->empty ())
           {
             tree_if_clause *elt = list->front ();
 
@@ -3017,17 +3018,17 @@ namespace octave
                                       tree_switch_case_list *list,
                                       token *end_tok,
                                       octave_comment_list *lc)
   {
     tree_switch_command *retval = 0;
 
     if (end_token_ok (end_tok, token::switch_end))
       {
-        octave_comment_list *tc = lexer.comment_buf.get_comment ();
+        octave_comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         int l = switch_tok->line ();
         int c = switch_tok->column ();
 
         if (list && ! list->empty ())
           {
             tree_switch_case *elt = list->front ();
 
@@ -3203,27 +3204,27 @@ namespace octave
                             tree_statement *end_script)
   {
     if (! cmds)
       cmds = new tree_statement_list ();
 
     cmds->append (end_script);
 
     octave_user_script *script
-      = new octave_user_script (lexer.fcn_file_full_name,
-                                lexer.fcn_file_name,
-                                cmds, lexer.help_text);
-
-    lexer.help_text = "";
+      = new octave_user_script (m_lexer.fcn_file_full_name,
+                                m_lexer.fcn_file_name,
+                                cmds, m_lexer.help_text);
+
+    m_lexer.help_text = "";
 
     octave::sys::time now;
 
     script->stash_fcn_file_time (now);
 
-    primary_fcn_ptr = script;
+    m_primary_fcn_ptr = script;
   }
 
   // Define a function.
 
   // FIXME: combining start_function, finish_function, and
   // recover_from_parsing_function should be possible, but it makes
   // for a large mess.  Maybe this could be a bit better organized?
 
@@ -3260,134 +3261,134 @@ namespace octave
                                tree_statement *end_fcn_stmt)
   {
     // We'll fill in the return list later.
 
     std::string id_name = id->name ();
 
     delete id;
 
-    if (lexer.parsing_classdef_get_method)
+    if (m_lexer.parsing_classdef_get_method)
       id_name.insert (0, "get.");
-    else if (lexer.parsing_classdef_set_method)
+    else if (m_lexer.parsing_classdef_set_method)
       id_name.insert (0, "set.");
 
-    lexer.parsing_classdef_get_method = false;
-    lexer.parsing_classdef_set_method = false;
+    m_lexer.parsing_classdef_get_method = false;
+    m_lexer.parsing_classdef_set_method = false;
 
     if (! body)
       body = new tree_statement_list ();
 
     body->append (end_fcn_stmt);
 
     octave_user_function *fcn
-      = new octave_user_function (lexer.symtab_context.curr_scope (),
+      = new octave_user_function (m_lexer.symtab_context.curr_scope (),
                                   param_list, 0, body);
 
     if (fcn)
       {
-        octave_comment_list *tc = lexer.comment_buf.get_comment ();
+        octave_comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         fcn->stash_trailing_comment (tc);
         fcn->stash_fcn_end_location (end_fcn_stmt->line (),
                                      end_fcn_stmt->column ());
       }
 
     // If input is coming from a file, issue a warning if the name of
     // the file does not match the name of the function stated in the
     // file.  Matlab doesn't provide a diagnostic (it ignores the stated
     // name).
-    if (! autoloading && lexer.reading_fcn_file
-        && curr_fcn_depth == 1 && ! parsing_subfunctions)
+    if (! m_autoloading && m_lexer.reading_fcn_file
+        && m_curr_fcn_depth == 1 && ! m_parsing_subfunctions)
       {
-        // FIXME: should lexer.fcn_file_name already be
+        // FIXME: should m_lexer.fcn_file_name already be
         // preprocessed when we get here?  It seems to only be a
         // problem with relative filenames.
 
-        std::string nm = lexer.fcn_file_name;
+        std::string nm = m_lexer.fcn_file_name;
 
         size_t pos = nm.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
         if (pos != std::string::npos)
-          nm = lexer.fcn_file_name.substr (pos+1);
+          nm = m_lexer.fcn_file_name.substr (pos+1);
 
         if (nm != id_name)
           {
             warning_with_id
               ("Octave:function-name-clash",
                "function name '%s' does not agree with function filename '%s'",
-               id_name.c_str (), lexer.fcn_file_full_name.c_str ());
+               id_name.c_str (), m_lexer.fcn_file_full_name.c_str ());
 
             id_name = nm;
           }
       }
 
-    if (lexer.reading_fcn_file || lexer.reading_classdef_file || autoloading)
+    if (m_lexer.reading_fcn_file || m_lexer.reading_classdef_file || m_autoloading)
       {
         octave::sys::time now;
 
-        fcn->stash_fcn_file_name (lexer.fcn_file_full_name);
+        fcn->stash_fcn_file_name (m_lexer.fcn_file_full_name);
         fcn->stash_fcn_file_time (now);
-        fcn->stash_dir_name (lexer.dir_name);
-        fcn->stash_package_name (lexer.package_name);
+        fcn->stash_dir_name (m_lexer.dir_name);
+        fcn->stash_package_name (m_lexer.package_name);
         fcn->mark_as_system_fcn_file ();
 
-        if (fcn_file_from_relative_lookup)
+        if (m_fcn_file_from_relative_lookup)
           fcn->mark_relative ();
 
-        if (curr_fcn_depth > 1 || parsing_subfunctions)
+        if (m_curr_fcn_depth > 1 || m_parsing_subfunctions)
           {
-            fcn->stash_parent_fcn_name (lexer.fcn_file_name);
-
-            if (curr_fcn_depth > 1)
-              fcn->stash_parent_fcn_scope (function_scopes.parent_scope ());
+            fcn->stash_parent_fcn_name (m_lexer.fcn_file_name);
+
+            if (m_curr_fcn_depth > 1)
+              fcn->stash_parent_fcn_scope (m_function_scopes.parent_scope ());
             else
-              fcn->stash_parent_fcn_scope (primary_fcn_scope);
+              fcn->stash_parent_fcn_scope (m_primary_fcn_scope);
           }
 
-        if (lexer.parsing_class_method)
+        if (m_lexer.parsing_class_method)
           {
-            if (curr_class_name == id_name)
+            if (m_curr_class_name == id_name)
               fcn->mark_as_class_constructor ();
             else
               fcn->mark_as_class_method ();
 
-            fcn->stash_dispatch_class (curr_class_name);
+            fcn->stash_dispatch_class (m_curr_class_name);
           }
 
         std::string nm = fcn->fcn_file_name ();
 
         octave::sys::file_stat fs (nm);
 
         if (fs && fs.is_newer (now))
           warning_with_id ("Octave:future-time-stamp",
                            "time stamp for '%s' is in the future", nm.c_str ());
       }
     else if (! input_from_tmp_history_file
-             && ! lexer.force_script
-             && lexer.reading_script_file
-             && lexer.fcn_file_name == id_name)
+             && ! m_lexer.force_script
+             && m_lexer.reading_script_file
+             && m_lexer.fcn_file_name == id_name)
       {
         warning ("function '%s' defined within script file '%s'",
-                 id_name.c_str (), lexer.fcn_file_full_name.c_str ());
+                 id_name.c_str (), m_lexer.fcn_file_full_name.c_str ());
       }
 
     fcn->stash_function_name (id_name);
 
-    if (! lexer.help_text.empty () && curr_fcn_depth == 1
-        && ! parsing_subfunctions)
+    if (! m_lexer.help_text.empty () && m_curr_fcn_depth == 1
+        && ! m_parsing_subfunctions)
       {
-        fcn->document (lexer.help_text);
-
-        lexer.help_text = "";
+        fcn->document (m_lexer.help_text);
+
+        m_lexer.help_text = "";
       }
 
-    if (lexer.reading_fcn_file && curr_fcn_depth == 1
-        && ! parsing_subfunctions)
-      primary_fcn_ptr = fcn;
+    if (m_lexer.reading_fcn_file && m_curr_fcn_depth == 1
+        && ! m_parsing_subfunctions)
+      m_primary_fcn_ptr = fcn;
 
     return fcn;
   }
 
   tree_statement *
   base_parser::make_end (const std::string& type, bool eof, int l, int c)
   {
     return make_statement (new tree_no_op_command (type, eof, l, c));
@@ -3420,77 +3421,77 @@ namespace octave
         symbol_table::scope *fcn_scope = fcn->scope ();
         fcn_scope->cache_name (tmp);
 
         if (lc)
           fcn->stash_leading_comment (lc);
 
         fcn->define_ret_list (ret_list);
 
-        if (curr_fcn_depth > 1 || parsing_subfunctions)
+        if (m_curr_fcn_depth > 1 || m_parsing_subfunctions)
           {
             fcn->stash_fcn_location (l, c);
 
             octave_value ov_fcn (fcn);
 
-            if (endfunction_found && function_scopes.size () > 1)
+            if (m_endfunction_found && m_function_scopes.size () > 1)
               {
-                symbol_table::scope *pscope = function_scopes.parent_scope ();
+                symbol_table::scope *pscope = m_function_scopes.parent_scope ();
 
                 pscope->install_nestfunction (nm, ov_fcn);
               }
             else
               {
                 fcn->mark_as_subfunction ();
-                subfunction_names.push_back (nm);
-
-                primary_fcn_scope->install_subfunction (nm, ov_fcn);
+                m_subfunction_names.push_back (nm);
+
+                m_primary_fcn_scope->install_subfunction (nm, ov_fcn);
                }
           }
 
-        if (parsing_local_functions )
+        if (m_parsing_local_functions )
           symtab.install_local_function (nm, octave_value (fcn), file);
-        else if (curr_fcn_depth == 1)
+        else if (m_curr_fcn_depth == 1)
           fcn_scope->update_nest ();
 
-        if (! lexer.reading_fcn_file && curr_fcn_depth == 1)
+        if (! m_lexer.reading_fcn_file && m_curr_fcn_depth == 1)
           {
             // We are either reading a script file or defining a function
             // at the command line, so this definition creates a
             // tree_function object that is placed in the parse tree.
             // Otherwise, it is just inserted in the symbol table,
             // either as a subfunction or nested function (see above),
             // or as the primary function for the file, via
-            // primary_fcn_ptr (see also load_fcn_from_file,,
+            // m_primary_fcn_ptr (see also load_fcn_from_file,,
             // parse_fcn_file, and
             // symbol_table::fcn_info::fcn_info_rep::find_user_function).
 
             retval = new tree_function_def (fcn);
           }
       }
 
     return retval;
   }
 
   void
   base_parser::recover_from_parsing_function (void)
   {
-    lexer.symtab_context.pop ();
-
-    if (lexer.reading_fcn_file && curr_fcn_depth == 1
-        && ! parsing_subfunctions)
-      parsing_subfunctions = true;
-
-    curr_fcn_depth--;
-    function_scopes.pop ();
-
-    lexer.defining_func--;
-    lexer.parsed_function_name.pop ();
-    lexer.looking_at_return_list = false;
-    lexer.looking_at_parameter_list = false;
+    m_lexer.symtab_context.pop ();
+
+    if (m_lexer.reading_fcn_file && m_curr_fcn_depth == 1
+        && ! m_parsing_subfunctions)
+      m_parsing_subfunctions = true;
+
+    m_curr_fcn_depth--;
+    m_function_scopes.pop ();
+
+    m_lexer.defining_func--;
+    m_lexer.parsed_function_name.pop ();
+    m_lexer.looking_at_return_list = false;
+    m_lexer.looking_at_parameter_list = false;
   }
 
   tree_funcall *
   base_parser::make_superclass_ref (const std::string& method_nm,
                                     const std::string& class_nm)
   {
     octave_value_list args;
 
@@ -3533,51 +3534,51 @@ namespace octave
                               tree_classdef_attribute_list *a,
                               tree_identifier *id,
                               tree_classdef_superclass_list *sc,
                               tree_classdef_body *body, token *end_tok,
                               octave_comment_list *lc)
   {
     tree_classdef *retval = 0;
 
-    lexer.symtab_context.pop ();
+    m_lexer.symtab_context.pop ();
 
     std::string cls_name = id->name ();
 
-    std::string nm = lexer.fcn_file_name;
+    std::string nm = m_lexer.fcn_file_name;
 
     size_t pos = nm.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
     if (pos != std::string::npos)
-      nm = lexer.fcn_file_name.substr (pos+1);
+      nm = m_lexer.fcn_file_name.substr (pos+1);
 
     if (nm != cls_name)
       {
         delete a;
         delete id;
         delete sc;
         delete body;
 
         bison_error ("invalid classdef definition, the class name must match the filename");
 
       }
     else
       {
         if (end_token_ok (end_tok, token::classdef_end))
           {
-            octave_comment_list *tc = lexer.comment_buf.get_comment ();
+            octave_comment_list *tc = m_lexer.comment_buf.get_comment ();
 
             int l = tok_val->line ();
             int c = tok_val->column ();
 
             if (! body)
               body = new tree_classdef_body ();
 
             retval = new tree_classdef (a, id, sc, body, lc, tc,
-                                        curr_package_name, l, c);
+                                        m_curr_package_name, l, c);
           }
         else
           {
             delete a;
             delete id;
             delete sc;
             delete body;
 
@@ -3594,17 +3595,17 @@ namespace octave
                                                tree_classdef_property_list *plist,
                                                token *end_tok,
                                                octave_comment_list *lc)
   {
     tree_classdef_properties_block *retval = 0;
 
     if (end_token_ok (end_tok, token::properties_end))
       {
-        octave_comment_list *tc = lexer.comment_buf.get_comment ();
+        octave_comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         int l = tok_val->line ();
         int c = tok_val->column ();
 
         if (! plist)
           plist = new tree_classdef_property_list ();
 
         retval = new tree_classdef_properties_block (a, plist, lc, tc, l, c);
@@ -3626,17 +3627,17 @@ namespace octave
                                             tree_classdef_methods_list *mlist,
                                             token *end_tok,
                                             octave_comment_list *lc)
   {
     tree_classdef_methods_block *retval = 0;
 
     if (end_token_ok (end_tok, token::methods_end))
       {
-        octave_comment_list *tc = lexer.comment_buf.get_comment ();
+        octave_comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         int l = tok_val->line ();
         int c = tok_val->column ();
 
         if (! mlist)
           mlist = new tree_classdef_methods_list ();
 
         retval = new tree_classdef_methods_block (a, mlist, lc, tc, l, c);
@@ -3658,17 +3659,17 @@ namespace octave
                                            tree_classdef_events_list *elist,
                                            token *end_tok,
                                            octave_comment_list *lc)
   {
     tree_classdef_events_block *retval = 0;
 
     if (end_token_ok (end_tok, token::events_end))
       {
-        octave_comment_list *tc = lexer.comment_buf.get_comment ();
+        octave_comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         int l = tok_val->line ();
         int c = tok_val->column ();
 
         if (! elist)
           elist = new tree_classdef_events_list ();
 
         retval = new tree_classdef_events_block (a, elist, lc, tc, l, c);
@@ -3690,17 +3691,17 @@ namespace octave
                                          tree_classdef_enum_list *elist,
                                          token *end_tok,
                                          octave_comment_list *lc)
   {
     tree_classdef_enum_block *retval = 0;
 
     if (end_token_ok (end_tok, token::enumeration_end))
       {
-        octave_comment_list *tc = lexer.comment_buf.get_comment ();
+        octave_comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         int l = tok_val->line ();
         int c = tok_val->column ();
 
         if (! elist)
           elist = new tree_classdef_enum_list ();
 
         retval = new tree_classdef_enum_block (a, elist, lc, tc, l, c);
@@ -3718,31 +3719,31 @@ namespace octave
 
   octave_user_function*
   base_parser::start_classdef_external_method (tree_identifier *id,
                                                tree_parameter_list *pl)
   {
     octave_user_function* retval = 0;
 
     // External methods are only allowed within @-folders. In this case,
-    // curr_class_name will be non-empty.
-
-    if (! curr_class_name.empty ())
+    // m_curr_class_name will be non-empty.
+
+    if (! m_curr_class_name.empty ())
       {
 
         std::string mname = id->name ();
 
         // Methods that cannot be declared outside the classdef file:
         // - methods with '.' character (e.g. property accessors)
         // - class constructor
         // - `delete'
 
         if (mname.find_first_of (".") == std::string::npos
             && mname != "delete"
-            && mname != curr_class_name)
+            && mname != m_curr_class_name)
           {
             // Create a dummy function that is used until the real method
             // is loaded.
 
             retval = new octave_user_function (0, pl);
 
             retval->stash_function_name (mname);
 
@@ -3842,17 +3843,17 @@ namespace octave
 
         tmp->append (elt);
 
         retval = tmp;
       }
     else
       retval = new tree_index_expression (expr, elt, l, c);
 
-    lexer.looking_at_indirect_ref = false;
+    m_lexer.looking_at_indirect_ref = false;
 
     return retval;
   }
 
   // Make an indirect reference expression with dynamic field name.
 
   tree_index_expression *
   base_parser::make_indirect_ref (tree_expression *expr,
@@ -3872,17 +3873,17 @@ namespace octave
 
         tmp->append (elt);
 
         retval = tmp;
       }
     else
       retval = new tree_index_expression (expr, elt, l, c);
 
-    lexer.looking_at_indirect_ref = false;
+    m_lexer.looking_at_indirect_ref = false;
 
     return retval;
   }
 
   // Make a declaration command.
 
   tree_decl_command *
   base_parser::make_decl_command (int tok, token *tok_val,
@@ -3898,26 +3899,26 @@ namespace octave
       case GLOBAL:
         {
           retval = new tree_decl_command ("global", lst, l, c);
           retval->mark_global ();
         }
         break;
 
       case PERSISTENT:
-        if (curr_fcn_depth > 0)
+        if (m_curr_fcn_depth > 0)
           {
             retval = new tree_decl_command ("persistent", lst, l, c);
             retval->mark_persistent ();
           }
         else
           {
-            if (lexer.reading_script_file)
+            if (m_lexer.reading_script_file)
               warning ("ignoring persistent declaration near line %d of file '%s'",
-                       l, lexer.fcn_file_full_name.c_str ());
+                       l, m_lexer.fcn_file_full_name.c_str ());
             else
               warning ("ignoring persistent declaration near line %d", l);
           }
         break;
 
       default:
         panic_impossible ();
         break;
@@ -4049,17 +4050,17 @@ namespace octave
                 is_simple_assign = false;
               }
           }
         else
           tmp = new tree_argument_list (e);
 
         if (tmp && tmp->is_valid_lvalue_list ())
           {
-            lexer.mark_as_variables (tmp->variable_names ());
+            m_lexer.mark_as_variables (tmp->variable_names ());
             retval = tmp;
           }
         else
           {
             delete tmp;
 
             bison_error ("invalid left hand side of assignment");
           }
@@ -4138,25 +4139,25 @@ namespace octave
     return (c
             ? finish_array_list (c)
             : new tree_constant (octave_value (Cell ())));
   }
 
   void
   base_parser::maybe_warn_missing_semi (tree_statement_list *t)
   {
-    if (curr_fcn_depth > 0)
+    if (m_curr_fcn_depth > 0)
       {
         tree_statement *tmp = t->back ();
 
         if (tmp->is_expression ())
           warning_with_id
             ("Octave:missing-semicolon",
              "missing semicolon near line %d, column %d in file '%s'",
-             tmp->line (), tmp->column (), lexer.fcn_file_full_name.c_str ());
+             tmp->line (), tmp->column (), m_lexer.fcn_file_full_name.c_str ());
       }
   }
 
   tree_statement_list *
   base_parser::set_stmt_print_flag (tree_statement_list *list,
                                     char sep, bool warn_missing_semi)
   {
     tree_statement *tmp = list->back ();
@@ -4192,17 +4193,17 @@ namespace octave
     return list;
   }
 
   // Finish building a statement.
   template <typename T>
   tree_statement *
   base_parser::make_statement (T *arg)
   {
-    octave_comment_list *comment = lexer.get_comment ();
+    octave_comment_list *comment = m_lexer.get_comment ();
 
     return new tree_statement (arg, comment);
   }
 
   tree_statement_list *
   base_parser::make_statement_list (tree_statement *stmt)
   {
     return new tree_statement_list (stmt);
@@ -4218,34 +4219,34 @@ namespace octave
     list->append (stmt);
 
     return list;
   }
 
   void
   base_parser::bison_error (const std::string& str, int l, int c)
   {
-    int err_line = l < 0 ? lexer.input_line_number : l;
-    int err_col = c < 0 ? lexer.current_input_column - 1 : c;
+    int err_line = l < 0 ? m_lexer.input_line_number : l;
+    int err_col = c < 0 ? m_lexer.current_input_column - 1 : c;
 
     std::ostringstream output_buf;
 
-    if (lexer.reading_fcn_file || lexer.reading_script_file
-        || lexer.reading_classdef_file)
+    if (m_lexer.reading_fcn_file || m_lexer.reading_script_file
+        || m_lexer.reading_classdef_file)
       output_buf << "parse error near line " << err_line
-                 << " of file " << lexer.fcn_file_full_name;
+                 << " of file " << m_lexer.fcn_file_full_name;
     else
       output_buf << "parse error:";
 
     if (str != "parse error")
       output_buf << "\n\n  " << str;
 
     output_buf << "\n\n";
 
-    std::string curr_line = lexer.current_input_line;
+    std::string curr_line = m_lexer.current_input_line;
 
     if (! curr_line.empty ())
       {
         size_t len = curr_line.length ();
 
         if (curr_line[len-1] == '\n')
           curr_line.resize (len-1);
 
@@ -4259,125 +4260,125 @@ namespace octave
         for (int i = 0; i < err_col + 3; i++)
           output_buf << " ";
 
         output_buf << "^";
       }
 
     output_buf << "\n";
 
-    parse_error_msg = output_buf.str ();
+    m_parse_error_msg = output_buf.str ();
   }
 
   int
   parser::run (void)
   {
     int status = -1;
 
-    yypstate *pstate = static_cast<yypstate *> (parser_state);
+    yypstate *pstate = static_cast<yypstate *> (m_parser_state);
 
     try
       {
         status = octave_pull_parse (pstate, *this);
       }
     catch (octave::execution_exception& e)
       {
-        std::string file = lexer.fcn_file_full_name;
+        std::string file = m_lexer.fcn_file_full_name;
 
         if (file.empty ())
           error (e, "parse error");
         else
           error (e, "parse error in %s", file.c_str ());
       }
     catch (const octave::exit_exception&)
       {
         throw;
       }
     catch (octave::interrupt_exception &)
       {
         throw;
       }
     catch (...)
       {
-        std::string file = lexer.fcn_file_full_name;
+        std::string file = m_lexer.fcn_file_full_name;
 
         if (file.empty ())
           error ("unexpected exception while parsing input");
         else
           error ("unexpected exception while parsing %s", file.c_str ());
       }
 
     if (status != 0)
-      parse_error ("%s", parse_error_msg.c_str ());
+      parse_error ("%s", m_parse_error_msg.c_str ());
 
     return status;
   }
 
   // Parse input from INPUT.  Pass TRUE for EOF if the end of INPUT should
   // finish the parse.
 
   int
   push_parser::run (const std::string& input, bool eof)
   {
     int status = -1;
 
-    dynamic_cast<push_lexer&> (lexer).append_input (input, eof);
+    dynamic_cast<push_lexer&> (m_lexer).append_input (input, eof);
 
     do
       {
         YYSTYPE lval;
 
-        int token = octave_lex (&lval, scanner);
+        int token = octave_lex (&lval, m_lexer.scanner);
 
         if (token < 0)
           {
-            if (! eof && lexer.at_end_of_buffer ())
+            if (! eof && m_lexer.at_end_of_buffer ())
               {
                 status = -1;
                 break;
               }
           }
 
-        yypstate *pstate = static_cast<yypstate *> (parser_state);
+        yypstate *pstate = static_cast<yypstate *> (m_parser_state);
 
         try
           {
             status = octave_push_parse (pstate, token, &lval, *this);
           }
         catch (octave::execution_exception& e)
           {
-            std::string file = lexer.fcn_file_full_name;
+            std::string file = m_lexer.fcn_file_full_name;
 
             if (file.empty ())
               error (e, "parse error");
             else
               error (e, "parse error in %s", file.c_str ());
           }
         catch (const octave::exit_exception&)
           {
             throw;
           }
         catch (octave::interrupt_exception &)
           {
             throw;
           }
         catch (...)
           {
-            std::string file = lexer.fcn_file_full_name;
+            std::string file = m_lexer.fcn_file_full_name;
 
             if (file.empty ())
               error ("unexpected exception while parsing input");
             else
               error ("unexpected exception while parsing %s", file.c_str ());
           }
       }
     while (status == YYPUSH_MORE);
 
     if (status != 0)
-      parse_error ("%s", parse_error_msg.c_str ());
+      parse_error ("%s", m_parse_error_msg.c_str ());
 
     return status;
   }
 }
 
 static void
 safe_fclose (FILE *f)
 {
@@ -4415,72 +4416,72 @@ parse_fcn_file (const std::string& full_
     ffile = std::fopen (full_file.c_str (), "rb");
 
   if (ffile)
     {
       frame.add_fcn (safe_fclose, ffile);
 
       octave::parser parser (ffile);
 
-      parser.curr_class_name = dispatch_type;
-      parser.curr_package_name = package_name;
-      parser.autoloading = autoload;
-      parser.fcn_file_from_relative_lookup = relative_lookup;
-
-      parser.lexer.force_script = force_script;
-      parser.lexer.prep_for_file ();
-      parser.lexer.parsing_class_method = ! dispatch_type.empty ();
-
-      parser.lexer.fcn_file_name = file;
-      parser.lexer.fcn_file_full_name = full_file;
-      parser.lexer.dir_name = dir_name;
-      parser.lexer.package_name = package_name;
+      parser.m_curr_class_name = dispatch_type;
+      parser.m_curr_package_name = package_name;
+      parser.m_autoloading = autoload;
+      parser.m_fcn_file_from_relative_lookup = relative_lookup;
+
+      parser.m_lexer.force_script = force_script;
+      parser.m_lexer.prep_for_file ();
+      parser.m_lexer.parsing_class_method = ! dispatch_type.empty ();
+
+      parser.m_lexer.fcn_file_name = file;
+      parser.m_lexer.fcn_file_full_name = full_file;
+      parser.m_lexer.dir_name = dir_name;
+      parser.m_lexer.package_name = package_name;
 
       int status = parser.run ();
 
-      fcn_ptr = parser.primary_fcn_ptr;
+      fcn_ptr = parser.m_primary_fcn_ptr;
 
       if (status == 0)
         {
-          if (parser.lexer.reading_classdef_file
-              && parser.classdef_object)
+          if (parser.m_lexer.reading_classdef_file
+              && parser.m_classdef_object)
             {
               // Convert parse tree for classdef object to
               // meta.class info (and stash it in the symbol
               // table?).  Return pointer to constructor?
 
               if (fcn_ptr)
                 panic_impossible ();
 
               bool is_at_folder = ! dispatch_type.empty ();
 
               octave::interpreter& interp
                 = octave::__get_interpreter__ ("parse_fcn_file");
 
               fcn_ptr
-                = parser.classdef_object->make_meta_class (interp, is_at_folder);
+                = parser.m_classdef_object->make_meta_class (interp, is_at_folder);
               if (fcn_ptr)
                 retval = octave_value (fcn_ptr);
 
-              delete (parser.classdef_object);
-
-              parser.classdef_object = 0;
+              delete (parser.m_classdef_object);
+
+              parser.m_classdef_object = 0;
             }
           else if (fcn_ptr)
             {
               retval = octave_value (fcn_ptr);
 
               fcn_ptr->maybe_relocate_end ();
 
-              if (parser.parsing_subfunctions)
+              if (parser.m_parsing_subfunctions)
                 {
-                  if (! parser.endfunction_found)
-                    parser.subfunction_names.reverse ();
-
-                  fcn_ptr->stash_subfunction_names (parser.subfunction_names);
+                  if (! parser.m_endfunction_found)
+                    parser.m_subfunction_names.reverse ();
+
+                  fcn_ptr->stash_subfunction_names (parser.m_subfunction_names);
                 }
             }
         }
       else
         error ("parse error while reading file %s", full_file.c_str ());
     }
   else if (require_file)
     error ("no such file, '%s'", full_file.c_str ());
@@ -5275,24 +5276,24 @@ namespace octave
     do
       {
         parser.reset ();
 
         parse_status = parser.run ();
 
         if (parse_status == 0)
           {
-            if (parser.stmt_list)
+            if (parser.m_stmt_list)
               {
                 tree_statement *stmt = 0;
 
                 octave::tree_evaluator& tw = __get_evaluator__ ("eval_string");
 
-                if (parser.stmt_list->length () == 1
-                    && (stmt = parser.stmt_list->front ())
+                if (parser.m_stmt_list->length () == 1
+                    && (stmt = parser.m_stmt_list->front ())
                     && stmt->is_expression ())
                   {
                     tree_expression *expr = stmt->expression ();
 
                     if (silent)
                       expr->set_print_flag (false);
 
                     bool do_bind_ans = false;
@@ -5311,26 +5312,26 @@ namespace octave
 
                     if (do_bind_ans && ! retval.empty ())
                       bind_ans (retval(0), expr->print_result ());
 
                     if (nargout == 0)
                       retval = octave_value_list ();
                   }
                 else if (nargout == 0)
-                  parser.stmt_list->accept (tw);
+                  parser.m_stmt_list->accept (tw);
                 else
                   error ("eval: invalid use of statement list");
 
                 if (tree_return_command::returning
                     || tree_break_command::breaking
                     || tree_continue_command::continuing)
                   break;
               }
-            else if (parser.lexer.end_of_input)
+            else if (parser.m_lexer.end_of_input)
               break;
           }
       }
     while (parse_status == 0);
 
     return retval;
   }
 
diff --git a/libinterp/parse-tree/parse.h b/libinterp/parse-tree/parse.h
--- a/libinterp/parse-tree/parse.h
+++ b/libinterp/parse-tree/parse.h
@@ -88,18 +88,17 @@ namespace octave
 
 #include "ovl.h"
 
 // Nonzero means print parser debugging info (-d).
 extern int octave_debug;
 
 namespace octave
 {
-  class
-  base_parser
+  class base_parser
   {
   private:
 
     class parent_scope_info
     {
     public:
 
       typedef std::pair<symbol_table::scope*, std::string> value_type;
@@ -133,18 +132,18 @@ namespace octave
       symbol_table::scope *parent_scope (void) const;
 
       std::string parent_name (void) const;
 
       void clear (void);
 
     private:
 
-      std::deque<value_type> info;
-      std::set<std::string> all_names;
+      std::deque<value_type> m_info;
+      std::set<std::string> m_all_names;
     };
 
   public:
 
     base_parser (base_lexer& lxr);
 
     // No copying!
 
@@ -406,86 +405,85 @@ namespace octave
     append_statement_list (tree_statement_list *list, char sep,
                            tree_statement *stmt, bool warn_missing_semi);
 
     // Generic error messages.
     void bison_error (const std::string& s, int l = -1, int c = -1);
 
     // Contains error message if Bison-generated parser returns non-zero
     // status.
-    std::string parse_error_msg;
+    std::string m_parse_error_msg;
 
     // Have we found an explicit end to a function?
-    bool endfunction_found;
+    bool m_endfunction_found;
 
     // TRUE means we are in the process of autoloading a function.
-    bool autoloading;
+    bool m_autoloading;
 
     // TRUE means the current function file was found in a relative path
     // element.
-    bool fcn_file_from_relative_lookup;
+    bool m_fcn_file_from_relative_lookup;
 
     // FALSE if we are still at the primary function.  Subfunctions can
     // only be declared inside function files.
-    bool parsing_subfunctions;
+    bool m_parsing_subfunctions;
 
     // TRUE if we are parsing local functions defined at after a
     // classdef block.  Local functions can only be declared inside
     // classdef files.
-    bool parsing_local_functions;
+    bool m_parsing_local_functions;
 
     // Maximum function depth detected.  Used to determine whether
     // we have nested functions or just implicitly ended subfunctions.
-    int max_fcn_depth;
+    int m_max_fcn_depth;
 
     // = 0 currently outside any function.
     // = 1 inside the primary function or a subfunction.
     // > 1 means we are looking at a function definition that seems to be
     //     inside a function.  Note that the function still might not be a
     //     nested function.
-    int curr_fcn_depth;
+    int m_curr_fcn_depth;
 
     // Scope where we install all subfunctions and nested functions.  Only
     // used while reading function files.
-    symbol_table::scope *primary_fcn_scope;
+    symbol_table::scope *m_primary_fcn_scope;
 
     // Name of the current class when we are parsing class methods or
     // constructors.
-    std::string curr_class_name;
+    std::string m_curr_class_name;
 
     // Name of the current package when we are parsing an element contained
     // in a package directory (+-directory).
-    std::string curr_package_name;
+    std::string m_curr_package_name;
 
     // Nested function scopes and names currently being parsed.
-    parent_scope_info function_scopes;
+    parent_scope_info m_function_scopes;
 
     // Pointer to the primary user function or user script function.
-    octave_function *primary_fcn_ptr;
+    octave_function *m_primary_fcn_ptr;
 
     // List of subfunction names, initially in the order they are
     // installed in the symbol table, then ordered as they appear in the
     // file.  Eventually stashed in the primary function object.
-    std::list<std::string> subfunction_names;
+    std::list<std::string> m_subfunction_names;
 
     // Pointer to the classdef object we just parsed, if any.
-    tree_classdef *classdef_object;
+    tree_classdef *m_classdef_object;
 
     // Result of parsing input.
-    tree_statement_list *stmt_list;
+    tree_statement_list *m_stmt_list;
 
     // State of the lexer.
-    base_lexer& lexer;
+    base_lexer& m_lexer;
 
     // Internal state of the Bison parser.
-    void *parser_state;
+    void *m_parser_state;
   };
 
-  class
-  parser : public base_parser
+  class parser : public base_parser
   {
   public:
 
     parser (void)
       : base_parser (*(new octave::lexer ()))
     { }
 
     parser (FILE *file)
@@ -506,18 +504,17 @@ namespace octave
 
     parser& operator = (const parser&) = delete;
 
     ~parser (void) = default;
 
     int run (void);
   };
 
-  class
-  push_parser : public base_parser
+  class push_parser : public base_parser
   {
   public:
 
     push_parser (void)
       : base_parser (*(new octave::push_lexer ()))
     { }
 
     // No copying!
