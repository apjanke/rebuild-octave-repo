# HG changeset patch
# User sh@sh-laptop
# Date 1231983865 18000
#      Wed Jan 14 20:44:25 2009 -0500
# Node ID 81d6ab3ac93ccf719684db4b22c93a9f5626c48f
# Parent  e2a179415bac5f933a51d9f840dc62c7035a1812
Allow documentation tobe built for other formats than tex and info

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,10 +1,31 @@
+2009-01-14  Søren Hauberg  <hauberg@gmail.com>
+
+	* general/diff.m, general/logspace.m, general/nextpow2.m,
+	linear-algebra/commutation_matrix.m,
+	linear-algebra/duplication_matrix.m, linear-algebra/expm.m,
+	miscellaneous/bincoeff.m, miscellaneous/list_primes.m,
+	optimization/fsolve.m, plot/subplot.m, polynomial/pchip.m,
+	polynomial/polyout.m, polynomial/residue.m, polynomial/spline.m,
+	signal/freqz.m, signal/sinc.m, specfun/beta.m, specfun/betaln.m,
+	specfun/nchoosek.m, specfun/pow2.m, special-matrix/hankel.m,
+	special-matrix/hilb.m, special-matrix/invhilb.m
+	special-matrix/sylvester_matrix.m, special-matrix/toeplitz.m,
+	special-matrix/vander.m, statistics/base/gls.m,
+	statistics/base/kendall.m, statistics/base/kurtosis.m,
+	statistics/base/mean.m, statistics/base/median.m,
+	statistics/base/ols.m, statistics/base/skewness.m,
+	statistics/distributions/kolmogorov_smirnov_cdf.m:
+	Use ifnottex instead of ifinfo.
+
 2009-01-14  John W. Eaton  <jwe@octave.org>
 
+	* linear-algebra/expm.m: 
+
 	* optimization/fsolve.m: Doc fix.
 
 	* plot/__go_draw_axes__.m: Scale markersize by 1/3, not 1/6.
 
 	* io/dlmwrite.m: Use '%c' format for character data.
 
 2009-01-13  John W. Eaton  <jwe@octave.org>
 
diff --git a/scripts/general/diff.m b/scripts/general/diff.m
--- a/scripts/general/diff.m
+++ b/scripts/general/diff.m
@@ -21,19 +21,19 @@
 ## @deftypefn {Function File} {} diff (@var{x}, @var{k}, @var{dim})
 ## If @var{x} is a vector of length @var{n}, @code{diff (@var{x})} is the
 ## vector of first differences
 ## @iftex
 ## @tex
 ##  $x_2 - x_1, \ldots{}, x_n - x_{n-1}$.
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##  @var{x}(2) - @var{x}(1), @dots{}, @var{x}(n) - @var{x}(n-1).
-## @end ifinfo
+## @end ifnottex
 ##
 ## If @var{x} is a matrix, @code{diff (@var{x})} is the matrix of column
 ## differences along the first non-singleton dimension.
 ##
 ## The second argument is optional.  If supplied, @code{diff (@var{x},
 ## @var{k})}, where @var{k} is a nonnegative integer, returns the
 ## @var{k}-th differences. It is possible that @var{k} is larger than
 ## then first non-singleton dimension of the matrix. In this case,
diff --git a/scripts/general/logspace.m b/scripts/general/logspace.m
--- a/scripts/general/logspace.m
+++ b/scripts/general/logspace.m
@@ -21,47 +21,47 @@
 ## @deftypefn {Function File} {} logspace (@var{base}, @var{limit}, @var{n})
 ## Similar to @code{linspace} except that the values are logarithmically
 ## spaced from
 ## @iftex
 ## @tex
 ## $10^{base}$ to $10^{limit}$.
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ## 10^base to 10^limit.
-## @end ifinfo
+## @end ifnottex
 ##
 ## If @var{limit} is equal to
 ## @iftex
 ## @tex
 ## $\pi$,
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ## pi,
-## @end ifinfo
+## @end ifnottex
 ## the points are between
 ## @iftex
 ## @tex
 ## $10^{base}$ and $\pi$,
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ## 10^base and pi,
-## @end ifinfo
+## @end ifnottex
 ## @emph{not}
 ## @iftex
 ## @tex
 ## $10^{base}$ and $10^{\pi}$,
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ## 10^base and 10^pi,
-## @end ifinfo
+## @end ifnottex
 ## in order to  be compatible with the corresponding @sc{Matlab}
 ## function.
 ##
 ## Also for compatibility, return the second argument if fewer than two
 ## values are requested.
 ## @seealso{linspace}
 ## @end deftypefn
 
diff --git a/scripts/general/nextpow2.m b/scripts/general/nextpow2.m
--- a/scripts/general/nextpow2.m
+++ b/scripts/general/nextpow2.m
@@ -20,19 +20,19 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} nextpow2 (@var{x})
 ## If @var{x} is a scalar, returns the first integer @var{n} such that
 ## @iftex
 ## @tex
 ##  $2^n \ge |x|$.
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##  2^n >= abs (x).
-## @end ifinfo
+## @end ifnottex
 ##
 ## If @var{x} is a vector, return @code{nextpow2 (length (@var{x}))}.
 ## @seealso{pow2}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 7 October 1994
 ## Adapted-By: jwe
diff --git a/scripts/linear-algebra/commutation_matrix.m b/scripts/linear-algebra/commutation_matrix.m
--- a/scripts/linear-algebra/commutation_matrix.m
+++ b/scripts/linear-algebra/commutation_matrix.m
@@ -20,65 +20,65 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} commutation_matrix (@var{m}, @var{n})
 ## Return the commutation matrix
 ## @iftex
 ## @tex
 ##  $K_{m,n}$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##  K(m,n)
-## @end ifinfo
+## @end ifnottex
 ##  which is the unique
 ## @iftex
 ## @tex
 ##  $m n \times m n$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##  @var{m}*@var{n} by @var{m}*@var{n}
-## @end ifinfo
+## @end ifnottex
 ##  matrix such that
 ## @iftex
 ## @tex
 ##  $K_{m,n} \cdot {\rm vec} (A) = {\rm vec} (A^T)$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##  @math{K(m,n) * vec(A) = vec(A')}
-## @end ifinfo
+## @end ifnottex
 ##  for all
 ## @iftex
 ## @tex
 ##  $m\times n$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##  @math{m} by @math{n}
-## @end ifinfo
+## @end ifnottex
 ##  matrices
 ## @iftex
 ## @tex
 ##  $A$.
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##  @math{A}.
-## @end ifinfo
+## @end ifnottex
 ##
 ## If only one argument @var{m} is given,
 ## @iftex
 ## @tex
 ##  $K_{m,m}$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##  @math{K(m,m)}
-## @end ifinfo
+## @end ifnottex
 ##  is returned.
 ##
 ## See Magnus and Neudecker (1988), Matrix differential calculus with
 ## applications in statistics and econometrics.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 8 May 1995
diff --git a/scripts/linear-algebra/duplication_matrix.m b/scripts/linear-algebra/duplication_matrix.m
--- a/scripts/linear-algebra/duplication_matrix.m
+++ b/scripts/linear-algebra/duplication_matrix.m
@@ -20,55 +20,55 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} duplication_matrix (@var{n})
 ## Return the duplication matrix
 ## @iftex
 ## @tex
 ##  $D_n$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##  @math{Dn}
-## @end ifinfo
+## @end ifnottex
 ##  which is the unique
 ## @iftex
 ## @tex
 ##  $n^2 \times n(n+1)/2$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##  @math{n^2} by @math{n*(n+1)/2}
-## @end ifinfo
+## @end ifnottex
 ##  matrix such that
 ## @iftex
 ## @tex
 ##  $D_n * {\rm vech} (A) = {\rm vec} (A)$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##  @math{Dn vech (A) = vec (A)}
-## @end ifinfo
+## @end ifnottex
 ##  for all symmetric
 ## @iftex
 ## @tex
 ##  $n \times n$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##  @math{n} by @math{n}
-## @end ifinfo
+## @end ifnottex
 ##  matrices
 ## @iftex
 ## @tex
 ##  $A$.
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##  @math{A}.
-## @end ifinfo
+## @end ifnottex
 ##
 ## See Magnus and Neudecker (1988), Matrix differential calculus with
 ## applications in statistics and econometrics.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 8 May 1995
 ## Adapged-By: jwe
diff --git a/scripts/linear-algebra/expm.m b/scripts/linear-algebra/expm.m
--- a/scripts/linear-algebra/expm.m
+++ b/scripts/linear-algebra/expm.m
@@ -22,87 +22,87 @@
 ## series
 ## @iftex
 ## @tex
 ## $$
 ##  \exp (A) = I + A + {A^2 \over 2!} + {A^3 \over 3!} + \cdots
 ## $$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ## 
 ## @example
 ## expm(a) = I + a + a^2/2! + a^3/3! + ...
 ## @end example
 ## 
-## @end ifinfo
+## @end ifnottex
 ## The Taylor series is @emph{not} the way to compute the matrix
 ## exponential; see Moler and Van Loan, @cite{Nineteen Dubious Ways to
 ## Compute the Exponential of a Matrix}, SIAM Review, 1978.  This routine
 ## uses Ward's diagonal
 ## @iftex
 ## @tex
 ## Pad\'e
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ## Pade'
-## @end ifinfo
+## @end ifnottex
 ## approximation method with three step preconditioning (SIAM Journal on
 ## Numerical Analysis, 1977).  Diagonal
 ## @iftex
 ## @tex
 ## Pad\'e
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ## Pade'
-## @end ifinfo
+## @end ifnottex
 ##  approximations are rational polynomials of matrices
 ## @iftex
 ## @tex
 ## $D_q(a)^{-1}N_q(a)$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ## 
 ## @example
 ##      -1
 ## D (a)   N (a)
 ## @end example
 ## 
-## @end ifinfo
+## @end ifnottex
 ##  whose Taylor series matches the first
 ## @iftex
 ## @tex
 ## $2 q + 1 $
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ## @code{2q+1}
-## @end ifinfo
+## @end ifnottex
 ## terms of the Taylor series above; direct evaluation of the Taylor series
 ## (with the same preconditioning steps) may be desirable in lieu of the
 ## @iftex
 ## @tex
 ## Pad\'e
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ## Pade'
-## @end ifinfo
+## @end ifnottex
 ## approximation when
 ## @iftex
 ## @tex
 ## $D_q(a)$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ## @code{Dq(a)}
-## @end ifinfo
+## @end ifnottex
 ## is ill-conditioned.
 ## @end deftypefn
 
 function r = expm (a)
 
   if (! ismatrix (a) || ! issquare (a))
     error ("expm requires a square matrix")
   endif
diff --git a/scripts/miscellaneous/bincoeff.m b/scripts/miscellaneous/bincoeff.m
--- a/scripts/miscellaneous/bincoeff.m
+++ b/scripts/miscellaneous/bincoeff.m
@@ -22,28 +22,28 @@
 ## Return the binomial coefficient of @var{n} and @var{k}, defined as
 ## @iftex
 ## @tex
 ## $$
 ##  {n \choose k} = {n (n-1) (n-2) \cdots (n-k+1) \over k!}
 ## $$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##
 ## @example
 ## @group
 ##  /   \
 ##  | n |    n (n-1) (n-2) ... (n-k+1)
 ##  |   |  = -------------------------
 ##  | k |               k!
 ##  \   /
 ## @end group
 ## @end example
-## @end ifinfo
+## @end ifnottex
 ##
 ## For example,
 ##
 ## @example
 ## @group
 ## bincoeff (5, 2)
 ##      @result{} 10
 ## @end group
diff --git a/scripts/miscellaneous/list_primes.m b/scripts/miscellaneous/list_primes.m
--- a/scripts/miscellaneous/list_primes.m
+++ b/scripts/miscellaneous/list_primes.m
@@ -23,19 +23,19 @@
 ## 30 primes are listed.
 ##
 ## The algorithm used is from page 218 of the
 ## @iftex
 ## @tex
 ##  {\TeX}book.
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##  TeXbook.
-## @end ifinfo
+## @end ifnottex
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = list_primes (n)
 
   if (nargin > 0)
     if (! isscalar (n))
diff --git a/scripts/plot/subplot.m b/scripts/plot/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/subplot.m
@@ -38,30 +38,30 @@
 ## \hfil\vbox{\offinterlineskip\hrule
 ## \halign{\vrule#&&\qquad\hfil#\hfil\qquad\vrule\cr
 ## height13pt&1&2&3\cr height12pt&&&\cr\noalign{\hrule}
 ## height13pt&4&5&6\cr height12pt&&&\cr\noalign{\hrule}}}
 ## \hfil
 ## \vskip 10pt
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ## @display
 ## @example
 ## @group
 ##
 ## +-----+-----+-----+
 ## |  1  |  2  |  3  |
 ## +-----+-----+-----+
 ## |  4  |  5  |  6  |
 ## +-----+-----+-----+
 ## @end group
 ## @end example
 ## @end display
-## @end ifinfo
+## @end ifnottex
 ## @seealso{plot}
 ## @end deftypefn
 
 ## Author: Vinayak Dutt <Dutt.Vinayak@mayo.EDU>
 ## Adapted-By: jwe
 
 function h = subplot (rows, columns, index)
 
diff --git a/scripts/polynomial/pchip.m b/scripts/polynomial/pchip.m
--- a/scripts/polynomial/pchip.m
+++ b/scripts/polynomial/pchip.m
@@ -30,29 +30,29 @@
 ## array. In the case where @var{y} is a vector, it must have a length
 ## of @var{n}. If @var{y} is an array, then the size of @var{y} must
 ## have the form
 ## @iftex
 ## @tex
 ## $$[s_1, s_2, \cdots, s_k, n]$$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ## @code{[@var{s1}, @var{s2}, @dots{}, @var{sk}, @var{n}]}
-## @end ifinfo
+## @end ifnottex
 ## The array is then reshaped internally to a matrix where the leading
 ## dimension is given by 
 ## @iftex
 ## @tex
 ## $$s_1 s_2 \cdots s_k$$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ## @code{@var{s1} * @var{s2} * @dots{} * @var{sk}}
-## @end ifinfo
+## @end ifnottex
 ## and each row in this matrix is then treated separately. Note that this
 ## is exactly the opposite treatment than @code{interp1} and is done
 ## for compatibility.
 ##
 ## Called with a third input argument, @code{pchip} evaluates the 
 ## piece-wise polynomial at the points @var{xi}. There is an equivalence
 ## between @code{ppval (pchip (@var{x}, @var{y}), @var{xi})} and
 ## @code{pchip (@var{x}, @var{y}, @var{xi})}.
diff --git a/scripts/polynomial/polyout.m b/scripts/polynomial/polyout.m
--- a/scripts/polynomial/polyout.m
+++ b/scripts/polynomial/polyout.m
@@ -20,21 +20,21 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} polyout (@var{c}, @var{x})
 ## Write formatted polynomial
 ## @iftex
 ## @tex
 ## $$ c(x) = c_1 x^n + \ldots + c_n x + c_{n+1} $$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ## @example
 ##    c(x) = c(1) * x^n + ... + c(n) x + c(n+1)
 ## @end example
-## @end ifinfo
+## @end ifnottex
 ##  and return it as a string or write it to the screen (if
 ##  @var{nargout} is zero).
 ##  @var{x} defaults to the string @code{"s"}.
 ## @seealso{polyval, polyvalm, poly, roots, conv, deconv, residue,
 ## filter, polyderiv, polyinteg}
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -26,24 +26,24 @@
 ## @iftex
 ## @tex
 ## $$
 ## {B(s)\over A(s)} = \sum_{m=1}^M {r_m\over (s-p_m)^e_m}
 ##   + \sum_{i=1}^N k_i s^{N-i}.
 ## $$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##
 ## @example
 ##  B(s)    M       r(m)         N
 ##  ---- = SUM -------------  + SUM k(i)*s^(N-i)
 ##  A(s)   m=1 (s-p(m))^e(m)    i=1
 ## @end example
-## @end ifinfo
+## @end ifnottex
 ##
 ## @noindent
 ## where @math{M} is the number of poles (the length of the @var{r},
 ## @var{p}, and @var{e}), the @var{k} vector is a polynomial of order @math{N-1}
 ## representing the direct contribution, and the @var{e} vector specifies
 ## the multiplicity of the m-th residue's pole.
 ##
 ## For example,
@@ -64,25 +64,25 @@
 ## which represents the following partial fraction expansion
 ## @iftex
 ## @tex
 ## $$
 ## {s^2+s+1\over s^3-5s^2+8s-4} = {-2\over s-2} + {7\over (s-2)^2} + {3\over s-1}
 ## $$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##
 ## @example
 ##         s^2 + s + 1       -2        7        3
 ##    ------------------- = ----- + ------- + -----
 ##    s^3 - 5s^2 + 8s - 4   (s-2)   (s-2)^2   (s-1)
 ## @end example
 ##
-## @end ifinfo
+## @end ifnottex
 ##
 ## @deftypefnx {Function File} {[@var{b}, @var{a}] =} residue (@var{r}, @var{p}, @var{k})
 ## @deftypefnx {Function File} {[@var{b}, @var{a}] =} residue (@var{r}, @var{p}, @var{k}, @var{e})
 ## Compute the reconstituted quotient of polynomials,
 ## @var{b}(s)/@var{a}(s), from the partial fraction expansion;
 ## represented by the residues, poles, and a direct polynomial specified
 ## by @var{r}, @var{p} and @var{k}, and the pole multiplicity @var{e}.
 ##
@@ -123,24 +123,24 @@
 ## which represents the following partial fraction expansion
 ## @iftex
 ## @tex
 ## $$
 ## {-2\over s-2} + {7\over (s-2)^2} + {3\over s-1} + s = {s^4-5s^3+9s^2-3s+1\over s^3-5s^2+8s-4}
 ## $$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##
 ## @example
 ##     -2        7        3         s^4 - 5s^3 + 9s^2 - 3s + 1
 ##    ----- + ------- + ----- + s = --------------------------
 ##    (s-2)   (s-2)^2   (s-1)          s^3 - 5s^2 + 8s - 4
 ## @end example
-## @end ifinfo
+## @end ifnottex
 ## @seealso{poly, roots, conv, deconv, mpoles, polyval, polyderiv, polyinteg}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: June 1994
 ## Adapted-By: jwe
 
diff --git a/scripts/polynomial/spline.m b/scripts/polynomial/spline.m
--- a/scripts/polynomial/spline.m
+++ b/scripts/polynomial/spline.m
@@ -35,38 +35,38 @@
 ## derivative of the cubic spline at the end-points.
 ##
 ## If @var{y} is an array, then the size of @var{y} must have the form
 ## @iftex
 ## @tex
 ## $$[s_1, s_2, \cdots, s_k, n]$$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ## @code{[@var{s1}, @var{s2}, @dots{}, @var{sk}, @var{n}]}
-## @end ifinfo
+## @end ifnottex
 ## or
 ## @iftex
 ## @tex
 ## $$[s_1, s_2, \cdots, s_k, n + 2]$$.
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ## @code{[@var{s1}, @var{s2}, @dots{}, @var{sk}, @var{n} + 2]}.
-## @end ifinfo
+## @end ifnottex
 ## The array is then reshaped internally to a matrix where to leading
 ## dimension is given by 
 ## @iftex
 ## @tex
 ## $$s_1 s_2 \cdots s_k$$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ## @code{@var{s1} * @var{s2} * @dots{} * @var{sk}}
-## @end ifinfo
+## @end ifnottex
 ## and each row this matrix is then treated separately. Note that this
 ## is exactly the opposite treatment than @code{interp1} and is done
 ## for compatibility.
 ##
 ## Called with a third input argument, @code{spline} evaluates the 
 ## piece-wise spline at the points @var{xi}. There is an equivalence
 ## between @code{ppval (spline (@var{x}, @var{y}), @var{xi})} and
 ## @code{spline (@var{x}, @var{y}, @var{xi})}.
diff --git a/scripts/signal/freqz.m b/scripts/signal/freqz.m
--- a/scripts/signal/freqz.m
+++ b/scripts/signal/freqz.m
@@ -18,33 +18,33 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{h}, @var{w}] =} freqz (@var{b}, @var{a}, @var{n}, "whole")
 ## Return the complex frequency response @var{h} of the rational IIR filter
 ## whose numerator and denominator coefficients are @var{b} and @var{a},
 ## respectively.  The response is evaluated at @var{n} angular frequencies
 ## between 0 and
-## @ifinfo
+## @ifnottex
 ##  2*pi.
-## @end ifinfo
+## @end ifnottex
 ## @iftex
 ## @tex
 ##  $2\pi$.
 ## @end tex
 ## @end iftex
 ##
 ## @noindent
 ## The output value @var{w} is a vector of the frequencies.
 ##
 ## If the fourth argument is omitted, the response is evaluated at
 ## frequencies between 0 and
-## @ifinfo
+## @ifnottex
 ##  pi.
-## @end ifinfo
+## @end ifnottex
 ## @iftex
 ## @tex
 ##  $\pi$.
 ## @end tex
 ## @end iftex
 ##
 ## If @var{n} is omitted, a value of 512 is assumed.
 ##
diff --git a/scripts/signal/sinc.m b/scripts/signal/sinc.m
--- a/scripts/signal/sinc.m
+++ b/scripts/signal/sinc.m
@@ -20,19 +20,19 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} sinc (@var{x})
 ## Return
 ## @iftex
 ## @tex
 ## $ \sin (\pi x)/(\pi x)$.
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##  sin(pi*x)/(pi*x).
-## @end ifinfo
+## @end ifnottex
 ## @end deftypefn
 
 ## Author: jwe ???
 
 function result = sinc (x)
 
   if (nargin != 1)
     print_usage ();
diff --git a/scripts/specfun/beta.m b/scripts/specfun/beta.m
--- a/scripts/specfun/beta.m
+++ b/scripts/specfun/beta.m
@@ -22,22 +22,22 @@
 ## For real inputs, return the Beta function,
 ## @iftex
 ## @tex
 ## $$
 ##  B (a, b) = {\Gamma (a) \Gamma (b) \over \Gamma (a + b)}.
 ## $$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##
 ## @example
 ## beta (a, b) = gamma (a) * gamma (b) / gamma (a + b).
 ## @end example
-## @end ifinfo
+## @end ifnottex
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 13 June 1993
 ## Adapted-By: jwe
 
 function retval = beta (a, b)
 
diff --git a/scripts/specfun/betaln.m b/scripts/specfun/betaln.m
--- a/scripts/specfun/betaln.m
+++ b/scripts/specfun/betaln.m
@@ -21,22 +21,22 @@
 ## Return the log of the Beta function,
 ## @iftex
 ## @tex
 ## $$
 ##  B (a, b) = \log {\Gamma (a) \Gamma (b) \over \Gamma (a + b)}.
 ## $$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##
 ## @example
 ## betaln (a, b) = gammaln (a) + gammaln (b) - gammaln (a + b)
 ## @end example
-## @end ifinfo
+## @end ifnottex
 ## @seealso{beta, betainc, gammaln}
 ## @end deftypefn
 
 ## Author:   Nicol N. Schraudolph <nic@idsia.ch>
 ## Created:  06 Aug 1998
 ## Keywords: log beta special function
 
 function retval = betaln (a, b)
diff --git a/scripts/specfun/nchoosek.m b/scripts/specfun/nchoosek.m
--- a/scripts/specfun/nchoosek.m
+++ b/scripts/specfun/nchoosek.m
@@ -27,28 +27,28 @@
 ## @iftex
 ## @tex
 ## $$
 ##  {n \choose k} = {n (n-1) (n-2) \cdots (n-k+1) \over k!}
 ##                = {n! \over k! (n-k)!}
 ## $$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##
 ## @example
 ## @group
 ##  /   \
 ##  | n |    n (n-1) (n-2) ... (n-k+1)       n!
 ##  |   |  = ------------------------- =  ---------
 ##  | k |               k!                k! (n-k)!
 ##  \   /
 ## @end group
 ## @end example
-## @end ifinfo
+## @end ifnottex
 ##
 ## If @var{n} is a vector generate all combinations of the elements
 ## of @var{n}, taken @var{k} at a time, one row per combination. The 
 ## resulting @var{c} has size @code{[nchoosek (length (@var{n}), 
 ## @var{k}), @var{k}]}.
 ##
 ## @code{nchoosek} works only for nonnegative integer arguments; use
 ## @code{bincoeff} for non-integer scalar arguments and for using vector
diff --git a/scripts/specfun/pow2.m b/scripts/specfun/pow2.m
--- a/scripts/specfun/pow2.m
+++ b/scripts/specfun/pow2.m
@@ -21,28 +21,28 @@
 ## @deftypefn {Mapping Function} {} pow2 (@var{x})
 ## @deftypefnx {Mapping Function} {} pow2 (@var{f}, @var{e})
 ## With one argument, computes
 ## @iftex
 ## @tex
 ##  $2^x$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##  2 .^ x
-## @end ifinfo
+## @end ifnottex
 ## for each element of @var{x}.  With two arguments, returns
 ## @iftex
 ## @tex
 ##  $f \cdot 2^e$.
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##  f .* (2 .^ e).
-## @end ifinfo
+## @end ifnottex
 ## @seealso{nextpow2}
 ## @end deftypefn
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 17 October 1994
 ## Adapted-By: jwe
 
 function y = pow2 (f, e)
diff --git a/scripts/special-matrix/hankel.m b/scripts/special-matrix/hankel.m
--- a/scripts/special-matrix/hankel.m
+++ b/scripts/special-matrix/hankel.m
@@ -29,25 +29,25 @@
 ## @var{r}, has the elements
 ## @iftex
 ## @tex
 ## $$
 ## H (i, j) = \cases{c_{i+j-1},&$i+j-1\le m$;\cr r_{i+j-m},&otherwise.\cr}
 ## $$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##
 ## @example
 ## @group
 ## H(i,j) = c(i+j-1),  i+j-1 <= m;
 ## H(i,j) = r(i+j-m),  otherwise
 ## @end group
 ## @end example
-## @end ifinfo
+## @end ifnottex
 ## @seealso{vander, sylvester_matrix, hilb, invhilb, toeplitz}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = hankel (c, r)
 
   if (nargin == 1)
diff --git a/scripts/special-matrix/hilb.m b/scripts/special-matrix/hilb.m
--- a/scripts/special-matrix/hilb.m
+++ b/scripts/special-matrix/hilb.m
@@ -20,33 +20,33 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hilb (@var{n})
 ## Return the Hilbert matrix of order @var{n}.  The
 ## @iftex
 ## @tex
 ## $i,\,j$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ## i, j
-## @end ifinfo
+## @end ifnottex
 ## element of a Hilbert matrix is defined as
 ## @iftex
 ## @tex
 ## $$
 ## H (i, j) = {1 \over (i + j - 1)}
 ## $$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##
 ## @example
 ## H (i, j) = 1 / (i + j - 1)
 ## @end example
-## @end ifinfo
+## @end ifnottex
 ## @seealso{hankel, vander, sylvester_matrix, invhilb, toeplitz}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = hilb (n)
 
 
diff --git a/scripts/special-matrix/invhilb.m b/scripts/special-matrix/invhilb.m
--- a/scripts/special-matrix/invhilb.m
+++ b/scripts/special-matrix/invhilb.m
@@ -30,33 +30,33 @@
 ##          &= { p(i)p(j) \over (i+j-1) }
 ## }$$
 ## where
 ## $$
 ##   p(k) = -1^k \left( \matrix{ k+n-1 \cr k-1 } \right)
 ##               \left( \matrix{ n \cr k } \right)
 ##$$
 ## @end tex
-## @ifinfo
+## @ifnottex
 ## @example
 ##
 ##             (i+j)         /n+i-1\  /n+j-1\   /i+j-2\ 2
 ##  A(i,j) = -1      (i+j-1)(       )(       ) (       )
 ##                           \ n-j /  \ n-i /   \ i-2 /
 ##
 ##         = p(i) p(j) / (i+j-1)
 ##
 ## @end example
 ## where
 ## @example
 ##              k  /k+n-1\   /n\
 ##     p(k) = -1  (       ) (   )
 ##                 \ k-1 /   \k/
 ## @end example
-## @end ifinfo
+## @end ifnottex
 ##
 ## The validity of this formula can easily be checked by expanding 
 ## the binomial coefficients in both formulas as factorials.  It can 
 ## be derived more directly via the theory of Cauchy matrices: 
 ## see J. W. Demmel, Applied Numerical Linear Algebra, page 92.
 ##
 ## Compare this with the numerical calculation of @code{inverse (hilb (n))},
 ## which suffers from the ill-conditioning of the Hilbert matrix, and the
diff --git a/scripts/special-matrix/sylvester_matrix.m b/scripts/special-matrix/sylvester_matrix.m
--- a/scripts/special-matrix/sylvester_matrix.m
+++ b/scripts/special-matrix/sylvester_matrix.m
@@ -20,19 +20,19 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} sylvester_matrix (@var{k})
 ## Return the Sylvester matrix of order
 ## @iftex
 ## @tex
 ## $n = 2^k$.
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ## n = 2^k.
-## @end ifinfo
+## @end ifnottex
 ## @seealso{hankel, vander, hilb, invhilb, toeplitz}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = sylvester_matrix (k)
 
   if (nargin != 1)
diff --git a/scripts/special-matrix/toeplitz.m b/scripts/special-matrix/toeplitz.m
--- a/scripts/special-matrix/toeplitz.m
+++ b/scripts/special-matrix/toeplitz.m
@@ -32,30 +32,30 @@
 ## \left[\matrix{c_0    & r_1     & r_2      & \cdots & r_n\cr
 ##               c_1    & c_0     & r_1      & \cdots & r_{n-1}\cr
 ##               c_2    & c_1     & c_0      & \cdots & r_{n-2}\cr
 ##               \vdots & \vdots  & \vdots   & \ddots & \vdots\cr
 ##               c_n    & c_{n-1} & c_{n-2} & \ldots & c_0}\right]
 ## $$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##
 ## @example
 ## @group
 ## c(0)  r(1)   r(2)  ...  r(n)
 ## c(1)  c(0)   r(1)  ... r(n-1)
 ## c(2)  c(1)   c(0)  ... r(n-2)
 ##  .     ,      ,   .      .
 ##  .     ,      ,     .    .
 ##  .     ,      ,       .  .
 ## c(n) c(n-1) c(n-2) ...  c(0)
 ## @end group
 ## @end example
-## @end ifinfo
+## @end ifnottex
 ## @seealso{hankel, vander, sylvester_matrix, hilb, invhilb}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = toeplitz (c, r)
 
   if (nargin == 1)
diff --git a/scripts/special-matrix/vander.m b/scripts/special-matrix/vander.m
--- a/scripts/special-matrix/vander.m
+++ b/scripts/special-matrix/vander.m
@@ -27,29 +27,29 @@
 ## $$
 ## \left[\matrix{c_1^{n-1}  & \cdots & c_1^2  & c_1    & 1      \cr
 ##               c_2^{n-1}  & \cdots & c_2^2  & c_2    & 1      \cr
 ##               \vdots     & \ddots & \vdots & \vdots & \vdots \cr
 ##               c_n^{n-1}  & \cdots & c_n^2  & c_n    & 1      }\right]
 ## $$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##
 ## @example
 ## @group
 ## c(1)^(n-1) ... c(1)^2  c(1)  1
 ## c(2)^(n-1) ... c(2)^2  c(2)  1
 ##     .     .      .      .    .
 ##     .       .    .      .    .
 ##     .         .  .      .    .
 ## c(n)^(n-1) ... c(n)^2  c(n)  1
 ## @end group
 ## @end example
-## @end ifinfo
+## @end ifnottex
 ## @seealso{hankel, sylvester_matrix, hilb, invhilb, toeplitz}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = vander (c)
 
   if (nargin != 1)
diff --git a/scripts/statistics/base/gls.m b/scripts/statistics/base/gls.m
--- a/scripts/statistics/base/gls.m
+++ b/scripts/statistics/base/gls.m
@@ -21,34 +21,34 @@
 ## @deftypefn {Function File} {[@var{beta}, @var{v}, @var{r}] =} gls (@var{y}, @var{x}, @var{o})
 ## Generalized least squares estimation for the multivariate model
 ## @iftex
 ## @tex
 ## $y = x b + e$
 ## with $\bar{e} = 0$ and cov(vec($e$)) = $(s^2)o$,
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ## @math{y = x b + e} with @math{mean (e) = 0} and
 ## @math{cov (vec (e)) = (s^2) o},
-## @end ifinfo
+## @end ifnottex
 ##  where
 ## @iftex
 ## @tex
 ## $y$ is a $t \times p$ matrix, $x$ is a $t \times k$ matrix, $b$ is a $k
 ## \times p$ matrix, $e$ is a $t \times p$ matrix, and $o$ is a $tp \times
 ## tp$ matrix.
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ## @math{y} is a @math{t} by @math{p} matrix, @math{x} is a @math{t} by
 ## @math{k} matrix, @math{b} is a @math{k} by @math{p} matrix, @math{e}
 ## is a @math{t} by @math{p} matrix, and @math{o} is a @math{t p} by
 ## @math{t p} matrix.
-## @end ifinfo
+## @end ifnottex
 ##
 ## @noindent
 ## Each row of @var{y} and @var{x} is an observation and each column a
 ## variable.  The return values @var{beta}, @var{v}, and @var{r} are
 ## defined as follows.
 ##
 ## @table @var
 ## @item beta
diff --git a/scripts/statistics/base/kendall.m b/scripts/statistics/base/kendall.m
--- a/scripts/statistics/base/kendall.m
+++ b/scripts/statistics/base/kendall.m
@@ -33,34 +33,34 @@
 ## differences of @var{x} and @var{y};  i.e., if both @var{x} and
 ## @var{y} have distinct entries, then
 ##
 ## @iftex
 ## @tex
 ## $$ \tau = {1 \over n(n-1)} \sum_{i,j} {\rm sign}(q_i-q_j) {\rm sign}(r_i-r_j) $$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ## @example
 ##          1    
 ## tau = -------   SUM sign (q(i) - q(j)) * sign (r(i) - r(j))
 ##       n (n-1)   i,j
 ## @end example
-## @end ifinfo
+## @end ifnottex
 ##
 ## @noindent
 ## in which the
 ## @iftex
 ## @tex
 ## $q_i$ and $r_i$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ## @var{q}(@var{i}) and @var{r}(@var{i})
-## @end ifinfo
+## @end ifnottex
 ##  are the ranks of
 ## @var{x} and @var{y}, respectively.
 ##
 ## If @var{x} and @var{y} are drawn from independent distributions,
 ## Kendall's @var{tau} is asymptotically normal with mean 0 and variance
 ## @iftex
 ## @tex
 ## ${2 (2n+5) \over 9n(n-1)}$.
diff --git a/scripts/statistics/base/kurtosis.m b/scripts/statistics/base/kurtosis.m
--- a/scripts/statistics/base/kurtosis.m
+++ b/scripts/statistics/base/kurtosis.m
@@ -23,22 +23,22 @@
 ## @iftex
 ## @tex
 ## $$
 ##  {\rm kurtosis} (x) = {1\over N \sigma(x)^4} \sum_{i=1}^N (x_i-\bar{x})^4 - 3
 ## $$
 ## where $\bar{x}$ is the mean value of $x$.
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##
 ## @example
 ## kurtosis (x) = N^(-1) std(x)^(-4) sum ((x - mean(x)).^4) - 3
 ## @end example
-## @end ifinfo
+## @end ifnottex
 ##
 ## @noindent
 ## of @var{x}.  If @var{x} is a matrix, return the kurtosis over the
 ## first non-singleton dimension. The optional argument @var{dim}
 ## can be given to force the kurtosis to be given over that 
 ## dimension.
 ## @end deftypefn
 
diff --git a/scripts/statistics/base/mean.m b/scripts/statistics/base/mean.m
--- a/scripts/statistics/base/mean.m
+++ b/scripts/statistics/base/mean.m
@@ -20,22 +20,22 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} mean (@var{x}, @var{dim}, @var{opt})
 ## If @var{x} is a vector, compute the mean of the elements of @var{x}
 ## @iftex
 ## @tex
 ## $$ {\rm mean}(x) = \bar{x} = {1\over N} \sum_{i=1}^N x_i $$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##
 ## @example
 ## mean (x) = SUM_i x(i) / N
 ## @end example
-## @end ifinfo
+## @end ifnottex
 ## If @var{x} is a matrix, compute the mean for each column and return them
 ## in a row vector.
 ##
 ## With the optional argument @var{opt}, the kind of mean computed can be
 ## selected.  The following options are recognized:
 ##
 ## @table @code
 ## @item "a"
diff --git a/scripts/statistics/base/median.m b/scripts/statistics/base/median.m
--- a/scripts/statistics/base/median.m
+++ b/scripts/statistics/base/median.m
@@ -26,26 +26,26 @@
 ## @tex
 ## $$
 ## {\rm median} (x) =
 ##   \cases{x(\lceil N/2\rceil), & $N$ odd;\cr
 ##           (x(N/2)+x(N/2+1))/2, & $N$ even.}
 ## $$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##
 ## @example
 ## @group
 ##             x(ceil(N/2)),             N odd
 ## median(x) =
 ##             (x(N/2) + x((N/2)+1))/2,  N even
 ## @end group
 ## @end example
-## @end ifinfo
+## @end ifnottex
 ## If @var{x} is a matrix, compute the median value for each
 ## column and return them in a row vector. If the optional @var{dim}
 ## argument is given, operate along this dimension.
 ## @seealso{std, mean}
 ## @end deftypefn
 
 ## Author: jwe
 
diff --git a/scripts/statistics/base/ols.m b/scripts/statistics/base/ols.m
--- a/scripts/statistics/base/ols.m
+++ b/scripts/statistics/base/ols.m
@@ -22,32 +22,32 @@
 ## Ordinary least squares estimation for the multivariate model
 ## @iftex
 ## @tex
 ## $y = x b + e$
 ## with
 ## $\bar{e} = 0$, and cov(vec($e$)) = kron ($s, I$)
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ## @math{y = x b + e} with
 ## @math{mean (e) = 0} and @math{cov (vec (e)) = kron (s, I)}.
-## @end ifinfo
+## @end ifnottex
 ##  where
 ## @iftex
 ## @tex
 ## $y$ is a $t \times p$ matrix, $x$ is a $t \times k$ matrix,
 ## $b$ is a $k \times p$ matrix, and $e$ is a $t \times p$ matrix.
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ## @math{y} is a @math{t} by @math{p} matrix, @math{x} is a @math{t} by
 ## @math{k} matrix, @math{b} is a @math{k} by @math{p} matrix, and
 ## @math{e} is a @math{t} by @math{p} matrix.
-## @end ifinfo
+## @end ifnottex
 ##
 ## Each row of @var{y} and @var{x} is an observation and each column a
 ## variable.
 ##
 ## The return values @var{beta}, @var{sigma}, and @var{r} are defined as
 ## follows.
 ##
 ## @table @var
diff --git a/scripts/statistics/base/skewness.m b/scripts/statistics/base/skewness.m
--- a/scripts/statistics/base/skewness.m
+++ b/scripts/statistics/base/skewness.m
@@ -23,22 +23,22 @@
 ## @iftex
 ## @tex
 ## $$
 ## {\rm skewness} (x) = {1\over N \sigma(x)^3} \sum_{i=1}^N (x_i-\bar{x})^3
 ## $$
 ## where $\bar{x}$ is the mean value of $x$.
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ##
 ## @example
 ## skewness (x) = N^(-1) std(x)^(-3) sum ((x - mean(x)).^3)
 ## @end example
-## @end ifinfo
+## @end ifnottex
 ##
 ## @noindent
 ## of @var{x}.  If @var{x} is a matrix, return the skewness along the
 ## first non-singleton dimension of the matrix. If the optional
 ## @var{dim} argument is given, operate along this dimension.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
diff --git a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
--- a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
+++ b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
@@ -20,23 +20,23 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} kolmogorov_smirnov_cdf (@var{x}, @var{tol})
 ## Return the CDF at @var{x} of the Kolmogorov-Smirnov distribution,
 ## @iftex
 ## @tex
 ## $$ Q(x) = \sum_{k=-\infty}^\infty (-1)^k \exp(-2 k^2 x^2) $$
 ## @end tex
 ## @end iftex
-## @ifinfo
+## @ifnottex
 ## @example
 ##          Inf
 ## Q(x) =   SUM    (-1)^k exp(-2 k^2 x^2)
 ##        k = -Inf
 ## @end example
-## @end ifinfo
+## @end ifnottex
 ##
 ## @noindent
 ## for @var{x} > 0.
 ##
 ## The optional parameter @var{tol} specifies the precision up to which
 ## the series should be evaluated;  the default is @var{tol} = @code{eps}.
 ## @end deftypefn
 
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,20 @@
+2009-01-14  Søren Hauberg  <hauberg@gmail.com>
+
+	* DLD-FUNCTIONS/betainc.cc, DLD-FUNCTIONS/chol.cc,
+	DLD-FUNCTIONS/daspk.cc, DLD-FUNCTIONS/dasrt.cc,
+	DLD-FUNCTIONS/dassl.cc, DLD-FUNCTIONS/filter.cc,
+	DLD-FUNCTIONS/gammainc.cc, DLD-FUNCTIONS/gcd.cc,
+	DLD-FUNCTIONS/givens.cc, DLD-FUNCTIONS/hess.cc,
+	DLD-FUNCTIONS/lsode.cc, DLD-FUNCTIONS/qr.cc, DLD-FUNCTIONS/qz.cc,
+	DLD-FUNCTIONS/schur.cc, DLD-FUNCTIONS/svd.cc,
+	DLD-FUNCTIONS/syl.cc, data.cc, mappers.cc:
+	Use ifnottex instead of ifinfo.
+
 2009-01-14  John W. Eaton  <jwe@octave.org>
 
 	* load-path.cc (load_path::do_set): Call do_clear after disabling
 	add_hook.
 
 2009-01-13  Jaroslav Hajek  <highegg@gmail.com>
 
 	* dirfns.cc (Freadddir): qsort -> sort.
diff --git a/src/DLD-FUNCTIONS/betainc.cc b/src/DLD-FUNCTIONS/betainc.cc
--- a/src/DLD-FUNCTIONS/betainc.cc
+++ b/src/DLD-FUNCTIONS/betainc.cc
@@ -38,26 +38,26 @@ DEFUN_DLD (betainc, args, ,
 Return the incomplete Beta function,\n\
 @iftex\n\
 @tex\n\
 $$\n\
  \\beta (x, a, b) = B (a, b)^{-1} \\int_0^x t^{(a-z)} (1-t)^{(b-1)} dt.\n\
 $$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 \n\
 @smallexample\n\
                                       x\n\
                                      /\n\
 betainc (x, a, b) = beta (a, b)^(-1) | t^(a-1) (1-t)^(b-1) dt.\n\
                                      /\n\
                                   t=0\n\
 @end smallexample\n\
-@end ifinfo\n\
+@end ifnottex\n\
 \n\
 If x has more than one component, both @var{a} and @var{b} must be\n\
 scalars.  If @var{x} is a scalar, @var{a} and @var{b} must be of\n\
 compatible dimensions.\n\
 @end deftypefn")
 {
   octave_value retval;
 
diff --git a/src/DLD-FUNCTIONS/chol.cc b/src/DLD-FUNCTIONS/chol.cc
--- a/src/DLD-FUNCTIONS/chol.cc
+++ b/src/DLD-FUNCTIONS/chol.cc
@@ -56,72 +56,72 @@ DEFUN_DLD (chol, args, nargout,
 @cindex Cholesky factorization\n\
 Compute the Cholesky factor, @var{r}, of the symmetric positive definite\n\
 matrix @var{a}, where\n\
 @iftex\n\
 @tex\n\
 $ R^T R = A $.\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 \n\
 @example\n\
 @var{r}' * @var{r} = @var{a}.\n\
 @end example\n\
-@end ifinfo\n\
+@end ifnottex\n\
 \n\
 Called with one output argument @code{chol} fails if @var{a} or @var{s} is\n\
 not positive definite. With two or more output arguments @var{p} flags\n\
 whether the matrix was positive definite and @code{chol} does not fail. A\n\
 zero value indicated that the matrix was positive definite and the @var{r}\n\
 gives the factorization, annd @var{p} will have a positive value otherwise.\n\
 \n\
 If called with 3 outputs then a sparsity preserving row/column permutation\n\
 is applied to @var{a} prior to the factorization. That is @var{r}\n\
 is the factorization of @code{@var{a}(@var{q},@var{q})} such that\n\
 @iftex\n\
 @tex\n\
 $ R^T R = Q^T A Q$.\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 \n\
 @example\n\
 @var{r}' * @var{r} = @var{q}' * @var{a} * @var{q}.\n\
 @end example\n\
-@end ifinfo\n\
+@end ifnottex\n\
 \n\
 The sparsity preserving permutation is generally returned as a matrix.\n\
 However, given the flag 'vector', @var{q} will be returned as a vector\n\
 such that\n\
 @iftex\n\
 @tex\n\
 $ R^T R = A (Q, Q)$.\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 \n\
 @example\n\
 @var{r}' * @var{r} = a (@var{q}, @var{q}).\n\
 @end example\n\
-@end ifinfo\n\
+@end ifnottex\n\
 \n\
 Called with either a sparse or full matrix and uing the 'lower' flag,\n\
 @code{chol} returns the lower triangular factorization such that\n\
 @iftex\n\
 @tex\n\
 $ L L^T = A $.\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 \n\
 @example\n\
 @var{l} * @var{l}' = @var{a}.\n\
 @end example\n\
-@end ifinfo\n\
+@end ifnottex\n\
 \n\
 In general the lower trinagular factorization is significantly faster for\n\
 sparse matrices.\n\
 @seealso{cholinv, chol2inv}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
diff --git a/src/DLD-FUNCTIONS/daspk.cc b/src/DLD-FUNCTIONS/daspk.cc
--- a/src/DLD-FUNCTIONS/daspk.cc
+++ b/src/DLD-FUNCTIONS/daspk.cc
@@ -180,29 +180,29 @@ DEFUN_DLD (daspk, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{x}, @var{xdot}, @var{istate}, @var{msg}] =} daspk (@var{fcn}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
 Solve the set of differential-algebraic equations\n\
 @tex\n\
 $$ 0 = f (x, \\dot{x}, t) $$\n\
 with\n\
 $$ x(t_0) = x_0, \\dot{x}(t_0) = \\dot{x}_0 $$\n\
 @end tex\n\
-@ifinfo\n\
+@ifnottex\n\
 \n\
 @example\n\
 0 = f (x, xdot, t)\n\
 @end example\n\
 \n\
 with\n\
 \n\
 @example\n\
 x(t_0) = x_0, xdot(t_0) = xdot_0\n\
 @end example\n\
 \n\
-@end ifinfo\n\
+@end ifnottex\n\
 The solution is returned in the matrices @var{x} and @var{xdot},\n\
 with each row in the result matrices corresponding to one of the\n\
 elements in the vector @var{t}.  The first element of @var{t}\n\
 should be @math{t_0} and correspond to the initial state of the\n\
 system @var{x_0} and its derivative @var{xdot_0}, so that the first\n\
 row of the output @var{x} is @var{x_0} and the first row\n\
 of the output @var{xdot} is @var{xdot_0}.\n\
 \n\
@@ -223,24 +223,24 @@ If @var{fcn} is a two-element string arr
 the function @math{f} described above, and the second element names\n\
 a function to compute the modified Jacobian\n\
 @tex\n\
 $$\n\
 J = {\\partial f \\over \\partial x}\n\
   + c {\\partial f \\over \\partial \\dot{x}}\n\
 $$\n\
 @end tex\n\
-@ifinfo\n\
+@ifnottex\n\
 \n\
 @example\n\
       df       df\n\
 jac = -- + c ------\n\
       dx     d xdot\n\
 @end example\n\
-@end ifinfo\n\
+@end ifnottex\n\
 \n\
 The modified Jacobian function must have the form\n\
 \n\
 @example\n\
 \n\
 @var{jac} = j (@var{x}, @var{xdot}, @var{t}, @var{c})\n\
 \n\
 @end example\n\
diff --git a/src/DLD-FUNCTIONS/dasrt.cc b/src/DLD-FUNCTIONS/dasrt.cc
--- a/src/DLD-FUNCTIONS/dasrt.cc
+++ b/src/DLD-FUNCTIONS/dasrt.cc
@@ -215,29 +215,29 @@ DEFUN_DLD (dasrt, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{x}, @var{xdot}, @var{t_out}, @var{istat}, @var{msg}] =} dasrt (@var{fcn} [, @var{g}], @var{x_0}, @var{xdot_0}, @var{t} [, @var{t_crit}])\n\
 Solve the set of differential-algebraic equations\n\
 @tex\n\
 $$ 0 = f (x, \\dot{x}, t) $$\n\
 with\n\
 $$ x(t_0) = x_0, \\dot{x}(t_0) = \\dot{x}_0 $$\n\
 @end tex\n\
-@ifinfo\n\
+@ifnottex\n\
 \n\
 @example\n\
 0 = f (x, xdot, t)\n\
 @end example\n\
 \n\
 with\n\
 \n\
 @example\n\
 x(t_0) = x_0, xdot(t_0) = xdot_0\n\
 @end example\n\
 \n\
-@end ifinfo\n\
+@end ifnottex\n\
 with functional stopping criteria (root solving).\n\
 \n\
 The solution is returned in the matrices @var{x} and @var{xdot},\n\
 with each row in the result matrices corresponding to one of the\n\
 elements in the vector @var{t_out}.  The first element of @var{t}\n\
 should be @math{t_0} and correspond to the initial state of the\n\
 system @var{x_0} and its derivative @var{xdot_0}, so that the first\n\
 row of the output @var{x} is @var{x_0} and the first row\n\
@@ -266,25 +266,25 @@ the first element names the function @ma
 second element names a function to compute the modified Jacobian\n\
 \n\
 @tex\n\
 $$\n\
 J = {\\partial f \\over \\partial x}\n\
   + c {\\partial f \\over \\partial \\dot{x}}\n\
 $$\n\
 @end tex\n\
-@ifinfo\n\
+@ifnottex\n\
 \n\
 @example\n\
       df       df\n\
 jac = -- + c ------\n\
       dx     d xdot\n\
 @end example\n\
 \n\
-@end ifinfo\n\
+@end ifnottex\n\
 \n\
 The modified Jacobian function must have the form\n\
 \n\
 @example\n\
 \n\
 @var{jac} = j (@var{x}, @var{xdot}, @var{t}, @var{c})\n\
 \n\
 @end example\n\
diff --git a/src/DLD-FUNCTIONS/dassl.cc b/src/DLD-FUNCTIONS/dassl.cc
--- a/src/DLD-FUNCTIONS/dassl.cc
+++ b/src/DLD-FUNCTIONS/dassl.cc
@@ -182,30 +182,30 @@ DEFUN_DLD (dassl, args, nargout,
 Solve the set of differential-algebraic equations\n\
 @iftex\n\
 @tex\n\
 $$ 0 = f (x, \\dot{x}, t) $$\n\
 with\n\
 $$ x(t_0) = x_0, \\dot{x}(t_0) = \\dot{x}_0 $$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 \n\
 @example\n\
 0 = f (x, xdot, t)\n\
 @end example\n\
 \n\
 @noindent\n\
 with\n\
 \n\
 @example\n\
 x(t_0) = x_0, xdot(t_0) = xdot_0\n\
 @end example\n\
 \n\
-@end ifinfo\n\
+@end ifnottex\n\
 The solution is returned in the matrices @var{x} and @var{xdot},\n\
 with each row in the result matrices corresponding to one of the\n\
 elements in the vector @var{t}.  The first element of @var{t}\n\
 should be @math{t_0} and correspond to the initial state of the\n\
 system @var{x_0} and its derivative @var{xdot_0}, so that the first\n\
 row of the output @var{x} is @var{x_0} and the first row\n\
 of the output @var{xdot} is @var{xdot_0}.\n\
 \n\
@@ -229,23 +229,23 @@ a function to compute the modified Jacob
 @iftex\n\
 @tex\n\
 $$\n\
 J = {\\partial f \\over \\partial x}\n\
   + c {\\partial f \\over \\partial \\dot{x}}\n\
 $$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @example\n\
       df       df\n\
 jac = -- + c ------\n\
       dx     d xdot\n\
 @end example\n\
-@end ifinfo\n\
+@end ifnottex\n\
 \n\
 The modified Jacobian function must have the form\n\
 \n\
 @example\n\
 \n\
 @var{jac} = j (@var{x}, @var{xdot}, @var{t}, @var{c})\n\
 \n\
 @end example\n\
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -289,59 +289,59 @@ equation:\n\
 @iftex\n\
 @tex\n\
 $$\n\
 \\sum_{k=0}^N a_{k+1} y_{n-k} = \\sum_{k=0}^M b_{k+1} x_{n-k}, \\qquad\n\
  1 \\le n \\le P\n\
 $$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 \n\
 @smallexample\n\
    N                   M\n\
   SUM a(k+1) y(n-k) = SUM b(k+1) x(n-k)      for 1<=n<=length(x)\n\
   k=0                 k=0\n\
 @end smallexample\n\
-@end ifinfo\n\
+@end ifnottex\n\
 \n\
 @noindent\n\
 where\n\
-@ifinfo\n\
+@ifnottex\n\
  N=length(a)-1 and M=length(b)-1.\n\
-@end ifinfo\n\
+@end ifnottex\n\
 @iftex\n\
 @tex\n\
  $a \\in \\Re^{N-1}$, $b \\in \\Re^{M-1}$, and $x \\in \\Re^P$.\n\
 @end tex\n\
 @end iftex\n\
 over the first non-singleton dimension of @var{x} or over @var{dim} if\n\
 supplied. An equivalent form of this equation is:\n\
 @iftex\n\
 @tex\n\
 $$\n\
 y_n = -\\sum_{k=1}^N c_{k+1} y_{n-k} + \\sum_{k=0}^M d_{k+1} x_{n-k}, \\qquad\n\
  1 \\le n \\le P\n\
 $$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 \n\
 @smallexample\n\
             N                   M\n\
   y(n) = - SUM c(k+1) y(n-k) + SUM d(k+1) x(n-k)  for 1<=n<=length(x)\n\
            k=1                 k=0\n\
 @end smallexample\n\
-@end ifinfo\n\
+@end ifnottex\n\
 \n\
 @noindent\n\
 where\n\
-@ifinfo\n\
+@ifnottex\n\
  c = a/a(1) and d = b/a(1).\n\
-@end ifinfo\n\
+@end ifnottex\n\
 @iftex\n\
 @tex\n\
 $c = a/a_1$ and $d = b/a_1$.\n\
 @end tex\n\
 @end iftex\n\
 \n\
 If the fourth argument @var{si} is provided, it is taken as the\n\
 initial state of the system and the final state is returned as\n\
@@ -356,28 +356,28 @@ system function:\n\
 @iftex\n\
 @tex\n\
 $$\n\
 H(z) = {\\displaystyle\\sum_{k=0}^M d_{k+1} z^{-k}\n\
         \\over 1 + \\displaystyle\\sum_{k+1}^N c_{k+1} z^{-k}}\n\
 $$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 \n\
 @example\n\
              M\n\
             SUM d(k+1) z^(-k)\n\
             k=0\n\
   H(z) = ----------------------\n\
                N\n\
           1 + SUM c(k+1) z^(-k)\n\
               k=1\n\
 @end example\n\
-@end ifinfo\n\
+@end ifnottex\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin  = args.length ();
 
   if (nargin < 3 || nargin > 5)
     {
diff --git a/src/DLD-FUNCTIONS/gammainc.cc b/src/DLD-FUNCTIONS/gammainc.cc
--- a/src/DLD-FUNCTIONS/gammainc.cc
+++ b/src/DLD-FUNCTIONS/gammainc.cc
@@ -38,27 +38,27 @@ DEFUN_DLD (gammainc, args, ,
 Compute the normalized incomplete gamma function,\n\
 @iftex\n\
 @tex\n\
 $$\n\
  \\gamma (x, a) = {\\displaystyle\\int_0^x e^{-t} t^{a-1} dt \\over \\Gamma (a)}\n\
 $$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 \n\
 @smallexample\n\
                                 x\n\
                       1        /\n\
 gammainc (x, a) = ---------    | exp (-t) t^(a-1) dt\n\
                   gamma (a)    /\n\
                             t=0\n\
 @end smallexample\n\
 \n\
-@end ifinfo\n\
+@end ifnottex\n\
 with the limiting value of 1 as @var{x} approaches infinity.\n\
 The standard notation is @math{P(a,x)}, e.g. Abramowitz and Stegun (6.5.1).\n\
 \n\
 If @var{a} is scalar, then @code{gammainc (@var{x}, @var{a})} is returned\n\
 for each element of @var{x} and vice versa.\n\
 \n\
 If neither @var{x} nor @var{a} is scalar, the sizes of @var{x} and\n\
 @var{a} must agree, and @var{gammainc} is applied element-by-element.\n\
diff --git a/src/DLD-FUNCTIONS/gcd.cc b/src/DLD-FUNCTIONS/gcd.cc
--- a/src/DLD-FUNCTIONS/gcd.cc
+++ b/src/DLD-FUNCTIONS/gcd.cc
@@ -75,21 +75,21 @@ and\n\
 gcd ([15, 9], [20 18])\n\
     @result{}  5  9\n\
 @end group\n\
 @end example\n\
 \n\
 Optional return arguments @var{v1}, etc, contain integer vectors such\n\
 that,\n\
 \n\
-@ifinfo\n\
+@ifnottex\n\
 @example\n\
 @var{g} = @var{v1} .* @var{a1} + @var{v2} .* @var{a2} + @dots{}\n\
 @end example\n\
-@end ifinfo\n\
+@end ifnottex\n\
 @iftex\n\
 @tex\n\
 $g = v_1 a_1 + v_2 a_2 + \\cdots$\n\
 @end tex\n\
 @end iftex\n\
 \n\
 For backward compatibility with previous versions of this function, when\n\
 all arguments are scalar, a single return argument @var{v1} containing\n\
diff --git a/src/DLD-FUNCTIONS/givens.cc b/src/DLD-FUNCTIONS/givens.cc
--- a/src/DLD-FUNCTIONS/givens.cc
+++ b/src/DLD-FUNCTIONS/givens.cc
@@ -42,21 +42,21 @@ Return a $2\\times 2$ orthogonal matrix\
 $$\n\
 such that\n\
 $$\n\
  G \\left[\\matrix{x\\cr y}\\right] = \\left[\\matrix{\\ast\\cr 0}\\right]\n\
 $$\n\
 with $x$ and $y$ scalars.\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 Return a 2 by 2 orthogonal matrix\n\
 @code{@var{g} = [@var{c} @var{s}; -@var{s}' @var{c}]} such that\n\
 @code{@var{g} [@var{x}; @var{y}] = [*; 0]} with @var{x} and @var{y} scalars.\n\
-@end ifinfo\n\
+@end ifnottex\n\
 \n\
 For example,\n\
 \n\
 @example\n\
 @group\n\
 givens (1, 1)\n\
      @result{}   0.70711   0.70711\n\
          -0.70711   0.70711\n\
diff --git a/src/DLD-FUNCTIONS/hess.cc b/src/DLD-FUNCTIONS/hess.cc
--- a/src/DLD-FUNCTIONS/hess.cc
+++ b/src/DLD-FUNCTIONS/hess.cc
@@ -51,21 +51,21 @@ Hessenberg decomposition is\n\
 @tex\n\
 $$\n\
 A = PHP^T\n\
 $$\n\
 where $P$ is a square unitary matrix ($P^HP = I$), and $H$\n\
 is upper Hessenberg ($H_{i,j} = 0, \\forall i \\ge j+1$).\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @code{p * h * p' = a} where @code{p} is a square unitary matrix\n\
 (@code{p' * p = I}, using complex-conjugate transposition) and @code{h}\n\
 is upper Hessenberg (@code{i >= j+1 => h (i, j) = 0}).\n\
-@end ifinfo\n\
+@end ifnottex\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 || nargout > 2)
     {
diff --git a/src/DLD-FUNCTIONS/lsode.cc b/src/DLD-FUNCTIONS/lsode.cc
--- a/src/DLD-FUNCTIONS/lsode.cc
+++ b/src/DLD-FUNCTIONS/lsode.cc
@@ -166,31 +166,31 @@ DEFUN_DLD (lsode, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{x}, @var{istate}, @var{msg}] =} lsode (@var{fcn}, @var{x_0}, @var{t}, @var{t_crit})\n\
 Solve the set of differential equations\n\
 @tex\n\
 $$ {dx \\over dt} = f (x, t) $$\n\
 with\n\
 $$ x(t_0) = x_0 $$\n\
 @end tex\n\
-@ifinfo\n\
+@ifnottex\n\
 \n\
 @example\n\
 dx\n\
 -- = f(x, t)\n\
 dt\n\
 @end example\n\
 \n\
 with\n\
 \n\
 @example\n\
 x(t_0) = x_0\n\
 @end example\n\
 \n\
-@end ifinfo\n\
+@end ifnottex\n\
 The solution is returned in the matrix @var{x}, with each row\n\
 corresponding to an element of the vector @var{t}.  The first element\n\
 of @var{t} should be @math{t_0} and should correspond to the initial\n\
 state of the system @var{x_0}, so that the first row of the output\n\
 is @var{x_0}.\n\
 \n\
 The first argument, @var{fcn}, is a string, or cell array of strings,\n\
 inline or function handles, that names the function to call to compute\n\
@@ -225,17 +225,17 @@ in which @var{jac} is the matrix of part
   & \\cdots\n\
   & {\\partial f_2 \\over \\partial x_N} \\cr\n\
  \\vdots & \\vdots & \\ddots & \\vdots \\cr\n\
 {\\partial f_3 \\over \\partial x_1}\n\
   & {\\partial f_3 \\over \\partial x_2}\n\
   & \\cdots\n\
   & {\\partial f_3 \\over \\partial x_N} \\cr}\\right]$$\n\
 @end tex\n\
-@ifinfo\n\
+@ifnottex\n\
 \n\
 @example\n\
              | df_1  df_1       df_1 |\n\
              | ----  ----  ...  ---- |\n\
              | dx_1  dx_2       dx_N |\n\
              |                       |\n\
              | df_2  df_2       df_2 |\n\
              | ----  ----  ...  ---- |\n\
@@ -245,17 +245,17 @@ jac = ---- = |                       |\n
              |  .    .      .   .    |\n\
              |  .    .       .  .    |\n\
              |                       |\n\
              | df_N  df_N       df_N |\n\
              | ----  ----  ...  ---- |\n\
              | dx_1  dx_2       dx_N |\n\
 @end example\n\
 \n\
-@end ifinfo\n\
+@end ifnottex\n\
 \n\
 The second and third arguments specify the initial state of the system,\n\
 @math{x_0}, and the initial value of the independent variable @math{t_0}.\n\
 \n\
 The fourth argument is optional, and may be used to specify a set of\n\
 times that the ODE solver should not integrate past.  It is useful for\n\
 avoiding difficulties with singularities and points where there is a\n\
 discontinuity in the derivative.\n\
diff --git a/src/DLD-FUNCTIONS/qr.cc b/src/DLD-FUNCTIONS/qr.cc
--- a/src/DLD-FUNCTIONS/qr.cc
+++ b/src/DLD-FUNCTIONS/qr.cc
@@ -94,42 +94,42 @@ The @code{qr} factorization has applicat
 squares problems\n\
 @iftex\n\
 @tex\n\
 $$\n\
 \\min_x \\left\\Vert A x - b \\right\\Vert_2\n\
 $$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 \n\
 @example\n\
 @code{min norm(A x - b)}\n\
 @end example\n\
 \n\
-@end ifinfo\n\
+@end ifnottex\n\
 for overdetermined systems of equations (i.e.,\n\
 @iftex\n\
 @tex\n\
 $A$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @code{a}\n\
-@end ifinfo\n\
+@end ifnottex\n\
  is a tall, thin matrix).  The QR factorization is\n\
 @iftex\n\
 @tex\n\
 $QR = A$ where $Q$ is an orthogonal matrix and $R$ is upper triangular.\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @code{q * r = a} where @code{q} is an orthogonal matrix and @code{r} is\n\
 upper triangular.\n\
-@end ifinfo\n\
+@end ifnottex\n\
 \n\
 If given a second argument of '0', @code{qr} returns an economy-sized\n\
 QR factorization, omitting zero rows of @var{R} and the corresponding\n\
 columns of @var{Q}.\n\
 \n\
 If the matrix @var{a} is full, the permuted QR factorization\n\
 @code{[@var{q}, @var{r}, @var{p}] = qr (@var{a})} forms the QR factorization\n\
 such that the diagonal entries of @code{r} are decreasing in magnitude\n\
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -213,42 +213,42 @@ Generalized eigenvalue problem @math{A x
 @item @code{lambda = qz(A,B)}\n\
 \n\
 Computes the generalized eigenvalues\n\
 @iftex\n\
 @tex\n\
 $\\lambda$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @var{lambda}\n\
-@end ifinfo\n\
+@end ifnottex\n\
 of @math{(A - s B)}.\n\
 @item @code{[AA, BB, Q, Z, V, W, lambda] = qz (A, B)}\n\
 \n\
 Computes qz decomposition, generalized eigenvectors, and \n\
 generalized eigenvalues of @math{(A - sB)}\n\
 @iftex\n\
 @tex\n\
 $$ AV = BV{ \\rm diag }(\\lambda) $$\n\
 $$ W^T A = { \\rm diag }(\\lambda)W^T B $$\n\
 $$ AA = Q^T AZ, BB = Q^T BZ $$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @example\n\
 @group\n\
 \n\
     A*V = B*V*diag(lambda)\n\
     W'*A = diag(lambda)*W'*B\n\
     AA = Q'*A*Z, BB = Q'*B*Z\n\
 \n\
 @end group\n\
 @end example\n\
-@end ifinfo\n\
+@end ifnottex\n\
 with @var{Q} and @var{Z} orthogonal (unitary)= @var{I}\n\
 \n\
 @item @code{[AA,BB,Z@{, lambda@}] = qz(A,B,opt)}\n\
 \n\
 As in form [2], but allows ordering of generalized eigenpairs\n\
 for (e.g.) solution of discrete time algebraic Riccati equations.\n\
 Form 3 is not available for complex matrices, and does not compute\n\
 the generalized eigenvectors @var{V}, @var{W}, nor the orthogonal matrix @var{Q}.\n\
diff --git a/src/DLD-FUNCTIONS/schur.cc b/src/DLD-FUNCTIONS/schur.cc
--- a/src/DLD-FUNCTIONS/schur.cc
+++ b/src/DLD-FUNCTIONS/schur.cc
@@ -47,208 +47,208 @@ The Schur decomposition is used to compu
 square matrix, and has applications in the solution of algebraic\n\
 Riccati equations in control (see @code{are} and @code{dare}).\n\
 @code{schur} always returns\n\
 @iftex\n\
 @tex\n\
 $S = U^T A U$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @code{s = u' * a * u}\n\
-@end ifinfo\n\
+@end ifnottex\n\
 where\n\
 @iftex\n\
 @tex\n\
 $U$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @code{u}\n\
-@end ifinfo\n\
+@end ifnottex\n\
  is a unitary matrix\n\
 @iftex\n\
 @tex\n\
 ($U^T U$ is identity)\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 (@code{u'* u} is identity)\n\
-@end ifinfo\n\
+@end ifnottex\n\
 and\n\
 @iftex\n\
 @tex\n\
 $S$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @code{s}\n\
-@end ifinfo\n\
+@end ifnottex\n\
 is upper triangular.  The eigenvalues of\n\
 @iftex\n\
 @tex\n\
 $A$ (and $S$)\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @code{a} (and @code{s})\n\
-@end ifinfo\n\
+@end ifnottex\n\
 are the diagonal elements of\n\
 @iftex\n\
 @tex\n\
 $S$.\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @code{s}.\n\
-@end ifinfo\n\
+@end ifnottex\n\
 If the matrix\n\
 @iftex\n\
 @tex\n\
 $A$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @code{a}\n\
-@end ifinfo\n\
+@end ifnottex\n\
 is real, then the real Schur decomposition is computed, in which the\n\
 matrix\n\
 @iftex\n\
 @tex\n\
 $U$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @code{u}\n\
-@end ifinfo\n\
+@end ifnottex\n\
 is orthogonal and\n\
 @iftex\n\
 @tex\n\
 $S$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @code{s}\n\
-@end ifinfo\n\
+@end ifnottex\n\
 is block upper triangular\n\
 with blocks of size at most\n\
 @iftex\n\
 @tex\n\
 $2\\times 2$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @code{2 x 2}\n\
-@end ifinfo\n\
+@end ifnottex\n\
 along the diagonal.  The diagonal elements of\n\
 @iftex\n\
 @tex\n\
 $S$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @code{s}\n\
-@end ifinfo\n\
+@end ifnottex\n\
 (or the eigenvalues of the\n\
 @iftex\n\
 @tex\n\
 $2\\times 2$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @code{2 x 2}\n\
-@end ifinfo\n\
+@end ifnottex\n\
 blocks, when\n\
 appropriate) are the eigenvalues of\n\
 @iftex\n\
 @tex\n\
 $A$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @code{a}\n\
-@end ifinfo\n\
+@end ifnottex\n\
 and\n\
 @iftex\n\
 @tex\n\
 $S$.\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @code{s}.\n\
-@end ifinfo\n\
+@end ifnottex\n\
 \n\
 The eigenvalues are optionally ordered along the diagonal according to\n\
 the value of @code{opt}.  @code{opt = \"a\"} indicates that all\n\
 eigenvalues with negative real parts should be moved to the leading\n\
 block of\n\
 @iftex\n\
 @tex\n\
 $S$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @code{s}\n\
-@end ifinfo\n\
+@end ifnottex\n\
 (used in @code{are}), @code{opt = \"d\"} indicates that all eigenvalues\n\
 with magnitude less than one should be moved to the leading block of\n\
 @iftex\n\
 @tex\n\
 $S$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @code{s}\n\
-@end ifinfo\n\
+@end ifnottex\n\
 (used in @code{dare}), and @code{opt = \"u\"}, the default, indicates that\n\
 no ordering of eigenvalues should occur.  The leading\n\
 @iftex\n\
 @tex\n\
 $k$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @code{k}\n\
-@end ifinfo\n\
+@end ifnottex\n\
 columns of\n\
 @iftex\n\
 @tex\n\
 $U$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @code{u}\n\
-@end ifinfo\n\
+@end ifnottex\n\
 always span the\n\
 @iftex\n\
 @tex\n\
 $A$-invariant\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @code{a}-invariant\n\
-@end ifinfo\n\
+@end ifnottex\n\
 subspace corresponding to the\n\
 @iftex\n\
 @tex\n\
 $k$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @code{k}\n\
-@end ifinfo\n\
+@end ifnottex\n\
 leading eigenvalues of\n\
 @iftex\n\
 @tex\n\
 $S$.\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @code{s}.\n\
-@end ifinfo\n\
+@end ifnottex\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2 || nargout > 2)
     {
diff --git a/src/DLD-FUNCTIONS/svd.cc b/src/DLD-FUNCTIONS/svd.cc
--- a/src/DLD-FUNCTIONS/svd.cc
+++ b/src/DLD-FUNCTIONS/svd.cc
@@ -45,33 +45,33 @@ DEFUN_DLD (svd, args, nargout,
 Compute the singular value decomposition of @var{a}\n\
 @iftex\n\
 @tex\n\
 $$\n\
  A = U S V^H\n\
 $$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 \n\
 @example\n\
 A = U*S*V'\n\
 @end example\n\
-@end ifinfo\n\
+@end ifnottex\n\
 \n\
 The function @code{svd} normally returns the vector of singular values.\n\
 If asked for three return values, it computes\n\
 @iftex\n\
 @tex\n\
 $U$, $S$, and $V$.\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 U, S, and V.\n\
-@end ifinfo\n\
+@end ifnottex\n\
 For example,\n\
 \n\
 @example\n\
 svd (hilb (3))\n\
 @end example\n\
 \n\
 @noindent\n\
 returns\n\
diff --git a/src/DLD-FUNCTIONS/syl.cc b/src/DLD-FUNCTIONS/syl.cc
--- a/src/DLD-FUNCTIONS/syl.cc
+++ b/src/DLD-FUNCTIONS/syl.cc
@@ -39,22 +39,22 @@ DEFUN_DLD (syl, args, nargout,
 Solve the Sylvester equation\n\
 @iftex\n\
 @tex\n\
 $$\n\
  A X + X B + C = 0\n\
 $$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 \n\
 @example\n\
 A X + X B + C = 0\n\
 @end example\n\
-@end ifinfo\n\
+@end ifnottex\n\
 using standard @sc{Lapack} subroutines.  For example,\n\
 \n\
 @example\n\
 @group\n\
 syl ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10; 11, 12])\n\
      @result{} [ -0.50000, -0.66667; -0.66667, -0.50000 ]\n\
 @end group\n\
 @end example\n\
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -3663,19 +3663,19 @@ DEFUN (NaN, args, ,
 @deftypefnx {Built-in Function} {} NaN (@dots{}, @var{class})\n\
 Return a matrix or N-dimensional array whose elements are all NaN\n\
 (Not a Number).  The value NaN is the result of an operation like\n\
 @iftex\n\
 @tex\n\
 $0/0$, or $\\infty - \\infty$,\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 0/0, or @samp{Inf - Inf},\n\
-@end ifinfo\n\
+@end ifnottex\n\
 or any operation with a NaN.\n\
 \n\
 Note that NaN always compares not equal to NaN.  This behavior is\n\
 specified by the IEEE standard for floating point arithmetic.  To\n\
 find NaN values, you must use the @code{isnan} function.\n\
 \n\
 The arguments are handled the same as the arguments for @code{eye}.\n\
 The optional argument @var{class} may be either @samp{\"single\"} or\n\
@@ -3714,28 +3714,28 @@ DEFUN (e, args, ,
 @deftypefnx {Built-in Function} {} e (@dots{}, @var{class})\n\
 Return a matrix or N-dimensional array whose elements are all equal\n\
 to the base of natural logarithms.  The constant\n\
 @iftex\n\
 @tex\n\
  $e$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
  @var{e}\n\
-@end ifinfo\n\
+@end ifnottex\n\
  satisfies the equation\n\
 @iftex\n\
 @tex\n\
  $\\log (e) = 1$.\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
  @code{log} (@var{e}) = 1.\n\
-@end ifinfo\n\
+@end ifnottex\n\
 @end deftypefn")
 {
 #if defined (M_E)
   double e_val = M_E;
 #else
   double e_val = exp (1.0);
 #endif
 
@@ -3749,28 +3749,28 @@ DEFUN (eps, args, ,
 @deftypefnx {Built-in Function} {} eps (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} eps (@dots{}, @var{class})\n\
 Return a matrix or N-dimensional array whose elements are all eps,\n\
 the machine precision.  More precisely, @code{eps} is the largest\n\
 relative spacing between any two adjacent numbers in the machine's\n\
 floating point system.  This number is obviously system-dependent.  On\n\
 machines that support 64-bit IEEE floating point arithmetic, @code{eps}\n\
 is approximately\n\
-@ifinfo\n\
+@ifnottex\n\
  2.2204e-16.\n\
-@end ifinfo\n\
+@end ifnottex\n\
 @iftex\n\
 @tex\n\
  $2.2204\\times10^{-16}$.\n\
 @end tex\n\
 @end iftex\n\
 for double precision and\n\
-@ifinfo\n\
+@ifnottex\n\
  1.1921e-07.\n\
-@end ifinfo\n\
+@end ifnottex\n\
 @iftex\n\
 @tex\n\
  $1.1921\\times10^{-7}$.\n\
 @end tex\n\
 @end iftex\n\
 for single precision. Given a single argument @var{x}, return the\n\
 distance between @var{x} and the next largest value.\n\
 @end deftypefn")
@@ -3886,19 +3886,19 @@ DEFUN (realmax, args, ,
 @deftypefn {Built-in Function} {} realmax (@var{x})\n\
 @deftypefnx {Built-in Function} {} realmax (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} realmax (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} realmax (@dots{}, @var{class})\n\
 Return a matrix or N-dimensional array whose elements are all equal\n\
 to the largest floating point number that is representable.  The actual\n\
 value is system-dependent.  On machines that support 64-bit IEEE\n\
 floating point arithmetic, @code{realmax} is approximately\n\
-@ifinfo\n\
+@ifnottex\n\
  1.7977e+308\n\
-@end ifinfo\n\
+@end ifnottex\n\
 @iftex\n\
 @tex\n\
  $1.7977\\times10^{308}$.\n\
 @end tex\n\
 @end iftex\n\
 @seealso{realmin}\n\
 @end deftypefn")
 {
@@ -3910,19 +3910,19 @@ DEFUN (realmin, args, ,
 @deftypefn {Built-in Function} {} realmin (@var{x})\n\
 @deftypefnx {Built-in Function} {} realmin (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} realmin (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} realmin (@dots{}, @var{class})\n\
 Return a matrix or N-dimensional array whose elements are all equal\n\
 to the smallest normalized floating point number that is representable.\n\
 The actual value is system-dependent.  On machines that support\n\
 64-bit IEEE floating point arithmetic, @code{realmin} is approximately\n\
-@ifinfo\n\
+@ifnottex\n\
  2.2251e-308\n\
-@end ifinfo\n\
+@end ifnottex\n\
 @iftex\n\
 @tex\n\
  $2.2251\\times10^{-308}$.\n\
 @end tex\n\
 @end iftex\n\
 @seealso{realmax}\n\
 @end deftypefn")
 {
@@ -3937,19 +3937,19 @@ DEFUN (I, args, ,
 @deftypefnx {Built-in Function} {} I (@dots{}, @var{class})\n\
 Return a matrix or N-dimensional array whose elements are all equal\n\
 to the pure imaginary unit, defined as\n\
 @iftex\n\
 @tex\n\
   $\\sqrt{-1}$.\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
   @code{sqrt (-1)}.\n\
-@end ifinfo\n\
+@end ifnottex\n\
 Since I (also i, J, and j) is a function, you can use the name(s) for\n\
 other purposes.\n\
 @end deftypefn")
 {
   return fill_matrix (args, Complex (0.0, 1.0), "I");
 }
 
 DEFALIAS (i, I);
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -40,19 +40,19 @@ DEFUN (abs, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} abs (@var{z})\n\
 Compute the magnitude of @var{z}, defined as\n\
 @iftex\n\
 @tex\n\
 $|z| = \\sqrt{x^2 + y^2}$.\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 |@var{z}| = @code{sqrt (x^2 + y^2)}.\n\
-@end ifinfo\n\
+@end ifnottex\n\
 \n\
 For example,\n\
 \n\
 @example\n\
 @group\n\
 abs (3 + 4i)\n\
      @result{} 5\n\
 @end group\n\
@@ -175,19 +175,19 @@ DEFUN (arg, args, ,
 @deftypefn {Mapping Function} {} arg (@var{z})\n\
 @deftypefnx {Mapping Function} {} angle (@var{z})\n\
 Compute the argument of @var{z}, defined as\n\
 @iftex\n\
 @tex\n\
 $\\theta = \\tan^{-1}(y/x)$.\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @var{theta} = @code{atan (@var{y}/@var{x})}.\n\
-@end ifinfo\n\
+@end ifnottex\n\
 @noindent\n\
 in radians. \n\
 \n\
 For example,\n\
 \n\
 @example\n\
 @group\n\
 arg (3 + 4i)\n\
@@ -389,19 +389,19 @@ DEFUN (conj, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} conj (@var{z})\n\
 Return the complex conjugate of @var{z}, defined as\n\
 @iftex\n\
 @tex\n\
 $\\bar{z} = x - iy$.\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @code{conj (@var{z})} = @var{x} - @var{i}@var{y}.\n\
-@end ifinfo\n\
+@end ifnottex\n\
 @seealso{real, imag}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).conj ();
   else
     print_usage ();
@@ -502,26 +502,26 @@ DEFUN (erf, args, ,
 Computes the error function,\n\
 @iftex\n\
 @tex\n\
 $$\n\
  {\\rm erf} (z) = {2 \\over \\sqrt{\\pi}}\\int_0^z e^{-t^2} dt\n\
 $$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 \n\
 @smallexample\n\
                          z\n\
                         /\n\
 erf (z) = (2/sqrt (pi)) | e^(-t^2) dt\n\
                         /\n\
                      t=0\n\
 @end smallexample\n\
-@end ifinfo\n\
+@end ifnottex\n\
 @seealso{erfc, erfinv}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).erf ();
   else
     print_usage ();
@@ -563,19 +563,19 @@ DEFUN (erfc, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erfc (@var{z})\n\
 Computes the complementary error function,\n\
 @iftex\n\
 @tex\n\
 $1 - {\\rm erf} (z)$.\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 @code{1 - erf (@var{z})}.\n\
-@end ifinfo\n\
+@end ifnottex\n\
 @seealso{erf, erfinv}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).erfc ();
   else
     print_usage ();
@@ -734,26 +734,26 @@ DEFUN (gamma, args, ,
 Computes the Gamma function,\n\
 @iftex\n\
 @tex\n\
 $$\n\
  \\Gamma (z) = \\int_0^\\infty t^{z-1} e^{-t} dt.\n\
 $$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 \n\
 @example\n\
             infinity\n\
             /\n\
 gamma (z) = | t^(z-1) exp (-t) dt.\n\
             /\n\
          t=0\n\
 @end example\n\
-@end ifinfo\n\
+@end ifnottex\n\
 @seealso{gammainc, lgamma}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).gamma ();
   else
     print_usage ();
@@ -1330,24 +1330,24 @@ DEFUN (sign, args, ,
 Compute the @dfn{signum} function, which is defined as\n\
 @iftex\n\
 @tex\n\
 $$\n\
 {\\rm sign} (@var{x}) = \\cases{1,&$x>0$;\\cr 0,&$x=0$;\\cr -1,&$x<0$.\\cr}\n\
 $$\n\
 @end tex\n\
 @end iftex\n\
-@ifinfo\n\
+@ifnottex\n\
 \n\
 @example\n\
            -1, x < 0;\n\
 sign (x) =  0, x = 0;\n\
             1, x > 0.\n\
 @end example\n\
-@end ifinfo\n\
+@end ifnottex\n\
 \n\
 For complex arguments, @code{sign} returns @code{x ./ abs (@var{x})}.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).signum ();
   else
